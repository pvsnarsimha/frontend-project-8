<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Array Visualizer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
:root {
    --primary-color: #8B4513; /* Rich Brown */
    --secondary-color: #A0522D; /* Sienna Brown */
    --success-color: #228B22; /* Forest Green */
    --danger-color: #DC143C; /* Crimson Red */
    --warning-color: #FF8C00; /* Dark Orange */
    --info-color: #87CEEB; /* Sky Blue */
    --dark-color: #2F4F4F; /* Dark Slate Gray */
    --light-color: #F5F5DC; /* Beige */
}

body {
    background: linear-gradient(135deg, #140ec3bb 0%, #0babd7 100%);
    color: #2F4F4F;
    min-height: 100vh;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.glass-card {
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(10px);
    border-radius: 15px;
    border: 1px solid rgba(139, 69, 19, 0.1);
    box-shadow: 0 8px 32px rgba(139, 69, 19, 0.15);
    padding: 20px;
    margin-bottom: 20px;
}

.array-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: flex-end;
    min-height: 300px;
    padding: 20px;
    margin: 20px 0;
    transition: all 0.5s ease;
    gap: 10px;
}

.array-element {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0 5px 15px 5px;
    transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    transform-origin: bottom;
    flex-shrink: 0;
}

.element-value {
    background: var(--primary-color);
    color: white;
    width: 60px;
    height: 60px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 10px;
    font-weight: bold;
    font-size: 1.2rem;
    box-shadow: 0 4px 15px rgba(139, 69, 19, 0.3);
    transition: all 0.3s ease;
    flex-shrink: 0;
    border: 1px solid rgba(255, 255, 255, 0.5);
}

.element-index {
    margin-top: 10px;
    font-size: 0.8rem;
    color: var(--secondary-color);
}

.btn-glow {
    background: linear-gradient(45deg, var(--primary-color), var(--info-color));
    border: none;
    color: white;
    padding: 10px 20px;
    border-radius: 50px;
    font-weight: bold;
    box-shadow: 0 4px 15px rgba(139, 69, 19, 0.3);
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.btn-glow:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 20px rgba(139, 69, 19, 0.4);
}

.btn-glow:active {
    transform: translateY(1px);
}

.btn-glow::after {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
    transition: 0.5s;
}

.btn-glow:hover::after {
    left: 100%;
}

.form-control {
    background: rgba(255, 255, 255, 0.9);
    border: 1px solid rgba(139, 69, 19, 0.2);
    color: #2F4F4F;
    border-radius: 10px;
}

.form-control:focus {
    background: rgba(255, 255, 255, 0.95);
    border-color: var(--primary-color);
    box-shadow: 0 0 0 0.25rem rgba(139, 69, 19, 0.25);
    color: #2F4F4F;
}

.stats-card {
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    text-align: center;
    border: 1px solid rgba(139, 69, 19, 0.1);
}

.stats-value {
    font-size: 1.5rem;
    font-weight: bold;
    color: var(--primary-color);
    word-break: break-all;
    max-height: 60px;
    overflow-y: auto;
}

.highlight {
    animation: highlight 1s ease;
}

@keyframes highlight {
    0% { transform: scale(1); box-shadow: 0 4px 15px rgba(139, 69, 19, 0.3); }
    50% { transform: scale(1.2); box-shadow: 0 0 25px var(--warning-color); }
    100% { transform: scale(1); box-shadow: 0 4px 15px rgba(139, 69, 19, 0.3); }
}

.pulse {
    animation: pulse 0.5s ease;
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

.slide-in {
    animation: slideIn 0.5s ease;
}

@keyframes slideIn {
    from { transform: translateY(50px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}

.slide-out {
    animation: slideOut 0.5s ease;
}

@keyframes slideOut {
    from { transform: translateY(0); opacity: 1; }
    to { transform: translateY(50px); opacity: 0; }
}

.shake {
    animation: shake 0.5s ease;
}

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-10px); }
    75% { transform: translateX(10px); }
}

.flip {
    animation: flip 0.6s ease;
}

@keyframes flip {
    0% { transform: rotateY(0); }
    50% { transform: rotateY(180deg); }
    100% { transform: rotateY(360deg); }
}

.bounce {
    animation: bounce 0.5s ease;
}

@keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-20px); }
}

.color-change {
    animation: colorChange 1s ease;
}

@keyframes colorChange {
    0% { background-color: var(--primary-color); }
    50% { background-color: var(--success-color); }
    100% { background-color: var(--primary-color); }
}

.operation-log {
    max-height: 200px;
    overflow-y: auto;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    padding: 10px;
    margin-top: 10px;
    border: 1px solid rgba(139, 69, 19, 0.1);
}

.log-entry {
    padding: 5px 10px;
    margin: 5px 0;
    border-radius: 5px;
    background: rgba(255, 255, 255, 0.9);
    font-size: 0.9rem;
    animation: slideIn 0.3s ease;
    color: #2F4F4F;
}

.log-success {
    border-left: 4px solid var(--success-color);
}

.log-warning {
    border-left: 4px solid var(--warning-color);
}

.log-danger {
    border-left: 4px solid var(--danger-color);
}

.log-info {
    border-left: 4px solid var(--info-color);
}

.array-empty-state {
    text-align: center;
    padding: 40px;
    color: var(--secondary-color);
}

.array-empty-state i {
    font-size: 3rem;
    margin-bottom: 15px;
    opacity: 0.5;
}

.element-value.read {
    background: var(--info-color);
}

.element-value.update {
    background: var(--warning-color);
}

.element-value.delete {
    background: var(--danger-color);
}

.element-value.create {
    background: var(--success-color);
}

.element-value.search {
    background: var(--secondary-color);
}

.element-value.linear-search-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
}

.element-value.linear-search-checked {
    background: var(--info-color);
}

.element-value.linear-search-found {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
}

.title-animation {
    color: white;
    text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
}

@keyframes gradientShift {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

.tab-content {
    padding: 15px 0;
}

.nav-tabs .nav-link {
    color: rgba(47, 79, 79, 0.7);
    border: none;
    border-radius: 10px 10px 0 0;
    background: rgba(255, 255, 255, 0.7);
}

.nav-tabs .nav-link.active {
    color: #2F4F4F;
    background: rgba(255, 255, 255, 0.95);
    border: none;
}

.search-results {
    margin-top: 10px;
    padding: 10px;
    border-radius: 10px;
    background: rgba(255, 255, 255, 0.8);
    border: 1px solid rgba(139, 69, 19, 0.1);
}

.algorithm-explanation {
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    font-size: 0.9rem;
    border: 1px solid rgba(139, 69, 19, 0.1);
}

.algorithm-step {
    margin-bottom: 10px;
    padding: 8px;
    border-left: 3px solid var(--info-color);
    background: rgba(255, 255, 255, 0.7);
}

.algorithm-step.active {
    border-left: 3px solid var(--success-color);
    background: rgba(34, 139, 34, 0.1);
}

.code-snippet {
    background: rgba(255, 255, 255, 0.9);
    padding: 10px;
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    margin: 10px 0;
    font-size: 0.85rem;
    border: 1px solid rgba(139, 69, 19, 0.1);
}

/* Responsive adjustments for smaller screens */
@media (max-width: 768px) {
    .element-value {
        width: 50px;
        height: 50px;
        font-size: 1rem;
    }
   
    .array-element {
        margin: 0 3px 10px 3px;
    }
}

/* Additional styles for various visualizations */
.subarrays-container {
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border: 1px solid rgba(139, 69, 19, 0.1);
}

.subarray-item {
    background: var(--primary-color) !important;
    color: white;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
}

.subarray-item:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(139, 69, 19, 0.3);
}

/* Binary search styles */
.element-value.binary-search-left {
    background: var(--info-color);
    opacity: 0.7;
}

.element-value.binary-search-right {
    background: var(--secondary-color);
    opacity: 0.7;
}

.element-value.binary-search-mid {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
}

.element-value.binary-search-found {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
}

/* Occurrence search styles */
.element-value.first-occurrence {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
}

.element-value.last-occurrence {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
}

.element-value.all-occurrence {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.search-highlight {
    animation: searchHighlight 2s ease-in-out;
}

@keyframes searchHighlight {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

/* Element analysis styles */
.element-value.element-exists {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
}

.element-value.min-element {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: minMaxPulse 2s ease-in-out;
}

.element-value.max-element {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: minMaxPulse 2s ease-in-out;
}

@keyframes minMaxPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

/* Shift highlight styles */
.element-value.shift-highlight {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    animation: shiftPulse 0.5s ease;
}

@keyframes shiftPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.2); }
}

/* Traversal styles */
.element-value.traverse-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: traversePulse 0.5s ease-in-out;
}

.element-value.traverse-completed {
    background: var(--info-color);
    opacity: 0.8;
}

@keyframes traversePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

/* Transformation styles */
.element-value.cumulative-highlight {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.prefix-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

@keyframes transformPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.element-value.transform-animation {
    animation: transformPulse 0.8s ease-in-out;
}

/* Dual array styles */
.dual-array-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 30px;
    margin: 20px 0;
}

.array-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
}

.array-label {
    color: var(--secondary-color);
    font-size: 0.9rem;
    margin-bottom: 10px;
    font-weight: bold;
    text-align: center;
}

.original-array-container, .transformed-array-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: flex-end;
    padding: 15px;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    margin: 10px 0;
    min-height: 150px;
    width: 100%;
    border: 1px solid rgba(139, 69, 19, 0.1);
}

.transformed-array-container {
    background: rgba(34, 139, 34, 0.1);
    border: 1px solid var(--success-color);
}

.transformation-arrow {
    font-size: 2rem;
    color: var(--primary-color);
    margin: 10px 0;
    animation: bounce 1s infinite;
}

.transformation-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Reverse and rotation styles */
.element-value.reverse-highlight {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
}

.element-value.rotate-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.swap-animation {
    animation: swapMove 1s ease-in-out;
}

@keyframes swapMove {
    0% { transform: translateX(0) scale(1.1); }
    50% { transform: translateX(var(--swap-distance)) scale(1.3); }
    100% { transform: translateX(0) scale(1.1); }
}

.dual-operation-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 30px;
    margin: 20px 0;
}

.operation-arrow {
    font-size: 1.5rem;
    color: var(--primary-color);
    margin: 10px 0;
    animation: bounce 1s infinite;
}

.operation-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Fill and swap styles */
.element-value.fill-highlight {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.swap-highlight {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
}

/* Subarray sum styles */
.element-value.subarray-sum-match {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
    animation: subarraySumPulse 1s ease-in-out;
}

@keyframes subarraySumPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.subarray-sum-results {
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--success-color);
}

.subarray-sum-item {
    background: var(--success-color) !important;
    color: white;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
}

.subarray-sum-item:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(34, 139, 34, 0.4);
}

/* Two pointer styles */
.element-value.two-pointer-left {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: twoPointerPulse 0.5s ease-in-out;
}

.element-value.two-pointer-right {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: twoPointerPulse 0.5s ease-in-out;
}

.element-value.two-pointer-meet {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: twoPointerMeet 1s ease-in-out;
}

@keyframes twoPointerPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes twoPointerMeet {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.two-pointer-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Sorting styles */
.element-value.sorting-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: sortingPulse 0.5s ease-in-out;
}

.element-value.sorting-compared {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.sorting-swap {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: swapHighlight 0.8s ease-in-out;
}

.element-value.sorting-sorted {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

@keyframes sortingPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes swapHighlight {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.sorting-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Validation styles */
.element-value.sorted-correct {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.sorted-incorrect {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
    animation: shake 0.5s ease;
}

.element-value.partial-sorted {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.partial-unsorted {
    background: var(--info-color);
    opacity: 0.7;
}

.validation-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Color utility classes */
.warning-color {
    background: var(--warning-color) !important;
}

.success-color {
    background: var(--success-color) !important;
}

.info-color {
    background: var(--info-color) !important;
}

/* Stable sort styles */
.element-value.stable-sort-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: stableSortPulse 0.5s ease-in-out;
}

.element-value.stable-sort-compared {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.stable-sort-swapped {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: stableSortSwap 0.8s ease-in-out;
}

.element-value.stable-sort-stable {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
    border: 2px solid var(--success-color);
}

.element-value.stable-sort-original-position {
    background: var(--primary-color);
    border: 2px dashed white;
}

@keyframes stableSortPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes stableSortSwap {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.stable-sort-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Merge array styles */
.merge-array-container {
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--info-color);
}

.array-title {
    color: var(--secondary-color);
    font-size: 1rem;
    font-weight: bold;
    margin-bottom: 10px;
    text-align: center;
}

/* Window styles */
.element-value.window-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: windowPulse 0.5s ease-in-out;
}

.element-value.window-included {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.window-max {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: maxWindowPulse 1s ease-in-out;
}

.element-value.window-left {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
}

.element-value.window-right {
    background: var(--primary-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--primary-color);
    border: 3px solid white;
}

@keyframes windowPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes maxWindowPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.window-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Two pointer sort styles */
.element-value.two-pointer-sort-left {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: twoPointerSortPulse 0.5s ease-in-out;
}

.element-value.two-pointer-sort-right {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: twoPointerSortPulse 0.5s ease-in-out;
}

.element-value.two-pointer-sort-swap {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: twoPointerSortSwap 0.8s ease-in-out;
}

.element-value.two-pointer-sort-sorted {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

.element-value.kadane-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
}

.element-value.kadane-max-subarray {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: kadaneHighlight 1s ease-in-out;
}

.element-value.kadane-included {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
}

@keyframes twoPointerSortPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes twoPointerSortSwap {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes kadaneHighlight {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

/* Zero movement styles */
.element-value.zero-element {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.non-zero-element {
    background: var(--info-color);
    transform: scale(1.05);
    box-shadow: 0 0 15px var(--info-color);
}

.element-value.zero-movement-current {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: zeroMovementPulse 0.5s ease-in-out;
}

.element-value.zero-movement-target {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

@keyframes zeroMovementPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.zero-movement-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Rearrange styles */
.element-value.negative-value {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.positive-value {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.rearrange-current {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: rearrangePulse 0.5s ease-in-out;
}

.element-value.rearrange-target {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

@keyframes rearrangePulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.rearrange-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Segregate styles */
.element-value.even-number {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.odd-number {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.segregate-current {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: segregatePulse 0.5s ease-in-out;
}

.element-value.segregate-target {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

@keyframes segregatePulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.segregate-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Frequency styles */
.element-value.frequency-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.duplicate-highlight {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: duplicatePulse 0.5s ease-in-out;
}

@keyframes duplicatePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

/* Frequency table styles */
.frequency-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    overflow: hidden;
}

.frequency-table th {
    background: var(--primary-color);
    color: white;
    padding: 12px;
    text-align: left;
    font-weight: bold;
}

.frequency-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
}

.frequency-table tr:last-child td {
    border-bottom: none;
}

.frequency-table tr:hover {
    background: rgba(255, 255, 255, 0.4);
}

.frequency-high-count {
    background: rgba(255, 140, 0, 0.3);
    font-weight: bold;
}

.frequency-duplicate {
    background: rgba(220, 20, 60, 0.3);
    font-weight: bold;
}

.frequency-unique {
    background: rgba(34, 139, 34, 0.3);
}

.table-container {
    max-height: 300px;
    overflow-y: auto;
    margin: 15px 0;
    border-radius: 10px;
    background: rgba(255, 255, 255, 0.8);
}

.table-animation {
    animation: slideIn 0.5s ease;
}

.stats-highlight {
    background: var(--info-color);
    padding: 10px;
    border-radius: 5px;
    margin: 10px 0;
    text-align: center;
    font-weight: bold;
}

/* Non-repeating styles */
.element-value.non-repeating {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: nonRepeatingPulse 1s ease-in-out;
}

.element-value.repeating {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
    opacity: 0.7;
}

.element-value.unique-element {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: uniquePulse 0.8s ease-in-out;
}

.element-value.checked-element {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--warning-color);
}

@keyframes nonRepeatingPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

@keyframes uniquePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

/* Unique elements table */
.unique-elements-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    overflow: hidden;
}

.unique-elements-table th {
    background: var(--primary-color);
    color: white;
    padding: 12px;
    text-align: left;
    font-weight: bold;
}

.unique-elements-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
}

.unique-elements-table tr:last-child td {
    border-bottom: none;
}

.unique-elements-table tr:hover {
    background: rgba(255, 255, 255, 0.4);
}

.frequency-unique {
    background: rgba(34, 139, 34, 0.3);
    font-weight: bold;
}

.frequency-duplicate {
    background: rgba(220, 20, 60, 0.3);
}

/* Majority element styles */
.element-value.majority-candidate {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: majorityPulse 0.5s ease-in-out;
}

.element-value.majority-count-increase {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: majorityHighlight 1s ease-in-out;
}

.element-value.majority-count-decrease {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

.element-value.majority-found {
    background: var(--success-color);
    transform: scale(1.4);
    box-shadow: 0 0 35px var(--success-color);
    border: 4px solid white;
    animation: majorityFound 2s ease-in-out infinite;
}

.element-value.majority-current {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
}

@keyframes majorityPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes majorityHighlight {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes majorityFound {
    0%, 100% { transform: scale(1.4); }
    50% { transform: scale(1.7); }
}

.majority-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Dutch flag styles */
.element-value.dutch-low {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: dutchPulse 0.5s ease-in-out;
}

.element-value.dutch-mid {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: dutchPulse 0.5s ease-in-out;
}

.element-value.dutch-high {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: dutchPulse 0.5s ease-in-out;
}

.element-value.dutch-swap {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: dutchSwap 0.8s ease-in-out;
}

.element-value.dutch-sorted {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

@keyframes dutchPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes dutchSwap {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.dutch-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Shift delete styles */
.element-value.shift-delete-target {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: shiftDeletePulse 0.5s ease-in-out;
}

.element-value.shift-left-moving {
    background: var(--warning-color);
    transform: translateX(-20px);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
    transition: all 0.5s ease;
}

.element-value.shift-left-completed {
    background: var(--info-color);
    transform: scale(1.1);
}

@keyframes shiftDeletePulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.shift-delete-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Pivot styles */
.element-value.pivot-low {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.pivot-high {
    background: var(--secondary-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--secondary-color);
    border: 2px solid white;
}

.element-value.pivot-mid {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: pivotPulse 0.5s ease-in-out;
}

.element-value.pivot-found {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: pivotFound 1s ease-in-out;
}

.element-value.rotation-highlight {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
    animation: rotationPulse 0.8s ease-in-out;
}

@keyframes pivotPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes pivotFound {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes rotationPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.pivot-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Rotated search styles */
.element-value.rotated-search-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: rotatedSearchPulse 0.5s ease-in-out;
}

.element-value.rotated-search-boundary {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.rotated-search-mid {
    background: var(--primary-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--primary-color);
    border: 3px solid white;
    animation: rotatedSearchMid 1s ease-in-out;
}

.element-value.rotated-search-found {
    background: var(--success-color);
    transform: scale(1.4);
    box-shadow: 0 0 35px var(--success-color);
    border: 4px solid white;
    animation: rotatedSearchFound 2s ease-in-out infinite;
}

.element-value.rotated-sorted-half {
    background: var(--secondary-color);
    opacity: 0.8;
}

@keyframes rotatedSearchPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes rotatedSearchMid {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes rotatedSearchFound {
    0%, 100% { transform: scale(1.4); }
    50% { transform: scale(1.7); }
}

.rotated-search-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Progression styles */
.element-value.ap-term {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
    animation: apTermPulse 0.8s ease-in-out;
}

.element-value.gp-term {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
    animation: gpTermPulse 0.8s ease-in-out;
}

.element-value.progression-formula {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: formulaHighlight 1s ease-in-out;
}

@keyframes apTermPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes gpTermPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes formulaHighlight {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.progression-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.progression-formula-display {
    background: rgba(255, 255, 255, 0.9);
    padding: 10px;
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    margin: 10px 0;
    font-size: 0.9rem;
    border: 1px solid var(--primary-color);
}

/* Kth element styles */
.element-value.kth-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: kthPulse 0.5s ease-in-out;
}

.element-value.kth-target {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: kthFound 1s ease-in-out;
}

.element-value.kth-compared {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.kth-partition {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
}

@keyframes kthPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes kthFound {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.kth-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Selection and insertion sort styles */
.element-value.selection-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: selectionPulse 0.5s ease-in-out;
}

.element-value.selection-min {
    background: var(--info-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--info-color);
    border: 3px solid white;
    animation: selectionMinPulse 0.8s ease-in-out;
}

.element-value.selection-compared {
    background: var(--secondary-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--secondary-color);
    border: 2px solid white;
}

.element-value.selection-swap {
    background: var(--danger-color);
    transform: scale(1.4);
    box-shadow: 0 0 35px var(--danger-color);
    border: 3px solid white;
    animation: selectionSwap 1s ease-in-out;
}

.element-value.selection-sorted {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

.element-value.insertion-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: insertionPulse 0.5s ease-in-out;
}

.element-value.insertion-key {
    background: var(--info-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--info-color);
    border: 3px solid white;
    animation: insertionKeyPulse 0.8s ease-in-out;
}

.element-value.insertion-compared {
    background: var(--secondary-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--secondary-color);
    border: 2px solid white;
}

.element-value.insertion-shift {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 2px solid white;
    animation: insertionShift 0.5s ease-in-out;
}

.element-value.insertion-sorted {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

@keyframes selectionPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes selectionMinPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes selectionSwap {
    0%, 100% { transform: scale(1.4); }
    50% { transform: scale(1.8); }
}

@keyframes insertionKeyPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes insertionShift {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

/* Cyclic shift styles */
.element-value.cyclic-shift-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: cyclicShiftPulse 0.5s ease-in-out;
}

/* Cyclic Shift Styles */
.element-value.cyclic-shift-moving {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: cyclicShiftMove 0.8s ease-in-out;
    z-index: 10;
}

.element-value.cyclic-shift-original {
    background: var(--info-color);
    opacity: 0.7;
}

.element-value.cyclic-shift-completed {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

.element-value.cyclic-shift-new-position {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

@keyframes cyclicShiftPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes cyclicShiftMove {
    0% { transform: scale(1.2) translateX(0); }
    50% { transform: scale(1.3) translateX(var(--move-distance)); }
    100% { transform: scale(1.2) translateX(0); }
}

.cyclic-shift-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Negation styles */
.element-value.negation-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: negationPulse 0.5s ease-in-out;
}

.element-value.negation-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
    animation: negationHighlight 1s ease-in-out;
}

@keyframes negationPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes negationHighlight {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

/* N/3 Elements styles */
.element-value.n3-candidate-1 {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: n3Candidate1Pulse 0.5s ease-in-out;
}

.element-value.n3-candidate-2 {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: n3Candidate2Pulse 0.5s ease-in-out;
}

.element-value.n3-count-increase {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: n3CountIncrease 1s ease-in-out;
}

.element-value.n3-count-decrease {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

.element-value.n3-found {
    background: var(--success-color);
    transform: scale(1.4);
    box-shadow: 0 0 35px var(--success-color);
    border: 4px solid white;
    animation: n3Found 2s ease-in-out infinite;
}

.element-value.n3-current {
    background: var(--primary-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--primary-color);
    border: 3px solid white;
}

@keyframes n3Candidate1Pulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes n3Candidate2Pulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes n3CountIncrease {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes n3Found {
    0%, 100% { transform: scale(1.4); }
    50% { transform: scale(1.7); }
}

/* Next Greater Element styles */
.element-value.nge-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: ngeCurrentPulse 0.5s ease-in-out;
}

.element-value.nge-processed {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.nge-found {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: ngeFound 1s ease-in-out;
}

.element-value.nge-no-greater {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

.stack-element {
    background: var(--secondary-color);
    color: white;
    padding: 10px;
    margin: 5px;
    border-radius: 5px;
    font-weight: bold;
    text-align: center;
    min-width: 60px;
    animation: stackSlideIn 0.5s ease;
}

.stack-container {
    display: flex;
    flex-direction: column-reverse;
    align-items: center;
    margin: 15px 0;
    padding: 10px;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    min-height: 200px;
    justify-content: flex-end;
}

.stack-label {
    color: var(--secondary-color);
    font-size: 0.9rem;
    margin-bottom: 10px;
    font-weight: bold;
}

@keyframes ngeCurrentPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes ngeFound {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes stackSlideIn {
    from { transform: translateY(-20px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}

.nge-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.n3-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.element-value.shallow-copy-original {
    background: var(--primary-color);
    border: 2px solid white;
}

.element-value.shallow-copy-reference {
    background: var(--warning-color);
    border: 2px dashed white;
    animation: referencePulse 1s ease-in-out;
}

.element-value.shallow-copy-modified {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: shallowCopyPulse 0.8s ease-in-out;
}

.element-value.shallow-copy-affected {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

@keyframes referencePulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

@keyframes shallowCopyPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.shallow-copy-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--warning-color);
}

/* Add these to the existing CSS */
.element-value.merge-sort-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: mergeSortPulse 0.5s ease-in-out;
}

.element-value.merge-sort-compare {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.merge-sort-merge {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.merge-sort-sorted {
    background: var(--success-color);
    transform: scale(1.05);
    box-shadow: 0 0 15px var(--success-color);
}

.element-value.merge-sort-left {
    background: var(--info-color);
    opacity: 0.8;
}

.element-value.merge-sort-right {
    background: var(--warning-color);
    opacity: 0.8;
}

@keyframes mergeSortPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.merge-sort-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.element-value.insert-sorted-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: insertSortedPulse 0.5s ease-in-out;
}

.element-value.insert-sorted-compared {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.insert-sorted-position {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: insertSortedPosition 1s ease-in-out;
}

.element-value.insert-sorted-new-element {
    background: var(--primary-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--primary-color);
    border: 3px dashed white;
    animation: newElementPulse 1s ease-in-out infinite;
}

@keyframes insertSortedPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes insertSortedPosition {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes newElementPulse {
    0%, 100% {
        transform: scale(1.2);
        box-shadow: 0 0 25px var(--primary-color);
    }
    50% {
        transform: scale(1.4);
        box-shadow: 0 0 35px var(--primary-color);
    }
}

.insert-sorted-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add to existing CSS */
.element-value.random-generated {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
    animation: randomGeneratePulse 0.8s ease-in-out;
}

@keyframes randomGeneratePulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.random-array-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.char-array-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: flex-end;
    min-height: 150px;
    padding: 20px;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    margin: 20px 0;
    transition: all 0.5s ease;
    gap: 10px;
}

.char-element-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0 5px 15px 5px;
    transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    transform-origin: bottom;
    flex-shrink: 0;
}

.char-element {
    background: var(--info-color);
    color: white;
    width: 60px;
    height: 60px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 10px;
    font-weight: bold;
    font-size: 1.2rem;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    transition: all 0.3s ease;
    flex-shrink: 0;
}

.char-element.special-char {
    background: var(--warning-color);
}

.char-element.space-char {
    background: var(--secondary-color);
    opacity: 0.7;
}

.char-element.highlight {
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    background: var(--success-color);
}

.char-index {
    margin-top: 10px;
    font-size: 0.8rem;
    color: var(--secondary-color);
}

.char-code {
    font-size: 0.7rem;
    color: var(--secondary-color);
    margin-top: 5px;
    text-align: center;
}

.string-display {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    font-family: 'Courier New', monospace;
    font-size: 1.2rem;
    text-align: center;
    border: 1px solid var(--primary-color);
    min-height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.conversion-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    border-left: 4px solid var(--info-color);
}

/* Responsive adjustments for smaller screens */
@media (max-width: 768px) {
    .char-element {
        width: 50px;
        height: 50px;
        font-size: 1rem;
    }
   
    .char-element-wrapper {
        margin: 0 3px 10px 3px;
    }
}

/* Add these to the existing CSS */
.custom-comparator-container {
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--info-color);
}

.dictionary-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    overflow: hidden;
}

.dictionary-table th {
    background: var(--primary-color);
    color: white;
    padding: 12px;
    text-align: left;
    font-weight: bold;
}

.dictionary-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
}

.dictionary-table tr:last-child td {
    border-bottom: none;
}

.dictionary-table tr:hover {
    background: rgba(255, 255, 255, 0.4);
}

.action-buttons {
    display: flex;
    gap: 5px;
}

.btn-sm {
    padding: 5px 10px;
    font-size: 0.8rem;
}

.editable-field {
    background: rgba(255, 255, 255, 0.9);
    border: 1px dashed var(--info-color);
    border-radius: 3px;
    padding: 2px 5px;
    cursor: pointer;
}

.editable-field:focus {
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid var(--info-color);
    outline: none;
}

.sort-configuration {
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border-left: 4px solid var(--warning-color);
}

.sort-step {
    background: rgba(255, 255, 255, 0.8);
    border-radius: 5px;
    padding: 10px;
    margin: 5px 0;
    border-left: 3px solid var(--info-color);
}

.sort-step.active {
    border-left: 3px solid var(--success-color);
    background: rgba(34, 139, 34, 0.1);
}

.dictionary-record-highlight {
    background: var(--warning-color);
    transform: scale(1.05);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
    animation: recordHighlight 0.5s ease-in-out;
}

@keyframes recordHighlight {
    0%, 100% { transform: scale(1.05); }
    50% { transform: scale(1.1); }
}

.dictionary-record-sorted {
    background: var(--success-color);
    transform: scale(1.02);
    box-shadow: 0 0 15px var(--success-color);
}

.confirmation-dialog {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 2px solid var(--danger-color);
    text-align: center;
}

.preview-highlight {
    background: rgba(255, 140, 0, 0.3);
    border: 1px solid var(--warning-color);
}

/* Add these to the existing CSS */
.element-value.quick-sort-pivot {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: quickSortPulse 0.8s ease-in-out;
}

.element-value.quick-sort-partition {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 2px solid white;
}

.element-value.quick-sort-sorted {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
}

.element-value.heap-sort-parent {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 2px solid white;
}

.element-value.heap-sort-child {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
}

.element-value.heap-sort-heapified {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

@keyframes quickSortPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

/* Add these to the existing CSS */
.element-value.even-number-sorted {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.odd-number-sorted {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.absolute-sorted {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
    animation: transformPulse 0.8s ease-in-out;
}

.element-value.positive-value-sorted {
    background: var(--info-color);
    transform: scale(1.05);
    box-shadow: 0 0 15px var(--info-color);
}

.element-value.negative-value-sorted {
    background: var(--warning-color);
    transform: scale(1.05);
    box-shadow: 0 0 15px var(--warning-color);
}

.element-value.sorting-move {
    animation: sortingMove 0.8s ease-in-out;
}

@keyframes sortingMove {
    0% { transform: translateX(0) scale(1.1); }
    50% { transform: translateX(var(--move-distance)) scale(1.3); }
    100% { transform: translateX(0) scale(1.1); }
}

/* Add these to the existing CSS */
.element-value.triplet-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
    animation: tripletPulse 0.8s ease-in-out;
}

.element-value.quadruplet-highlight {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
    animation: quadrupletPulse 0.8s ease-in-out;
}

.element-value.triplet-current {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: tripletCurrentPulse 0.5s ease-in-out;
}

.element-value.quadruplet-current {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: quadrupletCurrentPulse 0.5s ease-in-out;
}

@keyframes tripletPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes quadrupletPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes tripletCurrentPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

@keyframes quadrupletCurrentPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.triplet-results, .quadruplet-results {
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--info-color);
}

.triplet-item, .quadruplet-item {
    background: var(--info-color) !important;
    color: white;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
    display: inline-block;
}

.quadruplet-item {
    background: var(--warning-color) !important;
}

.triplet-item:hover, .quadruplet-item:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(139, 69, 19, 0.3);
}

/* Add these to the existing CSS */
.element-value.equilibrium-left {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.equilibrium-right {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.equilibrium-point {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: equilibriumPulse 1s ease-in-out;
}

@keyframes equilibriumPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.equilibrium-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.equilibrium-stats {
    display: flex;
    justify-content: space-around;
    margin: 10px 0;
}

.equilibrium-stat {
    text-align: center;
    padding: 10px;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 8px;
    min-width: 100px;
}

.equilibrium-stat-value {
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--primary-color);
}

/* Add these to the existing CSS */
.water-container {
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--info-color);
}

.water-bar {
    background: var(--info-color);
    margin: 0 2px;
    border-radius: 5px 5px 0 0;
    transition: all 0.5s ease;
    position: relative;
}

.water-filled {
    background: var(--primary-color);
    border-radius: 0 0 5px 5px;
    position: absolute;
    bottom: 0;
    width: 100%;
    transition: all 0.5s ease;
}

.water-pointer-left {
    background: var(--warning-color);
    border: 3px solid white;
    box-shadow: 0 0 20px var(--warning-color);
}

.water-pointer-right {
    background: var(--success-color);
    border: 3px solid white;
    box-shadow: 0 0 20px var(--success-color);
}

.water-current-area {
    background: var(--danger-color);
    border: 3px solid white;
    box-shadow: 0 0 25px var(--danger-color);
    animation: waterPulse 1s ease-in-out;
}

@keyframes waterPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.water-level {
    background: rgba(135, 206, 235, 0.3);
    border: 1px dashed var(--info-color);
}

/* Add these to the existing CSS */
.element-value.two-sum-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: twoSumPulse 0.5s ease-in-out;
}

.element-value.two-sum-checked {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.two-sum-found {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: twoSumFound 1s ease-in-out;
}

@keyframes twoSumPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes twoSumFound {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.two-sum-results {
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--success-color);
}

.two-sum-pair {
    background: var(--success-color) !important;
    color: white;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
    display: inline-block;
}

.two-sum-pair:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(34, 139, 34, 0.4);
}

/* Add these to the existing CSS */
.element-value.gcd-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
    animation: gcdLcmPulse 0.8s ease-in-out;
}

.element-value.lcm-highlight {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
    animation: gcdLcmPulse 0.8s ease-in-out;
}

.element-value.gcd-lcm-result {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: resultPulse 1s ease-in-out;
}

@keyframes gcdLcmPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes resultPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.gcd-lcm-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.element-value.prime-number {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
    animation: primePulse 0.8s ease-in-out;
}

.element-value.composite-number {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
    animation: compositePulse 0.8s ease-in-out;
}

.element-value.sieve-current {
    background: var(--warning-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: sieveCurrentPulse 0.5s ease-in-out;
}

.element-value.sieve-multiple {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--info-color);
    border: 2px solid white;
}

@keyframes primePulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes compositePulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.2); }
}

@keyframes sieveCurrentPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.prime-sieve-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.primes-list {
    background: rgba(34, 139, 34, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border: 1px solid var(--success-color);
}

.prime-item {
    background: var(--success-color) !important;
    color: white;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
    display: inline-block;
}

.prime-item:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(34, 139, 34, 0.4);
}

/* Add these to the existing CSS */
.element-value.substring-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: substringPulse 0.5s ease-in-out;
}

.element-value.substring-included {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.substring-duplicate {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: substringDuplicate 0.8s ease-in-out;
}

.element-value.substring-max {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: substringMax 1s ease-in-out;
}

@keyframes substringPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes substringDuplicate {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes substringMax {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.substring-window {
    position: relative;
    margin: 10px 0;
    padding: 10px;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    border: 2px solid var(--info-color);
}

.substring-window-label {
    position: absolute;
    top: -10px;
    left: 10px;
    background: var(--info-color);
    color: white;
    padding: 2px 8px;
    border-radius: 5px;
    font-size: 0.8rem;
    font-weight: bold;
}

.char-array-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    padding: 15px;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    margin: 10px 0;
    min-height: 100px;
}

.char-element {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0 8px 10px 8px;
    transition: all 0.3s ease;
}

.char-value {
    background: var(--primary-color);
    color: white;
    width: 50px;
    height: 50px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 8px;
    font-weight: bold;
    font-size: 1.1rem;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    transition: all 0.3s ease;
}

.char-index {
    margin-top: 5px;
    font-size: 0.7rem;
    color: var(--secondary-color);
}

/* Add these to the existing CSS */
.element-value.product-window-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: productWindowPulse 0.5s ease-in-out;
}

.element-value.product-window-included {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.product-window-valid {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.product-window-invalid {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

@keyframes productWindowPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.product-subarray-item {
    background: var(--success-color) !important;
    color: white;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
    display: inline-block;
}

.product-subarray-item:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(34, 139, 34, 0.4);
}

/* Add these to the existing CSS */
.element-value.leader-element {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: leaderPulse 1s ease-in-out;
}

.element-value.leader-candidate {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 2px solid white;
}

.element-value.leader-compared {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
}

.element-value.non-leader {
    background: var(--danger-color);
    opacity: 0.7;
}

@keyframes leaderPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.leader-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    overflow: hidden;
}

.leader-table th {
    background: var(--primary-color);
    color: white;
    padding: 12px;
    text-align: left;
    font-weight: bold;
}

.leader-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
}

.leader-table tr:last-child td {
    border-bottom: none;
}

.leader-table tr:hover {
    background: rgba(255, 255, 255, 0.4);
}

.leader-position {
    background: rgba(34, 139, 34, 0.3);
    font-weight: bold;
}

/* Add these to the existing CSS */
.element-value.jump-game-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: jumpGamePulse 0.5s ease-in-out;
}

.element-value.jump-game-reachable {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.jump-game-unreachable {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
    opacity: 0.7;
}

.element-value.jump-game-possible {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: jumpGameSuccess 1s ease-in-out;
}

@keyframes jumpGamePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes jumpGameSuccess {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.jump-game-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    overflow: hidden;
}

.jump-game-table th {
    background: var(--primary-color);
    color: white;
    padding: 12px;
    text-align: left;
    font-weight: bold;
}

.jump-game-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
}

.jump-game-table tr:last-child td {
    border-bottom: none;
}

.jump-game-table tr:hover {
    background: rgba(255, 255, 255, 0.4);
}

.jump-game-reachable-cell {
    background: rgba(34, 139, 34, 0.3);
    font-weight: bold;
}

.jump-game-unreachable-cell {
    background: rgba(220, 20, 60, 0.3);
}

.jump-game-current-cell {
    background: rgba(255, 140, 0, 0.3);
    font-weight: bold;
}

.jump-game-result {
    padding: 15px;
    border-radius: 10px;
    margin: 15px 0;
    text-align: center;
    font-size: 1.2rem;
    font-weight: bold;
    animation: slideIn 0.5s ease;
}

.jump-game-success {
    background: rgba(34, 139, 34, 0.3);
    border-left: 4px solid var(--success-color);
    color: var(--success-color);
}

.jump-game-failure {
    background: rgba(220, 20, 60, 0.3);
    border-left: 4px solid var(--danger-color);
    color: var(--danger-color);
}

/* Add these to the existing CSS */
.element-value.buy-day {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: buySellPulse 1s ease-in-out;
}

.element-value.sell-day {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: buySellPulse 1s ease-in-out;
}

.element-value.profit-calculation {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.current-min {
    background: var(--info-color);
    transform: scale(1.15);
    box-shadow: 0 0 22px var(--info-color);
    border: 2px solid white;
}

@keyframes buySellPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.stock-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.profit-highlight {
    background: var(--success-color);
    padding: 10px;
    border-radius: 5px;
    margin: 10px 0;
    text-align: center;
    font-weight: bold;
    animation: profitPulse 2s ease-in-out;
}

@keyframes profitPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

/* Add these to the existing CSS */
.element-value.subarray-near-zero {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: nearZeroPulse 1s ease-in-out;
}

.element-value.subarray-candidate {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

@keyframes nearZeroPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.near-zero-results {
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--success-color);
}

.near-zero-item {
    background: var(--success-color) !important;
    color: white;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
    display: inline-block;
}

.near-zero-item:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(34, 139, 34, 0.4);
}

.near-zero-best {
    background: var(--warning-color) !important;
    border: 2px solid white;
    animation: bestSubarrayPulse 2s infinite;
}

@keyframes bestSubarrayPulse {
    0%, 100% { transform: scale(1.05); }
    50% { transform: scale(1.15); }
}

/* Add these to the existing CSS */
.char-array-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    padding: 15px;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    margin: 10px 0;
    min-height: 80px;
}

.char-element {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0 5px 10px 5px;
    transition: all 0.3s ease;
}

.char-value {
    background: var(--primary-color);
    color: white;
    width: 50px;
    height: 50px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 8px;
    font-weight: bold;
    font-size: 1.1rem;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    transition: all 0.3s ease;
}

.char-index {
    margin-top: 5px;
    font-size: 0.7rem;
    color: var(--secondary-color);
}

.char-value.window-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 2px solid white;
}

.char-value.window-included {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
}

.char-value.window-required {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

.char-value.window-satisfied {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
}

.char-value.window-minimum {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: minWindowPulse 1s ease-in-out;
}

@keyframes minWindowPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.frequency-display {
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border-left: 4px solid var(--info-color);
}

.frequency-item {
    display: inline-block;
    background: var(--primary-color);
    color: white;
    padding: 5px 10px;
    margin: 2px;
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
}

/* Add these to the existing CSS */
.element-value.k-consecutive-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: kConsecutivePulse 0.5s ease-in-out;
}

.element-value.k-consecutive-included {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.k-consecutive-max {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: kConsecutiveMaxPulse 1s ease-in-out;
}

.element-value.k-consecutive-min {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: kConsecutiveMinPulse 1s ease-in-out;
}

@keyframes kConsecutivePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes kConsecutiveMaxPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes kConsecutiveMinPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.k-consecutive-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.element-value.rearrange-min {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: rearrangeMinMaxPulse 0.5s ease-in-out;
}

.element-value.rearrange-max {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: rearrangeMinMaxPulse 0.5s ease-in-out;
}

.element-value.rearrange-current {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: rearrangeCurrentPulse 0.5s ease-in-out;
}

.element-value.rearrange-target {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
}

@keyframes rearrangeMinMaxPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes rearrangeCurrentPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.rearrange-minmax-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.element-value.permutation-pivot {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: permutationPulse 0.5s ease-in-out;
}

.element-value.permutation-swap {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: permutationSwap 0.8s ease-in-out;
}

.element-value.permutation-reverse {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

@keyframes permutationPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes permutationSwap {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.permutation-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.element-value.consecutive-sequence {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
    animation: consecutivePulse 1s ease-in-out;
}

.element-value.consecutive-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: consecutiveCurrent 0.5s ease-in-out;
}

.element-value.consecutive-max {
    background: var(--info-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--info-color);
    border: 3px solid white;
    animation: consecutiveMax 1s ease-in-out;
}

@keyframes consecutivePulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes consecutiveCurrent {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes consecutiveMax {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.consecutive-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.element-value.interval-start {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.interval-end {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.interval-overlap {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: intervalPulse 0.8s ease-in-out;
}

.element-value.interval-merged {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: mergedPulse 1s ease-in-out;
}

.interval-container {
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--info-color);
}

.interval-item {
    background: var(--primary-color) !important;
    color: white;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
    display: inline-block;
}

.interval-item.overlapping {
    background: var(--warning-color) !important;
}

.interval-item.merged {
    background: var(--success-color) !important;
    transform: scale(1.05);
}

@keyframes intervalPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes mergedPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.interval-visualization {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin: 15px 0;
}

.interval-line {
    display: flex;
    align-items: center;
    padding: 10px;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 5px;
    position: relative;
}

.interval-label {
    min-width: 120px;
    font-weight: bold;
    color: var(--secondary-color);
}

.interval-range {
    flex: 1;
    height: 30px;
    background: rgba(255, 255, 255, 0.4);
    border-radius: 15px;
    position: relative;
    overflow: hidden;
}

.interval-segment {
    position: absolute;
    height: 100%;
    border-radius: 15px;
    transition: all 0.5s ease;
}

.interval-segment.original {
    background: var(--primary-color);
    opacity: 0.7;
}

.interval-segment.overlap {
    background: var(--danger-color);
    z-index: 2;
}

.interval-segment.merged {
    background: var(--success-color);
    z-index: 3;
}

.horizontal-arrays-container {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    justify-content: center;
}

.horizontal-array-group {
    flex: 0 0 auto;
}

/* Add these to the existing CSS */
.element-value.set-operation-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.set-operation-included {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
}

.element-value.set-operation-excluded {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
    opacity: 0.7;
}

.set-operation-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.set-operation-result {
    background: rgba(34, 139, 34, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border: 1px solid var(--success-color);
}

/* Add these to the existing CSS */
.subset-comp-element-match {
    background: var(--success-color) !important;
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
    animation: subsetMatchPulse 0.5s ease-in-out;
}

.subset-comp-element-not-found {
    background: var(--danger-color) !important;
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
    animation: subsetNotFoundPulse 0.5s ease-in-out;
}

.superset-comp-element-match {
    background: var(--info-color) !important;
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
    animation: supersetMatchPulse 0.5s ease-in-out;
}

@keyframes subsetMatchPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes subsetNotFoundPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes supersetMatchPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.subset-comp-container {
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--info-color);
}

.superset-comp-container {
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--warning-color);
}

.memory-address-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
    animation: memoryPulse 1s ease-in-out;
}

@keyframes memoryPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.memory-address-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    overflow: hidden;
}

.memory-address-table th {
    background: var(--primary-color);
    color: white;
    padding: 12px;
    text-align: left;
    font-weight: bold;
}

.memory-address-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
}

.memory-address-table tr:last-child td {
    border-bottom: none;
}

.memory-address-table tr:hover {
    background: rgba(255, 255, 255, 0.4);
}

/* Add these to the existing CSS */
.element-value.comparison-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: comparisonPulse 0.5s ease-in-out;
}

.element-value.comparison-checked {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.comparison-found {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: foundHighlight 1s ease-in-out;
}

.element-value.comparison-not-found {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: notFoundHighlight 1s ease-in-out;
}

@keyframes comparisonPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes foundHighlight {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

@keyframes notFoundHighlight {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

/* Add these to the existing CSS */
.element-value.statistical-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
    animation: statisticalPulse 0.8s ease-in-out;
}

.element-value.mean-highlight {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.deviation-highlight {
    background: var(--primary-color);
    transform: scale(1.05);
    box-shadow: 0 0 15px var(--primary-color);
    border: 1px solid white;
}

@keyframes statisticalPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.stats-positive {
    color: var(--success-color) !important;
    font-weight: bold;
}

.stats-negative {
    color: var(--danger-color) !important;
    font-weight: bold;
}

.stats-zero {
    color: #2F4F4F !important;
    font-weight: bold;
}

.statistical-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    border-left: 4px solid var(--info-color);
}

.covariance-table, .correlation-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    overflow: hidden;
}

.covariance-table th, .correlation-table th {
    background: var(--primary-color);
    color: white;
    padding: 12px;
    text-align: center;
    font-weight: bold;
}

.covariance-table td, .correlation-table td {
    padding: 10px 12px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    text-align: center;
}

.statistical-formula {
    background: rgba(255, 255, 255, 0.9);
    padding: 12px;
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    margin: 10px 0;
    font-size: 0.9rem;
    text-align: center;
    border-left: 4px solid var(--warning-color);
}

/* Add these to the existing CSS */
.element-value.statistical-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
    animation: statisticalPulse 0.8s ease-in-out;
}

.element-value.mean-element {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
}

.element-value.median-element {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
}

@keyframes statisticalPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.stats-result-card {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border-left: 4px solid var(--info-color);
}

.calculation-steps {
    background: rgba(255, 255, 255, 0.8);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
}

/* Add these to the existing CSS */
.element-wise-max-element {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: elementWisePulse 1s ease-in-out;
}

.element-wise-min-element {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: elementWisePulse 1s ease-in-out;
}

@keyframes elementWisePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.element-wise-source {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-wise-comparison {
    background: var(--primary-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--primary-color);
}

/* Add these to the existing CSS */
.element-value.logical-true {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.logical-false {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

.element-value.logical-operation-current {
    background: var(--warning-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: logicalPulse 0.5s ease-in-out;
}

.element-value.logical-operation-result {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: resultPulse 1s ease-in-out;
}

@keyframes logicalPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

@keyframes resultPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.logical-operation-container {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--info-color);
}

.array-title {
    color: var(--secondary-color);
    font-size: 1rem;
    font-weight: bold;
    margin-bottom: 10px;
    text-align: center;
}

/* Add these to the existing CSS */
.element-value.statistical-mean {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.statistical-deviation {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.statistical-variance {
    background: var(--primary-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--primary-color);
    border: 2px solid white;
}

.element-value.statistical-stddev {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
}

.statistical-results {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--info-color);
}

.statistical-formula {
    background: rgba(255, 255, 255, 0.9);
    padding: 10px;
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    margin: 10px 0;
    font-size: 0.85rem;
    text-align: center;
}

/* Add these to the existing CSS */
.element-value.scalar-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
    animation: scalarPulse 0.5s ease-in-out;
}

@keyframes scalarPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

/* Add these to the existing CSS */
.element-value.trig-operation-original {
    background: var(--primary-color);
    border: 2px dashed white;
}

.element-value.trig-operation-transformed {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
    animation: trigPulse 0.8s ease-in-out;
}

.element-value.trig-operation-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: trigHighlight 0.5s ease-in-out;
}

@keyframes trigPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes trigHighlight {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.trig-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.element-value.range-min {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: rangePulse 2s ease-in-out;
}

.element-value.range-max {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: rangePulse 2s ease-in-out;
}

.element-value.range-current {
    background: var(--primary-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--primary-color);
    border: 2px solid white;
}

@keyframes rangePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.range-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.range-result {
    background: rgba(34, 139, 34, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    text-align: center;
    border: 2px solid var(--success-color);
}

/* Add these to the existing CSS */
.element-value.math-operation-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: mathOperationPulse 0.5s ease-in-out;
}

.element-value.math-operation-completed {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
}

.element-value.math-operation-result {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

@keyframes mathOperationPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.math-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these styles to the CSS section */
.element-value.pancake-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: pancakePulse 0.5s ease-in-out;
}

.element-value.pancake-flip-range {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

.element-value.pancake-sorted {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

.element-value.pancake-max {
    background: var(--info-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--info-color);
    border: 3px solid white;
    animation: pancakeMaxPulse 0.8s ease-in-out;
}

@keyframes pancakePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes pancakeMaxPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.pancake-flip-animation {
    animation: pancakeFlip 0.8s ease-in-out;
}

@keyframes pancakeFlip {
    0% { transform: rotateX(0deg); }
    50% { transform: rotateX(180deg); }
    100% { transform: rotateX(0deg); }
}

.pancake-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.element-value.stock-span-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: stockSpanPulse 0.5s ease-in-out;
}

.element-value.stock-span-compared {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.stock-span-greater {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.stock-span-result {
    background: var(--primary-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--primary-color);
    border: 2px solid white;
}

.stock-span-value {
    background: var(--secondary-color);
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    font-weight: bold;
    margin-top: 5px;
    font-size: 0.8rem;
}

@keyframes stockSpanPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.monotonic-stack-container {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--info-color);
}

.stack-item {
    background: var(--warning-color);
    color: white;
    padding: 8px 12px;
    margin: 5px;
    border-radius: 5px;
    display: inline-block;
    transition: all 0.3s ease;
}

.stack-item.active {
    background: var(--success-color);
    transform: scale(1.1);
}

/* Add these to the existing CSS */
.element-value.and-pair-current {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: andOrPulse 0.5s ease-in-out;
}

.element-value.or-pair-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: andOrPulse 0.5s ease-in-out;
}

.element-value.max-and-pair {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: maxPairHighlight 1s ease-in-out;
}

.element-value.max-or-pair {
    background: var(--primary-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--primary-color);
    border: 3px solid white;
    animation: maxPairHighlight 1s ease-in-out;
}

@keyframes andOrPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes maxPairHighlight {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.logical-results {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
}

.logical-results .stats-card {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 0;
    height: 100%;
    transition: all 0.3s ease;
}

.logical-results .stats-card:hover {
    background: rgba(255, 255, 255, 0.95);
    transform: translateY(-2px);
}

.logical-results .stats-value {
    font-size: 0.9rem;
    line-height: 1.3;
    margin-bottom: 5px;
    word-break: break-all;
}

.logical-results .stats-value:last-child {
    margin-bottom: 0;
}

/* Animation for results update */
.stats-value {
    transition: all 0.3s ease;
}

.stats-value.updated {
    background: rgba(139, 69, 19, 0.2);
    border-radius: 5px;
    padding: 2px 5px;
}

.logical-result-item {
    background: var(--primary-color) !important;
    color: white;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
}

/* Add these to the existing CSS */
.element-value.histogram-bar {
    background: var(--primary-color);
    height: var(--bar-height);
    width: 50px;
    margin: 0 2px;
    border-radius: 5px 5px 0 0;
    position: relative;
    transition: all 0.3s ease;
}

.element-value.histogram-current {
    background: var(--warning-color);
    box-shadow: 0 0 20px var(--warning-color);
    z-index: 10;
}

.element-value.histogram-in-stack {
    background: var(--info-color);
    border: 2px solid white;
}

.element-value.histogram-max-area {
    background: var(--success-color);
    box-shadow: 0 0 25px var(--success-color);
    transform: scale(1.05);
    z-index: 20;
    animation: histogramPulse 2s ease-in-out infinite;
}

.element-value.histogram-left-boundary {
    background: var(--secondary-color);
    opacity: 0.8;
}

.element-value.histogram-right-boundary {
    background: var(--danger-color);
    opacity: 0.8;
}

@keyframes histogramPulse {
    0%, 100% { transform: scale(1.05); }
    50% { transform: scale(1.1); }
}

.histogram-container {
    display: flex;
    align-items: flex-end;
    justify-content: center;
    min-height: 400px;
    padding: 20px;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 15px;
    margin: 20px 0;
    position: relative;
}

.histogram-bar-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0 5px;
    position: relative;
}

.histogram-bar-label {
    margin-top: 10px;
    font-size: 0.8rem;
    color: var(--secondary-color);
    text-align: center;
}

.histogram-area-display {
    position: absolute;
    background: rgba(255, 255, 255, 0.95);
    color: var(--dark-color);
    padding: 5px 10px;
    border-radius: 5px;
    font-weight: bold;
    z-index: 30;
    pointer-events: none;
    transition: all 0.3s ease;
}

.stack-visualization {
    display: flex;
    flex-direction: column-reverse;
    align-items: center;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin: 15px 0;
    min-height: 150px;
}

.stack-item {
    background: var(--info-color);
    color: white;
    padding: 8px 15px;
    margin: 2px 0;
    border-radius: 5px;
    font-weight: bold;
    transition: all 0.3s ease;
}

.stack-item.active {
    background: var(--warning-color);
    transform: scale(1.1);
}

.area-calculation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border-left: 4px solid var(--info-color);
}

.area-formula {
    font-family: 'Courier New', monospace;
    background: rgba(255, 255, 255, 0.9);
    padding: 10px;
    border-radius: 5px;
    margin: 10px 0;
}

/* Add these to the existing CSS */
.element-value.basket-fruit {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.basket-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: basketPulse 0.5s ease-in-out;
}

.element-value.basket-max {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: basketMaxPulse 1s ease-in-out;
}

.element-value.basket-removed {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

@keyframes basketPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes basketMaxPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.basket-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.element-value.element-wise-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.element-wise-result {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: elementWisePulse 0.8s ease-in-out;
}

@keyframes elementWisePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.element-wise-operation-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    margin: 20px 0;
}

.element-wise-array-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
}

.element-wise-arrow {
    font-size: 1.5rem;
    color: var(--primary-color);
    margin: 10px 0;
    animation: bounce 1s infinite;
}

.element-wise-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.element-value.logical-not-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: logicalPulse 0.5s ease-in-out;
}

.element-value.logical-xor-current {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

@keyframes logicalPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

/* Add these to the existing CSS */
.element-value.transform-current {
    background: var(--warning-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: transformPulse 0.5s ease-in-out;
}

.element-value.transform-compared {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.transform-reduced {
    background: var(--danger-color);
    transform: scale(1.4);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: reduceAnimation 0.8s ease-in-out;
}

.element-value.transform-valid {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

@keyframes transformPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

@keyframes reduceAnimation {
    0% { transform: scale(1.4); background: var(--danger-color); }
    50% { transform: scale(1.6); background: var(--warning-color); }
    100% { transform: scale(1.4); background: var(--danger-color); }
}

.transform-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.operations-counter {
    background: var(--primary-color);
    color: white;
    padding: 10px 15px;
    border-radius: 10px;
    font-weight: bold;
    margin: 10px 0;
    text-align: center;
}

/* Add these to the existing CSS */
.element-value.flip-highlight {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: flipHighlight 0.5s ease-in-out;
}

.element-value.flip-candidate {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.flip-performed {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: flipPerformed 1s ease-in-out;
}

@keyframes flipHighlight {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes flipPerformed {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.binary-representation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    font-family: 'Courier New', monospace;
    text-align: center;
}

.binary-digit {
    display: inline-block;
    width: 30px;
    height: 30px;
    line-height: 30px;
    margin: 2px;
    background: var(--primary-color);
    color: white;
    border-radius: 5px;
    font-weight: bold;
}

.binary-digit.flipped {
    background: var(--danger-color);
    animation: digitFlip 0.5s ease-in-out;
}

@keyframes digitFlip {
    0% { transform: rotateY(0); }
    50% { transform: rotateY(180deg); }
    100% { transform: rotateY(360deg); }
}

/* Add these to the existing CSS */
.element-value.xor-highlight {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.xor-current {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: xorPulse 0.5s ease-in-out;
}

.element-value.xor-result {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

@keyframes xorPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.xor-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.xor-operation {
    font-family: 'Courier New', monospace;
    background: rgba(255, 255, 255, 0.9);
    padding: 5px 10px;
    border-radius: 5px;
    margin: 0 5px;
}

/* Add these to the existing CSS */
.element-value.abs-diff-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: absDiffPulse 0.5s ease-in-out;
}

.element-value.abs-diff-compared {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.abs-diff-max {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: absDiffMaxPulse 1s ease-in-out;
}

@keyframes absDiffPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes absDiffMaxPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.abs-diff-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    overflow: hidden;
    font-size: 0.85rem;
}

.abs-diff-table th {
    background: var(--primary-color);
    color: white;
    padding: 10px;
    text-align: center;
    font-weight: bold;
}

.abs-diff-table td {
    padding: 8px 10px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
    text-align: center;
}

.abs-diff-table tr:last-child td {
    border-bottom: none;
}

.abs-diff-table tr:hover {
    background: rgba(255, 255, 255, 0.4);
}

.abs-diff-highlight {
    background: rgba(34, 139, 34, 0.2);
    font-weight: bold;
}

.abs-diff-results {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--info-color);
}

.diff-value {
    font-size: 1.2rem;
    font-weight: bold;
    padding: 10px;
    border-radius: 5px;
    margin: 5px 0;
    text-align: center;
}

.diff1-value {
    background: rgba(135, 206, 235, 0.2);
    border: 2px solid var(--info-color);
}

.diff2-value {
    background: rgba(255, 140, 0, 0.2);
    border: 2px solid var(--warning-color);
}

.max-diff-value {
    background: rgba(34, 139, 34, 0.3);
    border: 3px solid var(--success-color);
    animation: pulse 1s ease-in-out;
}

/* Add these to the existing CSS */
.element-value.circular-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: circularPulse 0.5s ease-in-out;
}

.element-value.circular-included {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.circular-max-subarray {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: circularMaxPulse 1s ease-in-out;
}

.element-value.circular-min-subarray {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: circularMinPulse 1s ease-in-out;
}

@keyframes circularPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes circularMaxPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes circularMinPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.5); }
}

.circular-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    overflow: hidden;
}

.circular-table th {
    background: var(--primary-color);
    color: white;
    padding: 12px;
    text-align: left;
    font-weight: bold;
}

.circular-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
}

.circular-table tr:last-child td {
    border-bottom: none;
}

.circular-table tr:hover {
    background: rgba(255, 255, 255, 0.4);
}

.circular-step-active {
    background: rgba(34, 139, 34, 0.2) !important;
    font-weight: bold;
}

.circular-value-highlight {
    background: rgba(255, 140, 0, 0.2);
    font-weight: bold;
}

/* Add these to the existing CSS */
.element-value.wiggle-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: wigglePulse 0.5s ease-in-out;
}

.element-value.wiggle-compared {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.wiggle-swapped {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: wiggleSwap 0.8s ease-in-out;
}

.element-value.wiggle-correct {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

.element-value.wiggle-incorrect {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--danger-color);
    animation: shake 0.5s ease;
}

@keyframes wigglePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes wiggleSwap {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.wiggle-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.element-value.max-distance-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: maxDistancePulse 0.5s ease-in-out;
}

.element-value.max-distance-pair {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: maxDistanceHighlight 1s ease-in-out;
}

.element-value.max-distance-checked {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
}

@keyframes maxDistancePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes maxDistanceHighlight {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.max-distance-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.element-value.pair-element {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.pair-current {
    background: var(--warning-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: pairPulse 0.5s ease-in-out;
}

.element-value.pair-match {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: pairMatch 1s ease-in-out;
}

@keyframes pairPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

@keyframes pairMatch {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.pairs-results {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--success-color);
}

.pair-item {
    background: var(--success-color) !important;
    color: white;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
    display: inline-block;
}

.pair-item:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(34, 139, 34, 0.4);
}

/* Add these to the existing CSS */
.element-value.valid-element {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.invalid-element {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

.element-value.window-boundary {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: windowBoundaryPulse 1s ease-in-out;
}

.element-value.swap-candidate {
    background: var(--info-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--info-color);
    border: 3px solid white;
    animation: swapCandidatePulse 0.8s ease-in-out;
}

.element-value.swap-performed {
    background: var(--primary-color);
    transform: scale(1.4);
    box-shadow: 0 0 35px var(--primary-color);
    border: 3px solid white;
    animation: swapPerformed 1s ease-in-out;
}

@keyframes windowBoundaryPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes swapCandidatePulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

@keyframes swapPerformed {
    0%, 100% { transform: scale(1.4); }
    50% { transform: scale(1.6); }
}

.swaps-results {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--info-color);
}

.swap-operation {
    background: var(--info-color) !important;
    color: white;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
    display: inline-block;
}

.swap-operation:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(135, 206, 235, 0.4);
}

/* Add these to the existing CSS */
.element-value.repeating-element {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: repeatingPulse 1s ease-in-out;
}

.element-value.checked-repeating {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.non-repeating-check {
    background: var(--info-color);
    transform: scale(1.05);
    box-shadow: 0 0 15px var(--info-color);
}

@keyframes repeatingPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.repeating-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--danger-color);
}

/* Add these to the existing CSS */
.element-value.true-condition {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.false-condition {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.conditional-result {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: conditionalPulse 0.8s ease-in-out;
}

@keyframes conditionalPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.conditional-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.element-value.true-condition {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
    animation: conditionalPulse 0.8s ease-in-out;
}

.element-value.false-condition {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
    animation: conditionalPulse 0.8s ease-in-out;
}

.element-value.conditional-result {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: conditionalPulse 0.8s ease-in-out;
}

@keyframes conditionalPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.conditional-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Ensure the sorting classes are defined */
.element-value.sorting-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
}

.element-value.sorting-compared {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.success-color {
    background: var(--success-color) !important;
}

.warning-color {
    background: var(--warning-color) !important;
}

/* Add these to the existing CSS */
.element-value.predicate-match {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: predicatePulse 0.8s ease-in-out;
}

.element-value.predicate-nomatch {
    background: var(--danger-color);
    opacity: 0.6;
    transform: scale(0.9);
}

@keyframes predicatePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.predicate-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
/* Add these to the existing CSS */
.matrix-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    margin: 20px 0;
}

.matrix-row {
    display: flex;
    gap: 10px;
    justify-content: center;
}

.matrix-element {
    background: var(--primary-color);
    color: white;
    width: 60px;
    height: 60px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 10px;
    font-weight: bold;
    font-size: 1.2rem;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    transition: all 0.5s ease;
    animation: matrixAppear 0.6s ease;
}

@keyframes matrixAppear {
    from {
        transform: scale(0) rotate(180deg);
        opacity: 0;
    }
    to {
        transform: scale(1) rotate(0deg);
        opacity: 1;
    }
}

.reshape-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.matrix-label {
    color: var(--secondary-color);
    font-size: 1rem;
    font-weight: bold;
    margin-bottom: 10px;
    text-align: center;
}

/* Add these to the existing CSS */
.element-value.transform-animation {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: transformPulse 0.8s ease-in-out;
}

@keyframes transformPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

/* Add these to the existing CSS */
.element-value.shuffle-current {
    background: var(--warning-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: shufflePulse 0.5s ease-in-out;
}

.element-value.shuffle-swap {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

.element-value.shuffle-completed {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

@keyframes shufflePulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.shuffle-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.element-value.bin-interval-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
    animation: binPulse 0.5s ease-in-out;
}

.element-value.bin-boundary {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
}

.element-value.bin-count-highlight {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: binCountPulse 1s ease-in-out;
}

@keyframes binPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes binCountPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.bin-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    overflow: hidden;
}

.bin-table th {
    background: var(--primary-color);
    color: white;
    padding: 12px;
    text-align: left;
    font-weight: bold;
}

.bin-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
}

.bin-table tr:last-child td {
    border-bottom: none;
}

.bin-table tr:hover {
    background: rgba(255, 255, 255, 0.4);
}

.bin-interval-high-count {
    background: rgba(255, 140, 0, 0.2);
    font-weight: bold;
}

.bin-visualization {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border-left: 4px solid var(--info-color);
}

/* Enhanced Stock Market Styles */
.investment-insight {
    background: linear-gradient(135deg, #8B4513 0%, #A0522D 100%);
    color: white;
    padding: 15px;
    border-radius: 10px;
    margin: 10px 0;
    text-align: center;
}

.performance-metric {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 8px;
    padding: 10px;
    margin: 5px 0;
    border-left: 4px solid var(--info-color);
}

.metric-positive {
    border-left-color: var(--success-color) !important;
    background: rgba(34, 139, 34, 0.1);
}

.metric-negative {
    border-left-color: var(--danger-color) !important;
    background: rgba(220, 20, 60, 0.1);
}

.volatility-indicator {
    display: inline-block;
    padding: 4px 8px;
    border-radius: 15px;
    font-size: 0.8rem;
    margin: 2px;
}

.volatility-high {
    background: var(--danger-color);
    color: white;
}

.volatility-medium {
    background: var(--warning-color);
    color: black;
}

.volatility-low {
    background: var(--success-color);
    color: white;
}

.financial-summary {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--primary-color);
}

.business-insight {
    background: rgba(135, 206, 235, 0.1);
    border-left: 4px solid var(--info-color);
    padding: 10px;
    margin: 8px 0;
    border-radius: 5px;
    font-size: 0.9rem;
}

/* Add these to your existing CSS */
.momentum-positive {
    background: linear-gradient(135deg, #228B22, #1E7B1E) !important;
    color: white;
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(34, 139, 34, 0.4);
}

.momentum-negative {
    background: linear-gradient(135deg, #DC143C, #B22222) !important;
    color: white;
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(220, 20, 60, 0.4);
}

.roc-indicator {
    border: 3px solid transparent;
    background-clip: padding-box;
}

.roc-high {
    border-color: #228B22;
    animation: pulse-roc 2s infinite;
}

.roc-low {
    border-color: #DC143C;
    animation: pulse-roc 2s infinite;
}

@keyframes pulse-roc {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

.gap-up {
    background: rgba(34, 139, 34, 0.3) !important;
    border-left: 6px solid #228B22 !important;
}

.gap-down {
    background: rgba(220, 20, 60, 0.3) !important;
    border-left: 6px solid #DC143C !important;
}

.intraday-gain {
    box-shadow: 0 0 20px rgba(34, 139, 34, 0.5);
    animation: glow-gain 1.5s ease-in-out infinite alternate;
}

.intraday-loss {
    box-shadow: 0 0 20px rgba(220, 20, 60, 0.5);
    animation: glow-loss 1.5s ease-in-out infinite alternate;
}

@keyframes glow-gain {
    from { box-shadow: 0 0 10px rgba(34, 139, 34, 0.5); }
    to { box-shadow: 0 0 20px rgba(34, 139, 34, 0.8); }
}

@keyframes glow-loss {
    from { box-shadow: 0 0 10px rgba(220, 20, 60, 0.5); }
    to { box-shadow: 0 0 20px rgba(220, 20, 60, 0.8); }
}

.dual-operation-container {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 15px;
    padding: 20px;
    margin: 15px 0;
    border: 1px solid var(--primary-color);
}

.array-group {
    margin: 10px 0;
}

.array-label {
    font-weight: bold;
    margin-bottom: 8px;
    color: var(--info-color);
    text-align: center;
}

.operation-arrow {
    text-align: center;
    margin: 15px 0;
    font-size: 1.5rem;
    color: var(--primary-color);
}

.financial-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin: 15px 0;
    border-left: 4px solid var(--warning-color);
}

/* Add these to your existing CSS */
.technical-indicator {
    border-radius: 10px;
    transition: all 0.3s ease;
}

.moving-average {
    background: linear-gradient(135deg, #8B4513, #A0522D) !important;
    color: white;
    border: 2px solid #7A3D12;
}

.macd-line {
    background: linear-gradient(135deg, #A0522D, #DC143C) !important;
    color: white;
    border: 2px solid #8B4513;
}

.macd-signal {
    background: linear-gradient(135deg, #87CEEB, #00BFFF) !important;
    color: white;
    border: 2px solid #5F9EA0;
}

.bollinger-band {
    background: linear-gradient(135deg, #228B22, #32CD32) !important;
    color: white;
    border: 2px solid #1E7B1E;
}

.volatility-high {
    animation: volatility-pulse 1.5s ease-in-out infinite;
}

@keyframes volatility-pulse {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.05); opacity: 0.8; }
    100% { transform: scale(1); opacity: 1; }
}

.trend-up {
    box-shadow: 0 0 15px rgba(34, 139, 34, 0.6);
    animation: trend-up-glow 2s ease-in-out infinite alternate;
}

.trend-down {
    box-shadow: 0 0 15px rgba(220, 20, 60, 0.6);
    animation: trend-down-glow 2s ease-in-out infinite alternate;
}

@keyframes trend-up-glow {
    from { box-shadow: 0 0 10px rgba(34, 139, 34, 0.4); }
    to { box-shadow: 0 0 20px rgba(34, 139, 34, 0.8); }
}

@keyframes trend-down-glow {
    from { box-shadow: 0 0 10px rgba(220, 20, 60, 0.4); }
    to { box-shadow: 0 0 20px rgba(220, 20, 60, 0.8); }
}

.calculation-step {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 8px;
    padding: 10px;
    margin: 5px 0;
    border-left: 4px solid var(--info-color);
    transition: all 0.3s ease;
}

.calculation-step.active {
    background: rgba(255, 255, 255, 0.95);
    border-left-color: var(--warning-color);
    transform: translateX(5px);
}

.period-selector {
    background: rgba(255, 255, 255, 0.9);
    border: 1px solid var(--primary-color);
    border-radius: 8px;
    padding: 10px;
    margin: 10px 0;
}

.period-label {
    font-weight: bold;
    color: var(--info-color);
    margin-bottom: 8px;
}

/* Enhanced Matrix Styles */
.matrix-container {
    display: grid;
    gap: 8px;
    margin: 15px 0;
    justify-content: center;
    padding: 10px;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
}

.matrix-row {
    display: flex;
    gap: 8px;
    justify-content: center;
}

.matrix-cell {
    width: 60px;
    height: 60px;
    background: var(--primary-color);
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 8px;
    font-weight: bold;
    font-size: 0.9rem;
    transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    position: relative;
    overflow: hidden;
}

.matrix-cell::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: 0.5s;
}

.matrix-cell.highlight {
    background: var(--warning-color);
    transform: scale(1.15);
    box-shadow: 0 0 20px var(--warning-color);
    z-index: 10;
}

.matrix-cell.highlight::before {
    left: 100%;
}

.matrix-cell.result {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

.matrix-cell.processing {
    background: var(--info-color);
    transform: scale(1.05);
}

.axis-operation-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    border-left: 4px solid var(--info-color);
    transition: all 0.3s ease;
}

.axis-operation-explanation.highlight {
    background: rgba(255, 255, 255, 0.95);
    border-left: 4px solid var(--warning-color);
}

/* Add pulse animation for better visibility */
@keyframes matrixPulse {
    0%, 100% {
        transform: scale(1.15);
        box-shadow: 0 0 20px var(--warning-color);
    }
    50% {
        transform: scale(1.25);
        box-shadow: 0 0 30px var(--warning-color);
    }
}

.matrix-cell.highlight.pulse {
    animation: matrixPulse 1s ease-in-out;
}

/* Step animation */
.algorithm-step {
    transition: all 0.3s ease;
    margin-bottom: 8px;
    padding: 10px;
    border-radius: 5px;
}

.algorithm-step.active {
    background: rgba(255, 255, 255, 0.9);
    border-left: 4px solid var(--success-color);
    transform: translateX(5px);
}

/* Add these to the existing CSS */
.element-value.stat-min-highlight {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: statPulse 1s ease-in-out;
}

.element-value.stat-max-highlight {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: statPulse 1s ease-in-out;
}

.element-value.stat-n-smallest {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.stat-n-largest {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

@keyframes statPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.stats-results-container {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    border-left: 4px solid var(--info-color);
}

.stats-result-item {
    background: var(--primary-color);
    color: white;
    padding: 8px 12px;
    margin: 5px;
    border-radius: 5px;
    display: inline-block;
    font-family: 'Courier New', monospace;
}

/* Add these to the existing CSS */
.parentheses-valid {
    background: var(--success-color) !important;
    color: white;
    padding: 10px;
    border-radius: 5px;
    text-align: center;
    font-weight: bold;
    margin: 10px 0;
    animation: slideIn 0.5s ease;
}

.parentheses-invalid {
    background: var(--danger-color) !important;
    color: white;
    padding: 10px;
    border-radius: 5px;
    text-align: center;
    font-weight: bold;
    margin: 10px 0;
    animation: shake 0.5s ease;
}

.parentheses-current {
    background: var(--warning-color) !important;
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: parenthesesPulse 0.5s ease-in-out;
}

.parentheses-matched {
    background: var(--success-color) !important;
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.parentheses-unmatched {
    background: var(--danger-color) !important;
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
    animation: shake 0.5s ease;
}

@keyframes parenthesesPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.parentheses-stack-item {
    background: var(--info-color) !important;
    color: white;
    font-family: 'Courier New', monospace;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
    transition: all 0.3s ease;
}

.parentheses-stack-item.current {
    background: var(--warning-color) !important;
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--warning-color);
}

/* Add these to the existing CSS */
.element-value.kadane-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: kadaneCurrentPulse 0.5s ease-in-out;
}

.element-value.kadane-included {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.kadane-max-subarray {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: kadaneHighlight 1s ease-in-out;
}

@keyframes kadaneCurrentPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes kadaneHighlight {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

/* Add these to the existing CSS */
.palindrome-valid {
    background: var(--success-color) !important;
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: palindromePulse 1s ease-in-out;
}

.palindrome-invalid {
    background: var(--danger-color) !important;
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: palindromePulse 1s ease-in-out;
}

.anagram-valid {
    background: var(--success-color) !important;
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: anagramPulse 1s ease-in-out;
}

.anagram-invalid {
    background: var(--danger-color) !important;
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: anagramPulse 1s ease-in-out;
}

@keyframes palindromePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes anagramPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.string-operation-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    margin: 20px 0;
}

.string-input-group {
    width: 100%;
    max-width: 400px;
}

.string-display {
    font-size: 1.5rem;
    font-weight: bold;
    padding: 15px;
    border-radius: 10px;
    background: rgba(255, 255, 255, 0.9);
    text-align: center;
    min-height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 10px 0;
}

.character-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 8px;
    margin: 15px 0;
}

.character-box {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--primary-color);
    color: white;
    border-radius: 5px;
    font-weight: bold;
    font-size: 1.1rem;
    transition: all 0.3s ease;
}

.character-box.highlight {
    background: var(--warning-color);
    transform: scale(1.2);
}

/* Add these to the existing CSS */
.element-value.range-sum-highlight {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: rangeSumPulse 1s ease-in-out;
}

.element-value.range-sum-current {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

@keyframes rangeSumPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.range-sum-results {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--success-color);
}

/* Add these to the existing CSS */
.element-value.daily-temp-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: dailyTempPulse 0.5s ease-in-out;
}

.element-value.daily-temp-stack {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.daily-temp-warmer {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: dailyTempWarmer 1s ease-in-out;
}

.element-value.daily-temp-processed {
    background: var(--secondary-color);
    opacity: 0.7;
}

@keyframes dailyTempPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes dailyTempWarmer {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.daily-temp-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.daily-temp-result {
    background: rgba(34, 139, 34, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border: 1px solid var(--success-color);
}

/* Add these to the existing CSS */
.element-value.palindrome-center {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: palindromePulse 0.5s ease-in-out;
}

.element-value.palindrome-expanding {
    background: var(--warning-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--warning-color);
    border: 3px solid white;
}

.element-value.palindrome-found {
    background: var(--success-color);
    transform: scale(1.4);
    box-shadow: 0 0 35px var(--success-color);
    border: 3px solid white;
    animation: palindromeFound 1s ease-in-out;
}

.element-value.longest-palindrome {
    background: var(--danger-color);
    transform: scale(1.5);
    box-shadow: 0 0 40px var(--danger-color);
    border: 4px solid white;
    animation: longestPalindrome 2s ease-in-out infinite;
}

@keyframes palindromePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes palindromeFound {
    0%, 100% { transform: scale(1.4); }
    50% { transform: scale(1.6); }
}

@keyframes longestPalindrome {
    0%, 100% { transform: scale(1.5); }
    50% { transform: scale(1.7); }
}

.palindrome-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.palindrome-stats {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--success-color);
}

/* Add these to the existing CSS */
.dp-table {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    overflow-x: auto;
}

.dp-cell {
    transition: all 0.3s ease;
    border: 1px solid rgba(255, 255, 255, 0.3);
}

.dp-header {
    font-weight: bold;
    background: var(--primary-color) !important;
}

.dp-cell:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}

/* Add these to the existing CSS */
.element-value.backtrack-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: backtrackPulse 0.5s ease-in-out;
}

.element-value.backtrack-included {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.backtrack-skipped {
    background: var(--danger-color);
    opacity: 0.6;
    transform: scale(0.9);
}

.element-value.backtrack-valid {
    background: var(--info-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--info-color);
    border: 3px solid white;
    animation: validPulse 1s ease-in-out;
}

@keyframes backtrackPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes validPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.combination-result {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--success-color);
}

.subset-item {
    background: var(--primary-color);
    color: white;
    padding: 8px 12px;
    margin: 5px;
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    display: inline-block;
    transition: all 0.3s ease;
}

.subset-item:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(139, 69, 19, 0.4);
}

.backtrack-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.element-value.parenthesis-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: parenthesisPulse 0.5s ease-in-out;
}

.element-value.parenthesis-match {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
}

.element-value.parenthesis-invalid {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

@keyframes parenthesisPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.dp-table {
    display: grid;
    gap: 2px;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.9);
    padding: 10px;
    border-radius: 10px;
}

.dp-row {
    display: grid;
    grid-template-columns: 50px repeat(auto-fit, minmax(50px, 1fr));
    gap: 2px;
}

.dp-cell {
    background: var(--primary-color);
    padding: 10px;
    text-align: center;
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
}

.dp-cell.header {
    background: var(--dark-color);
    font-weight: bold;
}

.dp-cell.current {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--warning-color);
}

.dp-cell.updated {
    background: var(--success-color);
    transform: scale(1.05);
}

.dp-cell.zero {
    background: rgba(255, 255, 255, 0.9);
    opacity: 0.7;
}

.parenthesis-stack {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border-left: 4px solid var(--info-color);
}

.stack-item {
    background: var(--primary-color);
    color: white;
    padding: 10px;
    margin: 5px 0;
    border-radius: 5px;
    text-align: center;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
}

.stack-item.current {
    background: var(--warning-color);
    transform: scale(1.05);
    box-shadow: 0 0 15px var(--warning-color);
}

.stack-item.sentinel {
    background: var(--secondary-color);
    opacity: 0.8;
}

/* Add these to the existing CSS */
.element-value.smaller-count-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: smallerCountPulse 0.5s ease-in-out;
}

.element-value.smaller-count-compared {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.smaller-count-smaller {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.smaller-count-result {
    background: var(--primary-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--primary-color);
    border: 2px solid white;
}

@keyframes smallerCountPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.smaller-count-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    overflow: hidden;
}

.smaller-count-table th {
    background: var(--primary-color);
    color: white;
    padding: 12px;
    text-align: center;
    font-weight: bold;
}

.smaller-count-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
    text-align: center;
}

.smaller-count-table tr:last-child td {
    border-bottom: none;
}

.smaller-count-table tr:hover {
    background: rgba(255, 255, 255, 0.4);
}

.smaller-count-results-container {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 20px;
    border: 1px solid var(--info-color);
}

/* Ugly Number Styles */
.ugly-number-highlight {
    background: var(--warning-color) !important;
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: uglyPulse 0.8s ease-in-out;
}

.ugly-number-prime-factor {
    background: var(--info-color) !important;
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.ugly-number-current {
    background: var(--success-color) !important;
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: uglyCurrentPulse 1s ease-in-out;
}

.ugly-number-candidate {
    background: var(--secondary-color) !important;
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--secondary-color);
}

@keyframes uglyPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes uglyCurrentPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.ugly-number-sequence {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
    margin: 15px 0;
}

.ugly-sequence-item {
    background: var(--primary-color);
    color: white;
    padding: 8px 12px;
    border-radius: 5px;
    font-weight: bold;
    transition: all 0.3s ease;
}

.ugly-sequence-item.current {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 20px var(--success-color);
}

/* Add these to the existing CSS */
.element-value.perfect-number {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: perfectPulse 1s ease-in-out;
}

.element-value.armstrong-number {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: armstrongPulse 1s ease-in-out;
}

.element-value.checking-perfect {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
}

.element-value.checking-armstrong {
    background: var(--secondary-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--secondary-color);
}

@keyframes perfectPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes armstrongPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.perfect-explanation, .armstrong-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.pascal-triangle-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 20px 0;
}

.pascal-row {
    display: flex;
    justify-content: center;
    margin: 5px 0;
}

.pascal-element {
    background: var(--primary-color);
    color: white;
    width: 50px;
    height: 50px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 50%;
    font-weight: bold;
    margin: 0 5px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    transition: all 0.3s ease;
}

.pascal-element.highlight {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    animation: pascalHighlight 0.5s ease-in-out;
}

@keyframes pascalHighlight {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.pascal-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.circle-visualization {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    margin: 20px 0;
}

.circle-container {
    position: relative;
    width: 300px;
    height: 300px;
    border: 2px solid var(--primary-color);
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.9);
    margin: 20px 0;
}

.circle-center {
    position: absolute;
    width: 10px;
    height: 10px;
    background: var(--success-color);
    border-radius: 50%;
    transform: translate(-50%, -50%);
}

.random-point {
    position: absolute;
    width: 8px;
    height: 8px;
    background: var(--warning-color);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    transition: all 0.5s ease;
}

.point-label {
    position: absolute;
    color: #2F4F4F;
    font-size: 0.8rem;
    background: rgba(255, 255, 255, 0.9);
    padding: 2px 6px;
    border-radius: 3px;
    transform: translate(10px, -10px);
}

.radius-line {
    position: absolute;
    background: var(--info-color);
    height: 2px;
    transform-origin: 0 0;
}

.circle-info {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
}

.coordinate-display {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin: 10px 0;
}

.coordinate-item {
    background: var(--primary-color);
    padding: 8px 12px;
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    color: white;
}

/* Add these to the existing CSS */
.element-value.english-word {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
    animation: englishWordPulse 1s ease-in-out;
}

.element-value.contains-digit-one {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: digitOnePulse 1s ease-in-out;
}

.element-value.digit-one-count {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: digitOneHighlight 1s ease-in-out;
}

@keyframes englishWordPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes digitOnePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes digitOneHighlight {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.number-operation-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.english-word-display {
    background: var(--primary-color);
    color: white;
    padding: 15px;
    border-radius: 10px;
    margin: 10px 0;
    font-size: 1.2rem;
    font-weight: bold;
    text-align: center;
    animation: slideIn 0.5s ease;
}

/* Add these to the existing CSS */
.element-value.digital-root-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: digitalRootPulse 0.5s ease-in-out;
}

.element-value.digital-root-result {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: digitalRootResult 1s ease-in-out;
}

.element-value.happy-number {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: happyNumberPulse 1s ease-in-out;
}

.element-value.not-happy-number {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
    opacity: 0.7;
}

.element-value.happy-process {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

@keyframes digitalRootPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes digitalRootResult {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes happyNumberPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.digital-root-explanation, .happy-number-explanation {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.element-value.excel-column {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.excel-number {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
    animation: excelPulse 0.8s ease-in-out;
}

.element-value.excel-error {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
    animation: shake 0.5s ease;
}

@keyframes excelPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.excel-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    overflow: hidden;
}

.excel-table th {
    background: var(--primary-color);
    color: white;
    padding: 12px;
    text-align: left;
    font-weight: bold;
}

.excel-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
}

.excel-table tr:last-child td {
    border-bottom: none;
}

.excel-table tr:hover {
    background: rgba(255, 255, 255, 0.4);
}

.excel-conversion-step {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 5px;
    padding: 8px;
    margin: 5px 0;
    border-left: 3px solid var(--info-color);
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
}

.excel-conversion-step.active {
    border-left: 3px solid var(--success-color);
    background: rgba(34, 139, 34, 0.1);
}

/* Add these to the existing CSS for Number to Column Title */
.element-value.number-to-column {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.column-title-result {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
    animation: columnTitlePulse 0.8s ease-in-out;
}

@keyframes columnTitlePulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.number-to-column-step {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 5px;
    padding: 8px;
    margin: 5px 0;
    border-left: 3px solid var(--warning-color);
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
}

.number-to-column-step.active {
    border-left: 3px solid var(--success-color);
    background: rgba(34, 139, 34, 0.1);
}

.conversion-process {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--info-color);
}

.process-step {
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 10px 0;
    padding: 10px;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 5px;
}

.process-arrow {
    margin: 0 15px;
    color: var(--primary-color);
    font-size: 1.2rem;
}

/* Add these to the existing CSS */
.stack-container {
    display: flex;
    flex-direction: column-reverse;
    align-items: center;
    justify-content: flex-end;
    min-height: 400px;
    padding: 20px;
    margin: 20px 0;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 15px;
    border: 2px solid var(--primary-color);
}

.stack-element {
    width: 120px;
    height: 60px;
    background: var(--primary-color);
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 5px 0;
    border-radius: 8px;
    font-weight: bold;
    font-size: 1.1rem;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    transition: all 0.5s ease;
    position: relative;
}

.stack-element.top-element {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
}

.stack-element.push-animation {
    animation: stackPush 0.8s ease-out;
}

.stack-element.pop-animation {
    animation: stackPop 0.8s ease-out;
}

.stack-element.peek-highlight {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 30px var(--info-color);
    border: 3px solid white;
    animation: peekPulse 1.5s ease-in-out infinite;
}

.stack-pointer {
    color: var(--warning-color);
    font-weight: bold;
    margin-top: 10px;
    font-size: 1.1rem;
}

.stack-operation-log {
    max-height: 200px;
    overflow-y: auto;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 10px;
    margin-top: 10px;
}

.stack-operation-step {
    padding: 8px 12px;
    margin: 5px 0;
    border-radius: 5px;
    background: rgba(255, 255, 255, 0.9);
    font-size: 0.9rem;
    border-left: 4px solid var(--info-color);
    animation: slideIn 0.3s ease;
}

.stack-operation-step.success {
    border-left: 4px solid var(--success-color);
    background: rgba(34, 139, 34, 0.1);
}

.stack-operation-step.warning {
    border-left: 4px solid var(--warning-color);
    background: rgba(255, 140, 0, 0.1);
}

.stack-operation-step.danger {
    border-left: 4px solid var(--danger-color);
    background: rgba(220, 20, 60, 0.1);
}

@keyframes stackPush {
    0% {
        transform: translateY(-100px);
        opacity: 0;
    }
    70% {
        transform: translateY(10px);
        opacity: 1;
    }
    100% {
        transform: translateY(0);
        opacity: 1;
    }
}

@keyframes stackPop {
    0% {
        transform: translateY(0);
        opacity: 1;
    }
    30% {
        transform: translateY(-10px);
        opacity: 0.8;
    }
    100% {
        transform: translateY(-100px);
        opacity: 0;
    }
}

@keyframes peekPulse {
    0%, 100% {
        transform: scale(1.2);
        box-shadow: 0 0 30px var(--info-color);
    }
    50% {
        transform: scale(1.3);
        box-shadow: 0 0 40px var(--info-color);
    }
}

.stack-comparison {
    display: flex;
    justify-content: space-around;
    margin: 20px 0;
    gap: 20px;
}

.comparison-section {
    flex: 1;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    padding: 15px;
}

.comparison-title {
    color: var(--secondary-color);
    font-size: 1.1rem;
    font-weight: bold;
    margin-bottom: 10px;
    text-align: center;
}

.stack-empty-state {
    text-align: center;
    padding: 40px;
    color: var(--secondary-color);
}

.stack-empty-state i {
    font-size: 3rem;
    margin-bottom: 15px;
    opacity: 0.5;
}
/* Add these to the existing CSS */
.queue-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 2px solid var(--primary-color);
}

.queue-visualization {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 150px;
    padding: 20px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 10px;
    margin: 15px 0;
    position: relative;
}

.queue-item {
    width: 60px;
    height: 60px;
    background: var(--primary-color);
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 8px;
    font-weight: bold;
    margin: 0 5px;
    transition: all 0.5s ease;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    position: relative;
}

.queue-item.empty {
    background: rgba(255, 255, 255, 0.1);
    border: 2px dashed var(--secondary-color);
    color: var(--secondary-color);
}

.queue-item.front {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.queue-item.rear {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.queue-item.enqueue-animation {
    animation: enqueueSlide 1s ease-in-out;
}

.queue-item.dequeue-animation {
    animation: dequeueSlide 1s ease-in-out;
}

@keyframes enqueueSlide {
    0% { transform: translateY(-50px); opacity: 0; }
    70% { transform: translateY(10px); opacity: 1; }
    100% { transform: translateY(0); opacity: 1; }
}

@keyframes dequeueSlide {
    0% { transform: translateX(0) scale(1); opacity: 1; }
    50% { transform: translateX(-100px) scale(0.8); opacity: 0.7; }
    100% { transform: translateX(-200px) scale(0.5); opacity: 0; }
}

.queue-pointers {
    display: flex;
    justify-content: space-between;
    margin-top: 10px;
    padding: 0 20px;
}

.queue-pointer {
    text-align: center;
    font-size: 0.9rem;
    color: var(--secondary-color);
}

.queue-pointer.active {
    color: white;
    font-weight: bold;
}

.queue-operations {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    margin-top: 15px;
}

.queue-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    border-left: 4px solid var(--info-color);
}

.queue-stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin: 15px 0;
}

.queue-step {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 5px;
    padding: 10px;
    margin: 5px 0;
    border-left: 3px solid var(--info-color);
    animation: slideIn 0.3s ease;
}

.queue-step.active {
    border-left: 3px solid var(--success-color);
    background: rgba(0, 184, 148, 0.1);
}
/* Add these to the existing CSS */
.priority-queue-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    margin: 20px 0;
}

.queue-diagram {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 15px;
    padding: 20px;
    width: 100%;
    max-width: 600px;
    border: 2px solid var(--primary-color);
}

.queue-level {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin: 10px 0;
}

.queue-node {
    background: var(--primary-color);
    color: white;
    width: 60px;
    height: 60px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    border-radius: 10px;
    font-weight: bold;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    transition: all 0.3s ease;
    position: relative;
}

.queue-node.priority-high {
    background: var(--danger-color);
    transform: scale(1.1);
}

.queue-node.priority-medium {
    background: var(--warning-color);
}

.queue-node.priority-low {
    background: var(--info-color);
}

.queue-node.active {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
}

.queue-node-value {
    font-size: 1.2rem;
}

.queue-node-priority {
    font-size: 0.7rem;
    margin-top: 2px;
    opacity: 0.9;
}

.queue-connections {
    position: relative;
    height: 40px;
}

.connection-line {
    position: absolute;
    background: var(--secondary-color);
    height: 2px;
    transform-origin: left center;
}

.heap-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.queue-operations {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    justify-content: center;
}

.queue-input-group {
    display: flex;
    gap: 10px;
    margin: 10px 0;
}

.queue-stats {
    display: flex;
    gap: 15px;
    justify-content: center;
    flex-wrap: wrap;
    margin: 15px 0;
}

.queue-stat-item {
    background: rgba(255, 255, 255, 0.05);
    padding: 10px 15px;
    border-radius: 8px;
    text-align: center;
    min-width: 100px;
}

.queue-empty-message {
    text-align: center;
    color: var(--secondary-color);
    padding: 20px;
    font-style: italic;
}
/* Browser History Styles */
.browser-history-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 15px;
    padding: 20px;
    margin: 20px 0;
    border: 1px solid var(--primary-color);
}

.browser-history-visualization {
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.browser-stack {
    display: flex;
    flex-direction: column-reverse;
    align-items: center;
    gap: 10px;
    min-height: 200px;
    padding: 20px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    border: 2px solid var(--info-color);
}

.browser-page {
    background: var(--primary-color);
    color: white;
    padding: 15px 20px;
    border-radius: 8px;
    min-width: 200px;
    text-align: center;
    font-weight: bold;
    transition: all 0.5s ease;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
}

.browser-page.current {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
}

.browser-page.visited {
    background: var(--info-color);
    opacity: 0.8;
}

.browser-page.cleared {
    background: var(--danger-color);
    opacity: 0.6;
    text-decoration: line-through;
}

.browser-pointer {
    color: var(--warning-color);
    font-size: 1.5rem;
    font-weight: bold;
    margin: 10px 0;
    animation: bounce 1s infinite;
}

.browser-controls {
    display: flex;
    gap: 10px;
    justify-content: center;
    flex-wrap: wrap;
}

.browser-input-group {
    display: flex;
    gap: 10px;
    align-items: center;
}

.browser-stats {
    display: flex;
    justify-content: space-around;
    background: rgba(255, 255, 255, 0.1);
    padding: 15px;
    border-radius: 10px;
    margin: 10px 0;
}

.browser-stat {
    text-align: center;
}

.browser-stat-value {
    font-size: 1.5rem;
    font-weight: bold;
    color: var(--primary-color);
}

.browser-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    border-left: 4px solid var(--info-color);
}

.algorithm-step.browser-step {
    background: rgba(108, 92, 231, 0.2);
    border-left: 3px solid var(--primary-color);
}
/* Add these to the existing CSS */
.stream-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--info-color);
}

.stream-title {
    color: var(--secondary-color);
    font-size: 1rem;
    font-weight: bold;
    margin-bottom: 10px;
    text-align: center;
}

.stream-element {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0 5px 15px 5px;
    transition: all 0.5s ease;
}

.stream-value {
    background: var(--primary-color);
    color: white;
    width: 70px;
    height: 70px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    border-radius: 10px;
    font-weight: bold;
    font-size: 1rem;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    transition: all 0.3s ease;
    text-align: center;
    padding: 5px;
}

.stream-index {
    font-size: 0.8rem;
    color: var(--secondary-color);
    margin-top: 5px;
}

.stream-pointer {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.stream-filled {
    background: var(--success-color);
}

.stream-empty {
    background: var(--danger-color);
    opacity: 0.7;
}

.stream-chunk {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: streamChunkPulse 1s ease-in-out;
}

@keyframes streamChunkPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.chunk-container {
    background: rgba(0, 184, 148, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--success-color);
}

.chunk-title {
    color: var(--success-color);
    font-weight: bold;
    margin-bottom: 10px;
}

.final-stream-container {
    background: rgba(108, 92, 231, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--primary-color);
}

.final-stream-title {
    color: var(--primary-color);
    font-weight: bold;
    margin-bottom: 10px;
}
/* Add these to the existing CSS */
.rle-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--info-color);
}

.rle-step {
    margin-bottom: 10px;
    padding: 8px;
    border-left: 3px solid var(--info-color);
    background: rgba(255, 255, 255, 0.05);
}

.rle-step.active {
    border-left: 3px solid var(--success-color);
    background: rgba(0, 184, 148, 0.1);
}

.rle-char {
    background: var(--primary-color);
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    margin: 2px;
    display: inline-block;
}

.rle-count {
    background: var(--warning-color);
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    margin: 2px;
    display: inline-block;
}

.rle-encoded {
    background: var(--success-color);
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    margin: 2px;
    display: inline-block;
}

.rle-original {
    background: var(--info-color);
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    margin: 2px;
    display: inline-block;
}
/* Add these to the existing CSS */
.element-value.count-say-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: countSayPulse 0.5s ease-in-out;
}

.element-value.count-say-group {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.count-say-result {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.compression-char {
    background: var(--primary-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--primary-color);
}

.element-value.compression-count {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
}

.element-value.compression-current {
    background: var(--warning-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--warning-color);
    border: 3px solid white;
    animation: compressionPulse 0.5s ease-in-out;
}

@keyframes countSayPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes compressionPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.sequence-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--info-color);
}

.sequence-term {
    margin-bottom: 20px;
    padding: 15px;
    background: rgba(255, 255, 255, 0.03);
    border-radius: 8px;
    border-left: 4px solid var(--primary-color);
}

.sequence-term.active {
    background: rgba(108, 92, 231, 0.1);
    border-left: 4px solid var(--success-color);
}

.term-label {
    color: var(--secondary-color);
    font-size: 0.9rem;
    font-weight: bold;
    margin-bottom: 10px;
    text-align: center;
}
/* Add these to the existing CSS */
.array-element.dynamic-size {
    transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.element-value.dynamic-size {
    transition: all 0.5s ease;
    min-width: 60px;
    padding: 10px 15px;
    word-break: break-all;
    text-align: center;
    line-height: 1.2;
}
/* Add these to the existing CSS */
.element-value.warning-color {
    background: var(--warning-color) !important;
}

.element-value.info-color {
    background: var(--info-color) !important;
}

.element-value.success-color {
    background: var(--success-color) !important;
}
/* Add these to the existing CSS */
.pattern-search-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--info-color);
}

.string-display {
    font-family: 'Courier New', monospace;
    background: rgba(0, 0, 0, 0.3);
    padding: 15px;
    border-radius: 5px;
    margin: 10px 0;
    font-size: 1.1rem;
    letter-spacing: 1px;
}

.pattern-match {
    background: var(--success-color);
    color: white;
    padding: 2px 4px;
    border-radius: 3px;
    font-weight: bold;
    animation: patternMatchPulse 1s ease-in-out;
}

.pattern-current {
    background: var(--warning-color);
    color: white;
    padding: 2px 4px;
    border-radius: 3px;
    font-weight: bold;
}

.z-box {
    background: var(--info-color);
    color: white;
    padding: 2px 4px;
    border-radius: 3px;
    font-weight: bold;
}

.hash-value {
    background: var(--primary-color);
    color: white;
    padding: 8px 12px;
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    margin: 5px;
    display: inline-block;
}

@keyframes patternMatchPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

.algorithm-comparison {
    display: flex;
    justify-content: space-between;
    margin: 10px 0;
}

.comparison-item {
    flex: 1;
    text-align: center;
    padding: 10px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 5px;
    margin: 0 5px;
}

.z-array-display {
    background: rgba(0, 0, 0, 0.3);
    padding: 10px;
    border-radius: 5px;
    margin: 10px 0;
    font-family: 'Courier New', monospace;
    max-height: 200px;
    overflow-y: auto;
}

.pattern-search-inputs {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
}
/* Add these to the existing CSS */
.word-abbr-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 20px;
    margin: 15px 0;
    border: 1px solid var(--info-color);
}

.word-display, .abbr-display {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    gap: 5px;
    margin: 15px 0;
    padding: 15px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    min-height: 80px;
}

.char-element {
    width: 50px;
    height: 50px;
    display: flex;
    justify-content: center;
    align-items: center;
    background: var(--primary-color);
    color: white;
    border-radius: 8px;
    font-weight: bold;
    font-size: 1.1rem;
    transition: all 0.3s ease;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
}

.char-element.current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
}

.char-element.matched {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
}

.char-element.skipped {
    background: var(--info-color);
    opacity: 0.7;
}

.char-element.error {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: shake 0.5s ease;
}

.char-element.number {
    background: var(--secondary-color);
}

.abbr-validation-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    border-left: 4px solid var(--info-color);
}

.validation-result {
    padding: 15px;
    border-radius: 10px;
    margin: 15px 0;
    text-align: center;
    font-weight: bold;
    font-size: 1.1rem;
}

.validation-success {
    background: rgba(0, 184, 148, 0.2);
    border: 2px solid var(--success-color);
    color: var(--success-color);
}

.validation-error {
    background: rgba(255, 119, 117, 0.2);
    border: 2px solid var(--danger-color);
    color: var(--danger-color);
}

.pointer-indicator {
    color: var(--warning-color);
    font-weight: bold;
    margin-top: 5px;
    font-size: 0.9rem;
}
/* Add these to the existing CSS */
.element-value.word1-highlight {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: wordHighlight 1s ease-in-out;
}

.element-value.word2-highlight {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: wordHighlight 1s ease-in-out;
}

.element-value.shortest-distance-highlight {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: shortestDistancePulse 1s ease-in-out infinite;
}

@keyframes wordHighlight {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes shortestDistancePulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.word-distance-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.distance-pointer {
    position: absolute;
    color: var(--danger-color);
    font-weight: bold;
    font-size: 1.2rem;
    z-index: 10;
}

.distance-line {
    position: absolute;
    height: 3px;
    background: var(--success-color);
    z-index: 5;
    animation: distanceLineDraw 1s ease-in-out;
}

@keyframes distanceLineDraw {
    from { width: 0; opacity: 0; }
    to { opacity: 1; }
}
/* Add these to the existing CSS */
.element-value.nim-pile {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.nim-current {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: nimPulse 0.5s ease-in-out;
}

.element-value.nim-target {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.nim-winning-move {
    background: var(--info-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--info-color);
    border: 3px solid white;
    animation: nimWinPulse 1s ease-in-out;
}

@keyframes nimPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

@keyframes nimWinPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.nim-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.nim-result {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    font-weight: bold;
}

.nim-win {
    border-left: 4px solid var(--success-color);
    background: rgba(0, 184, 148, 0.1);
}

.nim-lose {
    border-left: 4px solid var(--danger-color);
    background: rgba(255, 118, 117, 0.1);
}
/* Add these to the existing CSS */
.element-value.player1-choice {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: playerChoicePulse 0.8s ease-in-out;
}

.element-value.player2-choice {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: playerChoicePulse 0.8s ease-in-out;
}

.element-value.available-choice {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.dp-cell-highlight {
    background: var(--primary-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--primary-color);
    border: 2px solid white;
}

@keyframes playerChoicePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.dp-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    overflow: hidden;
}

.dp-table th {
    background: var(--primary-color);
    color: white;
    padding: 12px;
    text-align: center;
    font-weight: bold;
}

.dp-table td {
    padding: 15px;
    text-align: center;
    border: 1px solid rgba(255, 255, 255, 0.1);
    min-width: 60px;
    font-family: 'Courier New', monospace;
}

.dp-table td.dp-cell {
    background: rgba(255, 255, 255, 0.1);
    transition: all 0.3s ease;
}

.game-result {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 20px;
    margin-top: 20px;
    text-align: center;
    border-left: 4px solid var(--success-color);
}

.game-result.win {
    border-left-color: var(--success-color);
}

.game-result.lose {
    border-left-color: var(--danger-color);
}

.player-score {
    font-size: 1.2rem;
    font-weight: bold;
    margin: 10px 0;
}

.move-explanation {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 5px;
    padding: 10px;
    margin: 5px 0;
    border-left: 3px solid var(--warning-color);
}
/* Add these to the existing CSS */
.stone-game-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 15px;
    padding: 20px;
    margin: 20px 0;
    border: 2px solid var(--primary-color);
}

.stone-pile {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
    margin: 20px 0;
    min-height: 100px;
}

.stone-item {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: linear-gradient(45deg, #6c5ce7, #a29bfe);
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: bold;
    box-shadow: 0 4px 15px rgba(108, 92, 231, 0.4);
    transition: all 0.3s ease;
    cursor: pointer;
}

.stone-item.taken {
    background: linear-gradient(45deg, #ff7675, #fd79a8);
    transform: scale(0.8);
    opacity: 0.5;
    animation: stoneTaken 0.5s ease;
}

.stone-item.available:hover {
    transform: scale(1.1);
    box-shadow: 0 6px 20px rgba(108, 92, 231, 0.6);
}

@keyframes stoneTaken {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.2); opacity: 0.8; }
    100% { transform: scale(0.8); opacity: 0.5; }
}

.game-info {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin: 15px 0;
    text-align: center;
}

.player-turn {
    background: var(--warning-color);
    color: var(--dark-color);
    padding: 10px 20px;
    border-radius: 25px;
    font-weight: bold;
    margin: 10px 0;
    animation: pulse 1s infinite;
}

.game-controls {
    display: flex;
    gap: 10px;
    justify-content: center;
    margin: 15px 0;
}

.pick-btn {
    background: var(--primary-color);
    color: white;
    border: none;
    border-radius: 10px;
    padding: 10px 20px;
    font-weight: bold;
    transition: all 0.3s ease;
    cursor: pointer;
}

.pick-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(108, 92, 231, 0.4);
}

.pick-btn:disabled {
    background: var(--secondary-color);
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
}

.winning-player {
    background: var(--success-color);
    color: white;
    padding: 15px;
    border-radius: 10px;
    font-size: 1.2rem;
    font-weight: bold;
    margin: 15px 0;
    animation: bounce 0.5s ease;
}

.game-log {
    max-height: 200px;
    overflow-y: auto;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    padding: 10px;
    margin-top: 15px;
}

.log-entry {
    padding: 5px;
    margin: 3px 0;
    border-radius: 5px;
    background: rgba(255, 255, 255, 0.1);
    font-size: 0.9rem;
}
/* Add these to the existing CSS */
.station-gas {
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 80px;
}

.station-gas-value {
    font-size: 1.2rem;
    font-weight: bold;
}

.station-cost-value {
    font-size: 0.9rem;
    color: var(--warning-color);
    margin-top: 5px;
}

.station-arrow {
    font-size: 0.8rem;
    color: var(--secondary-color);
    margin-top: 5px;
}

.element-value.station-gas {
    background: var(--primary-color);
    transition: all 0.3s ease;
}

.element-value.success-color {
    background: var(--success-color) !important;
}

.element-value.danger-color {
    background: var(--danger-color) !important;
}

.element-value.warning-color {
    background: var(--warning-color) !important;
}
/* Add these to the existing CSS */
.element-value.candy-initial {
    background: var(--primary-color);
    transform: scale(1);
}

.element-value.candy-left-pass {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.candy-right-pass {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.candy-final {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: candyFinalPulse 1s ease-in-out;
}

@keyframes candyFinalPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.candy-rating {
    font-size: 0.9rem;
    color: var(--light-color);
    margin-bottom: 5px;
}

.candy-count {
    font-size: 1.1rem;
    font-weight: bold;
    margin-top: 5px;
}
/* Add these to the existing CSS */
.task-scheduler-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--info-color);
}

.task-execution-timeline {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
    margin: 20px 0;
    padding: 15px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
}

.time-slot {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 5px;
}

.time-label {
    font-size: 0.8rem;
    color: var(--secondary-color);
    margin-bottom: 5px;
}

.task-slot {
    width: 60px;
    height: 60px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 10px;
    font-weight: bold;
    font-size: 1.1rem;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    transition: all 0.3s ease;
}

.task-slot.task-executing {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: taskExecute 0.5s ease-in-out;
}

.task-slot.task-idle {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.task-slot.task-cooldown {
    background: var(--danger-color);
    opacity: 0.7;
    transform: scale(0.9);
}

.task-slot.task-pending {
    background: var(--info-color);
    opacity: 0.5;
}

@keyframes taskExecute {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.cooldown-indicator {
    font-size: 0.7rem;
    color: var(--danger-color);
    margin-top: 5px;
}

.execution-stats {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}
/* Add these to the existing CSS */
.element-value.partition-left {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.partition-right {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.partition-boundary {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: partitionPulse 1s ease-in-out;
}

.element-value.partition-current-left {
    background: var(--primary-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--primary-color);
    border: 3px solid white;
}

.element-value.partition-current-right {
    background: var(--secondary-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--secondary-color);
    border: 3px solid white;
}

@keyframes partitionPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.partition-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.partition-results {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border: 1px solid var(--success-color);
}
/* Add these to the existing CSS */
.element-value.partition-highlight {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: partitionPulse 0.5s ease-in-out;
}

.element-value.partition-max {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: partitionMaxPulse 1s ease-in-out;
}

@keyframes partitionPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes partitionMaxPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.dp-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    overflow: hidden;
}

.dp-table th {
    background: var(--primary-color);
    color: white;
    padding: 12px;
    text-align: center;
    font-weight: bold;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.dp-table td {
    padding: 10px 12px;
    text-align: center;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.dp-table tr:hover {
    background: rgba(255, 255, 255, 0.1);
}

.dp-current {
    background: rgba(255, 193, 7, 0.3) !important;
    font-weight: bold;
}

.dp-highlight {
    background: rgba(40, 167, 69, 0.3) !important;
    font-weight: bold;
}

.partition-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}
/* Add these to the existing CSS */
.element-value.partition-labels-boundary {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: partitionLabelsPulse 0.5s ease-in-out;
}

.element-value.partition-labels-current {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.partition-labels-included {
    background: var(--info-color);
    transform: scale(1.05);
    box-shadow: 0 0 15px var(--info-color);
}

.element-value.partition-labels-completed {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

@keyframes partitionLabelsPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.partition-labels-boundary {
    border-right: 3px dashed var(--danger-color);
    padding-right: 5px;
    margin-right: 5px;
}

.partition-labels-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}
/* Add these to the existing CSS */
.element-value.split-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: splitPulse 0.5s ease-in-out;
}

.element-value.split-included {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.split-boundary {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: splitBoundaryPulse 1s ease-in-out;
}

.element-value.split-optimal {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
}

@keyframes splitPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes splitBoundaryPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.split-subarray {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 2px solid var(--info-color);
}

.subarray-label {
    color: var(--secondary-color);
    font-weight: bold;
    margin-bottom: 10px;
    text-align: center;
}

.subarray-sum {
    background: var(--primary-color);
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    font-weight: bold;
    margin-top: 5px;
    display: inline-block;
}
/* Add these to the existing CSS */
.element-value.equal-sum-part1 {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.equal-sum-part2 {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.equal-sum-part3 {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.equal-sum-current {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: equalSumPulse 0.5s ease-in-out;
}

.element-value.equal-sum-split-point {
    background: var(--primary-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--primary-color);
    border: 3px solid white;
    animation: splitPointPulse 1s ease-in-out;
}

@keyframes equalSumPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

@keyframes splitPointPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.equal-sum-result-success {
    background: rgba(40, 167, 69, 0.2);
    border-left: 4px solid var(--success-color);
    padding: 15px;
    border-radius: 10px;
    margin: 10px 0;
}

.equal-sum-result-error {
    background: rgba(220, 53, 69, 0.2);
    border-left: 4px solid var(--danger-color);
    padding: 15px;
    border-radius: 10px;
    margin: 10px 0;
}

.split-parts-container {
    display: flex;
    justify-content: space-between;
    gap: 10px;
    margin: 15px 0;
}

.split-part {
    flex: 1;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    text-align: center;
}

.split-part-title {
    color: var(--secondary-color);
    font-size: 0.9rem;
    margin-bottom: 10px;
    font-weight: bold;
}

.split-part-array {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 5px;
    margin-top: 10px;
}

.split-part-element {
    background: var(--primary-color);
    color: white;
    padding: 8px 12px;
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    font-weight: bold;
}
/* Add these to the existing CSS */
.element-value.sequence-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.sequence-used {
    background: var(--warning-color);
    opacity: 0.6;
    transform: scale(0.9);
}

.element-value.sequence-current {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: sequencePulse 0.5s ease-in-out;
}

.element-value.sequence-error {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: shake 0.5s ease;
}

@keyframes sequencePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.sequence-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--info-color);
}

.sequence-item {
    background: var(--primary-color);
    color: white;
    padding: 8px 12px;
    margin: 5px;
    border-radius: 5px;
    display: inline-block;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
}

.sequence-item:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(108, 92, 231, 0.4);
}

.balanced-string-char {
    display: inline-block;
    width: 40px;
    height: 40px;
    line-height: 40px;
    text-align: center;
    margin: 2px;
    border-radius: 5px;
    font-weight: bold;
    transition: all 0.3s ease;
}

.balanced-string-char.L {
    background: var(--info-color);
    color: white;
}

.balanced-string-char.R {
    background: var(--warning-color);
    color: white;
}

.balanced-string-char.balanced {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

.balanced-string-char.current {
    background: var(--primary-color);
    transform: scale(1.2);
    box-shadow: 0 0 20px var(--primary-color);
    border: 2px solid white;
}
/* Add these to the existing CSS */
.element-value.nice-subarray-odd {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.nice-subarray-even {
    background: var(--info-color);
    transform: scale(1.05);
    box-shadow: 0 0 15px var(--info-color);
}

.element-value.nice-subarray-current {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: niceSubarrayPulse 0.5s ease-in-out;
}

.element-value.nice-subarray-included {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.nice-subarray-boundary {
    background: var(--primary-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--primary-color);
    border: 3px solid white;
}

@keyframes niceSubarrayPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.nice-subarray-results {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--success-color);
}

.nice-subarray-item {
    background: var(--success-color) !important;
    color: white;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
    display: inline-block;
}

.nice-subarray-item:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(0, 184, 148, 0.4);
}
/* Add these to the existing CSS */
.subarray-item {
    background: var(--info-color) !important;
    color: white;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    margin: 2px;
    padding: 5px 8px;
    border-radius: 4px;
    font-size: 0.8rem;
}

.subarray-item:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(116, 185, 255, 0.4);
}
/* Add these to the existing CSS */
.element-value.substring-start {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.substring-end {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.substring-valid {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: substringPulse 0.5s ease-in-out;
}

.element-value.substring-current {
    background: var(--primary-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--primary-color);
    border: 3px solid white;
    animation: currentSubstringPulse 0.5s ease-in-out;
}

@keyframes substringPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes currentSubstringPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.substring-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.substring-results {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--success-color);
}

.valid-substring-item {
    background: var(--success-color) !important;
    color: white;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
    display: inline-block;
}

.valid-substring-item:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(0, 184, 148, 0.4);
}
/* Add these to the existing CSS */
.element-value.turbulent-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: turbulentPulse 0.5s ease-in-out;
}

.element-value.turbulent-included {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.turbulent-max {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: turbulentMaxPulse 1s ease-in-out;
}

.element-value.turbulent-compare-up {
    background: var(--primary-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--primary-color);
    border: 2px solid white;
}

.element-value.turbulent-compare-down {
    background: var(--secondary-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--secondary-color);
    border: 2px solid white;
}

@keyframes turbulentPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes turbulentMaxPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.turbulent-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.turbulent-comparison {
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 10px 0;
    font-family: 'Courier New', monospace;
    font-size: 1.1rem;
}

.comparison-arrow {
    margin: 0 10px;
    font-weight: bold;
}

.comparison-up {
    color: var(--success-color);
}

.comparison-down {
    color: var(--danger-color);
}

.comparison-equal {
    color: var(--warning-color);
}
/* Add these to the existing CSS */
.element-value.reverse-pair-i {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: reversePairPulse 0.5s ease-in-out;
}

.element-value.reverse-pair-j {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: reversePairPulse 0.5s ease-in-out;
}

@keyframes reversePairPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.reverse-pair-connection {
    position: absolute;
    background: var(--info-color);
    height: 3px;
    transform-origin: left center;
    z-index: -1;
}
/* Add these to the existing CSS */
.element-value.local-inversion {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: inversionPulse 0.8s ease-in-out;
}

.element-value.global-inversion {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.inversion-connection-start {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
}

.element-value.inversion-connection-end {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
}

.inversion-connection-line {
    position: absolute;
    height: 3px;
    background: linear-gradient(90deg, var(--danger-color), var(--success-color));
    z-index: 1;
    pointer-events: none;
}

.inversion-matrix {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin: 15px 0;
    border: 1px solid var(--info-color);
}

.matrix-row {
    display: flex;
    justify-content: center;
    margin-bottom: 5px;
}

.matrix-cell {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 2px;
    border-radius: 5px;
    font-weight: bold;
    transition: all 0.3s ease;
}

.matrix-cell.value {
    background: var(--primary-color);
    color: white;
}

.matrix-cell.inversion {
    background: var(--danger-color);
    color: white;
    transform: scale(1.1);
}

.matrix-cell.local {
    background: var(--warning-color);
    color: white;
}

.matrix-cell.header {
    background: var(--secondary-color);
    color: white;
    font-size: 0.8rem;
}

@keyframes inversionPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.inversion-stats {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border-left: 4px solid var(--info-color);
}

.inversion-relationship {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border-left: 4px solid var(--warning-color);
}
/* Add these to the existing CSS */
.range-single {
    background: var(--info-color) !important;
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.range-sequence {
    background: var(--success-color) !important;
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.interval-current {
    background: var(--warning-color) !important;
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
}

.interval-found {
    background: var(--success-color) !important;
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}
/* Add these to the existing CSS */
.balloon-interval {
    background: var(--info-color);
    color: white;
    padding: 8px 12px;
    border-radius: 5px;
    margin: 5px;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
}

.arrow-position {
    background: var(--warning-color);
    color: white;
    padding: 8px 12px;
    border-radius: 5px;
    margin: 5px;
    font-family: 'Courier New', monospace;
    font-weight: bold;
    animation: bounce 0.5s ease;
}

.balloon-burst {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
}

.balloon-active {
    background: var(--primary-color);
    transform: scale(1.05);
    box-shadow: 0 0 15px var(--primary-color);
}

.arrow-shot {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    animation: pulse 0.5s ease;
}

.intervals-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
}

.interval-item {
    display: flex;
    align-items: center;
    margin: 8px 0;
    padding: 8px;
    border-radius: 5px;
    background: rgba(255, 255, 255, 0.1);
}

.interval-range {
    font-family: 'Courier New', monospace;
    margin-right: 15px;
    min-width: 80px;
}

.interval-visual {
    flex: 1;
    height: 20px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    position: relative;
    margin: 0 10px;
}

.interval-bar {
    height: 100%;
    background: var(--primary-color);
    border-radius: 10px;
    position: absolute;
    transition: all 0.5s ease;
}

.arrow-marker {
    position: absolute;
    top: -5px;
    width: 2px;
    height: 30px;
    background: var(--warning-color);
    transform: translateX(-50%);
}

.arrow-label {
    position: absolute;
    top: -25px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--warning-color);
    color: white;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 0.8rem;
    white-space: nowrap;
}
/* Add these to the existing CSS - IMPROVED TIMELINE */
.element-value.teemo-attack {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: teemoAttackPulse 0.5s ease-in-out;
}

.element-value.teemo-poison {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.teemo-overlap {
    background: var(--warning-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--warning-color);
    border: 3px solid white;
    animation: teemoOverlapPulse 1s ease-in-out;
}

@keyframes teemoAttackPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes teemoOverlapPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.teemo-timeline-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 20px;
    margin: 15px 0;
    border: 2px solid var(--danger-color);
    min-height: 200px;
    position: relative;
}

.timeline-axis {
    position: relative;
    height: 60px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 5px;
    margin-bottom: 20px;
    border: 1px solid var(--secondary-color);
}

.timeline-axis-label {
    position: absolute;
    bottom: -25px;
    font-size: 0.8rem;
    color: var(--secondary-color);
    transform: translateX(-50%);
}

.timeline-segments {
    position: relative;
    height: 120px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 8px;
    padding: 10px;
    border: 1px solid var(--info-color);
}

.timeline-segment {
    position: absolute;
    height: 40px;
    background: linear-gradient(45deg, var(--success-color), #00d9a6);
    border-radius: 6px;
    margin: 5px 0;
    transition: all 0.5s ease;
    border: 2px solid white;
    box-shadow: 0 4px 15px rgba(0, 184, 148, 0.4);
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    color: white;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}

.timeline-segment.overlap {
    background: linear-gradient(45deg, var(--warning-color), #ffd166);
    box-shadow: 0 4px 15px rgba(253, 203, 110, 0.4);
    z-index: 10;
}

.timeline-segment.active {
    background: linear-gradient(45deg, var(--danger-color), #ff6b6b);
    box-shadow: 0 4px 20px rgba(255, 107, 107, 0.6);
    z-index: 20;
}

.segment-label {
    position: absolute;
    top: -25px;
    font-size: 0.9rem;
    color: white;
    background: rgba(0, 0, 0, 0.7);
    padding: 2px 8px;
    border-radius: 4px;
    white-space: nowrap;
    font-weight: bold;
}

.segment-duration {
    position: absolute;
    bottom: -20px;
    font-size: 0.8rem;
    color: var(--secondary-color);
    background: rgba(255, 255, 255, 0.1);
    padding: 2px 6px;
    border-radius: 3px;
}

.timeline-legend {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-top: 15px;
    flex-wrap: wrap;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.9rem;
}

.legend-color {
    width: 20px;
    height: 20px;
    border-radius: 4px;
    border: 2px solid white;
}

.legend-normal {
    background: linear-gradient(45deg, var(--success-color), #00d9a6);
}

.legend-overlap {
    background: linear-gradient(45deg, var(--warning-color), #ffd166);
}

.legend-active {
    background: linear-gradient(45deg, var(--danger-color), #ff6b6b);
}

.timeline-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 10px;
    margin-top: 15px;
}

.timeline-stat {
    background: rgba(255, 255, 255, 0.1);
    padding: 10px;
    border-radius: 5px;
    text-align: center;
}

.timeline-stat-value {
    font-size: 1.3rem;
    font-weight: bold;
    color: var(--primary-color);
    margin-top: 5px;
}
/* Add these to the existing CSS */
.element-value.ocean-view {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: oceanViewPulse 1s ease-in-out;
}

.element-value.no-ocean-view {
    background: var(--danger-color);
    opacity: 0.7;
    transform: scale(0.9);
}

.element-value.current-ocean-check {
    background: var(--warning-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--warning-color);
    border: 3px solid white;
    animation: oceanCheckPulse 0.5s ease-in-out;
}

.element-value.max-height-so-far {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

@keyframes oceanViewPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes oceanCheckPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

/* Target Array Styles */
.element-value.target-insert {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: targetInsertPulse 0.8s ease-in-out;
}

.element-value.target-shifted {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
}

.element-value.target-final {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

@keyframes targetInsertPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.ocean-view-explanation, .target-array-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}
/* Add these to the existing CSS */
.element-value.rle-freq {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.rle-val {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.rle-decompressed {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
    animation: rlePulse 0.5s ease-in-out;
}

.element-value.nesting-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: nestingPulse 0.5s ease-in-out;
}

.element-value.nesting-visited {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.nesting-max {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: nestingMaxPulse 1s ease-in-out;
}

@keyframes rlePulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes nestingPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes nestingMaxPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.rle-pair {
    display: flex;
    align-items: center;
    margin: 10px 0;
    padding: 10px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    border-left: 4px solid var(--info-color);
}

.nesting-chain {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border-left: 4px solid var(--warning-color);
}

.nesting-chain-item {
    display: inline-block;
    background: var(--primary-color);
    color: white;
    padding: 8px 12px;
    margin: 5px;
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
}

.nesting-chain-item.current {
    background: var(--warning-color);
    transform: scale(1.1);
}
/* Add these to the existing CSS */
.crawler-path-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 20px;
    margin: 15px 0;
    border: 1px solid var(--info-color);
}

.path-visualization {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
    margin: 15px 0;
    padding: 15px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 8px;
}

.path-segment {
    background: var(--primary-color);
    color: white;
    padding: 8px 15px;
    border-radius: 20px;
    font-weight: bold;
    transition: all 0.3s ease;
}

.path-segment.active {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

.path-segment.main {
    background: var(--info-color);
}

.path-arrow {
    color: var(--warning-color);
    font-weight: bold;
}

.crawler-step {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    padding: 12px;
    margin: 8px 0;
    border-left: 4px solid var(--info-color);
    transition: all 0.3s ease;
}

.crawler-step.active {
    border-left: 4px solid var(--success-color);
    background: rgba(0, 184, 148, 0.1);
}

.log-element {
    background: var(--warning-color);
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    margin: 0 2px;
}

.log-element.current {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 10px var(--success-color);
}
/* Add these to the existing CSS */
.element-value.single-number-bit-checked {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.single-number-group1 {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.single-number-group2 {
    background: var(--primary-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--primary-color);
    border: 2px solid white;
}

.single-number-result {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: nonRepeatingPulse 1s ease-in-out;
}
        /* New styles for the additional operations */
        .string-operation-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            margin: 20px 0;
        }
        
        .string-operation-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }
        
        .string-operation-label {
            color: var(--secondary-color);
            font-size: 0.9rem;
            margin-bottom: 10px;
            font-weight: bold;
            text-align: center;
        }
        
        .bitmask-display {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            border: 1px solid var(--info-color);
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }
        
        .bitmask-bits {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            margin-top: 10px;
        }
        
        .bitmask-bit {
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 5px;
            background: var(--primary-color);
            font-size: 0.8rem;
            font-weight: bold;
        }
        
        .bitmask-bit.active {
            background: var(--success-color);
        }
        
        .string-element {
            background: var(--primary-color);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            margin: 5px;
            display: inline-block;
            transition: all 0.3s ease;
        }
        
        .string-element.consistent {
            background: var(--success-color);
            transform: scale(1.1);
            box-shadow: 0 0 20px var(--success-color);
        }
        
        .string-element.inconsistent {
            background: var(--danger-color);
            transform: scale(1.1);
            box-shadow: 0 0 20px var(--danger-color);
        }
        
        .product-highlight {
            background: var(--warning-color);
            transform: scale(1.2);
            box-shadow: 0 0 25px var(--warning-color);
            border: 3px solid white;
            animation: productPulse 1s ease-in-out;
        }
        
        @keyframes productPulse {
            0%, 100% { transform: scale(1.2); }
            50% { transform: scale(1.4); }
        }
/* Add these to the existing CSS */
.element-value.bitwise-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: bitwisePulse 0.5s ease-in-out;
}

.element-value.bitwise-or-result {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.bitwise-distinct {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: distinctPulse 1s ease-in-out;
}

.bitwise-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

@keyframes bitwisePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes distinctPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}
/* Add these to the existing CSS */
.superstring-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 20px;
    margin: 15px 0;
    border: 1px solid var(--info-color);
}

.superstring-step {
    margin-bottom: 15px;
    padding: 12px;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.1);
    border-left: 4px solid var(--info-color);
}

.superstring-step.active {
    border-left: 4px solid var(--success-color);
    background: rgba(0, 184, 148, 0.1);
}

.superstring-overlap {
    color: var(--warning-color);
    font-weight: bold;
}

.superstring-merged {
    color: var(--success-color);
    font-weight: bold;
}

.superstring-final {
    background: rgba(0, 184, 148, 0.2);
    padding: 15px;
    border-radius: 8px;
    border: 2px solid var(--success-color);
    margin-top: 15px;
}

.string-highlight {
    background: var(--warning-color);
    padding: 2px 6px;
    border-radius: 4px;
    color: white;
    font-weight: bold;
}

.overlap-highlight {
    background: var(--info-color);
    padding: 2px 6px;
    border-radius: 4px;
    color: white;
    font-weight: bold;
}

.superstring-visualization {
    font-family: 'Courier New', monospace;
    background: rgba(0, 0, 0, 0.3);
    padding: 15px;
    border-radius: 8px;
    margin: 10px 0;
    border: 1px solid var(--primary-color);
}
/* Add these to the existing CSS */
.gray-code-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    overflow: hidden;
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
}

.gray-code-table th {
    background: var(--primary-color);
    color: white;
    padding: 12px;
    text-align: center;
    font-weight: bold;
    border-bottom: 2px solid var(--secondary-color);
}

.gray-code-table td {
    padding: 10px 12px;
    text-align: center;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.gray-code-table tr:hover {
    background: rgba(255, 255, 255, 0.1);
}

.gray-code-table .bit-changed {
    background: rgba(255, 193, 7, 0.3);
    font-weight: bold;
}

.gray-code-table .gray-code-cell {
    background: rgba(0, 184, 148, 0.2);
    font-weight: bold;
}

.gray-code-table .step-highlight {
    background: rgba(108, 92, 231, 0.3);
    animation: stepPulse 0.5s ease-in-out;
}

@keyframes stepPulse {
    0%, 100% { background-color: rgba(108, 92, 231, 0.3); }
    50% { background-color: rgba(108, 92, 231, 0.6); }
}

.gray-code-sequence {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
    margin: 15px 0;
    padding: 15px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
}

.gray-code-item {
    padding: 10px 15px;
    background: var(--primary-color);
    color: white;
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    font-weight: bold;
    transition: all 0.3s ease;
    min-width: 60px;
    text-align: center;
}

.gray-code-item.current {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--warning-color);
}

.gray-code-item.changed {
    background: var(--success-color);
    transform: scale(1.05);
}

.gray-code-steps-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    max-height: 300px;
    overflow-y: auto;
}

.gray-code-step {
    padding: 10px;
    margin: 8px 0;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 5px;
    border-left: 4px solid var(--info-color);
    animation: slideIn 0.3s ease;
}

.gray-code-step.active {
    border-left: 4px solid var(--success-color);
    background: rgba(0, 184, 148, 0.1);
}

.gray-code-step .bit-change {
    color: var(--warning-color);
    font-weight: bold;
}

.gray-code-verification {
    background: rgba(40, 167, 69, 0.1);
    border: 1px solid var(--success-color);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
}

.gray-code-verification.success {
    background: rgba(40, 167, 69, 0.1);
    border-color: var(--success-color);
}

.gray-code-verification .checkmark {
    color: var(--success-color);
    font-weight: bold;
    margin-right: 5px;
}
/* Add these to the existing CSS */
.element-value.divisor-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: divisorPulse 0.5s ease-in-out;
}

.element-value.divisor-calculated {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.divisor-too-large {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

.element-value.divisor-too-small {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.divisor-final {
    background: var(--primary-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--primary-color);
    border: 3px solid white;
    animation: divisorFinalPulse 1s ease-in-out infinite;
}

@keyframes divisorPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes divisorFinalPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.divisor-calculation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 10px;
    margin: 10px 0;
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
}

.divisor-calculation-step {
    margin: 5px 0;
    padding: 5px;
    border-left: 3px solid var(--info-color);
    background: rgba(255, 255, 255, 0.05);
}

.divisor-calculation-step.active {
    border-left: 3px solid var(--warning-color);
    background: rgba(253, 203, 110, 0.1);
}

.divisor-binary-search-visualization {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 15px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    margin: 15px 0;
}

.divisor-range {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    max-width: 600px;
}

.divisor-range-item {
    text-align: center;
    padding: 10px;
    min-width: 80px;
    border-radius: 8px;
    transition: all 0.3s ease;
}

.divisor-range-left {
    background: rgba(116, 185, 255, 0.2);
    border: 2px solid var(--info-color);
}

.divisor-range-mid {
    background: rgba(253, 203, 110, 0.3);
    border: 3px solid var(--warning-color);
    transform: scale(1.1);
    font-weight: bold;
}

.divisor-range-right {
    background: rgba(162, 155, 254, 0.2);
    border: 2px solid var(--secondary-color);
}

.divisor-arrow {
    font-size: 1.5rem;
    color: var(--primary-color);
    margin: 0 10px;
}

.divisor-range-value {
    font-size: 1.2rem;
    font-weight: bold;
    margin-bottom: 5px;
}

.divisor-range-label {
    font-size: 0.8rem;
    opacity: 0.8;
}
/* Add these to the existing CSS */
.element-value.h-index-paper {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.h-index-qualified {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: hIndexPulse 1s ease-in-out;
}

.element-value.h-index-disqualified {
    background: var(--danger-color);
    opacity: 0.7;
}

.element-value.h-index-current {
    background: var(--warning-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--warning-color);
    border: 3px solid white;
    animation: hIndexCurrentPulse 0.5s ease-in-out infinite;
}

@keyframes hIndexPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes hIndexCurrentPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.h-index-results {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    border-left: 4px solid var(--info-color);
}

.h-index-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    overflow: hidden;
}

.h-index-table th {
    background: var(--primary-color);
    color: white;
    padding: 12px;
    text-align: left;
    font-weight: bold;
}

.h-index-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.h-index-table tr:last-child td {
    border-bottom: none;
}

.h-index-table tr:hover {
    background: rgba(255, 255, 255, 0.1);
}

.h-index-match {
    background: rgba(0, 184, 148, 0.2);
    font-weight: bold;
}

.h-index-nomatch {
    background: rgba(220, 53, 69, 0.2);
}

.h-index-header {
    background: linear-gradient(45deg, var(--primary-color), var(--info-color));
    padding: 15px;
    border-radius: 10px;
    margin-bottom: 15px;
    text-align: center;
}

.h-index-summary {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    border-left: 4px solid var(--success-color);
}
/* Add these to the existing CSS */
.element-value.capacity-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
    animation: capacityPulse 0.5s ease-in-out;
}

.element-value.capacity-overload {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
}

.element-value.capacity-fits {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
}

.element-value.capacity-current-day {
    background: var(--warning-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--warning-color);
    border: 3px solid white;
}

@keyframes capacityPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.day-container {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 10px;
    margin: 10px 0;
    border: 1px solid var(--info-color);
}

.day-label {
    color: var(--warning-color);
    font-size: 1rem;
    font-weight: bold;
    margin-bottom: 8px;
    text-align: center;
}

.binary-search-range {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border-left: 4px solid var(--primary-color);
}
/* Add to existing CSS */
.element-value.koko-pile {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.koko-current-speed {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: kokoSpeedPulse 0.5s ease-in-out;
}

.element-value.koko-valid-speed {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.koko-invalid-speed {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
    animation: shake 0.5s ease;
}

.element-value.koko-optimal-speed {
    background: var(--primary-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--primary-color);
    border: 3px solid white;
    animation: kokoOptimalPulse 1s ease-in-out infinite;
}

@keyframes kokoSpeedPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes kokoOptimalPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.koko-speed-display {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    text-align: center;
    border-left: 4px solid var(--warning-color);
}

.speed-value {
    font-size: 2rem;
    font-weight: bold;
    color: var(--warning-color);
    margin: 10px 0;
}

.koko-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.hour-calc {
    background: rgba(255, 193, 7, 0.2);
    padding: 10px;
    border-radius: 5px;
    margin: 5px 0;
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
}
/* Add to the end of CSS for better message visibility */
.final-koko-message {
    background: rgba(108, 92, 231, 0.2);
    border: 2px solid var(--primary-color);
    border-radius: 10px;
    padding: 15px;
    margin: 15px 0;
    text-align: center;
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--primary-color);
    animation: pulse 2s infinite;
}
/* Add these to the existing CSS */
.element-version.good-version {
    background: var(--success-color);
    transform: scale(1.05);
    box-shadow: 0 0 15px var(--success-color);
    border: 2px solid white;
}

.element-version.bad-version {
    background: var(--danger-color);
    transform: scale(1.05);
    box-shadow: 0 0 15px var(--danger-color);
    border: 2px solid white;
}

.element-version.current-version {
    background: var(--warning-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: versionPulse 0.5s ease-in-out;
}

.element-version.first-bad-found {
    background: var(--info-color);
    transform: scale(1.4);
    box-shadow: 0 0 30px var(--info-color);
    border: 3px solid white;
    animation: firstBadFound 1s ease-in-out;
}

.element-version.left-search {
    background: var(--primary-color);
    opacity: 0.7;
}

.element-version.right-search {
    background: var(--secondary-color);
    opacity: 0.7;
}

@keyframes versionPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

@keyframes firstBadFound {
    0%, 100% { transform: scale(1.4); }
    50% { transform: scale(1.6); }
}

.version-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}
/* Add these to the existing CSS */
.element-value.robbed-house {
    background: var(--success-color) !important;
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    position: relative;
    animation: robbedHousePulse 1s ease-in-out;
}

.element-value.skipped-house {
    background: var(--danger-color) !important;
    opacity: 0.7;
    transform: scale(0.9);
}

@keyframes robbedHousePulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.house-arrow {
    position: absolute;
    top: -30px;
    left: 50%;
    transform: translateX(-50%);
    color: var(--success-color);
    font-size: 1.5rem;
    animation: arrowBounce 1s ease-in-out infinite;
}

@keyframes arrowBounce {
    0%, 100% { transform: translateX(-50%) translateY(0); }
    50% { transform: translateX(-50%) translateY(-10px); }
}

.robbed-house-label {
    position: absolute;
    top: -50px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--success-color);
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 0.8rem;
    font-weight: bold;
    white-space: nowrap;
}

.dp-table-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin: 15px 0;
    border: 1px solid var(--info-color);
}

.dp-table {
    width: 100%;
    border-collapse: collapse;
    margin: 10px 0;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 5px;
    overflow: hidden;
}

.dp-table th {
    background: var(--primary-color);
    color: white;
    padding: 12px;
    text-align: center;
    font-weight: bold;
    border-bottom: 2px solid var(--secondary-color);
}

.dp-table td {
    padding: 10px;
    text-align: center;
    border: 1px solid rgba(255, 255, 255, 0.1);
    transition: all 0.3s ease;
}

.dp-table tr:hover {
    background: rgba(255, 255, 255, 0.1);
}

.dp-cell-highlight {
    background: var(--warning-color) !important;
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--warning-color);
    animation: dpCellPulse 0.5s ease-in-out;
}

.dp-cell-optimal {
    background: var(--success-color) !important;
    font-weight: bold;
    color: white;
}

.dp-cell-option1 {
    background: rgba(255, 107, 107, 0.3) !important;
}

.dp-cell-option2 {
    background: rgba(107, 255, 107, 0.3) !important;
}

@keyframes dpCellPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); }
}

.decision-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border-left: 4px solid var(--info-color);
    font-size: 0.9rem;
}

.option-container {
    display: flex;
    justify-content: space-between;
    margin: 10px 0;
    gap: 10px;
}

.option-box {
    flex: 1;
    padding: 10px;
    border-radius: 8px;
    text-align: center;
    transition: all 0.3s ease;
}

.option-box.skip {
    background: rgba(255, 107, 107, 0.2);
    border: 2px solid var(--danger-color);
}

.option-box.rob {
    background: rgba(107, 255, 107, 0.2);
    border: 2px solid var(--success-color);
}

.option-box.selected {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}

.backtrack-step {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    padding: 10px;
    margin: 5px 0;
    border-left: 3px solid var(--warning-color);
    font-size: 0.85rem;
    animation: slideIn 0.3s ease;
}

.backtrack-step.final {
    border-left: 3px solid var(--success-color);
    background: rgba(0, 184, 148, 0.1);
}

.house-robber-summary {
    background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
    color: white;
    padding: 15px;
    border-radius: 10px;
    margin: 15px 0;
    text-align: center;
}

.robber-results {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border-left: 4px solid var(--success-color);
}
/* Add these to the existing CSS */
.element-value.deletion-highlight {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: deletionPulse 0.5s ease-in-out;
}

.element-value.forward-sum-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.backward-sum-highlight {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.max-subarray-highlight {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: maxSubarrayPulse 1s ease-in-out;
}

@keyframes deletionPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes maxSubarrayPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.leetcode-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--primary-color);
}

.leetcode-title {
    color: var(--primary-color);
    font-size: 1.1rem;
    font-weight: bold;
    margin-bottom: 10px;
    text-align: center;
}
/* Add these to the existing CSS */
.pair-element {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 10px;
    padding: 15px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    border: 2px solid var(--primary-color);
    transition: all 0.3s ease;
    min-width: 100px;
}

.pair-value {
    font-size: 1.2rem;
    font-weight: bold;
    color: white;
    margin-bottom: 5px;
    text-align: center;
}

.pair-index {
    font-size: 0.8rem;
    color: var(--secondary-color);
    margin-top: 5px;
}

.pair-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 15px;
    padding: 20px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 15px;
    margin: 20px 0;
}

.pair-active {
    background: rgba(108, 92, 231, 0.3);
    border-color: var(--primary-color);
    transform: scale(1.05);
    box-shadow: 0 0 20px rgba(108, 92, 231, 0.5);
}

.pair-chain-included {
    background: rgba(0, 184, 148, 0.3);
    border-color: var(--success-color);
    border: 3px solid var(--success-color);
}

.pair-chain-compatible {
    background: rgba(116, 185, 255, 0.3);
    border-color: var(--info-color);
}

.pair-chain-current {
    background: rgba(253, 203, 110, 0.3);
    border-color: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 25px rgba(253, 203, 110, 0.7);
}

.pair-connector {
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--primary-color);
    font-size: 1.5rem;
    margin: 0 10px;
}

.pair-chain-line {
    height: 3px;
    background: var(--success-color);
    margin: 0 10px;
    flex-grow: 1;
    position: relative;
    overflow: hidden;
}

.pair-chain-line::after {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.5), transparent);
    animation: chainFlow 2s infinite;
}

@keyframes chainFlow {
    0% { left: -100%; }
    100% { left: 100%; }
}

.pair-chain-container {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-wrap: wrap;
    padding: 20px;
    margin: 20px 0;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 15px;
    border: 1px solid var(--info-color);
}

.pair-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    overflow: hidden;
}

.pair-table th {
    background: var(--primary-color);
    color: white;
    padding: 12px;
    text-align: left;
    font-weight: bold;
}

.pair-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.pair-table tr:hover {
    background: rgba(255, 255, 255, 0.1);
}

.pair-table .dp-highlight {
    background: rgba(253, 203, 110, 0.3);
    font-weight: bold;
}

.pair-table .chain-highlight {
    background: rgba(0, 184, 148, 0.3);
    font-weight: bold;
}
/* Add these to the existing CSS */
.element-value.arithmetic-slice-start {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.arithmetic-slice-middle {
    background: var(--warning-color);
    transform: scale(1.05);
    box-shadow: 0 0 15px var(--warning-color);
    border: 1px solid white;
}

.element-value.arithmetic-slice-end {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: arithmeticSlicePulse 1s ease-in-out;
}

.element-value.arithmetic-slice-current {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: arithmeticSliceCurrent 0.5s ease-in-out infinite;
}

.element-value.arithmetic-difference-match {
    background: var(--primary-color);
    transform: scale(1.15);
    box-shadow: 0 0 20px var(--primary-color);
    border: 2px solid white;
}

@keyframes arithmeticSlicePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes arithmeticSliceCurrent {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.arithmetic-slice-item {
    background: var(--info-color) !important;
    color: white;
    font-family: 'Courier New', monospace;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
    transition: all 0.3s ease;
}

.arithmetic-slice-item:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(116, 185, 255, 0.4);
}

.arithmetic-results {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--info-color);
}
/* Add these to the existing CSS */
.grid-container {
    display: grid;
    gap: 10px;
    margin: 20px 0;
    padding: 15px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
}

.grid-cell {
    background: var(--primary-color);
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 5px;
    font-weight: bold;
    min-height: 60px;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.grid-cell:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(108, 92, 231, 0.4);
}

.grid-cell.dp-cell {
    background: var(--info-color);
    font-family: 'Courier New', monospace;
}

.grid-cell.current-cell {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: pulse 0.5s ease;
}

.grid-cell.above-cell {
    background: var(--secondary-color);
    opacity: 0.8;
}

.grid-cell.left-cell {
    background: var(--danger-color);
    opacity: 0.8;
}

.grid-cell.start-cell {
    background: var(--success-color);
    border: 3px solid white;
}

.grid-cell.end-cell {
    background: var(--warning-color);
    border: 3px solid white;
    animation: bounce 0.5s ease;
}

.grid-cell.path-count {
    background: var(--info-color);
    font-size: 0.9rem;
}

.dp-array-container {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: 10px;
    margin: 20px 0;
    padding: 15px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
}

.dp-array-element {
    background: var(--primary-color);
    color: white;
    width: 70px;
    height: 70px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 10px;
    font-weight: bold;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    position: relative;
}

.dp-array-element.current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
}

.dp-array-element.updated {
    background: var(--success-color);
    animation: highlight 0.5s ease;
}

.dp-array-element .dp-index {
    position: absolute;
    top: 5px;
    left: 5px;
    font-size: 0.7rem;
    opacity: 0.8;
}

.dp-array-element .dp-value {
    font-size: 1.2rem;
    font-weight: bold;
}

.dp-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border-left: 4px solid var(--info-color);
}

.path-visualization {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin: 15px 0;
    font-family: 'Courier New', monospace;
}

.path-step {
    margin: 5px 0;
    padding: 8px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 5px;
    animation: slideIn 0.3s ease;
}

.path-step.active {
    background: rgba(255, 193, 7, 0.2);
    border-left: 3px solid var(--warning-color);
}

.dp-formula {
    background: rgba(0, 0, 0, 0.3);
    padding: 10px;
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    margin: 10px 0;
    font-size: 0.9rem;
    color: var(--warning-color);
}

.unique-paths-stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin: 15px 0;
}

.stats-item {
    background: rgba(255, 255, 255, 0.05);
    padding: 10px;
    border-radius: 5px;
    text-align: center;
}

.stats-label {
    font-size: 0.8rem;
    color: var(--secondary-color);
    margin-bottom: 5px;
}

.stats-value {
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--primary-color);
}
/* Add these to the existing CSS */
/* Improve DP table visibility */
/* Updated DP Table CSS */
.dp-table-container {
    margin: 20px 0;
    overflow-x: auto;
    max-height: 500px;
    overflow-y: auto;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    padding: 10px;
}

.dp-table {
    width: auto;
    min-width: 100%;
    border-collapse: collapse;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 5px;
    overflow: hidden;
    font-family: 'Courier New', monospace;
}

.dp-table th {
    background: var(--primary-color);
    color: white;
    padding: 8px 4px;
    text-align: center;
    font-weight: bold;
    font-size: 0.8rem;
    position: sticky;
    top: 0;
    z-index: 10;
    min-width: 40px;
    max-width: 60px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.dp-table td {
    padding: 6px 4px;
    text-align: center;
    border: 1px solid rgba(255, 255, 255, 0.1);
    min-width: 40px;
    max-width: 60px;
    font-size: 0.8rem;
    height: 35px;
    overflow: hidden;
    text-overflow: ellipsis;
}

.dp-table tr:hover {
    background: rgba(255, 255, 255, 0.05);
}

.dp-cell {
    transition: all 0.3s ease;
    cursor: pointer;
    position: relative;
}

.dp-cell:hover::after {
    content: attr(data-tooltip);
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: var(--dark-color);
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 0.8rem;
    white-space: nowrap;
    z-index: 100;
    pointer-events: none;
    margin-bottom: 5px;
}

.dp-cell.initial {
    background: rgba(255, 255, 255, 0.05);
    color: var(--secondary-color);
    font-weight: bold;
}

.dp-cell.current {
    background: var(--warning-color);
    color: black;
    transform: scale(1.05);
    box-shadow: 0 0 10px var(--warning-color);
    font-weight: bold;
    z-index: 5;
    position: relative;
}

.dp-cell.updated {
    background: var(--success-color);
    color: white;
    animation: cellUpdate 0.5s ease;
}

.dp-cell.impossible {
    background: rgba(220, 53, 69, 0.3);
    color: #ff6b6b;
    font-weight: bold;
}

.dp-cell.solution {
    background: var(--info-color);
    color: white;
    font-weight: bold;
    border: 2px solid white;
}

.dp-cell.path {
    background: linear-gradient(135deg, var(--success-color), var(--info-color));
    color: white;
    animation: pathPulse 1.5s ease-in-out infinite;
    border: 2px solid white;
}

@keyframes cellUpdate {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

@keyframes pathPulse {
    0%, 100% { 
        transform: scale(1);
        box-shadow: 0 0 5px var(--success-color);
    }
    50% { 
        transform: scale(1.05);
        box-shadow: 0 0 15px var(--success-color);
    }
}

/* For large tables, make it scrollable with sticky headers */
.dp-table thead th:first-child {
    position: sticky;
    left: 0;
    z-index: 20;
    background: var(--primary-color);
}

.dp-table tbody td:first-child {
    position: sticky;
    left: 0;
    z-index: 15;
    background: rgba(108, 92, 231, 0.9);
    color: white;
    font-weight: bold;
}

/* Compact view for large amounts */
.compact-view .dp-table th,
.compact-view .dp-table td {
    padding: 4px 2px;
    font-size: 0.7rem;
    min-width: 30px;
    max-width: 40px;
}

.compact-view .dp-table {
    font-size: 0.7rem;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .dp-table th,
    .dp-table td {
        padding: 4px 2px;
        font-size: 0.7rem;
        min-width: 30px;
    }
    
    .dp-table-container {
        max-height: 400px;
    }
}

/* Column grouping for better readability */
.amount-group {
    background: rgba(255, 193, 7, 0.1);
}

.amount-group-header {
    background: var(--warning-color) !important;
    color: black !important;
    font-weight: bold;
}

/* Virtual scrolling optimization */
.dp-virtual-scroll {
    height: 400px;
    overflow-y: auto;
}

.dp-virtual-scroll .dp-table {
    position: relative;
}

/* Tooltip styles */
.cell-tooltip {
    display: none;
    position: absolute;
    background: var(--dark-color);
    color: white;
    padding: 8px 12px;
    border-radius: 5px;
    font-size: 0.9rem;
    z-index: 1000;
    max-width: 300px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
    pointer-events: none;
}

.cell-tooltip.show {
    display: block;
}
@keyframes cellUpdate {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); }
}

@keyframes pathPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

.coin-change-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    border-left: 4px solid var(--warning-color);
}

.coin-change-steps {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    max-height: 300px;
    overflow-y: auto;
}

.coin-change-step {
    padding: 8px 10px;
    margin: 5px 0;
    border-radius: 5px;
    background: rgba(255, 255, 255, 0.05);
    font-size: 0.9rem;
    border-left: 3px solid var(--info-color);
}

.coin-change-step.active {
    background: rgba(255, 193, 7, 0.1);
    border-left: 3px solid var(--warning-color);
    font-weight: bold;
}

.solution-coins {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
    margin: 15px 0;
}

.solution-coin {
    background: var(--success-color);
    color: white;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 1.2rem;
    animation: coinBounce 0.5s ease;
}

@keyframes coinBounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
}

.coin-highlight {
    background: var(--warning-color) !important;
    transform: scale(1.2);
    box-shadow: 0 0 20px var(--warning-color);
    border: 3px solid white !important;
}
/* Add these to the existing CSS */
.decode-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 20px;
    margin: 15px 0;
    border: 1px solid var(--info-color);
}

.decode-step {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    padding: 12px;
    margin: 10px 0;
    border-left: 4px solid var(--info-color);
    animation: slideIn 0.5s ease;
}

.decode-step.active {
    border-left: 4px solid var(--success-color);
    background: rgba(0, 184, 148, 0.1);
}

.decode-step.invalid {
    border-left: 4px solid var(--danger-color);
    background: rgba(255, 118, 117, 0.1);
}

.decode-digit {
    display: inline-block;
    width: 40px;
    height: 40px;
    line-height: 40px;
    text-align: center;
    background: var(--primary-color);
    color: white;
    border-radius: 8px;
    margin: 0 5px;
    font-weight: bold;
    transition: all 0.3s ease;
}

.decode-digit.current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 15px var(--warning-color);
}

.decode-digit.valid {
    background: var(--success-color);
    transform: scale(1.1);
}

.decode-digit.invalid {
    background: var(--danger-color);
    opacity: 0.7;
}

.decode-digit.pair {
    background: var(--info-color);
    width: 60px;
}

.dp-array-container {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin: 15px 0;
    flex-wrap: wrap;
}

.dp-element {
    display: flex;
    flex-direction: column;
    align-items: center;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    padding: 10px;
    min-width: 60px;
    transition: all 0.3s ease;
}

.dp-value {
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--primary-color);
    margin-bottom: 5px;
}

.dp-index {
    font-size: 0.8rem;
    color: var(--secondary-color);
}

.dp-element.active {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--warning-color);
}

.dp-element.updated {
    background: var(--success-color);
    animation: pulse 0.5s ease;
}

.decoding-example {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    padding: 10px;
    margin: 10px 0;
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
}

.letter-mapping {
    display: inline-block;
    width: 30px;
    height: 30px;
    line-height: 30px;
    text-align: center;
    background: var(--primary-color);
    color: white;
    border-radius: 5px;
    margin: 0 3px;
    font-weight: bold;
}

.letter-mapping.valid {
    background: var(--success-color);
}
/* Add these to the existing CSS */
.element-value.partition-included {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
}

.element-value.partition-excluded {
    background: var(--info-color);
    opacity: 0.6;
    transform: scale(0.9);
}

.element-value.partition-current {
    background: var(--warning-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--warning-color);
    border: 3px solid white;
    animation: partitionPulse 0.5s ease-in-out;
}

@keyframes partitionPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.partition-table {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
    gap: 5px;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
}

.partition-cell {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 5px;
    padding: 8px;
    text-align: center;
    font-weight: bold;
    transition: all 0.3s ease;
}

.partition-cell.target {
    background: var(--warning-color);
    color: white;
}

.partition-cell.possible {
    background: var(--success-color);
    color: white;
    animation: cellHighlight 0.5s ease;
}

@keyframes cellHighlight {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

.partition-cell.impossible {
    background: var(--danger-color);
    color: white;
    opacity: 0.7;
}

.partition-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.subset-result {
    background: var(--primary-color);
    color: white;
    padding: 10px;
    border-radius: 5px;
    margin: 5px;
    font-family: 'Courier New', monospace;
    display: inline-block;
}
/* Add these to the existing CSS */
.element-value.target-sum-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: targetSumPulse 0.5s ease-in-out;
}

.element-value.target-sum-positive {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.target-sum-negative {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

.element-value.target-sum-match {
    background: var(--info-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--info-color);
    border: 3px solid white;
    animation: targetSumMatch 1s ease-in-out;
}

@keyframes targetSumPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes targetSumMatch {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.target-sum-results {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--info-color);
}

.target-sum-expression {
    background: var(--primary-color) !important;
    color: white;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
    display: inline-block;
}

.target-sum-expression:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(108, 92, 231, 0.4);
}
/* Add these for Word Break */
.element-value.word-break-match {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: wordBreakPulse 0.8s ease-in-out;
}

.element-value.word-break-checking {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.word-break-dp-true {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

@keyframes wordBreakPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.word-break-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 20px;
    margin: 20px 0;
}

.word-break-string {
    font-family: 'Courier New', monospace;
    font-size: 1.5rem;
    text-align: center;
    margin: 20px 0;
    padding: 10px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 5px;
    letter-spacing: 2px;
}

.word-break-segment {
    display: inline-block;
    padding: 5px 10px;
    margin: 2px;
    border-radius: 3px;
    background: var(--primary-color);
    color: white;
    font-weight: bold;
    animation: slideIn 0.5s ease;
}

.dp-table {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
    gap: 5px;
    margin: 20px 0;
    justify-items: center;
}

.dp-cell {
    width: 40px;
    height: 40px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 5px;
    font-weight: bold;
    background: rgba(255, 255, 255, 0.1);
    transition: all 0.3s ease;
}

.dp-cell.true {
    background: var(--success-color);
    transform: scale(1.1);
}

.dp-cell.false {
    background: rgba(255, 255, 255, 0.1);
}

.dp-cell.current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 15px var(--warning-color);
}
/* Add or update these styles in the CSS section */
.lru-capacity-input,
.lru-operation-input {
    background: rgba(255, 255, 255, 0.15) !important;
    border: 1px solid var(--primary-color) !important;
    color: white !important; /* Changed from black to white for better contrast */
    padding: 10px !important;
    border-radius: 8px !important;
    text-align: center !important;
    font-weight: bold !important;
}

.lru-capacity-input:focus,
.lru-operation-input:focus {
    background: rgba(255, 255, 255, 0.25) !important;
    border-color: var(--secondary-color) !important;
    box-shadow: 0 0 10px var(--primary-color) !important;
    color: white !important;
    outline: none !important;
}

/* Placeholder color */
.lru-capacity-input::placeholder,
.lru-operation-input::placeholder {
    color: rgba(255, 255, 255, 0.7) !important;
    font-weight: normal !important;
}

/* GET feedback message */
.get-feedback {
    font-size: 1rem !important;
    font-weight: bold !important;
    color: white !important;
    padding: 12px 16px !important;
    border-radius: 8px !important;
    margin-top: 10px !important;
    text-align: center !important;
    animation: fadeIn 0.5s ease !important;
    border: 2px solid rgba(255, 255, 255, 0.3) !important;
}

.get-feedback-success {
    background: linear-gradient(135deg, var(--success-color), #00a884) !important;
    box-shadow: 0 4px 15px rgba(0, 184, 148, 0.4) !important;
}

.get-feedback-error {
    background: linear-gradient(135deg, var(--danger-color), #e74c3c) !important;
    box-shadow: 0 4px 15px rgba(255, 118, 117, 0.4) !important;
}

/* Enhanced hit animation */
@keyframes blinkGreen {
    0%, 100% { 
        background-color: var(--primary-color);
        transform: scale(1);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }
    50% { 
        background-color: var(--success-color);
        transform: scale(1.2);
        box-shadow: 0 0 30px var(--success-color);
    }
}

.lru-hit-animation {
    animation: blinkGreen 0.6s ease-in-out 3 !important;
}

/* Enhance array element visibility */
.lru-array-key {
    font-size: 1.3rem !important;
    font-weight: bold !important;
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3) !important;
}

.lru-array-data {
    font-size: 0.9rem !important;
    opacity: 1 !important;
    margin-top: 3px !important;
    font-weight: normal !important;
}

/* Make hashmap entries more visible */
.lru-hashmap-key {
    font-size: 1.1rem !important;
    font-weight: bold !important;
    margin-bottom: 5px !important;
}

.lru-hashmap-value {
    font-size: 1rem !important;
    opacity: 1 !important;
    font-weight: normal !important;
}

/* Add fade animation */
@keyframes fadeIn {
    from { 
        opacity: 0; 
        transform: translateY(-10px) scale(0.95); 
    }
    to { 
        opacity: 1; 
        transform: translateY(0) scale(1); 
    }
}
/* Add these to the existing CSS */
.lru-cache-container {
    display: flex;
    flex-direction: column;
    gap: 20px;
    margin: 20px 0;
}

.lru-cache-visualization {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 15px;
    padding: 20px;
    border: 2px solid var(--info-color);
}

.lru-cache-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 10px;
    border-bottom: 2px solid var(--primary-color);
}

.lru-cache-stats {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
}

.lru-stat-card {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 10px 15px;
    text-align: center;
    min-width: 120px;
}

.lru-stat-label {
    font-size: 0.9rem;
    color: var(--secondary-color);
    margin-bottom: 5px;
}

.lru-stat-value {
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--primary-color);
}

.lru-cache-sections {
    display: flex;
    gap: 30px;
    margin-bottom: 20px;
}

.lru-section {
    flex: 1;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 10px;
    padding: 15px;
}

.lru-section-title {
    color: var(--info-color);
    font-size: 1.1rem;
    font-weight: bold;
    margin-bottom: 15px;
    text-align: center;
    border-bottom: 1px solid var(--info-color);
    padding-bottom: 5px;
}
/* Make the whole LRU cache section more visible */
.lru-cache-container {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 15px;
    padding: 20px;
    border: 2px solid var(--primary-color);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
}

.lru-cache-header h4 {
    color: var(--info-color);
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

.lru-stat-card {
    background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
    border: 1px solid rgba(255,255,255,0.1);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
}

.lru-stat-value {
    font-size: 1.4rem;
    color: var(--primary-color);
    text-shadow: 0 2px 4px rgba(108, 92, 231, 0.3);
}

/* Make operation buttons more visible */
.lru-operation-btn {
    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-weight: bold;
    box-shadow: 0 4px 15px rgba(108, 92, 231, 0.3);
}

.lru-operation-btn:hover {
    background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(108, 92, 231, 0.4);
}

/* Make cache elements stand out */
.lru-array-value {
    background: linear-gradient(135deg, var(--primary-color), #7b6ce6);
    border: 2px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 6px 20px rgba(108, 92, 231, 0.3);
}

.lru-hashmap-entry {
    background: linear-gradient(135deg, var(--warning-color), #fdcb6e);
    border: 2px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 4px 15px rgba(253, 203, 110, 0.3);
}
.lru-array-container {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
    min-height: 100px;
    padding: 15px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
}

.lru-array-element {
    display: flex;
    flex-direction: column;
    align-items: center;
    transition: all 0.3s ease;
}

.lru-array-value {
    background: var(--primary-color);
    color: white;
    width: 60px;
    height: 60px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    border-radius: 10px;
    font-weight: bold;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    transition: all 0.3s ease;
}

.lru-array-key {
    font-size: 1.1rem;
    font-weight: bold;
}

.lru-array-data {
    font-size: 0.8rem;
    opacity: 0.9;
}

.lru-array-index {
    margin-top: 5px;
    font-size: 0.8rem;
    color: var(--secondary-color);
}

.lru-hashmap-container {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: 10px;
    padding: 15px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
}

.lru-hashmap-entry {
    background: var(--warning-color);
    color: white;
    padding: 10px;
    border-radius: 8px;
    text-align: center;
    transition: all 0.3s ease;
}

.lru-hashmap-key {
    font-weight: bold;
    font-size: 1rem;
}

.lru-hashmap-value {
    font-size: 0.9rem;
    opacity: 0.9;
}

.lru-hashmap-index {
    font-size: 0.8rem;
    color: rgba(255, 255, 255, 0.7);
    margin-top: 3px;
}

.lru-cache-operations {
    display: flex;
    gap: 10px;
    justify-content: center;
    flex-wrap: wrap;
}

.lru-operation-input {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid var(--primary-color);
    color: white;
    padding: 10px;
    border-radius: 8px;
    text-align: center;
    width: 150px;
}

.lru-operation-btn {
    background: var(--primary-color);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.lru-operation-btn:hover {
    background: var(--secondary-color);
    transform: translateY(-2px);
}

.lru-log {
    background: rgba(0, 0, 0, 0.3);
    border-radius: 8px;
    padding: 15px;
    margin-top: 20px;
    max-height: 200px;
    overflow-y: auto;
}

.lru-log-title {
    color: var(--info-color);
    font-size: 1rem;
    margin-bottom: 10px;
}

.lru-log-entry {
    padding: 8px;
    margin: 5px 0;
    border-radius: 5px;
    background: rgba(255, 255, 255, 0.1);
    font-size: 0.9rem;
    border-left: 4px solid var(--info-color);
    animation: slideIn 0.3s ease;
}

.lru-log-success {
    border-left-color: var(--success-color);
}

.lru-log-warning {
    border-left-color: var(--warning-color);
}

.lru-log-danger {
    border-left-color: var(--danger-color);
}

/* LRU Cache specific animations */
.lru-access-animation {
    animation: lruAccess 1s ease;
}

.lru-insert-animation {
    animation: lruInsert 1s ease;
}

.lru-evict-animation {
    animation: lruEvict 1s ease;
}

.lru-hit-animation {
    animation: lruHit 1s ease;
}

.lru-miss-animation {
    animation: lruMiss 1s ease;
}

@keyframes lruAccess {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); box-shadow: 0 0 20px var(--info-color); }
    100% { transform: scale(1); }
}

@keyframes lruInsert {
    0% { transform: scale(0); opacity: 0; }
    70% { transform: scale(1.1); opacity: 1; }
    100% { transform: scale(1); opacity: 1; }
}

@keyframes lruEvict {
    0% { transform: scale(1); opacity: 1; }
    100% { transform: scale(0); opacity: 0; }
}

@keyframes lruHit {
    0% { background-color: var(--primary-color); }
    50% { background-color: var(--success-color); }
    100% { background-color: var(--primary-color); }
}

@keyframes lruMiss {
    0% { background-color: var(--primary-color); }
    50% { background-color: var(--danger-color); }
    100% { background-color: var(--primary-color); }
}

/* Capacity selector */
.lru-capacity-selector {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 20px;
    justify-content: center;
}

.lru-capacity-input {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid var(--primary-color);
    color: white;
    padding: 8px 12px;
    border-radius: 8px;
    width: 100px;
    text-align: center;
}

.lru-cache-empty {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 40px;
    color: var(--secondary-color);
}

.lru-cache-empty i {
    font-size: 3rem;
    margin-bottom: 15px;
    opacity: 0.5;
}
/* Add to existing media query */
@media (max-width: 768px) {
    .lru-cache-sections {
        flex-direction: column;
    }
    
    .lru-cache-stats {
        justify-content: center;
    }
    
    .lru-stat-card {
        min-width: 100px;
    }
    
    .lru-cache-operations {
        flex-direction: column;
        align-items: center;
    }
    
    .lru-operation-input {
        width: 100%;
        max-width: 200px;
    }
}
/* Add these to the existing CSS */
.lfu-container {
    display: flex;
    flex-direction: column;
    gap: 20px;
    margin: 20px 0;
}

.lfu-header {
    text-align: center;
    color: var(--primary-color);
    font-size: 1.5rem;
    margin-bottom: 15px;
}

.lfu-stats {
    display: flex;
    justify-content: space-around;
    margin-bottom: 15px;
    flex-wrap: wrap;
    gap: 10px;
}

.lfu-stat-card {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 10px 15px;
    text-align: center;
    min-width: 150px;
}

.lfu-stat-value {
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--primary-color);
}

.lfu-visualization {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    justify-content: center;
}

.lfu-section {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    min-width: 300px;
    flex: 1;
}

.lfu-section-title {
    color: var(--secondary-color);
    font-size: 1.1rem;
    margin-bottom: 10px;
    text-align: center;
    border-bottom: 2px solid var(--primary-color);
    padding-bottom: 5px;
}

.bucket-container {
    display: flex;
    flex-direction: column;
    gap: 15px;
    margin-top: 10px;
}

.bucket {
    background: rgba(108, 92, 231, 0.1);
    border: 1px solid var(--primary-color);
    border-radius: 8px;
    padding: 10px;
}

.bucket-header {
    display: flex;
    justify-content: space-between;
    margin-bottom: 10px;
    font-size: 0.9rem;
    color: var(--secondary-color);
}

.bucket-items {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    min-height: 60px;
}

.bucket-item {
    background: var(--primary-color);
    color: white;
    padding: 8px 12px;
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    position: relative;
    min-width: 60px;
    text-align: center;
}

.bucket-item.found {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

.bucket-item.not-found {
    background: var(--danger-color);
    opacity: 0.7;
}

.bucket-item.lfu-element {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--warning-color);
}

.bucket-item .item-key {
    font-weight: bold;
    font-size: 1.1rem;
}

.bucket-item .item-value {
    font-size: 0.8rem;
    opacity: 0.8;
}

.bucket-item .item-freq {
    position: absolute;
    top: -8px;
    right: -8px;
    background: var(--info-color);
    color: white;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    font-size: 0.7rem;
    display: flex;
    align-items: center;
    justify-content: center;
}

.hashmap-container {
    max-height: 200px;
    overflow-y: auto;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 8px;
    padding: 10px;
}

.hashmap-entry {
    display: flex;
    justify-content: space-between;
    padding: 8px;
    margin: 5px 0;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
}

.hashmap-key {
    color: var(--secondary-color);
}

.hashmap-value {
    color: var(--info-color);
}

.lfu-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
    margin-top: 20px;
}

.lfu-input-group {
    display: flex;
    gap: 10px;
}

.lfu-operation-log {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    max-height: 150px;
    overflow-y: auto;
    margin-top: 15px;
}

.lfu-log-entry {
    padding: 5px 10px;
    margin: 3px 0;
    border-radius: 5px;
    background: rgba(255, 255, 255, 0.1);
    font-size: 0.85rem;
    font-family: 'Courier New', monospace;
}

.lfu-log-get {
    border-left: 4px solid var(--info-color);
}

.lfu-log-put {
    border-left: 4px solid var(--success-color);
}

.lfu-log-evict {
    border-left: 4px solid var(--danger-color);
}

.lfu-log-update {
    border-left: 4px solid var(--warning-color);
}

.lfu-highlight {
    animation: lfuPulse 0.5s ease-in-out;
}

@keyframes lfuPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); }
}
/* Update CSS for LFU controls */
.lfu-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
    margin-top: 20px;
}

.lfu-input-group {
    display: flex;
    gap: 5px;
    flex-wrap: wrap;
}

.lfu-input-group .form-control {
    min-width: 120px;
}

.lfu-input-group .btn {
    white-space: nowrap;
}
/* Add these to the existing CSS */
.element-value.median-element {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: medianPulse 1s ease-in-out;
}

.element-value.max-heap-element {
    background: var(--primary-color);
    border: 2px solid white;
}

.element-value.min-heap-element {
    background: var(--secondary-color);
    border: 2px solid white;
}

.element-value.invalid-element {
    background: var(--danger-color);
    opacity: 0.5;
    text-decoration: line-through;
    transform: scale(0.9);
}

.element-value.window-boundary {
    border: 3px dashed var(--warning-color);
}

.element-value.current-median {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: currentMedianPulse 1.5s ease-in-out infinite;
}

@keyframes medianPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes currentMedianPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.median-visualization-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    margin: 20px 0;
}

.heaps-container {
    display: flex;
    justify-content: space-around;
    width: 100%;
    margin: 15px 0;
}

.heap-box {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    width: 45%;
    min-height: 150px;
}

.heap-title {
    color: var(--secondary-color);
    font-size: 1.1rem;
    font-weight: bold;
    margin-bottom: 10px;
    text-align: center;
}

.heap-elements {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    justify-content: center;
    min-height: 100px;
    align-items: center;
}

.median-value-display {
    background: var(--success-color);
    color: white;
    padding: 15px 25px;
    border-radius: 10px;
    font-size: 1.5rem;
    font-weight: bold;
    margin: 10px 0;
    text-align: center;
    animation: valuePulse 1s ease-in-out;
}

@keyframes valuePulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

.step-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border-left: 4px solid var(--info-color);
}

.step-title {
    color: var(--info-color);
    font-weight: bold;
    margin-bottom: 5px;
}

.step-details {
    font-size: 0.95rem;
    line-height: 1.4;
}

.window-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 15px 0;
}

.window-slider {
    display: flex;
    align-items: center;
    gap: 5px;
    margin: 10px 0;
}

.window-slider i {
    color: var(--primary-color);
    font-size: 1.2rem;
}

.window-indicator {
    background: var(--warning-color);
    padding: 5px 10px;
    border-radius: 5px;
    font-weight: bold;
    margin: 5px 0;
}
/* Add these to the existing CSS */
.calendar-container {
    display: flex;
    flex-direction: column;
    gap: 20px;
    margin: 20px 0;
}

.calendar-timeline {
    width: 100%;
    height: 120px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    position: relative;
    margin: 15px 0;
    overflow-x: auto;
    overflow-y: hidden;
    padding: 10px;
}

.timeline-track {
    position: relative;
    height: 60px;
    margin: 25px 0;
    border-bottom: 2px solid rgba(255, 255, 255, 0.1);
}

.timeline-scale {
    display: flex;
    justify-content: space-between;
    padding: 0 20px;
    color: var(--secondary-color);
    font-size: 0.8rem;
    margin-top: 5px;
}

.timeline-marker {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    height: 40px;
    border-radius: 8px;
    opacity: 0.8;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: bold;
    font-size: 0.9rem;
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
    cursor: pointer;
    z-index: 1;
}

.timeline-marker:hover {
    transform: translateY(-50%) scale(1.05);
    opacity: 1;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}

.event-success {
    background: linear-gradient(45deg, var(--success-color), #00d9b8);
    border: 2px solid rgba(255, 255, 255, 0.3);
}

.event-failure {
    background: linear-gradient(45deg, var(--danger-color), #ff9a9e);
    border: 2px solid rgba(255, 255, 255, 0.3);
    animation: shake 0.5s ease;
}

.event-conflict {
    background: linear-gradient(45deg, var(--warning-color), #ffd166);
    border: 2px solid rgba(255, 255, 255, 0.3);
}

.event-processing {
    background: linear-gradient(45deg, var(--info-color), #84d2ff);
    border: 2px dashed rgba(255, 255, 255, 0.5);
    animation: pulse 1s infinite;
}

.event-overlap-line {
    position: absolute;
    height: 4px;
    background: var(--danger-color);
    top: -8px;
    border-radius: 2px;
    animation: colorChange 1s infinite;
}

.calendar-events-list {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
}

.calendar-event-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 15px;
    margin: 8px 0;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.1);
    transition: all 0.3s ease;
}

.calendar-event-item:hover {
    transform: translateX(5px);
    background: rgba(255, 255, 255, 0.15);
}

.event-status {
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 0.8rem;
    font-weight: bold;
}

.status-booked {
    background: rgba(0, 184, 148, 0.2);
    color: var(--success-color);
    border: 1px solid var(--success-color);
}

.status-rejected {
    background: rgba(255, 118, 117, 0.2);
    color: var(--danger-color);
    border: 1px solid var(--danger-color);
}

.status-pending {
    background: rgba(116, 185, 255, 0.2);
    color: var(--info-color);
    border: 1px solid var(--info-color);
}

.calendar-stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin: 15px 0;
}

.calendar-stat-card {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 12px;
    text-align: center;
}

.calendar-stat-value {
    font-size: 1.5rem;
    font-weight: bold;
    color: var(--primary-color);
    margin-top: 5px;
}

.calendar-stat-label {
    font-size: 0.85rem;
    color: var(--secondary-color);
    margin-bottom: 5px;
}

.booking-result {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border-left: 4px solid var(--info-color);
    animation: slideIn 0.5s ease;
}

.booking-success {
    border-left: 4px solid var(--success-color);
    background: rgba(0, 184, 148, 0.1);
}

.booking-failure {
    border-left: 4px solid var(--danger-color);
    background: rgba(255, 118, 117, 0.1);
}

.time-unit {
    position: absolute;
    width: 1px;
    height: 10px;
    background: rgba(255, 255, 255, 0.2);
    top: 0;
}

.time-unit-label {
    position: absolute;
    top: 12px;
    font-size: 0.7rem;
    color: rgba(255, 255, 255, 0.5);
    transform: translateX(-50%);
}
/* ===== MOBILE OPTIMIZATION ===== */
/* Ensure 100% visibility and usability on mobile devices */
@media (max-width: 768px) {
        .dp-table {
        font-size: 0.8rem;
    }
    
    .dp-table th,
    .dp-table td {
        padding: 6px 4px;
        min-width: 35px;
    }
    
    .dp-table th:first-child,
    .dp-table td:first-child {
        position: sticky;
        left: 0;
        z-index: 2;
    }
    /* General mobile adjustments */
    body {
        font-size: 14px;
        line-height: 1.4;
    }
   
    .container {
        padding-left: 10px;
        padding-right: 10px;
    }
   
    /* Header and title optimization */
    .display-4 {
        font-size: 1.8rem !important;
    }
   
    .lead {
        font-size: 1rem !important;
    }
   
    /* Main array container optimization */
    .array-container {
        min-height: 200px;
        padding: 10px;
        gap: 5px;
        margin: 10px 0;
    }
   
    /* Array elements optimization */
    .array-element {
        margin: 0 2px 8px 2px;
        min-width: 40px;
    }
   
    .element-value {
        width: 40px !important;
        height: 40px !important;
        font-size: 0.9rem !important;
        border-radius: 8px;
    }
   
    .element-index {
        font-size: 0.7rem;
        margin-top: 5px;
    }
   
    /* Stats cards optimization */
    .stats-card {
        padding: 10px;
        margin: 5px 0;
    }
   
    .stats-value {
        font-size: 1.1rem !important;
        max-height: 40px;
        overflow-y: auto;
    }
   
    /* Operation tabs optimization */
    .nav-tabs {
        flex-wrap: nowrap;
        overflow-x: auto;
        overflow-y: hidden;
        -webkit-overflow-scrolling: touch;
        white-space: nowrap;
    }
   
    .nav-tabs .nav-item {
        flex: 0 0 auto;
    }
   
    .nav-tabs .nav-link {
        font-size: 0.8rem;
        padding: 8px 12px;
        white-space: nowrap;
    }
   
    /* Form controls optimization */
    .form-control {
        font-size: 16px !important; /* Prevents zoom on iOS */
        padding: 10px;
    }
   
    .input-group {
        flex-wrap: wrap;
    }
   
    .input-group .form-control {
        flex: 1 1 100%;
        margin-bottom: 5px;
    }
   
    .input-group .btn {
        flex: 1 1 auto;
        margin: 2px;
    }
   
    /* Button optimization */
    .btn-glow {
        padding: 12px 16px;
        font-size: 0.9rem;
        margin: 3px 0;
        min-height: 44px; /* Minimum touch target size */
    }
   
    .btn {
        min-height: 44px; /* Apple's recommended minimum touch target */
        display: flex;
        align-items: center;
        justify-content: center;
    }
   
    /* Tab content optimization */
    .tab-content {
        padding: 10px 0;
        max-height: 60vh;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
    }
   
    /* Operation sections optimization */
    .mb-3 {
        margin-bottom: 15px !important;
    }
   
    /* Dual array containers optimization */
    .dual-array-container {
        gap: 15px;
    }
   
    .original-array-container,
    .transformed-array-container {
        padding: 10px;
        min-height: 120px;
    }
   
    /* Matrix optimization */
    .matrix-container {
        gap: 5px;
    }
   
    .matrix-row {
        gap: 5px;
    }
   
    .matrix-element {
        width: 35px !important;
        height: 35px !important;
        font-size: 0.8rem !important;
    }
   
    /* Stack containers optimization */
    .stack-container {
        min-height: 120px;
        padding: 8px;
    }
   
    .stack-element {
        padding: 6px 8px;
        min-width: 45px;
        font-size: 0.8rem;
    }
   
    /* Table optimization */
    .table-container {
        max-height: 200px;
    }
   
    .frequency-table,
    .dictionary-table,
    .leader-table,
    .jump-game-table,
    .memory-address-table {
        font-size: 0.7rem;
    }
   
    .frequency-table th,
    .dictionary-table th,
    .leader-table th,
    .jump-game-table th,
    .memory-address-table th {
        padding: 8px 6px;
    }
   
    .frequency-table td,
    .dictionary-table td,
    .leader-table td,
    .jump-game-table td,
    .memory-address-table td {
        padding: 6px 4px;
    }
   
    /* Explanation boxes optimization */
    .algorithm-explanation,
    .explanation,
    .merge-sort-explanation,
    .pancake-explanation,
    .wiggle-explanation,
    .stock-explanation,
    .set-operation-explanation,
    .conditional-explanation,
    .reshape-explanation,
    .shuffle-explanation {
        font-size: 0.8rem;
        padding: 10px;
        margin-top: 10px;
    }
   
    /* Code snippets optimization */
    .code-snippet {
        font-size: 0.7rem;
        padding: 8px;
        margin: 8px 0;
    }
   
    /* Results containers optimization */
    .search-results,
    .subarrays-container,
    .subarray-sum-results,
    .two-sum-results,
    .triplet-results,
    .quadruplet-results,
    .near-zero-results,
    .pairs-results,
    .swaps-results,
    .logical-results {
        padding: 10px;
        font-size: 0.8rem;
    }
   
    /* Special items optimization */
    .subarray-item,
    .subarray-sum-item,
    .triplet-item,
    .quadruplet-item,
    .two-sum-pair,
    .near-zero-item,
    .pair-item,
    .swap-operation,
    .logical-result-item,
    .prime-item {
        padding: 6px 8px;
        font-size: 0.7rem;
        margin: 3px;
    }
   
    /* Histogram optimization */
    .histogram-container {
        min-height: 250px;
        padding: 10px;
    }
   
    .histogram-bar-container {
        margin: 0 3px;
    }
   
    .element-value.histogram-bar {
        width: 30px !important;
    }
   
    .histogram-bar-label {
        font-size: 0.6rem;
        margin-top: 5px;
    }
   
    /* Water container optimization */
    .water-container {
        padding: 10px;
    }
   
    /* Equilibrium stats optimization */
    .equilibrium-stats {
        flex-direction: column;
        gap: 8px;
    }
   
    .equilibrium-stat {
        min-width: auto;
        padding: 8px;
    }
   
    /* Binary representation optimization */
    .binary-digit {
        width: 25px;
        height: 25px;
        line-height: 25px;
        font-size: 0.7rem;
    }
   
    /* Char array optimization */
    .char-array-container {
        padding: 10px;
        min-height: 80px;
    }
   
    .char-element-wrapper {
        margin: 0 3px 8px 3px;
    }
   
    .char-element {
        width: 35px !important;
        height: 35px !important;
        font-size: 0.9rem !important;
    }
   
    .char-index {
        font-size: 0.6rem;
        margin-top: 3px;
    }
   
    .string-display {
        padding: 10px;
        font-size: 1rem;
        min-height: 50px;
    }
   
    /* Statistical tables optimization */
    .covariance-table,
    .correlation-table,
    .abs-diff-table,
    .circular-table,
    .bin-table {
        font-size: 0.65rem;
    }
   
    .covariance-table th,
    .correlation-table th,
    .abs-diff-table th,
    .circular-table th,
    .bin-table th {
        padding: 8px 4px;
    }
   
    .covariance-table td,
    .correlation-table td,
    .abs-diff-table td,
    .circular-table td,
    .bin-table td {
        padding: 6px 3px;
    }
   
    /* Operation logs optimization */
    .operation-log {
        max-height: 150px;
        font-size: 0.8rem;
    }
   
    .log-entry {
        padding: 4px 8px;
        font-size: 0.75rem;
    }
   
    /* Empty state optimization */
    .array-empty-state {
        padding: 20px;
    }
   
    .array-empty-state i {
        font-size: 2rem;
    }
   
    .array-empty-state h4 {
        font-size: 1.2rem;
    }
   
    /* Grid system optimization */
    .row {
        margin-left: -5px;
        margin-right: -5px;
    }
   
    .col-md-3, .col-md-2, .col-md-4, .col-md-8 {
        padding-left: 5px;
        padding-right: 5px;
    }
   
    /* Glass card optimization */
    .glass-card {
        padding: 15px;
        margin-bottom: 15px;
    }
   
    /* Transformation arrows optimization */
    .transformation-arrow,
    .operation-arrow,
    .element-wise-arrow {
        font-size: 1.2rem;
        margin: 5px 0;
    }
   
    /* Stock span values optimization */
    .stock-span-value {
        font-size: 0.7rem;
        padding: 3px 6px;
    }
   
    /* Investment insights optimization */
    .investment-insight {
        padding: 10px;
        font-size: 0.9rem;
    }
   
    .performance-metric {
        padding: 8px;
        font-size: 0.8rem;
    }
   
    .financial-summary {
        padding: 10px;
        font-size: 0.8rem;
    }
   
    .business-insight {
        padding: 8px;
        font-size: 0.75rem;
    }
   
    /* Volatility indicators optimization */
    .volatility-indicator {
        padding: 3px 6px;
        font-size: 0.7rem;
    }
   
    /* Confirmation dialogs optimization */
    .confirmation-dialog {
        padding: 10px;
        font-size: 0.9rem;
    }
   
    /* Custom comparator optimization */
    .custom-comparator-container {
        padding: 10px;
    }
   
    .sort-configuration {
        padding: 10px;
        font-size: 0.8rem;
    }
   
    .sort-step {
        padding: 6px;
        font-size: 0.75rem;
    }
   
    /* Action buttons optimization */
    .action-buttons {
        flex-direction: column;
        gap: 3px;
    }
   
    .btn-sm {
        padding: 4px 6px;
        font-size: 0.7rem;
        min-height: 32px;
    }
   
    /* Editable fields optimization */
    .editable-field {
        padding: 1px 3px;
        font-size: 0.8rem;
    }
   
    /* Operations counter optimization */
    .operations-counter {
        padding: 8px 10px;
        font-size: 0.9rem;
    }
   
    /* Statistical formulas optimization */
    .statistical-formula,
    .progression-formula-display,
    .area-formula {
        padding: 8px;
        font-size: 0.7rem;
    }
   
    /* Calculation steps optimization */
    .calculation-steps {
        padding: 10px;
        font-size: 0.75rem;
    }
   
    /* Stats highlight optimization */
    .stats-highlight {
        padding: 8px;
        font-size: 0.9rem;
    }
   
    /* Progress bars optimization */
    .progress {
        height: 20px;
        margin: 8px 0;
    }
   
    .progress-bar {
        font-size: 0.7rem;
        line-height: 20px;
    }
}

/* Extra small devices (phones, less than 576px) */
@media (max-width: 575.98px) {
    .container {
        padding-left: 5px;
        padding-right: 5px;
    }
   
    .display-4 {
        font-size: 1.5rem !important;
    }
   
    .array-element {
        min-width: 35px;
    }
   
    .element-value {
        width: 35px !important;
        height: 35px !important;
        font-size: 0.8rem !important;
    }
   
    .stats-card {
        padding: 8px 5px;
    }
   
    .stats-value {
        font-size: 1rem !important;
    }
   
    .btn-glow {
        padding: 10px 12px;
        font-size: 0.85rem;
    }
   
    /* Stack items horizontally on very small screens for better space usage */
    .row .col-md-3, .row .col-md-2 {
        flex: 0 0 50%;
        max-width: 50%;
    }
}

/* Landscape orientation optimization */
@media (max-width: 768px) and (orientation: landscape) {
    .tab-content {
        max-height: 50vh;
    }
   
    .array-container {
        min-height: 150px;
    }
   
    .stats-card {
        padding: 5px;
    }
}

/* High-density displays optimization */
@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
    .element-value {
        border-width: 2px;
    }
}

/* Touch device specific optimizations */
@media (hover: none) and (pointer: coarse) {
    /* Improve touch interactions */
    .btn-glow:hover {
        transform: none; /* Remove hover effects on touch devices */
    }
   
    .element-value:hover {
        transform: none;
    }
   
    /* Increase tap target sizes */
    .nav-link {
        padding: 12px 16px;
    }
   
    /* Prevent double-tap zoom */
    button, .btn, .nav-link {
        touch-action: manipulation;
    }
}

/* Reduced motion preferences */
@media (prefers-reduced-motion: reduce) {
    * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
}

/* Dark mode support for mobile */
@media (max-width: 768px) and (prefers-color-scheme: dark) {
    .glass-card {
        background: rgba(30, 30, 30, 0.8);
    }
   
    .stats-card {
        background: rgba(30, 30, 30, 0.6);
    }
}

/* Print styles for mobile */
@media print {
    .btn, .nav-tabs, .operation-log {
        display: none !important;
    }
   
    .array-container {
        break-inside: avoid;
    }
}

/* Ensure no horizontal scrolling */
@media (max-width: 768px) {
    body {
        overflow-x: hidden;
    }
   
    .container {
        max-width: 100%;
        overflow-x: hidden;
    }
}

/* iOS specific fixes */
@supports (-webkit-touch-callout: none) {
    .btn-glow {
        -webkit-tap-highlight-color: transparent;
    }
   
    .element-value {
        -webkit-touch-callout: none;
    }
}

/* Android Chrome specific fixes */
@supports (-webkit-appearance:none) and (not (overflow:-webkit-marquee)) and (not (-ms-accelerator:true)) {
    .btn-glow {
        -webkit-appearance: none;
    }
}

</style>
</head>
<body>
<div class="container py-5">
        <div class="row mb-4">
            <div class="col-12 text-center">
                <h1 class="display-4 title-animation mb-3" >Advanced Array Visualizer</h1>
                <p class="lead" style="color:white">Create, Read, Update, Delete, and Search array elements with stunning animations</p>
            </div>
        </div>
         <!-- Add this after the title section and before the main content row -->
        <div class="row mb-4">
            <div class="col-12 text-center">
                <a href="Array_intro.html" class="btn btn-glow">
                    <i class="fas fa-home me-2"></i>Back to Home
                </a>
            </div>
        </div>
       
        <div class="row">
            <div class="col-md-8">
                <div class="glass-card">
                    <div class="array-container" id="arrayContainer">
                        <!-- Array elements will be dynamically inserted here -->
                        <div class="array-empty-state">
                            <i class="fas fa-layer-group"></i>
                            <h4>Array is Empty</h4>
                            <p>Add some elements to get started!</p>
                        </div>
                    </div>
                </div>
                
                <div class="row mt-4">
                    <div class="col-md-3">
                        <div class="stats-card">
                            <div>Array Length</div>
                            <div class="stats-value" id="arrayLength">0</div>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="stats-card">
                            <div>First Element</div>
                            <div class="stats-value" id="firstElement">-</div>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="stats-card">
                            <div>Last Element</div>
                            <div class="stats-value" id="lastElement">-</div>
                        </div>
                    </div>
                    <div class="col-md-2">
                        <div class="stats-card">
                            <div>Sum of Elements</div>
                            <div class="stats-value" id="sumElements">0</div>
                        </div>
                    </div>
                    <div class="col-md-2">
                        <div class="stats-card">
                            <div>Product of Elements</div>
                            <div class="stats-value" id="productElements">1</div>
                        </div>
                    </div>
<div class="col-md-3">
    <div class="stats-card">
        <div>Mode <small class="text-muted">(Most Frequent)</small></div>
        <div class="stats-value" id="modeElements">-</div>
        <small class="text-muted" id="modeFrequency" style="font-size: 0.7rem;"></small>
    </div>
</div>

                    <div class="col-md-3">
                        <div class="stats-card">
                            <div>Total Operations</div>
                            <div class="stats-value" id="totalOperations">0</div>
                        </div>
                    </div>
                    <div class="col-md-3">
    <div class="stats-card">
        <div>Memory Address</div>
        <div class="stats-value" id="memoryAddress">-</div>
    </div>
</div>
                </div>
            </div>
            
            <div class="col-md-4">
                <div class="glass-card">
                    <h4 class="mb-4">Array Operations</h4>
                    
                    <ul class="nav nav-tabs" id="operationTabs" role="tablist">
                        <li class="nav-item" role="presentation">
                            <button class="nav-link active" id="create-tab" data-bs-toggle="tab" data-bs-target="#create" type="button" role="tab">Create</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="read-tab" data-bs-toggle="tab" data-bs-target="#read" type="button" role="tab">Read</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="update-tab" data-bs-toggle="tab" data-bs-target="#update" type="button" role="tab">Update</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="delete-tab" data-bs-toggle="tab" data-bs-target="#delete" type="button" role="tab">Delete</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="search-tab" data-bs-toggle="tab" data-bs-target="#search" type="button" role="tab">Search</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="advanced-tab" data-bs-toggle="tab" data-bs-target="#advanced" type="button" role="tab">Advanced Basic Operations</button>
                        </li>
                        <li class="nav-item" role="presentation">
                              <button class="nav-link" id="stockmarket-tab" data-bs-toggle="tab" data-bs-target="#stockmarket" type="button" role="tab">Stock Market Operations</button>
                        </li>
                        <li class="nav-item" role="presentation">
                           <button class="nav-link" id="set-tab" data-bs-toggle="tab" data-bs-target="#set" type="button" role="tab">Set Operations</button>
                        </li>
                         <li class="nav-item" role="presentation">
                            <button class="nav-link" id="leetcode-tab" data-bs-toggle="tab" data-bs-target="#leetcode" type="button" role="tab">Leetcode Problems</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="leetcode2-tab" data-bs-toggle="tab" data-bs-target="#leetcode2" type="button" role="tab">LeetcodeProblems-II</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="string-tab" data-bs-toggle="tab" data-bs-target="#string" type="button" role="tab">LeetcodeProblems-III</button>
                        </li>
                        <!-- Add this with the other nav tabs in the operations section -->
                        <li class="nav-item" role="presentation">
                           <button class="nav-link" id="leetcode-tab" data-bs-toggle="tab" data-bs-target="#leetcode" type="button" role="tab">LeetCode Problem-IV</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="advanced-sorting-tab" data-bs-toggle="tab" data-bs-target="#advanced-sorting" type="button" role="tab">Advanced Sorting</button>
                        </li>
                    </ul>
                    
                    <div class="tab-content" id="operationTabsContent">
                        <!-- Create Tab -->
                        <div class="tab-pane fade show active" id="create" role="tabpanel">
                            <div class="mb-3">
                                <label class="form-label">Create (Push)</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="createValue" placeholder="Enter value">
                                    <button class="btn btn-glow" id="createBtn">
                                        <i class="fas fa-plus-circle me-2"></i>Add
                                    </button>
                                </div>
                                <div class="d-grid gap-2">
                                    <button class="btn btn-outline-light" id="createRandomBtn">
                                        <i class="fas fa-dice me-2"></i>Add Random
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Create Array from Range</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="arraySize" placeholder="Size (n)" min="1" max="50">
                                    <button class="btn btn-glow" id="createArrayFromRangeBtn">
                                        <i class="fas fa-layer-group me-2"></i>Create Array 0 to n-1
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Resize Array</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="resizeSize" placeholder="New size" min="1" max="100">
                                    <button class="btn btn-glow" id="resizeArrayBtn">
                                        <i class="fas fa-expand-alt me-2"></i>Resize
                                    </button>
                                </div>
                                <small class="text-muted">Extends array while preserving existing elements</small>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Clone Array Operation</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="cloneIndex" placeholder="Index (0 to n-1)" min="0">
                                    <input type="text" class="form-control" id="cloneElementValue" placeholder="New element value">
                                    <button class="btn btn-glow" id="cloneArrayBtn">
                                        <i class="fas fa-copy me-2"></i>Clone & Modify
                                    </button>
                                </div>
                                <small class="text-muted">Demonstrates cloning by modifying a copy without affecting original</small>
                            </div>
 <!-- Add this in the Create Tab after Clone Array Operation section -->
<div class="mb-3">
    <label class="form-label">Shallow Copy Operation</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="shallowCopyCount" placeholder="Number of objects to modify (1 to n)" min="1">
        <button class="btn btn-glow" id="shallowCopyBtn">
            <i class="fas fa-copy me-2"></i>Shallow Copy & Modify
        </button>
    </div>
    <small class="text-muted">Demonstrates shallow copy by modifying objects that affect both arrays</small>
</div>

<!-- Shallow Copy Input Group (initially hidden) -->
<div class="mb-3" id="shallowCopyInputGroup" style="display: none;">
    <label class="form-label">Enter Modification Details</label>
    <div id="shallowCopyInputs" class="mt-2"></div>
    <div class="d-grid gap-2 mt-2">
        <button class="btn btn-glow" id="confirmShallowCopyBtn">
            <i class="fas fa-play me-2"></i>Perform Shallow Copy Operation
        </button>
        <button class="btn btn-outline-light" id="cancelShallowCopyBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>
<!-- Add this in the Create Tab after Clone Array Operation section -->
<div class="mb-3">
    <label class="form-label">Scalar Operations</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="scalarValue" placeholder="Enter scalar value">
        <button class="btn btn-glow" id="addScalarBtn">
            <i class="fas fa-plus me-2"></i>Add Scalar
        </button>
    </div>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="scalarValueSubtract" placeholder="Enter scalar value">
        <button class="btn btn-glow" id="subtractScalarBtn">
            <i class="fas fa-minus me-2"></i>Subtract Scalar
        </button>
    </div>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="scalarValueMultiply" placeholder="Enter scalar value">
        <button class="btn btn-glow" id="multiplyScalarBtn">
            <i class="fas fa-times me-2"></i>Multiply by Scalar
        </button>
    </div>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="scalarValueDivide" placeholder="Enter scalar value">
        <button class="btn btn-glow" id="divideScalarBtn">
            <i class="fas fa-divide me-2"></i>Divide by Scalar
        </button>
    </div>
    <small class="text-muted">Apply mathematical operations to every element in the array</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Element-wise Array Operations</label>
    <div class="d-grid gap-2">
        <button class="btn btn-glow" id="addArraysElementWiseBtn">
            <i class="fas fa-plus-circle me-2"></i>Add Two Arrays Element-wise
        </button>
        <button class="btn btn-glow" id="subtractArraysElementWiseBtn">
            <i class="fas fa-minus-circle me-2"></i>Subtract Two Arrays Element-wise
        </button>
        <button class="btn btn-glow" id="multiplyArraysElementWiseBtn">
            <i class="fas fa-times-circle me-2"></i>Multiply Arrays Element-wise (Hadamard)
        </button>
        <button class="btn btn-glow" id="divideArraysElementWiseBtn">
            <i class="fas fa-divide me-2"></i>Divide Arrays Element-wise
        </button>
        <button class="btn btn-glow" id="modulusArraysElementWiseBtn">
            <i class="fas fa-percentage me-2"></i>Calculate Modulus Element-wise
        </button>
    </div>
</div>

<!-- Element-wise Operation Input Group (initially hidden) -->
<div class="mb-3" id="elementWiseOperationGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">First Array Details</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="elementWiseFirstArraySize" placeholder="Size of first array" min="1" max="20">
            <button class="btn btn-glow" id="confirmElementWiseFirstArraySizeBtn">
                <i class="fas fa-check me-2"></i>Set First Array Size
            </button>
        </div>
        <div id="elementWiseFirstArrayInputs" class="mt-2"></div>
    </div>

    <div class="mb-3">
        <label class="form-label">Second Array Details</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="elementWiseSecondArraySize" placeholder="Size of second array" min="1" max="20">
            <button class="btn btn-glow" id="confirmElementWiseSecondArraySizeBtn">
                <i class="fas fa-check me-2"></i>Set Second Array Size
            </button>
        </div>
        <div id="elementWiseSecondArrayInputs" class="mt-2"></div>
    </div>

    <div class="d-grid gap-2">
        <button class="btn btn-glow" id="performElementWiseOperationBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Perform Operation
        </button>
        <button class="btn btn-outline-light" id="cancelElementWiseOperationBtn">
            <i class="fas fa-times me-2"></i>Cancel Operation
        </button>
    </div>
</div>
<!-- Add this in the Create Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Insert Sorted (Maintain Order)</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="insertSortedBtn">
            <i class="fas fa-sort-amount-up me-2"></i>Insert Sorted (Maintain Order)
        </button>
    </div>
</div>
<!-- Add this in the Create Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">String to Char Array Conversion</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="convertToCharArrayBtn">
            <i class="fas fa-text-width me-2"></i>Convert String to Char Array
        </button>
    </div>
</div>
<!-- Add this in the Create Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Array Reshaping</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="convertTo2DBtn">
            <i class="fas fa-th me-2"></i>Convert 1D to 2D Array
        </button>
    </div>
    <small class="text-muted">Automatically reshapes 1D array to optimal 2D matrix</small>
</div>
<!-- String Input Group (initially hidden) -->
<div class="mb-3" id="stringInputGroup" style="display: none;">
    <label class="form-label">Enter a String</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="inputString" placeholder="Enter any string (e.g., Hello World)">
        <button class="btn btn-glow" id="confirmStringBtn">
            <i class="fas fa-play me-2"></i>Convert to Char Array
        </button>
        <button class="btn btn-outline-light" id="cancelStringBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>

<!-- Add this in the Create Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Generate Random Array</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="randomArraySize" placeholder="Enter size ( 1)" min="1" max="100">
        <button class="btn btn-glow" id="generateRandomArrayBtn">
            <i class="fas fa-random me-2"></i>Generate Random Array
        </button>
    </div>
    <small class="text-muted">Creates array with random positive and negative numbers</small>
</div>
<!-- Insert Sorted Input Group (initially hidden) -->
<div class="mb-3" id="insertSortedGroup" style="display: none;">
    <label class="form-label">Insert Sorted Operation</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="insertSortedCount" 
               placeholder="How many elements to add?" min="1" max="10">
        <button class="btn btn-glow" id="confirmInsertSortedCountBtn">
            <i class="fas fa-check me-2"></i>Confirm Count
        </button>
    </div>
    <div id="insertSortedInputs" class="mt-2"></div>
    
    <div class="d-grid gap-2 mt-3">
        <button class="btn btn-glow" id="performInsertSortedBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Perform Insert Sorted Operation
        </button>
        <button class="btn btn-outline-light" id="cancelInsertSortedBtn">
            <i class="fas fa-times me-2"></i>Cancel Operation
        </button>
    </div>
</div>
                            <div class="mb-3">
                                <label class="form-label">Find Pivot in Rotated Array</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="findPivotBtn">
                                        <i class="fas fa-search me-2"></i>Find Pivot (Smallest in Rotated Array)
                                    </button>
                                </div>
                                <small class="text-muted">Automatically rotates array if needed, then finds smallest element</small>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Mathematical Progressions</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="createAPBtn">
                                        <i class="fas fa-calculator me-2"></i>Create Arithmetic Progression (A.P.)
                                    </button>
                                    <button class="btn btn-glow" id="createGPBtn">
                                        <i class="fas fa-chart-line me-2"></i>Create Geometric Progression (G.P.)
                                    </button>
                                </div>
                            </div>
                            
                            <!-- AP Input Group (initially hidden) -->
                            <div class="mb-3" id="apInputGroup" style="display: none;">
                                <label class="form-label">Arithmetic Progression Parameters</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="apFirstTerm" placeholder="First term (a)" min="0">
                                    <input type="number" class="form-control" id="apCommonDiff" placeholder="Common difference (d)">
                                    <input type="number" class="form-control" id="apNumTerms" placeholder="Number of terms (n)" min="1" max="50">
                                    <button class="btn btn-glow" id="confirmAPBtn">
                                        <i class="fas fa-play me-2"></i>Generate A.P.
                                    </button>
                                </div>
                                <small class="text-muted">Formula: a, a+d, a+2d, ..., a+(n-1)d</small>
                            </div>
                            
                            <!-- GP Input Group (initially hidden) -->
                            <div class="mb-3" id="gpInputGroup" style="display: none;">
                                <label class="form-label">Geometric Progression Parameters</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="gpFirstTerm" placeholder="First term (a)" min="1">
                                    <input type="number" class="form-control" id="gpCommonRatio" placeholder="Common ratio (r)">
                                    <input type="number" class="form-control" id="gpNumTerms" placeholder="Number of terms (n)" min="1" max="50">
                                    <button class="btn btn-glow" id="confirmGPBtn">
                                        <i class="fas fa-play me-2"></i>Generate G.P.
                                    </button>
                                </div>
                                <small class="text-muted">Formula: a, ar, ar, ..., ar</small>
                            </div>
                            
                            <!-- Cancel Button for Progressions -->
                            <div class="mb-3" id="cancelProgressionGroup" style="display: none;">
                                <button class="btn btn-outline-light w-100" id="cancelProgressionBtn">
                                    <i class="fas fa-times me-2"></i>Cancel Progression Operation
                                </button>
                            </div>
                           <!-- Add this after the existing rotation buttons -->
<div class="mb-3">
    <label class="form-label">Cyclic Shift Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="cyclicShiftLeftBtn">
            <i class="fas fa-undo-alt me-2"></i>Cyclic Shift Left
        </button>
        <button class="btn btn-glow" id="cyclicShiftRightBtn">
            <i class="fas fa-redo-alt me-2"></i>Cyclic Shift Right
        </button>
    </div>
    
    <div class="input-group mb-2" id="cyclicShiftInputGroup" style="display: none;">
        <input type="number" class="form-control" id="cyclicShiftPositions" placeholder="Enter positions (1 to n)" min="1">
        <button class="btn btn-glow" id="confirmCyclicShiftBtn">
            <i class="fas fa-play me-2"></i>Apply Cyclic Shift
        </button>
        <button class="btn btn-outline-light" id="cancelCyclicShiftBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>
                            <div class="mb-3">
                                <label class="form-label">Stable Sorting</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="stableSortBtn">
                                        <i class="fas fa-sort-amount-up-alt me-2"></i>Stable Sort (Bubble Sort)
                                    </button>
                                </div>
                            </div>
                            <div class="mb-3">
    <label class="form-label">In-Place Merge Sort</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="inPlaceMergeSortBtn">
            <i class="fas fa-sort-amount-up-alt me-2"></i>In-Place Merge Sort
        </button>
    </div>
    <small class="text-muted">Sorts the array using in-place merge sort algorithm with detailed visualization</small>
</div>
<!-- Add this after the Special Sorting Operations section -->
<div class="mb-3">
    <label class="form-label">Pancake Sorting (Prefix Flips)</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="pancakeSortBtn">
            <i class="fas fa-utensils me-2"></i>Pancake Sorting
        </button>
    </div>
    <small class="text-muted">Sort array using only prefix flips (reverse from index 0 to k)</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Wiggle Sort II</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="wiggleSortIIBtn">
            <i class="fas fa-random me-2"></i>Wiggle Sort II
        </button>
    </div>
    <small class="text-muted">Sort array such that nums[0] < nums[1] > nums[2] < nums[3]...</small>
</div>
                            <div class="mb-3">
                                <label class="form-label">Merge Two Sorted Arrays</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="mergeSortedArraysBtn">
                                        <i class="fas fa-object-group me-2"></i>Merge Two Sorted Arrays
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Merge Arrays Input Groups (initially hidden) -->
                            <div class="mb-3" id="mergeArraysGroup" style="display: none;">
                                <div class="mb-3">
                                    <label class="form-label">First Array Details</label>
                                    <div class="input-group mb-2">
                                        <input type="number" class="form-control" id="firstArraySize" placeholder="Size of first array" min="1" max="20">
                                        <button class="btn btn-glow" id="confirmFirstArraySizeBtn">
                                            <i class="fas fa-check me-2"></i>Set First Array Size
                                        </button>
                                    </div>
                                    <div id="firstArrayInputs" class="mt-2"></div>
                                </div>
                                
                                <div class="mb-3">
                                    <label class="form-label">Second Array Details</label>
                                    <div class="input-group mb-2">
                                        <input type="number" class="form-control" id="secondArraySize" placeholder="Size of second array" min="1" max="20">
                                        <button class="btn btn-glow" id="confirmSecondArraySizeBtn">
                                            <i class="fas fa-check me-2"></i>Set Second Array Size
                                        </button>
                                    </div>
                                    <div id="secondArrayInputs" class="mt-2"></div>
                                </div>
                                
                                <div class="d-grid gap-2">
                                    <button class="btn btn-glow" id="performMergeBtn" style="display: none;">
                                        <i class="fas fa-play me-2"></i>Perform Merge Operation
                                    </button>
                                    <button class="btn btn-outline-light" id="cancelMergeBtn">
                                        <i class="fas fa-times me-2"></i>Cancel Merge Operation
                                    </button>
                                </div>
                            </div>
                            <!-- Add this in the Create Tab after the Array Sorting section -->
<div class="mb-3">
    <label class="form-label">Special Sorting Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="sortEvenBeforeOddBtn">
            <i class="fas fa-sort-numeric-up-alt me-2"></i>Sort Even Before Odd
        </button>
        <button class="btn btn-glow" id="sortByAbsoluteValueBtn">
            <i class="fas fa-sort-amount-up me-2"></i>Sort by Absolute Value
        </button>
    </div>
</div>

                            <div class="mb-3">
                                <label class="form-label">Array Reversal & Rotation</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="reverseArrayBtn">
                                        <i class="fas fa-exchange-alt me-2"></i>Reverse Array
                                    </button>
                                    <button class="btn btn-glow" id="rotateLeftBtn">
                                        <i class="fas fa-undo me-2"></i>Rotate Left
                                    </button>
                                    <button class="btn btn-glow" id="rotateRightBtn">
                                        <i class="fas fa-redo me-2"></i>Rotate Right
                                    </button>
                                </div>
                                
                                <div class="input-group mb-2" id="rotateInputGroup" style="display: none;">
                                    <input type="number" class="form-control" id="rotatePositions" placeholder="Enter positions (1 to n)" min="1">
                                    <button class="btn btn-glow" id="confirmRotateBtn">
                                        <i class="fas fa-play me-2"></i>Apply Rotation
                                    </button>
                                    <button class="btn btn-outline-light" id="cancelRotateBtn">
                                        <i class="fas fa-times me-2"></i>Cancel
                                    </button>
                                </div>
                            </div>
                            <!-- Add this in the Create Tab after Array Reversal & Rotation section -->
<div class="mb-3">
    <label class="form-label">Array Shuffling</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="shuffleElementsBtn">
            <i class="fas fa-random me-2"></i>Shuffle Elements (Fisher-Yates)
        </button>
    </div>
</div>
                            <div class="mb-3">
                                <label class="form-label">Array Validation & Partial Sort</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="checkSortedBtn">
                                        <i class="fas fa-check-circle me-2"></i>Check if Array is Sorted
                                    </button>
                                    <button class="btn btn-glow" id="partialSortBtn">
                                        <i class="fas fa-sort-amount-up me-2"></i>Partial Sort (Top K)
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Add this input group for partial sort (initially hidden) -->
                            <div class="mb-3" id="partialSortInputGroup" style="display: none;">
                                <label class="form-label">Partial Sort - Enter Number of Elements</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="partialSortCount" 
                                           placeholder="Enter K (1 to array length)" min="1">
                                    <button class="btn btn-glow" id="confirmPartialSortBtn">
                                        <i class="fas fa-play me-2"></i>Sort First K Elements
                                    </button>
                                    <button class="btn btn-outline-light" id="cancelPartialSortBtn">
                                        <i class="fas fa-times me-2"></i>Cancel
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Array Sorting</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="sortAscBtn">
                                        <i class="fas fa-sort-amount-up me-2"></i>Sort Ascending
                                    </button>
                                    <button class="btn btn-glow" id="sortDescBtn">
                                        <i class="fas fa-sort-amount-down me-2"></i>Sort Descending
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Sort Subarray</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="sortSubarrayStart" placeholder="Start index" min="0">
                                    <input type="number" class="form-control" id="sortSubarrayEnd" placeholder="End index" min="0">
                                    <button class="btn btn-glow" id="sortSubarrayBtn">
                                        <i class="fas fa-sort me-2"></i>Sort Subarray
                                    </button>
                                </div>
                                <small class="text-muted">Sorts only the specified subarray range</small>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Fill Array Operations</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="fillValue" placeholder="Value to fill">
                                    <input type="number" class="form-control" id="fillStart" placeholder="Start index (optional)">
                                    <input type="number" class="form-control" id="fillEnd" placeholder="End index (optional)">
                                    <button class="btn btn-glow" id="fillArrayBtn">
                                        <i class="fas fa-fill me-2"></i>Fill Array
                                    </button>
                                </div>
                                <small class="text-muted">Leave indices empty to fill entire array</small>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Swap Elements</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="swapByValuesBtn">
                                        <i class="fas fa-exchange-alt me-2"></i>Swap by Values
                                    </button>
                                    <button class="btn btn-glow" id="swapByIndicesBtn">
                                        <i class="fas fa-sync-alt me-2"></i>Swap by Indices
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Swap Input Groups (initially hidden) -->
                            <div class="mb-3" id="swapByValuesGroup" style="display: none;">
                                <label class="form-label">Swap Elements by Values</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="swapCount" placeholder="Number of elements to swap" min="2">
                                    <button class="btn btn-glow" id="confirmSwapCountBtn">
                                        <i class="fas fa-check me-2"></i>Confirm
                                    </button>
                                </div>
                                <div id="swapValuesInputs" class="mt-2"></div>
                            </div>
                            
                            <div class="mb-3" id="swapByIndicesGroup" style="display: none;">
                                <label class="form-label">Swap Elements by Indices</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="swapIndicesCount" placeholder="Number of indices to swap" min="2">
                                    <button class="btn btn-glow" id="confirmSwapIndicesCountBtn">
                                        <i class="fas fa-check me-2"></i>Confirm
                                    </button>
                                </div>
                                <div id="swapIndicesInputs" class="mt-2"></div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Create Subarray (Slice)</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="sliceStart" placeholder="Start index" min="0">
                                    <input type="number" class="form-control" id="sliceEnd" placeholder="End index">
                                    <button class="btn btn-glow" id="sliceBtn">
                                        <i class="fas fa-cut me-2"></i>Create Subarray
                                    </button>
                                </div>
                                <button class="btn btn-outline-light w-100" id="resetArrayBtn">
                                    <i class="fas fa-undo me-2"></i>Reset to Original Array
                                </button>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Generate All Subarrays</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="subarrayInput" placeholder="e.g., 3,5,44,56">
                                    <button class="btn btn-glow" id="countSubarraysBtn">
                                        <i class="fas fa-calculator me-2"></i>Count Subarrays
                                    </button>
                                </div>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow w-100" id="generateSubarraysBtn">
                                        <i class="fas fa-list me-2"></i>Generate All Subarrays
                                    </button>
                                </div>
                            </div>
                            
                            <div class="subarrays-results" id="subarraysResults" style="display: none;">
                                <h6>Subarrays Results</h6>
                                <div class="stats-card">
                                    <div>Total Subarrays</div>
                                    <div class="stats-value" id="subarrayCount">0</div>
                                </div>
                                <div id="subarraysList" class="mt-3"></div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Insert At Index</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="insertIndex" placeholder="Index" min="0">
                                    <input type="text" class="form-control" id="insertValue" placeholder="Value">
                                    <button class="btn btn-glow" id="insertBtn">
                                        <i class="fas fa-plus me-2"></i>Insert
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Array Transformations</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="cumulativeSumBtn">
                                        <i class="fas fa-chart-line me-2"></i>Cumulative Sum Array
                                    </button>
                                    <button class="btn btn-glow" id="prefixSumBtn">
                                        <i class="fas fa-layer-group me-2"></i>Prefix Sum Array
                                    </button>
                                    <button class="btn btn-glow" id="prefixXorBtn">
                                <i class="fas fa-calculator me-2"></i>Prefix XOR Array
                                 </button>
                                </div>
                                <div class="input-group mb-2">
                                    <button class="btn btn-outline-light" id="resetTransformationBtn" style="display: none;">
                                        <i class="fas fa-undo me-2"></i>Reset to Original Array
                                    </button>
                                </div>
                            </div>
                            <!-- Add this in the Create Tab after Array Transformations section -->
<div class="mb-3">
    <label class="form-label">Mathematical Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="calculateExponentialBtn">
            <i class="fas fa-calculator me-2"></i>Calculate Exponential
        </button>
        <button class="btn btn-glow" id="calculateNaturalLogBtn">
            <i class="fas fa-function me-2"></i>Calculate Natural Log
        </button>
        <button class="btn btn-glow" id="calculateLog10Btn">
            <i class="fas fa-superscript me-2"></i>Calculate Base-10 Log
        </button>
    </div>
    <small class="text-muted">Apply mathematical functions to all array elements</small>
</div>
                            <div class="mb-3">
    <label class="form-label">Trigonometric Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="calcSinBtn">
            <i class="fas fa-wave-square me-2"></i>Calculate Sine of Elements
        </button>
        <button class="btn btn-glow" id="calcCosBtn">
            <i class="fas fa-wave-circle me-2"></i>Calculate Cosine of Elements
        </button>
        <button class="btn btn-glow" id="calcTanBtn">
            <i class="fas fa-chart-line me-2"></i>Calculate Tangent of Elements
        </button>
    </div>
    <small class="text-muted">Calculates trigonometric functions for each element (in radians)</small>
</div>
                        </div>
                        <!-- Add this in the Create Tab after the Array Transformations section -->
                        <!-- Read Tab -->
                        <div class="tab-pane fade" id="read" role="tabpanel">
                            <div class="mb-3">
                                <label class="form-label">Read by Index</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="readIndex" placeholder="Enter index" min="0">
                                    <button class="btn btn-glow" id="readBtn">
                                        <i class="fas fa-eye me-2"></i>Read
                                    </button>
                                </div>
                            </div>
                            <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Data Type Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="getDataTypeBtn">
            <i class="fas fa-code me-2"></i>Get Data Type of Array
        </button>
        <button class="btn btn-glow" id="createTypedArrayBtn">
            <i class="fas fa-layer-group me-2"></i>Create Array with Specific Data Type
        </button>
        <button class="btn btn-glow" id="convertToListBtn">
            <i class="fas fa-list me-2"></i>Convert Array to List
        </button>
    </div>
</div>

<!-- Data Type Input Group (initially hidden) -->
<div class="mb-3" id="dataTypeInputGroup" style="display: none;">
    <label class="form-label">Create Array with Specific Data Type</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="typedArraySize" placeholder="Enter array size" min="1" max="50">
        <select class="form-control" id="dataTypeSelect">
            <option value="">Choose Data Type</option>
            <option value="integer">Integer</option>
            <option value="float">Float</option>
            <option value="string">String</option>
            <option value="char">Character</option>
            <option value="boolean">Boolean</option>
        </select>
        <button class="btn btn-glow" id="confirmDataTypeBtn">
            <i class="fas fa-check me-2"></i>Create Array
        </button>
        <button class="btn btn-outline-light" id="cancelDataTypeBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>
                            <div class="mb-3">
                                <label class="form-label">Array Traversal</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="traverseForwardBtn">
                                        <i class="fas fa-forward me-2"></i>Traverse Array (Forward)
                                    </button>
                                    <button class="btn btn-glow" id="traverseBackwardBtn">
                                        <i class="fas fa-backward me-2"></i>Traverse Array (Backward)
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Two-Pointer Traversal</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="twoPointerTraverseBtn">
                                        <i class="fas fa-arrows-alt-h me-2"></i>Two-Pointer Traversal
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Update Tab -->
                        <div class="tab-pane fade" id="update" role="tabpanel">
                            <div class="mb-3">
                                <label class="form-label">Update by Index</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="updateIndex" placeholder="Index" min="0">
                                    <input type="text" class="form-control" id="updateValue" placeholder="New value">
                                    <button class="btn btn-glow" id="updateBtn">
                                        <i class="fas fa-edit me-2"></i>Update
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Update by Element</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="updateElement" placeholder="Element to update">
                                    <input type="text" class="form-control" id="updateNewValue" placeholder="New value">
                                    <button class="btn btn-glow" id="updateByElementBtn">
                                        <i class="fas fa-edit me-2"></i>Update
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Delete Tab -->
                        <div class="tab-pane fade" id="delete" role="tabpanel">
                            <div class="mb-3">
                                <label class="form-label">Delete by Index</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="deleteIndex" placeholder="Enter index" min="0">
                                    <button class="btn btn-glow" id="deleteBtn">
                                        <i class="fas fa-trash me-2"></i>Delete
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Delete by Element</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="deleteElement" placeholder="Element to delete">
                                    <button class="btn btn-glow" id="deleteByElementBtn">
                                        <i class="fas fa-trash me-2"></i>Delete
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Advanced Delete Operations</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="deleteFirstOccurrence" placeholder="Element to delete first occurrence">
                                    <button class="btn btn-glow" id="deleteFirstOccurrenceBtn">
                                        <i class="fas fa-backspace me-2"></i>Delete First Occurrence
                                    </button>
                                </div>
                                
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="deleteAllOccurrences" placeholder="Element to delete all occurrences">
                                    <button class="btn btn-glow" id="deleteAllOccurrencesBtn">
                                        <i class="fas fa-eraser me-2"></i>Delete All Occurrences
                                    </button>
                                </div>
                                
                                <div class="d-grid gap-2">
                                    <button class="btn btn-glow" id="removeDuplicatesInPlaceBtn">
                                        <i class="fas fa-filter me-2"></i>Remove Duplicates (In-Place)
                                    </button>
                                    <button class="btn btn-glow" id="removeDuplicatesKeepOneBtn">
                                        <i class="fas fa-copy me-2"></i>Remove Duplicates (Keep One)
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Shift Left After Deletion</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="shiftDeleteIndex" placeholder="Index to delete" min="0">
                                    <button class="btn btn-glow" id="shiftLeftAfterDeleteBtn">
                                        <i class="fas fa-trash-arrow-left me-2"></i>Delete & Shift Left
                                    </button>
                                </div>
                                <small class="text-muted">Delete element and shift all subsequent elements left</small>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Shift Operations</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="shiftLeftBtn">
                                        <i class="fas fa-arrow-left me-2"></i>Shift Left
                                    </button>
                                    <button class="btn btn-glow" id="shiftRightBtn">
                                        <i class="fas fa-arrow-right me-2"></i>Shift Right
                                    </button>
                                    <button class="btn btn-outline-light" id="resetShiftBtn">
                                        <i class="fas fa-undo me-2"></i>Reset Shift
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Pop Operation</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="popLastBtn">
                                        <i class="fas fa-minus-circle me-2"></i>Pop Last Element
                                    </button>
                                </div>
                            </div>
                            <!-- Add this in the Delete Tab after the Pop Last Element section -->
<div class="mb-3">
    <label class="form-label">Advanced Pop Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="popFirstBtn">
            <i class="fas fa-minus-circle me-2"></i>Pop First Element
        </button>
        <button class="btn btn-glow" id="shiftRightInsertBtn">
            <i class="fas fa-arrow-right me-2"></i>Shift Right for Insertion
        </button>
    </div>
</div>

<!-- Add this input group for shift right insertion (initially hidden) -->
<div class="mb-3" id="shiftRightInsertGroup" style="display: none;">
    <label class="form-label">Shift Right for Insertion</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="insertShiftIndex" placeholder="Index to insert at" min="0">
        <input type="text" class="form-control" id="insertShiftValue" placeholder="Value to insert">
        <button class="btn btn-glow" id="confirmShiftInsertBtn">
            <i class="fas fa-play me-2"></i>Perform Insertion
        </button>
        <button class="btn btn-glow" id="cancelShiftInsertBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>
                            <div class="d-grid gap-2">
                                <button class="btn btn-glow" id="clearArrayBtn">
                                    <i class="fas fa-broom me-2"></i>Clear Array
                                </button>
                            </div>
                        </div>
                        
                        <!-- Search Tab -->
                        <div class="tab-pane fade" id="search" role="tabpanel">
                            <div class="mb-3">
                                <label class="form-label">Search by Element</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="searchElement" placeholder="Element to search">
                                    <button class="btn btn-glow" id="searchBtn">
                                        <i class="fas fa-search me-2"></i>Search
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Search by Index</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="searchIndex" placeholder="Index to search" min="0">
                                    <button class="btn btn-glow" id="searchByIndexBtn">
                                        <i class="fas fa-search me-2"></i>Search
                                    </button>
                                </div>
                            </div>
                             <!-- Add this in the Search Tab after the Element Analysis section -->
<div class="mb-3">
    <label class="form-label">Find Elements by Comparison</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="comparisonValue" placeholder="Enter x value">
        <button class="btn btn-glow" id="findFirstGreaterBtn">
            <i class="fas fa-arrow-right me-2"></i>Find First Element > x
        </button>
    </div>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="comparisonValueLess" placeholder="Enter x value">
        <button class="btn btn-glow" id="findLastLessBtn">
            <i class="fas fa-arrow-left me-2"></i>Find Last Element < x
        </button>
    </div>
</div>
<!-- Add this in the Search Tab after the Element Analysis section -->
<div class="mb-3">
    <label class="form-label">Range Analysis</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="findRangeBtn">
            <i class="fas fa-ruler me-2"></i>Find Range (Max - Min)
        </button>
    </div>
</div>
<!-- Add this in the Search Tab after Element Analysis section -->
<div class="mb-3">
    <label class="form-label">Statistical Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="findMeanBtn">
            <i class="fas fa-calculator me-2"></i>Find Mean (Average)
        </button>
        <button class="btn btn-glow" id="findMedianBtn">
            <i class="fas fa-sort-amount-up me-2"></i>Find Median
        </button>
    </div>
</div>
                            <div class="mb-3">
                                <label class="form-label">Kth Element Operations</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="kthElementInput" placeholder="Enter k (1 to n)" min="1">
                                    <button class="btn btn-glow" id="kthSmallestBtn">
                                        <i class="fas fa-sort-amount-down me-2"></i>Kth Smallest (Sorted)
                                    </button>
                                    <button class="btn btn-glow" id="kthLargestBtn">
                                        <i class="fas fa-sort-amount-up me-2"></i>Kth Largest (Unsorted)
                                    </button>
                                </div>
                                <small class="text-muted">Find kth smallest element in sorted array or kth largest in unsorted array</small>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Find Subarrays with Given Sum</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="subarraySumInput" placeholder="Enter target sum">
                                    <button class="btn btn-glow" id="findSubarraySumBtn">
                                        <i class="fas fa-calculator me-2"></i>Find Subarrays
                                    </button>
                                </div>
                                <div class="input-group mb-2">
                                    <button class="btn btn-outline-light w-100" id="generateAllSubarraysWithSumBtn">
                                        <i class="fas fa-list me-2"></i>Generate All Subarrays with Sum
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Linear Search (Step-by-Step)</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="linearSearchElement" placeholder="Element to search">
                                    <button class="btn btn-glow" id="linearSearchBtn">
                                        <i class="fas fa-search me-2"></i>Linear Search
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Binary Search (Sorted Array Required)</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="binarySearchElement" placeholder="Element to search">
                                    <button class="btn btn-glow" id="binarySearchBtn">
                                        <i class="fas fa-search me-2"></i>Binary Search
                                    </button>
                                </div>
                                <small class="text-muted">Array will be automatically sorted if needed</small>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Search in Rotated Sorted Array</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="rotatedSearchElement" placeholder="Element to search">
                                    <button class="btn btn-glow" id="rotatedSearchBtn">
                                        <i class="fas fa-search me-2"></i>Search in Rotated Array
                                    </button>
                                </div>
                                <small class="text-muted">Array will be automatically rotated and sorted if needed</small>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Find Occurrences</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="occurrenceElement" placeholder="Element to find">
                                    <button class="btn btn-glow" id="findFirstOccurrenceBtn">
                                        <i class="fas fa-search me-2"></i>First Occurrence
                                    </button>
                                </div>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="occurrenceElementLast" placeholder="Element to find" value="">
                                    <button class="btn btn-glow" id="findLastOccurrenceBtn">
                                        <i class="fas fa-search me-2"></i>Last Occurrence
                                    </button>
                                </div>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="occurrenceElementAll" placeholder="Element to find" value="">
                                    <button class="btn btn-glow" id="findAllOccurrencesBtn">
                                        <i class="fas fa-list me-2"></i>All Occurrences
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Element Analysis</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="checkElement" placeholder="Element to check">
                                    <button class="btn btn-glow" id="checkElementBtn">
                                        <i class="fas fa-check-circle me-2"></i>Check Existence
                                    </button>
                                </div>
                                <div class="d-grid gap-2">
                                    <button class="btn btn-glow" id="findMinElementBtn">
                                        <i class="fas fa-arrow-down me-2"></i>Find Minimum Element
                                    </button>
                                    <button class="btn btn-glow" id="findMaxElementBtn">
                                        <i class="fas fa-arrow-up me-2"></i>Find Maximum Element
                                    </button>
                                </div>
                            </div>
                            <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Statistical Analysis Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="findMinIndexBtn">
            <i class="fas fa-arrow-down me-2"></i>Find Index of Minimum Value
        </button>
        <button class="btn btn-glow" id="findMaxIndexBtn">
            <i class="fas fa-arrow-up me-2"></i>Find Index of Maximum Value
        </button>
    </div>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="findNSmallestBtn">
            <i class="fas fa-sort-amount-down me-2"></i>Find N Smallest Values
        </button>
        <button class="btn btn-glow" id="findNLargestBtn">
            <i class="fas fa-sort-amount-up me-2"></i>Find N Largest Values
        </button>
    </div>
    
    <!-- Input group for N value (initially hidden) -->
    <div class="mb-3" id="nValueInputGroup" style="display: none;">
        <label class="form-label">Enter N Value</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="nValueInput" 
                   placeholder="Enter N (1 to array length)" min="1">
            <button class="btn btn-glow" id="confirmNValueBtn">
                <i class="fas fa-check me-2"></i>Confirm N Value
            </button>
            <button class="btn btn-outline-light" id="cancelNValueBtn">
                <i class="fas fa-times me-2"></i>Cancel
            </button>
        </div>
    </div>
</div>
                            <!-- Add this in the Search Tab after the Element Analysis section -->
<div class="mb-3">
    <label class="form-label">Find Elements by Predicate Function</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="predicateCondition" placeholder="e.g., arr%2==0, arr!=0, arr<5">
        <button class="btn btn-glow" id="findByPredicateBtn">
            <i class="fas fa-filter me-2"></i>Filter by Condition
        </button>
    </div>
    <small class="text-muted">Use 'arr' to represent array elements. Examples: arr%2==0 (even), arr!=0 (non-zero), arr<5 (less than 5)</small>
</div>
                            <!-- Add this in the Search Tab after the Element Analysis section -->
<div class="mb-3">
    <label class="form-label">Find Missing & Repeating Number</label>
    <div class="input-group mb-2">
        <select class="form-control" id="missingRepeatingMethod">
            <option value="math">Using Math (Sum & Sum of Squares)</option>
            <option value="xor">Using XOR (Bit Manipulation)</option>
        </select>
        <button class="btn btn-glow" id="findMissingRepeatingBtn">
            <i class="fas fa-search me-2"></i>Find Missing & Repeating
        </button>
    </div>
    <small class="text-muted">Array should contain numbers from 1 to n with one missing and one repeated</small>
</div>
                            <!-- Add this in the Search Tab after Element Analysis section -->
<div class="mb-3">
    <label class="form-label">Maximum Absolute Difference</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="findMaxAbsDiffBtn">
            <i class="fas fa-calculator me-2"></i>Find Maximum Absolute Difference
        </button>
    </div>
    <small class="text-muted">Calculate max(|A[i] - A[j]| + |i - j|) for all i, j</small>
</div>
<div class="mb-3">
    <label class="form-label">Count Pairs with Difference K</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="pairDifferenceK" placeholder="Enter K value">
        <button class="btn btn-glow" id="countPairsWithDifferenceBtn">
            <i class="fas fa-calculator me-2"></i>Count Pairs with Difference K
        </button>
    </div>
    <small class="text-muted">Count unique pairs (i,j) where |arr[i]-arr[j]| = K</small>
</div>
<!-- Add this in the AdvancedBasicOperations Tab after the Element Analysis section -->
<div class="mb-3">
    <label class="form-label">Statistical Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="calculateStdDevBtn">
            <i class="fas fa-chart-line me-2"></i>Calculate Standard Deviation
        </button>
        <button class="btn btn-glow" id="calculateVarianceBtn">
            <i class="fas fa-calculator me-2"></i>Calculate Variance
        </button>
    </div>
</div>
                            
                            <div class="search-results" id="searchResults">
                                <p class="text-center mb-0">Search results will appear here</p>
                            </div>
                            
                            <div class="algorithm-explanation" id="algorithmExplanation">
                                <h6>Linear Search Algorithm</h6>
                                <p>Linear search checks each element in the array sequentially until the target is found or the end is reached.</p>
                                
                                <div class="code-snippet">
                                    function linearSearch(arr, target) {<br>
                                    &nbsp;&nbsp;for (let i = 0; i < arr.length; i++) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;if (arr[i] === target) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return i; // Found at index i<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                                    &nbsp;&nbsp;}<br>
                                    &nbsp;&nbsp;return -1; // Not found<br>
                                    }
                                </div>
                                
                                <div id="algorithmSteps">
                                    <div class="algorithm-step">
                                        <strong>Step 1:</strong> Start from the first element (index 0)
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 2:</strong> Compare current element with target
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 3:</strong> If match found, return current index
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 4:</strong> Move to next element and repeat Step 2
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 5:</strong> If end of array reached, element not found
                                    </div>
                                </div>
                            </div>
                            
                            <div class="algorithm-explanation mt-3" id="binarySearchExplanation">
                                <h6>Binary Search Algorithm</h6>
                                <p>Binary search works on sorted arrays by repeatedly dividing the search interval in half.</p>
                                
                                <div class="code-snippet">
                                    function binarySearch(arr, target) {<br>
                                    &nbsp;&nbsp;let left = 0, right = arr.length - 1;<br>
                                    &nbsp;&nbsp;while (left <= right) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;let mid = Math.floor((left + right) / 2);<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;if (arr[mid] === target) return mid;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;else if (arr[mid] < target) left = mid + 1;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;else right = mid - 1;<br>
                                    &nbsp;&nbsp;}<br>
                                    &nbsp;&nbsp;return -1;<br>
                                    }
                                </div>
                                
                                <div id="binarySearchSteps">
                                    <div class="algorithm-step">
                                        <strong>Step 1:</strong> Ensure array is sorted (sort if needed)
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 2:</strong> Set left=0, right=array.length-1
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 3:</strong> Calculate mid = (left + right) / 2
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 4:</strong> Compare element at mid with target
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 5:</strong> If match found, return mid index
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 6:</strong> If target > mid, search right half (left = mid+1)
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 7:</strong> If target < mid, search left half (right = mid-1)
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 8:</strong> Repeat until found or search space exhausted
                                    </div>
                                </div>
                            </div>
                            <!-- Add this in the Search Tab after Binary Search algorithm explanation -->
<div class="algorithm-explanation mt-3" id="countPairsExplanation">
    <h6>Count Pairs with Difference K Algorithm</h6>
    <p>This algorithm counts all unique pairs (i,j) where i < j and |arr[i]-arr[j]| = K.</p>
    
    <div class="code-snippet">
        function countPairsWithDifferenceK(arr, k) {<br>
        &nbsp;&nbsp;let count = 0;<br>
        &nbsp;&nbsp;for (let i = 0; i < arr.length; i++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;for (let j = i + 1; j < arr.length; j++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Math.abs(arr[i] - arr[j]) === k) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;}<br>
        &nbsp;&nbsp;return count;<br>
        }
    </div>
    
    <div id="countPairsSteps">
        <div class="algorithm-step">
            <strong>Step 1:</strong> Start with i=0, j=i+1
        </div>
        <div class="algorithm-step">
            <strong>Step 2:</strong> Calculate |arr[i]-arr[j]|
        </div>
        <div class="algorithm-step">
            <strong>Step 3:</strong> If difference equals K, count as valid pair
        </div>
        <div class="algorithm-step">
            <strong>Step 4:</strong> Increment j until end of array
        </div>
        <div class="algorithm-step">
            <strong>Step 5:</strong> Increment i and repeat from Step 2
        </div>
        <div class="algorithm-step">
            <strong>Step 6:</strong> Return total count of valid pairs
        </div>
    </div>
</div>
                            <div class="algorithm-explanation mt-3" id="rotatedSearchExplanation">
                                <h6>Search in Rotated Sorted Array Algorithm</h6>
                                <p>This algorithm searches for an element in a sorted array that has been rotated at some pivot point.</p>
                                
                                <div class="code-snippet">
                                    function searchRotatedSorted(arr, target) {<br>
                                    &nbsp;&nbsp;let left = 0, right = arr.length - 1;<br>
                                    &nbsp;&nbsp;while (left <= right) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;let mid = Math.floor((left + right) / 2);<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;if (arr[mid] === target) return mid;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Check which half is sorted<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;if (arr[left] <= arr[mid]) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Left half is sorted<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (arr[left] <= target && target < arr[mid]) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right = mid - 1;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left = mid + 1;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Right half is sorted<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (arr[mid] < target && target <= arr[right]) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left = mid + 1;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right = mid - 1;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                                    &nbsp;&nbsp;}<br>
                                    &nbsp;&nbsp;return -1;<br>
                                    }
                                </div>
                                
                                <div id="rotatedSearchSteps">
                                    <div class="algorithm-step">
                                        <strong>Step 1:</strong> Find mid index of current search space
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 2:</strong> Check if mid element equals target
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 3:</strong> Determine which half is properly sorted
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 4:</strong> Check if target lies within the sorted half
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 5:</strong> Adjust search boundaries based on sorted half analysis
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 6:</strong> Repeat until found or search space exhausted
                                    </div>
                                </div>
                            </div>
                            <!-- Add this after Binary Search algorithm explanation -->
<div class="algorithm-explanation mt-3" id="comparisonSearchExplanation">
    <h6>Comparison Search Algorithms</h6>
    
    <div class="mb-3">
        <strong>Find First Element > x:</strong>
        <div class="code-snippet">
            function findFirstGreater(arr, x) {<br>
            &nbsp;&nbsp;for (let i = 0; i < arr.length; i++) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (arr[i] > x) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return i; // Found at index i<br>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
            &nbsp;&nbsp;}<br>
            &nbsp;&nbsp;return -1; // Not found<br>
            }
        </div>
    </div>
    
    <div class="mb-3">
        <strong>Find Last Element < x:</strong>
        <div class="code-snippet">
            function findLastLess(arr, x) {<br>
            &nbsp;&nbsp;for (let i = arr.length - 1; i >= 0; i--) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (arr[i] < x) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return i; // Found at index i<br>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
            &nbsp;&nbsp;}<br>
            &nbsp;&nbsp;return -1; // Not found<br>
            }
        </div>
    </div>
    <!-- Add this in the Search Tab after Binary Search explanation -->
<div class="algorithm-explanation mt-3" id="rangeAlgorithmExplanation">
    <h6>Range Calculation Algorithm (Linear Scan)</h6>
    <p>This algorithm finds the minimum and maximum elements in an array using a single pass, then calculates the range as max - min.</p>
    
    <div class="code-snippet">
        function findRange(arr) {<br>
        &nbsp;&nbsp;if (arr.length === 0) return 0;<br>
        &nbsp;&nbsp;let min = arr[0];<br>
        &nbsp;&nbsp;let max = arr[0];<br>
        &nbsp;&nbsp;for (let i = 1; i < arr.length; i++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (arr[i] < min) min = arr[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (arr[i] > max) max = arr[i];<br>
        &nbsp;&nbsp;}<br>
        &nbsp;&nbsp;return max - min;<br>
        }
    </div>
    
    <div id="rangeAlgorithmSteps">
        <div class="algorithm-step">
            <strong>Step 1:</strong> Initialize min and max with first element
        </div>
        <div class="algorithm-step">
            <strong>Step 2:</strong> Iterate through remaining elements
        </div>
        <div class="algorithm-step">
            <strong>Step 3:</strong> Update min if current element is smaller
        </div>
        <div class="algorithm-step">
            <strong>Step 4:</strong> Update max if current element is larger
        </div>
        <div class="algorithm-step">
            <strong>Step 5:</strong> Calculate range = max - min
        </div>
        <div class="algorithm-step">
            <strong>Complexity:</strong> Time: O(n), Space: O(1)
        </div>
    </div>
</div>
</div>

                        </div>
                        <!-- Advanced Basic Operations Tab -->
                        <div class="tab-pane fade" id="advanced" role="tabpanel">
                            <div class="mb-3">
                                <label class="form-label">Fixed-size Sliding Window</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="fixedWindowSize" placeholder="Enter k (window size)" min="1">
                                    <button class="btn btn-glow" id="fixedWindowBtn">
                                        <i class="fas fa-window-maximize me-2"></i>Find Max Sum
                                    </button>
                                </div>
                                <small class="text-muted">Find maximum sum of any contiguous subarray of length k</small>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Variable-size Sliding Window</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="variableWindowSum" placeholder="Enter target sum">
                                    <button class="btn btn-glow" id="variableWindowBtn">
                                        <i class="fas fa-arrows-alt-h me-2"></i>Find Longest Subarray
                                    </button>
                                </div>
                                <small class="text-muted">Find longest subarray with sum  target</small>
                            </div>
                            <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Element-wise Logical Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="logicalAndBtn">
            <i class="fas fa-code me-2"></i>Perform Element-wise Logical AND
        </button>
        <button class="btn btn-glow" id="logicalOrBtn">
            <i class="fas fa-code me-2"></i>Perform Element-wise Logical OR
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Logical Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="logicalNotBtn">
            <i class="fas fa-exchange-alt me-2"></i>Perform Element-wise Logical NOT
        </button>
        <button class="btn btn-glow" id="logicalXorBtn">
            <i class="fas fa-not-equal me-2"></i>Perform Element-wise Logical XOR
        </button>
    </div>
</div>
<!-- Logical NOT Input Group (initially hidden) -->
<div class="mb-3" id="logicalNotGroup" style="display: none;">
    <label class="form-label">Logical NOT Operation</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="logicalNotSize" placeholder="Enter array size" min="1" max="20">
        <button class="btn btn-glow" id="confirmLogicalNotSizeBtn">
            <i class="fas fa-check me-2"></i>Set Array Size
        </button>
    </div>
    <div id="logicalNotInputs" class="mt-2"></div>
    <button class="btn btn-outline-light mt-2" id="cancelLogicalNotBtn">
        <i class="fas fa-times me-2"></i>Cancel NOT Operation
    </button>
</div>

<!-- Logical XOR Input Group (initially hidden) -->
<div class="mb-3" id="logicalXorGroup" style="display: none;">
    <label class="form-label">Logical XOR Operation</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="logicalXorArrayCount" placeholder="Number of arrays" min="2" max="5">
        <button class="btn btn-glow" id="confirmLogicalXorArrayCountBtn">
            <i class="fas fa-check me-2"></i>Set Array Count
        </button>
    </div>
    <div id="logicalXorSizeInputs" class="mt-2"></div>
    <div id="logicalXorElementInputs" class="mt-2"></div>
    <button class="btn btn-outline-light mt-2" id="cancelLogicalXorBtn">
        <i class="fas fa-times me-2"></i>Cancel XOR Operation
    </button>
</div>
<!-- Logical Operations Input Group (initially hidden) -->
<div class="mb-3" id="logicalOperationsGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">Logical Operation Configuration</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="logicalArraysCount" placeholder="Number of arrays (2-5)" min="2" max="5">
            <button class="btn btn-glow" id="confirmArraysCountBtn">
                <i class="fas fa-check me-2"></i>Confirm Number of Arrays
            </button>
        </div>
    </div>

    <div id="arraysSizeInputs" class="mt-2"></div>
    <div id="arraysElementsInputs" class="mt-2"></div>

    <div class="d-grid gap-2">
        <button class="btn btn-glow" id="performLogicalOperationBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Perform Logical Operation
        </button>
        <button class="btn btn-outline-light" id="cancelLogicalOperationBtn">
            <i class="fas fa-times me-2"></i>Cancel Logical Operation
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Data Binning Operations</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="binCount" placeholder="Number of bins" min="2" max="20">
        <button class="btn btn-glow" id="binIntervalsBtn">
            <i class="fas fa-chart-bar me-2"></i>Create Bin Intervals
        </button>
    </div>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="binWidth" placeholder="Bin width" min="1">
        <button class="btn btn-glow" id="binByWidthBtn">
            <i class="fas fa-ruler me-2"></i>Bin by Width
        </button>
    </div>
    <small class="text-muted">Group array elements into intervals for histogram analysis</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">NumPy-style Conditional Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="conditionalWhereBtn">
            <i class="fas fa-question-circle me-2"></i>Conditional Select (Where)
        </button>
        <button class="btn btn-glow" id="multiConditionSelectBtn">
            <i class="fas fa-list-alt me-2"></i>Multi-Condition Select
        </button>
        <button class="btn btn-glow" id="piecewiseEvaluateBtn">
            <i class="fas fa-puzzle-piece me-2"></i>Piecewise Evaluate
        </button>
    </div>
</div>

<!-- Conditional Operations Input Groups (initially hidden) -->
<div class="mb-3" id="conditionalOperationsGroup" style="display: none;">
    <div class="mb-3" id="arraySizesGroup">
        <label class="form-label">Array Configuration</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="arraySize1" placeholder="Size of Array 1" min="1" max="20">
            <input type="number" class="form-control" id="arraySize2" placeholder="Size of Array 2" min="1" max="20">
            <button class="btn btn-glow" id="confirmArraySizesBtn">
                <i class="fas fa-check me-2"></i>Set Array Sizes
            </button>
        </div>
    </div>

    <div class="mb-3" id="arrayElementsGroup" style="display: none;">
        <div class="mb-3">
            <label class="form-label">Array 1 Elements</label>
            <div id="array1Inputs" class="mt-2"></div>
        </div>

        <div class="mb-3">
            <label class="form-label">Array 2 Elements</label>
            <div id="array2Inputs" class="mt-2"></div>
        </div>
    </div>

    <div class="mb-3" id="conditionGroup" style="display: none;">
        <label class="form-label">Condition Configuration</label>
        <div class="input-group mb-2">
            <select class="form-control" id="conditionOperator">
                <option value="<">Less than (<)</option>
                <option value=">">Greater than (>)</option>
                <option value="<=">Less than or equal ()</option>
                <option value=">=">Greater than or equal ()</option>
                <option value="==">Equal (==)</option>
                <option value="!=">Not equal (!=)</option>
            </select>
            <input type="number" class="form-control" id="conditionValue" placeholder="Condition value">
            <button class="btn btn-glow" id="confirmConditionBtn">
                <i class="fas fa-play me-2"></i>Apply Condition
            </button>
        </div>
    </div>

    <div class="d-grid gap-2">
        <button class="btn btn-outline-light" id="cancelConditionalBtn">
            <i class="fas fa-times me-2"></i>Cancel Operation
        </button>
    </div>
</div>
                            <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
                           <div class="mb-3">
                          <label class="form-label">Consecutive Sequence Operations</label>
                           <div class="input-group mb-2">
                             <button class="btn btn-glow" id="longestConsecutiveSequenceBtn">
                            <i class="fas fa-link me-2"></i>Find Longest Consecutive Sequence
                              </button>
                             <button class="btn btn-glow" id="maxConsecutiveOnesBtn">
                            <i class="fas fa-binary me-2"></i>Maximum Consecutive 1s (Binary Array)
                             </button>
                             </div>
                             </div>
                            <!-- NEW: Max and Min Sum of K Consecutive Elements -->
                             <div class="mb-3">
                           <label class="form-label">K Consecutive Elements Sum</label>
                            <div class="input-group mb-2">
                           <input type="number" class="form-control" id="kConsecutiveSize" placeholder="Enter k value" min="1">
                            <button class="btn btn-glow" id="maxKConsecutiveBtn">
                            <i class="fas fa-arrow-up me-2"></i>Find Max Sum of K Consecutive
                             </button>
                              <button class="btn btn-glow" id="minKConsecutiveBtn">
                            <i class="fas fa-arrow-down me-2"></i>Find Min Sum of K Consecutive
                            </button>
                           </div>
                            <small class="text-muted">Find maximum/minimum sum of k consecutive elements</small>
                           </div>
                        <!-- Add these buttons in the Advanced Basic Operations Tab -->
<div class="mb-3">
    <label class="form-label">Previous Greater/Smaller Element</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="previousGreaterBtn">
            <i class="fas fa-arrow-up me-2"></i>Previous Greater Element
        </button>
        <button class="btn btn-glow" id="previousSmallerBtn">
            <i class="fas fa-arrow-down me-2"></i>Previous Smaller Element
        </button>
    </div>
</div>   
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Custom UFunc (Universal Function)</label>
    <div class="input-group mb-2">
        <select class="form-control" id="ufuncSelect">
            <option value="">Select a Universal Function</option>
            <option value="c2f">Celsius to Fahrenheit</option>
            <option value="f2c">Fahrenheit to Celsius</option>
            <option value="square">Square (x)</option>
            <option value="cube">Cube (x)</option>
            <option value="reciprocal">Reciprocal (1/x)</option>
            <option value="relu">ReLU Activation</option>
            <option value="sigmoid">Sigmoid Activation</option>
            <option value="is_even">Is Even</option>
            <option value="is_odd">Is Odd</option>
            <option value="clamp">Clamp Values</option>
            <!-- NEW FUNCTIONS -->
            <option value="zscore_elem">Z-Score Element</option>
            <option value="percentile_rank">Percentile Rank</option>
            <option value="to_grade">Convert to Grade</option>
            <option value="euclid_1d">Euclidean Distance 1D</option>
            <option value="inc">Increment</option>
            <option value="dec">Decrement</option>
            <option value="double">Double</option>
            <option value="half">Half</option>
            <option value="neg">Negate</option>
            <option value="is_positive">Is Positive</option>
            <option value="is_negative">Is Negative</option>
            <option value="is_zero">Is Zero</option>
            <option value="sqroot">Square Root</option>
            <option value="cbrt">Cube Root</option>
            <option value="sin_deg">Sine (Degrees)</option>
            <option value="cos_deg">Cosine (Degrees)</option>
            <option value="tan_deg">Tangent (Degrees)</option>
            <!-- NEWLY ADDED FUNCTIONS -->
            <option value="bit_flip">Bit Flip</option>
            <option value="bit_and">Bitwise AND</option>
            <option value="bit_or">Bitwise OR</option>
            <option value="bit_xor">Bitwise XOR</option>
            <option value="asin_deg">Arcsine (Degrees)</option>
            <option value="acos_deg">Arccosine (Degrees)</option>
            <option value="atan_deg">Arctangent (Degrees)</option>
            <option value="factorial_approx">Factorial (Approximation)</option>
            <option value="leaky_relu">Leaky ReLU</option>
            <option value="bin_0_100">Bin to 0-100</option>
        </select>
        <button class="btn btn-glow" id="applyUfuncBtn">
            <i class="fas fa-calculator me-2"></i>Apply UFunc
        </button>
    </div>
    
    <!-- Additional inputs for functions that need parameters -->
    <div id="ufuncParams" style="display: none;">
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="clampLow" placeholder="Lower bound" style="display: none;">
            <input type="number" class="form-control" id="clampHigh" placeholder="Upper bound" style="display: none;">
            <input type="number" class="form-control" id="euclidRef" placeholder="Reference point" style="display: none;">
            <input type="number" class="form-control" id="bitwiseOperand" placeholder="Operand value" style="display: none;">
            <input type="number" class="form-control" id="leakyReluAlpha" placeholder="Alpha value" style="display: none;">
        </div>
    </div>
</div>     
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">apply_along_axis() for 1D Slices</label>
    <div class="input-group mb-2">
        <select class="form-control" id="axisFunctionSelect">
            <option value="">Select an operation...</option>
            <option value="rowSum">Row-wise Sum</option>
            <option value="colMean">Column-wise Mean</option>
            <option value="rowStd">Row-wise Standard Deviation</option>
            <option value="colMedian">Column-wise Median</option>
            <option value="rowMax">Row-wise Max</option>
            <option value="rowMin">Row-wise Min</option>
            <option value="colVariance">Column-wise Variance</option>
            <option value="rowRange">Row-wise Range</option>
            <option value="rowNormalize">Row-wise Normalization (Min-Max)</option>
            <option value="colZScore">Column-wise Z-Score</option>
            <option value="custom">Custom Function</option>
        </select>
        <button class="btn btn-glow" id="applyAxisBtn">
            <i class="fas fa-play me-2"></i>Apply Operation
        </button>
    </div>
    
    <!-- Custom function input (initially hidden) -->
    <div id="customFunctionGroup" style="display: none;">
        <label class="form-label">Custom Function (JavaScript)</label>
        <textarea class="form-control" id="customFunction" rows="3" 
                  placeholder="Enter function body. Use 'arr' as parameter. Example: return arr.reduce((a, b) => a + b, 0);"></textarea>
        <small class="text-muted">Function should take an array and return a single value</small>
    </div>
    
    <!-- Matrix dimensions input -->
    <div class="mt-2" id="matrixDimensionsGroup" style="display: none;">
        <label class="form-label">Matrix Dimensions</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="matrixRows" placeholder="Rows" min="1" max="10">
            <input type="number" class="form-control" id="matrixCols" placeholder="Columns" min="1" max="10">
            <button class="btn btn-glow" id="createMatrixBtn">
                <i class="fas fa-table me-2"></i>Create Matrix
            </button>
        </div>
    </div>
</div>       
<!-- Add these buttons in the Advanced Basic Operations Tab -->
<!-- Add these buttons in the Advanced Basic Operations Tab -->
<div class="mb-3">
    <label class="form-label">Statistical Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="findCovarianceBtn">
            <i class="fas fa-chart-line me-2"></i>Find Covariance
        </button>
        <button class="btn btn-glow" id="findCorrelationBtn">
            <i class="fas fa-link me-2"></i>Find Correlation Coefficient
        </button>
    </div>
</div>

<!-- Add this section for covariance/correlation input (initially hidden) -->
<div class="mb-3" id="covarianceCorrelationGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label" id="operationTitle">Covariance Operation</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="arrayCountInput" placeholder="Number of arrays (2)" min="2" max="5" value="2">
            <button class="btn btn-glow" id="confirmArrayCountBtn">
                <i class="fas fa-check me-2"></i>Confirm Array Count
            </button>
        </div>
    </div>

    <div id="arrayDetailsContainer" class="mt-3"></div>

    <div class="d-grid gap-2 mt-3">
        <button class="btn btn-glow" id="performStatisticalOperationBtn" style="display: none;">
            <i class="fas fa-calculator me-2"></i>Calculate
        </button>
        <button class="btn btn-outline-light" id="cancelStatisticalOperationBtn">
            <i class="fas fa-times me-2"></i>Cancel Operation
        </button>
    </div>
</div>
                            <div class="mb-3">
                                <label class="form-label">Dutch National Flag Problem</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="sortDutchNationalFlagBtn">
                                        <i class="fas fa-flag me-2"></i>Sort 0s, 1s, 2s (Dutch National Flag)
                                    </button>
                                </div>
                                <small class="text-muted">Sort array containing only 0s, 1s, and 2s using three-pointer technique</small>
                            </div>
                            <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
                             <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
                                      <div class="mb-3">
                           <label class="form-label">Rearrange Array Alternately</label>
                          <div class="input-group mb-2">
                          <button class="btn btn-glow" id="rearrangeMinMaxBtn">
                          <i class="fas fa-random me-2"></i>Rearrange Array (Min, Max) Alternately
                         </button>
                         </div>
                           <small class="text-muted">Rearranges sorted array as: max, min, 2nd max, 2nd min, ...</small>
                           </div>
                         <div class="mb-3">
                         <label class="form-label">Subarray Product Operations</label>
                             <div class="input-group mb-2">
                        <input type="number" class="form-control" id="subarrayProductK" placeholder="Enter k value" min="1">
                        <button class="btn btn-glow" id="subarrayProductBtn">
                       <i class="fas fa-calculator me-2"></i>Subarray Product < k
                        </button>
                        </div>
                         <small class="text-muted">Find all contiguous subarrays with product less than k</small>
                         </div>
                         <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Minimum Swaps to Bring Elements  K Together</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="minSwapsK" placeholder="Enter K value">
        <button class="btn btn-glow" id="minSwapsBtn">
            <i class="fas fa-exchange-alt me-2"></i>Find Minimum Swaps
        </button>
    </div>
    <small class="text-muted">Find minimum swaps to group all elements  K together</small>
</div>
                        
 <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
  <div class="mb-3">
    <label class="form-label">Leader in Array</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="leaderInArrayBtn">
            <i class="fas fa-crown me-2"></i>Find Leaders in Array
        </button>
    </div>
    <small class="text-muted">Find elements that are greater than all elements to their right</small>
    </div>
                            <div class="mb-3">
                                <label class="form-label">Find Majority Element (Boyer-Moore Algorithm)</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="findMajorityElementBtn">
                                        <i class="fas fa-chart-pie me-2"></i>Find Majority Element
                                    </button>
                                </div>
                                <small class="text-muted">Find element that appears more than n/2 times</small>
                            </div>
                            <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
                             <!-- Add this in the Search Tab after the existing search sections -->
               <div class="mb-3">
            <label class="form-label">Equilibrium Point</label>
           <div class="input-group mb-2">
          <button class="btn btn-glow" id="equilibriumPointBtn">
            <i class="fas fa-balance-scale me-2"></i>Find Equilibrium Point
        </button>
      </div>
    <small class="text-muted">Find index where sum of left elements equals sum of right elements</small>
     </div>
     <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
     <div class="mb-3">
    <label class="form-label">Mathematical Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="findGcdBtn">
            <i class="fas fa-calculator me-2"></i>Find GCD of Array
        </button>
        <button class="btn btn-glow" id="findLcmBtn">
            <i class="fas fa-calculator me-2"></i>Find LCM of Array
        </button>
    </div>
    <small class="text-muted">Calculate Greatest Common Divisor and Least Common Multiple</small>
 </div>
 <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
 <div class="mb-3">
    <label class="form-label">Prime Number Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="primeSieveBtn">
            <i class="fas fa-filter me-2"></i>Prime Sieve (Identify Primes)
        </button>
    </div>
    <small class="text-muted">Identify prime numbers (green) and composite numbers (red) in the array</small>
  </div>
  <!-- Add this after Binary Search algorithm explanation -->
  <div class="algorithm-explanation mt-3" id="equilibriumExplanationSection">
    <h6>Equilibrium Point Algorithm</h6>
    <p>An equilibrium point is an index in the array where the sum of elements on the left equals the sum of elements on the right.</p>
    
    <div class="code-snippet">
        function findEquilibrium(arr) {<br>
        &nbsp;&nbsp;let totalSum = arr.reduce((a, b) => a + b, 0);<br>
        &nbsp;&nbsp;let leftSum = 0;<br>
        &nbsp;&nbsp;for (let i = 0; i < arr.length; i++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;let rightSum = totalSum - leftSum - arr[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (leftSum === rightSum) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return i; // Equilibrium found<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;&nbsp;&nbsp;leftSum += arr[i];<br>
        &nbsp;&nbsp;}<br>
        &nbsp;&nbsp;return -1; // No equilibrium point<br>
        }
    </div>
    
    <div id="equilibriumAlgorithmSteps">
        <div class="algorithm-step">
            <strong>Step 1:</strong> Calculate total sum of all elements
        </div>
        <div class="algorithm-step">
            <strong>Step 2:</strong> Initialize left sum to 0
        </div>
        <div class="algorithm-step">
            <strong>Step 3:</strong> For each index i, calculate right sum = total sum - left sum - arr[i]
        </div>
        <div class="algorithm-step">
            <strong>Step 4:</strong> If left sum equals right sum, return current index
        </div>
        <div class="algorithm-step">
            <strong>Step 5:</strong> Otherwise, add current element to left sum and continue
        </div>
        <div class="algorithm-step">
            <strong>Step 6:</strong> If no equilibrium found, return -1
        </div>
    </div>
 </div>
 <!-- Add this in the Advanced Basic Operations Tab after the Data Binning Operations section -->
<div class="algorithm-explanation mt-3">
    <h6>Data Binning Algorithms</h6>
    
    <div class="mb-3">
        <strong>Binning by Number of Intervals:</strong>
        <div class="code-snippet">
            function binByCount(arr, numBins) {<br>
            &nbsp;&nbsp;const minVal = Math.min(...arr);<br>
            &nbsp;&nbsp;const maxVal = Math.max(...arr);<br>
            &nbsp;&nbsp;const range = maxVal - minVal;<br>
            &nbsp;&nbsp;const binSize = range / numBins;<br>
            &nbsp;&nbsp;const bins = Array(numBins).fill(0).map(() => []);<br>
            &nbsp;&nbsp;<br>
            &nbsp;&nbsp;for (let value of arr) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;const binIndex = Math.min(<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Math.floor((value - minVal) / binSize), <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numBins - 1<br>
            &nbsp;&nbsp;&nbsp;&nbsp;);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;bins[binIndex].push(value);<br>
            &nbsp;&nbsp;}<br>
            &nbsp;&nbsp;return bins;<br>
            }
        </div>
    </div>
    
    <div class="mb-3">
        <strong>Binning by Fixed Width:</strong>
        <div class="code-snippet">
            function binByWidth(arr, width) {<br>
            &nbsp;&nbsp;const minVal = Math.min(...arr);<br>
            &nbsp;&nbsp;const maxVal = Math.max(...arr);<br>
            &nbsp;&nbsp;const numBins = Math.ceil((maxVal - minVal) / width);<br>
            &nbsp;&nbsp;const bins = Array(numBins).fill(0).map(() => []);<br>
            &nbsp;&nbsp;<br>
            &nbsp;&nbsp;for (let value of arr) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;const binIndex = Math.min(<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Math.floor((value - minVal) / width), <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numBins - 1<br>
            &nbsp;&nbsp;&nbsp;&nbsp;);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;bins[binIndex].push(value);<br>
            &nbsp;&nbsp;}<br>
            &nbsp;&nbsp;return bins;<br>
            }
        </div>
    </div>
    
    <div class="algorithm-step">
        <strong>Step 1:</strong> Calculate data range (min, max values)
    </div>
    <div class="algorithm-step">
        <strong>Step 2:</strong> Determine bin intervals based on method
    </div>
    <div class="algorithm-step">
        <strong>Step 3:</strong> Assign each element to appropriate bin
    </div>
    <div class="algorithm-step">
        <strong>Step 4:</strong> Count elements in each bin and display distribution
    </div>
</div>
  <div class="mb-3">
    <label class="form-label">Triplet & Quadruplet Sum Operations</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="tripletSumInput" placeholder="Enter target sum for triplets">
        <button class="btn btn-glow" id="findTripletsBtn">
            <i class="fas fa-cube me-2"></i>Find Triplets
        </button>
    </div>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="quadrupletSumInput" placeholder="Enter target sum for quadruplets">
        <button class="btn btn-glow" id="findQuadrupletsBtn">
            <i class="fas fa-cubes me-2"></i>Find Quadruplets
        </button>
    </div>
    </div>
                            <!-- Add these buttons to the Advanced Basic Operations tab, after the existing buttons -->
                   <div class="mb-3">
                <label class="form-label">Advanced Array Algorithms</label>
                 <div class="input-group mb-2">
              <button class="btn btn-glow" id="findNBy3ElementsBtn">
              <i class="fas fa-chart-pie me-2"></i>Find Elements > n/3 Times
              </button>
           <button class="btn btn-glow" id="nextGreaterElementBtn">
            <i class="fas fa-arrow-right me-2"></i>Find Next Greater Element
           </button>
          </div>
          </div>

                            <div class="mb-3">
                                <label class="form-label">Advanced Algorithms</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="twoPointerSortBtn">
                                        <i class="fas fa-arrows-alt-h me-2"></i>Two-Pointer (Sort Array)
                                    </button>
                                    <button class="btn btn-glow" id="kadaneAlgorithmBtn">
                                        <i class="fas fa-chart-line me-2"></i>Kadane's Algorithm (Max Subarray Sum)
                                    </button>
                                            <button class="btn btn-glow" id="maxCircularSubarrayBtn">
                                      <i class="fas fa-sync-alt me-2"></i>Maximum Sum Circular Subarray
                                    </button>

                                </div>
                            </div>
                            <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Maximum Distance Between Same Elements</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="maxDistanceSameElementsBtn">
            <i class="fas fa-arrows-alt-h me-2"></i>Find Max Distance Between Same Elements
        </button>
    </div>
    <small class="text-muted">Find maximum distance (j-i) where arr[i] == arr[j] and i < j</small>
</div>
                     <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Element-wise Array Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="elementWiseMaxBtn">
            <i class="fas fa-arrow-up me-2"></i>Element-wise Maximum of Two Arrays
        </button>
        <button class="btn btn-glow" id="elementWiseMinBtn">
            <i class="fas fa-arrow-down me-2"></i>Element-wise Minimum of Two Arrays
        </button>
    </div>
</div>

<!-- Element-wise Operations Input Group (initially hidden) -->
<div class="mb-3" id="elementWiseGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">First Array Details</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="firstArraySizeElementWise" placeholder="Size of first array" min="1" max="20">
            <button class="btn btn-glow" id="confirmFirstArraySizeElementWiseBtn">
                <i class="fas fa-check me-2"></i>Set First Array Size
            </button>
        </div>
        <div id="firstArrayInputsElementWise" class="mt-2"></div>
    </div>

    <div class="mb-3">
        <label class="form-label">Second Array Details</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="secondArraySizeElementWise" placeholder="Size of second array" min="1" max="20">
            <button class="btn btn-glow" id="confirmSecondArraySizeElementWiseBtn">
                <i class="fas fa-check me-2"></i>Set Second Array Size
            </button>
        </div>
        <div id="secondArrayInputsElementWise" class="mt-2"></div>
    </div>

    <div class="d-grid gap-2">
        <button class="btn btn-glow" id="performElementWiseBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Perform Element-wise Operation
        </button>
        <button class="btn btn-outline-light" id="cancelElementWiseBtn">
            <i class="fas fa-times me-2"></i>Cancel Operation
        </button>

    </div>
</div>       
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Logical Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="maxPairAndOrBtn">
            <i class="fas fa-code me-2"></i>Max Pair AND/OR
        </button>
    </div>
    <small class="text-muted">Find maximum AND and OR pairs in the array</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Minimum Flips Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="minFlipsOrBtn">
            <i class="fas fa-exchange-alt me-2"></i>Minimum Flips OR
        </button>
        <button class="btn btn-glow" id="minFlipsAndBtn">
            <i class="fas fa-exchange-alt me-2"></i>Minimum Flips AND
        </button>
    </div>
</div>

<!-- Minimum Flips Input Group (initially hidden) -->
<div class="mb-3" id="minFlipsInputGroup" style="display: none;">
    <h6 id="minFlipsTitle" class="text-center mb-3">Minimum Flips Operation</h6>
    
    <div class="mb-3">
        <label class="form-label">Number of Arrays</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="numArraysInput" placeholder="Enter number of arrays" min="2" max="5">
            <button class="btn btn-glow" id="confirmNumArraysBtn">
                <i class="fas fa-check me-2"></i>Confirm
            </button>
        </div>
    </div>

    <div id="arraySizeInputs" class="mb-3"></div>
    <div id="arrayElementsInputs" class="mb-3"></div>

    <div class="d-grid gap-2">
        <button class="btn btn-glow" id="performMinFlipsBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Find Minimum Flips
        </button>
        <button class="btn btn-outline-light" id="cancelMinFlipsBtn">
            <i class="fas fa-times me-2"></i>Cancel Operation
        </button>
    </div>
</div>

                            <div class="mb-3">
                                <label class="form-label">Zero Movement Operations</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="moveZerosToFrontBtn">
                                        <i class="fas fa-arrow-left me-2"></i>Move Zeros to Front
                                    </button>
                                    <button class="btn btn-glow" id="moveZerosToEndBtn">
                                        <i class="fas fa-arrow-right me-2"></i>Move Zeros to End
                                    </button>
                                </div>
                                <small class="text-muted">Move all zero elements to front or end while maintaining relative order of non-zero elements</small>
                            </div>
                            <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
  <div class="mb-3">
    <label class="form-label">Find Subarray with Sum Closest to Zero</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="findSubarrayNearZeroBtn">
            <i class="fas fa-bullseye me-2"></i>Find Subarray with Sum Near Zero
        </button>
    </div>
    <small class="text-muted">Find subarray whose sum is closest to zero</small>
   </div>
                            <div class="mb-3">
                                <label class="form-label">Element Analysis</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="countElementFrequencyBtn">
                                        <i class="fas fa-chart-bar me-2"></i>Count Element Frequency
                                    </button>
                                    <button class="btn btn-glow" id="findDuplicatesBtn">
                                        <i class="fas fa-clone me-2"></i>Find Duplicate Elements
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Element Uniqueness Operations</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="firstNonRepeatingBtn">
                                        <i class="fas fa-search me-2"></i>Find First Non-Repeating Element
                                    </button>
                                    <button class="btn btn-glow" id="findUniqueElementsBtn">
                                        <i class="fas fa-star me-2"></i>Find All Unique Elements
                                    </button>
                                </div>
                            </div>
                            <!-- Add this in the Search Tab after Element Uniqueness Operations -->
                    <div class="mb-3">
                     <label class="form-label">Find Repeating Elements</label>
                     <div class="input-group mb-2">
                     <button class="btn btn-glow" id="findFirstRepeatingBtn">
                       <i class="fas fa-redo me-2"></i>Find First Repeating Element
                        </button>
                     </div>
                   </div>
                            <div class="mb-3">
                                <label class="form-label">Rearrange Positive & Negative Values</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="rearrangePositiveNegativeBtn">
                                        <i class="fas fa-sort-amount-up me-2"></i>Rearrange Positive & Negative Values
                                    </button>
                                </div>
                                <small class="text-muted">Move all negative values to the front while maintaining relative order</small>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Segregate Even & Odd Numbers</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="segregateEvenOddBtn">
                                        <i class="fas fa-sort-numeric-up-alt me-2"></i>Segregate Even & Odd Numbers
                                    </button>
                                </div>
                                <small class="text-muted">Move all even numbers to the front while maintaining relative order</small>
                            </div>
                                   <!-- Add this in the Advanced Basic Operations section after the existing buttons -->
                                      <div class="mb-3">
                                       <label class="form-label">In-place Negation</label>
                                       <div class="input-group mb-2">
                                          <button class="btn btn-glow" id="inPlaceNegationBtn">
                                        <i class="fas fa-exchange-alt me-2"></i>In-place Negation
                                              </button>
                                          </div>
                                          <small class="text-muted">Negate every element of a mutable numeric sequence</small>
                                       </div>
                            <div class="algorithm-explanation mt-3">
                                <h6>Sliding Window Algorithms</h6>
                                
                                <div class="mb-3">
                                    <strong>Fixed-size Window:</strong>
                                    <div class="code-snippet">
                                        function maxSumFixedWindow(arr, k) {<br>
                                        &nbsp;&nbsp;let maxSum = 0, currentSum = 0;<br>
                                        &nbsp;&nbsp;// Calculate first window<br>
                                        &nbsp;&nbsp;for (let i = 0; i < k; i++) {<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;currentSum += arr[i];<br>
                                        &nbsp;&nbsp;}<br>
                                        &nbsp;&nbsp;maxSum = currentSum;<br>
                                        &nbsp;&nbsp;// Slide the window<br>
                                        &nbsp;&nbsp;for (let i = k; i < arr.length; i++) {<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;currentSum += arr[i] - arr[i - k];<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;maxSum = Math.max(maxSum, currentSum);<br>
                                        &nbsp;&nbsp;}<br>
                                        &nbsp;&nbsp;return maxSum;<br>
                                        }
                                    </div>
                                </div>
                                
                                <div class="mb-3">
                                    <strong>Variable-size Window:</strong>
                                    <div class="code-snippet">
                                        function longestSubarraySumLeq(arr, target) {<br>
                                        &nbsp;&nbsp;let left = 0, currentSum = 0, maxLength = 0;<br>
                                        &nbsp;&nbsp;for (let right = 0; right < arr.length; right++) {<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;currentSum += arr[right];<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;while (currentSum > target && left <= right) {<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentSum -= arr[left];<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left++;<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;maxLength = Math.max(maxLength, right - left + 1);<br>
                                        &nbsp;&nbsp;}<br>
                                        &nbsp;&nbsp;return maxLength;<br>
                                        }
                                    </div>
                                </div>
                            </div>
                            
                            <div class="algorithm-explanation mt-3">
                                <h6>Dutch National Flag Algorithm (Three-Pointer Technique)</h6>
                                <p>Sorts an array containing only 0s, 1s, and 2s in a single pass using three pointers:</p>
                                
                                <div class="code-snippet">
                                    function dutchNationalFlagSort(arr) {<br>
                                    &nbsp;&nbsp;let low = 0, mid = 0, high = arr.length - 1;<br>
                                    &nbsp;&nbsp;while (mid <= high) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;switch (arr[mid]) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 0: // Found 0<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[arr[low], arr[mid]] = [arr[mid], arr[low]];<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;low++; mid++;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1: // Found 1<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid++;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 2: // Found 2<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[arr[mid], arr[high]] = [arr[high], arr[mid]];<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;high--;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                                    &nbsp;&nbsp;}<br>
                                    &nbsp;&nbsp;return arr;<br>
                                    }
                                </div>
                                
                                <div class="algorithm-step">
                                    <strong>Pointer Roles:</strong>
                                </div>
                                <div class="algorithm-step">
                                     <strong>Low:</strong> Tracks the boundary for 0s (everything before low is 0)
                                </div>
                                <div class="algorithm-step">
                                     <strong>Mid:</strong> Current element being processed (everything between low and mid-1 is 1)
                                </div>
                                <div class="algorithm-step">
                                     <strong>High:</strong> Tracks the boundary for 2s (everything after high is 2)
                                </div>
                                <div class="algorithm-step">
                                    <strong>Time Complexity:</strong> O(n) - Single pass through the array
                                </div>
                                <div class="algorithm-step">
                                    <strong>Space Complexity:</strong> O(1) - In-place sorting
                                </div>
                            </div>
                        </div>  
<!-- Add this tab content after the Advanced Basic Operations tab -->
<div class="tab-pane fade" id="leetcode2" role="tabpanel">
    <div class="mb-3">
        <h5 class="mb-3">Ugly Number Problems</h5>
        
        <!-- Ugly Number Check -->
        <div class="mb-3">
            <label class="form-label">Check Ugly Number</label>
            <div class="input-group mb-2">
                <input type="number" class="form-control" id="uglyNumberInput" placeholder="Enter number to check" min="1">
                <button class="btn btn-glow" id="checkUglyNumberBtn">
                    <i class="fas fa-check-circle me-2"></i>Check Ugly Number
                </button>
            </div>
            <small class="text-muted">An ugly number is a positive number whose prime factors are only 2, 3, and 5</small>
        </div>

        <!-- Nth Ugly Number -->
        <div class="mb-3">
            <label class="form-label">Find Nth Ugly Number</label>
            <div class="input-group mb-2">
                <input type="number" class="form-control" id="nthUglyNumberInput" placeholder="Enter n (1-100)" min="1" max="100">
                <button class="btn btn-glow" id="findNthUglyNumberBtn">
                    <i class="fas fa-sort-numeric-up me-2"></i>Find Nth Ugly Number
                </button>
            </div>
            <small class="text-muted">Find the n-th number whose prime factors are only 2, 3, and 5</small>
        </div>

        <!-- Super Ugly Number -->
        <div class="mb-3">
            <label class="form-label">Find Super Ugly Number</label>
            <div class="input-group mb-2">
                <input type="number" class="form-control" id="superUglyNInput" placeholder="Enter n (1-50)" min="1" max="50">
                <input type="text" class="form-control" id="superUglyPrimesInput" placeholder="Primes (e.g., 2,3,5,7)">
                <button class="btn btn-glow" id="findSuperUglyNumberBtn">
                    <i class="fas fa-star me-2"></i>Find Super Ugly Number
                </button>
            </div>
            <small class="text-muted">Find the n-th number whose prime factors are from given prime list</small>
        </div>

        <!-- Results Display -->
        <div class="algorithm-explanation mt-3" id="uglyNumberResults">
            <h6>Ugly Number Results</h6>
            <div id="uglyNumberOutput" class="mt-2">
                <p class="text-center mb-0">Results will appear here</p>
            </div>
        </div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Special Number Detection</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="findPerfectNumbersBtn">
            <i class="fas fa-calculator me-2"></i>Find Perfect Numbers
        </button>
        <button class="btn btn-glow" id="findArmstrongNumbersBtn">
            <i class="fas fa-square-root-alt me-2"></i>Find Armstrong Numbers
        </button>
    </div>
    <small class="text-muted">Detect special mathematical numbers in the array</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Number Operations</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="numberInput" placeholder="Enter number (0-999999999)" min="0" max="999999999">
        <button class="btn btn-glow" id="convertToEnglishBtn">
            <i class="fas fa-language me-2"></i>Convert to English Words
        </button>
    </div>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="findDigitOneBtn">
            <i class="fas fa-search me-2"></i>Find Digit One in Array
        </button>
    </div>
</div>
<!-- Add this in the Create Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Excel Sheet Column Number</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="excelColumnNumberBtn">
            <i class="fas fa-file-excel me-2"></i>Convert Excel Columns to Numbers
        </button>
    </div>
    <small class="text-muted">Convert Excel column titles (A, AB, ZY) to column numbers</small>
</div>
<!-- Add this in the Create Tab after the Excel Column Number button -->
<div class="mb-3">
    <label class="form-label">Number to Column Title</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="numberToColumnTitleBtn">
            <i class="fas fa-file-excel me-2"></i>Convert Numbers to Excel Columns
        </button>
    </div>
    <small class="text-muted">Convert column numbers to Excel column titles (1A, 28AB, 701ZY)</small>
</div>

<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Compression Algorithms</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="deltaEncodingBtn">
            <i class="fas fa-compress-alt me-2"></i>Delta Encoding
        </button>
        <button class="btn btn-glow" id="bwtTransformBtn">
            <i class="fas fa-sync-alt me-2"></i>Burrows-Wheeler Transform
        </button>
        <button class="btn btn-glow" id="mtfTransformBtn">
            <i class="fas fa-exchange-alt me-2"></i>Move-to-Front Transform
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">String Algorithms</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="countAndSayBtn">
            <i class="fas fa-sort-numeric-up-alt me-2"></i>Count and Say Sequence
        </button>
        <button class="btn btn-glow" id="stringCompressionBtn">
            <i class="fas fa-compress-alt me-2"></i>String Compression (In-Place)
        </button>
    </div>
</div>

<!-- Count and Say Input Group (initially hidden) -->
<div class="mb-3" id="countAndSayGroup" style="display: none;">
    <label class="form-label">Count and Say Sequence - Enter Number of Terms</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="countAndSayTerms" 
               placeholder="Enter number of terms (1-10)" min="1" max="10">
        <button class="btn btn-glow" id="confirmCountAndSayBtn">
            <i class="fas fa-play me-2"></i>Generate Sequence
        </button>
        <button class="btn btn-outline-light" id="cancelCountAndSayBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>

<!-- String Compression Input Group (initially hidden) -->
<div class="mb-3" id="stringCompressionGroup" style="display: none;">
    <label class="form-label">String Compression - Enter String</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="stringToCompress" 
               placeholder="Enter string (e.g., aabbccc)">
        <button class="btn btn-glow" id="confirmStringCompressionBtn">
            <i class="fas fa-play me-2"></i>Compress String
        </button>
        <button class="btn btn-outline-light" id="cancelStringCompressionBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>
<!-- Delta Encoding Input Group -->
<div class="mb-3" id="deltaEncodingGroup" style="display: none;">
    <label class="form-label">Delta Encoding - Enter Array Details</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="deltaArraySize" placeholder="Array size" min="1" max="20">
        <button class="btn btn-glow" id="confirmDeltaSizeBtn">
            <i class="fas fa-check me-2"></i>Set Size
        </button>
    </div>
    <div id="deltaArrayInputs" class="mt-2"></div>
    <div class="d-grid gap-2 mt-2">
        <button class="btn btn-glow" id="performDeltaEncodingBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Perform Delta Encoding
        </button>
        <button class="btn btn-outline-light" id="cancelDeltaBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>

<!-- BWT Input Group -->
<div class="mb-3" id="bwtGroup" style="display: none;">
    <label class="form-label">Burrows-Wheeler Transform - Enter String</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="bwtString" placeholder="Enter string (e.g., banana)">
        <input type="text" class="form-control" id="bwtSentinel" placeholder="Sentinel (default: $)" value="$">
        <button class="btn btn-glow" id="performBWTBtn">
            <i class="fas fa-play me-2"></i>Perform BWT
        </button>
    </div>
    <button class="btn btn-outline-light w-100" id="cancelBWTBtn">
        <i class="fas fa-times me-2"></i>Cancel
    </button>
</div>

<!-- MTF Input Group -->
<div class="mb-3" id="mtfGroup" style="display: none;">
    <label class="form-label">Move-to-Front Transform - Enter String</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="mtfString" placeholder="Enter string (e.g., broood)">
        <button class="btn btn-glow" id="performMTFBtn">
            <i class="fas fa-play me-2"></i>Perform MTF
        </button>
    </div>
    <button class="btn btn-outline-light w-100" id="cancelMTFBtn">
        <i class="fas fa-times me-2"></i>Cancel
    </button>
</div>
<!-- Add this in the Create Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Browser History Simulation</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="browserHistoryBtn">
            <i class="fas fa-globe me-2"></i>Design Browser History
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Ordered Stream Simulation</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="streamSize" placeholder="Stream size (n)" min="1" max="20">
        <button class="btn btn-glow" id="designOrderedStreamBtn">
            <i class="fas fa-stream me-2"></i>Design Ordered Stream
        </button>
    </div>
    <small class="text-muted">Create an ordered stream and insert values at specific indices</small>
</div>

<!-- Ordered Stream Input Group (initially hidden) -->
<div class="mb-3" id="orderedStreamGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">Insert into Ordered Stream</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="streamIndex" placeholder="Index (1 to n)" min="1">
            <input type="text" class="form-control" id="streamValue" placeholder="Value to insert">
            <button class="btn btn-glow" id="insertIntoStreamBtn">
                <i class="fas fa-plus me-2"></i>Insert
            </button>
        </div>
    </div>
    
    <div class="ordered-stream-results mt-3">
        <h6>Ordered Stream Results</h6>
        <div class="stats-card">
            <div>Current Pointer</div>
            <div class="stats-value" id="currentPointer">1</div>
        </div>
        <div class="stats-card mt-2">
            <div>Last Returned Chunk</div>
            <div class="stats-value" id="lastChunk">[]</div>
        </div>
    </div>
    
    <div class="d-grid gap-2 mt-3">
        <button class="btn btn-outline-light" id="resetStreamBtn">
            <i class="fas fa-undo me-2"></i>Reset Ordered Stream
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Number Theory Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="addDigitsBtn">
            <i class="fas fa-calculator me-2"></i>Add Digits (Digital Root)
        </button>
        <button class="btn btn-glow" id="happyNumberBtn">
            <i class="fas fa-smile me-2"></i>Happy Number Check
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Run-Length Encoding (RLE)</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="rleEncodeBtn">
            <i class="fas fa-compress me-2"></i>RLE - Compress String
        </button>
        <button class="btn btn-glow" id="rleDecodeBtn">
            <i class="fas fa-expand me-2"></i>Decode RLE
        </button>
    </div>
</div>
<!-- Add this in the Create Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Stack Implementation</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="implementStackBtn">
            <i class="fas fa-layer-group me-2"></i>Implement Stack using Arrays
        </button>

    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Queue Implementation</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="implementQueueBtn">
            <i class="fas fa-layer-group me-2"></i>Implement Queue using Arrays
        </button>
    </div>
</div>
<!-- Add this in the Create Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Priority Queue Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="implementPriorityQueueBtn">
            <i class="fas fa-layer-group me-2"></i>Implement Priority Queue
        </button>
    </div>
</div>

<!-- Priority Queue Input Group (initially hidden) -->
<div class="mb-3" id="priorityQueueGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">Initialize Priority Queue</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="queueSizeInput" placeholder="Enter queue size" min="1" max="20">
            <button class="btn btn-glow" id="initializeQueueBtn">
                <i class="fas fa-play me-2"></i>Initialize Queue
            </button>
        </div>
    </div>

    <div class="queue-operations" id="queueOperations" style="display: none;">
        <div class="queue-input-group">
            <input type="number" class="form-control" id="enqueueValue" placeholder="Value">
            <input type="number" class="form-control" id="enqueuePriority" placeholder="Priority">
            <button class="btn btn-glow" id="enqueueBtn">
                <i class="fas fa-plus me-2"></i>Enqueue
            </button>
        </div>
        
        <div class="queue-input-group">
            <button class="btn btn-glow" id="dequeueBtn">
                <i class="fas fa-minus me-2"></i>Dequeue
            </button>
            <button class="btn btn-glow" id="peekBtn">
                <i class="fas fa-eye me-2"></i>Peek
            </button>
        </div>
        
        <div class="queue-input-group">
            <button class="btn btn-outline-light" id="resetQueueBtn">
                <i class="fas fa-undo me-2"></i>Reset Queue
            </button>
        </div>
    </div>

    <div class="queue-stats" id="queueStats" style="display: none;">
        <div class="queue-stat-item">
            <div>Queue Size</div>
            <div class="stats-value" id="currentQueueSize">0</div>
        </div>
        <div class="queue-stat-item">
            <div>Front</div>
            <div class="stats-value" id="queueFront">-</div>
        </div>
        <div class="queue-stat-item">
            <div>Rear</div>
            <div class="stats-value" id="queueRear">-</div>
        </div>
    </div>
</div>
<!-- Stack Implementation Interface (initially hidden) -->
<div class="mb-3" id="stackImplementationGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">Stack Size</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="stackSize" placeholder="Enter stack size" min="1" max="50">
            <button class="btn btn-glow" id="createStackBtn">
                <i class="fas fa-plus-circle me-2"></i>Create Stack
            </button>
        </div>
    </div>

    <div class="mb-3" id="stackOperations" style="display: none;">
        <label class="form-label">Stack Operations</label>
        <div class="input-group mb-2">
            <input type="text" class="form-control" id="pushValue" placeholder="Enter value to push">
            <button class="btn btn-glow" id="pushBtn">
                <i class="fas fa-arrow-up me-2"></i>Push
            </button>
        </div>
        
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="popCount" placeholder="Number of pops" min="1" value="1">
            <button class="btn btn-glow" id="popBtn">
                <i class="fas fa-arrow-down me-2"></i>Pop
            </button>
        </div>
        
        <div class="d-grid gap-2">
            <button class="btn btn-glow" id="peekBtn">
                <i class="fas fa-eye me-2"></i>Peek (Top Element)
            </button>
            <button class="btn btn-glow" id="isFullBtn">
                <i class="fas fa-check-circle me-2"></i>Check if Full
            </button>
            <button class="btn btn-glow" id="isEmptyBtn">
                <i class="fas fa-question-circle me-2"></i>Check if Empty
            </button>
        </div>
        
        <div class="d-grid gap-2 mt-2">
            <button class="btn btn-outline-light" id="resetStackBtn">
                <i class="fas fa-undo me-2"></i>Reset Stack
            </button>
        </div>
    </div>


    <div class="stack-info mt-3" id="stackInfo" style="display: none;">
        <div class="stats-card">
            <div>Stack Size</div>
            <div class="stats-value" id="stackSizeValue">0</div>
        </div>
        <div class="stats-card">
            <div>Current Top</div>
            <div class="stats-value" id="stackTopValue">-1</div>
        </div>
        <div class="stats-card">
            <div>Stack Status</div>
            <div class="stats-value" id="stackStatus">Empty</div>
        </div>
    </div>

    <div class="stack-explanation mt-3" id="stackExplanation" style="display: none;">
        <h6>Stack Implementation using Array</h6>
        <p>A stack is a linear data structure that follows the LIFO (Last-In-First-Out) principle.</p>
        
        <div class="code-snippet">
            class Stack {<br>
            &nbsp;&nbsp;constructor(size) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;this.arr = new Array(size);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;this.top = -1;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;this.capacity = size;<br>
            &nbsp;&nbsp;}<br><br>
            
            &nbsp;&nbsp;push(x) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (this.isFull()) throw "Stack Overflow";<br>
            &nbsp;&nbsp;&nbsp;&nbsp;this.arr[++this.top] = x;<br>
            &nbsp;&nbsp;}<br><br>
            
            &nbsp;&nbsp;pop() {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (this.isEmpty()) throw "Stack Underflow";<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return this.arr[this.top--];<br>
            &nbsp;&nbsp;}<br><br>
            
            &nbsp;&nbsp;peek() {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (this.isEmpty()) throw "Stack is Empty";<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return this.arr[this.top];<br>
            &nbsp;&nbsp;}<br>
            }
        </div>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Find Consecutive Number Sequences</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="consecutiveTargetSum" placeholder="Enter target sum">
        <button class="btn btn-glow" id="findConsecutiveSequencesBtn">
            <i class="fas fa-search me-2"></i>Find Consecutive Sequences
        </button>
    </div>
    <small class="text-muted">Find all sequences of consecutive numbers that sum to target</small>
</div>
<!-- Add this in the Create Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Pascal's Triangle</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="pascalRowNumber" placeholder="Row number (0-indexed)" min="0" max="20">
        <button class="btn btn-glow" id="pascalSpecificRowBtn">
            <i class="fas fa-triangle me-2"></i>Pascal's Triangle with Specific Row
        </button>
    </div>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="pascalNumRows" placeholder="Number of rows" min="1" max="10">
        <button class="btn btn-glow" id="pascalMultipleRowsBtn">
            <i class="fas fa-layer-group me-2"></i>Pascal's Triangle with No of Rows
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Random Pick with Weight</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="randomPickWithWeightBtn">
            <i class="fas fa-dice me-2"></i>Random Pick with Weight
        </button>
    </div>
    <small class="text-muted">Randomly select an element based on weights using Cumulative Weights method</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Generate Random Point in Circle</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="generateRandomPointBtn">
            <i class="fas fa-bullseye me-2"></i>Generate Random Point in Circle
        </button>
    </div>
    <small class="text-muted">Uses array elements as center coordinates and radius</small>
</div>

        <!-- Algorithm Explanation -->
        <div class="algorithm-explanation mt-3" id="uglyNumberExplanation">
            <h6>Ugly Number Algorithms</h6>
            
            <div class="mb-3">
                <strong>Ugly Number Check:</strong>
                <div class="code-snippet">
                    function isUgly(num) {<br>
                    &nbsp;&nbsp;if (num <= 0) return false;<br>
                    &nbsp;&nbsp;while (num % 2 === 0) num /= 2;<br>
                    &nbsp;&nbsp;while (num % 3 === 0) num /= 3;<br>
                    &nbsp;&nbsp;while (num % 5 === 0) num /= 5;<br>
                    &nbsp;&nbsp;return num === 1;<br>
                    }
                </div>
            </div>
            
            <div class="mb-3">
                <strong>Nth Ugly Number (Dynamic Programming):</strong>
                <div class="code-snippet">
                    function nthUglyNumber(n) {<br>
                    &nbsp;&nbsp;let ugly = [1];<br>
                    &nbsp;&nbsp;let i2 = 0, i3 = 0, i5 = 0;<br>
                    &nbsp;&nbsp;for (let i = 1; i < n; i++) {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;let next = Math.min(ugly[i2]*2, ugly[i3]*3, ugly[i5]*5);<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;ugly.push(next);<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;if (next === ugly[i2]*2) i2++;<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;if (next === ugly[i3]*3) i3++;<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;if (next === ugly[i5]*5) i5++;<br>
                    &nbsp;&nbsp;}<br>
                    &nbsp;&nbsp;return ugly[n-1];<br>
                    }
                </div>
            </div>
            
            <div class="mb-3">
                <strong>Super Ugly Number:</strong>
                <div class="code-snippet">
                    function superUglyNumber(n, primes) {<br>
                    &nbsp;&nbsp;let ugly = [1];<br>
                    &nbsp;&nbsp;let indices = Array(primes.length).fill(0);<br>
                    &nbsp;&nbsp;for (let i = 1; i < n; i++) {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;let next = Math.min(...primes.map((p, j) => ugly[indices[j]] * p));<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;ugly.push(next);<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;primes.forEach((p, j) => {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (next === ugly[indices[j]] * p) indices[j]++;<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;});<br>
                    &nbsp;&nbsp;}<br>
                    &nbsp;&nbsp;return ugly[n-1];<br>
                    }
                </div>
            </div>
        </div>
    </div>
</div>
<!-- String Operations Tab -->
<div class="tab-pane fade" id="string" role="tabpanel">
 <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Pattern Searching Algorithms</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="rabinKarpBtn">
            <i class="fas fa-search me-2"></i>Rabin-Karp Algorithm
        </button>
        <button class="btn btn-glow" id="zAlgorithmBtn">
            <i class="fas fa-project-diagram me-2"></i>Z-Algorithm
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Word Abbreviation Validation</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="wordInput" placeholder="Enter word (e.g., internationalization)">
        <input type="text" class="form-control" id="abbrInput" placeholder="Enter abbreviation (e.g., i12iz4n)">
        <button class="btn btn-glow" id="wordAbbrValidationBtn">
            <i class="fas fa-check-circle me-2"></i>Validate Abbreviation
        </button>
    </div>
    <small class="text-muted">Abbreviation must be alphanumeric (e.g., w3b4j9)</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">String Algorithms</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="groupShiftedStringsBtn">
            <i class="fas fa-object-group me-2"></i>Group Shifted Strings
        </button>
        <button class="btn btn-glow" id="flipGameBtn">
            <i class="fas fa-sync-alt me-2"></i>Flip Game
        </button>
    </div>
</div>

<!-- Group Shifted Strings Input Group (initially hidden) -->
<div class="mb-3" id="groupShiftedStringsGroup" style="display: none;">
    <label class="form-label">Group Shifted Strings</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="shiftedStringsSize" placeholder="Enter array size" min="1" max="20">
        <button class="btn btn-glow" id="confirmShiftedStringsSizeBtn">
            <i class="fas fa-check me-2"></i>Set Array Size
        </button>
    </div>
    <div id="shiftedStringsInputs" class="mt-2"></div>
    <div class="d-grid gap-2 mt-2">
        <button class="btn btn-glow" id="performGroupShiftedStringsBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Group Shifted Strings
        </button>
        <button class="btn btn-outline-light" id="cancelGroupShiftedStringsBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>

<!-- Flip Game Input Group (initially hidden) -->
<div class="mb-3" id="flipGameGroup" style="display: none;">
    <label class="form-label">Flip Game</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="flipGameInput" placeholder="Enter string with + and - only (e.g., ++++--)">
        <button class="btn btn-glow" id="performFlipGameBtn">
            <i class="fas fa-play me-2"></i>Generate Next Moves
        </button>
    </div>
    <small class="text-muted">Enter a string containing only + and - characters</small>
    <div class="d-grid gap-2 mt-2">
        <button class="btn btn-outline-light" id="cancelFlipGameBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>
<!-- Pattern Search Input Group (initially hidden) -->
<div class="mb-3" id="patternSearchGroup" style="display: none;">
    <div class="pattern-search-inputs">
        <h6 id="patternAlgorithmTitle">Pattern Search Algorithm</h6>
        
        <div class="mb-3">
            <label class="form-label">Enter Text</label>
            <input type="text" class="form-control" id="searchTextInput" 
                   placeholder="Enter the text to search in">
        </div>
        
        <div class="mb-3">
            <label class="form-label">Enter Pattern</label>
            <input type="text" class="form-control" id="searchPatternInput" 
                   placeholder="Enter the pattern to search for">
        </div>
        
        <div class="d-grid gap-2">
            <button class="btn btn-glow" id="startPatternSearchBtn">
                <i class="fas fa-play me-2"></i>Start Pattern Search
            </button>
            <button class="btn btn-outline-light" id="cancelPatternSearchBtn">
                <i class="fas fa-times me-2"></i>Cancel
            </button>
        </div>
    </div>
</div>
<!-- Add this in the Create Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Shortest Word Distance</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="shortestWordDistanceBtn">
            <i class="fas fa-route me-2"></i>Shortest Word Distance
        </button>
    </div>
</div>

<!-- Shortest Word Distance Input Group (initially hidden) -->
<div class="mb-3" id="shortestWordDistanceGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">Array Size</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="wordArraySize" placeholder="Enter array size" min="1" max="20">
            <button class="btn btn-glow" id="confirmWordArraySizeBtn">
                <i class="fas fa-check me-2"></i>Set Array Size
            </button>
        </div>
    </div>

    <div id="wordArrayInputs" class="mt-2"></div>

    <div class="mb-3" id="wordSearchInputs" style="display: none;">
        <label class="form-label">Find Shortest Distance Between Words</label>
        <div class="input-group mb-2">
            <input type="text" class="form-control" id="word1Input" placeholder="Enter word 1">
            <input type="text" class="form-control" id="word2Input" placeholder="Enter word 2">
            <button class="btn btn-glow" id="findShortestDistanceBtn">
                <i class="fas fa-search me-2"></i>Find Distance
            </button>
        </div>
    </div>

    <div class="d-grid gap-2">
        <button class="btn btn-outline-light" id="cancelShortestWordDistanceBtn">
            <i class="fas fa-times me-2"></i>Cancel Operation
        </button>
    </div>
</div>

<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Split Array Largest Sum</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="splitArrayK" placeholder="Enter k (1 to n)" min="1">
        <button class="btn btn-glow" id="splitArrayLargestSumBtn">
            <i class="fas fa-code-branch me-2"></i>Split Array Largest Sum
        </button>
    </div>
    <small class="text-muted">Split array into k subarrays to minimize the largest sum</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Subarrays with K Different Integers</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="kDifferentIntegers" placeholder="Enter k value" min="1">
        <button class="btn btn-glow" id="kDifferentIntegersBtn">
            <i class="fas fa-calculator me-2"></i>Find Subarrays with K Different Integers
        </button>
    </div>
    <small class="text-muted">Count subarrays with exactly k distinct integers</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Longest Turbulent Subarray</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="longestTurbulentSubarrayBtn">
            <i class="fas fa-wave-square me-2"></i>Find Longest Turbulent Subarray
        </button>
    </div>
    <small class="text-muted">Find the longest subarray where comparison signs alternate between elements</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Reverse Pairs Algorithm</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="reversePairsBtn">
            <i class="fas fa-exchange-alt me-2"></i>Find Reverse Pairs
        </button>
    </div>
    <small class="text-muted">Count pairs (i, j) where i &lt; j and nums[i] &gt; 2 * nums[j]</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Array Analysis - Inversions</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="inversionsAnalysisBtn">
            <i class="fas fa-exchange-alt me-2"></i>Global & Local Inversions Analysis
        </button>
    </div>
    <small class="text-muted">Analyze local and global inversions with step-by-step visualization</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Range & Interval Problems</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="summaryRangesBtn">
            <i class="fas fa-compress-alt me-2"></i>Find Summary Ranges
        </button>
        <button class="btn btn-glow" id="findRightIntervalBtn">
            <i class="fas fa-arrow-right me-2"></i>Find Right Interval
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Game Algorithms</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="teemoAttackingBtn">
            <i class="fas fa-skull-crossbones me-2"></i>Teemo Attacking (Poison Duration)
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Interval Problems</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="minArrowsBtn">
            <i class="fas fa-bullseye me-2"></i>Minimum Number of Arrows
        </button>
    </div>
    <small class="text-muted">Find minimum arrows to burst overlapping balloons (intervals)</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Special Array Problems</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="buildingsOceanViewBtn">
            <i class="fas fa-building me-2"></i>Buildings With Ocean View
        </button>
        <button class="btn btn-glow" id="createTargetArrayBtn">
            <i class="fas fa-bullseye me-2"></i>Create Target Array
        </button>
    </div>
</div>

<!-- Buildings Ocean View Input Group (initially hidden) -->
<div class="mb-3" id="buildingsOceanViewGroup" style="display: none;">
    <label class="form-label">Enter Building Heights (comma-separated numbers)</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="buildingHeights" placeholder="e.g., 4,2,3,1">
        <button class="btn btn-glow" id="confirmBuildingHeightsBtn">
            <i class="fas fa-play me-2"></i>Find Ocean View Buildings
        </button>
    </div>
    <small class="text-muted">Enter building heights to find which buildings have ocean view</small>
</div>

<!-- Create Target Array Input Group (initially hidden) -->
<div class="mb-3" id="createTargetArrayGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">Enter Values Array (comma-separated)</label>
        <div class="input-group mb-2">
            <input type="text" class="form-control" id="targetArrayValues" placeholder="e.g., 0,1,2,3,4">
            <button class="btn btn-glow" id="confirmTargetValuesBtn">
                <i class="fas fa-check me-2"></i>Set Values
            </button>
        </div>
    </div>
    
    <div class="mb-3">
        <label class="form-label">Enter Index Array (comma-separated, 0 to n-1)</label>
        <div class="input-group mb-2">
            <input type="text" class="form-control" id="targetArrayIndices" placeholder="e.g., 0,1,2,2,1">
            <button class="btn btn-glow" id="confirmTargetIndicesBtn">
                <i class="fas fa-check me-2"></i>Set Indices
            </button>
        </div>
        <small class="text-muted">Index array size must match values array size</small>
    </div>
    
    <div class="d-grid gap-2">
        <button class="btn btn-glow" id="performTargetArrayBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Create Target Array
        </button>
        <button class="btn btn-outline-light" id="cancelTargetArrayBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>
<!-- Add this in the Create Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Queue Reconstruction by Height</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="queueReconstructionBtn">
            <i class="fas fa-users me-2"></i>Queue Reconstruction
        </button>
    </div>
</div>

<!-- Queue Reconstruction Input Group (initially hidden) -->
<div class="mb-3" id="queueReconstructionGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">Enter Number of People</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="queueSize" placeholder="Number of people" min="1" max="20">
            <button class="btn btn-glow" id="confirmQueueSizeBtn">
                <i class="fas fa-check me-2"></i>Set Queue Size
            </button>
        </div>
    </div>

    <div id="queueInputs" class="mt-2"></div>

    <div class="d-grid gap-2">
        <button class="btn btn-glow" id="performQueueReconstructionBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Perform Queue Reconstruction
        </button>
        <button class="btn btn-outline-light" id="cancelQueueReconstructionBtn">
            <i class="fas fa-times me-2"></i>Cancel Operation
        </button>
    </div>
</div>
<!-- Add this in the Create Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Crawler Log Folder Simulation</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="crawlerLogFolderBtn">
            <i class="fas fa-folder-tree me-2"></i>Crawler Log Folder
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing buttons -->
<div class="mb-3">
    <label class="form-label">Gray Code Generator</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="grayCodeBtn">
            <i class="fas fa-code-branch me-2"></i>Generate Gray Code Sequence
        </button>
    </div>
    <small class="text-muted">Generate Gray code where successive numbers differ by exactly one bit</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Find Smallest Divisor Given Threshold</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="thresholdValue" placeholder="Enter threshold value" min="1">
        <button class="btn btn-glow" id="findSmallestDivisorBtn">
            <i class="fas fa-divide me-2"></i>Find Smallest Divisor
        </button>
    </div>
    <small class="text-muted">Binary search to find smallest divisor where sum of ceil(arr[i]/divisor)  threshold</small>
</div>
<!-- Gray Code Input Group (initially hidden) -->
<div class="mb-3" id="grayCodeInputGroup" style="display: none;">
    <label class="form-label">Enter Number of Bits</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="grayCodeBits" 
               placeholder="Enter bits (1 to 5)" min="1" max="5" value="3">
        <button class="btn btn-glow" id="generateGrayCodeBtn">
            <i class="fas fa-play me-2"></i>Generate Gray Code
        </button>
        <button class="btn btn-outline-light" id="cancelGrayCodeBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
    <small class="text-muted">Higher bit counts will show more detailed visualization</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Capacity To Ship Packages</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="capacityToShipBtn">
            <i class="fas fa-ship me-2"></i>Capacity To Ship Packages
        </button>
    </div>
</div>

<!-- Capacity Input Group (initially hidden) -->
<div class="mb-3" id="capacityInputGroup" style="display: none;">
    <label class="form-label">Enter Number of Days</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="capacityDays" 
               placeholder="Enter days (e.g., 5)" min="1">
        <button class="btn btn-glow" id="confirmCapacityBtn">
            <i class="fas fa-play me-2"></i>Start Calculation
        </button>
        <button class="btn btn-outline-light" id="cancelCapacityBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
    <small class="text-muted">Find minimum capacity to ship all packages within given days</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Koko Eating Bananas Algorithm</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="kokoHours" placeholder="Enter hours (h)" min="1">
        <button class="btn btn-glow" id="kokoBananasBtn">
            <i class="fas fa-banana me-2"></i>Koko Eating Bananas
        </button>
    </div>
    <small class="text-muted">Find minimum eating speed to finish all bananas within given hours</small>
</div>

<!-- Koko's Input Group (initially hidden) -->
<div class="mb-3" id="kokoInputGroup" style="display: none;">
    <label class="form-label">Set Banana Piles</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="kokoPileCount" placeholder="Number of piles (1-10)" min="1" max="10">
        <button class="btn btn-glow" id="confirmKokoPilesBtn">
            <i class="fas fa-check me-2"></i>Set Piles
        </button>
    </div>
    <div id="kokoPileInputs" class="mt-2"></div>
    
    <div class="d-grid gap-2 mt-3">
        <button class="btn btn-glow" id="startKokoAlgorithmBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Start Koko's Algorithm
        </button>
        <button class="btn btn-outline-light" id="cancelKokoBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>
<!-- Add this in the Search Tab after the Element Analysis section -->
<div class="mb-3">
    <label class="form-label">First Bad Version Algorithm</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="versionCount" placeholder="Enter n (total versions)" min="1" max="100">
        <button class="btn btn-glow" id="firstBadVersionBtn">
            <i class="fas fa-bug me-2"></i>Find First Bad Version
        </button>
    </div>
    <small class="text-muted">Find the first bad version in [G, G, ..., B, B, ...] array</small>
</div>
    <!-- NEW: String Operations Section -->
            <div class="mb-3">
                <label class="form-label">String Array Operations</label>
                <div class="input-group mb-2">
                    <button class="btn btn-glow" id="maxProductBtn">
                        <i class="fas fa-calculator me-2"></i>Maximum Product of Word Lengths
                    </button>
                    <button class="btn btn-glow" id="countConsistentBtn">
                        <i class="fas fa-check-circle me-2"></i>Count Consistent Strings
                    </button>
                </div>
            </div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">House Robber Problem</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="houseRobberBtn">
            <i class="fas fa-home me-2"></i>House Robber Problem
        </button>
    </div>
    <small class="text-muted">Maximum sum of non-adjacent elements with DP visualization</small>
</div>

<!-- House Robber Input Group (initially hidden) -->
<div class="mb-3" id="houseRobberGroup" style="display: none;">
    <label class="form-label">Enter House Values (comma-separated)</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="houseValues" 
               placeholder="e.g., 1,2,4,8,16" value="">
        <button class="btn btn-glow" id="confirmHouseRobberBtn">
            <i class="fas fa-play me-2"></i>Run House Robber
        </button>
    </div>
    <div class="input-group mb-2">
        <button class="btn btn-outline-light" id="useCurrentArrayBtn">
            <i class="fas fa-exchange-alt me-2"></i>Use Current Array
        </button>
        <button class="btn btn-outline-light" id="generateRandomHousesBtn">
            <i class="fas fa-dice me-2"></i>Generate Random Houses
        </button>
    </div>
    <div class="d-grid gap-2">
        <button class="btn btn-outline-light" id="cancelHouseRobberBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>            
            <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Hamming Weight & Distance Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="hammingWeightBtn">
            <i class="fas fa-binary me-2"></i>Number of 1 Bits (Hamming Weight) for an Array
        </button>
        <button class="btn btn-glow" id="hammingDistanceBtn">
            <i class="fas fa-exchange-alt me-2"></i>Total Hamming Distance
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Shortest Superstring (NP-hard Problem)</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="superstringCount" placeholder="Number of strings" min="2" max="10">
        <button class="btn btn-glow" id="shortestSuperstringBtn">
            <i class="fas fa-link me-2"></i>Find Shortest Superstring
        </button>
    </div>
    <small class="text-muted">Greedy algorithm for the NP-hard Shortest Superstring problem</small>
</div>

<!-- Superstring Input Group (initially hidden) -->
<div class="mb-3" id="superstringInputGroup" style="display: none;">
    <div id="superstringInputs" class="mt-2"></div>
    
    <div class="d-grid gap-2 mt-3">
        <button class="btn btn-glow" id="performSuperstringBtn">
            <i class="fas fa-play me-2"></i>Find Shortest Superstring
        </button>
        <button class="btn btn-outline-light" id="cancelSuperstringBtn">
            <i class="fas fa-times me-2"></i>Cancel Operation
        </button>
    </div>
</div>
<!-- Hamming Operations Input Group (initially hidden) -->
<div class="mb-3" id="hammingOperationsGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label" id="hammingOperationLabel">Enter Array Details</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="hammingArraySize" placeholder="Size of array" min="1" max="20">
            <button class="btn btn-glow" id="confirmHammingArraySizeBtn">
                <i class="fas fa-check me-2"></i>Set Array Size
            </button>
        </div>
        <div id="hammingArrayInputs" class="mt-2"></div>
    </div>

    <div class="d-grid gap-2">
        <button class="btn btn-glow" id="performHammingOperationBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Perform Operation
        </button>
        <button class="btn btn-outline-light" id="cancelHammingOperationBtn">
            <i class="fas fa-times me-2"></i>Cancel Operation
        </button>
    </div>
</div>
            <!-- Input Group for String Operations (initially hidden) -->
            <div class="mb-3" id="stringOperationGroup" style="display: none;">
                <div class="mb-3">
                    <label class="form-label" id="stringOperationTitle">Operation Details</label>
                    <div class="input-group mb-2">
                        <input type="number" class="form-control" id="stringArraySize" placeholder="Size of array" min="1" max="20">
                        <button class="btn btn-glow" id="confirmStringArraySizeBtn">
                            <i class="fas fa-check me-2"></i>Set Array Size
                        </button>
                    </div>
                    <div id="stringArrayInputs" class="mt-2"></div>
                </div>
                
                <div class="d-grid gap-2">
                    <button class="btn btn-glow" id="performStringOperationBtn" style="display: none;">
                        <i class="fas fa-play me-2"></i>Perform Operation
                    </button>
                    <button class="btn btn-outline-light" id="cancelStringOperationBtn">
                        <i class="fas fa-times me-2"></i>Cancel Operation
                    </button>
                </div>
            </div>
          <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Bitwise Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="subarrayBitwiseORsBtn">
            <i class="fas fa-code me-2"></i>Subarray Bitwise ORs
        </button>
        <button class="btn btn-glow" id="bitwiseAndRangeBtn">
            <i class="fas fa-binary me-2"></i>Bitwise AND of Numbers Range
        </button>
    </div>
</div>  
<!-- Crawler Log Input Group (initially hidden) -->
<div class="mb-3" id="crawlerLogGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">Enter Log Array Size</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="crawlerLogSize" placeholder="Size of log array" min="1" max="20">
            <button class="btn btn-glow" id="confirmCrawlerLogSizeBtn">
                <i class="fas fa-check me-2"></i>Set Array Size
            </button>
        </div>
    </div>

    <div id="crawlerLogInputs" class="mt-2"></div>

    <div class="d-grid gap-2">
        <button class="btn btn-glow" id="performCrawlerLogBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Simulate Crawler Log
        </button>
        <button class="btn btn-outline-light" id="cancelCrawlerLogBtn">
            <i class="fas fa-times me-2"></i>Cancel Operation
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Single Number Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="singleNumberIIBtn">
            <i class="fas fa-hashtag me-2"></i>Single Number II
        </button>
        <button class="btn btn-glow" id="singleNumberIIIBtn">
            <i class="fas fa-hashtag me-2"></i>Single Number III
        </button>
    </div>
    <small class="text-muted">Find elements that appear once when others appear multiple times</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Compression & Nesting Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="decompressRLEBtn">
            <i class="fas fa-expand-alt me-2"></i>Decompress Run-Length Encoded List
        </button>
        <button class="btn btn-glow" id="arrayNestingBtn">
            <i class="fas fa-project-diagram me-2"></i>Array Nesting
        </button>
    </div>
</div>
<!-- Add this in the Create Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Nim Game</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="nimGameBtn">
            <i class="fas fa-gamepad me-2"></i>Play Nim Game
        </button>
    </div>
</div>
<!-- Add this in the Create Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Predict the Winner Game</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="predictWinnerBtn">
            <i class="fas fa-trophy me-2"></i>Predict the Winner
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Stone Game Simulation</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="stoneGameBtn">
            <i class="fas fa-gem me-2"></i>Stone Game
        </button>
    </div>
</div>
<!-- Stone Game Input Group (initially hidden) -->
<div class="mb-3" id="stoneGameGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">Game Configuration</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="totalStones" placeholder="Total stones" min="5" max="100" value="20">
            <input type="number" class="form-control" id="maxPick" placeholder="Max pick per turn" min="1" max="10" value="3">
        </div>
        <div class="input-group mb-2">
            <input type="text" class="form-control" id="player1Name" placeholder="Player 1 name" value="Alice">
            <input type="text" class="form-control" id="player2Name" placeholder="Player 2 name" value="Bob">
        </div>
        <div class="d-grid gap-2">
            <button class="btn btn-glow" id="startStoneGameBtn">
                <i class="fas fa-play me-2"></i>Start Stone Game
            </button>
            <button class="btn btn-outline-light" id="cancelStoneGameBtn">
                <i class="fas fa-times me-2"></i>Cancel
            </button>
        </div>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Gas Station Problem</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="gasStationBtn">
            <i class="fas fa-gas-pump me-2"></i>Gas Station Problem
        </button>
    </div>
    <small class="text-muted">Solve circular route gas station problem</small>
</div>

<!-- Gas Station Input Group (initially hidden) -->
<div class="mb-3" id="gasStationGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">Number of Gas Stations</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="gasStationCount" placeholder="Enter number of stations" min="1" max="20">
            <button class="btn btn-glow" id="confirmGasStationCountBtn">
                <i class="fas fa-check me-2"></i>Set Station Count
            </button>
        </div>
    </div>

    <div id="gasStationInputs" class="mt-2"></div>

    <div class="d-grid gap-2">
        <button class="btn btn-glow" id="solveGasStationBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Solve Gas Station Problem
        </button>
        <button class="btn btn-outline-light" id="cancelGasStationBtn">
            <i class="fas fa-times me-2"></i>Cancel Operation
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Task Scheduler with Cooldown Period</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="taskSchedulerBtn">
            <i class="fas fa-tasks me-2"></i>Task Scheduler with Cooldown
        </button>
    </div>
</div>

<!-- Task Scheduler Input Group (initially hidden) -->
<div class="mb-3" id="taskSchedulerGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">Task Scheduler Setup</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="taskArraySize" placeholder="Number of tasks" min="1" max="20">
            <button class="btn btn-glow" id="confirmTaskSizeBtn">
                <i class="fas fa-check me-2"></i>Set Task Count
            </button>
        </div>
        <div id="taskInputs" class="mt-2"></div>
        
        <div class="input-group mb-2 mt-3">
            <input type="number" class="form-control" id="cooldownPeriod" placeholder="Cooldown period" min="0" max="10">
            <button class="btn btn-glow" id="performTaskSchedulingBtn" style="display: none;">
                <i class="fas fa-play me-2"></i>Start Task Scheduling
            </button>
        </div>
        
        <div class="d-grid gap-2">
            <button class="btn btn-outline-light" id="cancelTaskSchedulingBtn">
                <i class="fas fa-times me-2"></i>Cancel Task Scheduling
            </button>
        </div>
    </div>
</div>
<!-- Predict Winner Input Group (initially hidden) -->
<div class="mb-3" id="predictWinnerGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">Game Array Details</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="predictWinnerSize" placeholder="Size of array" min="1" max="20">
            <button class="btn btn-glow" id="confirmPredictWinnerSizeBtn">
                <i class="fas fa-check me-2"></i>Set Array Size
            </button>
        </div>
        <div id="predictWinnerInputs" class="mt-2"></div>
    </div>

    <div class="d-grid gap-2">
        <button class="btn btn-glow" id="performPredictWinnerBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Start Prediction Game
        </button>
        <button class="btn btn-outline-light" id="cancelPredictWinnerBtn">
            <i class="fas fa-times me-2"></i>Cancel Game
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Candy Distribution Problem</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="candyDistributeBtn">
            <i class="fas fa-candy-cane me-2"></i>Candy Distribute Problem
        </button>
    </div>
</div>

<!-- Candy Distribution Input Group (initially hidden) -->
<div class="mb-3" id="candyInputGroup" style="display: none;">
    <label class="form-label">Enter Array Size</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="candyArraySize" placeholder="Size of array" min="1" max="20">
        <button class="btn btn-glow" id="confirmCandySizeBtn">
            <i class="fas fa-check me-2"></i>Set Array Size
        </button>
    </div>
    
    <div id="candyArrayInputs" class="mt-2"></div>
    
    <div class="d-grid gap-2 mt-3">
        <button class="btn btn-glow" id="performCandyDistributionBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Perform Candy Distribution
        </button>
        <button class="btn btn-outline-light" id="cancelCandyBtn">
            <i class="fas fa-times me-2"></i>Cancel Operation
        </button>
    </div>
</div>
<!-- Nim Game Input Group (initially hidden) -->
<div class="mb-3" id="nimGameGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">Nim Game Setup</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="nimArraySize" placeholder="Number of piles" min="1" max="10">
            <button class="btn btn-glow" id="confirmNimSizeBtn">
                <i class="fas fa-check me-2"></i>Set Number of Piles
            </button>
        </div>
        <div id="nimPilesInputs" class="mt-2"></div>
    </div>

    <div class="d-grid gap-2">
        <button class="btn btn-glow" id="playNimGameBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Play Nim Game
        </button>
        <button class="btn btn-outline-light" id="cancelNimGameBtn">
            <i class="fas fa-times me-2"></i>Cancel Nim Game
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Sequence Division Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="divideKConsecutiveBtn">
            <i class="fas fa-layer-group me-2"></i>Divide Array in Sets of K Consecutive Numbers
        </button>
    </div>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="divideIncreasingSequencesBtn">
            <i class="fas fa-chart-line me-2"></i>Divide Array Into Increasing Sequences
        </button>
    </div>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="splitBalancedStringsBtn">
            <i class="fas fa-code me-2"></i>Split a String in Balanced Strings
        </button>
    </div>
</div>

<!-- Input groups (initially hidden) -->
<div class="mb-3" id="kConsecutiveInputGroup" style="display: none;">
    <label class="form-label">Enter K Value for Consecutive Numbers</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="kConsecutiveValue" placeholder="Enter k value" min="2">
        <button class="btn btn-glow" id="confirmKConsecutiveBtn">
            <i class="fas fa-play me-2"></i>Start Operation
        </button>
        <button class="btn btn-outline-light" id="cancelKConsecutiveBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>

<div class="mb-3" id="increasingSequencesInputGroup" style="display: none;">
    <label class="form-label">Enter K Value for Increasing Sequences</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="kIncreasingValue" placeholder="Enter k value" min="2">
        <button class="btn btn-glow" id="confirmIncreasingSequencesBtn">
            <i class="fas fa-play me-2"></i>Start Operation
        </button>
        <button class="btn btn-outline-light" id="cancelIncreasingSequencesBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>

<div class="mb-3" id="balancedStringsInputGroup" style="display: none;">
    <label class="form-label">Enter String with L and R only</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="balancedStringInput" placeholder="Enter string (e.g., LRLRLLRR)">
        <button class="btn btn-glow" id="confirmBalancedStringsBtn">
            <i class="fas fa-play me-2"></i>Start Operation
        </button>
        <button class="btn btn-outline-light" id="cancelBalancedStringsBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
    <small class="text-muted">String should contain only 'L' and 'R' characters</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Substring Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="threeCharsSubstringsBtn">
            <i class="fas fa-calculator me-2"></i>Number of Substrings Containing All Three Characters ('a', 'b', 'c')
        </button>
    </div>
</div>
<!-- Input group for string input (initially hidden) -->
<div class="mb-3" id="threeCharsInputGroup" style="display: none;">
    <label class="form-label">Enter a string containing 'a', 'b', 'c' characters</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="threeCharsInput" placeholder="e.g., abcabc, aaabbbccc, etc.">
        <button class="btn btn-glow" id="confirmThreeCharsBtn">
            <i class="fas fa-play me-2"></i>Calculate Substrings
        </button>
        <button class="btn btn-outline-light" id="cancelThreeCharsBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
    <small class="text-muted">Enter a string containing characters 'a', 'b', and 'c'</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Count Number of Nice Subarrays</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="niceSubarrayK" placeholder="Enter k (number of odd numbers)" min="1">
        <button class="btn btn-glow" id="countNiceSubarraysBtn">
            <i class="fas fa-calculator me-2"></i>Count Number of Nice Subarrays
        </button>
    </div>
    <small class="text-muted">Count subarrays with exactly k odd numbers</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Array Partitioning</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="partitionDisjointBtn">
            <i class="fas fa-code-branch me-2"></i>Partition Array into Disjoint Intervals
        </button>
    </div>
    <small class="text-muted">Partition array such that every element in left <= every element in right</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Partition Array for Maximum Sum</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="partitionKValue" placeholder="Enter k value" min="1">
        <button class="btn btn-glow" id="partitionArrayBtn">
            <i class="fas fa-object-group me-2"></i>Partition Array for Maximum Sum
        </button>
    </div>
    <small class="text-muted">Partition array into subarrays of length at most k to maximize sum</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">String Partition Labels</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="partitionLabelsStringInput" placeholder="Enter string (e.g., ababcbacadefegdehijhklij)">
        <button class="btn btn-glow" id="partitionLabelsOperationBtn">
            <i class="fas fa-object-group me-2"></i>Partition Labels
        </button>
    </div>
    <small class="text-muted">Partition string where each character appears in only one partition</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Split Array with Equal Sum</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="splitEqualSumBtn">
            <i class="fas fa-divide me-2"></i>Split Array into Three Equal Sum Parts
        </button>
    </div>
    <small class="text-muted">Check if array can be split into three contiguous parts with equal sum</small>
</div>
    <div class="mb-3">
        <label class="form-label">Encode and Decode Strings</label>
        <div class="input-group mb-2">
            <input type="text" class="form-control" id="stringsInput" placeholder='["Hello", "World", "!@#$%^", ""]'>
            <input type="text" class="form-control" id="delimiterInput" placeholder='Delimiter (e.g., #)' value="#">
            <button class="btn btn-glow" id="encodeDecodeBtn">
                <i class="fas fa-code me-2"></i>Encode/Decode
            </button>
        </div>
        <small class="text-muted">Enter strings as JSON array and choose delimiter</small>
    </div>
    
    <div class="mb-3">
        <label class="form-label">Reorder Data in Log Files</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="logCount" placeholder="Number of logs" min="1" max="20">
            <button class="btn btn-glow" id="setLogCountBtn">
                <i class="fas fa-check me-2"></i>Set Count
            </button>
        </div>
        <div id="logInputs" class="mt-2"></div>
        <button class="btn btn-glow w-100 mt-2" id="reorderLogsBtn" style="display: none;">
            <i class="fas fa-sort-alpha-down me-2"></i>Reorder Log Files
        </button>
    </div>
    <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Can I Win Game</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="maxChoosableInteger" placeholder="Max Integer" min="1" max="20">
        <input type="number" class="form-control" id="desiredTotal" placeholder="Desired Total" min="0">
        <button class="btn btn-glow" id="canIWinBtn">
            <i class="fas fa-trophy me-2"></i>Can I Win
        </button>
    </div>
    <small class="text-muted">Game theory: Can the first player force a win?</small>
</div>

    <div class="algorithm-explanation mt-3">
        <h6>String Operations Algorithms</h6>
        
        <div class="mb-3">
            <strong>Encode/Decode Strings:</strong>
            <div class="code-snippet">
                def encode(strs):<br>
                &nbsp;&nbsp;if not strs: return ""<br>
                &nbsp;&nbsp;encoded = []<br>
                &nbsp;&nbsp;for s in strs:<br>
                &nbsp;&nbsp;&nbsp;&nbsp;encoded.append(f"{len(s)}#{s}")<br>
                &nbsp;&nbsp;return "".join(encoded)<br><br>
                
                def decode(s):<br>
                &nbsp;&nbsp;if not s: return []<br>
                &nbsp;&nbsp;res = []<br>
                &nbsp;&nbsp;i = 0<br>
                &nbsp;&nbsp;while i < len(s):<br>
                &nbsp;&nbsp;&nbsp;&nbsp;delimiter_idx = s.find('#', i)<br>
                &nbsp;&nbsp;&nbsp;&nbsp;length = int(s[i:delimiter_idx])<br>
                &nbsp;&nbsp;&nbsp;&nbsp;i = delimiter_idx + 1<br>
                &nbsp;&nbsp;&nbsp;&nbsp;res.append(s[i:i + length])<br>
                &nbsp;&nbsp;&nbsp;&nbsp;i += length<br>
                &nbsp;&nbsp;return res
            </div>
        </div>
        <!-- Add this in the Advanced Basic Operations Tab after existing algorithm explanations -->
 <div class="algorithm-explanation mt-3" id="kokoAlgorithmExplanation">
    <h6>Koko Eating Bananas Algorithm</h6>
    <p>Koko wants to eat all bananas in h hours. Each pile has a different number of bananas. Koko can eat k bananas per hour from any pile. Find the minimum k such that Koko can eat all bananas within h hours.</p>
    
    <div class="mb-3">
        <strong>Algorithm Steps:</strong>
        <div class="code-snippet">
            function minEatingSpeed(piles, h):<br>
            &nbsp;&nbsp;left = 1, right = max(piles)<br>
            &nbsp;&nbsp;while left < right:<br>
            &nbsp;&nbsp;&nbsp;&nbsp;mid = (left + right) // 2<br>
            &nbsp;&nbsp;&nbsp;&nbsp;hours_needed = 0<br>
            &nbsp;&nbsp;&nbsp;&nbsp;for pile in piles:<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hours_needed += ceil(pile / mid)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if hours_needed <= h:<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right = mid  // Try smaller speed<br>
            &nbsp;&nbsp;&nbsp;&nbsp;else:<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left = mid + 1  // Need larger speed<br>
            &nbsp;&nbsp;return left
        </div>
    </div>
    
    <div class="mb-3">
        <strong>Example:</strong>
        <div class="code-snippet">
            piles = [3, 6, 7, 11], h = 8<br>
            k = 4  hours = ceil(3/4)+ceil(6/4)+ceil(7/4)+ceil(11/4) = 1+2+2+3 = 8 <br>
            k = 3  hours = ceil(3/3)+ceil(6/3)+ceil(7/3)+ceil(11/3) = 1+2+3+4 = 10 <br>
            Minimum k = 4
        </div>
    </div>
    
    <div class="algorithm-steps">
        <div class="algorithm-step">
            <strong>Step 1:</strong> Initialize binary search range [1, max(pile)]
        </div>
        <div class="algorithm-step">
            <strong>Step 2:</strong> Test middle speed k
        </div>
        <div class="algorithm-step">
            <strong>Step 3:</strong> Calculate total hours needed for speed k
        </div>
        <div class="algorithm-step">
            <strong>Step 4:</strong> If hours  h, k is valid  search lower half
        </div>
        <div class="algorithm-step">
            <strong>Step 5:</strong> If hours > h, k is invalid  search upper half
        </div>
        <div class="algorithm-step">
            <strong>Step 6:</strong> Repeat until left = right
        </div>
     </div>
     </div>
        <div class="mb-3">
            <strong>Reorder Log Files:</strong>
            <div class="code-snippet">
                def reorderLogFiles(logs):<br>
                &nbsp;&nbsp;def transform(log):<br>
                &nbsp;&nbsp;&nbsp;&nbsp;idx = log.find(' ')<br>
                &nbsp;&nbsp;&nbsp;&nbsp;identifier, content = log[:idx], log[idx+1:]<br>
                &nbsp;&nbsp;&nbsp;&nbsp;if content[0].isdigit():<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (1, )<br>
                &nbsp;&nbsp;&nbsp;&nbsp;else:<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (0, content, identifier)<br>
                &nbsp;&nbsp;logs.sort(key=transform)<br>
                &nbsp;&nbsp;return logs
            </div>
        </div>
    </div>
</div>
<!-- Add this with the other tab-pane divs -->
<div class="tab-pane fade" id="leetcode" role="tabpanel">
    <div class="mb-3">
        <label class="form-label">Maximum Subarray Sum with One Deletion</label>
        <div class="input-group mb-2">
            <button class="btn btn-glow" id="maxSubarrayOneDeletionBtn">
                <i class="fas fa-trash-alt me-2"></i>Maximum Subarray Sum with One Deletion
            </button>
        </div>
        <small class="text-muted">Find maximum sum of contiguous subarray allowing at most one element deletion</small>
    </div>
    <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Maximum Length of Pair Chain</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="maxPairChainBtn">
            <i class="fas fa-link me-2"></i>Maximum Length of Pair Chain
        </button>
    </div>
    <small class="text-muted">Find the longest chain of pairs where b < c in [a,b] and [c,d]</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Dynamic Programming - Grid Problems</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="uniquePathsBtn">
            <i class="fas fa-route me-2"></i>Unique Paths (Grid DP)
        </button>
    </div>
</div>

<!-- Unique Paths Input Group (initially hidden) -->
<div class="mb-3" id="uniquePathsInputGroup" style="display: none;">
    <label class="form-label">Enter Grid Dimensions</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="gridRows" placeholder="Number of rows (m)" min="1" max="10">
        <input type="number" class="form-control" id="gridCols" placeholder="Number of columns (n)" min="1" max="10">
    </div>
    <div class="d-grid gap-2">
        <button class="btn btn-glow" id="confirmUniquePathsBtn">
            <i class="fas fa-play me-2"></i>Calculate Unique Paths
        </button>
        <button class="btn btn-outline-light" id="cancelUniquePathsBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Arithmetic Slices</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="arithmeticSlicesBtn">
            <i class="fas fa-calculator me-2"></i>Count Arithmetic Slices
        </button>
    </div>
    <small class="text-muted">Find all arithmetic subarrays with at least 3 elements</small>
</div>
<!-- Add this in the Create Tab after the Merge Sorted Arrays section -->
<div class="mb-3">
    <label class="form-label">Coin Change Problem</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="coinChangeBtn">
            <i class="fas fa-coins me-2"></i>Coin Change (Minimum Coins)
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after Segregate Even & Odd Numbers -->
<div class="mb-3">
    <label class="form-label">Decode Ways Algorithm</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="decodeWaysInput" 
               placeholder="Enter numeric string (e.g., 123)">
        <button class="btn btn-glow" id="decodeWaysBtn">
            <i class="fas fa-code me-2"></i>Calculate Decode Ways
        </button>
    </div>
    <small class="text-muted">Calculate number of ways to decode a numeric string to letters (A=1, B=2... Z=26)</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Partition Equal Subset Sum</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="partitionEqualSubsetSumBtn">
            <i class="fas fa-balance-scale me-2"></i>Partition Equal Subset Sum
        </button>
    </div>
    <small class="text-muted">Check if array can be partitioned into two subsets with equal sum</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Target Sum (assign + or - to get target)</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="targetSumInput" placeholder="Enter target sum">
        <button class="btn btn-glow" id="targetSumBtn">
            <i class="fas fa-calculator me-2"></i>Find Target Sum Ways
        </button>
    </div>
</div>
<!-- Word Break Problem -->
<div class="mb-3">
    <label class="form-label">Word Break Problem</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="wordBreakBtn">
            <i class="fas fa-language me-2"></i>Word Break Problem
        </button>
    </div>
    <small class="text-muted">Check if a string can be segmented into dictionary words</small>
</div>

<!-- Word Break Input Group (initially hidden) -->
<div class="mb-3" id="wordBreakGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">Enter String to Check</label>
        <div class="input-group mb-2">
            <input type="text" class="form-control" id="wordBreakString" 
                   placeholder="e.g., leetcode, applepenapple" maxlength="50">
        </div>
    </div>
    
    <div class="mb-3">
        <label class="form-label">Dictionary Words (comma-separated)</label>
        <div class="input-group mb-2">
            <input type="text" class="form-control" id="wordDict" 
                   placeholder="e.g., leet, code, apple, pen" maxlength="100">
        </div>
    </div>
    
    <div class="d-grid gap-2">
        <button class="btn btn-glow" id="performWordBreakBtn">
            <i class="fas fa-play me-2"></i>Perform Word Break
        </button>
        <button class="btn btn-outline-light" id="cancelWordBreakBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Max Subarray Sum (No Larger Than K)</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="maxRectangleSum" placeholder="Enter K (target sum)" min="1">
        <button class="btn btn-glow" id="maxRectangleBtn">
            <i class="fas fa-calculator me-2"></i>Find Max Rectangle Sum
        </button>
    </div>
    <small class="text-muted">Find maximum subarray sum no larger than K</small>
</div>
<!-- Add these buttons in the Advanced Basic Operations Tab -->
<div class="mb-3">
    <label class="form-label">Median Algorithms</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="findMedianStreamBtn">
            <i class="fas fa-chart-line me-2"></i>Find Median from Data Stream
        </button>
        <button class="btn btn-glow" id="slidingWindowMedianBtn">
            <i class="fas fa-window-restore me-2"></i>Sliding Window Median
        </button>
    </div>
</div>

<!-- Sliding Window Median Input Group (initially hidden) -->
<div class="mb-3" id="slidingWindowInputGroup" style="display: none;">
    <label class="form-label">Sliding Window Settings</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="slidingWindowK" 
               placeholder="Enter window size k ( 1)" min="1">
        <button class="btn btn-glow" id="confirmSlidingWindowBtn">
            <i class="fas fa-play me-2"></i>Start Sliding Window Median
        </button>
        <button class="btn btn-outline-light" id="cancelSlidingWindowBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
    <small class="text-muted">For Sliding Window Median: Enter window size k between 1 and array length</small>
</div>
<!-- Add this in the Create Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">My Calendar - Event Booking System</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="calendarBtn">
            <i class="fas fa-calendar-alt me-2"></i>My Calendar
        </button>
    </div>
</div>

<!-- Calendar Input Group (initially hidden) -->
<div class="mb-3" id="calendarGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">Enter Number of Events</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="numEvents" placeholder="Number of events (1-20)" min="1" max="20">
            <button class="btn btn-glow" id="confirmNumEventsBtn">
                <i class="fas fa-check me-2"></i>Set Number of Events
            </button>
        </div>
    </div>

    <div id="calendarEventsInputs" class="mt-2"></div>

    <div class="d-grid gap-2 mt-3">
        <button class="btn btn-glow" id="performCalendarBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Start Calendar Operations
        </button>
        <button class="btn btn-outline-light" id="cancelCalendarBtn">
            <i class="fas fa-times me-2"></i>Cancel Calendar Operation
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">LRU Cache Simulation</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="lruCacheBtn">
            <i class="fas fa-history me-2"></i>LRU Cache Simulation
        </button>
    </div>
    <small class="text-muted">Visualizes LRU Cache with array + hash map. Press Shift+R to reset.</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">LFU Cache Visualization</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="lfuCapacityInput" placeholder="Capacity" min="1" max="10" value="3">
        <button class="btn btn-glow" id="lfuCacheBtn">
            <i class="fas fa-database me-2"></i>Start LFU Cache
        </button>
    </div>
    <small class="text-muted">Visualizes Least Frequently Used (LFU) Cache Algorithm</small>
</div>
<!-- Coin Change Input Group (initially hidden) -->
<div class="mb-3" id="coinChangeGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">Coin Denominations</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="coinCount" placeholder="Number of coin types" min="1" max="20">
            <button class="btn btn-glow" id="confirmCoinCountBtn">
                <i class="fas fa-check me-2"></i>Set Coin Types
            </button>
        </div>
        <div id="coinInputs" class="mt-2"></div>
    </div>

    <div class="mb-3">
        <label class="form-label">Amount</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="targetAmount" placeholder="Enter target amount" min="1">
        </div>
    </div>

    <div class="d-grid gap-2">
        <button class="btn btn-glow" id="performCoinChangeBtn">
            <i class="fas fa-calculator me-2"></i>Calculate Minimum Coins
        </button>
        <button class="btn btn-outline-light" id="cancelCoinChangeBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>
<div class="mb-3" id="pairInputGroup" style="display: none;">
    <label class="form-label">Enter Pairs</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="pairCount" placeholder="Number of pairs (n)" min="1" max="20">
        <button class="btn btn-glow" id="confirmPairCountBtn">
            <i class="fas fa-check me-2"></i>Confirm Number of Pairs
        </button>
    </div>
    <div id="pairsInputs" class="mt-2"></div>
    <div class="d-grid gap-2 mt-2">
        <button class="btn btn-glow" id="performPairChainBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Find Maximum Chain Length
        </button>
        <button class="btn btn-outline-light" id="cancelPairChainBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the Decode Ways input -->
<div class="algorithm-explanation mt-3">
    <h6>Decode Ways Algorithm</h6>
    <p>Counts the number of ways to decode a string of digits to letters using mapping: A=1, B=2, ..., Z=26.</p>
    
    <div class="code-snippet">
        function numDecodings(s) {<br>
        &nbsp;&nbsp;if (!s || s[0] == '0') return 0;<br>
        &nbsp;&nbsp;let n = s.length;<br>
        &nbsp;&nbsp;let dp = new Array(n+1).fill(0);<br>
        &nbsp;&nbsp;dp[0] = 1; // empty string<br>
        &nbsp;&nbsp;dp[1] = 1; // first digit<br>
        &nbsp;&nbsp;for (let i = 2; i <= n; i++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;let single = parseInt(s[i-1]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;let twoDigit = parseInt(s.substring(i-2, i));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (single != 0) dp[i] += dp[i-1];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (10 <= twoDigit <= 26) dp[i] += dp[i-2];<br>
        &nbsp;&nbsp;}<br>
        &nbsp;&nbsp;return dp[n];<br>
        }
    </div>
    
    <div class="mb-3">
        <strong>Rules:</strong>
        <ul class="mb-0">
            <li>A digit 1-9 can be decoded as A-I</li>
            <li>Two digits 10-26 can be decoded as J-Z</li>
            <li>'0' cannot be decoded alone</li>
            <li>'0' can only appear as part of 10 or 20</li>
        </ul>
    </div>
    
    <div class="mb-2">
        <strong>Examples:</strong>
        <ul class="mb-0">
            <li>"12"  2 ways: "AB" (1,2) or "L" (12)</li>
            <li>"226"  3 ways: "BBF" (2,2,6), "BZ" (2,26), "VF" (22,6)</li>
            <li>"06"  0 ways (starts with 0)</li>
        </ul>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing algorithm explanations -->
<div class="algorithm-explanation mt-3">
    <h6>Arithmetic Slices Algorithm</h6>
    <p>An arithmetic slice is a contiguous subarray with at least 3 elements where the difference between consecutive elements is constant.</p>
    
    <div class="code-snippet">
        function numberOfArithmeticSlices(nums) {<br>
        &nbsp;&nbsp;if (nums.length < 3) return 0;<br>
        &nbsp;&nbsp;let count = 0;<br>
        &nbsp;&nbsp;let currentLength = 2;<br>
        &nbsp;&nbsp;for (let i = 2; i < nums.length; i++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentLength++;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count += (currentLength - 2);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentLength = 2;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;}<br>
        &nbsp;&nbsp;return count;<br>
        }
    </div>
    
    <div class="mb-3">
        <strong>Example:</strong> For array [1, 2, 3, 4]<br>
        - Arithmetic slices: [1,2,3], [2,3,4], [1,2,3,4]<br>
        - Total: 3 slices
    </div>
</div>
    <div class="algorithm-explanation mt-3">
        <h6>LeetCode Problem 1186: Maximum Subarray Sum with One Deletion</h6>
        <p>Given an array of integers, return the maximum sum of a contiguous subarray (possibly empty) 
        after deleting at most one element from the array.</p>
        
        <div class="code-snippet">
            def maximumSum(arr):<br>
            &nbsp;&nbsp;"""<br>
            &nbsp;&nbsp;Given an array of integers, return the maximum sum of a subarray<br>
            &nbsp;&nbsp;with at most one element deletion.<br>
            &nbsp;&nbsp;Time: O(n), Space: O(n)<br>
            &nbsp;&nbsp;"""<br>
            &nbsp;&nbsp;n = len(arr)<br>
            &nbsp;&nbsp;if n == 0: return 0<br>
            &nbsp;&nbsp;if n == 1: return arr[0]<br>
            <br>
            &nbsp;&nbsp;# forward[i]: max subarray sum ending at i<br>
            &nbsp;&nbsp;forward = [0] * n<br>
            &nbsp;&nbsp;forward[0] = arr[0]<br>
            &nbsp;&nbsp;for i in range(1, n):<br>
            &nbsp;&nbsp;&nbsp;&nbsp;forward[i] = max(arr[i], forward[i-1] + arr[i])<br>
            <br>
            &nbsp;&nbsp;# backward[i]: max subarray sum starting at i<br>
            &nbsp;&nbsp;backward = [0] * n<br>
            &nbsp;&nbsp;backward[n-1] = arr[n-1]<br>
            &nbsp;&nbsp;for i in range(n-2, -1, -1):<br>
            &nbsp;&nbsp;&nbsp;&nbsp;backward[i] = max(arr[i], backward[i+1] + arr[i])<br>
            <br>
            &nbsp;&nbsp;# Option 1: No deletion (standard Kadane's algorithm)<br>
            &nbsp;&nbsp;max_no_deletion = max(forward)<br>
            <br>
            &nbsp;&nbsp;# Option 2: With one deletion<br>
            &nbsp;&nbsp;max_with_deletion = float('-inf')<br>
            &nbsp;&nbsp;for i in range(1, n-1):<br>
            &nbsp;&nbsp;&nbsp;&nbsp;# Delete element at i, connect forward[i-1] and backward[i+1]<br>
            &nbsp;&nbsp;&nbsp;&nbsp;max_with_deletion = max(max_with_deletion, forward[i-1] + backward[i+1])<br>
            <br>
            &nbsp;&nbsp;return max(max_no_deletion, max_with_deletion)
        </div>
        
        <div class="code-snippet mt-2">
            # Optimized version with O(1) space<br>
            def maximumSumOptimized(arr):<br>
            &nbsp;&nbsp;"""Optimized version with O(1) space using DP states."""<br>
            &nbsp;&nbsp;dp0 = arr[0]  # max sum ending at i with 0 deletions<br>
            &nbsp;&nbsp;dp1 = 0       # max sum ending at i with 1 deletion<br>
            &nbsp;&nbsp;res = arr[0]<br>
            <br>
            &nbsp;&nbsp;for i in range(1, len(arr)):<br>
            &nbsp;&nbsp;&nbsp;&nbsp;# With 1 deletion: either delete current element (dp0) <br>
            &nbsp;&nbsp;&nbsp;&nbsp;# or we've already deleted before (dp1 + arr[i])<br>
            &nbsp;&nbsp;&nbsp;&nbsp;dp1 = max(dp0, dp1 + arr[i])<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;# With 0 deletions: standard Kadane<br>
            &nbsp;&nbsp;&nbsp;&nbsp;dp0 = max(arr[i], dp0 + arr[i])<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;res = max(res, dp0, dp1)<br>
            <br>
            &nbsp;&nbsp;return res
        </div>
    </div>
    
    <div class="algorithm-explanation mt-3">
        <h6>Algorithm Explanation</h6>
        <div class="algorithm-step">
            <strong>Step 1:</strong> Calculate forward maximum subarray sums (Kadane's algorithm from left)
        </div>
        <div class="algorithm-step">
            <strong>Step 2:</strong> Calculate backward maximum subarray sums (Kadane's algorithm from right)
        </div>
        <div class="algorithm-step">
            <strong>Step 3:</strong> For each element (except first and last), calculate sum of forward[i-1] + backward[i+1]
        </div>
        <div class="algorithm-step">
            <strong>Step 4:</strong> Compare with no-deletion maximum and return the maximum of both
        </div>
        <div class="algorithm-step">
            <strong>Time Complexity:</strong> O(n) where n is array length
        </div>
        <div class="algorithm-step">
            <strong>Space Complexity:</strong> O(n) for DP arrays, O(1) for optimized version
        </div>
    </div>
</div>
<!-- Stock Market Operations Tab -->
<div class="tab-pane fade" id="stockmarket" role="tabpanel">
    <div class="investment-insight">
        <h6><i class="fas fa-chart-line me-2"></i>Investment Analysis Toolkit</h6>
        <p class="mb-0">Professional financial metrics for informed investment decisions</p>
    </div>
    
    <div class="mb-3">
        <label class="form-label">Stock Price Data Input</label>
        <div class="input-group mb-2">
            <input type="text" class="form-control" id="stockPricesInput" placeholder="Enter daily stock prices (e.g., 100, 102, 105, 103, 107)">
            <button class="btn btn-glow" id="loadStockPricesBtn">
                <i class="fas fa-database me-2"></i>Load Price Data
            </button>
        </div>
        <div class="business-insight">
            <strong> Business Context:</strong> Enter historical stock prices to analyze investment performance, volatility, and returns.
        </div>
    </div>
    
    <div class="mb-3">
        <label class="form-label">Financial Analysis Operations</label>
        <div class="row">
            <div class="col-md-6 mb-2">
                <button class="btn btn-glow w-100" id="dailyReturnsBtn">
                    <i class="fas fa-percentage me-2"></i>Daily Returns
                </button>
                <small class="text-muted">Day-to-day percentage changes</small>
            </div>
            <div class="col-md-6 mb-2">
                <button class="btn btn-glow w-100" id="logReturnsBtn">
                    <i class="fas fa-calculator me-2"></i>Log Returns
                </button>
                <small class="text-muted">Continuous compounding returns</small>
            </div>
            <div class="col-md-6 mb-2">
                <button class="btn btn-glow w-100" id="cumulativeReturnsBtn">
                    <i class="fas fa-chart-bar me-2"></i>Cumulative Returns
                </button>
                <small class="text-muted">Total return from start to each point</small>
            </div>
            <div class="col-md-6 mb-2">
                <button class="btn btn-glow w-100" id="totalReturnBtn">
                    <i class="fas fa-chart-pie me-2"></i>Total Return
                </button>
                <small class="text-muted">Overall investment performance</small>
            </div>
            <div class="col-md-12 mb-2">
                <button class="btn btn-glow w-100" id="priceDifferenceBtn">
                    <i class="fas fa-exchange-alt me-2"></i>Price Differences
                </button>
                <small class="text-muted">Daily price movements & volatility</small>
            </div>
                <!-- NEW: Add these 4 new buttons -->
    <div class="col-md-6 mb-2">
        <button class="btn btn-glow w-100" id="priceMomentumBtn">
            <i class="fas fa-rocket me-2"></i>Price Momentum
        </button>
        <small class="text-muted">N-day price momentum</small>
    </div>
    <div class="col-md-6 mb-2">
        <button class="btn btn-glow w-100" id="rateOfChangeBtn">
            <i class="fas fa-tachometer-alt me-2"></i>Rate of Change
        </button>
        <small class="text-muted">ROC percentage indicator</small>
    </div>
    <div class="col-md-6 mb-2">
        <button class="btn btn-glow w-100" id="gapAnalysisBtn">
            <i class="fas fa-arrows-alt-v me-2"></i>Gap Analysis
        </button>
        <small class="text-muted">Opening gap calculations</small>
    </div>
    <div class="col-md-6 mb-2">
        <button class="btn btn-glow w-100" id="intradayGainBtn">
            <i class="fas fa-chart-area me-2"></i>Intraday Gain/Loss
        </button>
        <small class="text-muted">Daily trading performance</small>
    </div>
    <!-- NEW: Technical Indicators -->
    <div class="col-md-6 mb-2">
        <button class="btn btn-glow w-100" id="smaBtn">
            <i class="fas fa-chart-line me-2"></i>Simple Moving Average
        </button>
        <small class="text-muted">SMA - Average price over period</small>
    </div>
    <div class="col-md-6 mb-2">
        <button class="btn btn-glow w-100" id="emaBtn">
            <i class="fas fa-bolt me-2"></i>Exponential Moving Average
        </button>
        <small class="text-muted">EMA - Weighted average</small>
    </div>
    <div class="col-md-6 mb-2">
        <button class="btn btn-glow w-100" id="macdBtn">
            <i class="fas fa-wave-square me-2"></i>MACD Line
        </button>
        <small class="text-muted">MACD - Trend momentum</small>
    </div>
    <div class="col-md-6 mb-2">
        <button class="btn btn-glow w-100" id="macdSignalBtn">
            <i class="fas fa-signal me-2"></i>MACD Signal Line
        </button>
        <small class="text-muted">Signal line for MACD</small>
    </div>
    <div class="col-md-6 mb-2">
        <button class="btn btn-glow w-100" id="bollingerMiddleBtn">
            <i class="fas fa-arrows-alt-h me-2"></i>Bollinger Middle
        </button>
        <small class="text-muted">Bollinger Middle Band</small>
    </div>
    <div class="col-md-6 mb-2">
        <button class="btn btn-glow w-100" id="bollingerUpperBtn">
            <i class="fas fa-arrow-up me-2"></i>Bollinger Upper
        </button>
        <small class="text-muted">Bollinger Upper Band</small>
    </div>
        </div>
    </div>
    
    <div class="financial-summary">
        <h6><i class="fas fa-lightbulb me-2"></i>Key Metrics Explained</h6>
        <div class="performance-metric metric-positive">
            <strong>Daily Returns:</strong> Essential for understanding short-term volatility and daily performance
        </div>
        <div class="performance-metric">
            <strong>Log Returns:</strong> Used in financial modeling for time-series analysis and risk management
        </div>
        <div class="performance-metric metric-positive">
            <strong>Cumulative Returns:</strong> Shows investment growth trajectory over time
        </div>
        <div class="performance-metric">
            <strong>Total Return:</strong> Overall investment performance measurement
        </div>
        <div class="performance-metric">
            <strong>Price Differences:</strong> Reveals daily price movements and market volatility patterns
        </div>
    </div>
</div>
                    <!-- Set Operations Tab -->
                    <div class="tab-pane fade" id="set" role="tabpanel">
                        <div class="mb-3">
                            <label class="form-label">Set Operations</label>
                            <div class="input-group mb-2">
                                <button class="btn btn-glow" id="unionArraysBtn">
                                    <i class="fas fa-object-group me-2"></i>Union of Arrays
                                </button>
                                <button class="btn btn-glow" id="intersectionArraysBtn">
                                    <i class="fas fa-bezier-curve me-2"></i>Intersection of Arrays
                                </button>
                            </div>
                        </div>

                        <!-- Set Operations Input Group (initially hidden) -->
                        <div class="mb-3" id="setOperationsGroup" style="display: none;">
                            <div class="mb-3">
                                <label class="form-label">Number of Arrays</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="numArrays" placeholder="Enter number of arrays (1-3)" min="1" max="3">
                                    <button class="btn btn-glow" id="confirmNumArraysBtn">
                                        <i class="fas fa-check me-2"></i>Confirm Number of Arrays
                                    </button>
                                </div>
                            </div>

                            <!-- Dynamic array inputs will be inserted here -->
                            <div id="setArraysInputs" class="mt-2"></div>

                            <div class="d-grid gap-2">
                                <button class="btn btn-glow" id="performSetOperationBtn" style="display: none;">
                                    <i class="fas fa-play me-2"></i>Perform Set Operation
                                </button>
                                <button class="btn btn-outline-light" id="cancelSetOperationBtn">
                                    <i class="fas fa-times me-2"></i>Cancel Set Operation
                                </button>
                            </div>
                        </div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Set Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="setDifferenceBtn">
            <i class="fas fa-minus-circle me-2"></i>Set Difference (A - B)
        </button>
        <button class="btn btn-glow" id="symmetricDifferenceBtn">
            <i class="fas fa-exchange-alt me-2"></i>Symmetric Difference
        </button>
    </div>
</div>

<!-- Set Operations Input Group (initially hidden) -->
<div class="mb-3" id="setOperationsGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">Set Operation Details</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="numArrays" placeholder="Number of arrays (2)" min="2" max="2" value="2">
            <button class="btn btn-glow" id="confirmNumArraysBtn">
                <i class="fas fa-check me-2"></i>Confirm Number of Arrays
            </button>
        </div>
        <small class="text-muted">Set operations work with exactly 2 arrays</small>
    </div>

    <div id="setArraysInputs" class="mt-2"></div>

    <div class="d-grid gap-2 mt-3">
        <button class="btn btn-glow" id="performSetOperationBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Perform Set Operation
        </button>
        <button class="btn btn-outline-light" id="cancelSetOperationBtn">
            <i class="fas fa-times me-2"></i>Cancel Set Operation
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Set Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="checkSubsetCompBtn">
            <i class="fas fa-subscript me-2"></i>Check if Array is Subset
        </button>
        <button class="btn btn-glow" id="checkSupersetCompBtn">
            <i class="fas fa-superscript me-2"></i>Check if Array is Superset
        </button>
    </div>
</div>

<!-- Subset Comparison Input Group -->
<div class="mb-3" id="subsetCompInputGroup" style="display: none;">
    <label class="form-label">Subset Comparison - Enter Number of Arrays</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="numArraysSubsetComp" placeholder="Number of arrays (2)" min="2" max="5" value="2">
        <button class="btn btn-glow" id="confirmNumArraysSubsetCompBtn">
            <i class="fas fa-check me-2"></i>Confirm Number of Arrays
        </button>
    </div>
    
    <div id="subsetCompArraysInputs" class="mt-3"></div>
    
    <div class="d-grid gap-2 mt-3">
        <button class="btn btn-glow" id="performSubsetCompBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Perform Subset Check
        </button>
        <button class="btn btn-outline-light" id="cancelSubsetCompBtn">
            <i class="fas fa-times me-2"></i>Cancel Subset Check
        </button>
    </div>
</div>

<!-- Superset Comparison Input Group -->
<div class="mb-3" id="supersetCompInputGroup" style="display: none;">
    <label class="form-label">Superset Comparison - Enter Number of Arrays</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="numArraysSupersetComp" placeholder="Number of arrays (2)" min="2" max="5" value="2">
        <button class="btn btn-glow" id="confirmNumArraysSupersetCompBtn">
            <i class="fas fa-check me-2"></i>Confirm Number of Arrays
        </button>
    </div>
    
    <div id="supersetCompArraysInputs" class="mt-3"></div>
    
    <div class="d-grid gap-2 mt-3">
        <button class="btn btn-glow" id="performSupersetCompBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Perform Superset Check
        </button>
        <button class="btn btn-outline-light" id="cancelSupersetCompBtn">
            <i class="fas fa-times me-2"></i>Cancel Superset Check
        </button>
    </div>
</div>
                        <div class="algorithm-explanation mt-3">
                            <h6>Set Operations Algorithms</h6>
                            
                            <div class="mb-3">
                                <strong>Union of Arrays:</strong>
                                <div class="code-snippet">
                                    function unionArrays(arrays) {<br>
                                    &nbsp;&nbsp;let unionSet = new Set();<br>
                                    &nbsp;&nbsp;for (let arr of arrays) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;for (let element of arr) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unionSet.add(element);<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                                    &nbsp;&nbsp;}<br>
                                    &nbsp;&nbsp;return Array.from(unionSet);<br>
                                    }
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <strong>Intersection of Arrays:</strong>
                                <div class="code-snippet">
                                    function intersectionArrays(arrays) {<br>
                                    &nbsp;&nbsp;if (arrays.length === 0) return [];<br>
                                    &nbsp;&nbsp;let intersection = arrays[0];<br>
                                    &nbsp;&nbsp;for (let i = 1; i < arrays.length; i++) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;intersection = intersection.filter(<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element => arrays[i].includes(element)<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;);<br>
                                    &nbsp;&nbsp;}<br>
                                    &nbsp;&nbsp;return [...new Set(intersection)];<br>
                                    }
                                </div>
                            </div>
                        </div>
                    </div>
                        <!-- Leetcode Problems Tab -->
        <div class="tab-pane fade" id="leetcode" role="tabpanel">
          <div class="mb-3">
          <label class="form-label">Leetcode Array Problems</label>
         <div class="input-group mb-2">
            <button class="btn btn-glow" id="containerWithMostWaterBtn">
                <i class="fas fa-tint me-2"></i>Container With Most Water
            </button>
            <button class="btn btn-glow" id="trappingRainWaterBtn">
                <i class="fas fa-cloud-rain me-2"></i>Trapping Rain Water
            </button>
          </div>
           <small class="text-muted">Solve famous Leetcode array problems with visualizations</small>
         </div>
         <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
         <div class="mb-3">
         <label class="form-label">Valid Parentheses Check</label>
         <div class="input-group mb-2">
         <input type="text" class="form-control" id="parenthesesInput" placeholder="Enter string with only {} parentheses">
         <button class="btn btn-glow" id="validParenthesesBtn">
            <i class="fas fa-check-circle me-2"></i>Valid Parentheses
         </button>
          </div>
         <small class="text-muted">Enter a string containing only curly braces {} to validate parentheses</small>
          </div>
         <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
     <div class="mb-3">
    <label class="form-label">Substring with Concatenation of All Words</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="findWordConcatenationBtn">
            <i class="fas fa-link me-2"></i>Find Word Concatenation Substrings
        </button>
    </div>
    </div>

 <!-- Word Concatenation Input Group (initially hidden) -->
 <div class="mb-3" id="wordConcatInputSection" style="display: none;">
    <div class="mb-3">
        <label class="form-label">Enter Text String</label>
        <input type="text" class="form-control" id="textStringInputField" placeholder="e.g., barfoothefoobarman">
    </div>
    
    <div class="mb-3">
        <label class="form-label">Enter Search Words (comma-separated)</label>
        <input type="text" class="form-control" id="searchWordsInputField" placeholder="e.g., foo,bar">
    </div>
    
    <div class="d-grid gap-2">
        <button class="btn btn-glow" id="runWordConcatSearchBtn">
            <i class="fas fa-play me-2"></i>Find Concatenated Substrings
        </button>
        <button class="btn btn-outline-light" id="stopWordConcatSearchBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
 </div>
 <!-- Add this in the Search Tab after the existing search sections -->
 <div class="mb-3">
    <label class="form-label">Find First & Last Position in Sorted Array</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="firstLastTarget" placeholder="Enter target element">
        <button class="btn btn-glow" id="findFirstLastBtn">
            <i class="fas fa-search me-2"></i>Find First & Last Position
        </button>
    </div>
    <small class="text-muted">Uses binary search to find first and last occurrence in sorted array</small>
 </div>
 <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
 <div class="mb-3">
    <label class="form-label">String Algorithms</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="longestValidParenthesesBtn">
            <i class="fas fa-parentheses me-2"></i>Find Longest Valid Parentheses
        </button>
        <button class="btn btn-glow" id="distinctSubsequencesBtn">
            <i class="fas fa-code-branch me-2"></i>Find Distinct Subsequences
        </button>
    </div>
 </div>

 <!-- Longest Valid Parentheses Input Group -->
 <div class="mb-3" id="parenthesesInputGroup" style="display: none;">
    <label class="form-label">Enter Parentheses String</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="lvpInput" 
               placeholder="e.g., (( ) ) ( ( ) )" maxlength="50">
        <button class="btn btn-glow" id="confirmParenthesesBtn">
            <i class="fas fa-play me-2"></i>Find Longest Valid
        </button>
        <button class="btn btn-outline-light" id="cancelParenthesesBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
    <small class="text-muted">Enter string containing only '(' and ')' characters</small>
 </div>

 <!-- Distinct Subsequences Input Group -->
 <div class="mb-3" id="subsequencesInputGroup" style="display: none;">
    <label class="form-label">Enter Strings for Distinct Subsequences</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="dsMainStringInput" 
               placeholder="Main string (s)" maxlength="30">
        <input type="text" class="form-control" id="dsTargetStringInput" 
               placeholder="Target string (t)" maxlength="20">
    </div>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="confirmSubsequencesBtn">
            <i class="fas fa-play me-2"></i>Find Distinct Subsequences
        </button>
        <button class="btn btn-outline-light" id="cancelSubsequencesBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
    <small class="text-muted">Count how many times target string appears as subsequence in main string</small>
 </div>
 <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
 <div class="mb-3">
    <label class="form-label">String Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="checkPalindromeBtn">
            <i class="fas fa-check-circle me-2"></i>Check Valid Palindrome
        </button>
        <button class="btn btn-glow" id="findAnagramsBtn">
            <i class="fas fa-search me-2"></i>Find All Anagrams
        </button>
    </div>
 </div>
 <!-- Add this in the Advanced Basic Operations Tab after Kadane's Algorithm -->
 <div class="mb-3">
    <label class="form-label">Palindrome Operations</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="palindromeInput" placeholder="Enter a string">
        <button class="btn btn-glow" id="findPalindromicSubstringsBtn">
            <i class="fas fa-palindrome me-2"></i>Find Palindromic Substrings
        </button>
    </div>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="longestPalindromeInput" placeholder="Enter a string" value="">
        <button class="btn btn-glow" id="findLongestPalindromicSubstringBtn">
            <i class="fas fa-search-plus me-2"></i>Find Longest Palindromic Substring
        </button>
    </div>
 </div>
 <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
 <div class="mb-3">
    <label class="form-label">Backtracking Algorithms</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="combinationSumBtn">
            <i class="fas fa-calculator me-2"></i>Find Combination Sum
        </button>
        <button class="btn btn-glow" id="subsetsBtn">
            <i class="fas fa-layer-group me-2"></i>Find Subsets
        </button>
    </div>
 </div>
 <!-- Combination Sum Input Group -->
 <div class="mb-3" id="combinationSumGroup" style="display: none;">
    <label class="form-label">Combination Sum Target</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="combinationSumTarget" placeholder="Enter target sum">
        <button class="btn btn-glow" id="confirmCombinationSumBtn">
            <i class="fas fa-play me-2"></i>Find Combinations
        </button>
        <button class="btn btn-outline-light" id="cancelCombinationSumBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
 </div>
 <!-- Add these buttons in the Advanced Basic Operations Tab -->
 <div class="mb-3">
    <label class="form-label">Pattern Matching Algorithms</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="wildcardMatchingBtn">
            <i class="fas fa-asterisk me-2"></i>Wildcard Matching
        </button>
        <button class="btn btn-glow" id="regexMatchingBtn">
            <i class="fas fa-code me-2"></i>Regular Expression Matching
        </button>
    </div>
 </div>

 <!-- Add this input group for pattern matching (initially hidden) -->
 <div class="mb-3" id="patternMatchingGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label" id="patternMatchingLabel">Pattern Matching Details</label>
        <div class="input-group mb-2">
            <input type="text" class="form-control" id="patternString" placeholder="Enter string (e.g., abcc)">
            <input type="text" class="form-control" id="patternPattern" placeholder="Enter pattern (e.g., a*b*)">
            <button class="btn btn-glow" id="confirmPatternMatchingBtn">
                <i class="fas fa-play me-2"></i>Start Pattern Matching
            </button>
        </div>
    </div>
    
    <div class="d-grid gap-2">
        <button class="btn btn-outline-light" id="cancelPatternMatchingBtn">
            <i class="fas fa-times me-2"></i>Cancel Pattern Matching
        </button>
    </div>
 </div>
   <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
   <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
    <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
        <div class="mb-3">
        <label class="form-label">LeetCode Problems</label>
        <div class="input-group mb-2">
        <button class="btn btn-glow" id="jumpGameBtn">
            <i class="fas fa-gamepad me-2"></i>Jump Game (Can Reach End?)
        </button>
      </div>
      <small class="text-muted">Determine if you can reach the last index starting from first index</small>
      </div>
 <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
 <div class="mb-3">
    <label class="form-label">Stock Buy/Sell Problem</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="bestTimeStockBtn">
            <i class="fas fa-chart-line me-2"></i>Best Time to Buy & Sell Stock
        </button>
    </div>
    <small class="text-muted">Find maximum profit from daily stock prices (LeetCode #121)</small>
 </div>
 // Add this in the algorithm explanation section
 <div class="algorithm-explanation mt-3" id="stockAlgorithmExplanation">
    <h6>Best Time to Buy and Sell Stock Algorithm</h6>
    <p>Find the maximum profit by buying low and selling high. You can only make one transaction.</p>
    
    <div class="code-snippet">
        function maxProfit(prices) {<br>
        &nbsp;&nbsp;let minPrice = Infinity;<br>
        &nbsp;&nbsp;let maxProfit = 0;<br>
        &nbsp;&nbsp;for (let i = 0; i < prices.length; i++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (prices[i] < minPrice) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minPrice = prices[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;} else if (prices[i] - minPrice > maxProfit) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxProfit = prices[i] - minPrice;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;}<br>
        &nbsp;&nbsp;return maxProfit;<br>
        }
    </div>
    
    <div id="stockAlgorithmSteps">
        <div class="algorithm-step">
            <strong>Step 1:</strong> Initialize minPrice to infinity and maxProfit to 0
        </div>
        <div class="algorithm-step">
            <strong>Step 2:</strong> Iterate through each day's price
        </div>
        <div class="algorithm-step">
            <strong>Step 3:</strong> Update minPrice if current price is lower
        </div>
        <div class="algorithm-step">
            <strong>Step 4:</strong> Calculate potential profit and update maxProfit if higher
        </div>
        <div class="algorithm-step">
            <strong>Step 5:</strong> Return the maximum profit found
        </div>
    </div>
 </div>
 <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
 <div class="mb-3">
    <label class="form-label">Minimum Window Substring</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="minWindowSubstringBtn">
            <i class="fas fa-window-restore me-2"></i>Find Minimum Window Substring
        </button>
    </div>
 </div>
 <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
 <div class="mb-3">
    <label class="form-label">Daily Temperatures Algorithm</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="dailyTemperaturesBtn">
            <i class="fas fa-thermometer-half me-2"></i>Daily Temperatures
        </button>
    </div>
    <small class="text-muted">Find days until warmer temperature for each day</small>
 </div>
 <!-- Add this in the Create Tab after Clone Array Operation section -->
 <div class="mb-3">
    <label class="form-label">Range Sum Query</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="rangeSumStart" placeholder="Start index" min="0">
        <input type="number" class="form-control" id="rangeSumEnd" placeholder="End index" min="0">
        <button class="btn btn-glow" id="rangeSumQueryBtn">
            <i class="fas fa-calculator me-2"></i>Calculate Range Sum
        </button>
    </div>
    <small class="text-muted">Calculate sum of elements from start to end index (inclusive)</small>
 </div>
 <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
 <div class="mb-3">
    <label class="form-label">Maximum Subarray Problems</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="maxSubarraySumBtn">
            <i class="fas fa-chart-line me-2"></i>Maximum Subarray (Kadane's Algorithm)
        </button>
        <button class="btn btn-glow" id="maxProductSubarrayBtn">
            <i class="fas fa-times-circle me-2"></i>Maximum Product Subarray
        </button>
    </div>
 </div>
 <!-- Input Groups for Minimum Window Substring (initially hidden) -->
 <div class="mb-3" id="minWindowGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">Enter Strings</label>
        <div class="input-group mb-2">
            <input type="text" class="form-control" id="mainStringInput" placeholder="Main string (s)">
        </div>
        <div class="input-group mb-2">
            <input type="text" class="form-control" id="targetStringInput" placeholder="Target string (t)">
        </div>
    </div>

    <div class="d-grid gap-2">
        <button class="btn btn-glow" id="performMinWindowBtn">
            <i class="fas fa-play me-2"></i>Find Minimum Window
        </button>
        <button class="btn btn-outline-light" id="cancelMinWindowBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
 </div>
 <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
 <div class="mb-3">
    <label class="form-label">Leetcode Problems - Merge Intervals</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="mergeIntervalsBtn">
            <i class="fas fa-object-group me-2"></i>Merge Intervals
        </button>
    </div>
    <small class="text-muted">Given a collection of intervals, merge all overlapping intervals</small>
 </div>
 <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
 <div class="mb-3">
    <label class="form-label">Count of Smaller Numbers After Self</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="countSmallerAfterSelfBtn">
            <i class="fas fa-sort-numeric-down me-2"></i>Find Count of Smaller Numbers After Self
        </button>
    </div>
    <small class="text-muted">For each element, count how many elements to the right are smaller</small>
 </div>
 <div class="mb-3">
    <label class="form-label">Longest Substring Without Repeating Characters</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="substringInput" placeholder="Enter string (e.g., abcabcbb)">
        <button class="btn btn-glow" id="findLongestSubstringBtn">
            <i class="fas fa-search me-2"></i>Find Longest Substring
        </button>
    </div>
    <small class="text-muted">Find the length of the longest substring without repeating characters</small>
 </div>
 <!-- Longest Substring Results (initially hidden) -->
 <div class="subarrays-results" id="longestSubstringResults" style="display: none;">
    <h6>Longest Substring Results</h6>
    <div class="stats-card">
        <div>Longest Substring Length</div>
        <div class="stats-value" id="longestSubstringLength">0</div>
    </div>
    <div class="stats-card mt-2">
        <div>Longest Substring Found</div>
        <div class="stats-value" id="longestSubstringValue">-</div>
    </div>
    <div id="longestSubstringSteps" class="mt-3"></div>
 </div>
 <!-- Longest Substring Results (initially hidden) -->
 <div class="subarrays-results" id="longestSubstringResults" style="display: none;">
    <h6>Longest Substring Results</h6>
    <div class="stats-card">
        <div>Longest Substring Length</div>
        <div class="stats-value" id="longestSubstringLength">0</div>
    </div>
    <div class="stats-card mt-2">
        <div>Longest Substring Found</div>
        <div class="stats-value" id="longestSubstringValue">-</div>
    </div>
    <div id="longestSubstringSteps" class="mt-3"></div>
 </div>
 <!-- Add this in the Advanced Basic Operations Tab after the algorithm explanations -->
 <div class="algorithm-explanation mt-3">
    <h6>Longest Substring Without Repeating Characters Algorithm</h6>
    
    <div class="code-snippet">
        function lengthOfLongestSubstring(s) {<br>
        &nbsp;&nbsp;let maxLength = 0;<br>
        &nbsp;&nbsp;let start = 0;<br>
        &nbsp;&nbsp;let charMap = new Map();<br>
        &nbsp;&nbsp;<br>
        &nbsp;&nbsp;for (let end = 0; end < s.length; end++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (charMap.has(s[end]) && charMap.get(s[end]) >= start) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start = charMap.get(s[end]) + 1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;&nbsp;&nbsp;charMap.set(s[end], end);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;maxLength = Math.max(maxLength, end - start + 1);<br>
        &nbsp;&nbsp;}<br>
        &nbsp;&nbsp;return maxLength;<br>
        }
    </div>
    
    <div class="mt-3">
        <strong>Algorithm Steps:</strong>
        <div class="algorithm-step">
            <strong>Step 1:</strong> Initialize start pointer, maxLength, and character map
        </div>
        <div class="algorithm-step">
            <strong>Step 2:</strong> Iterate through string with end pointer
        </div>
        <div class="algorithm-step">
            <strong>Step 3:</strong> If duplicate found within current window, move start pointer
        </div>
        <div class="algorithm-step">
            <strong>Step 4:</strong> Update character's last seen position
        </div>
        <div class="algorithm-step">
            <strong>Step 5:</strong> Update maxLength if current window is longer
        </div>
        <div class="algorithm-step">
            <strong>Step 6:</strong> Return maxLength when iteration completes
        </div>
    </div>
 </div>
 <div class="mb-3">
    <label class="form-label">LeetCode Problems - Two Sum</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="twoSumBtn">
            <i class="fas fa-bullseye me-2"></i>Two Sum Problem
        </button>
    </div>
 </div>
 <!-- Two Sum Input Group (initially hidden) -->
 <div class="mb-3" id="twoSumInputGroup" style="display: none;">
    <label class="form-label">Enter Target Sum for Two Sum</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="twoSumTarget" placeholder="Enter target sum">
        <button class="btn btn-glow" id="confirmTwoSumBtn">
            <i class="fas fa-play me-2"></i>Find Two Sum
        </button>
        <button class="btn btn-outline-light" id="cancelTwoSumBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
 </div>
 <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
 <div class="mb-3">
    <label class="form-label">Fruit Into Baskets Problem</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="fruitIntoBasketsBtn">
            <i class="fas fa-apple-alt me-2"></i>Fruit Into Baskets
        </button>
    </div>
    <small class="text-muted">Find maximum fruits you can pick with two baskets</small>
 </div>
 <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
 <div class="mb-3">
    <label class="form-label">Array Transformation</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="transformNonDecreasingBtn">
            <i class="fas fa-sort-amount-up me-2"></i>Transform to Non-Decreasing Array
        </button>
    </div>
    <small class="text-muted">Convert array to non-decreasing using Greedy + Prefix Sum approach</small>
 </div>
 <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
 <div class="mb-3">
    <label class="form-label">Stock Span Problem</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="stockSpanBtn">
            <i class="fas fa-chart-line me-2"></i>Calculate Stock Span
        </button>
    </div>
    <small class="text-muted">Calculate span values using monotonic stack approach</small>
 </div>
 <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
 <div class="mb-3">
    <label class="form-label">Histogram Problems</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="largestRectangleHistogramBtn">
            <i class="fas fa-chart-bar me-2"></i>Find Largest Rectangle in Histogram
        </button>
    </div>
    <small class="text-muted">Calculate maximum rectangular area in histogram using stack</small>
 </div>
 <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
 <div class="mb-3">
    <label class="form-label">Next Permutation</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="nextPermutationBtn">
            <i class="fas fa-sort-amount-up me-2"></i>Find Next Permutation
        </button>
    </div>
    <small class="text-muted">Rearranges array into lexicographically next greater permutation</small>
</div>
<!-- Add this in the algorithm explanation section if desired -->
<div class="algorithm-explanation mt-3" id="twoSumAlgorithmExplanation">
    <h6>Two Sum Algorithm</h6>
    <p>Find all pairs of indices where the sum of elements equals the target.</p>
    
    <div class="code-snippet">
        function twoSum(arr, target) {<br>
        &nbsp;&nbsp;let pairs = [];<br>
        &nbsp;&nbsp;for (let i = 0; i < arr.length; i++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;for (let j = i + 1; j < arr.length; j++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (arr[i] + arr[j] === target) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pairs.push([i, j]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;}<br>
        &nbsp;&nbsp;return pairs;<br>
        }
    </div>
 </div>        
        <div class="mb-3">
            <strong>Trapping Rain Water:</strong>
            <p class="mb-2">Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.</p>
            <div class="code-snippet">
                function trap(height) {<br>
                &nbsp;&nbsp;let left = 0, right = height.length - 1;<br>
                &nbsp;&nbsp;let leftMax = 0, rightMax = 0;<br>
                &nbsp;&nbsp;let water = 0;<br>
                &nbsp;&nbsp;while (left < right) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;if (height[left] < height[right]) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftMax = Math.max(leftMax, height[left]);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;water += leftMax - height[left];<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left++;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rightMax = Math.max(rightMax, height[right]);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;water += rightMax - height[right];<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right--;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                &nbsp;&nbsp;}<br>
                &nbsp;&nbsp;return water;<br>
                }
            </div>
        </div>
        <div class="algorithm-explanation mt-3">
    <h6>Stock Span Problem Algorithm</h6>
    <p>The stock span problem calculates for each day, the number of consecutive days (including current day) 
    for which the stock price was less than or equal to the current day's price.</p>
    
    <div class="code-snippet">
        function calculateStockSpan(prices) {<br>
        &nbsp;&nbsp;let spans = new Array(prices.length);<br>
        &nbsp;&nbsp;let stack = []; // monotonic stack (decreasing order)<br>
        &nbsp;&nbsp;<br>
        &nbsp;&nbsp;for (let i = 0; i < prices.length; i++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;// Pop while stack is not empty and top <= current<br>
        &nbsp;&nbsp;&nbsp;&nbsp;while (stack.length > 0 && prices[stack[stack.length-1]] <= prices[i]) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.pop();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;&nbsp;&nbsp;// Calculate span<br>
        &nbsp;&nbsp;&nbsp;&nbsp;spans[i] = stack.length === 0 ? i + 1 : i - stack[stack.length-1];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;// Push current index to stack<br>
        &nbsp;&nbsp;&nbsp;&nbsp;stack.push(i);<br>
        &nbsp;&nbsp;}<br>
        &nbsp;&nbsp;return spans;<br>
        }
    </div>
    
    <div class="algorithm-step active">
        <strong>Key Points:</strong>
    </div>
    <div class="algorithm-step">
         Uses a monotonic stack (decreasing order of prices)
    </div>
    <div class="algorithm-step">
         Time Complexity: O(n) - each element pushed and popped once
    </div>
    <div class="algorithm-step">
         Space Complexity: O(n) for the stack
    </div>
 </div>
    </div>
 </div>

                        <!-- Advanced Sorting Tab -->
                        <div class="tab-pane fade" id="advanced-sorting" role="tabpanel">
                            <div class="mb-3">
                                <label class="form-label">Advanced Sorting Algorithms</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="selectionSortBtn">
                                        <i class="fas fa-sort-amount-down me-2"></i>Selection Sort
                                    </button>
                                    <button class="btn btn-glow" id="insertionSortBtn">
                                        <i class="fas fa-sort-numeric-up me-2"></i>Insertion Sort
                                    </button>
                                </div>
                                <small class="text-muted">Visualize advanced sorting algorithms with step-by-step animations</small>
                            </div>
                            
                            <div class="algorithm-explanation mt-3" id="advancedSortingExplanation">
                                <h6>Advanced Sorting Algorithms</h6>
                                
                                <div class="mb-3">
                                    <strong>Selection Sort:</strong>
                                    <div class="code-snippet">
                                        function selectionSort(arr) {<br>
                                        &nbsp;&nbsp;let n = arr.length;<br>
                                        &nbsp;&nbsp;for (let i = 0; i < n-1; i++) {<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;let minIdx = i;<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;for (let j = i+1; j < n; j++) {<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (arr[j] < arr[minIdx]) {<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minIdx = j;<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;[arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];<br>
                                        &nbsp;&nbsp;}<br>
                                        &nbsp;&nbsp;return arr;<br>
                                        }
                                    </div>
                                </div>
                                <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
                                <!-- Add this in the Create Tab after the existing sorting buttons -->
<div class="mb-3">
    <label class="form-label">Ultra Advanced Sorting Algorithms </label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="quickSortBtn">
            <i class="fas fa-bolt me-2"></i>Quick Sort
        </button>
        <button class="btn btn-glow" id="heapSortBtn">
            <i class="fas fa-layer-group me-2"></i>Heap Sort
        </button>
    </div>
</div>
<!-- Add this in the Search Tab after the Element Uniqueness Operations section -->
<div class="mb-3">
    <label class="form-label">Research Impact Analysis</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="hIndexBtn">
            <i class="fas fa-chart-line me-2"></i>Calculate H-Index (Research Impact)
        </button>
    </div>
    <small class="text-muted">Measures research impact based on citation counts</small>
</div>
<div class="mb-3">
    <label class="form-label">Custom Comparator Sort</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="customComparatorSortBtn">
            <i class="fas fa-sort-alpha-down me-2"></i>Custom Comparator Sort
        </button>
    </div>
</div>

<!-- Custom Comparator Sort Container (initially hidden) -->
<div class="custom-comparator-container" id="customComparatorContainer" style="display: none;">
    <h5 class="text-center mb-3">Custom Comparator Sort</h5>
    
    <!-- Dictionary Creation Section -->
    <div class="mb-3" id="dictionaryCreationSection">
        <label class="form-label">Create Dictionary</label>
        <div class="input-group mb-2">
            <input type="text" class="form-control" id="dictionaryName" placeholder="Enter dictionary name">
            <button class="btn btn-glow" id="createDictionaryBtn">
                <i class="fas fa-plus me-2"></i>Create Dictionary
            </button>
        </div>
    </div>

    <!-- Dictionary Structure Section (initially hidden) -->
    <div class="mb-3" id="dictionaryStructureSection" style="display: none;">
        <label class="form-label">Define Dictionary Structure</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="fieldCount" placeholder="Number of fields" min="1" max="10">
            <button class="btn btn-glow" id="confirmFieldCountBtn">
                <i class="fas fa-check me-2"></i>Confirm Field Count
            </button>
        </div>
        <div id="fieldDefinitions" class="mt-3"></div>
    </div>

    <!-- Data Entry Section (initially hidden) -->
    <div class="mb-3" id="dataEntrySection" style="display: none;">
        <label class="form-label">Add Data Records</label>
        <div id="dataEntryForm" class="mb-3"></div>
        <button class="btn btn-glow" id="addRecordBtn">
            <i class="fas fa-plus-circle me-2"></i>Add Record
        </button>
        <button class="btn btn-glow" id="finishDataEntryBtn">
            <i class="fas fa-check-double me-2"></i>Finish Data Entry
        </button>
    </div>

    <!-- Dictionary Operations Section (initially hidden) -->
    <div class="mb-3" id="dictionaryOperationsSection" style="display: none;">
        <label class="form-label">Dictionary Operations</label>
        <div class="d-flex gap-2 mb-3">
            <button class="btn btn-glow" id="updateDictionaryBtn">
                <i class="fas fa-edit me-2"></i>Update Dictionary
            </button>
            <button class="btn btn-glow" id="dropDictionaryBtn">
                <i class="fas fa-trash me-2"></i>Drop Dictionary
            </button>
        </div>
        
        <!-- Sort Configuration -->
        <div class="sort-configuration">
            <h6>Sort Configuration</h6>
            <div class="row mb-3">
                <div class="col-md-5">
                    <label class="form-label">Sort By Field</label>
                    <select class="form-control" id="sortFieldSelect"></select>
                </div>
                <div class="col-md-5">
                    <label class="form-label">Order By</label>
                    <select class="form-control" id="sortOrderSelect">
                        <option value="asc">Ascending</option>
                        <option value="desc">Descending</option>
                    </select>
                </div>
                <div class="col-md-2">
                    <label class="form-label">&nbsp;</label>
                    <button class="btn btn-glow w-100" id="performSortBtn">
                        <i class="fas fa-play me-1"></i>Sort
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Dictionary Display Section -->
    <div id="dictionaryDisplaySection" style="display: none;">
        <h6>Dictionary Data</h6>
        <div class="table-container" id="dictionaryTableContainer">
            <table class="dictionary-table" id="dictionaryTable">
                <thead>
                    <tr id="dictionaryTableHeader"></tr>
                </thead>
                <tbody id="dictionaryTableBody"></tbody>
            </table>
        </div>
    </div>

    <!-- Sort Visualization Section -->
    <div id="sortVisualizationSection" style="display: none;">
        <h6 class="text-center">Sorting Process Visualization</h6>
        <div class="algorithm-explanation" id="sortAlgorithmExplanation">
            <p id="sortExplanationText">Starting custom comparator sort...</p>
            <div id="sortStepsContainer" class="mt-3"></div>
        </div>
        <button class="btn btn-sm btn-outline-light mt-3" id="resetAfterSortBtn">
            <i class="fas fa-undo me-1"></i>Return to Original Order
        </button>
    </div>

    <!-- Cancel Button -->
    <div class="text-center mt-3">
        <button class="btn btn-outline-light" id="cancelCustomSortBtn">
            <i class="fas fa-times me-2"></i>Cancel Custom Sort
        </button>
    </div>
</div>
                                <div class="mb-3">
                                    <strong>Insertion Sort:</strong>
                                    <div class="code-snippet">
                                        function insertionSort(arr) {<br>
                                        &nbsp;&nbsp;let n = arr.length;<br>
                                        &nbsp;&nbsp;for (let i = 1; i < n; i++) {<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;let key = arr[i];<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;let j = i - 1;<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;while (j >= 0 && arr[j] > key) {<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j+1] = arr[j];<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j--;<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;arr[j+1] = key;<br>
                                        &nbsp;&nbsp;}<br>
                                        &nbsp;&nbsp;return arr;<br>
                                        }
                                    </div>
                                </div>
                                
                                <div id="advancedSortingSteps">
                                    <div class="algorithm-step">
                                        <strong>Selection Sort Steps:</strong>
                                    </div>
                                    <div class="algorithm-step">
                                         Find the minimum element in the unsorted portion
                                    </div>
                                    <div class="algorithm-step">
                                         Swap it with the first element of the unsorted portion
                                    </div>
                                    <div class="algorithm-step">
                                         Move the boundary between sorted and unsorted portions one element to the right
                                    </div>
                                    <div class="algorithm-step">
                                         Repeat until the entire array is sorted
                                    </div>
                                    
                                    <div class="algorithm-step mt-2">
                                        <strong>Insertion Sort Steps:</strong>
                                    </div>
                                    <div class="algorithm-step">
                                         Start with the second element as the key
                                    </div>
                                    <div class="algorithm-step">
                                         Compare the key with elements in the sorted portion to its left
                                    </div>
                                    <div class="algorithm-step">
                                         Shift elements greater than the key one position to the right
                                    </div>
                                    <div class="algorithm-step">
                                         Insert the key in its correct position
                                    </div>
                                    <div class="algorithm-step">
                                         Repeat for all elements
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="glass-card mt-4">
                    <h5 class="mb-3">Operation Log</h5>
                    <div class="operation-log" id="operationLog">
                        <!-- Operation logs will appear here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Array to store our data
        let myArray = [];
        let operationCount = 0;
        let isLinearSearchRunning = false;
        
        // DOM Elements
        const arrayContainer = document.getElementById('arrayContainer');
        const arrayLength = document.getElementById('arrayLength');
        const firstElement = document.getElementById('firstElement');
        const lastElement = document.getElementById('lastElement');
        const totalOperations = document.getElementById('totalOperations');
        const operationLog = document.getElementById('operationLog');
        const searchResults = document.getElementById('searchResults');
        const algorithmSteps = document.getElementById('algorithmSteps');
        // Add these with other input elements
const arraySize = document.getElementById('arraySize');
const resizeSize = document.getElementById('resizeSize');

// Add these with other button elements
const createArrayFromRangeBtn = document.getElementById('createArrayFromRangeBtn');
const resizeArrayBtn = document.getElementById('resizeArrayBtn');
// Add these with other input elements
const sliceStart = document.getElementById('sliceStart');
const sliceEnd = document.getElementById('sliceEnd');
const sumElements = document.getElementById('sumElements');
const productElements = document.getElementById('productElements');
// Add these with other button elements
const sliceBtn = document.getElementById('sliceBtn');
const resetArrayBtn = document.getElementById('resetArrayBtn');
// Add with other button elements
const shiftLeftBtn = document.getElementById('shiftLeftBtn');
const shiftRightBtn = document.getElementById('shiftRightBtn');
const resetShiftBtn = document.getElementById('resetShiftBtn');
const popLastBtn = document.getElementById('popLastBtn');
// Add with other input elements
const cloneIndex = document.getElementById('cloneIndex');
const cloneElementValue = document.getElementById('cloneElementValue');
const cloneArrayBtn = document.getElementById('cloneArrayBtn');

// Add these with other data variables
let originalArray = []; // To store the original array
let isSubarray = false; // To track if we're viewing a subarray

// Add with other variables
let isBinarySearchRunning = false;
let sortedArrayBackup = []; // To store original array during binary search
let isCurrentlySorted = false; // Track if array is currently sorted
// Add with other data variables
let originalArrayForShift = []; // To store original array for shift operations
let isShifted = false; // Track if array is currently shifted
// Add with other data variables
let isTraversalRunning = false;
let traversalDirection = null;
// Add with other data variables
let originalArrayForTransformation = [];
let currentTransformationType = null; // 'cumulative' or 'prefix'
// Add with other data variables
let originalArrayForOperations = [];
let currentOperation = null;
let rotatePositions = 0;
// Add with other data variables
let originalArrayForFill = [];
let originalArrayForSwap = [];
let isFillOperation = false;
let isSwapOperation = false;
// Add with other data variables
let subarraySumResults = [];
// Add with other data variables
let isTwoPointerRunning = false;
let twoPointerLeft = 0;
let twoPointerRight = 0;
// Add with other data variables
let isSortingRunning = false;
let originalArrayForSort = [];
// Add with other data variables
let isValidationRunning = false;
let isPartialSortRunning = false;
let originalArrayForPartialSort = [];
let isStableSortRunning = false;
let originalArrayForStableSort = [];
// Add with other data variables
let isSubarraySortRunning = false;
let originalArrayForSubarraySort = [];
let subarraySortStart = 0;
let subarraySortEnd = 0;
// Add with other data variables
let isMergeOperationRunning = false;
let firstArray = [];
let secondArray = [];
let firstArraySize = 0;
let secondArraySize = 0;
let originalArrayBeforeMerge = [];
// Add with other data variables
let isWindowOperationRunning = false;
let originalArrayForWindow = [];
// Add with other data variables
let isTwoPointerSortRunning = false;
let isKadaneAlgorithmRunning = false;
let originalArrayForTwoPointerSort = [];
let originalArrayForKadane = [];
let isZeroMovementRunning = false;
let originalArrayForZeroMovement = [];
// Add with other data variables
let isRearrangeRunning = false;
let originalArrayForRearrange = [];
// Add with other data variables
let isSegregateRunning = false;
let originalArrayForSegregate = [];
// Add with other data variables
let isFrequencyCountRunning = false;
let isFindDuplicatesRunning = false;
let originalArrayForFrequency = [];
let originalArrayForDuplicates = [];
// Add with other data variables
let isNonRepeatingRunning = false;
let isUniqueElementsRunning = false;
let originalArrayForUniqueness = [];
// Add with other data variables
let isMajoritySearchRunning = false;
let originalArrayForMajority = [];
// Add with other data variables
let isDutchSortRunning = false;
let originalArrayForDutch = [];
// Add with other data variables
let originalArrayBeforeShiftDelete = [];
let isShiftDeleteRunning = false;
// Add with other data variables
let isPivotSearchRunning = false;
let originalArrayForPivot = [];
// Add with other data variables
let isRotatedSearchRunning = false;
let originalArrayForRotatedSearch = [];
let rotatedArray = [];
// Add with other data variables
let originalArrayBeforeProgression = [];
let isProgressionOperation = false;
let currentProgressionType = null;
// Add these variables with other data variables
let isKthOperationRunning = false;
let originalArrayForKth = [];
let kthOperationType = null;
let kthValue = 1;
// Add these variables with other data variables
let isSelectionSortRunning = false;
let isInsertionSortRunning = false;
let originalArrayForSelectionSort = [];
let originalArrayForInsertionSort = [];
// Add with other data variables
let isCyclicShiftRunning = false;
let originalArrayForCyclicShift = [];
let currentCyclicShiftType = null; // 'left' or 'right'
let cyclicShiftPositions = 0;
// Add with other data variables
let isNegationRunning = false;
let originalArrayForNegation = [];
// Add these variables with other data variables
let isNBy3OperationRunning = false;
let isNextGreaterElementRunning = false;
let originalArrayForNBy3 = [];
let originalArrayForNGE = [];
// Add with other data variables
let isShallowCopyRunning = false;
let originalArrayForShallowCopy = [];
let shallowCopyModifications = [];
// Add with other data variables
let isInPlaceMergeSortRunning = false;
let originalArrayForInPlaceMergeSort = [];
// Add with other data variables
let isInsertSortedRunning = false;
let insertSortedElements = [];
let originalArrayForInsertSorted = [];
let insertSortedCount = 0;
// Add with other data variables
let isRandomArrayGenerationRunning = false;
let originalArrayBeforeRandom = [];
// Add with other data variables
let isCharArrayConversionRunning = false;
let originalArrayForCharConversion = [];
// Global variables
let isCustomSortRunning = false;
let currentDictionary = {
    name: '',
    fields: [],
    data: [],
    originalData: []
};
let isEditingRecord = false;
let editingRecordIndex = -1;
// Add with other data variables
let isQuickSortRunning = false;
let isHeapSortRunning = false;
let originalArrayForQuickSort = [];
let originalArrayForHeapSort = [];
// Add with other data variables
let isEvenOddSortRunning = false;
let isAbsoluteSortRunning = false;
let originalArrayForSpecialSort = [];
// Add with other data variables
let originalArrayForShiftInsert = [];
let isShiftInsertRunning = false;
// Add with other data variables
let isTripletOperationRunning = false;
let isQuadrupletOperationRunning = false;
let originalArrayForTriplet = [];
let originalArrayForQuadruplet = [];
// Add with other data variables
let isEquilibriumRunning = false;
let originalArrayForEquilibrium = [];
// Add with other data variables
let isWaterProblemRunning = false;
let originalArrayForWater = [];
// Add with other data variables
let isTwoSumRunning = false;
let originalArrayForTwoSum = [];
let twoSumTarget = 0;
// Add with other data variables
let isGcdOperationRunning = false;
let isLcmOperationRunning = false;
let originalArrayForGcdLcm = [];
// Add with other data variables
let isPrimeSieveRunning = false;
let originalArrayForPrimeSieve = [];
// Add with other data variables
let isLongestSubstringRunning = false;
let originalArrayForSubstring = [];
// Add with other data variables
let isSubarrayProductRunning = false;
let originalArrayForProduct = [];
// Add with other data variables
let isLeaderOperationRunning = false;
let originalArrayForLeader = [];
// Add with other data variables
let isJumpGameRunning = false;
let originalArrayForJumpGame = [];
// Add with other data variables
let isNearZeroRunning = false;
let originalArrayForNearZero = [];
// Add with other data variables
let isMinWindowRunning = false;
let originalArrayForMinWindow = [];
let mainString = "";
let targetString = "";
// Add with other data variables
let isKConsecutiveRunning = false;
let originalArrayForKConsecutive = [];
// Add with other data variables
let isRearrangeMinMaxRunning = false;
let originalArrayForMinMax = [];
// Add with other data variables
let isNextPermutationRunning = false;
let originalArrayForPermutation = [];
// Add with other data variables
let isConsecutiveOperationRunning = false;
let originalArrayForConsecutive = [];
// Add with other data variables
let isMergeIntervalsRunning = false;
let originalArrayForMergeIntervals = [];
// Add with other data variables
let isSetOperationRunning = false;
let currentSetOperation = null;
let setArrays = [];
let originalArrayBeforeSetOperation = [];
// Add with other data variables
let isSetOpRunning = false;
let currentSetOpType = null;
let setOpArrays = [];
let originalArrayBeforeSetOp = [];
// Add with other data variables
let isSubsetSupersetRunning = false;
let currentSubsetSupersetOperation = null; // 'subset' or 'superset'
let comparisonArrays = [];
let originalArrayBeforeComparison = [];
let numArraysComp = 0;
let arraySizesComp = [];
let arrayElementsComp = [];
// Add these with other data variables
let isSubsetCompRunning = false;
let isSupersetCompRunning = false;
let originalArrayForSubsetComp = [];
let originalArrayForSupersetComp = [];
let subsetCompArrays = [];
let supersetCompArrays = [];
// Add with other data variables
let memoryAddresses = new Map(); // Store memory addresses for each array
let currentMemoryAddress = '';
// Add with other data variables
let isComparisonRunning = false;
let originalArrayForComparison = [];
// Add with other data variables
let isStatisticalOperationRunning = false;
let currentStatisticalOperation = null; // 'covariance' or 'correlation'
let statisticalArrays = [];
let statisticalArrayNames = [];
let originalArrayForStatistical = [];
// Add with other data variables
let isStatisticalCalculationRunning = false; // Note: Different name to avoid duplication
let originalArrayForStats = [];
// Add with other data variables
let isElementWiseOperationRunning = false;
let elementWiseFirstArray = [];
let elementWiseSecondArray = [];
let elementWiseFirstArraySize = 0;
let elementWiseSecondArraySize = 0;
let originalArrayBeforeElementWise = [];
let currentElementWiseOperation = null; // 'max' or 'min'
// Add with other data variables
let isLogicalOperationRunning = false;
let logicalArrays = [];
let logicalOperationType = '';
let originalArrayForLogical = [];
let logicalArraysCount = 0;
let logicalArraysSizes = [];
// Add with other data variables - ONLY ONCE
let isStatsCalcRunning = false; // Different name to avoid duplicates
let statsOriginalArray = []; // Renamed from originalArrayForStats
// Add with other data variables
let originalArrayForScalar = [];
let isScalarOperationRunning = false;
// Add with other data variables
let isTrigOperationRunning = false;
let originalArrayForTrig = [];
let currentTrigOperation = null;
// Add with other data variables
let isRangeOperationRunning = false;
let originalArrayForRange = [];
// Add with other data variables
let isMathOperationRunning = false;
let originalArrayForMath = [];
let currentMathOperation = null;
// Add with other data variables
let isPancakeSortRunning = false;
let originalArrayForPancakeSort = [];
let pancakeSortSteps = [];
let currentPancakeStep = 0;
// Add with other data variables
let isStockSpanRunning = false;
let originalArrayForStockSpan = [];
// Add with other data variables
let isMaxPairAndOrRunning = false;
let originalArrayForMaxPair = [];
// Add with other data variables
let isHistogramRunning = false;
let originalArrayForHistogram = [];
// Add with other data variables
let isFruitBasketRunning = false;
let originalArrayForFruitBasket = [];
// Add with other data variables
let isElementWiseOpRunning = false;
let elemWiseFirstArray = [];
let elemWiseSecondArray = [];
let elemWiseFirstSize = 0;
let elemWiseSecondSize = 0;
let currentElementWiseOp = null;
let originalArrayBeforeElemWise = [];
// Add with other data variables (replace the conflicting ones)
let isLogicalOpRunning = false;
let originalArrayForLogicalOps = [];
let logicalOpType = null;
let logicalOpArrays = [];
let logicalOpResultArray = [];
// Add with other data variables
let isTransformRunning = false;
let originalArrayForTransform = [];
let transformSteps = [];
let currentTransformStep = 0;
// Add with other data variables
let isMinFlipsRunning = false;
let minFlipsOperationType = null; // 'or' or 'and'
let minFlipsArrays = [];
let minFlipsOriginalArrays = [];
let minFlipsNumArraysCount = 0; // Changed from minFlipsNumArrays
let minFlipsArraySizes = [];
// Add with other data variables
let isPrefixXorRunning = false;
let originalArrayForXor = [];
// Add with other data variables
let isMaxAbsDiffRunning = false;
let originalArrayForAbsDiff = [];
// Add with other data variables
let isCircularSubarrayRunning = false;
let originalArrayForCircular = [];
// Add with other data variables
let isWiggleSortRunning = false;
let originalArrayForWiggle = [];
// Add with other data variables
let isMaxDistanceRunning = false;
let originalArrayForMaxDistance = [];
// Add with other data variables
let isCountPairsRunning = false;
let originalArrayForPairs = [];
// Add with other data variables
let isMinSwapsRunning = false;
let originalArrayForMinSwaps = [];
// Add with other data variables
let isMissingRepeatingRunning = false;
let originalArrayForMissingRepeating = [];
// Add with other data variables
let isFirstRepeatingRunning = false;
let originalArrayForRepeating = [];
// Add with other data variables
let isConditionalOperationRunning = false;
let currentConditionalOperation = null;
let array1 = [];
let array2 = [];
let array1Size = 0;
let array2Size = 0;
let originalArrayForConditional = [];
// Add these with other data variables
let isPreviousElementRunning = false;
let originalArrayForPreviousElement = [];
// Add with other data variables
let isPredicateFilterRunning = false;
let originalArrayForPredicate = [];
// Add with other data variables
let isReshapeOperationRunning = false;
let originalArrayForReshape = [];
let autoRevertTimer = null;
// Add with other data variables
let isDataTypeOperationRunning = false;
let originalArrayForDataType = [];
// Add with other data variables
let isShuffleRunning = false;
let originalArrayForShuffle = [];
// Add with other data variables
let isBinningRunning = false;
let originalArrayForBinning = [];
// Add with other data variables
let isUfuncRunning = false;
let originalArrayForUfunc = [];
// Stock Market Data Variables
let originalStockPrices = [];
let isStockOperationRunning = false;
// Add these with your existing stock market variables
let openPrices = [];
let closePrices = [];
// Add with other data variables
let isAxisOperationRunning = false;
let originalArrayForAxis = [];
let currentMatrix = [];
let matrixRows = 0;
let matrixCols = 0;
// Add with other data variables - using unique names
let isStatisticalAnalysisRunning = false;
let originalArrayForStatisticalOps = [];
let currentStatOperation = null; // Renamed from currentStatisticalOperation
let nValueForStatisticalAnalysis = 0;
// Add with other data variables (using unique names)
let isParenthesesCheckActive = false;
let originalArrayState = [];
// Add with other data variables
let isPalindromeOperationRunning = false;
let isAnagramOperationRunning = false;
// Add with other data variables
let isRangeSumRunning = false;
let originalArrayForRangeSum = [];
// Add with other data variables
let isDailyTemperaturesRunning = false;
let originalArrayForDailyTemperatures = [];
// Add with other data variables
let isFirstLastSearchRunning = false;
let originalArrayForFirstLast = [];
// Add with other data variables - PALINDROME OPERATIONS
let isPalindromicOperationRunning = false;
let originalArrayBeforePalindrome = [];
let originalStringBeforePalindrome = "";
// Add these with other data variables
let isPatternMatchingRunning = false;
let currentPatternMatchingType = null;
let originalArrayForPatternMatching = [];
// Add with other data variables
let isCombinationSumRunning = false;
let isSubsetsRunning = false;
let originalArrayForBacktrack = [];
// Add with other data variables
let isParenthesesOperationRunning = false;
let isSubsequencesOperationRunning = false;
let originalArrayForParentheses = [];
let originalArrayForSubsequences = [];
// Add with other data variables
let isWordConcatSearchActive = false;
let originalArrayBeforeWordConcat = [];
let wordConcatSearchResults = [];
// Add with other data variables
let isSmallerCountRunning = false;
let originalArrayForSmallerCount = [];
// Add these with other data variables
let isUglyNumberOperationRunning = false;
// Add with other data variables
let isPerfectNumberRunning = false;
let isArmstrongNumberRunning = false;
let originalArrayForSpecialNumbers = [];
// Add with other data variables
let isPascalOperationRunning = false;
let originalArrayForPascal = [];
// Add with other data variables
let isRandomPickRunning = false;
let originalArrayForRandomPick = [];
// Add with other data variables
let isRandomPointRunning = false;
let originalArrayForRandomPoint = [];
// Add with other data variables - using unique names
let isConsecutiveSequenceSearchRunning = false;
let originalArrayForConsecutiveSearch = [];
// Add with other data variables
let isNumberOperationRunning = false;
let originalArrayForNumberOps = [];
// Add with other data variables
let isDigitalRootRunning = false;
let isHappyNumberRunning = false;
let originalArrayForDigitalRoot = [];
let originalArrayForHappyNumber = [];
// Add with other data variables
let isExcelConversionRunning = false;
let originalArrayForExcel = [];
// Add with other data variables
let isNumberToColumnRunning = false;
let originalArrayForNumberToColumn = [];
// Add these with other data variables
let stack = null;
let originalArrayForStack = [];
let isStackOperationRunning = false;
let stackAnimationTimeout = null;
// Add with other data variables
let isQueueOperationRunning = false;
let queueArray = [];
let queueSize = 0;
let front = -1;
let rear = -1;
let originalArrayForQueue = [];
// Add with other data variables
let isPriorityQueueRunning = false;
let priorityQueueArray = [];
let maxQueueSize = 0;
let queueFrontIndex = -1;
let queueRearIndex = -1;
let originalArrayForPriorityQueue = [];
let isMinHeap = true; // true for Min-Heap, false for Max-Heap
// Add with other data variables
let isBrowserHistoryRunning = false;
let browserHistory = null;
let originalArrayForBrowser = [];
// Add with other data variables
let orderedStream = null;
let isStreamActive = false;
let originalArrayBeforeStream = [];
// Add with other data variables
let isRLEOperationRunning = false;
let originalArrayForRLE = [];
let rleInputString = '';
// Add with other data variables
let isDeltaEncodingRunning = false;
let isBWTRunning = false;
let isMTFRunning = false;
let originalArrayForDelta = [];
let deltaArraySize = 0;
// Add with other data variables
let isCountAndSayRunning = false;
let isStringCompressionRunning = false;
let originalArrayForCountSay = [];
let originalArrayForCompression = [];
// Add with other data variables
let isStringOperationRunning = false;
let originalArrayForStringOps = [];
let logEntries = [];
let logCount = 0;
// Add with other data variables
// Pattern Search Variables
let currentPatternAlgorithm = null;
let isPatternSearchRunning = false;
let originalArrayBeforePatternSearch = [];
// Add with other data variables
let isWordAbbrValidationRunning = false;
let originalWord = '';
let originalAbbr = '';
// Add with other data variables
let isShortestWordDistanceRunning = false;
let originalArrayForWordDistance = [];
let wordDistanceArray = [];
let word1Positions = [];
let word2Positions = [];
// Add with other data variables - USING UNIQUE NAMES
let isGroupShiftedStringsRunning = false;
let isFlipGameRunning = false;
let shiftedStringsArray = [];
let originalArrayForStringAlgorithms = []; // Renamed to avoid conflict
// Add with other data variables
let isNimGameRunning = false;
let originalArrayForNim = [];
let nimPiles = [];
let nimArraySize = 0;
// Add with other data variables
let isCanIWinRunning = false;
let originalArrayForCanIWin = [];
// Add with other data variables
let isPredictWinnerRunning = false;
let originalArrayForPredictWinner = [];
let predictWinnerArray = [];
let predictWinnerSize = 0;
// Add with other data variables
let isStoneGameRunning = false;
let originalArrayForStoneGame = [];
let stoneGameState = {
    totalStones: 0,
    maxPick: 0,
    remainingStones: 0,
    currentPlayer: '',
    player1: '',
    player2: '',
    gameLog: []
};
// Add with other data variables
let isGasStationRunning = false;
let gasStationData = {
    gas: [],
    cost: [],
    stationCount: 0
};
let originalArrayForGasStation = [];
// Add with other data variables
let isCandyDistributionRunning = false;
let originalArrayForCandy = [];
let candyRatings = [];
let candyArray = [];
// Add with other data variables
let isTaskSchedulerRunning = false;
let originalArrayForTaskScheduler = [];
let taskSchedulerTasks = [];
let taskSchedulerCooldown = 0;
// Add with other data variables
let isPartitionRunning = false;
let originalArrayForPartition = [];
// Add with other data variables
let isPartitionMaxSumRunning = false;
let originalArrayForPartitionMaxSum = [];
// Add with other data variables
let isPartitionLabelsOperationRunning = false;
let originalArrayBeforePartitionLabels = [];
// Add with other data variables
let isSplitArrayRunning = false;
let originalArrayForSplit = [];
// Add with other data variables
let isSplitEqualSumRunning = false;
let originalArrayForEqualSplit = [];
// Add with other data variables
let isSequenceOperationRunning = false;
let originalArrayForSequence = [];
let currentSequenceOperation = null;
// Add with other data variables
let isNiceSubarrayRunning = false;
let originalArrayForNiceSubarray = [];
// Add with other data variables
let isKDistinctRunning = false;
let originalArrayForKDistinct = [];
// Add with other data variables
let isThreeCharsRunning = false;
let originalArrayForThreeChars = [];
let inputStringForThreeChars = '';
// Add with other data variables
let isTurbulentRunning = false;
let originalArrayForTurbulent = [];
// Add with other data variables
let isReversePairsRunning = false;
let originalArrayForReversePairs = [];
// Add with other data variables
let isInversionsAnalysisRunning = false;
let originalArrayForInversions = [];
// Add with other data variables
let isSummaryRangesRunning = false;
let isFindRightIntervalRunning = false;
let originalArrayForSummaryRanges = [];
let originalArrayForRightInterval = [];
// Add with other data variables
let isMinArrowsRunning = false;
let originalArrayForArrows = [];
let balloonIntervals = [];
// Add with other data variables
let isTeemoAttackingRunning = false;
let originalArrayForTeemo = [];
let teemoDuration = 0;
// Add with other data variables
let isOceanViewRunning = false;
let isTargetArrayRunning = false;
let originalArrayForOceanView = [];
let originalArrayForTargetArray = [];
let targetArrayValues = [];
let targetArrayIndices = [];
// Add with other data variables
let isRLEOperationActive = false;
let isNestingOperationActive = false;
let originalArrayForRLEOperation = [];
let originalArrayForNestingOperation = [];
// Add with other data variables
let isQueueReconstructionRunning = false;
let originalArrayForQueueReconstruction = []; // Renamed from originalArrayForQueue
let queuePeople = [];
let queueSizeValue = 0;
// Add with other data variables
let isCrawlerLogRunning = false;
let originalArrayForCrawler = [];
let crawlerLogs = [];
let crawlerLogSize = 0;
// Add with other data variables
let isSingleNumberRunning = false;
let originalArrayForSingleNumber = [];
 // NEW: Variables for string operations (renamed to avoid duplicates)
let isStringOpRunning = false;
let currentStringOpType = null;
let stringOpArray = [];
let stringOpArraySize = 0;
let originalArrayForStringOp = [];
// Add with other data variables
let isBitwiseOperationRunning = false;
let originalArrayForBitwise = [];
let isRangeBitwiseRunning = false;
// Add with other data variables
let isHammingOperationRunning = false;
let currentHammingOperation = null;
let hammingArray = [];
let originalArrayForHamming = [];
// Add with other data variables
let isSuperstringRunning = false;
let originalArrayForSuperstring = [];
let superstringStrings = [];
// Add with other data variables
let isGrayCodeRunning = false;
let originalArrayForGrayCode = [];
let grayCodeReturnTimer = null;
// Add with other data variables
let isSmallestDivisorRunning = false;
let originalArrayForSmallestDivisor = [];
// Add with other data variables
let isHIndexRunning = false;
let originalArrayForHIndex = [];
// Add with other data variables
let isCapacityCalculationRunning = false;
let originalArrayForCapacity = [];
let capacityDays = 0;
// Add with other data variables
let isKokoAlgorithmRunning = false;
let kokoPiles = [];
let kokoHours = 0;
let originalArrayForKoko = [];
// Add with other data variables
let isBadVersionRunning = false;
let originalArrayForBadVersion = [];
let badVersionArray = [];
let firstBadVersionIndex = -1;
// Add with other data variables
let isHouseRobberRunning = false;
let originalArrayForRobber = [];
let robberHouses = [];
let robberDP = [];
// Add with other data variables
let isMaxSubarrayOneDeletionRunning = false;
let originalArrayForMaxSubarray = [];
// Add with other data variables
let isPairChainRunning = false;
let originalArrayForPairChain = [];
let pairArray = [];
let pairChainResults = [];
// Add with other data variables
let isArithmeticSlicesRunning = false;
let originalArrayForArithmetic = [];
// Add with other data variables
let isUniquePathsRunning = false;
let uniquePathsTimer = null;
// Add these with other data variables
let isCoinChangeRunning = false;
let originalArrayForCoinChange = [];
let coinArray = [];
let targetAmount = 0;
let coinChangeStep = 0;
let dpTable = [];
let solutionPath = [];
// Add with other data variables
let isDecodeWaysRunning = false;
let originalArrayForDecodeWays = [];
// Add with other data variables - RENAMED to avoid conflicts
let isPartitionEqualRunning = false;
let originalArrayForPartitionEqual = [];
// Add with other data variables
let isTargetSumRunning = false;
let originalArrayForTargetSum = [];
let targetSumResults = [];
// Add with other data variables
// Add with other data variables
let isWordBreakRunning = false;
let originalArrayForWordBreak = [];
let wordBreakString = '';
let wordDict = [];
// Add with other data variables
let isMaxRectangleRunning = false;
let originalArrayForMaxRectangle = [];
// Add with other data variables
let isLRUCacheRunning = false;
let lruCache = null;
let originalArrayForLRU = [];
let lruCapacity = 3;
// Add with other data variables
let isLFURunning = false;
let lfuCache = null;
let originalArrayForLFU = [];
let lfuHistory = [];
// Add with other data variables
let isMedianOperationRunning = false;
let originalArrayForMedian = [];
let isSlidingWindowMedianRunning = false;
let kValue = 0;
// Add with other data variables
let isCalendarRunning = false;
let calendarEvents = [];
let originalArrayBeforeCalendar = [];
let bookedEvents = [];
let currentCalendarStep = 0;

        // Input elements
        const createValue = document.getElementById('createValue');
        const insertIndex = document.getElementById('insertIndex');
        const insertValue = document.getElementById('insertValue');
        const readIndex = document.getElementById('readIndex');
        const updateIndex = document.getElementById('updateIndex');
        const updateValue = document.getElementById('updateValue');
        const updateElement = document.getElementById('updateElement');
        const updateNewValue = document.getElementById('updateNewValue');
        const deleteIndex = document.getElementById('deleteIndex');
        const deleteElement = document.getElementById('deleteElement');
        const searchElement = document.getElementById('searchElement');
        const searchIndex = document.getElementById('searchIndex');
        const linearSearchElement = document.getElementById('linearSearchElement'); // NEW
        
        // Button elements
        const createBtn = document.getElementById('createBtn');
        const createRandomBtn = document.getElementById('createRandomBtn');
        const insertBtn = document.getElementById('insertBtn');
        const readBtn = document.getElementById('readBtn');
        const updateBtn = document.getElementById('updateBtn');
        const updateByElementBtn = document.getElementById('updateByElementBtn');
        const deleteBtn = document.getElementById('deleteBtn');
        const deleteByElementBtn = document.getElementById('deleteByElementBtn');
        const clearArrayBtn = document.getElementById('clearArrayBtn');
        const searchBtn = document.getElementById('searchBtn');
        const searchByIndexBtn = document.getElementById('searchByIndexBtn');
        const linearSearchBtn = document.getElementById('linearSearchBtn'); // NEW
        // Add with other DOM elements
const binarySearchElement = document.getElementById('binarySearchElement');
const binarySearchBtn = document.getElementById('binarySearchBtn');
const binarySearchSteps = document.getElementById('binarySearchSteps');
const checkElement = document.getElementById('checkElement');

// Add with other button elements
const checkElementBtn = document.getElementById('checkElementBtn');
const findMinElementBtn = document.getElementById('findMinElementBtn');
const findMaxElementBtn = document.getElementById('findMaxElementBtn');
// Add with other button elements
const traverseForwardBtn = document.getElementById('traverseForwardBtn');
const traverseBackwardBtn = document.getElementById('traverseBackwardBtn');
// Add with other DOM elements
const reverseArrayBtn = document.getElementById('reverseArrayBtn');
const rotateLeftBtn = document.getElementById('rotateLeftBtn');
const rotateRightBtn = document.getElementById('rotateRightBtn');
const rotateInputGroup = document.getElementById('rotateInputGroup');
const rotatePositionsInput = document.getElementById('rotatePositions');
const confirmRotateBtn = document.getElementById('confirmRotateBtn');
const cancelRotateBtn = document.getElementById('cancelRotateBtn');
// Add with other DOM elements
const fillValue = document.getElementById('fillValue');
const fillStart = document.getElementById('fillStart');
const fillEnd = document.getElementById('fillEnd');
const fillArrayBtn = document.getElementById('fillArrayBtn');
const swapByValuesBtn = document.getElementById('swapByValuesBtn');
const swapByIndicesBtn = document.getElementById('swapByIndicesBtn');
const swapByValuesGroup = document.getElementById('swapByValuesGroup');
const swapByIndicesGroup = document.getElementById('swapByIndicesGroup');
const swapCount = document.getElementById('swapCount');
const confirmSwapCountBtn = document.getElementById('confirmSwapCountBtn');
const swapValuesInputs = document.getElementById('swapValuesInputs');
const swapIndicesCount = document.getElementById('swapIndicesCount');
const confirmSwapIndicesCountBtn = document.getElementById('confirmSwapIndicesCountBtn');
const swapIndicesInputs = document.getElementById('swapIndicesInputs');
const stableSortBtn = document.getElementById('stableSortBtn');
// Add with other DOM elements
const subarraySumInput = document.getElementById('subarraySumInput');
const findSubarraySumBtn = document.getElementById('findSubarraySumBtn');
const generateAllSubarraysWithSumBtn = document.getElementById('generateAllSubarraysWithSumBtn');
// Add with other DOM elements
const twoPointerTraverseBtn = document.getElementById('twoPointerTraverseBtn');
// Add with other DOM elements
const sortAscBtn = document.getElementById('sortAscBtn');
const sortDescBtn = document.getElementById('sortDescBtn');
    // Add with other input elements
const occurrenceElement = document.getElementById('occurrenceElement');
const occurrenceElementLast = document.getElementById('occurrenceElementLast');
const occurrenceElementAll = document.getElementById('occurrenceElementAll');
// Add with other button elements
const findFirstOccurrenceBtn = document.getElementById('findFirstOccurrenceBtn');
const findLastOccurrenceBtn = document.getElementById('findLastOccurrenceBtn');
const findAllOccurrencesBtn = document.getElementById('findAllOccurrencesBtn');
// Add with other input elements
const deleteFirstOccurrence = document.getElementById('deleteFirstOccurrence');
const deleteAllOccurrences = document.getElementById('deleteAllOccurrences');
// Add with other button elements
const deleteFirstOccurrenceBtn = document.getElementById('deleteFirstOccurrenceBtn');
const deleteAllOccurrencesBtn = document.getElementById('deleteAllOccurrencesBtn');
const removeDuplicatesInPlaceBtn = document.getElementById('removeDuplicatesInPlaceBtn');
const removeDuplicatesKeepOneBtn = document.getElementById('removeDuplicatesKeepOneBtn');
// Add with other DOM elements
const checkSortedBtn = document.getElementById('checkSortedBtn');
const partialSortBtn = document.getElementById('partialSortBtn');
const partialSortInputGroup = document.getElementById('partialSortInputGroup');
const partialSortCount = document.getElementById('partialSortCount');
const confirmPartialSortBtn = document.getElementById('confirmPartialSortBtn');
const cancelPartialSortBtn = document.getElementById('cancelPartialSortBtn');
// Add with other DOM elements
const sortSubarrayStart = document.getElementById('sortSubarrayStart');
const sortSubarrayEnd = document.getElementById('sortSubarrayEnd');
const sortSubarrayBtn = document.getElementById('sortSubarrayBtn');
// Add with other DOM elements
const mergeSortedArraysBtn = document.getElementById('mergeSortedArraysBtn');
const mergeArraysGroup = document.getElementById('mergeArraysGroup');
const firstArraySizeInput = document.getElementById('firstArraySize');
const secondArraySizeInput = document.getElementById('secondArraySize');
const confirmFirstArraySizeBtn = document.getElementById('confirmFirstArraySizeBtn');
const confirmSecondArraySizeBtn = document.getElementById('confirmSecondArraySizeBtn');
const firstArrayInputs = document.getElementById('firstArrayInputs');
const secondArrayInputs = document.getElementById('secondArrayInputs');
const performMergeBtn = document.getElementById('performMergeBtn');
const cancelMergeBtn = document.getElementById('cancelMergeBtn');
// Add with other DOM elements
const fixedWindowSize = document.getElementById('fixedWindowSize');
const fixedWindowBtn = document.getElementById('fixedWindowBtn');
const variableWindowSum = document.getElementById('variableWindowSum');
const variableWindowBtn = document.getElementById('variableWindowBtn');
// Add with other DOM elements
const twoPointerSortBtn = document.getElementById('twoPointerSortBtn');
const kadaneAlgorithmBtn = document.getElementById('kadaneAlgorithmBtn');
const subarrayInput = document.getElementById('subarrayInput');
const countSubarraysBtn = document.getElementById('countSubarraysBtn');
const generateSubarraysBtn = document.getElementById('generateSubarraysBtn');
const subarraysResults = document.getElementById('subarraysResults');
const subarrayCount = document.getElementById('subarrayCount');
const subarraysList = document.getElementById('subarraysList');
// Add with other DOM elements
const rearrangePositiveNegativeBtn = document.getElementById('rearrangePositiveNegativeBtn');
// Add with other DOM elements
const segregateEvenOddBtn = document.getElementById('segregateEvenOddBtn');
// Add with other button elements
const firstNonRepeatingBtn = document.getElementById('firstNonRepeatingBtn');
const findUniqueElementsBtn = document.getElementById('findUniqueElementsBtn');
// Add with other DOM elements
const findMajorityElementBtn = document.getElementById('findMajorityElementBtn');
// Add with other DOM elements
const sortDutchNationalFlagBtn = document.getElementById('sortDutchNationalFlagBtn');
// Add with other DOM elements
const shiftDeleteIndex = document.getElementById('shiftDeleteIndex');
const shiftLeftAfterDeleteBtn = document.getElementById('shiftLeftAfterDeleteBtn');
// Add with other DOM elements
const findPivotBtn = document.getElementById('findPivotBtn');
// Add with other DOM elements
const rotatedSearchElement = document.getElementById('rotatedSearchElement');
const rotatedSearchBtn = document.getElementById('rotatedSearchBtn');
// Add with other DOM elements
// Add with other DOM elements
const apFirstTerm = document.getElementById('apFirstTerm');
const apCommonDiff = document.getElementById('apCommonDiff');
const apNumTerms = document.getElementById('apNumTerms');
const gpFirstTerm = document.getElementById('gpFirstTerm');
const gpCommonRatio = document.getElementById('gpCommonRatio');
const gpNumTerms = document.getElementById('gpNumTerms');
const createAPBtn = document.getElementById('createAPBtn');
const createGPBtn = document.getElementById('createGPBtn');
// Add these DOM elements with other elements
const kthElementInput = document.getElementById('kthElementInput');
const kthSmallestBtn = document.getElementById('kthSmallestBtn');
const kthLargestBtn = document.getElementById('kthLargestBtn');
// Add these DOM elements with other elements
const selectionSortBtn = document.getElementById('selectionSortBtn');
const insertionSortBtn = document.getElementById('insertionSortBtn');
// Add with other DOM elements
const cyclicShiftLeftBtn = document.getElementById('cyclicShiftLeftBtn');
const cyclicShiftRightBtn = document.getElementById('cyclicShiftRightBtn');
const cyclicShiftInputGroup = document.getElementById('cyclicShiftInputGroup');
const cyclicShiftPositionsInput = document.getElementById('cyclicShiftPositions');
const confirmCyclicShiftBtn = document.getElementById('confirmCyclicShiftBtn');
const cancelCyclicShiftBtn = document.getElementById('cancelCyclicShiftBtn');
// Add this with other DOM elements
const inPlaceNegationBtn = document.getElementById('inPlaceNegationBtn');
// Add these DOM elements with other elements
const findNBy3ElementsBtn = document.getElementById('findNBy3ElementsBtn');
const nextGreaterElementBtn = document.getElementById('nextGreaterElementBtn');
// Add with other event listeners
const shallowCopyBtn = document.getElementById('shallowCopyBtn');
const shallowCopyCount = document.getElementById('shallowCopyCount');
const shallowCopyInputGroup = document.getElementById('shallowCopyInputGroup');
const shallowCopyInputs = document.getElementById('shallowCopyInputs');
const confirmShallowCopyBtn = document.getElementById('confirmShallowCopyBtn');
const cancelShallowCopyBtn = document.getElementById('cancelShallowCopyBtn');
// Add with other DOM elements
const inPlaceMergeSortBtn = document.getElementById('inPlaceMergeSortBtn');
// Add with other DOM elements
const insertSortedBtn = document.getElementById('insertSortedBtn');
const insertSortedGroup = document.getElementById('insertSortedGroup');
const insertSortedCountInput = document.getElementById('insertSortedCount');
const confirmInsertSortedCountBtn = document.getElementById('confirmInsertSortedCountBtn');
const insertSortedInputs = document.getElementById('insertSortedInputs');
const performInsertSortedBtn = document.getElementById('performInsertSortedBtn');
const cancelInsertSortedBtn = document.getElementById('cancelInsertSortedBtn');
// Add with other DOM elements
const randomArraySize = document.getElementById('randomArraySize');
const generateRandomArrayBtn = document.getElementById('generateRandomArrayBtn');
// DOM Elements
const customComparatorSortBtn = document.getElementById('customComparatorSortBtn');
const customComparatorContainer = document.getElementById('customComparatorContainer');
const dictionaryName = document.getElementById('dictionaryName');
const createDictionaryBtn = document.getElementById('createDictionaryBtn');
const dictionaryStructureSection = document.getElementById('dictionaryStructureSection');
const fieldCount = document.getElementById('fieldCount');
const confirmFieldCountBtn = document.getElementById('confirmFieldCountBtn');
const fieldDefinitions = document.getElementById('fieldDefinitions');
const dataEntrySection = document.getElementById('dataEntrySection');
const dataEntryForm = document.getElementById('dataEntryForm');
const addRecordBtn = document.getElementById('addRecordBtn');
const finishDataEntryBtn = document.getElementById('finishDataEntryBtn');
const dictionaryOperationsSection = document.getElementById('dictionaryOperationsSection');
const updateDictionaryBtn = document.getElementById('updateDictionaryBtn');
const dropDictionaryBtn = document.getElementById('dropDictionaryBtn');
const sortFieldSelect = document.getElementById('sortFieldSelect');
const sortOrderSelect = document.getElementById('sortOrderSelect');
const performSortBtn = document.getElementById('performSortBtn');
const dictionaryDisplaySection = document.getElementById('dictionaryDisplaySection');
const dictionaryTableContainer = document.getElementById('dictionaryTableContainer');
const dictionaryTableHeader = document.getElementById('dictionaryTableHeader');
const dictionaryTableBody = document.getElementById('dictionaryTableBody');
const sortVisualizationSection = document.getElementById('sortVisualizationSection');
const sortAlgorithmExplanation = document.getElementById('sortAlgorithmExplanation');
const sortExplanationText = document.getElementById('sortExplanationText');
const sortStepsContainer = document.getElementById('sortStepsContainer');
const resetAfterSortBtn = document.getElementById('resetAfterSortBtn');
const cancelCustomSortBtn = document.getElementById('cancelCustomSortBtn');
// Add with other event listeners
const sortEvenBeforeOddBtn = document.getElementById('sortEvenBeforeOddBtn');
const sortByAbsoluteValueBtn = document.getElementById('sortByAbsoluteValueBtn');
// Add with other DOM elements
const popFirstBtn = document.getElementById('popFirstBtn');
const shiftRightInsertBtn = document.getElementById('shiftRightInsertBtn');
const shiftRightInsertGroup = document.getElementById('shiftRightInsertGroup');
const insertShiftIndex = document.getElementById('insertShiftIndex');
const insertShiftValue = document.getElementById('insertShiftValue');
const confirmShiftInsertBtn = document.getElementById('confirmShiftInsertBtn');
const cancelShiftInsertBtn = document.getElementById('cancelShiftInsertBtn');
// Add with other DOM elements
const tripletSumInput = document.getElementById('tripletSumInput');
const quadrupletSumInput = document.getElementById('quadrupletSumInput');
const findTripletsBtn = document.getElementById('findTripletsBtn');
const findQuadrupletsBtn = document.getElementById('findQuadrupletsBtn');
// Add with other DOM elements
const equilibriumPointBtn = document.getElementById('equilibriumPointBtn');
// Add with other DOM elements
const containerWithMostWaterBtn = document.getElementById('containerWithMostWaterBtn');
const trappingRainWaterBtn = document.getElementById('trappingRainWaterBtn');
// Add with other DOM elements
const twoSumBtn = document.getElementById('twoSumBtn');
const twoSumInputGroup = document.getElementById('twoSumInputGroup');
const twoSumTargetInput = document.getElementById('twoSumTarget');
const confirmTwoSumBtn = document.getElementById('confirmTwoSumBtn');
const cancelTwoSumBtn = document.getElementById('cancelTwoSumBtn');
// Add with other DOM elements
const findGcdBtn = document.getElementById('findGcdBtn');
const findLcmBtn = document.getElementById('findLcmBtn');
// Add with other DOM elements
const primeSieveBtn = document.getElementById('primeSieveBtn');
// Add with other DOM elements
const substringInput = document.getElementById('substringInput');
const findLongestSubstringBtn = document.getElementById('findLongestSubstringBtn');
const longestSubstringResults = document.getElementById('longestSubstringResults');
const longestSubstringLength = document.getElementById('longestSubstringLength');
const longestSubstringValue = document.getElementById('longestSubstringValue');
const longestSubstringSteps = document.getElementById('longestSubstringSteps');
// Add with other DOM elements
const subarrayProductK = document.getElementById('subarrayProductK');
const subarrayProductBtn = document.getElementById('subarrayProductBtn');
// Add with other DOM elements
const leaderInArrayBtn = document.getElementById('leaderInArrayBtn');
// Add with other DOM elements
const jumpGameBtn = document.getElementById('jumpGameBtn');
// Add with other DOM elements
const bestTimeStockBtn = document.getElementById('bestTimeStockBtn');
// Add with other DOM elements
const findSubarrayNearZeroBtn = document.getElementById('findSubarrayNearZeroBtn');
// Add with other DOM elements
const minWindowSubstringBtn = document.getElementById('minWindowSubstringBtn');
const minWindowGroup = document.getElementById('minWindowGroup');
const mainStringInput = document.getElementById('mainStringInput');
const targetStringInput = document.getElementById('targetStringInput');
const performMinWindowBtn = document.getElementById('performMinWindowBtn');
const cancelMinWindowBtn = document.getElementById('cancelMinWindowBtn');
// Add with other DOM elements
const kConsecutiveSize = document.getElementById('kConsecutiveSize');
const maxKConsecutiveBtn = document.getElementById('maxKConsecutiveBtn');
const minKConsecutiveBtn = document.getElementById('minKConsecutiveBtn');
// Add with other DOM elements
const rearrangeMinMaxBtn = document.getElementById('rearrangeMinMaxBtn');
// Add with other DOM elements
const nextPermutationBtn = document.getElementById('nextPermutationBtn');
// Add with other DOM elements
const longestConsecutiveSequenceBtn = document.getElementById('longestConsecutiveSequenceBtn');
const maxConsecutiveOnesBtn = document.getElementById('maxConsecutiveOnesBtn');
// Add with other DOM elements
const mergeIntervalsBtn = document.getElementById('mergeIntervalsBtn');
// Add with other DOM elements
const setOperationsGroup = document.getElementById('setOperationsGroup');
const numArrays = document.getElementById('numArrays');
const confirmNumArraysBtn = document.getElementById('confirmNumArraysBtn');
const setArraysInputs = document.getElementById('setArraysInputs');
const performSetOperationBtn = document.getElementById('performSetOperationBtn');
const cancelSetOperationBtn = document.getElementById('cancelSetOperationBtn');
const unionArraysBtn = document.getElementById('unionArraysBtn');
const intersectionArraysBtn = document.getElementById('intersectionArraysBtn');
// Add with other DOM elements
const setDifferenceBtn = document.getElementById('setDifferenceBtn');
const symmetricDifferenceBtn = document.getElementById('symmetricDifferenceBtn');
// Add with other DOM elements for subset/superset
const checkSubsetBtn = document.getElementById('checkSubsetBtn');
const checkSupersetBtn = document.getElementById('checkSupersetBtn');
const subsetSupersetGroup = document.getElementById('subsetSupersetGroup');
const subsetSupersetTitle = document.getElementById('subsetSupersetTitle');
const numArraysCompInput = document.getElementById('numArraysComp');
const confirmNumArraysCompBtn = document.getElementById('confirmNumArraysBtn'); // Renamed
const arraySizeInputsComp = document.getElementById('arraySizeInputsComp');
const arrayElementsInputsComp = document.getElementById('arrayElementsInputsComp');
const performSubsetSupersetBtn = document.getElementById('performSubsetSupersetBtn');
const cancelSubsetSupersetBtn = document.getElementById('cancelSubsetSupersetBtn');
// Add these with other DOM elements
const checkSubsetCompBtn = document.getElementById('checkSubsetCompBtn');
const checkSupersetCompBtn = document.getElementById('checkSupersetCompBtn');
const subsetCompInputGroup = document.getElementById('subsetCompInputGroup');
const supersetCompInputGroup = document.getElementById('supersetCompInputGroup');
const numArraysSubsetComp = document.getElementById('numArraysSubsetComp');
const numArraysSupersetComp = document.getElementById('numArraysSupersetComp');
const confirmNumArraysSubsetCompBtn = document.getElementById('confirmNumArraysSubsetCompBtn');
const confirmNumArraysSupersetCompBtn = document.getElementById('confirmNumArraysSupersetCompBtn');
const subsetCompArraysInputs = document.getElementById('subsetCompArraysInputs');
const supersetCompArraysInputs = document.getElementById('supersetCompArraysInputs');
const performSubsetCompBtn = document.getElementById('performSubsetCompBtn');
const performSupersetCompBtn = document.getElementById('performSupersetCompBtn');
const cancelSubsetCompBtn = document.getElementById('cancelSubsetCompBtn');
const cancelSupersetCompBtn = document.getElementById('cancelSupersetCompBtn');
// Add with other DOM elements
const memoryAddress = document.getElementById('memoryAddress');
// Add with other DOM elements
const comparisonValue = document.getElementById('comparisonValue');
const comparisonValueLess = document.getElementById('comparisonValueLess');
const findFirstGreaterBtn = document.getElementById('findFirstGreaterBtn');
const findLastLessBtn = document.getElementById('findLastLessBtn');
// Add with other DOM elements
const findCovarianceBtn = document.getElementById('findCovarianceBtn');
const findCorrelationBtn = document.getElementById('findCorrelationBtn');
const covarianceCorrelationGroup = document.getElementById('covarianceCorrelationGroup');
const arrayCountInput = document.getElementById('arrayCountInput');
const confirmArrayCountBtn = document.getElementById('confirmArrayCountBtn');
const arrayDetailsContainer = document.getElementById('arrayDetailsContainer');
const performStatisticalOperationBtn = document.getElementById('performStatisticalOperationBtn');
const cancelStatisticalOperationBtn = document.getElementById('cancelStatisticalOperationBtn');
const operationTitle = document.getElementById('operationTitle');
// Add with other DOM elements
const elementWiseMaxBtn = document.getElementById('elementWiseMaxBtn');
const elementWiseMinBtn = document.getElementById('elementWiseMinBtn');
const elementWiseGroup = document.getElementById('elementWiseGroup');
const firstArraySizeElementWise = document.getElementById('firstArraySizeElementWise');
const secondArraySizeElementWise = document.getElementById('secondArraySizeElementWise');
const confirmFirstArraySizeElementWiseBtn = document.getElementById('confirmFirstArraySizeElementWiseBtn');
const confirmSecondArraySizeElementWiseBtn = document.getElementById('confirmSecondArraySizeElementWiseBtn');
const firstArrayInputsElementWise = document.getElementById('firstArrayInputsElementWise');
const secondArrayInputsElementWise = document.getElementById('secondArrayInputsElementWise');
const performElementWiseBtn = document.getElementById('performElementWiseBtn');
const cancelElementWiseBtn = document.getElementById('cancelElementWiseBtn');
// Add with other DOM elements
const logicalAndBtn = document.getElementById('logicalAndBtn');
const logicalOrBtn = document.getElementById('logicalOrBtn');
const logicalOperationsGroup = document.getElementById('logicalOperationsGroup');
const logicalArraysCountInput = document.getElementById('logicalArraysCount');
const confirmArraysCountBtn = document.getElementById('confirmArraysCountBtn');
const arraysSizeInputs = document.getElementById('arraysSizeInputs');
const arraysElementsInputs = document.getElementById('arraysElementsInputs');
const performLogicalOperationBtn = document.getElementById('performLogicalOperationBtn');
const cancelLogicalOperationBtn = document.getElementById('cancelLogicalOperationBtn');
// Add with other DOM elements
const calculateStdDevBtn = document.getElementById('calculateStdDevBtn');
const calculateVarianceBtn = document.getElementById('calculateVarianceBtn');
// Add with other DOM elements
const scalarValue = document.getElementById('scalarValue');
const scalarValueSubtract = document.getElementById('scalarValueSubtract');
const scalarValueMultiply = document.getElementById('scalarValueMultiply');
const scalarValueDivide = document.getElementById('scalarValueDivide');
const addScalarBtn = document.getElementById('addScalarBtn');
const subtractScalarBtn = document.getElementById('subtractScalarBtn');
const multiplyScalarBtn = document.getElementById('multiplyScalarBtn');
const divideScalarBtn = document.getElementById('divideScalarBtn');
// Add with other button elements
const calcSinBtn = document.getElementById('calcSinBtn');
const calcCosBtn = document.getElementById('calcCosBtn');
const calcTanBtn = document.getElementById('calcTanBtn');
// Add with other DOM elements
const modeElements = document.getElementById('modeElements');
// Add with other DOM elements
const findRangeBtn = document.getElementById('findRangeBtn');
// Add with other button elements
const calculateExponentialBtn = document.getElementById('calculateExponentialBtn');
const calculateNaturalLogBtn = document.getElementById('calculateNaturalLogBtn');
const calculateLog10Btn = document.getElementById('calculateLog10Btn');
// Add with other DOM elements
const stockSpanBtn = document.getElementById('stockSpanBtn');
// Add with other DOM elements
const maxPairAndOrBtn = document.getElementById('maxPairAndOrBtn');
// Add with other DOM elements
const largestRectangleHistogramBtn = document.getElementById('largestRectangleHistogramBtn');
// Add with other DOM elements
const fruitIntoBasketsBtn = document.getElementById('fruitIntoBasketsBtn');
// Add with other DOM elements
const addArraysElementWiseBtn = document.getElementById('addArraysElementWiseBtn');
const subtractArraysElementWiseBtn = document.getElementById('subtractArraysElementWiseBtn');
const multiplyArraysElementWiseBtn = document.getElementById('multiplyArraysElementWiseBtn');
const divideArraysElementWiseBtn = document.getElementById('divideArraysElementWiseBtn');
const modulusArraysElementWiseBtn = document.getElementById('modulusArraysElementWiseBtn');
const elementWiseOperationGroup = document.getElementById('elementWiseOperationGroup');
const elementWiseFirstArraySizeInput = document.getElementById('elementWiseFirstArraySize');
const elementWiseSecondArraySizeInput = document.getElementById('elementWiseSecondArraySize');
const confirmElementWiseFirstArraySizeBtn = document.getElementById('confirmElementWiseFirstArraySizeBtn');
const confirmElementWiseSecondArraySizeBtn = document.getElementById('confirmElementWiseSecondArraySizeBtn');
const elementWiseFirstArrayInputs = document.getElementById('elementWiseFirstArrayInputs');
const elementWiseSecondArrayInputs = document.getElementById('elementWiseSecondArrayInputs');
const performElementWiseOperationBtn = document.getElementById('performElementWiseOperationBtn');
const cancelElementWiseOperationBtn = document.getElementById('cancelElementWiseOperationBtn');
// Add with other DOM elements
const logicalNotBtn = document.getElementById('logicalNotBtn');
const logicalXorBtn = document.getElementById('logicalXorBtn');
const logicalNotGroup = document.getElementById('logicalNotGroup');
const logicalXorGroup = document.getElementById('logicalXorGroup');
const logicalNotSize = document.getElementById('logicalNotSize');
const confirmLogicalNotSizeBtn = document.getElementById('confirmLogicalNotSizeBtn');
const logicalNotInputs = document.getElementById('logicalNotInputs');
const cancelLogicalNotBtn = document.getElementById('cancelLogicalNotBtn');
const logicalXorArrayCount = document.getElementById('logicalXorArrayCount');
const confirmLogicalXorArrayCountBtn = document.getElementById('confirmLogicalXorArrayCountBtn');
const logicalXorSizeInputs = document.getElementById('logicalXorSizeInputs');
const logicalXorElementInputs = document.getElementById('logicalXorElementInputs');
const cancelLogicalXorBtn = document.getElementById('cancelLogicalXorBtn');
// Add with other DOM elements
const transformNonDecreasingBtn = document.getElementById('transformNonDecreasingBtn');
// Add with other DOM elements - USING UNIQUE NAMES
const minFlipsOrBtn = document.getElementById('minFlipsOrBtn');
const minFlipsAndBtn = document.getElementById('minFlipsAndBtn');
const minFlipsInputGroup = document.getElementById('minFlipsInputGroup');
const minFlipsTitle = document.getElementById('minFlipsTitle');
const numArraysInputField = document.getElementById('numArraysInput'); // Changed from numArraysInput
const confirmNumArraysButton = document.getElementById('confirmNumArraysBtn'); // Changed from confirmNumArraysBtn
const arraySizeInputsContainer = document.getElementById('arraySizeInputs'); // Changed from arraySizeInputs
const arrayElementsInputsContainer = document.getElementById('arrayElementsInputs'); // Changed from arrayElementsInputs
const performMinFlipsOperationBtn = document.getElementById('performMinFlipsBtn'); // Changed from performMinFlipsBtn
const cancelMinFlipsOperationBtn = document.getElementById('cancelMinFlipsBtn'); // Changed from cancelMinFlipsBtn
// Add with other DOM elements
const findMaxAbsDiffBtn = document.getElementById('findMaxAbsDiffBtn');
// Add with other DOM elements
const maxCircularSubarrayBtn = document.getElementById('maxCircularSubarrayBtn');
// Add with other DOM elements
const wiggleSortIIBtn = document.getElementById('wiggleSortIIBtn');
// Add with other DOM elements
const maxDistanceSameElementsBtn = document.getElementById('maxDistanceSameElementsBtn');
// Add with other DOM elements
const pairDifferenceK = document.getElementById('pairDifferenceK');
const countPairsWithDifferenceBtn = document.getElementById('countPairsWithDifferenceBtn');
// Add with other DOM elements
const minSwapsK = document.getElementById('minSwapsK');
const minSwapsBtn = document.getElementById('minSwapsBtn');
// Add with other DOM elements
const missingRepeatingMethod = document.getElementById('missingRepeatingMethod');
const findMissingRepeatingBtn = document.getElementById('findMissingRepeatingBtn');
// Add with other DOM elements
const findFirstRepeatingBtn = document.getElementById('findFirstRepeatingBtn');
// Add with other DOM elements
const conditionalWhereBtn = document.getElementById('conditionalWhereBtn');
const multiConditionSelectBtn = document.getElementById('multiConditionSelectBtn');
const piecewiseEvaluateBtn = document.getElementById('piecewiseEvaluateBtn');
const conditionalOperationsGroup = document.getElementById('conditionalOperationsGroup');
const arraySizesGroup = document.getElementById('arraySizesGroup');
const arrayElementsGroup = document.getElementById('arrayElementsGroup');
const conditionGroup = document.getElementById('conditionGroup');
const arraySize1 = document.getElementById('arraySize1');
const arraySize2 = document.getElementById('arraySize2');
const confirmArraySizesBtn = document.getElementById('confirmArraySizesBtn');
const array1Inputs = document.getElementById('array1Inputs');
const array2Inputs = document.getElementById('array2Inputs');
const conditionOperator = document.getElementById('conditionOperator');
const conditionValue = document.getElementById('conditionValue');
const confirmConditionBtn = document.getElementById('confirmConditionBtn');
const cancelConditionalBtn = document.getElementById('cancelConditionalBtn');
// Add these with other DOM elements
const previousGreaterBtn = document.getElementById('previousGreaterBtn');
const previousSmallerBtn = document.getElementById('previousSmallerBtn');
// Add with other DOM elements
const predicateCondition = document.getElementById('predicateCondition');
const findByPredicateBtn = document.getElementById('findByPredicateBtn');
// Add with other DOM elements
const convertTo2DBtn = document.getElementById('convertTo2DBtn');
// Add with other DOM elements
const getDataTypeBtn = document.getElementById('getDataTypeBtn');
const createTypedArrayBtn = document.getElementById('createTypedArrayBtn');
const convertToListBtn = document.getElementById('convertToListBtn');
const dataTypeInputGroup = document.getElementById('dataTypeInputGroup');
const typedArraySize = document.getElementById('typedArraySize');
const dataTypeSelect = document.getElementById('dataTypeSelect');
const confirmDataTypeBtn = document.getElementById('confirmDataTypeBtn');
const cancelDataTypeBtn = document.getElementById('cancelDataTypeBtn');
// Add with other DOM elements
const shuffleElementsBtn = document.getElementById('shuffleElementsBtn');
// Add with other DOM elements
const binCount = document.getElementById('binCount');
const binWidth = document.getElementById('binWidth');
const binIntervalsBtn = document.getElementById('binIntervalsBtn');
const binByWidthBtn = document.getElementById('binByWidthBtn');
// Add with other DOM elements
const ufuncSelect = document.getElementById('ufuncSelect');
const applyUfuncBtn = document.getElementById('applyUfuncBtn');
const ufuncParams = document.getElementById('ufuncParams');
const clampLow = document.getElementById('clampLow');
const clampHigh = document.getElementById('clampHigh');
const euclidRef = document.getElementById('euclidRef');
const bitwiseOperand = document.getElementById('bitwiseOperand');
const leakyReluAlpha = document.getElementById('leakyReluAlpha');
// Stock Market Operations DOM Elements
const stockPricesInput = document.getElementById('stockPricesInput');
const loadStockPricesBtn = document.getElementById('loadStockPricesBtn');
const dailyReturnsBtn = document.getElementById('dailyReturnsBtn');
const logReturnsBtn = document.getElementById('logReturnsBtn');
const cumulativeReturnsBtn = document.getElementById('cumulativeReturnsBtn');
const totalReturnBtn = document.getElementById('totalReturnBtn');
const priceDifferenceBtn = document.getElementById('priceDifferenceBtn');
const priceMomentumBtn = document.getElementById('priceMomentumBtn');
const rateOfChangeBtn = document.getElementById('rateOfChangeBtn');
const gapAnalysisBtn = document.getElementById('gapAnalysisBtn');
const intradayGainBtn = document.getElementById('intradayGainBtn');
// Add these with your existing stock market variables
const smaBtn = document.getElementById('smaBtn');
const emaBtn = document.getElementById('emaBtn');
const macdBtn = document.getElementById('macdBtn');
const macdSignalBtn = document.getElementById('macdSignalBtn');
const bollingerMiddleBtn = document.getElementById('bollingerMiddleBtn');
const bollingerUpperBtn = document.getElementById('bollingerUpperBtn');
// Add with other DOM elements
const axisFunctionSelect = document.getElementById('axisFunctionSelect');
const applyAxisBtn = document.getElementById('applyAxisBtn');
const customFunctionGroup = document.getElementById('customFunctionGroup');
const customFunction = document.getElementById('customFunction');
const matrixDimensionsGroup = document.getElementById('matrixDimensionsGroup');
const matrixRowsInput = document.getElementById('matrixRows');
const matrixColsInput = document.getElementById('matrixCols');
const createMatrixBtn = document.getElementById('createMatrixBtn');
// Add with other DOM elements
const findMinIndexBtn = document.getElementById('findMinIndexBtn');
const findMaxIndexBtn = document.getElementById('findMaxIndexBtn');
const findNSmallestBtn = document.getElementById('findNSmallestBtn');
const findNLargestBtn = document.getElementById('findNLargestBtn');
const nValueInputGroup = document.getElementById('nValueInputGroup');
const nValueInput = document.getElementById('nValueInput');
const confirmNValueBtn = document.getElementById('confirmNValueBtn');
const cancelNValueBtn = document.getElementById('cancelNValueBtn');
// Add with other DOM elements
const parenthesesInput = document.getElementById('parenthesesInput');
const validParenthesesBtn = document.getElementById('validParenthesesBtn');
// Add with other DOM elements
const checkPalindromeBtn = document.getElementById('checkPalindromeBtn');
const findAnagramsBtn = document.getElementById('findAnagramsBtn');
// Add with other DOM elements
const rangeSumStart = document.getElementById('rangeSumStart');
const rangeSumEnd = document.getElementById('rangeSumEnd');
const rangeSumQueryBtn = document.getElementById('rangeSumQueryBtn');
// Add with other DOM elements
const dailyTemperaturesBtn = document.getElementById('dailyTemperaturesBtn');
// Add with other DOM elements
const firstLastTarget = document.getElementById('firstLastTarget');
const findFirstLastBtn = document.getElementById('findFirstLastBtn');
// Add with other DOM elements
const palindromeInput = document.getElementById('palindromeInput');
const longestPalindromeInput = document.getElementById('longestPalindromeInput');
const findPalindromicSubstringsBtn = document.getElementById('findPalindromicSubstringsBtn');
const findLongestPalindromicSubstringBtn = document.getElementById('findLongestPalindromicSubstringBtn');
// Add these with other DOM elements
const wildcardMatchingBtn = document.getElementById('wildcardMatchingBtn');
const regexMatchingBtn = document.getElementById('regexMatchingBtn');
const patternMatchingGroup = document.getElementById('patternMatchingGroup');
const patternString = document.getElementById('patternString');
const patternPattern = document.getElementById('patternPattern');
const confirmPatternMatchingBtn = document.getElementById('confirmPatternMatchingBtn');
const cancelPatternMatchingBtn = document.getElementById('cancelPatternMatchingBtn');
const patternMatchingLabel = document.getElementById('patternMatchingLabel');
// Add with other DOM elements
const combinationSumBtn = document.getElementById('combinationSumBtn');
const subsetsBtn = document.getElementById('subsetsBtn');
const combinationSumGroup = document.getElementById('combinationSumGroup');
const combinationSumTarget = document.getElementById('combinationSumTarget');
const confirmCombinationSumBtn = document.getElementById('confirmCombinationSumBtn');
const cancelCombinationSumBtn = document.getElementById('cancelCombinationSumBtn');
// Add with other DOM elements
const longestValidParenthesesBtn = document.getElementById('longestValidParenthesesBtn');
const distinctSubsequencesBtn = document.getElementById('distinctSubsequencesBtn');
const parenthesesInputGroup = document.getElementById('parenthesesInputGroup');
const subsequencesInputGroup = document.getElementById('subsequencesInputGroup');
const lvpInput = document.getElementById('lvpInput');
const dsMainStringInput = document.getElementById('dsMainStringInput');
const dsTargetStringInput = document.getElementById('dsTargetStringInput');
const confirmParenthesesBtn = document.getElementById('confirmParenthesesBtn');
const cancelParenthesesBtn = document.getElementById('cancelParenthesesBtn');
const confirmSubsequencesBtn = document.getElementById('confirmSubsequencesBtn');
const cancelSubsequencesBtn = document.getElementById('cancelSubsequencesBtn');
// Add with other DOM elements
const findWordConcatenationBtn = document.getElementById('findWordConcatenationBtn');
const wordConcatInputSection = document.getElementById('wordConcatInputSection');
const textStringInputField = document.getElementById('textStringInputField');
const searchWordsInputField = document.getElementById('searchWordsInputField');
const runWordConcatSearchBtn = document.getElementById('runWordConcatSearchBtn');
const stopWordConcatSearchBtn = document.getElementById('stopWordConcatSearchBtn');
// Add with other DOM elements
const countSmallerAfterSelfBtn = document.getElementById('countSmallerAfterSelfBtn');
// Add these with other DOM elements
const uglyNumberInput = document.getElementById('uglyNumberInput');
const checkUglyNumberBtn = document.getElementById('checkUglyNumberBtn');
const nthUglyNumberInput = document.getElementById('nthUglyNumberInput');
const findNthUglyNumberBtn = document.getElementById('findNthUglyNumberBtn');
const superUglyNInput = document.getElementById('superUglyNInput');
const superUglyPrimesInput = document.getElementById('superUglyPrimesInput');
const findSuperUglyNumberBtn = document.getElementById('findSuperUglyNumberBtn');
const uglyNumberOutput = document.getElementById('uglyNumberOutput');
// Add with other DOM elements
const findPerfectNumbersBtn = document.getElementById('findPerfectNumbersBtn');
const findArmstrongNumbersBtn = document.getElementById('findArmstrongNumbersBtn');
// Add with other DOM elements
const pascalRowNumber = document.getElementById('pascalRowNumber');
const pascalNumRows = document.getElementById('pascalNumRows');
const pascalSpecificRowBtn = document.getElementById('pascalSpecificRowBtn');
const pascalMultipleRowsBtn = document.getElementById('pascalMultipleRowsBtn');
// Add with other DOM elements
const randomPickWithWeightBtn = document.getElementById('randomPickWithWeightBtn');
// Add with other DOM elements
const generateRandomPointBtn = document.getElementById('generateRandomPointBtn');
// Add with other DOM elements
const consecutiveTargetSum = document.getElementById('consecutiveTargetSum');
const findConsecutiveSequencesBtn = document.getElementById('findConsecutiveSequencesBtn');
// Add with other DOM elements
const numberInput = document.getElementById('numberInput');
const convertToEnglishBtn = document.getElementById('convertToEnglishBtn');
const findDigitOneBtn = document.getElementById('findDigitOneBtn');
// Add with other button elements
const addDigitsBtn = document.getElementById('addDigitsBtn');
const happyNumberBtn = document.getElementById('happyNumberBtn');
// Add with other DOM elements
const excelColumnNumberBtn = document.getElementById('excelColumnNumberBtn');
// Add with other DOM elements
const numberToColumnTitleBtn = document.getElementById('numberToColumnTitleBtn');
// Add these with other DOM elements
const implementStackBtn = document.getElementById('implementStackBtn');
const stackImplementationGroup = document.getElementById('stackImplementationGroup');
const stackSizeInput = document.getElementById('stackSize');
const createStackBtn = document.getElementById('createStackBtn');
const stackOperations = document.getElementById('stackOperations');
const pushValue = document.getElementById('pushValue');
const pushBtn = document.getElementById('pushBtn');
const popCount = document.getElementById('popCount');
const popBtn = document.getElementById('popBtn');
const peekBtn = document.getElementById('peekBtn');
const isFullBtn = document.getElementById('isFullBtn');
const isEmptyBtn = document.getElementById('isEmptyBtn');
const resetStackBtn = document.getElementById('resetStackBtn');
const stackInfo = document.getElementById('stackInfo');
const stackExplanation = document.getElementById('stackExplanation');
const stackSizeValue = document.getElementById('stackSizeValue');
const stackTopValue = document.getElementById('stackTopValue');
const stackStatus = document.getElementById('stackStatus');
// Add with other event listeners
const browserHistoryBtn = document.getElementById('browserHistoryBtn');
// Add with other DOM elements
const designOrderedStreamBtn = document.getElementById('designOrderedStreamBtn');
const orderedStreamGroup = document.getElementById('orderedStreamGroup');
const streamSize = document.getElementById('streamSize');
const streamIndex = document.getElementById('streamIndex');
const streamValue = document.getElementById('streamValue');
const insertIntoStreamBtn = document.getElementById('insertIntoStreamBtn');
const resetStreamBtn = document.getElementById('resetStreamBtn');
const currentPointer = document.getElementById('currentPointer');
const lastChunk = document.getElementById('lastChunk');
// Add with other DOM elements
const rleEncodeBtn = document.getElementById('rleEncodeBtn');
const rleDecodeBtn = document.getElementById('rleDecodeBtn');
// Add with other DOM elements
const deltaEncodingBtn = document.getElementById('deltaEncodingBtn');
const bwtTransformBtn = document.getElementById('bwtTransformBtn');
const mtfTransformBtn = document.getElementById('mtfTransformBtn');
const deltaEncodingGroup = document.getElementById('deltaEncodingGroup');
const bwtGroup = document.getElementById('bwtGroup');
const mtfGroup = document.getElementById('mtfGroup');
const deltaArraySizeInput = document.getElementById('deltaArraySize');
const confirmDeltaSizeBtn = document.getElementById('confirmDeltaSizeBtn');
const deltaArrayInputs = document.getElementById('deltaArrayInputs');
const performDeltaEncodingBtn = document.getElementById('performDeltaEncodingBtn');
const cancelDeltaBtn = document.getElementById('cancelDeltaBtn');
const bwtString = document.getElementById('bwtString');
const bwtSentinel = document.getElementById('bwtSentinel');
const performBWTBtn = document.getElementById('performBWTBtn');
const cancelBWTBtn = document.getElementById('cancelBWTBtn');
const mtfString = document.getElementById('mtfString');
const performMTFBtn = document.getElementById('performMTFBtn');
const cancelMTFBtn = document.getElementById('cancelMTFBtn');
// Add with other DOM elements
const countAndSayBtn = document.getElementById('countAndSayBtn');
const stringCompressionBtn = document.getElementById('stringCompressionBtn');
const countAndSayGroup = document.getElementById('countAndSayGroup');
const stringCompressionGroup = document.getElementById('stringCompressionGroup');
const countAndSayTerms = document.getElementById('countAndSayTerms');
const stringToCompress = document.getElementById('stringToCompress');
const confirmCountAndSayBtn = document.getElementById('confirmCountAndSayBtn');
const confirmStringCompressionBtn = document.getElementById('confirmStringCompressionBtn');
const cancelCountAndSayBtn = document.getElementById('cancelCountAndSayBtn');
const cancelStringCompressionBtn = document.getElementById('cancelStringCompressionBtn');
// Add with other DOM elements
const stringsInput = document.getElementById('stringsInput');
const delimiterInput = document.getElementById('delimiterInput');
const encodeDecodeBtn = document.getElementById('encodeDecodeBtn');
const logCountInput = document.getElementById('logCount');
const setLogCountBtn = document.getElementById('setLogCountBtn');
const logInputs = document.getElementById('logInputs');
const reorderLogsBtn = document.getElementById('reorderLogsBtn');
// Pattern Search DOM Elements
const rabinKarpBtn = document.getElementById('rabinKarpBtn');
const zAlgorithmBtn = document.getElementById('zAlgorithmBtn');
const patternSearchGroup = document.getElementById('patternSearchGroup');
const patternAlgorithmTitle = document.getElementById('patternAlgorithmTitle');
const searchTextInput = document.getElementById('searchTextInput');
const searchPatternInput = document.getElementById('searchPatternInput');
const startPatternSearchBtn = document.getElementById('startPatternSearchBtn');
const cancelPatternSearchBtn = document.getElementById('cancelPatternSearchBtn');
// Add with other event listeners
const wordAbbrValidationBtn = document.getElementById('wordAbbrValidationBtn');
// Add Enter key support
const wordInput = document.getElementById('wordInput');
const abbrInput = document.getElementById('abbrInput');
// Add with other DOM elements
const shortestWordDistanceBtn = document.getElementById('shortestWordDistanceBtn');
const shortestWordDistanceGroup = document.getElementById('shortestWordDistanceGroup');
const wordArraySize = document.getElementById('wordArraySize');
const confirmWordArraySizeBtn = document.getElementById('confirmWordArraySizeBtn');
const wordArrayInputs = document.getElementById('wordArrayInputs');
const wordSearchInputs = document.getElementById('wordSearchInputs');
const word1Input = document.getElementById('word1Input');
const word2Input = document.getElementById('word2Input');
const findShortestDistanceBtn = document.getElementById('findShortestDistanceBtn');
const cancelShortestWordDistanceBtn = document.getElementById('cancelShortestWordDistanceBtn');
// Add with other DOM elements
const groupShiftedStringsBtn = document.getElementById('groupShiftedStringsBtn');
const flipGameBtn = document.getElementById('flipGameBtn');
const groupShiftedStringsGroup = document.getElementById('groupShiftedStringsGroup');
const flipGameGroup = document.getElementById('flipGameGroup');
const shiftedStringsSize = document.getElementById('shiftedStringsSize');
const confirmShiftedStringsSizeBtn = document.getElementById('confirmShiftedStringsSizeBtn');
const shiftedStringsInputs = document.getElementById('shiftedStringsInputs');
const performGroupShiftedStringsBtn = document.getElementById('performGroupShiftedStringsBtn');
const cancelGroupShiftedStringsBtn = document.getElementById('cancelGroupShiftedStringsBtn');
const flipGameInput = document.getElementById('flipGameInput');
const performFlipGameBtn = document.getElementById('performFlipGameBtn');
const cancelFlipGameBtn = document.getElementById('cancelFlipGameBtn');
// Add with other event listeners
const nimGameBtn = document.getElementById('nimGameBtn');
const nimGameGroup = document.getElementById('nimGameGroup');
const nimArraySizeInput = document.getElementById('nimArraySize');
const confirmNimSizeBtn = document.getElementById('confirmNimSizeBtn');
const nimPilesInputs = document.getElementById('nimPilesInputs');
const playNimGameBtn = document.getElementById('playNimGameBtn');
const cancelNimGameBtn = document.getElementById('cancelNimGameBtn');
// Add with other DOM elements
const maxChoosableInteger = document.getElementById('maxChoosableInteger');
const desiredTotal = document.getElementById('desiredTotal');
const canIWinBtn = document.getElementById('canIWinBtn');
// Add with other DOM elements
const predictWinnerBtn = document.getElementById('predictWinnerBtn');
const predictWinnerGroup = document.getElementById('predictWinnerGroup');
const predictWinnerSizeInput = document.getElementById('predictWinnerSize');
const confirmPredictWinnerSizeBtn = document.getElementById('confirmPredictWinnerSizeBtn');
const predictWinnerInputs = document.getElementById('predictWinnerInputs');
const performPredictWinnerBtn = document.getElementById('performPredictWinnerBtn');
const cancelPredictWinnerBtn = document.getElementById('cancelPredictWinnerBtn');
// Add with other DOM elements
const stoneGameBtn = document.getElementById('stoneGameBtn');
const stoneGameGroup = document.getElementById('stoneGameGroup');
const totalStones = document.getElementById('totalStones');
const maxPick = document.getElementById('maxPick');
const player1Name = document.getElementById('player1Name');
const player2Name = document.getElementById('player2Name');
const startStoneGameBtn = document.getElementById('startStoneGameBtn');
const cancelStoneGameBtn = document.getElementById('cancelStoneGameBtn');
// Add with other DOM elements
const gasStationBtn = document.getElementById('gasStationBtn');
const gasStationGroup = document.getElementById('gasStationGroup');
const gasStationCount = document.getElementById('gasStationCount');
const confirmGasStationCountBtn = document.getElementById('confirmGasStationCountBtn');
const gasStationInputs = document.getElementById('gasStationInputs');
const solveGasStationBtn = document.getElementById('solveGasStationBtn');
const cancelGasStationBtn = document.getElementById('cancelGasStationBtn');
// Add with other DOM elements
const candyDistributeBtn = document.getElementById('candyDistributeBtn');
const candyInputGroup = document.getElementById('candyInputGroup');
const candyArraySize = document.getElementById('candyArraySize');
const confirmCandySizeBtn = document.getElementById('confirmCandySizeBtn');
const candyArrayInputs = document.getElementById('candyArrayInputs');
const performCandyDistributionBtn = document.getElementById('performCandyDistributionBtn');
const cancelCandyBtn = document.getElementById('cancelCandyBtn');
// Add with other DOM elements
const partitionDisjointBtn = document.getElementById('partitionDisjointBtn');
// Add with other DOM elements
const partitionKValue = document.getElementById('partitionKValue');
const partitionArrayBtn = document.getElementById('partitionArrayBtn');
// Add with other DOM elements
const partitionLabelsStringInput = document.getElementById('partitionLabelsStringInput');
const partitionLabelsOperationBtn = document.getElementById('partitionLabelsOperationBtn');
// Add with other DOM elements
const splitArrayK = document.getElementById('splitArrayK');
const splitArrayLargestSumBtn = document.getElementById('splitArrayLargestSumBtn');
// Add with other DOM elements
const splitEqualSumBtn = document.getElementById('splitEqualSumBtn');
// Add with other DOM elements
const niceSubarrayK = document.getElementById('niceSubarrayK');
const countNiceSubarraysBtn = document.getElementById('countNiceSubarraysBtn');
// Add with other DOM elements
const kDifferentIntegers = document.getElementById('kDifferentIntegers');
const kDifferentIntegersBtn = document.getElementById('kDifferentIntegersBtn');
// Add with other DOM elements
const threeCharsSubstringsBtn = document.getElementById('threeCharsSubstringsBtn');
const threeCharsInputGroup = document.getElementById('threeCharsInputGroup');
const threeCharsInput = document.getElementById('threeCharsInput');
const confirmThreeCharsBtn = document.getElementById('confirmThreeCharsBtn');
const cancelThreeCharsBtn = document.getElementById('cancelThreeCharsBtn');
// Add with other DOM elements
const longestTurbulentSubarrayBtn = document.getElementById('longestTurbulentSubarrayBtn');
// Add with other DOM elements
const reversePairsBtn = document.getElementById('reversePairsBtn');
// Add with other DOM elements
const inversionsAnalysisBtn = document.getElementById('inversionsAnalysisBtn');
// Add with other DOM elements
const summaryRangesBtn = document.getElementById('summaryRangesBtn');
const findRightIntervalBtn = document.getElementById('findRightIntervalBtn');
// Add with other DOM elements
const minArrowsBtn = document.getElementById('minArrowsBtn');
// Add with other DOM elements
const teemoAttackingBtn = document.getElementById('teemoAttackingBtn');
// Add with other DOM elements
const buildingsOceanViewBtn = document.getElementById('buildingsOceanViewBtn');
const createTargetArrayBtn = document.getElementById('createTargetArrayBtn');
const buildingsOceanViewGroup = document.getElementById('buildingsOceanViewGroup');
const createTargetArrayGroup = document.getElementById('createTargetArrayGroup');
const buildingHeights = document.getElementById('buildingHeights');
const confirmBuildingHeightsBtn = document.getElementById('confirmBuildingHeightsBtn');
const targetArrayValuesInput = document.getElementById('targetArrayValues');
const targetArrayIndicesInput = document.getElementById('targetArrayIndices');
const confirmTargetValuesBtn = document.getElementById('confirmTargetValuesBtn');
const confirmTargetIndicesBtn = document.getElementById('confirmTargetIndicesBtn');
const performTargetArrayBtn = document.getElementById('performTargetArrayBtn');
const cancelTargetArrayBtn = document.getElementById('cancelTargetArrayBtn');
// Add these with other DOM elements
const queueReconstructionBtn = document.getElementById('queueReconstructionBtn');
const queueReconstructionGroup = document.getElementById('queueReconstructionGroup');
const queueSizeInput = document.getElementById('queueSize'); // Renamed from queueSize
const confirmQueueSizeBtn = document.getElementById('confirmQueueSizeBtn');
const queueInputs = document.getElementById('queueInputs');
const performQueueReconstructionBtn = document.getElementById('performQueueReconstructionBtn');
const cancelQueueReconstructionBtn = document.getElementById('cancelQueueReconstructionBtn');
// Add with other DOM elements
const singleNumberIIBtn = document.getElementById('singleNumberIIBtn');
const singleNumberIIIBtn = document.getElementById('singleNumberIIIBtn');
// NEW: DOM elements for string operations
const maxProductBtn = document.getElementById('maxProductBtn');
const countConsistentBtn = document.getElementById('countConsistentBtn');
const stringOperationGroup = document.getElementById('stringOperationGroup');
const stringOperationTitle = document.getElementById('stringOperationTitle');
const stringArraySizeInput = document.getElementById('stringArraySize');
const confirmStringArraySizeBtn = document.getElementById('confirmStringArraySizeBtn');
const stringArrayInputs = document.getElementById('stringArrayInputs');
const performStringOperationBtn = document.getElementById('performStringOperationBtn');
const cancelStringOperationBtn = document.getElementById('cancelStringOperationBtn');
// Add with other button elements
const subarrayBitwiseORsBtn = document.getElementById('subarrayBitwiseORsBtn');
const bitwiseAndRangeBtn = document.getElementById('bitwiseAndRangeBtn');
// Add with other DOM elements
const hammingWeightBtn = document.getElementById('hammingWeightBtn');
const hammingDistanceBtn = document.getElementById('hammingDistanceBtn');
const hammingOperationsGroup = document.getElementById('hammingOperationsGroup');
const hammingOperationLabel = document.getElementById('hammingOperationLabel');
const hammingArraySize = document.getElementById('hammingArraySize');
const confirmHammingArraySizeBtn = document.getElementById('confirmHammingArraySizeBtn');
const hammingArrayInputs = document.getElementById('hammingArrayInputs');
const performHammingOperationBtn = document.getElementById('performHammingOperationBtn');
const cancelHammingOperationBtn = document.getElementById('cancelHammingOperationBtn');
// Add with other DOM elements
const superstringCount = document.getElementById('superstringCount');
const shortestSuperstringBtn = document.getElementById('shortestSuperstringBtn');
const superstringInputGroup = document.getElementById('superstringInputGroup');
const superstringInputs = document.getElementById('superstringInputs');
const performSuperstringBtn = document.getElementById('performSuperstringBtn');
const cancelSuperstringBtn = document.getElementById('cancelSuperstringBtn');
// Add with other DOM elements
const grayCodeBtn = document.getElementById('grayCodeBtn');
const grayCodeInputGroup = document.getElementById('grayCodeInputGroup');
const grayCodeBits = document.getElementById('grayCodeBits');
const generateGrayCodeBtn = document.getElementById('generateGrayCodeBtn');
const cancelGrayCodeBtn = document.getElementById('cancelGrayCodeBtn');
// Add with other DOM elements
const thresholdValue = document.getElementById('thresholdValue');
const findSmallestDivisorBtn = document.getElementById('findSmallestDivisorBtn');
// Add with other DOM elements
const hIndexBtn = document.getElementById('hIndexBtn');
// Add with other DOM elements
const capacityToShipBtn = document.getElementById('capacityToShipBtn');
const capacityInputGroup = document.getElementById('capacityInputGroup');
const capacityDaysInput = document.getElementById('capacityDays');
const confirmCapacityBtn = document.getElementById('confirmCapacityBtn');
const cancelCapacityBtn = document.getElementById('cancelCapacityBtn');
// Add with other DOM elements
const kokoHoursInput = document.getElementById('kokoHours');
const kokoBananasBtn = document.getElementById('kokoBananasBtn');
const kokoInputGroup = document.getElementById('kokoInputGroup');
const kokoPileCountInput = document.getElementById('kokoPileCount');
const confirmKokoPilesBtn = document.getElementById('confirmKokoPilesBtn');
const kokoPileInputs = document.getElementById('kokoPileInputs');
const startKokoAlgorithmBtn = document.getElementById('startKokoAlgorithmBtn');
const cancelKokoBtn = document.getElementById('cancelKokoBtn');
// Add with other DOM elements
const versionCount = document.getElementById('versionCount');
const firstBadVersionBtn = document.getElementById('firstBadVersionBtn');
// Add with other DOM elements
const houseRobberBtn = document.getElementById('houseRobberBtn');
const houseRobberGroup = document.getElementById('houseRobberGroup');
const houseValues = document.getElementById('houseValues');
const confirmHouseRobberBtn = document.getElementById('confirmHouseRobberBtn');
const useCurrentArrayBtn = document.getElementById('useCurrentArrayBtn');
const generateRandomHousesBtn = document.getElementById('generateRandomHousesBtn');
const cancelHouseRobberBtn = document.getElementById('cancelHouseRobberBtn');
// Add with other DOM elements
const maxSubarrayOneDeletionBtn = document.getElementById('maxSubarrayOneDeletionBtn');
// Add with other DOM elements
const maxPairChainBtn = document.getElementById('maxPairChainBtn');
const pairInputGroup = document.getElementById('pairInputGroup');
const pairCountInput = document.getElementById('pairCount');
const confirmPairCountBtn = document.getElementById('confirmPairCountBtn');
const pairsInputs = document.getElementById('pairsInputs');
const performPairChainBtn = document.getElementById('performPairChainBtn');
const cancelPairChainBtn = document.getElementById('cancelPairChainBtn');
// Add with other DOM elements
const arithmeticSlicesBtn = document.getElementById('arithmeticSlicesBtn');
// Add with other DOM elements
const uniquePathsBtn = document.getElementById('uniquePathsBtn');
const uniquePathsInputGroup = document.getElementById('uniquePathsInputGroup');
const gridRows = document.getElementById('gridRows');
const gridCols = document.getElementById('gridCols');
const confirmUniquePathsBtn = document.getElementById('confirmUniquePathsBtn');
const cancelUniquePathsBtn = document.getElementById('cancelUniquePathsBtn');
// Add with other DOM elements
const coinChangeBtn = document.getElementById('coinChangeBtn');
const coinChangeGroup = document.getElementById('coinChangeGroup');
const coinCount = document.getElementById('coinCount');
const confirmCoinCountBtn = document.getElementById('confirmCoinCountBtn');
const coinInputs = document.getElementById('coinInputs');
const targetAmountInput = document.getElementById('targetAmount');
const performCoinChangeBtn = document.getElementById('performCoinChangeBtn');
const cancelCoinChangeBtn = document.getElementById('cancelCoinChangeBtn');
// Add with other DOM elements
const decodeWaysInput = document.getElementById('decodeWaysInput');
const decodeWaysBtn = document.getElementById('decodeWaysBtn');
// Add with other DOM elements
const partitionEqualSubsetSumBtn = document.getElementById('partitionEqualSubsetSumBtn');
// Add with other DOM elements
const targetSumInput = document.getElementById('targetSumInput');
const targetSumBtn = document.getElementById('targetSumBtn');
// Add with other DOM elements
const wordBreakBtn = document.getElementById('wordBreakBtn');
const wordBreakGroup = document.getElementById('wordBreakGroup');
const wordBreakStringInput = document.getElementById('wordBreakString');
const wordDictInput = document.getElementById('wordDict');
const performWordBreakBtn = document.getElementById('performWordBreakBtn');
const cancelWordBreakBtn = document.getElementById('cancelWordBreakBtn');
// Add with other DOM elements
const maxRectangleSum = document.getElementById('maxRectangleSum');
const maxRectangleBtn = document.getElementById('maxRectangleBtn');
// Add with other DOM elements
const lruCacheBtn = document.getElementById('lruCacheBtn');
// Add with other DOM elements
const lfuCacheBtn = document.getElementById('lfuCacheBtn');
// Add with other DOM elements
const findMedianStreamBtn = document.getElementById('findMedianStreamBtn');
const slidingWindowMedianBtn = document.getElementById('slidingWindowMedianBtn');
const slidingWindowInputGroup = document.getElementById('slidingWindowInputGroup');
const slidingWindowK = document.getElementById('slidingWindowK');
const confirmSlidingWindowBtn = document.getElementById('confirmSlidingWindowBtn');
const cancelSlidingWindowBtn = document.getElementById('cancelSlidingWindowBtn');
// Add with other DOM elements
const calendarBtn = document.getElementById('calendarBtn');
const calendarGroup = document.getElementById('calendarGroup');
const numEvents = document.getElementById('numEvents');
const confirmNumEventsBtn = document.getElementById('confirmNumEventsBtn');
const calendarEventsInputs = document.getElementById('calendarEventsInputs');
const performCalendarBtn = document.getElementById('performCalendarBtn');
const cancelCalendarBtn = document.getElementById('cancelCalendarBtn');

        // Initialize
        updateStats();
        
        // Event Listeners
        createBtn.addEventListener('click', handleCreate);
        createRandomBtn.addEventListener('click', handleCreateRandom);
        insertBtn.addEventListener('click', handleInsert);
        readBtn.addEventListener('click', handleRead);
        updateBtn.addEventListener('click', handleUpdate);
        updateByElementBtn.addEventListener('click', handleUpdateByElement);
        deleteBtn.addEventListener('click', handleDelete);
        deleteByElementBtn.addEventListener('click', handleDeleteByElement);
        clearArrayBtn.addEventListener('click', handleClearArray);
        searchBtn.addEventListener('click', handleSearch);
        searchByIndexBtn.addEventListener('click', handleSearchByIndex);
        linearSearchBtn.addEventListener('click', handleLinearSearch); // NEW
        binarySearchBtn.addEventListener('click', handleBinarySearch);
        checkElementBtn.addEventListener('click', handleCheckElement);
findMinElementBtn.addEventListener('click', handleFindMinElement);
findMaxElementBtn.addEventListener('click', handleFindMaxElement);
// Add with other event listeners
shiftLeftBtn.addEventListener('click', handleShiftLeft);
shiftRightBtn.addEventListener('click', handleShiftRight);
resetShiftBtn.addEventListener('click', handleResetShift);
popLastBtn.addEventListener('click', handlePopLast);
// Add with other event listeners
traverseForwardBtn.addEventListener('click', handleTraverseForward);
traverseBackwardBtn.addEventListener('click', handleTraverseBackward);
cumulativeSumBtn.addEventListener('click', handleCumulativeSum);
prefixSumBtn.addEventListener('click', handlePrefixSum);
reverseArrayBtn.addEventListener('click', handleReverseArray);
rotateLeftBtn.addEventListener('click', () => handleRotateOperation('left'));
rotateRightBtn.addEventListener('click', () => handleRotateOperation('right'));
confirmRotateBtn.addEventListener('click', handleConfirmRotate);
cancelRotateBtn.addEventListener('click', handleCancelRotate);
fillArrayBtn.addEventListener('click', handleFillArray);
swapByValuesBtn.addEventListener('click', () => showSwapInputGroup('values'));
swapByIndicesBtn.addEventListener('click', () => showSwapInputGroup('indices'));
confirmSwapCountBtn.addEventListener('click', handleConfirmSwapCount);
confirmSwapIndicesCountBtn.addEventListener('click', handleConfirmSwapIndicesCount);
findSubarraySumBtn.addEventListener('click', handleFindSubarraySum);
generateAllSubarraysWithSumBtn.addEventListener('click', handleGenerateAllSubarraysWithSum);
// Add with other event listeners
twoPointerTraverseBtn.addEventListener('click', handleTwoPointerTraversal);
// Add with other event listeners
sortAscBtn.addEventListener('click', () => handleSort('asc'));
sortDescBtn.addEventListener('click', () => handleSort('desc'));
// Add with other event listeners
checkSortedBtn.addEventListener('click', handleCheckSorted);
partialSortBtn.addEventListener('click', handlePartialSort);
confirmPartialSortBtn.addEventListener('click', handleConfirmPartialSort);
cancelPartialSortBtn.addEventListener('click', handleCancelPartialSort);
findFirstOccurrenceBtn.addEventListener('click', handleFindFirstOccurrence);
findLastOccurrenceBtn.addEventListener('click', handleFindLastOccurrence);
findAllOccurrencesBtn.addEventListener('click', handleFindAllOccurrences);
deleteFirstOccurrenceBtn.addEventListener('click', handleDeleteFirstOccurrence);
deleteAllOccurrencesBtn.addEventListener('click', handleDeleteAllOccurrences);
removeDuplicatesInPlaceBtn.addEventListener('click', handleRemoveDuplicatesInPlace);
removeDuplicatesKeepOneBtn.addEventListener('click', handleRemoveDuplicatesKeepOne);
cloneArrayBtn.addEventListener('click', handleCloneArray);
stableSortBtn.addEventListener('click', handleStableSort);
// Add with other event listeners
sortSubarrayBtn.addEventListener('click', handleSortSubarray);
// Add with other event listeners
mergeSortedArraysBtn.addEventListener('click', handleMergeSortedArrays);
confirmFirstArraySizeBtn.addEventListener('click', handleConfirmFirstArraySize);
confirmSecondArraySizeBtn.addEventListener('click', handleConfirmSecondArraySize);
performMergeBtn.addEventListener('click', handlePerformMerge);
cancelMergeBtn.addEventListener('click', handleCancelMerge);
// Add with other event listeners
twoPointerSortBtn.addEventListener('click', handleTwoPointerSort);
kadaneAlgorithmBtn.addEventListener('click', handleKadaneAlgorithm);
moveZerosToFrontBtn.addEventListener('click', () => handleMoveZeros('front'));
moveZerosToEndBtn.addEventListener('click', () => handleMoveZeros('end'));
countSubarraysBtn.addEventListener('click', handleCountSubarrays);
generateSubarraysBtn.addEventListener('click', handleGenerateSubarrays);
// Add with other event listeners
rearrangePositiveNegativeBtn.addEventListener('click', handleRearrangePositiveNegative);
// Add with other event listeners
segregateEvenOddBtn.addEventListener('click', handleSegregateEvenOdd);
// Add with other event listeners
countElementFrequencyBtn.addEventListener('click', handleCountElementFrequency);
findDuplicatesBtn.addEventListener('click', handleFindDuplicates);
// Add with other event listeners
firstNonRepeatingBtn.addEventListener('click', handleFirstNonRepeating);
findUniqueElementsBtn.addEventListener('click', handleFindUniqueElements);
// Add with other event listeners
findMajorityElementBtn.addEventListener('click', handleFindMajorityElement);
// Add with other event listeners
sortDutchNationalFlagBtn.addEventListener('click', handleDutchNationalFlagSort);
shiftLeftAfterDeleteBtn.addEventListener('click', handleShiftLeftAfterDelete);
// Add with other event listeners
findPivotBtn.addEventListener('click', handleFindPivot);
rotatedSearchBtn.addEventListener('click', handleRotatedSearch);
// Add with other event listeners
// Add with other event listeners
createAPBtn.addEventListener('click', () => showProgressionInput('ap'));
createGPBtn.addEventListener('click', () => showProgressionInput('gp'));
confirmAPBtn.addEventListener('click', handleCreateAP);
confirmGPBtn.addEventListener('click', handleCreateGP);
cancelProgressionBtn.addEventListener('click', handleCancelProgression);
// Add these event listeners with other listeners
kthSmallestBtn.addEventListener('click', () => handleKthOperation('smallest'));
kthLargestBtn.addEventListener('click', () => handleKthOperation('largest'));
// Add these event listeners with other listeners
selectionSortBtn.addEventListener('click', handleSelectionSort);
insertionSortBtn.addEventListener('click', handleInsertionSort);
// Add with other event listeners
cyclicShiftLeftBtn.addEventListener('click', () => handleCyclicShiftOperation('left'));
cyclicShiftRightBtn.addEventListener('click', () => handleCyclicShiftOperation('right'));
confirmCyclicShiftBtn.addEventListener('click', handleConfirmCyclicShift);
cancelCyclicShiftBtn.addEventListener('click', handleCancelCyclicShift);
// Add with other event listeners
inPlaceNegationBtn.addEventListener('click', handleInPlaceNegation);
// Add these event listeners with other listeners
findNBy3ElementsBtn.addEventListener('click', handleFindNBy3Elements);
nextGreaterElementBtn.addEventListener('click', handleNextGreaterElement);
// Add event listeners
shallowCopyBtn.addEventListener('click', handleShallowCopy);
confirmShallowCopyBtn.addEventListener('click', handleConfirmShallowCopy);
cancelShallowCopyBtn.addEventListener('click', handleCancelShallowCopy);
// Add with other event listeners
inPlaceMergeSortBtn.addEventListener('click', handleInPlaceMergeSort);
// Add with other event listeners
insertSortedBtn.addEventListener('click', handleInsertSorted);
confirmInsertSortedCountBtn.addEventListener('click', handleConfirmInsertSortedCount);
performInsertSortedBtn.addEventListener('click', handlePerformInsertSorted);
cancelInsertSortedBtn.addEventListener('click', handleCancelInsertSorted);
// Add with other event listeners
generateRandomArrayBtn.addEventListener('click', handleGenerateRandomArray);
// Add with other event listeners
convertToCharArrayBtn.addEventListener('click', handleConvertToCharArray);
confirmStringBtn.addEventListener('click', handleConfirmString);
cancelStringBtn.addEventListener('click', handleCancelString);
// Event Listeners
customComparatorSortBtn.addEventListener('click', handleCustomComparatorSort);
createDictionaryBtn.addEventListener('click', handleCreateDictionary);
confirmFieldCountBtn.addEventListener('click', handleConfirmFieldCount);
addRecordBtn.addEventListener('click', handleAddRecord);
finishDataEntryBtn.addEventListener('click', handleFinishDataEntry);
updateDictionaryBtn.addEventListener('click', handleUpdateDictionary);
dropDictionaryBtn.addEventListener('click', handleDropDictionary);
performSortBtn.addEventListener('click', handlePerformSort);
resetAfterSortBtn.addEventListener('click', handleResetAfterSort);
cancelCustomSortBtn.addEventListener('click', handleCancelCustomSort);
// Add with other event listeners
quickSortBtn.addEventListener('click', handleQuickSort);
heapSortBtn.addEventListener('click', handleHeapSort);
// Add with other event listeners
sortEvenBeforeOddBtn.addEventListener('click', handleSortEvenBeforeOdd);
sortByAbsoluteValueBtn.addEventListener('click', handleSortByAbsoluteValue);
// Add with other event listeners
popFirstBtn.addEventListener('click', handlePopFirst);
shiftRightInsertBtn.addEventListener('click', handleShiftRightInsert);
confirmShiftInsertBtn.addEventListener('click', handleConfirmShiftInsert);
cancelShiftInsertBtn.addEventListener('click', handleCancelShiftInsert);
// Add with other event listeners
findTripletsBtn.addEventListener('click', handleFindTriplets);
findQuadrupletsBtn.addEventListener('click', handleFindQuadruplets);
// Add with other event listeners
equilibriumPointBtn.addEventListener('click', handleEquilibriumPoint);
// Add with other event listeners
containerWithMostWaterBtn.addEventListener('click', handleContainerWithMostWater);
trappingRainWaterBtn.addEventListener('click', handleTrappingRainWater);
// Add with other event listeners
twoSumBtn.addEventListener('click', handleTwoSum);
confirmTwoSumBtn.addEventListener('click', handleConfirmTwoSum);
cancelTwoSumBtn.addEventListener('click', handleCancelTwoSum);
// Add with other event listeners
findGcdBtn.addEventListener('click', handleFindGCD);
findLcmBtn.addEventListener('click', handleFindLCM);
// Add with other event listeners
primeSieveBtn.addEventListener('click', handlePrimeSieve);
// Add with other event listeners
findLongestSubstringBtn.addEventListener('click', handleFindLongestSubstring);
// Add with other event listeners
subarrayProductBtn.addEventListener('click', handleSubarrayProduct);
// Add with other event listeners
leaderInArrayBtn.addEventListener('click', handleLeaderInArray);
// Add with other event listeners
jumpGameBtn.addEventListener('click', handleJumpGame);
// Add with other event listeners
bestTimeStockBtn.addEventListener('click', handleBestTimeStock);
// Add with other event listeners
findSubarrayNearZeroBtn.addEventListener('click', handleFindSubarrayNearZero);
// Add with other event listeners
minWindowSubstringBtn.addEventListener('click', handleMinWindowSubstring);
performMinWindowBtn.addEventListener('click', handlePerformMinWindow);
cancelMinWindowBtn.addEventListener('click', handleCancelMinWindow);
// Add with other event listeners
maxKConsecutiveBtn.addEventListener('click', () => handleKConsecutive('max'));
minKConsecutiveBtn.addEventListener('click', () => handleKConsecutive('min'));
// Add with other event listeners
rearrangeMinMaxBtn.addEventListener('click', handleRearrangeMinMax);
// Add with other event listeners
nextPermutationBtn.addEventListener('click', handleNextPermutation);
// Add with other event listeners
longestConsecutiveSequenceBtn.addEventListener('click', handleLongestConsecutiveSequence);
maxConsecutiveOnesBtn.addEventListener('click', handleMaxConsecutiveOnes);
// Add with other event listeners
mergeIntervalsBtn.addEventListener('click', handleMergeIntervals);
// Add with other event listeners
unionArraysBtn.addEventListener('click', () => handleSetOperation('union'));
intersectionArraysBtn.addEventListener('click', () => handleSetOperation('intersection'));
confirmNumArraysBtn.addEventListener('click', handleConfirmNumArrays);
performSetOperationBtn.addEventListener('click', handlePerformSetOperation);
cancelSetOperationBtn.addEventListener('click', handleCancelSetOperation);
// Add with other event listeners
setDifferenceBtn.addEventListener('click', () => handleSetOperation('difference'));
symmetricDifferenceBtn.addEventListener('click', () => handleSetOperation('symmetric'));
confirmNumArraysBtn.addEventListener('click', handleConfirmNumArrays);
performSetOperationBtn.addEventListener('click', handlePerformSetOperation);
cancelSetOperationBtn.addEventListener('click', handleCancelSetOperation);
// Add these with other event listeners
checkSubsetCompBtn.addEventListener('click', handleCheckSubsetComp);
checkSupersetCompBtn.addEventListener('click', handleCheckSupersetComp);
confirmNumArraysSubsetCompBtn.addEventListener('click', handleConfirmNumArraysSubsetComp);
confirmNumArraysSupersetCompBtn.addEventListener('click', handleConfirmNumArraysSupersetComp);
performSubsetCompBtn.addEventListener('click', handlePerformSubsetComp);
performSupersetCompBtn.addEventListener('click', handlePerformSupersetComp);
cancelSubsetCompBtn.addEventListener('click', handleCancelSubsetComp);
cancelSupersetCompBtn.addEventListener('click', handleCancelSupersetComp);
// Add with other event listeners
findFirstGreaterBtn.addEventListener('click', () => handleFindComparison('greater'));
findLastLessBtn.addEventListener('click', () => handleFindComparison('less'));
// Add with other event listeners
findCovarianceBtn.addEventListener('click', () => handleStatisticalOperation('covariance'));
findCorrelationBtn.addEventListener('click', () => handleStatisticalOperation('correlation'));
confirmArrayCountBtn.addEventListener('click', handleConfirmArrayCount);
performStatisticalOperationBtn.addEventListener('click', handlePerformStatisticalOperation);
cancelStatisticalOperationBtn.addEventListener('click', handleCancelStatisticalOperation);
// Add with other event listeners
findMeanBtn.addEventListener('click', handleFindMean);
findMedianBtn.addEventListener('click', handleFindMedian);
// Add with other event listeners
elementWiseMaxBtn.addEventListener('click', () => handleElementWiseOperation('max'));
elementWiseMinBtn.addEventListener('click', () => handleElementWiseOperation('min'));
confirmFirstArraySizeElementWiseBtn.addEventListener('click', handleConfirmFirstArraySizeElementWise);
confirmSecondArraySizeElementWiseBtn.addEventListener('click', handleConfirmSecondArraySizeElementWise);
performElementWiseBtn.addEventListener('click', handlePerformElementWise);
cancelElementWiseBtn.addEventListener('click', handleCancelElementWise);
// Add with other event listeners
logicalAndBtn.addEventListener('click', () => handleLogicalOperation('AND'));
logicalOrBtn.addEventListener('click', () => handleLogicalOperation('OR'));
confirmArraysCountBtn.addEventListener('click', handleConfirmArraysCount);
performLogicalOperationBtn.addEventListener('click', handlePerformLogicalOperation);
cancelLogicalOperationBtn.addEventListener('click', handleCancelLogicalOperation);
// Add with other event listeners
calculateStdDevBtn.addEventListener('click', handleCalculateStdDev);
calculateVarianceBtn.addEventListener('click', handleCalculateVariance);
// Add with other event listeners
addScalarBtn.addEventListener('click', () => handleScalarOperation('add'));
subtractScalarBtn.addEventListener('click', () => handleScalarOperation('subtract'));
multiplyScalarBtn.addEventListener('click', () => handleScalarOperation('multiply'));
divideScalarBtn.addEventListener('click', () => handleScalarOperation('divide'));
// Add with other event listeners
calcSinBtn.addEventListener('click', () => handleTrigOperation('sin'));
calcCosBtn.addEventListener('click', () => handleTrigOperation('cos'));
calcTanBtn.addEventListener('click', () => handleTrigOperation('tan'));
// Add with other event listeners
findRangeBtn.addEventListener('click', handleFindRange);
// Add with other event listeners
calculateExponentialBtn.addEventListener('click', () => handleMathOperation('exponential'));
calculateNaturalLogBtn.addEventListener('click', () => handleMathOperation('naturalLog'));
calculateLog10Btn.addEventListener('click', () => handleMathOperation('log10'));
// Add with other event listeners
document.getElementById('pancakeSortBtn').addEventListener('click', handlePancakeSort);
// Add with other event listeners
stockSpanBtn.addEventListener('click', handleStockSpan);
// Add Enter key support if needed
// Add with other event listeners
maxPairAndOrBtn.addEventListener('click', handleMaxPairAndOr);
// Add with other event listeners
largestRectangleHistogramBtn.addEventListener('click', handleLargestRectangleHistogram);
// Add with other event listeners
fruitIntoBasketsBtn.addEventListener('click', handleFruitIntoBaskets);
// Add with other event listeners
addArraysElementWiseBtn.addEventListener('click', () => handleElementWiseOperation('add'));
subtractArraysElementWiseBtn.addEventListener('click', () => handleElementWiseOperation('subtract'));
multiplyArraysElementWiseBtn.addEventListener('click', () => handleElementWiseOperation('multiply'));
divideArraysElementWiseBtn.addEventListener('click', () => handleElementWiseOperation('divide'));
modulusArraysElementWiseBtn.addEventListener('click', () => handleElementWiseOperation('modulus'));
confirmElementWiseFirstArraySizeBtn.addEventListener('click', handleConfirmElementWiseFirstArraySize);
confirmElementWiseSecondArraySizeBtn.addEventListener('click', handleConfirmElementWiseSecondArraySize);
performElementWiseOperationBtn.addEventListener('click', handlePerformElementWiseOperation);
cancelElementWiseOperationBtn.addEventListener('click', handleCancelElementWiseOperation);
// Add with other event listeners
logicalNotBtn.addEventListener('click', handleLogicalNot);
logicalXorBtn.addEventListener('click', handleLogicalXor);
confirmLogicalNotSizeBtn.addEventListener('click', handleConfirmLogicalNotSize);
cancelLogicalNotBtn.addEventListener('click', handleCancelLogicalNot);
confirmLogicalXorArrayCountBtn.addEventListener('click', handleConfirmLogicalXorArrayCount);
cancelLogicalXorBtn.addEventListener('click', handleCancelLogicalXor);
// Add with other event listeners
transformNonDecreasingBtn.addEventListener('click', handleTransformNonDecreasing);
// Add with other event listeners - USING UPDATED VARIABLE NAMES
minFlipsOrBtn.addEventListener('click', () => handleMinFlipsOperation('or'));
minFlipsAndBtn.addEventListener('click', () => handleMinFlipsOperation('and'));
confirmNumArraysButton.addEventListener('click', handleConfirmNumArrays); // Updated variable name
performMinFlipsOperationBtn.addEventListener('click', handlePerformMinFlips); // Updated variable name
cancelMinFlipsOperationBtn.addEventListener('click', handleCancelMinFlips); // Updated variable name
// Add with other event listeners
prefixXorBtn.addEventListener('click', handlePrefixXor);
// Add with other event listeners
findMaxAbsDiffBtn.addEventListener('click', handleFindMaxAbsDiff);
// Add with other event listeners
maxCircularSubarrayBtn.addEventListener('click', handleMaxCircularSubarray);
// Add with other event listeners
wiggleSortIIBtn.addEventListener('click', handleWiggleSortII);
// Add with other event listeners
maxDistanceSameElementsBtn.addEventListener('click', handleMaxDistanceSameElements);
// Add with other event listeners
countPairsWithDifferenceBtn.addEventListener('click', handleCountPairsWithDifference);
// Add with other event listeners
minSwapsBtn.addEventListener('click', handleMinSwaps);
// Add with other event listeners
findMissingRepeatingBtn.addEventListener('click', handleFindMissingRepeating);
// Add with other event listeners
findFirstRepeatingBtn.addEventListener('click', handleFindFirstRepeating);
// Add with other event listeners
conditionalWhereBtn.addEventListener('click', () => handleConditionalOperation('where'));
multiConditionSelectBtn.addEventListener('click', () => handleConditionalOperation('select'));
piecewiseEvaluateBtn.addEventListener('click', () => handleConditionalOperation('piecewise'));
confirmArraySizesBtn.addEventListener('click', handleConfirmArraySizes);
confirmConditionBtn.addEventListener('click', handleConfirmCondition);
cancelConditionalBtn.addEventListener('click', handleCancelConditional);
// Add these with other event listeners
previousGreaterBtn.addEventListener('click', () => handlePreviousElement('greater'));
previousSmallerBtn.addEventListener('click', () => handlePreviousElement('smaller'));
// Add with other event listeners
findByPredicateBtn.addEventListener('click', handleFindByPredicate);
// Add with other event listeners
convertTo2DBtn.addEventListener('click', handleConvertTo2D);
// Add with other event listeners
getDataTypeBtn.addEventListener('click', handleGetDataType);
createTypedArrayBtn.addEventListener('click', handleCreateTypedArray);
convertToListBtn.addEventListener('click', handleConvertToList);
confirmDataTypeBtn.addEventListener('click', handleConfirmDataType);
cancelDataTypeBtn.addEventListener('click', handleCancelDataType);
// Add with other event listeners
shuffleElementsBtn.addEventListener('click', handleShuffleElements);
// Add with other event listeners
binIntervalsBtn.addEventListener('click', handleBinIntervals);
binByWidthBtn.addEventListener('click', handleBinByWidth);
// Add with other event listeners
applyUfuncBtn.addEventListener('click', handleApplyUfunc);
ufuncSelect.addEventListener('change', handleUfuncSelection);
// Stock Market Event Listeners
loadStockPricesBtn.addEventListener('click', handleLoadStockPrices);
dailyReturnsBtn.addEventListener('click', () => handleStockOperation('dailyReturns'));
logReturnsBtn.addEventListener('click', () => handleStockOperation('logReturns'));
cumulativeReturnsBtn.addEventListener('click', () => handleStockOperation('cumulativeReturns'));
totalReturnBtn.addEventListener('click', () => handleStockOperation('totalReturn'));
priceDifferenceBtn.addEventListener('click', () => handleStockOperation('priceDifference'));
// Add these with your existing event listeners
priceMomentumBtn.addEventListener('click', () => handleStockOperation('priceMomentum'));
rateOfChangeBtn.addEventListener('click', () => handleStockOperation('rateOfChange'));
gapAnalysisBtn.addEventListener('click', () => handleStockOperation('gapAnalysis'));
intradayGainBtn.addEventListener('click', () => handleStockOperation('intradayGain'));
// Add these with your existing event listeners
smaBtn.addEventListener('click', () => handleStockOperation('sma'));
emaBtn.addEventListener('click', () => handleStockOperation('ema'));
macdBtn.addEventListener('click', () => handleStockOperation('macd'));
macdSignalBtn.addEventListener('click', () => handleStockOperation('macdSignal'));
bollingerMiddleBtn.addEventListener('click', () => handleStockOperation('bollingerMiddle'));
bollingerUpperBtn.addEventListener('click', () => handleStockOperation('bollingerUpper'));
// Add with other event listeners
applyAxisBtn.addEventListener('click', handleApplyAxis);
axisFunctionSelect.addEventListener('change', handleAxisFunctionChange);
createMatrixBtn.addEventListener('click', handleCreateMatrix);
// Add event listeners for statistical operations
findMinIndexBtn.addEventListener('click', () => handleStatisticalOperation('minIndex'));
findMaxIndexBtn.addEventListener('click', () => handleStatisticalOperation('maxIndex'));
findNSmallestBtn.addEventListener('click', () => handleStatisticalOperation('nSmallest'));
findNLargestBtn.addEventListener('click', () => handleStatisticalOperation('nLargest'));
confirmNValueBtn.addEventListener('click', handleConfirmNValue);
cancelNValueBtn.addEventListener('click', handleCancelNValue);
// Add with other event listeners
validParenthesesBtn.addEventListener('click', handleValidParentheses);
// Add with other event listeners
maxSubarraySumBtn.addEventListener('click', handleMaxSubarraySum);
maxProductSubarrayBtn.addEventListener('click', handleMaxProductSubarray);
// Add with other event listeners
checkPalindromeBtn.addEventListener('click', handleCheckPalindrome);
findAnagramsBtn.addEventListener('click', handleFindAnagrams);
// Add with other event listeners
rangeSumQueryBtn.addEventListener('click', handleRangeSumQuery);
// Add with other event listeners
dailyTemperaturesBtn.addEventListener('click', handleDailyTemperatures);
// Add with other event listeners
findFirstLastBtn.addEventListener('click', handleFindFirstLast);
// Add with other event listeners
findPalindromicSubstringsBtn.addEventListener('click', handleFindPalindromicSubstrings);
findLongestPalindromicSubstringBtn.addEventListener('click', handleFindLongestPalindromicSubstring);
// Add these with other event listeners
wildcardMatchingBtn.addEventListener('click', () => handlePatternMatching('wildcard'));
regexMatchingBtn.addEventListener('click', () => handlePatternMatching('regex'));
confirmPatternMatchingBtn.addEventListener('click', handleConfirmPatternMatching);
cancelPatternMatchingBtn.addEventListener('click', handleCancelPatternMatching);
// Add with other event listeners
combinationSumBtn.addEventListener('click', handleCombinationSum);
subsetsBtn.addEventListener('click', handleSubsets);
confirmCombinationSumBtn.addEventListener('click', handleConfirmCombinationSum);
cancelCombinationSumBtn.addEventListener('click', handleCancelCombinationSum);
// Add with other event listeners
longestValidParenthesesBtn.addEventListener('click', handleLongestValidParentheses);
distinctSubsequencesBtn.addEventListener('click', handleDistinctSubsequences);
confirmParenthesesBtn.addEventListener('click', handleConfirmParentheses);
cancelParenthesesBtn.addEventListener('click', handleCancelParentheses);
confirmSubsequencesBtn.addEventListener('click', handleConfirmSubsequences);
cancelSubsequencesBtn.addEventListener('click', handleCancelSubsequences);
// Add with other event listeners
findWordConcatenationBtn.addEventListener('click', handleStartWordConcatSearch);
runWordConcatSearchBtn.addEventListener('click', handleRunWordConcatSearch);
stopWordConcatSearchBtn.addEventListener('click', handleStopWordConcatSearch);
// Add with other event listeners
countSmallerAfterSelfBtn.addEventListener('click', handleCountSmallerAfterSelf);
// Add these with other event listeners
checkUglyNumberBtn.addEventListener('click', handleCheckUglyNumber);
findNthUglyNumberBtn.addEventListener('click', handleFindNthUglyNumber);
findSuperUglyNumberBtn.addEventListener('click', handleFindSuperUglyNumber);
// Add with other event listeners
findPerfectNumbersBtn.addEventListener('click', handleFindPerfectNumbers);
findArmstrongNumbersBtn.addEventListener('click', handleFindArmstrongNumbers);
// Add with other event listeners
pascalSpecificRowBtn.addEventListener('click', handlePascalSpecificRow);
pascalMultipleRowsBtn.addEventListener('click', handlePascalMultipleRows);
// Add with other event listeners
randomPickWithWeightBtn.addEventListener('click', handleRandomPickWithWeight);
// Add with other event listeners
generateRandomPointBtn.addEventListener('click', handleGenerateRandomPoint);
// Add with other event listeners
findConsecutiveSequencesBtn.addEventListener('click', handleFindConsecutiveSequences);
// Add with other event listeners
convertToEnglishBtn.addEventListener('click', handleConvertToEnglish);
findDigitOneBtn.addEventListener('click', handleFindDigitOne);
// Add with other event listeners
addDigitsBtn.addEventListener('click', handleAddDigits);
happyNumberBtn.addEventListener('click', handleHappyNumber);
// Add with other event listeners
excelColumnNumberBtn.addEventListener('click', handleExcelColumnNumber);
// Add with other event listeners
numberToColumnTitleBtn.addEventListener('click', handleNumberToColumnTitle);
// Add these with other event listeners
implementStackBtn.addEventListener('click', handleImplementStack);
createStackBtn.addEventListener('click', handleCreateStack);
pushBtn.addEventListener('click', handlePush);
popBtn.addEventListener('click', handlePop);
peekBtn.addEventListener('click', handlePeek);
isFullBtn.addEventListener('click', handleIsFull);
isEmptyBtn.addEventListener('click', handleIsEmpty);
resetStackBtn.addEventListener('click', handleResetStack);
// Add with other event listeners
implementQueueBtn.addEventListener('click', handleImplementQueue);
// Add with other event listeners
implementPriorityQueueBtn.addEventListener('click', handleImplementPriorityQueue);
initializeQueueBtn.addEventListener('click', handleInitializeQueue);
enqueueBtn.addEventListener('click', handleEnqueue);
dequeueBtn.addEventListener('click', handleDequeue);
peekBtn.addEventListener('click', handlePeek);
resetQueueBtn.addEventListener('click', handleResetQueue);
browserHistoryBtn.addEventListener('click', handleBrowserHistory);
// Add with other event listeners
designOrderedStreamBtn.addEventListener('click', handleDesignOrderedStream);
insertIntoStreamBtn.addEventListener('click', handleInsertIntoStream);
resetStreamBtn.addEventListener('click', handleResetStream);
// Add with other event listeners
rleEncodeBtn.addEventListener('click', () => handleRLEOperation('encode'));
rleDecodeBtn.addEventListener('click', () => handleRLEOperation('decode'));
// Add with other event listeners
deltaEncodingBtn.addEventListener('click', handleDeltaEncoding);
bwtTransformBtn.addEventListener('click', handleBWTTransform);
mtfTransformBtn.addEventListener('click', handleMTFTransform);
confirmDeltaSizeBtn.addEventListener('click', handleConfirmDeltaSize);
performDeltaEncodingBtn.addEventListener('click', handlePerformDeltaEncoding);
cancelDeltaBtn.addEventListener('click', handleCancelDelta);
performBWTBtn.addEventListener('click', handlePerformBWT);
cancelBWTBtn.addEventListener('click', handleCancelBWT);
performMTFBtn.addEventListener('click', handlePerformMTF);
cancelMTFBtn.addEventListener('click', handleCancelMTF);
// Add with other event listeners
countAndSayBtn.addEventListener('click', handleCountAndSay);
stringCompressionBtn.addEventListener('click', handleStringCompression);
confirmCountAndSayBtn.addEventListener('click', handleConfirmCountAndSay);
confirmStringCompressionBtn.addEventListener('click', handleConfirmStringCompression);
cancelCountAndSayBtn.addEventListener('click', handleCancelCountAndSay);
cancelStringCompressionBtn.addEventListener('click', handleCancelStringCompression);
// Add with other event listeners
encodeDecodeBtn.addEventListener('click', handleEncodeDecode);
setLogCountBtn.addEventListener('click', handleSetLogCount);
reorderLogsBtn.addEventListener('click', handleReorderLogs);
// Pattern Search Event Listeners
rabinKarpBtn.addEventListener('click', () => handlePatternAlgorithm('rabin-karp'));
zAlgorithmBtn.addEventListener('click', () => handlePatternAlgorithm('z-algorithm'));
startPatternSearchBtn.addEventListener('click', executePatternSearch);
cancelPatternSearchBtn.addEventListener('click', cancelPatternSearch);
wordAbbrValidationBtn.addEventListener('click', handleWordAbbrValidation);
// Add with other event listeners
shortestWordDistanceBtn.addEventListener('click', handleShortestWordDistance);
confirmWordArraySizeBtn.addEventListener('click', handleConfirmWordArraySize);
findShortestDistanceBtn.addEventListener('click', handleFindShortestDistance);
cancelShortestWordDistanceBtn.addEventListener('click', handleCancelShortestWordDistance);
// Add with other event listeners
groupShiftedStringsBtn.addEventListener('click', handleGroupShiftedStrings);
flipGameBtn.addEventListener('click', handleFlipGame);
confirmShiftedStringsSizeBtn.addEventListener('click', handleConfirmShiftedStringsSize);
performGroupShiftedStringsBtn.addEventListener('click', handlePerformGroupShiftedStrings);
cancelGroupShiftedStringsBtn.addEventListener('click', handleCancelGroupShiftedStrings);
performFlipGameBtn.addEventListener('click', handlePerformFlipGame);
cancelFlipGameBtn.addEventListener('click', handleCancelFlipGame);
nimGameBtn.addEventListener('click', handleNimGame);
confirmNimSizeBtn.addEventListener('click', handleConfirmNimSize);
playNimGameBtn.addEventListener('click', handlePlayNimGame);
cancelNimGameBtn.addEventListener('click', handleCancelNimGame);
// Add with other event listeners
canIWinBtn.addEventListener('click', handleCanIWin);
// Add with other event listeners
predictWinnerBtn.addEventListener('click', handlePredictWinner);
confirmPredictWinnerSizeBtn.addEventListener('click', handleConfirmPredictWinnerSize);
performPredictWinnerBtn.addEventListener('click', handlePerformPredictWinner);
cancelPredictWinnerBtn.addEventListener('click', handleCancelPredictWinner);
// Add with other event listeners
stoneGameBtn.addEventListener('click', handleStoneGame);
startStoneGameBtn.addEventListener('click', handleStartStoneGame);
cancelStoneGameBtn.addEventListener('click', handleCancelStoneGame);
// Add with other event listeners
gasStationBtn.addEventListener('click', handleGasStationProblem);
confirmGasStationCountBtn.addEventListener('click', handleConfirmGasStationCount);
solveGasStationBtn.addEventListener('click', handleSolveGasStation);
cancelGasStationBtn.addEventListener('click', handleCancelGasStation);
// Add with other event listeners
candyDistributeBtn.addEventListener('click', handleCandyDistribution);
confirmCandySizeBtn.addEventListener('click', handleConfirmCandySize);
performCandyDistributionBtn.addEventListener('click', handlePerformCandyDistribution);
cancelCandyBtn.addEventListener('click', handleCancelCandy);
// Add with other event listeners
taskSchedulerBtn.addEventListener('click', handleTaskScheduler);
confirmTaskSizeBtn.addEventListener('click', handleConfirmTaskSize);
performTaskSchedulingBtn.addEventListener('click', handlePerformTaskScheduling);
cancelTaskSchedulingBtn.addEventListener('click', handleCancelTaskScheduling);
// Add with other event listeners
partitionDisjointBtn.addEventListener('click', handlePartitionDisjoint);
// Add with other event listeners
partitionArrayBtn.addEventListener('click', handlePartitionArray);
// Add with other event listeners
partitionLabelsOperationBtn.addEventListener('click', handlePartitionLabelsOperation);
// Add with other event listeners
splitArrayLargestSumBtn.addEventListener('click', handleSplitArrayLargestSum);
// Add with other event listeners
splitEqualSumBtn.addEventListener('click', handleSplitEqualSum);
// Add with other event listeners
document.getElementById('divideKConsecutiveBtn').addEventListener('click', () => showSequenceInput('consecutive'));
document.getElementById('divideIncreasingSequencesBtn').addEventListener('click', () => showSequenceInput('increasing'));
document.getElementById('splitBalancedStringsBtn').addEventListener('click', () => showSequenceInput('balanced'));

document.getElementById('confirmKConsecutiveBtn').addEventListener('click', () => handleSequenceOperation('consecutive'));
document.getElementById('confirmIncreasingSequencesBtn').addEventListener('click', () => handleSequenceOperation('increasing'));
document.getElementById('confirmBalancedStringsBtn').addEventListener('click', () => handleSequenceOperation('balanced'));

document.getElementById('cancelKConsecutiveBtn').addEventListener('click', () => cancelSequenceOperation('consecutive'));
document.getElementById('cancelIncreasingSequencesBtn').addEventListener('click', () => cancelSequenceOperation('increasing'));
document.getElementById('cancelBalancedStringsBtn').addEventListener('click', () => cancelSequenceOperation('balanced'));

// Add with other event listeners
countNiceSubarraysBtn.addEventListener('click', handleCountNiceSubarrays);
// Add with other event listeners
kDifferentIntegersBtn.addEventListener('click', handleKDifferentIntegers);
// Add with other event listeners
threeCharsSubstringsBtn.addEventListener('click', handleThreeCharsSubstrings);
confirmThreeCharsBtn.addEventListener('click', handleConfirmThreeChars);
cancelThreeCharsBtn.addEventListener('click', handleCancelThreeChars);
// Add with other event listeners
longestTurbulentSubarrayBtn.addEventListener('click', handleLongestTurbulentSubarray);
// Add with other event listeners
reversePairsBtn.addEventListener('click', handleReversePairs);
// Add with other event listeners
inversionsAnalysisBtn.addEventListener('click', handleInversionsAnalysis);
// Add with other event listeners
summaryRangesBtn.addEventListener('click', handleSummaryRanges);
findRightIntervalBtn.addEventListener('click', handleFindRightInterval);
// Add with other event listeners
minArrowsBtn.addEventListener('click', handleMinArrows);
// Add with other event listeners
teemoAttackingBtn.addEventListener('click', handleTeemoAttacking);
// Add with other event listeners
buildingsOceanViewBtn.addEventListener('click', handleBuildingsOceanView);
createTargetArrayBtn.addEventListener('click', handleCreateTargetArray);
confirmBuildingHeightsBtn.addEventListener('click', handleConfirmBuildingHeights);
confirmTargetValuesBtn.addEventListener('click', handleConfirmTargetValues);
confirmTargetIndicesBtn.addEventListener('click', handleConfirmTargetIndices);
performTargetArrayBtn.addEventListener('click', handlePerformTargetArray);
cancelTargetArrayBtn.addEventListener('click', handleCancelTargetArray);
// Add with other event listeners
decompressRLEBtn.addEventListener('click', handleDecompressRLE);
arrayNestingBtn.addEventListener('click', handleArrayNesting);
// Add with other event listeners
queueReconstructionBtn.addEventListener('click', handleQueueReconstruction);
confirmQueueSizeBtn.addEventListener('click', handleConfirmQueueSize);
performQueueReconstructionBtn.addEventListener('click', handlePerformQueueReconstruction);
cancelQueueReconstructionBtn.addEventListener('click', handleCancelQueueReconstruction);
// Add with other event listeners
document.getElementById('crawlerLogFolderBtn').addEventListener('click', handleCrawlerLogFolder);
document.getElementById('confirmCrawlerLogSizeBtn').addEventListener('click', handleConfirmCrawlerLogSize);
document.getElementById('performCrawlerLogBtn').addEventListener('click', handlePerformCrawlerLog);
document.getElementById('cancelCrawlerLogBtn').addEventListener('click', handleCancelCrawlerLog);
// Add with other event listeners
singleNumberIIBtn.addEventListener('click', handleSingleNumberII);
singleNumberIIIBtn.addEventListener('click', handleSingleNumberIII);
// NEW: Event listeners for string operations
maxProductBtn.addEventListener('click', () => handleStringOperation('maxProduct'));
countConsistentBtn.addEventListener('click', () => handleStringOperation('countConsistent'));
confirmStringArraySizeBtn.addEventListener('click', handleConfirmStringArraySize);
performStringOperationBtn.addEventListener('click', handlePerformStringOperation);
cancelStringOperationBtn.addEventListener('click', handleCancelStringOperation);
// Add with other event listeners
subarrayBitwiseORsBtn.addEventListener('click', handleSubarrayBitwiseORs);
bitwiseAndRangeBtn.addEventListener('click', handleBitwiseAndRange);
// Add with other event listeners
hammingWeightBtn.addEventListener('click', () => startHammingOperation('weight'));
hammingDistanceBtn.addEventListener('click', () => startHammingOperation('distance'));
confirmHammingArraySizeBtn.addEventListener('click', handleConfirmHammingArraySize);
performHammingOperationBtn.addEventListener('click', handlePerformHammingOperation);
cancelHammingOperationBtn.addEventListener('click', handleCancelHammingOperation);
// Add with other event listeners
shortestSuperstringBtn.addEventListener('click', handleShortestSuperstring);
performSuperstringBtn.addEventListener('click', handlePerformSuperstring);
cancelSuperstringBtn.addEventListener('click', handleCancelSuperstring);
// Add with other event listeners
grayCodeBtn.addEventListener('click', handleGrayCodeButton);
generateGrayCodeBtn.addEventListener('click', handleGenerateGrayCode);
cancelGrayCodeBtn.addEventListener('click', handleCancelGrayCode);
// Add with other event listeners
findSmallestDivisorBtn.addEventListener('click', handleSmallestDivisor);
// Add with other event listeners
hIndexBtn.addEventListener('click', handleHIndex);
// Add with other event listeners
capacityToShipBtn.addEventListener('click', handleCapacityToShip);
confirmCapacityBtn.addEventListener('click', handleConfirmCapacity);
cancelCapacityBtn.addEventListener('click', handleCancelCapacity);
// Add with other event listeners
kokoBananasBtn.addEventListener('click', handleKokoBananas);
confirmKokoPilesBtn.addEventListener('click', handleConfirmKokoPiles);
startKokoAlgorithmBtn.addEventListener('click', handleStartKokoAlgorithm);
cancelKokoBtn.addEventListener('click', handleCancelKoko);
// Add with other event listeners
firstBadVersionBtn.addEventListener('click', handleFirstBadVersion);
// Add with other event listeners
houseRobberBtn.addEventListener('click', handleHouseRobber);
confirmHouseRobberBtn.addEventListener('click', handleConfirmHouseRobber);
useCurrentArrayBtn.addEventListener('click', handleUseCurrentArray);
generateRandomHousesBtn.addEventListener('click', handleGenerateRandomHouses);
cancelHouseRobberBtn.addEventListener('click', handleCancelHouseRobber);
// Add with other event listeners
maxSubarrayOneDeletionBtn.addEventListener('click', handleMaxSubarrayOneDeletion);
// Add with other event listeners
maxPairChainBtn.addEventListener('click', handleMaxPairChain);
confirmPairCountBtn.addEventListener('click', handleConfirmPairCount);
performPairChainBtn.addEventListener('click', handlePerformPairChain);
cancelPairChainBtn.addEventListener('click', handleCancelPairChain);
// Add with other event listeners
arithmeticSlicesBtn.addEventListener('click', handleArithmeticSlices);
// Add with other event listeners
uniquePathsBtn.addEventListener('click', handleUniquePaths);
confirmUniquePathsBtn.addEventListener('click', handleConfirmUniquePaths);
cancelUniquePathsBtn.addEventListener('click', handleCancelUniquePaths);
// Add with other event listeners
coinChangeBtn.addEventListener('click', handleCoinChange);
confirmCoinCountBtn.addEventListener('click', handleConfirmCoinCount);
performCoinChangeBtn.addEventListener('click', handlePerformCoinChange);
cancelCoinChangeBtn.addEventListener('click', handleCancelCoinChange);
// Add with other event listeners
decodeWaysBtn.addEventListener('click', handleDecodeWays);
// Add with other event listeners
if (partitionEqualSubsetSumBtn) {
    partitionEqualSubsetSumBtn.addEventListener('click', handlePartitionEqualSubsetSum);
}
// Add with other event listeners
targetSumBtn.addEventListener('click', handleTargetSum);
// Add with other event listeners
wordBreakBtn.addEventListener('click', handleWordBreak);
performWordBreakBtn.addEventListener('click', handlePerformWordBreak);
cancelWordBreakBtn.addEventListener('click', handleCancelWordBreak);
// Add with other event listeners
maxRectangleBtn.addEventListener('click', handleMaxRectangle);
// Add with other event listeners
lruCacheBtn.addEventListener('click', handleLRUCache);
// Add with other event listeners
lfuCacheBtn.addEventListener('click', handleLFUCache);
// Add with other event listeners
findMedianStreamBtn.addEventListener('click', handleFindMedianStream);
slidingWindowMedianBtn.addEventListener('click', handleSlidingWindowMedianClick);
confirmSlidingWindowBtn.addEventListener('click', handleConfirmSlidingWindow);
cancelSlidingWindowBtn.addEventListener('click', handleCancelSlidingWindow);
// Add with other event listeners
calendarBtn.addEventListener('click', handleCalendar);
confirmNumEventsBtn.addEventListener('click', handleConfirmNumEvents);
performCalendarBtn.addEventListener('click', handlePerformCalendar);
cancelCalendarBtn.addEventListener('click', handleCancelCalendar);

        // Allow Enter key to trigger operations
        createValue.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleCreate();
        });
        
        insertValue.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleInsert();
        });
        
        readIndex.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleRead();
        });
        
        updateValue.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleUpdate();
        });
        
        updateNewValue.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleUpdateByElement();
        });
        
        deleteIndex.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleDelete();
        });
        
        deleteElement.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleDeleteByElement();
        });
        // Add Enter key support
deleteFirstOccurrence.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleDeleteFirstOccurrence();
});
deleteAllOccurrences.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleDeleteAllOccurrences();
});
        searchElement.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleSearch();
        });
        
        searchIndex.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleSearchByIndex();
        });
        
        linearSearchElement.addEventListener('keypress', (e) => { // NEW
            if (e.key === 'Enter') handleLinearSearch();
        });
        // Add Enter key support
binarySearchElement.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleBinarySearch();
});
checkElement.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCheckElement();
});
        // Add these with other event listeners
createArrayFromRangeBtn.addEventListener('click', handleCreateArrayFromRange);
resizeArrayBtn.addEventListener('click', handleResizeArray);

// Add Enter key support
arraySize.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCreateArrayFromRange();
});

resizeSize.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleResizeArray();
});
// Add Enter key support
cloneIndex.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCloneArray();
});
cloneElementValue.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCloneArray();
});
// Add Enter key support
substringInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindLongestSubstring();
});
// Add Enter key support
elementWiseFirstArraySizeInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmElementWiseFirstArraySize();
});
elementWiseSecondArraySizeInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmElementWiseSecondArraySize();
});

// Add these with other event listeners
sliceBtn.addEventListener('click', handleSlice);
resetArrayBtn.addEventListener('click', handleResetArray);
document.getElementById('resetTransformationBtn').addEventListener('click', resetTransformation);
// Add with other event listeners
fixedWindowBtn.addEventListener('click', handleFixedWindow);
variableWindowBtn.addEventListener('click', handleVariableWindow);


// Add Enter key support
sliceStart.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleSlice();
});
sliceEnd.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleSlice();
});
// Add Enter key support
rotatePositionsInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmRotate();
});
// Add Enter key support
fillValue.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFillArray();
});
fillStart.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFillArray();
});
fillEnd.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFillArray();
});
swapCount.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmSwapCount();
});
swapIndicesCount.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmSwapIndicesCount();
});
// Add Enter key support
subarraySumInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindSubarraySum();
});
// Add Enter key support
partialSortCount.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmPartialSort();
});
// Add Enter key support
occurrenceElement.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindFirstOccurrence();
});
occurrenceElementLast.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindLastOccurrence();
});
occurrenceElementAll.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindAllOccurrences();
});
// Add Enter key support
sortSubarrayStart.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleSortSubarray();
});
sortSubarrayEnd.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleSortSubarray();
});

// Add Enter key support
firstArraySizeInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmFirstArraySize();
});
secondArraySizeInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmSecondArraySize();
});
// Add Enter key support
fixedWindowSize.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFixedWindow();
});
variableWindowSum.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleVariableWindow();
});
// Add Enter key support
subarrayInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCountSubarrays();
});
// Add Enter key support
shiftDeleteIndex.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleShiftLeftAfterDelete();
});
// Add Enter key support
rotatedSearchElement.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleRotatedSearch();
});
// Add Enter key support
apFirstTerm.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCreateAP();
});
apCommonDiff.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCreateAP();
});
apNumTerms.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCreateAP();
});
gpFirstTerm.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCreateGP();
});
gpCommonRatio.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCreateGP();
});
gpNumTerms.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCreateGP();
});
kthElementInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        // Default to kth smallest if Enter is pressed
        handleKthOperation('smallest');
    }
});
// Add Enter key support
cyclicShiftPositionsInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmCyclicShift();
});
// Add Enter key support
shallowCopyCount.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleShallowCopy();
});
// Add Enter key support
insertSortedCountInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmInsertSortedCount();
});
// Add Enter key support
randomArraySize.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleGenerateRandomArray();
});
// Add Enter key support
inputString.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmString();
});
// Enter key support
dictionaryName.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCreateDictionary();
});

fieldCount.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmFieldCount();
});
// Add Enter key support
insertShiftIndex.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmShiftInsert();
});
insertShiftValue.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmShiftInsert();
});
// Add Enter key support
tripletSumInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindTriplets();
});

quadrupletSumInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindQuadruplets();
});
// Add Enter key support
twoSumTargetInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmTwoSum();
});
// Add Enter key support
subarrayProductK.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleSubarrayProduct();
});
// Add Enter key support
mainStringInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') targetStringInput.focus();
});

targetStringInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handlePerformMinWindow();
});
// Add Enter key support
kConsecutiveSize.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        // Default to max if Enter is pressed without clicking a specific button
        handleKConsecutive('max');
    }
});
// Add Enter key support
numArrays.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmNumArrays();
});
// Add Enter key support
numArraysSubsetComp.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmNumArraysSubsetComp();
});
numArraysSupersetComp.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmNumArraysSupersetComp();
});
// Add Enter key support
buildingHeights.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmBuildingHeights();
});
targetArrayValuesInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmTargetValues();
});
targetArrayIndicesInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmTargetIndices();
});
// NEW: Enter key support for string operations
stringArraySizeInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmStringArraySize();
});

// Use event delegation for dynamically created buttons
document.addEventListener('click', function(e) {
    // Handle edit record button clicks
    if (e.target.closest('.edit-record')) {
        const button = e.target.closest('.edit-record');
        const index = parseInt(button.getAttribute('data-index'));
        handleEditRecord(index);
    }
    
    // Handle delete record button clicks
    if (e.target.closest('.delete-record')) {
        const button = e.target.closest('.delete-record');
        const index = parseInt(button.getAttribute('data-index'));
        handleDeleteRecord(index);
    }
    
    // Handle inline edit field clicks
    if (e.target.classList.contains('editable-field')) {
        const td = e.target;
        const fieldName = td.getAttribute('data-field');
        const recordIndex = parseInt(td.getAttribute('data-index'));
        startEditField(td, fieldName, recordIndex);
    }
});
// Add Enter key support
comparisonValue.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindComparison('greater');
});

comparisonValueLess.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindComparison('less');
});
// Add Enter key support
arrayCountInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmArrayCount();
});
// Add Enter key support
firstArraySizeElementWise.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmFirstArraySizeElementWise();
});
secondArraySizeElementWise.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmSecondArraySizeElementWise();
});
// Add Enter key support
logicalArraysCountInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmArraysCount();
});
// Add Enter key support
scalarValue.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleScalarOperation('add');
});
scalarValueSubtract.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleScalarOperation('subtract');
});
scalarValueMultiply.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleScalarOperation('multiply');
});
scalarValueDivide.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleScalarOperation('divide');
});
// Add Enter key support
logicalNotSize.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmLogicalNotSize();
});
logicalXorArrayCount.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmLogicalXorArrayCount();
});
// Add Enter key support - USING UPDATED VARIABLE NAME
numArraysInputField.addEventListener('keypress', (e) => { // Updated variable name
    if (e.key === 'Enter') handleConfirmNumArrays();
});
// Add Enter key support
pairDifferenceK.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCountPairsWithDifference();
});
// Add Enter key support
minSwapsK.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleMinSwaps();
});
// Add Enter key support for the method selection (optional)
missingRepeatingMethod.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindMissingRepeating();
});
// Add Enter key support
arraySize1.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmArraySizes();
});
arraySize2.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmArraySizes();
});
conditionValue.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmCondition();
});
// Add Enter key support
predicateCondition.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindByPredicate();
});
// Add Enter key support
typedArraySize.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmDataType();
});
// Add Enter key support
binCount.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleBinIntervals();
});
binWidth.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleBinByWidth();
});
// Add Enter key support for parameters
clampLow.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleApplyUfunc();
});
clampHigh.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleApplyUfunc();
});
euclidRef.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleApplyUfunc();
});
bitwiseOperand.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleApplyUfunc();
});
leakyReluAlpha.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleApplyUfunc();
});
// Enter key support for stock prices input
stockPricesInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleLoadStockPrices();
});
// Add Enter key support
matrixRowsInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCreateMatrix();
});
matrixColsInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCreateMatrix();
});
// Add Enter key support
parenthesesInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleValidParentheses();
});
// Add Enter key support
rangeSumStart.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleRangeSumQuery();
});
rangeSumEnd.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleRangeSumQuery();
});
// Add Enter key support
firstLastTarget.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindFirstLast();
});
// Add Enter key support
palindromeInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindPalindromicSubstrings();
});

longestPalindromeInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindLongestPalindromicSubstring();
});
// Add Enter key support
patternString.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmPatternMatching();
});
patternPattern.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmPatternMatching();
});
// Add Enter key support
combinationSumTarget.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmCombinationSum();
});
// Add Enter key support
lvpInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmParentheses();
});
dsMainStringInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmSubsequences();
});
dsTargetStringInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmSubsequences();
});
// Add Enter key support
textStringInputField.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleRunWordConcatSearch();
});
searchWordsInputField.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleRunWordConcatSearch();
});
nthUglyNumberInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindNthUglyNumber();
});
superUglyNInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindSuperUglyNumber();
});
superUglyPrimesInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindSuperUglyNumber();
});
uglyNumberInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCheckUglyNumber();
});
// Add Enter key support
pascalRowNumber.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handlePascalSpecificRow();
});
pascalNumRows.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handlePascalMultipleRows();
});
// Add Enter key support
consecutiveTargetSum.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindConsecutiveSequences();
});
// Add Enter key support
numberInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConvertToEnglish();
});
// Add Enter key support
stackSizeInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCreateStack();
});

pushValue.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handlePush();
});

popCount.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handlePop();
});
// Add Enter key support
streamSize.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleDesignOrderedStream();
});

streamIndex.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleInsertIntoStream();
});

streamValue.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleInsertIntoStream();
});
// Add Enter key support
deltaArraySizeInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmDeltaSize();
});
bwtString.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handlePerformBWT();
});
bwtSentinel.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handlePerformBWT();
});
mtfString.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handlePerformMTF();
});
// Add Enter key support
countAndSayTerms.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmCountAndSay();
});
stringToCompress.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmStringCompression();
});
// Add Enter key support
stringsInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleEncodeDecode();
});
delimiterInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleEncodeDecode();
});
logCountInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleSetLogCount();
});
// Enter key support for pattern search inputs
searchTextInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') executePatternSearch();
});
searchPatternInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') executePatternSearch();
});
wordInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleWordAbbrValidation();
});

abbrInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleWordAbbrValidation();
});
// Add Enter key support
wordArraySize.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmWordArraySize();
});

word1Input.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindShortestDistance();
});

word2Input.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindShortestDistance();
});
// Add Enter key support
nimArraySizeInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmNimSize();
});
// Add Enter key support
maxChoosableInteger.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCanIWin();
});
desiredTotal.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCanIWin();
});
// Add Enter key support
predictWinnerSizeInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmPredictWinnerSize();
});
// Add Enter key support
gasStationCount.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmGasStationCount();
});
// Add Enter key support
candyArraySize.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmCandySize();
});

// Add Enter key support
taskArraySize.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmTaskSize();
});
cooldownPeriod.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handlePerformTaskScheduling();
});

// Add Enter key support
partitionKValue.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handlePartitionArray();
});
// Add Enter key support
partitionLabelsStringInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handlePartitionLabelsOperation();
});
splitArrayK.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleSplitArrayLargestSum();
});
// Add Enter key support
document.getElementById('kConsecutiveValue').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleSequenceOperation('consecutive');
});
document.getElementById('kIncreasingValue').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleSequenceOperation('increasing');
});
document.getElementById('balancedStringInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleSequenceOperation('balanced');
});
// Add Enter key support
kDifferentIntegers.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleKDifferentIntegers();
});
// Add Enter key support
threeCharsInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmThreeChars();
});
// Add Enter key support
queueSizeInput.addEventListener('keypress', (e) => { // Updated to queueSizeInput
    if (e.key === 'Enter') handleConfirmQueueSize();
});

// Add Enter key support
document.getElementById('crawlerLogSize').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmCrawlerLogSize();
});
// Add Enter key support
hammingArraySize.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmHammingArraySize();
});
// Add Enter key support
grayCodeBits.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleGenerateGrayCode();
});
// Add Enter key support
thresholdValue.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleSmallestDivisor();
});
// Add Enter key support
capacityDaysInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmCapacity();
});
// Add Enter key support
kokoHoursInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleKokoBananas();
});

kokoPileCountInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmKokoPiles();
});
// Add Enter key support
versionCount.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFirstBadVersion();
});
// Add Enter key support
houseValues.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmHouseRobber();
});
// Add Enter key support
pairCountInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmPairCount();
});
// Add Enter key support
gridRows.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmUniquePaths();
});
gridCols.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmUniquePaths();
});
// Add Enter key support
coinCount.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmCoinCount();
});

targetAmountInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handlePerformCoinChange();
});
// Add Enter key support
decodeWaysInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleDecodeWays();
});
// Add Enter key support
wordBreakStringInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handlePerformWordBreak();
});
wordDictInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handlePerformWordBreak();
});
// Add Enter key support
maxRectangleSum.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleMaxRectangle();
});
// Add Enter key support
slidingWindowK.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmSlidingWindow();
});
// Add Enter key support
numEvents.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmNumEvents();
});

// Add keyboard shortcut for Shift+R
document.addEventListener('keydown', (e) => {
    if (e.shiftKey && e.key === 'R') {
        if (isLRUCacheRunning) {
            resetAfterLRUCache();
        }
    }
});

// Add keyboard shortcut for reset (Left Shift + R)
document.addEventListener('keydown', (e) => {
    if (e.key === 'R' && e.shiftKey && !e.ctrlKey && !e.altKey) {
        if (isStreamActive) {
            handleResetStream();
            showNotification('Ordered Stream reset using keyboard shortcut', 'info');
        }
    }
});
// Add Enter key support
superstringCount.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleShortestSuperstring();
});
// Add Enter key support
targetSumInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleTargetSum();
});

document.addEventListener('keydown', (e) => {
    // Left Shift + X: Stop current animation
    if (e.shiftKey && e.key === 'X') {
        if (isStackOperationRunning) {
            stopStackAnimation();
        }
    }
    
    // Left Shift + R: Reset to original position
    if (e.shiftKey && e.key === 'R') {
        if (stack) {
            handleResetStack();
            showNotification('Reset to original position (Shift+R)', 'info');
        } else if (isStackOperationRunning) {
            stopStackAnimation();
            setTimeout(() => {
                if (stack) {
                    handleResetStack();
                    showNotification('Reset to original position (Shift+R)', 'info');
                }
            }, 500);
        }
    }
});
// Add keyboard shortcut for Left Shift + R to reset to original array
document.addEventListener('keydown', (e) => {
    if (e.shiftKey && e.key === 'R') {
        // Check if we're in LFU mode
        if (isLFURunning) {
            handleLFUBack();
        }
        // Also reset the main array if not in subarray mode
        else if (!isSubarray && originalArray.length > 0) {
            handleResetArray();
        }
    }
});
// Add keyboard shortcut for reset (Left Shift + R)
document.addEventListener('keydown', function(e) {
    if (e.shiftKey && e.key === 'R') {
        if (isQueueOperationRunning) {
            resetAfterQueueOperation();
        }
    }
});
// Add Enter key support
queueSizeInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleInitializeQueue();
});
enqueueValue.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleEnqueue();
});
enqueuePriority.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleEnqueue();
});

// Add Enter key support
shiftedStringsSize.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmShiftedStringsSize();
});
flipGameInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handlePerformFlipGame();
});
// Add Enter key support
niceSubarrayK.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCountNiceSubarrays();
});

// Add keyboard shortcut for reset (Left Shift + R)
document.addEventListener('keydown', (e) => {
    if (e.shiftKey && e.key === 'R') {
        if (isPriorityQueueRunning) {
            handleResetQueue();
        }
    }
});

     // Operation Handlers
        function handleCreate() {
            const value = createValue.value.trim();
            if (value === '') {
                showNotification('Please enter a value to add', 'warning');
                createValue.focus();
                return;
            }
            
            myArray.push(value);
            createValue.value = '';
            renderArray();
            highlightElement(myArray.length - 1, 'create');
            updateStats();
            logOperation(`Added "${value}" to the array`, 'success');
        }
        
        function handleCreateRandom() {
            const randomValues = ['Apple', 'Banana', 'Cherry', 'Date', 'Elderberry', 'Fig', 'Grape', 'Honeydew'];
            const randomValue = randomValues[Math.floor(Math.random() * randomValues.length)];
            myArray.push(randomValue);
            renderArray();
            highlightElement(myArray.length - 1, 'create');
            updateStats();
            logOperation(`Added random value "${randomValue}" to the array`, 'success');
        }
        // NEW: Create Array from Range (0 to n-1)
function handleCreateArrayFromRange() {
    const size = parseInt(arraySize.value);
    
    if (isNaN(size) || size < 1 || size > 50) {
        showNotification('Please enter a valid size between 1 and 50', 'danger');
        arraySize.focus();
        return;
    }
    
    // Create array from 0 to size-1
    myArray = Array.from({length: size}, (_, i) => i.toString());
    
    renderArray();
    updateStats();
    arraySize.value = '';
    
    // Animate all elements
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation(`Created new array with ${size} elements (0 to ${size-1})`, 'success');
}

// NEW: Resize Array (Dynamic resizing)
function handleResizeArray() {
    const newSize = parseInt(resizeSize.value);
    
    if (isNaN(newSize) || newSize < 1 || newSize > 100) {
        showNotification('Please enter a valid size between 1 and 100', 'danger');
        resizeSize.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please create an array first.', 'warning');
        return;
    }
    
    const oldSize = myArray.length;
    
    if (newSize === oldSize) {
        showNotification(`Array is already size ${newSize}`, 'info');
        return;
    }
    
    if (newSize > oldSize) {
        // Extend the array - preserve existing elements and add new ones
        const currentLength = myArray.length;
        for (let i = currentLength; i < newSize; i++) {
            myArray.push(i.toString()); // Add sequential numbers for new elements
        }
        
        renderArray();
        updateStats();
        
        // Animate only the new elements
        setTimeout(() => {
            for (let i = oldSize; i < newSize; i++) {
                highlightElement(i, 'create');
            }
        }, 100);
        
        logOperation(`Resized array from ${oldSize} to ${newSize} (extended by ${newSize - oldSize} elements)`, 'success');
        
    } else {
        // Shrink the array - remove elements from the end
        const removedElements = myArray.slice(newSize);
        myArray.length = newSize;
        
        renderArray();
        updateStats();
        
        logOperation(`Resized array from ${oldSize} to ${newSize} (removed ${oldSize - newSize} elements: ${removedElements.join(', ')})`, 'warning');
    }
    
    resizeSize.value = '';
}
// NEW: Create Subarray (Slice) Handler
function handleSlice() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    const start = sliceStart.value === '' ? 0 : parseInt(sliceStart.value);
    const end = sliceEnd.value === '' ? myArray.length : parseInt(sliceEnd.value);
    
    if (isNaN(start) || start < 0 || start >= myArray.length) {
        showNotification('Please enter a valid start index', 'danger');
        sliceStart.focus();
        return;
    }
    
    if (end !== '' && (isNaN(end) || end < start || end > myArray.length)) {
        showNotification('Please enter a valid end index', 'danger');
        sliceEnd.focus();
        return;
    }
    
    // Store original array if this is the first slice operation
    if (!isSubarray) {
        originalArray = [...myArray];
    }
    
    // Create subarray
    const subarray = myArray.slice(start, end);
    
    if (subarray.length === 0) {
        showNotification('The subarray is empty. Please select different indices.', 'warning');
        return;
    }
    
    // Update the array and render
    myArray = subarray;
    isSubarray = true;
    renderArray();
    updateStats();
    
    // Clear inputs
    sliceStart.value = '';
    sliceEnd.value = '';
    
    // Highlight all elements in the subarray
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'search');
        });
    }, 100);
    
    logOperation(`Created subarray from index ${start} to ${end === '' ? myArray.length : end}`, 'success');
}

// NEW: Reset to Original Array Handler
// Update the existing handleResetArray function
function handleResetArray() {
    if ((!isSubarray && !isCurrentlySorted) || (originalArray.length === 0 && sortedArrayBackup.length === 0)) {
        showNotification('No original array to reset to', 'info');
        return;
    }
    
    // Reset from subarray OR from sorted state (binary search)
    if (isSubarray && originalArray.length > 0) {
        myArray = [...originalArray];
        isSubarray = false;
        originalArray = [];
    } else if (isCurrentlySorted && sortedArrayBackup.length > 0) {
        myArray = [...sortedArrayBackup];
        isCurrentlySorted = false;
        sortedArrayBackup = [];
    }
    
    renderArray();
    updateStats();
    
    // Highlight all elements
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation('Reset to original array', 'info');
}

        function handleInsert() {
            const index = parseInt(insertIndex.value);
            const value = insertValue.value.trim();
            
            if (isNaN(index) || index < 0 || index > myArray.length) {
                showNotification('Please enter a valid index', 'danger');
                insertIndex.focus();
                return;
            }
            
            if (value === '') {
                showNotification('Please enter a value to insert', 'warning');
                insertValue.focus();
                return;
            }
            
            myArray.splice(index, 0, value);
            renderArray();
            highlightElement(index, 'create');
            updateStats();
            insertIndex.value = '';
            insertValue.value = '';
            logOperation(`Inserted "${value}" at index ${index}`, 'success');
        }
        
        function handleRead() {
            const index = parseInt(readIndex.value);
            if (isNaN(index) || index < 0 || index >= myArray.length) {
                showNotification('Please enter a valid index', 'danger');
                readIndex.focus();
                return;
            }
            
            highlightElement(index, 'read');
            readIndex.value = '';
            logOperation(`Read value at index ${index}: "${myArray[index]}"`, 'info');
        }
        
        function handleUpdate() {
            const index = parseInt(updateIndex.value);
            const value = updateValue.value.trim();
            
            if (isNaN(index) || index < 0 || index >= myArray.length) {
                showNotification('Please enter a valid index', 'danger');
                updateIndex.focus();
                return;
            }
            
            if (value === '') {
                showNotification('Please enter a new value', 'warning');
                updateValue.focus();
                return;
            }
            
            const oldValue = myArray[index];
            myArray[index] = value;
            renderArray();
            highlightElement(index, 'update');
            updateStats();
            updateIndex.value = '';
            updateValue.value = '';
            logOperation(`Updated index ${index} from "${oldValue}" to "${value}"`, 'warning');
        }
        
      function handleUpdateByElement() {
    const element = updateElement.value.trim();
    const newValue = updateNewValue.value.trim();
    
    if (element === '') {
        showNotification('Please enter an element to update', 'warning');
        updateElement.focus();
        return;
    }
    
    if (newValue === '') {
        showNotification('Please enter a new value', 'warning');
        updateNewValue.focus();
        return;
    }
    
    // Try to preserve type when searching
    const indices = [];
    const elementToUpdate = !isNaN(element) ? Number(element) : element;
    const newElementValue = !isNaN(newValue) ? Number(newValue) : newValue;
    
    for (let i = 0; i < myArray.length; i++) {
        // Try both string and number comparison for better matching
        if (myArray[i] === elementToUpdate || 
            (typeof myArray[i] === 'number' && myArray[i] === Number(element)) ||
            (typeof myArray[i] === 'string' && myArray[i] === element)) {
            indices.push(i);
            myArray[i] = newElementValue;
        }
    }
    
    if (indices.length === 0) {
        showNotification(`Element "${element}" not found in the array`, 'danger');
        return;
    }
    
    renderArray();
    indices.forEach(index => highlightElement(index, 'update'));
    updateStats();
    updateElement.value = '';
    updateNewValue.value = '';
    logOperation(`Updated ${indices.length} occurrence(s) of "${element}" to "${newValue}"`, 'warning');
}
        function handleDelete() {
            const index = parseInt(deleteIndex.value);
            if (isNaN(index) || index < 0 || index >= myArray.length) {
                showNotification('Please enter a valid index', 'danger');
                deleteIndex.focus();
                return;
            }
            
            const deletedValue = myArray[index];
            highlightElement(index, 'delete', () => {
                myArray.splice(index, 1);
                renderArray();
                updateStats();
                deleteIndex.value = '';
                logOperation(`Deleted value "${deletedValue}" at index ${index}`, 'danger');
            });
        }
        
       function handleDeleteByElement() {
    const element = deleteElement.value.trim();
    if (element === '') {
        showNotification('Please enter an element to delete', 'warning');
        deleteElement.focus();
        return;
    }
    
    // Check if array contains numbers and convert input accordingly
    const arrayContainsNumbers = myArray.length > 0 && 
        typeof myArray[0] === 'number';
    
    const searchElement = arrayContainsNumbers && !isNaN(element) 
        ? Number(element) 
        : element;
    
    const indices = [];
    for (let i = myArray.length - 1; i >= 0; i--) {
        if (myArray[i] === searchElement) {
            indices.push(i);
        }
    }
    
    if (indices.length === 0) {
        showNotification(`Element "${element}" not found in the array`, 'danger');
        return;
    }

            
            // Animate deletion of all matching elements
            let deletedCount = 0;
            indices.forEach((index, i) => {
                setTimeout(() => {
                    highlightElement(index, 'delete', () => {
                        myArray.splice(index, 1);
                        deletedCount++;
                        
                        if (deletedCount === indices.length) {
                            renderArray();
                            updateStats();
                            deleteElement.value = '';
                            logOperation(`Deleted ${indices.length} occurrence(s) of "${element}"`, 'danger');
                        }
                    });
                }, i * 300);
            });
        }
        
function handleClearArray() {
    if (myArray.length === 0) {
        showNotification('Array is already empty', 'info');
        return;
    }
    
    // Animate removal of all elements
    const elements = document.querySelectorAll('.array-element');
    elements.forEach((element, index) => {
        setTimeout(() => {
            element.classList.add('slide-out');
        }, index * 100);
    });
    
    setTimeout(() => {
        myArray = [];
        originalArray = []; // Reset original array
        originalArrayForShift = []; // Reset shift array
        isSubarray = false; // Reset subarray flag
        isShifted = false; // Reset shift flag
        renderArray();
        updateStats();
        logOperation('Cleared the entire array', 'danger');
    }, elements.length * 100 + 500);
}
 function handleSearch() {
    // Check if array is properly initialized
    if (!myArray || myArray.length === 0) {
        showNotification('Array is empty. Please initialize array first.', 'warning');
        return;
    }
    
    const element = searchElement.value.trim();
    if (element === '') {
        showNotification('Please enter an element to search', 'warning');
        searchElement.focus();
        return;
    }
    
    // Convert search element to number if array contains numbers
    let searchValue = element;
    if (myArray.every(item => typeof item === 'number' || !isNaN(item))) {
        searchValue = !isNaN(element) ? Number(element) : element;
    }
    
    const indices = [];
    for (let i = 0; i < myArray.length; i++) {
        // Use loose equality to handle number-string comparisons
        if (myArray[i] == searchValue) {
            indices.push(i);
        }
    }
    
    if (indices.length === 0) {
        searchResults.innerHTML = `<p class="text-center mb-0 text-danger">Element "${element}" not found in the array</p>`;
        showNotification(`Element "${element}" not found`, 'error');
        
        // Blink all elements in red for "not found"
        blinkAllElements('error', 5000);
        return;
    }
    
    // Highlight found elements with blinking effect
    indices.forEach(index => highlightElement(index, 'search'));
    
    // Start blinking animation for found elements
    blinkFoundElements(indices, 5000);
    
    // Display results with green success message
    searchResults.innerHTML = `
        <p class="mb-2 text-success">Found "${element}" at ${indices.length} position(s):</p>
        <p class="mb-0">${indices.map(i => `Index [${i}]`).join(', ')}</p>
    `;
    
    searchElement.value = '';
    showNotification(`Element "${element}" found at ${indices.length} position(s)`, 'success');
    logOperation(`Searched for "${element}" - found at indices: ${indices.join(', ')}`, 'info');
}

// Function to blink found elements for specified duration
function blinkFoundElements(indices, duration) {
    const elements = document.querySelectorAll('.array-element');
    let blinkCount = 0;
    const maxBlinks = 10; // Blink 10 times over 5 seconds (500ms each)
    
    const blinkInterval = setInterval(() => {
        indices.forEach(index => {
            if (elements[index]) {
                if (blinkCount % 2 === 0) {
                    elements[index].style.backgroundColor = '#28a745'; // Green
                    elements[index].style.color = 'white';
                    elements[index].style.transform = 'scale(1.1)';
                    elements[index].style.boxShadow = '0 0 10px #28a745';
                } else {
                    elements[index].style.backgroundColor = '';
                    elements[index].style.color = '';
                    elements[index].style.transform = '';
                    elements[index].style.boxShadow = '';
                }
            }
        });
        
        blinkCount++;
        if (blinkCount >= maxBlinks) {
            clearInterval(blinkInterval);
            // Reset to normal highlight after blinking
            setTimeout(() => {
                indices.forEach(index => highlightElement(index, 'search'));
            }, 100);
        }
    }, duration / maxBlinks); // Calculate interval for even blinking
}

// Function to blink all elements in red for "not found"
function blinkAllElements(type, duration) {
    const elements = document.querySelectorAll('.array-element');
    let blinkCount = 0;
    const maxBlinks = 10;
    
    const originalStyles = [];
    elements.forEach((element, index) => {
        originalStyles[index] = {
            backgroundColor: element.style.backgroundColor,
            color: element.style.color,
            transform: element.style.transform,
            boxShadow: element.style.boxShadow
        };
    });
    
    const blinkInterval = setInterval(() => {
        elements.forEach((element, index) => {
            if (blinkCount % 2 === 0) {
                element.style.backgroundColor = type === 'error' ? '#dc3545' : '#ffc107';
                element.style.color = 'white';
                element.style.transform = 'scale(1.05)';
                element.style.boxShadow = type === 'error' ? '0 0 10px #dc3545' : '0 0 10px #ffc107';
            } else {
                element.style.backgroundColor = originalStyles[index].backgroundColor;
                element.style.color = originalStyles[index].color;
                element.style.transform = originalStyles[index].transform;
                element.style.boxShadow = originalStyles[index].boxShadow;
            }
        });
        
        blinkCount++;
        if (blinkCount >= maxBlinks) {
            clearInterval(blinkInterval);
            // Reset to original styles
            setTimeout(() => {
                elements.forEach((element, index) => {
                    element.style.backgroundColor = originalStyles[index].backgroundColor;
                    element.style.color = originalStyles[index].color;
                    element.style.transform = originalStyles[index].transform;
                    element.style.boxShadow = originalStyles[index].boxShadow;
                });
            }, 100);
        }
    }, duration / maxBlinks);
}

// Update showNotification function to support success and error colors
function showNotification(message, type = 'info') {
    // Remove any existing notifications
    const existingNotification = document.querySelector('.custom-notification');
    if (existingNotification) {
        existingNotification.remove();
    }
    
    const notification = document.createElement('div');
    notification.className = `custom-notification alert alert-${type === 'error' ? 'danger' : type} fade show`;
    notification.innerHTML = `
        <strong>${type === 'success' ? '' : type === 'error' ? '' : ''}</strong> ${message}
    `;
    
    // Add styles for positioning
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1000;
        min-width: 300px;
        animation: slideInRight 0.3s ease-out;
    `;
    
    document.body.appendChild(notification);
    
    // Auto remove after 5 seconds
    setTimeout(() => {
        if (notification.parentNode) {
            notification.remove();
        }
    }, 5000);
}

// Improved sample data initialization
setTimeout(() => {
    myArray = [1, 2, 3, 4];
    originalArray = [...myArray]; // Keep a copy of original array
    isSubarray = false;
    renderArray();
    updateStats();
    logOperation('Array initialized with sample data: [1, 2, 3, 4]', 'info');
    showNotification('Sample array loaded successfully!', 'success');
}, 1000);
        
        function handleSearchByIndex() {
            const index = parseInt(searchIndex.value);
            if (isNaN(index) || index < 0 || index >= myArray.length) {
                showNotification('Please enter a valid index', 'danger');
                searchIndex.focus();
                return;
            }
            
            const value = myArray[index];
            highlightElement(index, 'search');
            
            // Display results
            searchResults.innerHTML = `
                <p class="mb-0">Value at index ${index} is: "${value}"</p>
            `;
            
            searchIndex.value = '';
            logOperation(`Searched index ${index} - found: "${value}"`, 'info');
        }
        
       // NEW: Linear Search Handler
function handleLinearSearch() {
    if (isLinearSearchRunning) {
        showNotification('A linear search is already in progress', 'warning');
        return;
    }
    
    const element = linearSearchElement.value.trim();
    if (element === '') {
        showNotification('Please enter an element to search', 'warning');
        linearSearchElement.focus();
        return;
    }
    
    if (!myArray || myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    isLinearSearchRunning = true;
    linearSearchBtn.disabled = true;
    
    // Reset algorithm steps highlighting
    const steps = algorithmSteps.querySelectorAll('.algorithm-step');
    steps.forEach(step => step.classList.remove('active'));
    
    // Reset all elements to normal state
    const elements = document.querySelectorAll('.array-element');
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('linear-search-current', 'linear-search-checked', 'linear-search-found');
    });
    
    searchResults.innerHTML = '<p class="text-center mb-0">Starting linear search...</p>';
    
    // Convert search element to number if array contains numbers
    let searchValue = element;
    if (myArray.every(item => typeof item === 'number' || !isNaN(item))) {
        searchValue = !isNaN(element) ? Number(element) : element;
    }
    
    // Perform linear search with visualization
    performLinearSearch(searchValue, 0);
}

// NEW: Perform Linear Search with Step-by-Step Visualization
function performLinearSearch(target, currentIndex) {
    if (currentIndex >= myArray.length) {
        // Element not found
        searchResults.innerHTML = `<p class="text-center mb-0 text-danger">Element "${target}" not found in the array</p>`;
        logOperation(`Linear search for "${target}" - not found`, 'info');
        
        // Blink all elements in red for "not found"
        blinkAllElements('error', 5000);
        
        // Show red notification
        showNotification(`Element "${target}" not found`, 'error');
        
        // Reset after 5 seconds
        setTimeout(() => {
            const elements = document.querySelectorAll('.array-element');
            elements.forEach(el => {
                const valueDiv = el.querySelector('.element-value');
                valueDiv.classList.remove('linear-search-current', 'linear-search-checked', 'linear-search-found');
            });
            
            isLinearSearchRunning = false;
            linearSearchBtn.disabled = false;
            linearSearchElement.value = '';
        }, 5000);
        
        return;
    }
    
    // Update algorithm steps
    const steps = algorithmSteps.querySelectorAll('.algorithm-step');
    steps.forEach(step => step.classList.remove('active'));
    
    if (currentIndex === 0) {
        steps[0].classList.add('active'); // Step 1: Start from first element
    } else {
        steps[3].classList.add('active'); // Step 4: Move to next element
    }
    
    // Highlight current element being checked
    const elements = document.querySelectorAll('.array-element');
    const currentElement = elements[currentIndex];
    const valueDiv = currentElement.querySelector('.element-value');
    
    // Mark previous elements as checked
    for (let i = 0; i < currentIndex; i++) {
        const prevElement = elements[i];
        const prevValueDiv = prevElement.querySelector('.element-value');
        prevValueDiv.classList.remove('linear-search-current');
        prevValueDiv.classList.add('linear-search-checked');
    }
    
    // Highlight current element
    valueDiv.classList.remove('linear-search-checked');
    valueDiv.classList.add('linear-search-current');
    
    // Update search results
    searchResults.innerHTML = `
        <p class="mb-1">Searching for "${target}"...</p>
        <p class="mb-1">Checking index ${currentIndex}: "${myArray[currentIndex]}"</p>
        <p class="mb-0">Comparisons made: ${currentIndex + 1}</p>
    `;
    
    steps[1].classList.add('active'); // Step 2: Compare current element with target
    
    // Use loose equality to handle number-string comparisons for sample array
    const isMatch = myArray[currentIndex] == target;
    
    // Check if current element matches target
    if (isMatch) {
        // Element found
        setTimeout(() => {
            valueDiv.classList.remove('linear-search-current');
            valueDiv.classList.add('linear-search-found');
            
            steps[2].classList.add('active'); // Step 3: Match found
            
            searchResults.innerHTML = `
                <p class="mb-1 text-success">Element "${target}" found at index ${currentIndex}!</p>
                <p class="mb-1">Total comparisons: ${currentIndex + 1}</p>
                <p class="mb-0">Time complexity: O(n) - linear time</p>
            `;
            
            logOperation(`Linear search found "${target}" at index ${currentIndex} after ${currentIndex + 1} comparisons`, 'success');
            
            // Blink found element in green for 5 seconds
            blinkFoundElement(currentIndex, 5000);
            
            // Show green success notification
            showNotification(`Element "${target}" found at index ${currentIndex}`, 'success');
            
            // Reset after 5 seconds
            setTimeout(() => {
                valueDiv.classList.remove('linear-search-found');
                isLinearSearchRunning = false;
                linearSearchBtn.disabled = false;
                linearSearchElement.value = '';
                
                // Reset all elements to original state
                const allElements = document.querySelectorAll('.array-element');
                allElements.forEach(el => {
                    const valDiv = el.querySelector('.element-value');
                    valDiv.classList.remove('linear-search-current', 'linear-search-checked', 'linear-search-found');
                });
            }, 5000);
            
        }, 1000);
    } else {
        // Move to next element
        setTimeout(() => {
            performLinearSearch(target, currentIndex + 1);
        }, 1500);
    }
}

// Function to blink found element in green
function blinkFoundElement(index, duration) {
    const elements = document.querySelectorAll('.array-element');
    const foundElement = elements[index];
    const valueDiv = foundElement.querySelector('.element-value');
    
    let blinkCount = 0;
    const maxBlinks = 10; // Blink 10 times over 5 seconds (500ms each)
    
    const blinkInterval = setInterval(() => {
        if (blinkCount % 2 === 0) {
            valueDiv.style.backgroundColor = '#28a745'; // Green
            valueDiv.style.color = 'white';
            valueDiv.style.transform = 'scale(1.2)';
            valueDiv.style.boxShadow = '0 0 15px #28a745';
        } else {
            valueDiv.style.backgroundColor = '';
            valueDiv.style.color = '';
            valueDiv.style.transform = '';
            valueDiv.style.boxShadow = '';
        }
        
        blinkCount++;
        if (blinkCount >= maxBlinks) {
            clearInterval(blinkInterval);
            // Reset to normal after blinking
            setTimeout(() => {
                valueDiv.style.backgroundColor = '';
                valueDiv.style.color = '';
                valueDiv.style.transform = '';
                valueDiv.style.boxShadow = '';
            }, 100);
        }
    }, duration / maxBlinks);
}

// Function to blink all elements in red for "not found"
function blinkAllElements(type, duration) {
    const elements = document.querySelectorAll('.array-element');
    let blinkCount = 0;
    const maxBlinks = 10;
    
    const blinkInterval = setInterval(() => {
        elements.forEach((element) => {
            const valueDiv = element.querySelector('.element-value');
            if (blinkCount % 2 === 0) {
                valueDiv.style.backgroundColor = '#dc3545'; // Red
                valueDiv.style.color = 'white';
                valueDiv.style.transform = 'scale(1.1)';
                valueDiv.style.boxShadow = '0 0 10px #dc3545';
            } else {
                valueDiv.style.backgroundColor = '';
                valueDiv.style.color = '';
                valueDiv.style.transform = '';
                valueDiv.style.boxShadow = '';
            }
        });
        
        blinkCount++;
        if (blinkCount >= maxBlinks) {
            clearInterval(blinkInterval);
            // Reset to original styles
            setTimeout(() => {
                elements.forEach((element) => {
                    const valueDiv = element.querySelector('.element-value');
                    valueDiv.style.backgroundColor = '';
                    valueDiv.style.color = '';
                    valueDiv.style.transform = '';
                    valueDiv.style.boxShadow = '';
                });
            }, 100);
        }
    }, duration / maxBlinks);
}

// Improved sample data initialization
setTimeout(() => {
    myArray = [1, 2, 3, 4];
    originalArray = [...myArray]; // Keep a copy of original array
    isSubarray = false;
    renderArray();
    updateStats();
    logOperation('Array initialized with sample data: [1, 2, 3, 4]', 'info');
    showNotification('Sample array loaded successfully!', 'success');
}, 1000);

 // NEW: Binary Search Handler
// NEW: Binary Search Handler
function handleBinarySearch() {
    if (isBinarySearchRunning) {
        showNotification('A binary search is already in progress', 'warning');
        return;
    }
    
    const element = binarySearchElement.value.trim();
    if (element === '') {
        showNotification('Please enter an element to search', 'warning');
        binarySearchElement.focus();
        return;
    }
    
    if (!myArray || myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    isBinarySearchRunning = true;
    binarySearchBtn.disabled = true;
    
    // Reset algorithm steps highlighting
    const steps = binarySearchSteps.querySelectorAll('.algorithm-step');
    steps.forEach(step => step.classList.remove('active'));
    
    // Convert search element to number if array contains numbers
    let searchValue = element;
    if (myArray.every(item => typeof item === 'number' || !isNaN(item))) {
        searchValue = !isNaN(element) ? Number(element) : element;
    }
    
    // Check if array needs sorting
    if (!isArraySorted(myArray)) {
        showNotification('Array is not sorted. Auto-sorting for binary search...', 'warning');
        
        // Backup original array
        sortedArrayBackup = [...myArray];
        
        // Sort the array (numerically if possible, otherwise lexicographically)
        myArray.sort((a, b) => {
            const numA = parseFloat(a);
            const numB = parseFloat(b);
            if (!isNaN(numA) && !isNaN(numB)) {
                return numA - numB;
            }
            return a.toString().localeCompare(b.toString());
        });
        
        isCurrentlySorted = true;
        renderArray();
        
        // Highlight that array was sorted
        setTimeout(() => {
            myArray.forEach((_, index) => {
                highlightElement(index, 'update');
            });
            
            // Start binary search after sorting animation
            setTimeout(() => {
                performBinarySearch(searchValue, 0, myArray.length - 1);
            }, 1000);
        }, 500);
        
    } else {
        // Array is already sorted, proceed with binary search
        performBinarySearch(searchValue, 0, myArray.length - 1);
    }
}

// NEW: Check if array is sorted
function isArraySorted(arr) {
    for (let i = 1; i < arr.length; i++) {
        const current = parseFloat(arr[i]);
        const prev = parseFloat(arr[i-1]);
        
        if (!isNaN(current) && !isNaN(prev)) {
            // Numeric comparison
            if (current < prev) return false;
        } else {
            // String comparison
            if (arr[i] < arr[i-1]) return false;
        }
    }
    return true;
}

// NEW: Perform Binary Search with Visualization
function performBinarySearch(target, left, right) {
    if (left > right) {
        // Element not found
        searchResults.innerHTML = `<p class="text-center mb-0 text-danger">Element "${target}" not found in the array</p>`;
        logOperation(`Binary search for "${target}" - not found`, 'info');
        
        // Blink all elements in red for "not found"
        blinkAllElements('error', 5000);
        
        // Show red notification
        showNotification(`Element "${target}" not found`, 'error');
        
        // Restore original array if it was sorted for this search
        restoreOriginalArrayAfterDelay(10000);
        
        // Reset search state
        setTimeout(() => {
            resetBinarySearchState();
        }, 5000);
        
        return;
    }
    
    const mid = Math.floor((left + right) / 2);
    const steps = binarySearchSteps.querySelectorAll('.algorithm-step');
    
    // Reset all steps
    steps.forEach(step => step.classList.remove('active'));
    
    // Update current step
    if (left === 0 && right === myArray.length - 1) {
        steps[1].classList.add('active'); // Step 2: Set left and right bounds
    } else {
        steps[2].classList.add('active'); // Step 3: Calculate mid
    }
    
    // Highlight current search space
    highlightBinarySearchSpace(left, right, mid);
    
    // Update search results
    searchResults.innerHTML = `
        <p class="mb-1">Searching for "${target}"...</p>
        <p class="mb-1">Search space: indices ${left} to ${right}</p>
        <p class="mb-1">Checking mid index ${mid}: "${myArray[mid]}"</p>
        <p class="mb-0">Comparisons made: ${getBinarySearchComparisons(left, right)}</p>
    `;
    
    steps[3].classList.add('active'); // Step 4: Compare element at mid with target
    
    setTimeout(() => {
        // Use loose equality to handle number-string comparisons for sample array
        const isMatch = myArray[mid] == target;
        
        if (isMatch) {
            // Element found
            highlightBinarySearchFound(mid);
            
            steps[4].classList.add('active'); // Step 5: Match found
            
            searchResults.innerHTML = `
                <p class="mb-1 text-success">Element "${target}" found at index ${mid}!</p>
                <p class="mb-1">Total comparisons: ${getBinarySearchComparisons(left, right)}</p>
                <p class="mb-0">Time complexity: O(log n) - logarithmic time</p>
            `;
            
            logOperation(`Binary search found "${target}" at index ${mid}`, 'success');
            
            // Blink found element in green for 5 seconds
            blinkFoundElement(mid, 5000);
            
            // Show green success notification
            showNotification(`Element "${target}" found at index ${mid}`, 'success');
            
            // Restore original array if it was sorted for this search
            restoreOriginalArrayAfterDelay(10000);
            
            // Reset after 5 seconds
            setTimeout(() => {
                resetBinarySearchState();
            }, 5000);
            
        } else {
            // Continue search
            const currentValue = myArray[mid];
            const numTarget = parseFloat(target);
            const numCurrent = parseFloat(currentValue);
            
            let newLeft = left, newRight = right;
            
            if (!isNaN(numTarget) && !isNaN(numCurrent)) {
                // Numeric comparison
                if (numTarget > numCurrent) {
                    steps[5].classList.add('active'); // Step 6: Search right half
                    newLeft = mid + 1;
                } else {
                    steps[6].classList.add('active'); // Step 7: Search left half
                    newRight = mid - 1;
                }
            } else {
                // String comparison
                if (target > currentValue) {
                    steps[5].classList.add('active');
                    newLeft = mid + 1;
                } else {
                    steps[6].classList.add('active');
                    newRight = mid - 1;
                }
            }
            
            steps[7].classList.add('active'); // Step 8: Repeat
            
            // Continue search with new bounds
            setTimeout(() => {
                performBinarySearch(target, newLeft, newRight);
            }, 1500);
        }
    }, 1000);
}

// NEW: Helper function to restore original array after delay
function restoreOriginalArrayAfterDelay(delay) {
    if (sortedArrayBackup && sortedArrayBackup.length > 0) {
        setTimeout(() => {
            myArray = [...sortedArrayBackup];
            sortedArrayBackup = [];
            isCurrentlySorted = false;
            renderArray();
            updateStats();
            showNotification('Array restored to original order', 'info');
            logOperation('Array restored to original order after binary search', 'info');
        }, delay);
    }
}

// NEW: Helper function to highlight binary search space
function highlightBinarySearchSpace(left, right, mid) {
    const elements = document.querySelectorAll('.array-element');
    
    // Reset all elements
    elements.forEach((el, index) => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('binary-search-left', 'binary-search-right', 'binary-search-mid', 'binary-search-found');
        
        if (index >= left && index <= right) {
            // In current search space
            if (index === mid) {
                valueDiv.classList.add('binary-search-mid');
            } else if (index < mid) {
                valueDiv.classList.add('binary-search-left');
            } else {
                valueDiv.classList.add('binary-search-right');
            }
        }
    });
}

// NEW: Helper function to highlight found element
function highlightBinarySearchFound(index) {
    const elements = document.querySelectorAll('.array-element');
    const valueDiv = elements[index].querySelector('.element-value');
    valueDiv.classList.remove('binary-search-mid', 'binary-search-left', 'binary-search-right');
    valueDiv.classList.add('binary-search-found');
}

// NEW: Calculate binary search comparisons
function getBinarySearchComparisons(left, right) {
    // This is a simplified calculation for demonstration
    return Math.floor(Math.log2(right - left + 1)) + 1;
}

// NEW: Reset binary search state
function resetBinarySearchState() {
    isBinarySearchRunning = false;
    binarySearchBtn.disabled = false;
    binarySearchElement.value = '';
    
    // Reset all binary search highlights
    const elements = document.querySelectorAll('.array-element');
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('binary-search-left', 'binary-search-right', 'binary-search-mid', 'binary-search-found');
    });
}

// Function to blink found element in green
function blinkFoundElement(index, duration) {
    const elements = document.querySelectorAll('.array-element');
    const foundElement = elements[index];
    const valueDiv = foundElement.querySelector('.element-value');
    
    let blinkCount = 0;
    const maxBlinks = 10; // Blink 10 times over 5 seconds (500ms each)
    
    const blinkInterval = setInterval(() => {
        if (blinkCount % 2 === 0) {
            valueDiv.style.backgroundColor = '#28a745'; // Green
            valueDiv.style.color = 'white';
            valueDiv.style.transform = 'scale(1.2)';
            valueDiv.style.boxShadow = '0 0 15px #28a745';
        } else {
            valueDiv.style.backgroundColor = '';
            valueDiv.style.color = '';
            valueDiv.style.transform = '';
            valueDiv.style.boxShadow = '';
        }
        
        blinkCount++;
        if (blinkCount >= maxBlinks) {
            clearInterval(blinkInterval);
            // Reset to normal after blinking
            setTimeout(() => {
                valueDiv.style.backgroundColor = '';
                valueDiv.style.color = '';
                valueDiv.style.transform = '';
                valueDiv.style.boxShadow = '';
            }, 100);
        }
    }, duration / maxBlinks);
}

// Function to blink all elements in red for "not found"
function blinkAllElements(type, duration) {
    const elements = document.querySelectorAll('.array-element');
    let blinkCount = 0;
    const maxBlinks = 10;
    
    const blinkInterval = setInterval(() => {
        elements.forEach((element) => {
            const valueDiv = element.querySelector('.element-value');
            if (blinkCount % 2 === 0) {
                valueDiv.style.backgroundColor = '#dc3545'; // Red
                valueDiv.style.color = 'white';
                valueDiv.style.transform = 'scale(1.1)';
                valueDiv.style.boxShadow = '0 0 10px #dc3545';
            } else {
                valueDiv.style.backgroundColor = '';
                valueDiv.style.color = '';
                valueDiv.style.transform = '';
                valueDiv.style.boxShadow = '';
            }
        });
        
        blinkCount++;
        if (blinkCount >= maxBlinks) {
            clearInterval(blinkInterval);
            // Reset to original styles
            setTimeout(() => {
                elements.forEach((element) => {
                    const valueDiv = element.querySelector('.element-value');
                    valueDiv.style.backgroundColor = '';
                    valueDiv.style.color = '';
                    valueDiv.style.transform = '';
                    valueDiv.style.boxShadow = '';
                });
            }, 100);
        }
    }, duration / maxBlinks);
}

// Improved sample data initialization
setTimeout(() => {
    myArray = [1, 2, 3, 4];
    originalArray = [...myArray]; // Keep a copy of original array
    isSubarray = false;
    renderArray();
    updateStats();
    logOperation('Array initialized with sample data: [1, 2, 3, 4]', 'info');
    showNotification('Sample array loaded successfully!', 'success');
}, 1000);
// NEW: Check Element Existence Handler
// NEW: Check Element Existence Handler
function handleCheckElement() {
    const element = checkElement.value.trim();
    if (element === '') {
        showNotification('Please enter an element to check', 'warning');
        checkElement.focus();
        return;
    }
    
    if (!myArray || myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Convert search element to number if array contains numbers
    let searchValue = element;
    if (myArray.every(item => typeof item === 'number' || !isNaN(item))) {
        searchValue = !isNaN(element) ? Number(element) : element;
    }
    
    // Check if element exists
    let exists = false;
    let foundIndex = -1;
    
    for (let i = 0; i < myArray.length; i++) {
        // Use loose equality to handle number-string comparisons
        if (myArray[i] == searchValue) {
            exists = true;
            foundIndex = i;
            break;
        }
    }
    
    if (exists) {
        // Element exists - highlight it
        highlightElementExistence(foundIndex, element, true);
    } else {
        // Element doesn't exist
        searchResults.innerHTML = `
            <p class="mb-1 text-danger"><strong>Element Not Found</strong></p>
            <p class="mb-1">Element: "${element}"</p>
            <p class="mb-0 text-danger">"${element}" does not exist in the array</p>
        `;
        
        // Blink all elements in red for "not found"
        blinkAllElements('error', 5000);
        
        logOperation(`Checked existence of "${element}" - not found`, 'danger');
        
        // Show dark red notification for element not found
        showNotification(`"${element}" does not exist in the array`, 'dark-red');
    }
    
    checkElement.value = '';
}

// NEW: Find Minimum Element Handler
function handleFindMinElement() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Find minimum element
    let minIndex = 0;
    let minValue = myArray[0];
    
    // Try numeric comparison first, then fall back to string comparison
    let isNumeric = !isNaN(parseFloat(myArray[0]));
    
    for (let i = 1; i < myArray.length; i++) {
        const currentValue = myArray[i];
        
        if (isNumeric) {
            // Numeric comparison
            if (parseFloat(currentValue) < parseFloat(minValue)) {
                minValue = currentValue;
                minIndex = i;
            }
        } else {
            // String comparison
            if (currentValue < minValue) {
                minValue = currentValue;
                minIndex = i;
            }
        }
    }
    
    // Highlight the minimum element
    highlightMinMaxElement(minIndex, minValue, 'min');
}

// NEW: Find Maximum Element Handler
function handleFindMaxElement() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Find maximum element
    let maxIndex = 0;
    let maxValue = myArray[0];
    
    // Try numeric comparison first, then fall back to string comparison
    let isNumeric = !isNaN(parseFloat(myArray[0]));
    
    for (let i = 1; i < myArray.length; i++) {
        const currentValue = myArray[i];
        
        if (isNumeric) {
            // Numeric comparison
            if (parseFloat(currentValue) > parseFloat(maxValue)) {
                maxValue = currentValue;
                maxIndex = i;
            }
        } else {
            // String comparison
            if (currentValue > maxValue) {
                maxValue = currentValue;
                maxIndex = i;
            }
        }
    }
    
    // Highlight the maximum element
    highlightMinMaxElement(maxIndex, maxValue, 'max');
}
// NEW: Highlight Element Existence
function highlightElementExistence(index, element, exists) {
    const elements = document.querySelectorAll('.array-element');
    
    if (exists) {
        // Reset all elements first
        elements.forEach(el => {
            const valueDiv = el.querySelector('.element-value');
            valueDiv.classList.remove('element-exists', 'search-highlight');
        });
        
        // Highlight the found element
        const targetElement = elements[index];
        const valueDiv = targetElement.querySelector('.element-value');
        
        valueDiv.classList.add('element-exists', 'search-highlight');
        
        // Display results with green success message
        searchResults.innerHTML = `
            <p class="mb-1 text-success"><strong>Element Found!</strong></p>
            <p class="mb-1">Element: "${element}"</p>
            <p class="mb-1">Index: [${index}]</p>
            <p class="mb-0 text-success">"${element}" exists in the array</p>
        `;
        
        // Blink found element in green for 5 seconds
        blinkFoundElement(index, 5000);
        
        // Show green success notification
        showNotification(`"${element}" exists in the array at index ${index}`, 'success');
        
        logOperation(`Checked existence of "${element}" - found at index ${index}`, 'success');
        
        // Auto-reset highlight after 5 seconds
        setTimeout(() => {
            valueDiv.classList.remove('element-exists', 'search-highlight');
        }, 5000);
    }
}

// Function to blink found element in green
function blinkFoundElement(index, duration) {
    const elements = document.querySelectorAll('.array-element');
    const foundElement = elements[index];
    const valueDiv = foundElement.querySelector('.element-value');
    
    let blinkCount = 0;
    const maxBlinks = 10; // Blink 10 times over 5 seconds (500ms each)
    
    const blinkInterval = setInterval(() => {
        if (blinkCount % 2 === 0) {
            valueDiv.style.backgroundColor = '#28a745'; // Green
            valueDiv.style.color = 'white';
            valueDiv.style.transform = 'scale(1.2)';
            valueDiv.style.boxShadow = '0 0 15px #28a745';
        } else {
            valueDiv.style.backgroundColor = '';
            valueDiv.style.color = '';
            valueDiv.style.transform = '';
            valueDiv.style.boxShadow = '';
        }
        
        blinkCount++;
        if (blinkCount >= maxBlinks) {
            clearInterval(blinkInterval);
            // Reset to normal after blinking
            setTimeout(() => {
                valueDiv.style.backgroundColor = '';
                valueDiv.style.color = '';
                valueDiv.style.transform = '';
                valueDiv.style.boxShadow = '';
            }, 100);
        }
    }, duration / maxBlinks);
}

// Function to blink all elements in red for "not found"
function blinkAllElements(type, duration) {
    const elements = document.querySelectorAll('.array-element');
    let blinkCount = 0;
    const maxBlinks = 10;
    
    const blinkInterval = setInterval(() => {
        elements.forEach((element) => {
            const valueDiv = element.querySelector('.element-value');
            if (blinkCount % 2 === 0) {
                valueDiv.style.backgroundColor = '#8B0000'; // Dark Red
                valueDiv.style.color = 'white';
                valueDiv.style.transform = 'scale(1.1)';
                valueDiv.style.boxShadow = '0 0 10px #8B0000';
            } else {
                valueDiv.style.backgroundColor = '';
                valueDiv.style.color = '';
                valueDiv.style.transform = '';
                valueDiv.style.boxShadow = '';
            }
        });
        
        blinkCount++;
        if (blinkCount >= maxBlinks) {
            clearInterval(blinkInterval);
            // Reset to original styles
            setTimeout(() => {
                elements.forEach((element) => {
                    const valueDiv = element.querySelector('.element-value');
                    valueDiv.style.backgroundColor = '';
                    valueDiv.style.color = '';
                    valueDiv.style.transform = '';
                    valueDiv.style.boxShadow = '';
                });
            }, 100);
        }
    }, duration / maxBlinks);
}

// Update showNotification function to support dark-red color
function showNotification(message, type = 'info') {
    // Remove any existing notifications
    const existingNotification = document.querySelector('.custom-notification');
    if (existingNotification) {
        existingNotification.remove();
    }
    
    // Map type to Bootstrap alert classes and custom colors
    let alertClass = 'alert-info';
    let icon = '';
    
    switch (type) {
        case 'success':
            alertClass = 'alert-success';
            icon = '';
            break;
        case 'error':
        case 'dark-red':
            alertClass = 'alert-danger'; // Using danger for dark red
            icon = '';
            break;
        case 'warning':
            alertClass = 'alert-warning';
            icon = '';
            break;
        case 'info':
        default:
            alertClass = 'alert-info';
            icon = '';
            break;
    }
    
    const notification = document.createElement('div');
    notification.className = `custom-notification alert ${alertClass} fade show`;
    
    // Add custom dark red background if type is dark-red
    if (type === 'dark-red') {
        notification.style.backgroundColor = '#8B0000';
        notification.style.borderColor = '#660000';
        notification.style.color = 'white';
    }
    
    notification.innerHTML = `
        <strong>${icon}</strong> ${message}
    `;
    
    // Add styles for positioning
    notification.style.cssText += `
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1000;
        min-width: 300px;
        animation: slideInRight 0.3s ease-out;
    `;
    
    document.body.appendChild(notification);
    
    // Auto remove after 5 seconds
    setTimeout(() => {
        if (notification.parentNode) {
            notification.remove();
        }
    }, 5000);
}

// Improved sample data initialization
setTimeout(() => {
    myArray = [1, 2, 3, 4];
    originalArray = [...myArray]; // Keep a copy of original array
    isSubarray = false;
    renderArray();
    updateStats();
    logOperation('Array initialized with sample data: [1, 2, 3, 4]', 'info');
    showNotification('Sample array loaded successfully!', 'success');
}, 1000);

// NEW: Highlight Minimum/Maximum Element
function highlightMinMaxElement(index, value, type) {
    const elements = document.querySelectorAll('.array-element');
    
    // Reset all elements first
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('min-element', 'max-element', 'search-highlight');
    });
    
    // Highlight the min/max element
    const targetElement = elements[index];
    const valueDiv = targetElement.querySelector('.element-value');
    
    if (type === 'min') {
        valueDiv.classList.add('min-element', 'search-highlight');
        
        // Display results
        searchResults.innerHTML = `
            <p class="mb-1"><strong>Minimum Element Found!</strong></p>
            <p class="mb-1">Minimum Value: "${value}"</p>
            <p class="mb-1">Index: [${index}]</p>
            <p class="mb-0">Type: ${!isNaN(parseFloat(value)) ? 'Numeric' : 'String'} comparison</p>
        `;
        
        logOperation(`Found minimum element "${value}" at index ${index}`, 'info');
    } else {
        valueDiv.classList.add('max-element', 'search-highlight');
        
        // Display results
        searchResults.innerHTML = `
            <p class="mb-1"><strong>Maximum Element Found!</strong></p>
            <p class="mb-1">Maximum Value: "${value}"</p>
            <p class="mb-1">Index: [${index}]</p>
            <p class="mb-0">Type: ${!isNaN(parseFloat(value)) ? 'Numeric' : 'String'} comparison</p>
        `;
        
        logOperation(`Found maximum element "${value}" at index ${index}`, 'info');
    }
    
    // Auto-reset highlight after 4 seconds
    setTimeout(() => {
        valueDiv.classList.remove('min-element', 'max-element', 'search-highlight');
    }, 4000);
}

// Update the existing handleResetArray function
function handleResetArray() {
    if ((!isSubarray && !isCurrentlySorted) || (originalArray.length === 0 && sortedArrayBackup.length === 0)) {
        showNotification('No original array to reset to', 'info');
        return;
    }
    
    // Reset from subarray OR from sorted state (binary search)
    if (isSubarray && originalArray.length > 0) {
        myArray = [...originalArray];
        isSubarray = false;
        originalArray = [];
    } else if (isCurrentlySorted && sortedArrayBackup.length > 0) {
        myArray = [...sortedArrayBackup];
        isCurrentlySorted = false;
        sortedArrayBackup = [];
    }
    
    renderArray();
    updateStats();
    
    // Highlight all elements
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation('Reset to original array', 'info');
}  
// NEW: Shift Left Handler
function handleShiftLeft() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - cannot shift', 'info');
        return;
    }
    
    // Store original array if this is the first shift operation
    if (!isShifted) {
        originalArrayForShift = [...myArray];
    }
    
    // Perform left shift
    const firstElement = myArray.shift(); // Remove first element
    myArray.push(firstElement); // Add it to the end
    
    renderArray();
    updateStats();
    isShifted = true;
    
    // Animate the shift
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'update');
        });
    }, 100);
    
    logOperation(`Shifted array left. First element "${firstElement}" moved to end`, 'warning');
    showNotification('Array shifted left successfully', 'success');
}

// NEW: Shift Right Handler
function handleShiftRight() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - cannot shift', 'info');
        return;
    }
    
    // Store original array if this is the first shift operation
    if (!isShifted) {
        originalArrayForShift = [...myArray];
    }
    
    // Perform right shift
    const lastElement = myArray.pop(); // Remove last element
    myArray.unshift(lastElement); // Add it to the beginning
    
    renderArray();
    updateStats();
    isShifted = true;
    
    // Animate the shift
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'update');
        });
    }, 100);
    
    logOperation(`Shifted array right. Last element "${lastElement}" moved to beginning`, 'warning');
    showNotification('Array shifted right successfully', 'success');
}

// NEW: Reset Shift Handler
function handleResetShift() {
    if (!isShifted || originalArrayForShift.length === 0) {
        showNotification('No shift operation to reset', 'info');
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayForShift];
    originalArrayForShift = [];
    isShifted = false;
    
    renderArray();
    updateStats();
    
    // Highlight all elements
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation('Reset array to original state after shift operations', 'info');
    showNotification('Array reset to original state', 'success');
}

// NEW: Pop Last Element Handler
function handlePopLast() {
    if (myArray.length === 0) {
        // Show error message in red color
        searchResults.innerHTML = `
            <p class="mb-1 text-danger"><strong>Error: No elements in array</strong></p>
            <p class="mb-0 text-danger">Array is empty. Please add elements first.</p>
        `;
        showNotification('Array is empty. Cannot pop last element.', 'danger');
        logOperation('Attempted to pop from empty array - failed', 'danger');
        return;
    }
    
    const lastElement = myArray[myArray.length - 1];
    const lastIndex = myArray.length - 1;
    
    // Highlight the last element before popping
    highlightElement(lastIndex, 'delete', () => {
        myArray.pop(); // Remove last element
        renderArray();
        updateStats();
        
        // Show success message in green color
        searchResults.innerHTML = `
            <p class="mb-1 text-success"><strong>Success: Last Element Popped</strong></p>
            <p class="mb-1">Popped Element: "${lastElement}"</p>
            <p class="mb-0">New array length: ${myArray.length}</p>
        `;
        
        logOperation(`Popped last element: "${lastElement}"`, 'success');
        showNotification(`Last element "${lastElement}" popped successfully`, 'success');
    });
}    
// NEW: Traverse Forward Handler
function handleTraverseForward() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isTraversalRunning) {
        showNotification('A traversal operation is already in progress', 'warning');
        return;
    }
    
    isTraversalRunning = true;
    traversalDirection = 'forward';
    traverseForwardBtn.disabled = true;
    traverseBackwardBtn.disabled = true;
    
    // Reset all elements first
    const elements = document.querySelectorAll('.array-element');
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('traverse-current', 'traverse-completed');
    });
    
    // Start traversal from index 0
    performTraverseForward(0);
}

// NEW: Traverse Backward Handler
function handleTraverseBackward() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isTraversalRunning) {
        showNotification('A traversal operation is already in progress', 'warning');
        return;
    }
    
    isTraversalRunning = true;
    traversalDirection = 'backward';
    traverseForwardBtn.disabled = true;
    traverseBackwardBtn.disabled = true;
    
    // Reset all elements first
    const elements = document.querySelectorAll('.array-element');
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('traverse-current', 'traverse-completed');
    });
    
    // Start traversal from last index
    performTraverseBackward(myArray.length - 1);
}

// NEW: Perform Forward Traversal
function performTraverseForward(currentIndex) {
    if (currentIndex >= myArray.length || traversalDirection !== 'forward') {
        // Traversal completed
        resetTraversalState();
        logOperation('Forward traversal completed', 'success');
        showNotification('Forward traversal completed', 'success');
        return;
    }
    
    const elements = document.querySelectorAll('.array-element');
    
    // Mark previous elements as completed
    for (let i = 0; i < currentIndex; i++) {
        const prevElement = elements[i];
        const prevValueDiv = prevElement.querySelector('.element-value');
        prevValueDiv.classList.remove('traverse-current');
        prevValueDiv.classList.add('traverse-completed');
    }
    
    // Highlight current element
    const currentElement = elements[currentIndex];
    const valueDiv = currentElement.querySelector('.element-value');
    valueDiv.classList.remove('traverse-completed');
    valueDiv.classList.add('traverse-current');
    
    // Update search results to show current traversal status
    searchResults.innerHTML = `
        <p class="mb-1"><strong>Forward Traversal in Progress</strong></p>
        <p class="mb-1">Current Index: [${currentIndex}]</p>
        <p class="mb-1">Current Value: "${myArray[currentIndex]}"</p>
        <p class="mb-0">Progress: ${currentIndex + 1}/${myArray.length}</p>
    `;
    
    // Move to next element after delay
    setTimeout(() => {
        performTraverseForward(currentIndex + 1);
    }, 800);
}

// NEW: Perform Backward Traversal
function performTraverseBackward(currentIndex) {
    if (currentIndex < 0 || traversalDirection !== 'backward') {
        // Traversal completed
        resetTraversalState();
        logOperation('Backward traversal completed', 'success');
        showNotification('Backward traversal completed', 'success');
        return;
    }
    
    const elements = document.querySelectorAll('.array-element');
    
    // Mark elements after current as completed
    for (let i = myArray.length - 1; i > currentIndex; i--) {
        const nextElement = elements[i];
        const nextValueDiv = nextElement.querySelector('.element-value');
        nextValueDiv.classList.remove('traverse-current');
        nextValueDiv.classList.add('traverse-completed');
    }
    
    // Highlight current element
    const currentElement = elements[currentIndex];
    const valueDiv = currentElement.querySelector('.element-value');
    valueDiv.classList.remove('traverse-completed');
    valueDiv.classList.add('traverse-current');
    
    // Update search results to show current traversal status
    searchResults.innerHTML = `
        <p class="mb-1"><strong>Backward Traversal in Progress</strong></p>
        <p class="mb-1">Current Index: [${currentIndex}]</p>
        <p class="mb-1">Current Value: "${myArray[currentIndex]}"</p>
        <p class="mb-0">Progress: ${myArray.length - currentIndex}/${myArray.length}</p>
    `;
    
    // Move to previous element after delay
    setTimeout(() => {
        performTraverseBackward(currentIndex - 1);
    }, 800);
}

// NEW: Reset Traversal State
function resetTraversalState() {
    isTraversalRunning = false;
    traversalDirection = null;
    traverseForwardBtn.disabled = false;
    traverseBackwardBtn.disabled = false;
    
    // Reset all traversal highlights
    const elements = document.querySelectorAll('.array-element');
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('traverse-current', 'traverse-completed');
    });
    
    // Clear search results after a short delay
    setTimeout(() => {
        searchResults.innerHTML = '<p class="text-center mb-0">Traversal operation completed</p>';
    }, 2000);
}
// Calculate sum of all elements
function calculateSum() {
    if (myArray.length === 0) return 0;
    
    let sum = 0;
    for (let i = 0; i < myArray.length; i++) {
        const num = parseFloat(myArray[i]);
        if (!isNaN(num)) {
            sum += num;
        }
    }
    return sum;
}

// Calculate product of all elements
function calculateProduct() {
    if (myArray.length === 0) return 1;
    
    let product = 1;
    let hasValidNumbers = false;
    
    for (let i = 0; i < myArray.length; i++) {
        const num = parseFloat(myArray[i]);
        if (!isNaN(num)) {
            product *= num;
            hasValidNumbers = true;
        }
    }
    
    return hasValidNumbers ? product : 0;
}
// NEW: Cumulative Sum Array Handler (Updated)
// UPDATED: Cumulative Sum Array Handler with Dual Display
function handleCumulativeSum() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if all elements are numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Cumulative sum requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array BEFORE transformation
    if (!isSubarray) {
        originalArray = [...myArray];
    }
    
    // Create cumulative sum array
    const cumulativeArray = [];
    let runningSum = 0;
    
    for (let i = 0; i < myArray.length; i++) {
        runningSum += parseFloat(myArray[i]);
        cumulativeArray.push(runningSum.toString());
    }
    
    // Show dual array visualization with step-by-step calculation
    showDualArrayVisualizationWithCalculation(
        originalArray, 
        cumulativeArray, 
        'Cumulative Sum Transformation',
        'Each element contains the sum of all previous elements including current',
        'cumulative'
    );
}

// UPDATED: Prefix Sum Array Handler with Step-by-Step Calculation Animation
function handlePrefixSum() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if all elements are numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Prefix sum requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array BEFORE transformation
    if (!isSubarray) {
        originalArray = [...myArray];
    }
    
    // Create prefix sum array
    const prefixArray = [];
    let runningSum = 0;
    
    for (let i = 0; i < myArray.length; i++) {
        runningSum += parseFloat(myArray[i]);
        prefixArray.push(runningSum.toString());
    }
    
    // Show dual array visualization with step-by-step calculation
    showDualArrayVisualizationWithCalculation(
        originalArray, 
        prefixArray, 
        'Prefix Sum Transformation',
        'Each element contains the sum of all elements from index 0 to current index',
        'prefix'
    );
}

// NEW: Show Dual Array Visualization with Step-by-Step Calculation
function showDualArrayVisualizationWithCalculation(originalArray, transformedArray, title, explanation, type) {
    // Create dual array container
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-array-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">${title}</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalArrayVis"></div>
        </div>
        
        <div class="transformation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">${type === 'cumulative' ? 'Cumulative Sum Array' : 'Prefix Sum Array'}</div>
            <div class="transformed-array-container" id="transformedArrayVis"></div>
        </div>
        
        <div class="transformation-explanation">
            <p class="mb-0">${explanation}</p>
        </div>
        
        <div class="calculation-steps mt-3" id="calculationSteps">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="stepsContainer"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterVisualization" style="display: none;">
            <i class="fas fa-play me-1"></i>Continue with Transformed Array
        </button>
    `;
    
    // Replace the main array container with dual visualization
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Render original array
    renderArrayInContainer(originalArray, 'originalArrayVis');
    
    // Render empty transformed array
    renderArrayInContainer(new Array(originalArray.length).fill('?'), 'transformedArrayVis');
    
    // Start step-by-step calculation animation
    performStepByStepCalculation(originalArray, transformedArray, type);
}

// NEW: Perform Step-by-Step Calculation Animation
// NEW: Modified function to automatically handle transformation
function performStepByStepCalculation(originalArray, transformedArray, type) {
    const stepsContainer = document.getElementById('stepsContainer');
    const transformedContainer = document.getElementById('transformedArrayVis');
    const originalContainer = document.getElementById('originalArrayVis');
    const continueButton = document.getElementById('continueAfterVisualization');
    
    let runningSum = 0;
    let currentStep = 0;
    
    // Function to perform one calculation step
    function performStep(index) {
        if (index >= originalArray.length) {
            // All steps completed
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${currentStep}:</strong> Calculation Complete!
                </div>
            `;
            
            // Show continue button
            continueButton.style.display = 'block';
            
            // Auto-proceed after 3 seconds if user doesn't click the button
            const autoProceedTimer = setTimeout(() => {
                proceedWithTransformation();
            }, 3000);
            
            // Manual click handler
            continueButton.addEventListener('click', () => {
                clearTimeout(autoProceedTimer);
                proceedWithTransformation();
            });
            
            return;
        }
        
        // Highlight current original element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const originalValueDiv = originalElements[index].querySelector('.element-value');
        originalValueDiv.classList.add('traverse-current');
        
        // Calculate new value
        const currentValue = parseFloat(originalArray[index]);
        runningSum += currentValue;
        
        // Update step explanation
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentStep}:</strong> 
                ${type === 'cumulative' ? 'Cumulative' : 'Prefix'} Sum [${index}] = 
                ${index > 0 ? `${runningSum - currentValue} + ${currentValue}` : currentValue} 
                = ${runningSum}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // After a delay, update the transformed array
        setTimeout(() => {
            // Update transformed array element
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const transformedValueDiv = transformedElements[index].querySelector('.element-value');
            transformedValueDiv.textContent = runningSum;
            transformedValueDiv.classList.add('cumulative-highlight', 'transform-animation');
            
            // Remove highlight from original element
            originalValueDiv.classList.remove('traverse-current');
            
            // Move to next step
            currentStep++;
            performStep(index + 1);
        }, 1500);
    }
    
    // Function to proceed with transformation
    function proceedWithTransformation() {
        // Update the actual array
        myArray = [...transformedArray];
        isSubarray = true;
        
        // Remove dual visualization and return to normal view
        const mainContainer = document.getElementById('arrayContainer');
        mainContainer.innerHTML = '';
        renderArray();
        updateStats();
        
        logOperation(`Transformed array to ${type === 'cumulative' ? 'cumulative sum' : 'prefix sum'}`, 'success');
        showNotification(`Array transformed to ${type === 'cumulative' ? 'cumulative sum' : 'prefix sum'} successfully`, 'success');
        
        // Auto-reset after 10 seconds
        setTimeout(() => {
            if (isSubarray && originalArray.length > 0) {
                resetAfterTransformation();
                showNotification(`Automatically reset to original array after ${type === 'cumulative' ? 'cumulative sum' : 'prefix sum'}`, 'info');
            }
        }, 10000);
    }
    
    // Start the step-by-step calculation
    performStep(0);
}

// NEW: Reset after transformation
function resetAfterTransformation() {
    if (!isSubarray || originalArray.length === 0) {
        showNotification('No transformation to reset', 'info');
        return;
    }
    
    // Reset to original array
    myArray = [...originalArray];
    originalArray = [];
    isSubarray = false;
    
    renderArray();
    updateStats();
    
    // Clear search results
    searchResults.innerHTML = '<p class="text-center mb-0">Reset to original array</p>';
    
    // Highlight all elements
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation('Reset to original array after transformation', 'info');
    showNotification('Reset to original array successfully', 'success');
}
// NEW: Find Subarray with Given Sum Handler
function handleFindSubarraySum() {
    const targetSum = parseFloat(subarraySumInput.value);
    
    if (isNaN(targetSum)) {
        showNotification('Please enter a valid target sum', 'warning');
        subarraySumInput.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Subarray sum calculation requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Find subarrays with given sum
    subarraySumResults = findSubarraysWithSum(targetSum);
    
    if (subarraySumResults.length === 0) {
        searchResults.innerHTML = `
            <div class="subarray-sum-results">
                <p class="mb-1"><strong>No Subarrays Found</strong></p>
                <p class="mb-1">Target Sum: ${targetSum}</p>
                <p class="mb-0 text-danger">No subarrays found with the given sum</p>
            </div>
        `;
        logOperation(`No subarrays found with sum ${targetSum}`, 'warning');
        return;
    }
    
    // Display results
    displaySubarraySumResults(targetSum);
    
    // Animate the found subarrays
    animateSubarraySumResults();
}

// NEW: Generate All Subarrays with Sum Handler
function handleGenerateAllSubarraysWithSum() {
    const targetSum = parseFloat(subarraySumInput.value);
    
    if (isNaN(targetSum)) {
        showNotification('Please enter a valid target sum', 'warning');
        subarraySumInput.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Subarray sum calculation requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Find all subarrays with given sum
    subarraySumResults = findSubarraysWithSum(targetSum);
    
    if (subarraySumResults.length === 0) {
        searchResults.innerHTML = `
            <div class="subarray-sum-results">
                <p class="mb-1"><strong>No Subarrays Found</strong></p>
                <p class="mb-1">Target Sum: ${targetSum}</p>
                <p class="mb-0 text-danger">No subarrays found with the given sum</p>
            </div>
        `;
        logOperation(`No subarrays found with sum ${targetSum}`, 'warning');
        return;
    }
    
    // Generate and display all subarrays with the sum
    generateAllSubarraysWithSum(targetSum);
}

// NEW: Find Subarrays with Given Sum Algorithm
function findSubarraysWithSum(targetSum) {
    const results = [];
    const n = myArray.length;
    
    // Convert array to numbers
    const numArray = myArray.map(val => parseFloat(val));
    
    // Find all subarrays with sum equal to target
    for (let start = 0; start < n; start++) {
        let currentSum = 0;
        for (let end = start; end < n; end++) {
            currentSum += numArray[end];
            
            if (currentSum === targetSum) {
                results.push({
                    start: start,
                    end: end,
                    sum: currentSum,
                    elements: myArray.slice(start, end + 1)
                });
            }
            
            // If we exceed the target sum, break inner loop (for positive numbers)
            // if (currentSum > targetSum && numArray[start] > 0) {
            //     break;
            // }
        }
    }
    
    return results;
}

// NEW: Display Subarray Sum Results
function displaySubarraySumResults(targetSum) {
    const totalSubarrays = subarraySumResults.length;
    
    searchResults.innerHTML = `
        <div class="subarray-sum-results">
            <p class="mb-1"><strong>Subarrays with Sum ${targetSum}</strong></p>
            <p class="mb-1">Total Subarrays Found: ${totalSubarrays}</p>
            <p class="mb-1">Array: [${myArray.join(', ')}]</p>
            <div class="mt-3">
                <h6>Found Subarrays:</h6>
                <div class="d-flex flex-wrap gap-2" id="subarraySumList"></div>
            </div>
        </div>
    `;
    
    const subarraySumList = document.getElementById('subarraySumList');
    
    // Display first few subarrays (limit to 10 for performance)
    const displayLimit = Math.min(totalSubarrays, 10);
    for (let i = 0; i < displayLimit; i++) {
        const subarray = subarraySumResults[i];
        const subarrayElement = document.createElement('div');
        subarrayElement.className = 'subarray-sum-item';
        subarrayElement.innerHTML = `
            [${subarray.elements.join(', ')}]<br>
            <small>Indices: ${subarray.start} to ${subarray.end}</small>
        `;
        subarraySumList.appendChild(subarrayElement);
    }
    
    if (totalSubarrays > displayLimit) {
        const moreElement = document.createElement('div');
        moreElement.className = 'text-info mt-2';
        moreElement.textContent = `... and ${totalSubarrays - displayLimit} more subarrays`;
        subarraySumList.appendChild(moreElement);
    }
    
    logOperation(`Found ${totalSubarrays} subarray(s) with sum ${targetSum}`, 'success');
    showNotification(`Found ${totalSubarrays} subarray(s) with sum ${targetSum}`, 'success');
}

// NEW: Animate Subarray Sum Results
function animateSubarraySumResults() {
    let currentSubarrayIndex = 0;
    
    function animateNextSubarray() {
        if (currentSubarrayIndex >= subarraySumResults.length) {
            // All subarrays animated
            setTimeout(() => {
                // Reset all highlights
                const elements = document.querySelectorAll('.array-element');
                elements.forEach(el => {
                    const valueDiv = el.querySelector('.element-value');
                    valueDiv.classList.remove('subarray-sum-match');
                });
            }, 2000);
            return;
        }
        
        const subarray = subarraySumResults[currentSubarrayIndex];
        
        // Highlight elements in current subarray
        for (let i = subarray.start; i <= subarray.end; i++) {
            setTimeout(() => {
                const elements = document.querySelectorAll('.array-element');
                const valueDiv = elements[i].querySelector('.element-value');
                valueDiv.classList.add('subarray-sum-match');
                
                // Remove highlight after animation
                setTimeout(() => {
                    valueDiv.classList.remove('subarray-sum-match');
                }, 1500);
            }, (i - subarray.start) * 200);
        }
        
        // Move to next subarray after delay
        setTimeout(() => {
            currentSubarrayIndex++;
            animateNextSubarray();
        }, (subarray.end - subarray.start + 2) * 200);
    }
    
    // Start animation
    animateNextSubarray();
}

// NEW: Generate All Subarrays with Sum
function generateAllSubarraysWithSum(targetSum) {
    const totalSubarrays = subarraySumResults.length;
    
    searchResults.innerHTML = `
        <div class="subarray-sum-results">
            <p class="mb-1"><strong>All Subarrays with Sum ${targetSum}</strong></p>
            <p class="mb-1">Total Subarrays Found: ${totalSubarrays}</p>
            <p class="mb-1">Array: [${myArray.join(', ')}]</p>
            <div class="mt-3">
                <h6>All Subarrays with Sum ${targetSum}:</h6>
                <div class="subarrays-container" style="max-height: 400px; overflow-y: auto;">
                    <div class="d-flex flex-wrap gap-2" id="allSubarraysSumList"></div>
                </div>
            </div>
        </div>
    `;
    
    const allSubarraysSumList = document.getElementById('allSubarraysSumList');
    
    // Display all subarrays
    subarraySumResults.forEach((subarray, index) => {
        const subarrayElement = document.createElement('div');
        subarrayElement.className = 'subarray-sum-item';
        subarrayElement.innerHTML = `
            <strong>Subarray ${index + 1}:</strong> [${subarray.elements.join(', ')}]<br>
            <small>Indices: ${subarray.start} to ${subarray.end} | Sum: ${subarray.sum}</small>
        `;
        allSubarraysSumList.appendChild(subarrayElement);
    });
    
    logOperation(`Generated all ${totalSubarrays} subarrays with sum ${targetSum}`, 'success');
    showNotification(`Generated all ${totalSubarrays} subarrays with sum ${targetSum}`, 'success');
    
    // Auto-animate after displaying all
    setTimeout(() => {
        animateSubarraySumResults();
    }, 1000);
}

// NEW: Helper function to render array in specific container
function renderArrayInContainer(array, containerId, animate = false, type = '') {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    array.forEach((value, index) => {
        const element = document.createElement('div');
        element.className = 'array-element';
        
        const valueDiv = document.createElement('div');
        valueDiv.className = 'element-value';
        valueDiv.textContent = value;
        
        const indexDiv = document.createElement('div');
        indexDiv.className = 'element-index';
        indexDiv.textContent = `[${index}]`;
        
        element.appendChild(valueDiv);
        element.appendChild(indexDiv);
        container.appendChild(element);
          if (animate) {
            setTimeout(() => {
                valueDiv.classList.add('slide-in');
                setTimeout(() => {
                    valueDiv.classList.remove('slide-in');
                }, 1000);
            }, index * 100);
        }
        // Add animation if requested
        if (animate) {
            setTimeout(() => {
                valueDiv.classList.add('slide-in');
                if (type === 'cumulative') {
                    valueDiv.classList.add('cumulative-highlight');
                } else if (type === 'prefix') {
                    valueDiv.classList.add('prefix-highlight');
                }
                if (type === 'ap') {
    valueDiv.classList.add('ap-term');
} else if (type === 'gp') {
    valueDiv.classList.add('gp-term');
}

                // Remove highlight after animation
                setTimeout(() => {
                    valueDiv.classList.remove('cumulative-highlight', 'prefix-highlight');
                }, 2000);
            }, index * 200);
        }
    });
}
// NEW: Stable Sort Handler
function handleStableSort() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - already sorted', 'info');
        return;
    }
    
    if (isStableSortRunning) {
        showNotification('A stable sort operation is already in progress', 'warning');
        return;
    }
    
    isStableSortRunning = true;
    stableSortBtn.disabled = true;
    
    // Store original array
    originalArrayForStableSort = [...myArray];
    
    // Show stable sort visualization
    showStableSortVisualization();
}
// NEW: Show Stable Sort Visualization
function showStableSortVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Stable Sort - Bubble Sort Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalStableArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Stable Sorted Array</div>
            <div class="transformed-array-container" id="transformedStableArray"></div>
        </div>
        
        <div class="stable-sort-explanation">
            <p class="mb-2"><strong>Stable Sort Property:</strong> Equal elements maintain their original relative order</p>
            <p class="mb-0" id="stableSortExplanation">Starting stable bubble sort...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="stableSortStepsContainer">
            <h6 class="text-center">Stable Sort Steps</h6>
            <div class="steps-container" id="stableSortSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterStableSort" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForStableSort, 'originalStableArray');
    renderArrayInContainer([...originalArrayForStableSort], 'transformedStableArray');
    
    performStableSortAnimation();
}
// NEW: Perform Stable Sort Animation
function performStableSortAnimation() {
    const originalContainer = document.getElementById('originalStableArray');
    const transformedContainer = document.getElementById('transformedStableArray');
    const explanation = document.getElementById('stableSortExplanation');
    const stepsContainer = document.getElementById('stableSortSteps');
    const continueButton = document.getElementById('continueAfterStableSort');
    
    const array = [...originalArrayForStableSort];
    const n = array.length;
    let sortedArray = [...array];
    let currentPass = 1;
    let currentComparison = 0;
    let totalSwaps = 0;
    
    // Create array with original indices to track stability
    const elementsWithIndices = array.map((value, index) => ({
        value: value,
        originalIndex: index,
        displayValue: `${value}(${index})` // Show original index for demonstration
    }));
    
    let sortedElements = [...elementsWithIndices];
    
    function performStableSortStep() {
        if (currentPass > n - 1) {
            // Sorting completed
            explanation.innerHTML = `<strong>Stable Sort Completed!</strong> Array sorted with stability maintained. Total passes: ${n-1}, Total swaps: ${totalSwaps}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Stable sort completed! Equal elements maintained their original order.
                </div>
            `;
            
            // Highlight all elements as stable sorted
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                const valueDiv = el.querySelector('.element-value');
                setTimeout(() => {
                    valueDiv.classList.add('stable-sort-stable');
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return to original after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterStableSort();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterStableSort);
            
            return;
        }
        
        if (currentComparison >= n - currentPass) {
            // Pass completed
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Pass ${currentPass} Complete:</strong> Largest element bubbled to position ${n - currentPass}
                </div>
            `;
            
            // Highlight the last sorted element
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const sortedElement = transformedElements[n - currentPass].querySelector('.element-value');
            sortedElement.classList.add('stable-sort-stable');
            
            currentPass++;
            currentComparison = 0;
            performStableSortStep();
            return;
        }
        
        const i = currentComparison;
        const j = i + 1;
        
        // Update explanation with stability information
        explanation.innerHTML = `Pass ${currentPass}: Comparing elements at indices ${i} and ${j}. Checking stability...`;
        
        // Highlight elements being compared
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const elementI = originalElements[i].querySelector('.element-value');
        const elementJ = originalElements[j].querySelector('.element-value');
        
        elementI.classList.add('stable-sort-current');
        elementJ.classList.add('stable-sort-compared');
        
        // Compare values
        const valI = parseFloat(sortedElements[i].value);
        const valJ = parseFloat(sortedElements[j].value);
        
        let shouldSwap = false;
        let stabilityNote = '';
        
        if (!isNaN(valI) && !isNaN(valJ)) {
            shouldSwap = valI > valJ;
            if (valI === valJ) {
                stabilityNote = ' - Equal values, maintaining original order (STABILITY)';
            }
        } else {
            shouldSwap = sortedElements[i].value > sortedElements[j].value;
            if (sortedElements[i].value === sortedElements[j].value) {
                stabilityNote = ' - Equal values, maintaining original order (STABILITY)';
            }
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${shouldSwap ? 'active' : ''}">
                <strong>Step:</strong> Compare [${i}]="${sortedElements[i].displayValue}" and [${j}]="${sortedElements[j].displayValue}" - 
                ${shouldSwap ? 'SWAP needed' : 'No swap needed'}${stabilityNote}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            if (shouldSwap) {
                // Perform swap
                explanation.innerHTML = `Pass ${currentPass}: Swapping elements at indices ${i} and ${j} - Maintaining stability`;
                
                elementI.classList.remove('stable-sort-current');
                elementJ.classList.remove('stable-sort-compared');
                elementI.classList.add('stable-sort-swapped');
                elementJ.classList.add('stable-sort-swapped');
                
                // Calculate swap distance for animation
                const rectI = originalElements[i].getBoundingClientRect();
                const rectJ = originalElements[j].getBoundingClientRect();
                const swapDistance = rectJ.left - rectI.left;
                
                elementI.style.setProperty('--swap-distance', `${swapDistance}px`);
                elementJ.style.setProperty('--swap-distance', `-${swapDistance}px`);
                
                setTimeout(() => {
                    elementI.classList.add('swap-animation');
                    elementJ.classList.add('swap-animation');
                    
                    setTimeout(() => {
                        // Swap the elements
                        [sortedElements[i], sortedElements[j]] = [sortedElements[j], sortedElements[i]];
                        totalSwaps++;
                        
                        // Update transformed array display with original indices
                        const displayArray = sortedElements.map(item => item.displayValue);
                        renderArrayInContainer(displayArray, 'transformedStableArray');
                        
                        // Remove highlights
                        elementI.classList.remove('stable-sort-swapped', 'swap-animation');
                        elementJ.classList.remove('stable-sort-swapped', 'swap-animation');
                        
                        currentComparison++;
                        performStableSortStep();
                    }, 1000);
                }, 500);
            } else {
                // No swap needed - emphasize stability
                if (stabilityNote) {
                    explanation.innerHTML = `Pass ${currentPass}: Equal values detected - Maintaining original order (STABILITY PRESERVED)`;
                    
                    // Highlight both elements to show they're equal
                    elementI.classList.add('stable-sort-stable');
                    elementJ.classList.add('stable-sort-stable');
                    
                    setTimeout(() => {
                        elementI.classList.remove('stable-sort-stable');
                        elementJ.classList.remove('stable-sort-stable');
                    }, 1000);
                }
                
                elementI.classList.remove('stable-sort-current');
                elementJ.classList.remove('stable-sort-compared');
                
                currentComparison++;
                performStableSortStep();
            }
        }, 2000);
    }
    
    // Start stable sort process
    performStableSortStep();
}
// NEW: Return to Original after Stable Sort
function returnToOriginalAfterStableSort() {
    // Reset to original array
    myArray = [...originalArrayForStableSort];
    originalArrayForStableSort = [];
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isStableSortRunning = false;
    stableSortBtn.disabled = false;
    
    // Show original positions with animation
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'stable-sort-original-position');
        });
    }, 100);
    
    logOperation('Stable sort demonstration completed - returned to original array', 'info');
    showNotification('Returned to original array after stable sort demonstration', 'success');
}
// UPDATED: Reset after transformation
function resetAfterTransformation() {
    if (!isSubarray || originalArray.length === 0) {
        showNotification('No transformation to reset', 'info');
        return;
    }
    
    // Reset to original array
    myArray = [...originalArray];
    originalArray = [];
    isSubarray = false;
    
    renderArray();
    updateStats();
    
    // Clear search results
    searchResults.innerHTML = '<p class="text-center mb-0">Reset to original array</p>';
    
    // Highlight all elements
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation('Reset to original array after transformation', 'info');
    showNotification('Reset to original array successfully', 'success');
}
// NEW: Reset transformation
function resetTransformation() {
    if (originalArrayForTransformation.length === 0) {
        showNotification('No transformation to reset', 'info');
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayForTransformation];
    originalArrayForTransformation = [];
    currentTransformationType = null;
    
    renderArray();
    updateStats();
    
    // Hide the reset button
    document.getElementById('resetTransformationBtn').style.display = 'none';
    
    // Clear search results
    document.getElementById('searchResults').innerHTML = '<p class="text-center mb-0">Reset to original array</p>';
    
    // Highlight all elements to show reset
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation('Reset to original array after transformation', 'info');
    showNotification('Reset to original array successfully', 'success');
}
// NEW: Sort Subarray Handler
function handleSortSubarray() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isSubarraySortRunning) {
        showNotification('A subarray sort operation is already in progress', 'warning');
        return;
    }
    
    const start = parseInt(sortSubarrayStart.value);
    const end = parseInt(sortSubarrayEnd.value);
    
    // Validation
    if (isNaN(start) || start < 0 || start >= myArray.length) {
        showNotification('Please enter a valid start index', 'danger');
        sortSubarrayStart.focus();
        return;
    }
    
    if (isNaN(end) || end < 0 || end >= myArray.length) {
        showNotification('Please enter a valid end index', 'danger');
        sortSubarrayEnd.focus();
        return;
    }
    
    if (start === end) {
        showNotification('Start and end indices cannot be the same', 'danger');
        return;
    }
    
    if (start > end) {
        showNotification('Start index cannot be greater than end index', 'danger');
        return;
    }
    
    if (end - start < 1) {
        showNotification('Subarray must have at least 2 elements to sort', 'warning');
        return;
    }
    
    isSubarraySortRunning = true;
    subarraySortStart = start;
    subarraySortEnd = end;
    
    // Store original array
    originalArrayForSubarraySort = [...myArray];
    
    // Perform subarray sort visualization
    performSubarraySort(start, end);
}
// NEW: Perform Subarray Sort with Visualization
function performSubarraySort(start, end) {
    const subarrayLength = end - start + 1;
    
    // Create dual container for subarray sort
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Sort Subarray (Indices ${start} to ${end})</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalSubarraySort"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After Subarray Sort</div>
            <div class="transformed-array-container" id="transformedSubarraySort"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Subarray Sort:</strong> Sorting elements from index ${start} to ${end} only</p>
            <p class="mb-0" id="subarraySortExplanation">Starting subarray sort animation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="subarraySortStepsContainer">
            <h6 class="text-center">Sorting Steps (Bubble Sort on Subarray)</h6>
            <div class="steps-container" id="subarraySortSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSubarraySort" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSubarraySort, 'originalSubarraySort');
    renderArrayInContainer([...originalArrayForSubarraySort], 'transformedSubarraySort');
    
    performSubarraySortAnimation(start, end);
}
// NEW: Perform Subarray Sort Animation
function performSubarraySortAnimation(start, end) {
    const originalContainer = document.getElementById('originalSubarraySort');
    const transformedContainer = document.getElementById('transformedSubarraySort');
    const explanation = document.getElementById('subarraySortExplanation');
    const stepsContainer = document.getElementById('subarraySortSteps');
    const continueButton = document.getElementById('continueAfterSubarraySort');
    
    const array = [...originalArrayForSubarraySort];
    const subarrayLength = end - start + 1;
    let sortedArray = [...array];
    let currentPass = 1;
    let currentComparison = 0;
    let totalSwaps = 0;
    
    // Convert subarray to numbers for comparison if possible
    const isNumeric = !array.slice(start, end + 1).some(item => isNaN(parseFloat(item)));
    
    function performSubarraySortStep() {
        if (currentPass > subarrayLength - 1) {
            // Sorting completed
            explanation.innerHTML = `<strong>Subarray Sort Completed!</strong> Sorted indices ${start} to ${end}. Total passes: ${subarrayLength-1}, Total swaps: ${totalSwaps}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Subarray sort completed! Only the specified range was sorted.
                </div>
            `;
            
            // Highlight the sorted subarray
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            for (let i = start; i <= end; i++) {
                const valueDiv = transformedElements[i].querySelector('.element-value');
                setTimeout(() => {
                    valueDiv.classList.add('sorting-sorted');
                }, (i - start) * 100);
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return to original after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterSubarraySort();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSubarraySort);
            
            return;
        }
        
        if (currentComparison >= subarrayLength - currentPass) {
            // Pass completed
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Pass ${currentPass} Complete:</strong> Element bubbled to position ${end - currentPass + 1}
                </div>
            `;
            
            // Highlight the last sorted element in subarray
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const sortedElement = transformedElements[end - currentPass + 1].querySelector('.element-value');
            sortedElement.classList.add('sorting-sorted');
            
            currentPass++;
            currentComparison = 0;
            performSubarraySortStep();
            return;
        }
        
        const i = start + currentComparison;
        const j = i + 1;
        
        // Update explanation
        explanation.innerHTML = `Pass ${currentPass}: Comparing subarray elements at indices ${i} and ${j}`;
        
        // Highlight elements being compared
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const elementI = originalElements[i].querySelector('.element-value');
        const elementJ = originalElements[j].querySelector('.element-value');
        
        elementI.classList.add('sorting-current');
        elementJ.classList.add('sorting-compared');
        
        // Compare values
        let shouldSwap = false;
        if (isNumeric) {
            const valI = parseFloat(sortedArray[i]);
            const valJ = parseFloat(sortedArray[j]);
            shouldSwap = valI > valJ;
        } else {
            shouldSwap = sortedArray[i] > sortedArray[j];
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${shouldSwap ? 'active' : ''}">
                <strong>Step:</strong> Compare [${i}]="${sortedArray[i]}" and [${j}]="${sortedArray[j]}" - 
                ${shouldSwap ? 'SWAP needed' : 'No swap needed'}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            if (shouldSwap) {
                // Perform swap
                explanation.innerHTML = `Pass ${currentPass}: Swapping elements at indices ${i} and ${j}`;
                
                elementI.classList.remove('sorting-current');
                elementJ.classList.remove('sorting-compared');
                elementI.classList.add('sorting-swap');
                elementJ.classList.add('sorting-swap');
                
                // Calculate swap distance for animation
                const rectI = originalElements[i].getBoundingClientRect();
                const rectJ = originalElements[j].getBoundingClientRect();
                const swapDistance = rectJ.left - rectI.left;
                
                elementI.style.setProperty('--swap-distance', `${swapDistance}px`);
                elementJ.style.setProperty('--swap-distance', `-${swapDistance}px`);
                
                setTimeout(() => {
                    elementI.classList.add('swap-animation');
                    elementJ.classList.add('swap-animation');
                    
                    setTimeout(() => {
                        // Swap the elements
                        [sortedArray[i], sortedArray[j]] = [sortedArray[j], sortedArray[i]];
                        totalSwaps++;
                        
                        // Update transformed array display
                        renderArrayInContainer(sortedArray, 'transformedSubarraySort');
                        
                        // Remove highlights
                        elementI.classList.remove('sorting-swap', 'swap-animation');
                        elementJ.classList.remove('sorting-swap', 'swap-animation');
                        
                        currentComparison++;
                        performSubarraySortStep();
                    }, 1000);
                }, 500);
            } else {
                // No swap needed
                elementI.classList.remove('sorting-current');
                elementJ.classList.remove('sorting-compared');
                
                currentComparison++;
                performSubarraySortStep();
            }
        }, 1500);
    }
    
    // Start subarray sort process
    performSubarraySortStep();
}
// NEW: Return to Original after Subarray Sort
function returnToOriginalAfterSubarraySort() {
    // Reset to original array
    myArray = [...originalArrayForSubarraySort];
    originalArrayForSubarraySort = [];
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isSubarraySortRunning = false;
    
    // Clear inputs
    sortSubarrayStart.value = '';
    sortSubarrayEnd.value = '';
    
    // Show original positions with animation
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation('Subarray sort demonstration completed - returned to original array', 'info');
    showNotification('Returned to original array after subarray sort demonstration', 'success');
}
// NEW: Find First Occurrence Handler
function handleFindFirstOccurrence() {
    const element = occurrenceElement.value.trim();
    if (element === '') {
        showNotification('Please enter an element to find', 'warning');
        occurrenceElement.focus();
        return;
    }
    
    if (!myArray || myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Convert search element to number if array contains numbers
    let searchValue = element;
    if (myArray.every(item => typeof item === 'number' || !isNaN(item))) {
        searchValue = !isNaN(element) ? Number(element) : element;
    }
    
    // Find first occurrence
    let firstIndex = -1;
    for (let i = 0; i < myArray.length; i++) {
        // Use loose equality to handle number-string comparisons
        if (myArray[i] == searchValue) {
            firstIndex = i;
            break;
        }
    }
    
    if (firstIndex === -1) {
        searchResults.innerHTML = `<p class="text-center mb-0 text-danger">Element "${element}" not found in the array</p>`;
        showNotification(`Element "${element}" not found`, 'error');
        
        // Blink all elements in red for "not found"
        blinkAllElements('error', 5000);
        return;
    }
    
    // Auto-scroll down to show results
    autoScrollToResults();
    
    // Highlight the first occurrence with special animation
    highlightFirstOccurrence(firstIndex, element);
}

// NEW: Find Last Occurrence Handler
function handleFindLastOccurrence() {
    const element = occurrenceElementLast.value.trim();
    if (element === '') {
        showNotification('Please enter an element to find', 'warning');
        occurrenceElementLast.focus();
        return;
    }
    
    if (!myArray || myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Convert search element to number if array contains numbers
    let searchValue = element;
    if (myArray.every(item => typeof item === 'number' || !isNaN(item))) {
        searchValue = !isNaN(element) ? Number(element) : element;
    }
    
    // Find last occurrence
    let lastIndex = -1;
    for (let i = myArray.length - 1; i >= 0; i--) {
        // Use loose equality to handle number-string comparisons
        if (myArray[i] == searchValue) {
            lastIndex = i;
            break;
        }
    }
    
    if (lastIndex === -1) {
        searchResults.innerHTML = `<p class="text-center mb-0 text-danger">Element "${element}" not found in the array</p>`;
        showNotification(`Element "${element}" not found`, 'error');
        
        // Blink all elements in red for "not found"
        blinkAllElements('error', 5000);
        return;
    }
    
    // Auto-scroll down to show results
    autoScrollToResults();
    
    // Highlight the last occurrence with special animation
    highlightLastOccurrence(lastIndex, element);
}

// NEW: Find All Occurrences Handler
function handleFindAllOccurrences() {
    const element = occurrenceElementAll.value.trim();
    if (element === '') {
        showNotification('Please enter an element to find', 'warning');
        occurrenceElementAll.focus();
        return;
    }
    
    if (!myArray || myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Convert search element to number if array contains numbers
    let searchValue = element;
    if (myArray.every(item => typeof item === 'number' || !isNaN(item))) {
        searchValue = !isNaN(element) ? Number(element) : element;
    }
    
    // Find all occurrences
    const indices = [];
    for (let i = 0; i < myArray.length; i++) {
        // Use loose equality to handle number-string comparisons
        if (myArray[i] == searchValue) {
            indices.push(i);
        }
    }
    
    if (indices.length === 0) {
        searchResults.innerHTML = `<p class="text-center mb-0 text-danger">Element "${element}" not found in the array</p>`;
        showNotification(`Element "${element}" not found`, 'error');
        
        // Blink all elements in red for "not found"
        blinkAllElements('error', 5000);
        return;
    }
    
    // Auto-scroll down to show results
    autoScrollToResults();
    
    // Highlight all occurrences with special animation
    highlightAllOccurrences(indices, element);
}

// NEW: Auto-scroll to results section
function autoScrollToResults() {
    const resultsSection = document.getElementById('searchResults');
    if (resultsSection) {
        resultsSection.scrollIntoView({ 
            behavior: 'smooth', 
            block: 'center' 
        });
    }
}

// NEW: Auto-scroll back to occurrence buttons section
function autoScrollToOccurrenceButtons() {
    const occurrenceSection = document.querySelector('.occurrenceElement');
    if (occurrenceSection) {
        occurrenceSection.scrollIntoView({ 
            behavior: 'smooth', 
            block: 'center' 
        });
    }
}
// NEW: Auto-scroll back to occurrence buttons section
function autoScrollToOccurrenceButtons() {
    // Directly target the element with id="occurrenceElement"
    const occurrenceInput = document.getElementById('occurrenceElement');
    
    if (occurrenceInput) {
        occurrenceInput.scrollIntoView({ 
            behavior: 'smooth', 
            block: 'center'
        });
    } else {
        // Fallback: scroll to top
        window.scrollTo({ 
            top: 0, 
            behavior: 'smooth' 
        });
    }
}
// NEW: Highlight First Occurrence with Animation
function highlightFirstOccurrence(index, element) {
    const elements = document.querySelectorAll('.array-element');
    
    // Reset all elements first
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('first-occurrence', 'search-highlight');
    });
    
    // Highlight the first occurrence
    const targetElement = elements[index];
    const valueDiv = targetElement.querySelector('.element-value');
    
    valueDiv.classList.add('first-occurrence', 'search-highlight');
    
    // Display results with green success message
    searchResults.innerHTML = `
        <p class="mb-1 text-success"><strong>First Occurrence Found!</strong></p>
        <p class="mb-1">Element: "${element}"</p>
        <p class="mb-1">Index: [${index}]</p>
        <p class="mb-0">Value: "${myArray[index]}"</p>
    `;
    
    // Blink found element in green for 5 seconds
    blinkFoundElement(index, 5000);
    
    // Show green success notification
    showNotification(`First occurrence of "${element}" found at index ${index}`, 'success');
    
    logOperation(`Found first occurrence of "${element}" at index ${index}`, 'success');
    
    // Auto-clear the input, reset highlight, and scroll back after 5 seconds
    setTimeout(() => {
        occurrenceElement.value = '';
        valueDiv.classList.remove('first-occurrence', 'search-highlight');
        
        // Auto-scroll back to occurrence buttons
        autoScrollToOccurrenceButtons();
    }, 5000);
}

// NEW: Highlight Last Occurrence with Animation
function highlightLastOccurrence(index, element) {
    const elements = document.querySelectorAll('.array-element');
    
    // Reset all elements first
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('last-occurrence', 'search-highlight');
    });
    
    // Highlight the last occurrence
    const targetElement = elements[index];
    const valueDiv = targetElement.querySelector('.element-value');
    
    valueDiv.classList.add('last-occurrence', 'search-highlight');
    
    // Display results with green success message
    searchResults.innerHTML = `
        <p class="mb-1 text-success"><strong>Last Occurrence Found!</strong></p>
        <p class="mb-1">Element: "${element}"</p>
        <p class="mb-1">Index: [${index}]</p>
        <p class="mb-0">Value: "${myArray[index]}"</p>
    `;
    
    // Blink found element in green for 5 seconds
    blinkFoundElement(index, 5000);
    
    // Show green success notification
    showNotification(`Last occurrence of "${element}" found at index ${index}`, 'success');
    
    logOperation(`Found last occurrence of "${element}" at index ${index}`, 'success');
    
    // Auto-clear the input, reset highlight, and scroll back after 5 seconds
    setTimeout(() => {
        occurrenceElementLast.value = '';
        valueDiv.classList.remove('last-occurrence', 'search-highlight');
        
        // Auto-scroll back to occurrence buttons
        autoScrollToOccurrenceButtons();
    }, 5000);
}

// NEW: Highlight All Occurrences with Animation
function highlightAllOccurrences(indices, element) {
    const elements = document.querySelectorAll('.array-element');
    
    // Reset all elements first
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('all-occurrence', 'search-highlight');
    });
    
    // Highlight all occurrences sequentially
    indices.forEach((index, i) => {
        setTimeout(() => {
            const targetElement = elements[index];
            const valueDiv = targetElement.querySelector('.element-value');
            valueDiv.classList.add('all-occurrence', 'search-highlight');
            
            // Pulse animation for each found element
            valueDiv.classList.add('pulse');
            setTimeout(() => {
                valueDiv.classList.remove('pulse');
            }, 600);
        }, i * 300);
    });
    
    // Display results with green success message
    searchResults.innerHTML = `
        <p class="mb-1 text-success"><strong>All Occurrences Found!</strong></p>
        <p class="mb-1">Element: "${element}"</p>
        <p class="mb-1">Total Occurrences: ${indices.length}</p>
        <p class="mb-1">Indices: ${indices.map(i => `[${i}]`).join(', ')}</p>
        <p class="mb-0">Values: "${indices.map(i => myArray[i]).join('", "')}"</p>
    `;
    
    // Blink all found elements in green for 5 seconds
    blinkMultipleFoundElements(indices, 5000);
    
    // Show green success notification
    showNotification(`Found ${indices.length} occurrence(s) of "${element}"`, 'success');
    
    logOperation(`Found ${indices.length} occurrence(s) of "${element}" at indices: ${indices.join(', ')}`, 'success');
    
    // Auto-clear the input, reset highlights, and scroll back after 5 seconds
    setTimeout(() => {
        occurrenceElementAll.value = '';
        indices.forEach(index => {
            const valueDiv = elements[index].querySelector('.element-value');
            valueDiv.classList.remove('all-occurrence', 'search-highlight');
        });
        
        // Auto-scroll back to occurrence buttons
        autoScrollToOccurrenceButtons();
    }, 5000);
}

// Function to blink found element in green
function blinkFoundElement(index, duration) {
    const elements = document.querySelectorAll('.array-element');
    const foundElement = elements[index];
    const valueDiv = foundElement.querySelector('.element-value');
    
    let blinkCount = 0;
    const maxBlinks = 10; // Blink 10 times over 5 seconds (500ms each)
    
    const blinkInterval = setInterval(() => {
        if (blinkCount % 2 === 0) {
            valueDiv.style.backgroundColor = '#28a745'; // Green
            valueDiv.style.color = 'white';
            valueDiv.style.transform = 'scale(1.2)';
            valueDiv.style.boxShadow = '0 0 15px #28a745';
        } else {
            valueDiv.style.backgroundColor = '';
            valueDiv.style.color = '';
            valueDiv.style.transform = '';
            valueDiv.style.boxShadow = '';
        }
        
        blinkCount++;
        if (blinkCount >= maxBlinks) {
            clearInterval(blinkInterval);
            // Reset to normal after blinking
            setTimeout(() => {
                valueDiv.style.backgroundColor = '';
                valueDiv.style.color = '';
                valueDiv.style.transform = '';
                valueDiv.style.boxShadow = '';
            }, 100);
        }
    }, duration / maxBlinks);
}

// Function to blink multiple found elements in green
function blinkMultipleFoundElements(indices, duration) {
    const elements = document.querySelectorAll('.array-element');
    let blinkCount = 0;
    const maxBlinks = 10;
    
    const blinkInterval = setInterval(() => {
        indices.forEach(index => {
            const foundElement = elements[index];
            const valueDiv = foundElement.querySelector('.element-value');
            
            if (blinkCount % 2 === 0) {
                valueDiv.style.backgroundColor = '#28a745'; // Green
                valueDiv.style.color = 'white';
                valueDiv.style.transform = 'scale(1.2)';
                valueDiv.style.boxShadow = '0 0 15px #28a745';
            } else {
                valueDiv.style.backgroundColor = '';
                valueDiv.style.color = '';
                valueDiv.style.transform = '';
                valueDiv.style.boxShadow = '';
            }
        });
        
        blinkCount++;
        if (blinkCount >= maxBlinks) {
            clearInterval(blinkInterval);
            // Reset to normal after blinking
            setTimeout(() => {
                indices.forEach(index => {
                    const foundElement = elements[index];
                    const valueDiv = foundElement.querySelector('.element-value');
                    valueDiv.style.backgroundColor = '';
                    valueDiv.style.color = '';
                    valueDiv.style.transform = '';
                    valueDiv.style.boxShadow = '';
                });
            }, 100);
        }
    }, duration / maxBlinks);
}

// Function to blink all elements in red for "not found"
function blinkAllElements(type, duration) {
    const elements = document.querySelectorAll('.array-element');
    let blinkCount = 0;
    const maxBlinks = 10;
    
    const blinkInterval = setInterval(() => {
        elements.forEach((element) => {
            const valueDiv = element.querySelector('.element-value');
            if (blinkCount % 2 === 0) {
                valueDiv.style.backgroundColor = '#dc3545'; // Red
                valueDiv.style.color = 'white';
                valueDiv.style.transform = 'scale(1.1)';
                valueDiv.style.boxShadow = '0 0 10px #dc3545';
            } else {
                valueDiv.style.backgroundColor = '';
                valueDiv.style.color = '';
                valueDiv.style.transform = '';
                valueDiv.style.boxShadow = '';
            }
        });
        
        blinkCount++;
        if (blinkCount >= maxBlinks) {
            clearInterval(blinkInterval);
            // Reset to original styles
            setTimeout(() => {
                elements.forEach((element) => {
                    const valueDiv = element.querySelector('.element-value');
                    valueDiv.style.backgroundColor = '';
                    valueDiv.style.color = '';
                    valueDiv.style.transform = '';
                    valueDiv.style.boxShadow = '';
                });
            }, 100);
        }
    }, duration / maxBlinks);
}

// Improved sample data initialization
setTimeout(() => {
    myArray = [1, 2, 3, 4];
    originalArray = [...myArray]; // Keep a copy of original array
    isSubarray = false;
    renderArray();
    updateStats();
    logOperation('Array initialized with sample data: [1, 2, 3, 4]', 'info');
    showNotification('Sample array loaded successfully!', 'success');
}, 1000);
// NEW: Delete First Occurrence Handler
function handleDeleteFirstOccurrence() {
    const element = deleteFirstOccurrence.value.trim();
    if (element === '') {
        showNotification('Please enter an element to delete', 'warning');
        deleteFirstOccurrence.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers and convert input accordingly
    const arrayContainsNumbers = myArray.length > 0 && 
        typeof myArray[0] === 'number';
    
    const searchElement = arrayContainsNumbers && !isNaN(element) 
        ? Number(element) 
        : element;
    
    // Find first occurrence
    let firstIndex = -1;
    for (let i = 0; i < myArray.length; i++) {
        if (myArray[i] === searchElement) {
            firstIndex = i;
            break;
        }
    }
    
    if (firstIndex === -1) {
        showNotification(`Element "${element}" not found in the array`, 'danger');
        return;
    }
    
    // Delete first occurrence with animation
    const deletedValue = myArray[firstIndex];
    highlightElement(firstIndex, 'delete', () => {
        myArray.splice(firstIndex, 1);
        renderArray();
        updateStats();
        deleteFirstOccurrence.value = '';
        logOperation(`Deleted first occurrence of "${deletedValue}" at index ${firstIndex}`, 'danger');
    });
}

// NEW: Delete All Occurrences Handler
function handleDeleteAllOccurrences() {
    const element = deleteAllOccurrences.value.trim();
    if (element === '') {
        showNotification('Please enter an element to delete', 'warning');
        deleteAllOccurrences.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers and convert input accordingly
    const arrayContainsNumbers = myArray.length > 0 && 
        typeof myArray[0] === 'number';
    
    const searchElement = arrayContainsNumbers && !isNaN(element) 
        ? Number(element) 
        : element;
    
    // Find all occurrences
    const indices = [];
    for (let i = myArray.length - 1; i >= 0; i--) {
        if (myArray[i] === searchElement) {
            indices.push(i);
        }
    }
    
    if (indices.length === 0) {
        showNotification(`Element "${element}" not found in the array`, 'danger');
        return;
    }
    
    // Animate deletion of all matching elements
    let deletedCount = 0;
    indices.forEach((index, i) => {
        setTimeout(() => {
            highlightElement(index, 'delete', () => {
                myArray.splice(index, 1);
                deletedCount++;
                
                if (deletedCount === indices.length) {
                    renderArray();
                    updateStats();
                    deleteAllOccurrences.value = '';
                    logOperation(`Deleted all ${indices.length} occurrence(s) of "${element}"`, 'danger');
                }
            });
        }, i * 300);
    });
}
// Helper function to convert input based on array type
function getSearchElement(inputValue) {
    if (myArray.length === 0) return inputValue;
    
    const arrayContainsNumbers = typeof myArray[0] === 'number';
    return arrayContainsNumbers && !isNaN(inputValue) 
        ? Number(inputValue) 
        : inputValue;
}

// Then in your functions, use:
// const searchElement = getSearchElement(element.trim());
// NEW: Highlight transformed element
function highlightTransformedElement(index, type) {
    const elements = document.querySelectorAll('.array-element');
    if (index < elements.length) {
        const valueDiv = elements[index].querySelector('.element-value');
        valueDiv.classList.add('transformation-highlight');
        
        setTimeout(() => {
            valueDiv.classList.remove('transformation-highlight');
        }, 2000);
    }
}
// NEW: Remove Duplicates (In-Place) Handler
function handleRemoveDuplicatesInPlace() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - no duplicates to remove', 'info');
        return;
    }
    
    // Create a copy for comparison
    const originalArrayCopy = [...myArray];
    
    // In-place duplicate removal using two pointers
    let writeIndex = 0;
    const seen = new Set();
    const removedIndices = [];
    
    // First pass: identify duplicates and prepare for removal
    for (let readIndex = 0; readIndex < myArray.length; readIndex++) {
        if (!seen.has(myArray[readIndex])) {
            seen.add(myArray[readIndex]);
            if (writeIndex !== readIndex) {
                removedIndices.push(readIndex);
            }
            writeIndex++;
        } else {
            removedIndices.push(readIndex);
        }
    }
    
    if (removedIndices.length === 0) {
        showNotification('No duplicates found in the array', 'info');
        return;
    }
    
    // Animate removal of duplicates
    let removedCount = 0;
    removedIndices.forEach((index, i) => {
        setTimeout(() => {
            highlightElement(index, 'delete', () => {
                removedCount++;
                
                if (removedCount === removedIndices.length) {
                    // Actually perform the in-place removal
                    const newArray = [];
                    const uniqueSet = new Set();
                    
                    for (const item of originalArrayCopy) {
                        if (!uniqueSet.has(item)) {
                            uniqueSet.add(item);
                            newArray.push(item);
                        }
                    }
                    
                    myArray = newArray;
                    renderArray();
                    updateStats();
                    
                    logOperation(`Removed ${removedIndices.length} duplicate(s) in-place`, 'warning');
                    showNotification(`Removed ${removedIndices.length} duplicate element(s)`, 'success');
                }
            });
        }, i * 200);
    });
}

// NEW: Remove Duplicates (Keep One) Handler
function handleRemoveDuplicatesKeepOne() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - no duplicates to remove', 'info');
        return;
    }
    
    // Create a copy for comparison
    const originalArrayCopy = [...myArray];
    
    // Keep one occurrence of each element
    const uniqueArray = [];
    const seen = new Set();
    const removedIndices = [];
    
    // Identify which indices will be removed
    for (let i = 0; i < myArray.length; i++) {
        if (!seen.has(myArray[i])) {
            seen.add(myArray[i]);
            uniqueArray.push(myArray[i]);
        } else {
            removedIndices.push(i);
        }
    }
    
    if (removedIndices.length === 0) {
        showNotification('No duplicates found in the array', 'info');
        return;
    }
    
    // Animate removal of duplicates
    let removedCount = 0;
    removedIndices.forEach((index, i) => {
        setTimeout(() => {
            highlightElement(index, 'delete', () => {
                removedCount++;
                
                if (removedCount === removedIndices.length) {
                    // Update the array with unique elements only
                    myArray = uniqueArray;
                    renderArray();
                    updateStats();
                    
                    logOperation(`Removed duplicates, keeping one of each unique element (${removedIndices.length} removed)`, 'warning');
                    showNotification(`Kept one of each element, removed ${removedIndices.length} duplicate(s)`, 'success');
                }
            });
        }, i * 200);
    });
}     
// NEW: Clone Array Handler
function handleCloneArray() {
    const index = parseInt(cloneIndex.value);
    const newValue = cloneElementValue.value.trim();
    
    // Validation
    if (isNaN(index) || index < 0 || index >= myArray.length) {
        showNotification(`Please enter a valid index between 0 and ${myArray.length - 1}`, 'danger');
        cloneIndex.focus();
        return;
    }
    
    if (newValue === '') {
        showNotification('Please enter a new element value', 'warning');
        cloneElementValue.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Show clone operation visualization
    showCloneVisualization(index, newValue);
}
// NEW: Show Clone Visualization
function showCloneVisualization(index, newValue) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Array Cloning Demonstration</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array (Reference)</div>
            <div class="original-array-container" id="originalArrayClone"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-copy"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Cloned Array (Deep Copy)</div>
            <div class="transformed-array-container" id="clonedArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Cloning Process:</strong> Creating a true copy that can be modified independently</p>
            <p class="mb-0" id="cloneExplanation">Starting clone demonstration...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="cloneStepsContainer">
            <h6 class="text-center">Clone Operation Steps</h6>
            <div class="steps-container" id="cloneSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterClone" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Store original array reference
    const originalArray = myArray;
    
    // Render both arrays
    renderArrayInContainer(originalArray, 'originalArrayClone');
    renderArrayInContainer([...originalArray], 'clonedArray');
    
    // Perform clone demonstration
    performCloneDemonstration(index, newValue, originalArray);
}
// NEW: Perform Clone Demonstration
function performCloneDemonstration(index, newValue, originalArray) {
    const originalContainer = document.getElementById('originalArrayClone');
    const clonedContainer = document.getElementById('clonedArray');
    const explanation = document.getElementById('cloneExplanation');
    const stepsContainer = document.getElementById('cloneSteps');
    const continueButton = document.getElementById('continueAfterClone');
    
    // Create a true clone (deep copy)
    const clonedArray = [...originalArray];
    
    let currentStep = 0;
    
    function performCloneStep() {
        switch (currentStep) {
            case 0:
                // Step 1: Show original array
                explanation.innerHTML = 'Step 1: Original array created';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Original array created: [${originalArray.join(', ')}]
                    </div>
                `;
                break;
                
            case 1:
                // Step 2: Demonstrate reference assignment (wrong way)
                explanation.innerHTML = 'Step 2: Reference assignment (wrong way) - let copy = original';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step 2:</strong> Reference assignment: Both variables point to same array
                    </div>
                `;
                
                // Highlight both arrays as same
                const originalElements = originalContainer.querySelectorAll('.array-element');
                const clonedElements = clonedContainer.querySelectorAll('.array-element');
                
                originalElements.forEach(el => {
                    el.querySelector('.element-value').classList.add('warning-color');
                });
                clonedElements.forEach(el => {
                    el.querySelector('.element-value').classList.add('warning-color');
                });
                break;
                
            case 2:
                // Step 3: Show proper cloning
                explanation.innerHTML = 'Step 3: Proper cloning using spread operator - let clone = [...original]';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Proper cloning creates independent copy
                    </div>
                `;
                
                // Remove warning highlights and show success
                const allElements = document.querySelectorAll('.element-value');
                allElements.forEach(el => {
                    el.classList.remove('warning-color');
                    el.classList.add('info-color');
                });
                break;
                
            case 3:
                // Step 4: Modify cloned array
                explanation.innerHTML = `Step 4: Modifying cloned array at index ${index} with value "${newValue}"`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 4:</strong> Modifying clone[index ${index}] = "${newValue}"
                    </div>
                `;
                
                // Highlight the element being modified in cloned array
                const clonedElementsMod = clonedContainer.querySelectorAll('.array-element');
                const elementToModify = clonedElementsMod[index].querySelector('.element-value');
                elementToModify.classList.add('update', 'pulse');
                
                // After delay, update the cloned array
                setTimeout(() => {
                    clonedArray[index] = newValue;
                    renderArrayInContainer(clonedArray, 'clonedArray');
                    
                    // Highlight the modified element
                    const updatedElements = clonedContainer.querySelectorAll('.array-element');
                    const updatedElement = updatedElements[index].querySelector('.element-value');
                    updatedElement.classList.add('create', 'bounce');
                    
                    explanation.innerHTML = `Step 5: Cloned array modified! Original remains unchanged.`;
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 5:</strong> Clone modified successfully! Original array unchanged.
                        </div>
                    `;
                    
                    // Show comparison
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Result:</strong> 
                            Original: [${originalArray.join(', ')}] | 
                            Clone: [${clonedArray.join(', ')}]
                        </div>
                    `;
                    
                    currentStep++;
                    performCloneStep();
                }, 1500);
                return;
                
            case 4:
                // Step 5: Show that original is unchanged
                explanation.innerHTML = '<strong>Clone Demonstration Complete!</strong> Original array remains unchanged while clone is modified.';
                
                // Highlight the difference
                const originalElementsFinal = originalContainer.querySelectorAll('.array-element');
                const clonedElementsFinal = clonedContainer.querySelectorAll('.array-element');
                
                // Show original as unchanged (green)
                originalElementsFinal.forEach(el => {
                    el.querySelector('.element-value').classList.add('success-color');
                });
                
                // Show modified element in clone (yellow)
                clonedElementsFinal[index].querySelector('.element-value').classList.add('warning-color');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Clone operation successful! Arrays are independent.
                    </div>
                `;
                
                continueButton.style.display = 'block';
                continueButton.addEventListener('click', resetAfterClone);
                
                // Auto-reset after 5 seconds
                setTimeout(() => {
                    resetAfterClone();
                }, 5000);
                return;
        }
        
        currentStep++;
        setTimeout(performCloneStep, 2000);
    }
    
    // Start the demonstration
    performCloneStep();
}
// NEW: Reset after Clone Operation
function resetAfterClone() {
    // Clear inputs
    cloneIndex.value = '';
    cloneElementValue.value = '';
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    
    logOperation('Clone array demonstration completed', 'info');
    showNotification('Returned to original array view', 'success');
}  
// NEW: Merge Two Sorted Arrays Handler
function handleMergeSortedArrays() {
    if (isMergeOperationRunning) {
        showNotification('A merge operation is already in progress', 'warning');
        return;
    }

    // Reset arrays
    firstArray = [];
    secondArray = [];
    firstArraySize = 0;
    secondArraySize = 0;
    
    // Show input group
    mergeArraysGroup.style.display = 'block';
    firstArraySizeInput.focus();
    
    // Hide perform merge button initially
    performMergeBtn.style.display = 'none';
    
    logOperation('Started merge two sorted arrays operation', 'info');
}

// NEW: Confirm First Array Size Handler
function handleConfirmFirstArraySize() {
    const size = parseInt(firstArraySizeInput.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        firstArraySizeInput.focus();
        return;
    }
    
    firstArraySize = size;
    firstArray = [];
    
    // Create input fields for first array
    firstArrayInputs.innerHTML = '<label class="form-label">Enter elements for First Array:</label>';
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="text" class="form-control first-array-element" 
                   placeholder="Enter value" data-index="${i}">
        `;
        firstArrayInputs.appendChild(inputGroup);
    }
    
    // Add event listeners for first array inputs
    const firstArrayElements = firstArrayInputs.querySelectorAll('.first-array-element');
    firstArrayElements.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                // Auto-focus next input or move to second array
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('first-array-element')) {
                    nextInput.focus();
                } else {
                    secondArraySizeInput.focus();
                }
            }
        });
    });
    
    showNotification(`First array size set to ${size}. Please enter ${size} elements.`, 'success');
    logOperation(`First array size set to ${size}`, 'info');
}

// NEW: Confirm Second Array Size Handler
function handleConfirmSecondArraySize() {
    const size = parseInt(secondArraySizeInput.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        secondArraySizeInput.focus();
        return;
    }
    
    secondArraySize = size;
    secondArray = [];
    
    // Create input fields for second array
    secondArrayInputs.innerHTML = '<label class="form-label">Enter elements for Second Array:</label>';
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="text" class="form-control second-array-element" 
                   placeholder="Enter value" data-index="${i}">
        `;
        secondArrayInputs.appendChild(inputGroup);
    }
    
    // Add event listeners for second array inputs
    const secondArrayElements = secondArrayInputs.querySelectorAll('.second-array-element');
    secondArrayElements.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('second-array-element')) {
                    nextInput.focus();
                }
            }
        });
    });
    
    // Show perform merge button
    performMergeBtn.style.display = 'block';
    
    showNotification(`Second array size set to ${size}. Please enter ${size} elements.`, 'success');
    logOperation(`Second array size set to ${size}`, 'info');
}

// NEW: Perform Merge Handler
function handlePerformMerge() {
    // Collect first array elements
    const firstArrayInputs = document.querySelectorAll('.first-array-element');
    firstArray = [];
    
    for (let i = 0; i < firstArrayInputs.length; i++) {
        const value = firstArrayInputs[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all elements for first array. Missing element at position ${i}`, 'danger');
            firstArrayInputs[i].focus();
            return;
        }
        firstArray.push(value);
    }
    
    // Collect second array elements
    const secondArrayInputs = document.querySelectorAll('.second-array-element');
    secondArray = [];
    
    for (let i = 0; i < secondArrayInputs.length; i++) {
        const value = secondArrayInputs[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all elements for second array. Missing element at position ${i}`, 'danger');
            secondArrayInputs[i].focus();
            return;
        }
        secondArray.push(value);
    }
    
    // Store original array
    originalArrayBeforeMerge = [...myArray];
    
    // Hide input group
    mergeArraysGroup.style.display = 'none';
    
    // Start merge visualization
    showMergeVisualization();
}

// NEW: Cancel Merge Handler
function handleCancelMerge() {
    mergeArraysGroup.style.display = 'none';
    firstArraySizeInput.value = '';
    secondArraySizeInput.value = '';
    firstArrayInputs.innerHTML = '';
    secondArrayInputs.innerHTML = '';
    performMergeBtn.style.display = 'none';
    
    firstArray = [];
    secondArray = [];
    firstArraySize = 0;
    secondArraySize = 0;
    
    logOperation('Cancelled merge operation', 'info');
    showNotification('Merge operation cancelled', 'info');
}
// NEW: Show Merge Visualization
function showMergeVisualization() {
    isMergeOperationRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Merge Two Sorted Arrays</h5>
        
        <div class="array-group">
            <div class="array-label">First Array (Arr1)</div>
            <div class="original-array-container" id="firstArrayDisplay"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Second Array (Arr2)</div>
            <div class="original-array-container" id="secondArrayDisplay"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Merged Sorted Array</div>
            <div class="transformed-array-container" id="mergedArrayDisplay"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Merge Process:</strong> Merging two sorted arrays into one sorted array</p>
            <p class="mb-0" id="mergeExplanation">Starting merge operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="mergeStepsContainer">
            <h6 class="text-center">Merge Steps</h6>
            <div class="steps-container" id="mergeSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMerge" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display the input arrays
    renderArrayInContainer(firstArray, 'firstArrayDisplay');
    renderArrayInContainer(secondArray, 'secondArrayDisplay');
    renderArrayInContainer([], 'mergedArrayDisplay');
    
    // Start merge animation
    performMergeAnimation();
}

// NEW: Perform Merge Animation
function performMergeAnimation() {
    const firstContainer = document.getElementById('firstArrayDisplay');
    const secondContainer = document.getElementById('secondArrayDisplay');
    const mergedContainer = document.getElementById('mergedArrayDisplay');
    const explanation = document.getElementById('mergeExplanation');
    const stepsContainer = document.getElementById('mergeSteps');
    const continueButton = document.getElementById('continueAfterMerge');
    
    // Sort both arrays first (if not already sorted)
    const sortedFirstArray = [...firstArray].sort((a, b) => {
        const numA = parseFloat(a);
        const numB = parseFloat(b);
        if (!isNaN(numA) && !isNaN(numB)) {
            return numA - numB;
        }
        return a.toString().localeCompare(b.toString());
    });
    
    const sortedSecondArray = [...secondArray].sort((a, b) => {
        const numA = parseFloat(a);
        const numB = parseFloat(b);
        if (!isNaN(numA) && !isNaN(numB)) {
            return numA - numB;
        }
        return a.toString().localeCompare(b.toString());
    });
    
    let mergedArray = [];
    let i = 0, j = 0;
    let step = 0;
    
    function performMergeStep() {
        if (i >= sortedFirstArray.length && j >= sortedSecondArray.length) {
            // Merge completed
            explanation.innerHTML = `<strong>Merge Completed!</strong> Successfully merged two arrays into one sorted array.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Merge completed! Total elements: ${mergedArray.length}
                </div>
            `;
            
            // Highlight the merged array
            const mergedElements = mergedContainer.querySelectorAll('.array-element');
            mergedElements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('create', 'bounce');
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return to original after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterMerge();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterMerge);
            
            return;
        }
        
        step++;
        
        if (i < sortedFirstArray.length && j < sortedSecondArray.length) {
            // Compare elements from both arrays
            const val1 = sortedFirstArray[i];
            const val2 = sortedSecondArray[j];
            
            const num1 = parseFloat(val1);
            const num2 = parseFloat(val2);
            
            let shouldTakeFirst = false;
            
            if (!isNaN(num1) && !isNaN(num2)) {
                shouldTakeFirst = num1 <= num2;
            } else {
                shouldTakeFirst = val1 <= val2;
            }
            
            explanation.innerHTML = `Step ${step}: Comparing Arr1[${i}]="${val1}" and Arr2[${j}]="${val2}"`;
            
            // Highlight elements being compared
            const firstElements = firstContainer.querySelectorAll('.array-element');
            const secondElements = secondContainer.querySelectorAll('.array-element');
            
            if (i < firstElements.length) {
                firstElements[i].querySelector('.element-value').classList.add('sorting-current');
            }
            if (j < secondElements.length) {
                secondElements[j].querySelector('.element-value').classList.add('sorting-compared');
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Compare Arr1[${i}]="${val1}" and Arr2[${j}]="${val2}" - 
                    Taking ${shouldTakeFirst ? 'Arr1' : 'Arr2'} element
                </div>
            `;
            
            // Scroll steps container
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            setTimeout(() => {
                // Remove highlights
                if (i < firstElements.length) {
                    firstElements[i].querySelector('.element-value').classList.remove('sorting-current');
                }
                if (j < secondElements.length) {
                    secondElements[j].querySelector('.element-value').classList.remove('sorting-compared');
                }
                
                // Take the smaller element
                if (shouldTakeFirst) {
                    mergedArray.push(val1);
                    i++;
                } else {
                    mergedArray.push(val2);
                    j++;
                }
                
                // Update merged array display
                renderArrayInContainer(mergedArray, 'mergedArrayDisplay');
                
                // Continue to next step
                performMergeStep();
            }, 1500);
            
        } else if (i < sortedFirstArray.length) {
            // Take remaining elements from first array
            explanation.innerHTML = `Step ${step}: Taking remaining element from Arr1[${i}]="${sortedFirstArray[i]}"`;
            
            const firstElements = firstContainer.querySelectorAll('.array-element');
            if (i < firstElements.length) {
                firstElements[i].querySelector('.element-value').classList.add('create');
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}:</strong> Taking remaining element from Arr1[${i}]="${sortedFirstArray[i]}"
                </div>
            `;
            
            setTimeout(() => {
                if (i < firstElements.length) {
                    firstElements[i].querySelector('.element-value').classList.remove('create');
                }
                
                mergedArray.push(sortedFirstArray[i]);
                i++;
                
                renderArrayInContainer(mergedArray, 'mergedArrayDisplay');
                performMergeStep();
            }, 1000);
            
        } else {
            // Take remaining elements from second array
            explanation.innerHTML = `Step ${step}: Taking remaining element from Arr2[${j}]="${sortedSecondArray[j]}"`;
            
            const secondElements = secondContainer.querySelectorAll('.array-element');
            if (j < secondElements.length) {
                secondElements[j].querySelector('.element-value').classList.add('create');
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}:</strong> Taking remaining element from Arr2[${j}]="${sortedSecondArray[j]}"
                </div>
            `;
            
            setTimeout(() => {
                if (j < secondElements.length) {
                    secondElements[j].querySelector('.element-value').classList.remove('create');
                }
                
                mergedArray.push(sortedSecondArray[j]);
                j++;
                
                renderArrayInContainer(mergedArray, 'mergedArrayDisplay');
                performMergeStep();
            }, 1000);
        }
    }
    
    // Start merge process
    performMergeStep();
}

// NEW: Return to Original after Merge
function returnToOriginalAfterMerge() {
    // Reset to original array
    myArray = [...originalArrayBeforeMerge];
    originalArrayBeforeMerge = [];
    
    // Remove merge visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMergeOperationRunning = false;
    
    // Clear all merge-related data
    firstArray = [];
    secondArray = [];
    firstArraySize = 0;
    secondArraySize = 0;
    
    // Reset input groups
    mergeArraysGroup.style.display = 'none';
    firstArraySizeInput.value = '';
    secondArraySizeInput.value = '';
    firstArrayInputs.innerHTML = '';
    secondArrayInputs.innerHTML = '';
    performMergeBtn.style.display = 'none';
    
    logOperation('Merge operation completed - returned to original array', 'info');
    showNotification('Returned to original array after merge operation', 'success');
}

// NEW: Reverse Array Handler
function handleReverseArray() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - cannot reverse', 'info');
        return;
    }
    
    // Store original array
    originalArrayForOperations = [...myArray];
    currentOperation = 'reverse';
    
    // Show dual visualization for reversal
    showReverseVisualization();
}

// NEW: Handle Rotate Operation (Left/Right)
function handleRotateOperation(direction) {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - cannot rotate', 'info');
        return;
    }
    
    currentOperation = direction;
    
    // Show input for positions
    rotateInputGroup.style.display = 'flex';
    rotatePositionsInput.focus();
    rotatePositionsInput.placeholder = `Enter positions (1 to ${myArray.length})`;
    
    // Update button text based on direction
    confirmRotateBtn.innerHTML = 
        direction === 'left' 
            ? '<i class="fas fa-undo me-2"></i>Rotate Left' 
            : '<i class="fas fa-redo me-2"></i>Rotate Right';
}

// NEW: Confirm Rotate Handler
function handleConfirmRotate() {
    const positions = parseInt(rotatePositionsInput.value);
    const maxPositions = myArray.length;
    
    if (isNaN(positions) || positions < 1 || positions > maxPositions) {
        showNotification(`Please enter a valid number between 1 and ${maxPositions}`, 'danger');
        rotatePositionsInput.focus();
        return;
    }
    
    rotatePositions = positions;
    
    // Store original array
    originalArrayForOperations = [...myArray];
    
    // Hide input group
    rotateInputGroup.style.display = 'none';
    rotatePositionsInput.value = '';
    
    // Show rotation visualization
    if (currentOperation === 'left') {
        showRotateLeftVisualization();
    } else {
        showRotateRightVisualization();
    }
}

// NEW: Cancel Rotate Handler
function handleCancelRotate() {
    rotateInputGroup.style.display = 'none';
    rotatePositionsInput.value = '';
    currentOperation = null;
}

// NEW: Show Reverse Visualization
function showReverseVisualization() {
    // Create dual container for reverse operation
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Array Reversal Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalArrayOp"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrows-alt-h"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Reversed Array</div>
            <div class="transformed-array-container" id="transformedArrayOp"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Reversal Process:</strong> Swapping elements from both ends towards the center</p>
            <p class="mb-0" id="reverseExplanation">Starting reversal animation...</p>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterReverse" style="display: none;">
            <i class="fas fa-play me-1"></i>Continue with Reversed Array
        </button>
    `;
    
    // Replace the main array container
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Render original array
    renderArrayInContainer(originalArrayForOperations, 'originalArrayOp');
    
    // Render reversed array (initially same as original)
    renderArrayInContainer([...originalArrayForOperations], 'transformedArrayOp');
    
    // Start reversal animation
    performReverseAnimation();
}

// NEW: Perform Reverse Animation
function performReverseAnimation() {
    const originalContainer = document.getElementById('originalArrayOp');
    const transformedContainer = document.getElementById('transformedArrayOp');
    const explanation = document.getElementById('reverseExplanation');
    const continueButton = document.getElementById('continueAfterReverse');
    
    const array = [...originalArrayForOperations];
    const n = array.length;
    let step = 0;
    
    function performSwapStep(left, right) {
        if (left >= right) {
            // Reversal completed
            explanation.innerHTML = '<strong>Reversal Completed!</strong> Array has been successfully reversed.';
            
            // Show continue button
            continueButton.style.display = 'block';
            
            // Auto-proceed after 3 seconds
            const autoProceedTimer = setTimeout(() => {
                proceedWithReversedArray();
            }, 3000);
            
            continueButton.addEventListener('click', () => {
                clearTimeout(autoProceedTimer);
                proceedWithReversedArray();
            });
            
            return;
        }
        
        // Update explanation
        explanation.innerHTML = `Swapping elements at indices [${left}] and [${right}]: "${array[left]}"  "${array[right]}"`;
        
        // Highlight elements being swapped in original array
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const leftElement = originalElements[left].querySelector('.element-value');
        const rightElement = originalElements[right].querySelector('.element-value');
        
        leftElement.classList.add('reverse-highlight');
        rightElement.classList.add('reverse-highlight');
        
        // Calculate swap distance for animation
        const leftRect = originalElements[left].getBoundingClientRect();
        const rightRect = originalElements[right].getBoundingClientRect();
        const swapDistance = rightRect.left - leftRect.left;
        
        leftElement.style.setProperty('--swap-distance', `${swapDistance}px`);
        rightElement.style.setProperty('--swap-distance', `-${swapDistance}px`);
        
        // Perform swap animation
        setTimeout(() => {
            leftElement.classList.add('swap-animation');
            rightElement.classList.add('swap-animation');
            
            // After animation, update the transformed array
            setTimeout(() => {
                // Swap the elements
                [array[left], array[right]] = [array[right], array[left]];
                
                // Update transformed array display
                renderArrayInContainer(array, 'transformedArrayOp');
                
                // Remove highlights
                leftElement.classList.remove('reverse-highlight', 'swap-animation');
                rightElement.classList.remove('reverse-highlight', 'swap-animation');
                
                // Move to next pair
                step++;
                performSwapStep(left + 1, right - 1);
            }, 1000);
        }, 500);
    }
    
    // Start the reversal process
    performSwapStep(0, n - 1);
}

// NEW: Proceed with Reversed Array
function proceedWithReversedArray() {
    // Reverse the actual array
    myArray.reverse();
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    logOperation('Array reversed successfully', 'success');
    showNotification('Array reversed successfully', 'success');
    
    // Auto-reset after 8 seconds
    setTimeout(() => {
        resetAfterOperation();
    }, 8000);
}

// NEW: Show Rotate Left Visualization
function showRotateLeftVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Rotate Left by ${rotatePositions} Position(s)</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalArrayOp"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-left"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Rotated Array</div>
            <div class="transformed-array-container" id="transformedArrayOp"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Rotation Process:</strong> Moving first ${rotatePositions} element(s) to the end</p>
            <p class="mb-0" id="rotateExplanation">Starting rotation animation...</p>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterRotate" style="display: none;">
            <i class="fas fa-play me-1"></i>Continue with Rotated Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForOperations, 'originalArrayOp');
    renderArrayInContainer([...originalArrayForOperations], 'transformedArrayOp');
    
    performRotateLeftAnimation();
}

// NEW: Show Rotate Right Visualization
function showRotateRightVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Rotate Right by ${rotatePositions} Position(s)</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalArrayOp"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-right"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Rotated Array</div>
            <div class="transformed-array-container" id="transformedArrayOp"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Rotation Process:</strong> Moving last ${rotatePositions} element(s) to the beginning</p>
            <p class="mb-0" id="rotateExplanation">Starting rotation animation...</p>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterRotate" style="display: none;">
            <i class="fas fa-play me-1"></i>Continue with Rotated Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForOperations, 'originalArrayOp');
    renderArrayInContainer([...originalArrayForOperations], 'transformedArrayOp');
    
    performRotateRightAnimation();
}

// NEW: Perform Rotate Left Animation
function performRotateLeftAnimation() {
    const originalContainer = document.getElementById('originalArrayOp');
    const transformedContainer = document.getElementById('transformedArrayOp');
    const explanation = document.getElementById('rotateExplanation');
    const continueButton = document.getElementById('continueAfterRotate');
    
    const array = [...originalArrayForOperations];
    const k = rotatePositions;
    let currentStep = 0;
    
    function performRotationStep() {
        if (currentStep >= k) {
            // Rotation completed
            explanation.innerHTML = `<strong>Rotation Completed!</strong> Array rotated left by ${k} position(s).`;
            
            continueButton.style.display = 'block';
            const autoProceedTimer = setTimeout(() => {
                proceedWithRotatedArray();
            }, 3000);
            
            continueButton.addEventListener('click', () => {
                clearTimeout(autoProceedTimer);
                proceedWithRotatedArray();
            });
            
            return;
        }
        
        // Show current step
        explanation.innerHTML = `Moving element from position ${currentStep} to the end: "${array[currentStep]}"`;
        
        // Highlight current element being moved
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentStep].querySelector('.element-value');
        currentElement.classList.add('rotate-highlight');
        
        // Perform rotation animation
        setTimeout(() => {
            // Remove element from beginning and add to end
            const elementToMove = array.shift();
            array.push(elementToMove);
            
            // Update transformed array display
            renderArrayInContainer(array, 'transformedArrayOp');
            
            // Remove highlight
            currentElement.classList.remove('rotate-highlight');
            
            // Move to next step
            currentStep++;
            performRotationStep();
        }, 1500);
    }
    
    // Start rotation process
    performRotationStep();
}

// NEW: Perform Rotate Right Animation
function performRotateRightAnimation() {
    const originalContainer = document.getElementById('originalArrayOp');
    const transformedContainer = document.getElementById('transformedArrayOp');
    const explanation = document.getElementById('rotateExplanation');
    const continueButton = document.getElementById('continueAfterRotate');
    
    const array = [...originalArrayForOperations];
    const k = rotatePositions;
    let currentStep = 0;
    
    function performRotationStep() {
        if (currentStep >= k) {
            // Rotation completed
            explanation.innerHTML = `<strong>Rotation Completed!</strong> Array rotated right by ${k} position(s).`;
            
            continueButton.style.display = 'block';
            const autoProceedTimer = setTimeout(() => {
                proceedWithRotatedArray();
            }, 3000);
            
            continueButton.addEventListener('click', () => {
                clearTimeout(autoProceedTimer);
                proceedWithRotatedArray();
            });
            
            return;
        }
        
        // Show current step
        const moveIndex = array.length - 1;
        explanation.innerHTML = `Moving element from position ${moveIndex} to the beginning: "${array[moveIndex]}"`;
        
        // Highlight current element being moved
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[moveIndex].querySelector('.element-value');
        currentElement.classList.add('rotate-highlight');
        
        // Perform rotation animation
        setTimeout(() => {
            // Remove element from end and add to beginning
            const elementToMove = array.pop();
            array.unshift(elementToMove);
            
            // Update transformed array display
            renderArrayInContainer(array, 'transformedArrayOp');
            
            // Remove highlight
            currentElement.classList.remove('rotate-highlight');
            
            // Move to next step
            currentStep++;
            performRotationStep();
        }, 1500);
    }
    
    // Start rotation process
    performRotationStep();
}

// NEW: Proceed with Rotated Array
function proceedWithRotatedArray() {
    // Apply the rotation to the actual array
    if (currentOperation === 'left') {
        // Rotate left
        for (let i = 0; i < rotatePositions; i++) {
            myArray.push(myArray.shift());
        }
    } else {
        // Rotate right
        for (let i = 0; i < rotatePositions; i++) {
            myArray.unshift(myArray.pop());
        }
    }
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    const operationName = currentOperation === 'left' ? 'left rotation' : 'right rotation';
    logOperation(`Array ${operationName} by ${rotatePositions} position(s)`, 'success');
    showNotification(`Array ${operationName} by ${rotatePositions} position(s) successful`, 'success');
    
    // Auto-reset after 8 seconds
    setTimeout(() => {
        resetAfterOperation();
    }, 8000);
}

// NEW: Reset after operation
function resetAfterOperation() {
    if (originalArrayForOperations.length === 0) {
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayForOperations];
    originalArrayForOperations = [];
    currentOperation = null;
    rotatePositions = 0;
    
    renderArray();
    updateStats();
    
    logOperation('Reset to original array after operation', 'info');
    showNotification('Automatically reset to original array', 'info');
}
// NEW: Fill Array Handler
// NEW: Fill Array Handler
function handleFillArray() {
    const value = fillValue.value.trim();
    
    if (value === '') {
        showNotification('Please enter a value to fill', 'warning');
        fillValue.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    const startIndex = fillStart.value === '' ? 0 : parseInt(fillStart.value);
    const endIndex = fillEnd.value === '' ? myArray.length - 1 : parseInt(fillEnd.value);
    
    // Validate indices
    if (isNaN(startIndex) || startIndex < 0 || startIndex >= myArray.length) {
        showNotification(`Please enter a valid start index between 0 and ${myArray.length - 1}`, 'danger');
        fillStart.focus();
        return;
    }
    
    if (isNaN(endIndex) || endIndex < 0 || endIndex >= myArray.length) {
        showNotification(`Please enter a valid end index between 0 and ${myArray.length - 1}`, 'danger');
        fillEnd.focus();
        return;
    }
    
    // ADD THIS VALIDATION: Check if start index is greater than end index
    if (startIndex > endIndex) {
        showNotification('Start index cannot be greater than end index', 'danger');
        fillStart.focus();
        return;
    }
    
    // Store original array
    originalArrayForFill = [...myArray];
    isFillOperation = true;
    
    // Show fill operation visualization
    showFillVisualization(value, startIndex, endIndex);
}
// NEW: Show Fill Visualization
function showFillVisualization(value, startIndex, endIndex) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Fill Array Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalArrayOp"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After Fill Operation</div>
            <div class="transformed-array-container" id="transformedArrayOp"></div>
        </div>
        
        <div class="operation-explanation">
           <p class="mb-2"><strong>Fill Operation:</strong> Setting elements from index ${startIndex} to ${endIndex} to value "${value}"</p>
            <p class="mb-0" id="fillExplanation">Starting fill operation...</p>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterFill" style="display: none;">
            <i class="fas fa-play me-1"></i>Continue with Filled Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForFill, 'originalArrayOp');
    renderArrayInContainer([...originalArrayForFill], 'transformedArrayOp');
    
    performFillAnimation(value, startIndex, endIndex);
}

// NEW: Perform Fill Animation
function performFillAnimation(value, startIndex, endIndex) {
    const originalContainer = document.getElementById('originalArrayOp');
    const transformedContainer = document.getElementById('transformedArrayOp');
    const explanation = document.getElementById('fillExplanation');
    const continueButton = document.getElementById('continueAfterFill');
    
    const array = [...originalArrayForFill];
    let currentIndex = startIndex;
    
    function performFillStep() {
        if (currentIndex > endIndex) {
            // Fill operation completed
            explanation.innerHTML = `<strong>Fill Operation Completed!</strong> Filled ${endIndex - startIndex + 1} elements with value "${value}"`;
            
            continueButton.style.display = 'block';
            const autoProceedTimer = setTimeout(() => {
                proceedWithFilledArray(value, startIndex, endIndex);
            }, 3000);
            
            continueButton.addEventListener('click', () => {
                clearTimeout(autoProceedTimer);
                proceedWithFilledArray(value, startIndex, endIndex);
            });
            
            return;
        }
        
        // Update explanation
        explanation.innerHTML = `Filling index ${currentIndex} with value "${value}"`;
        
        // Highlight current element being filled
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentIndex].querySelector('.element-value');
        currentElement.classList.add('update');
        
        // Perform fill animation
        setTimeout(() => {
            // Update the array
            array[currentIndex] = value;
            
            // Update transformed array display
            renderArrayInContainer(array, 'transformedArrayOp');
            
            // Highlight the filled element in transformed array
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const transformedElement = transformedElements[currentIndex].querySelector('.element-value');
            transformedElement.classList.add('create', 'pulse');
            
            // Remove highlight from original element
            currentElement.classList.remove('update');
            
            // Move to next index
            currentIndex++;
            performFillStep();
        }, 800);
    }
    
    // Start fill operation
    performFillStep();
}

// NEW: Proceed with Filled Array
function proceedWithFilledArray(value, startIndex, endIndex) {
    // Apply the fill operation to the actual array
    for (let i = startIndex; i <= endIndex; i++) {
        myArray[i] = value;
    }
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Clear inputs
    fillValue.value = '';
    fillStart.value = '';
    fillEnd.value = '';
    
    logOperation(`Filled array from index ${startIndex} to ${endIndex} with value "${value}"`, 'warning');
    showNotification(`Array filled successfully with "${value}"`, 'success');
    
    // Auto-reset after 8 seconds
    setTimeout(() => {
        resetAfterFillOperation();
    }, 8000);
}

// NEW: Reset after Fill Operation
function resetAfterFillOperation() {
    if (!isFillOperation || originalArrayForFill.length === 0) {
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayForFill];
    originalArrayForFill = [];
    isFillOperation = false;
    
    renderArray();
    updateStats();
    
    logOperation('Reset to original array after fill operation', 'info');
    showNotification('Automatically reset to original array', 'info');
}

// NEW: Show Swap Input Group
function showSwapInputGroup(type) {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Hide all swap groups first
    swapByValuesGroup.style.display = 'none';
    swapByIndicesGroup.style.display = 'none';
    
    // Show the selected group
    if (type === 'values') {
        swapByValuesGroup.style.display = 'block';
        swapCount.focus();
    } else {
        swapByIndicesGroup.style.display = 'block';
        swapIndicesCount.focus();
    }
}

// NEW: Confirm Swap Count Handler (for values)
function handleConfirmSwapCount() {
    const count = parseInt(swapCount.value);
    
    if (isNaN(count) || count < 2) {
        showNotification('Please enter a valid number (minimum 2)', 'danger');
        swapCount.focus();
        return;
    }
    
    if (count > myArray.length) {
        showNotification(`Cannot swap more elements than array size (${myArray.length})`, 'danger');
        swapCount.focus();
        return;
    }
    
    // Create input fields for values
    swapValuesInputs.innerHTML = '';
    for (let i = 0; i < count; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Value ${i + 1}</span>
            <input type="text" class="form-control swap-value-input" placeholder="Enter element value">
        `;
        swapValuesInputs.appendChild(inputGroup);
    }
    
    const confirmButton = document.createElement('button');
    confirmButton.className = 'btn btn-glow w-100';
    confirmButton.innerHTML = '<i class="fas fa-exchange-alt me-2"></i>Perform Swap';
    confirmButton.addEventListener('click', handleSwapByValues);
    swapValuesInputs.appendChild(confirmButton);
}

// NEW: Confirm Swap Count Handler (for indices)
// NEW: Confirm Swap Count Handler (for indices)
function handleConfirmSwapIndicesCount() {
    const count = parseInt(swapIndicesCount.value);
    
    if (isNaN(count) || count < 2) {  // This line already ensures minimum 2
        showNotification('Please enter a valid number (minimum 2)', 'danger');
        swapIndicesCount.focus();
        return;
    }
    
    if (count > myArray.length) {
        showNotification(`Cannot swap more indices than array size (${myArray.length})`, 'danger');
        swapIndicesCount.focus();
        return;
    }
    
    // ADD THIS VALIDATION: Ensure we have enough unique indices available
    if (count > myArray.length) {
        showNotification(`Cannot select more than ${myArray.length} unique indices`, 'danger');
        swapIndicesCount.focus();
        return;
    }
    
    // Create input fields for indices
    swapIndicesInputs.innerHTML = '';
    for (let i = 0; i < count; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Index ${i + 1}</span>
            <input type="number" class="form-control swap-index-input" placeholder="Enter index (0 to ${myArray.length - 1})" min="0" max="${myArray.length - 1}">
        `;
        swapIndicesInputs.appendChild(inputGroup);
    }
    
    const confirmButton = document.createElement('button');
    confirmButton.className = 'btn btn-glow w-100';
    confirmButton.innerHTML = '<i class="fas fa-sync-alt me-2"></i>Perform Swap';
    confirmButton.addEventListener('click', handleSwapByIndices);
    swapIndicesInputs.appendChild(confirmButton);
}

// NEW: Swap by Values Handler
function handleSwapByValues() {
    const valueInputs = document.querySelectorAll('.swap-value-input');
    const values = [];
    
    // Collect values
    for (let input of valueInputs) {
        const value = input.value.trim();
        if (value === '') {
            showNotification('Please fill all value fields', 'warning');
            input.focus();
            return;
        }
        values.push(value);
    }
    
    // Check if all values exist in array
    const indices = [];
    for (let value of values) {
        let found = false;
        for (let i = 0; i < myArray.length; i++) {
            if (myArray[i] === value) {
                indices.push(i);
                found = true;
                break;
            }
        }
        if (!found) {
            showNotification(`Value "${value}" not found in array`, 'danger');
            return;
        }
    }
    
    // Check for duplicate indices (same value multiple times)
    if (new Set(indices).size !== indices.length) {
        showNotification('Cannot swap the same element multiple times', 'warning');
        return;
    }
    
    // Store original array
    originalArrayForSwap = [...myArray];
    isSwapOperation = true;
    
    // Perform swap visualization
    showSwapVisualization(indices, 'values');
}

// NEW: Swap by Indices Handler
// NEW: Swap by Indices Handler
function handleSwapByIndices() {
    const indexInputs = document.querySelectorAll('.swap-index-input');
    const indices = [];
    
    // Collect indices
    for (let input of indexInputs) {
        const index = parseInt(input.value);
        if (isNaN(index) || index < 0 || index >= myArray.length) {
            showNotification(`Please enter valid indices between 0 and ${myArray.length - 1}`, 'danger');
            input.focus();
            return;
        }
        indices.push(index);
    }
    
    // Check for duplicate indices
    if (new Set(indices).size !== indices.length) {
        showNotification('Cannot swap the same index multiple times', 'warning');
        return;
    }
    
    // ADD THIS VALIDATION: Check if there are at least 2 unique indices to swap
    if (indices.length < 2) {
        showNotification('At least 2 different indices are required for swapping', 'warning');
        return;
    }
    
    // Store original array
    originalArrayForSwap = [...myArray];
    isSwapOperation = true;
    
    // Perform swap visualization
    showSwapVisualization(indices, 'indices');
}

// NEW: Show Swap Visualization
function showSwapVisualization(indices, type) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Swap Elements Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalArrayOp"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrows-alt-h"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After Swap Operation</div>
            <div class="transformed-array-container" id="transformedArrayOp"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Swap Operation:</strong> Swapping ${indices.length} elements</p>
            <p class="mb-0" id="swapExplanation">Starting swap operation...</p>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSwap" style="display: none;">
            <i class="fas fa-play me-1"></i>Continue with Swapped Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSwap, 'originalArrayOp');
    renderArrayInContainer([...originalArrayForSwap], 'transformedArrayOp');
    
    performSwapAnimation(indices);
}

// NEW: Perform Swap Animation
function performSwapAnimation(indices) {
    const originalContainer = document.getElementById('originalArrayOp');
    const transformedContainer = document.getElementById('transformedArrayOp');
    const explanation = document.getElementById('swapExplanation');
    const continueButton = document.getElementById('continueAfterSwap');
    
    const array = [...originalArrayForSwap];
    const n = indices.length;
    
    // Perform circular swap
    function performSwapStep(step) {
        if (step >= n) {
            // Swap operation completed
            explanation.innerHTML = `<strong>Swap Operation Completed!</strong> Successfully swapped ${n} elements`;
            
            continueButton.style.display = 'block';
            const autoProceedTimer = setTimeout(() => {
                proceedWithSwappedArray(indices);
            }, 3000);
            
            continueButton.addEventListener('click', () => {
                clearTimeout(autoProceedTimer);
                proceedWithSwappedArray(indices);
            });
            
            return;
        }
        
        const currentIndex = indices[step];
        const nextIndex = indices[(step + 1) % n];
        
        // Update explanation
        explanation.innerHTML = `Swapping index ${currentIndex} ("${array[currentIndex]}") with index ${nextIndex} ("${array[nextIndex]}")`;
        
        // Highlight elements being swapped
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentIndex].querySelector('.element-value');
        const nextElement = originalElements[nextIndex].querySelector('.element-value');
        
        currentElement.classList.add('reverse-highlight');
        nextElement.classList.add('reverse-highlight');
        
        // Calculate swap distance for animation
        const currentRect = originalElements[currentIndex].getBoundingClientRect();
        const nextRect = originalElements[nextIndex].getBoundingClientRect();
        const swapDistance = nextRect.left - currentRect.left;
        
        currentElement.style.setProperty('--swap-distance', `${swapDistance}px`);
        nextElement.style.setProperty('--swap-distance', `-${swapDistance}px`);
        
        // Perform swap animation
        setTimeout(() => {
            currentElement.classList.add('swap-animation');
            nextElement.classList.add('swap-animation');
            
            // After animation, update the array
            setTimeout(() => {
                // Swap the elements
                [array[currentIndex], array[nextIndex]] = [array[nextIndex], array[currentIndex]];
                
                // Update transformed array display
                renderArrayInContainer(array, 'transformedArrayOp');
                
                // Remove highlights
                currentElement.classList.remove('reverse-highlight', 'swap-animation');
                nextElement.classList.remove('reverse-highlight', 'swap-animation');
                
                // Move to next step
                performSwapStep(step + 1);
            }, 1000);
        }, 500);
    }
    
    // Start swap operation
    performSwapStep(0);
}

// NEW: Proceed with Swapped Array
function proceedWithSwappedArray(indices) {
    // Apply the swap operation to the actual array
    const n = indices.length;
    const tempArray = [...myArray];
    
    // Perform circular swap
    for (let i = 0; i < n - 1; i++) {
        [tempArray[indices[i]], tempArray[indices[i + 1]]] = [tempArray[indices[i + 1]], tempArray[indices[i]]];
    }
    
    myArray = tempArray;
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Clear swap inputs
    swapCount.value = '';
    swapIndicesCount.value = '';
    swapValuesInputs.innerHTML = '';
    swapIndicesInputs.innerHTML = '';
    swapByValuesGroup.style.display = 'none';
    swapByIndicesGroup.style.display = 'none';
    
    logOperation(`Swapped ${indices.length} elements at indices: ${indices.join(', ')}`, 'warning');
    showNotification('Elements swapped successfully', 'success');
    
    // Auto-reset after 8 seconds
    setTimeout(() => {
        resetAfterSwapOperation();
    }, 8000);
}

// NEW: Reset after Swap Operation
function resetAfterSwapOperation() {
    if (!isSwapOperation || originalArrayForSwap.length === 0) {
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayForSwap];
    originalArrayForSwap = [];
    isSwapOperation = false;
    
    renderArray();
    updateStats();
    
    logOperation('Reset to original array after swap operation', 'info');
    showNotification('Automatically reset to original array', 'info');
}
// NEW: Two-Pointer Traversal Handler
function handleTwoPointerTraversal() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isTwoPointerRunning) {
        showNotification('Two-pointer traversal is already in progress', 'warning');
        return;
    }
    
    if (myArray.length < 2) {
        showNotification('Array must have at least 2 elements for two-pointer traversal', 'warning');
        return;
    }
    
    isTwoPointerRunning = true;
    twoPointerTraverseBtn.disabled = true;
    
    // Reset all elements first
    const elements = document.querySelectorAll('.array-element');
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('two-pointer-left', 'two-pointer-right', 'two-pointer-meet');
    });
    
    // Initialize pointers
    twoPointerLeft = 0;
    twoPointerRight = myArray.length - 1;
    
    // Update search results
    searchResults.innerHTML = `
        <div class="two-pointer-explanation">
            <p class="mb-1"><strong>Two-Pointer Traversal Started</strong></p>
            <p class="mb-1">Left Pointer: Index ${twoPointerLeft} | Right Pointer: Index ${twoPointerRight}</p>
            <p class="mb-0">Algorithm: Move pointers towards center until they meet</p>
        </div>
    `;
    
    // Start two-pointer traversal
    performTwoPointerTraversal();
}

// NEW: Perform Two-Pointer Traversal
function performTwoPointerTraversal() {
    if (twoPointerLeft > twoPointerRight || !isTwoPointerRunning) {
        // Traversal completed
        resetTwoPointerState();
        logOperation('Two-pointer traversal completed', 'success');
        showNotification('Two-pointer traversal completed', 'success');
        return;
    }
    
    const elements = document.querySelectorAll('.array-element');
    
    // Reset previous highlights
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('two-pointer-left', 'two-pointer-right', 'two-pointer-meet');
    });
    
    // Check if pointers meet
    if (twoPointerLeft === twoPointerRight) {
        // Pointers meet at center
        const centerElement = elements[twoPointerLeft];
        const centerValueDiv = centerElement.querySelector('.element-value');
        centerValueDiv.classList.add('two-pointer-meet');
        
        searchResults.innerHTML = `
            <div class="two-pointer-explanation">
                <p class="mb-1"><strong>Pointers Met at Center!</strong></p>
                <p class="mb-1">Meeting Point: Index ${twoPointerLeft}</p>
                <p class="mb-1">Value: "${myArray[twoPointerLeft]}"</p>
                <p class="mb-0">Traversal completed successfully</p>
            </div>
        `;
        
        // Move to next step after delay
        setTimeout(() => {
            twoPointerLeft++;
            twoPointerRight--;
            performTwoPointerTraversal();
        }, 1500);
        
        return;
    }
    
    // Highlight current pointers
    const leftElement = elements[twoPointerLeft];
    const rightElement = elements[twoPointerRight];
    const leftValueDiv = leftElement.querySelector('.element-value');
    const rightValueDiv = rightElement.querySelector('.element-value');
    
    leftValueDiv.classList.add('two-pointer-left');
    rightValueDiv.classList.add('two-pointer-right');
    
    // Update search results
    searchResults.innerHTML = `
        <div class="two-pointer-explanation">
            <p class="mb-1"><strong>Two-Pointer Traversal in Progress</strong></p>
            <p class="mb-1">Left Pointer: Index ${twoPointerLeft} | Value: "${myArray[twoPointerLeft]}"</p>
            <p class="mb-1">Right Pointer: Index ${twoPointerRight} | Value: "${myArray[twoPointerRight]}"</p>
            <p class="mb-0">Distance between pointers: ${twoPointerRight - twoPointerLeft}</p>
        </div>
    `;
    
    // Move pointers after delay
    setTimeout(() => {
        twoPointerLeft++;
        twoPointerRight--;
        performTwoPointerTraversal();
    }, 1000);
}

// NEW: Reset Two-Pointer State
function resetTwoPointerState() {
    isTwoPointerRunning = false;
    twoPointerTraverseBtn.disabled = false;
    twoPointerLeft = 0;
    twoPointerRight = 0;
    
    // Reset all two-pointer highlights
    const elements = document.querySelectorAll('.array-element');
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('two-pointer-left', 'two-pointer-right', 'two-pointer-meet');
    });
    
    // Clear search results after a short delay
    setTimeout(() => {
        searchResults.innerHTML = '<p class="text-center mb-0">Two-pointer traversal completed</p>';
    }, 3000);
}
// NEW: Sort Array Handler
function handleSort(order) {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - already sorted', 'info');
        return;
    }
    
    if (isSortingRunning) {
        showNotification('A sorting operation is already in progress', 'warning');
        return;
    }
    
    isSortingRunning = true;
    sortAscBtn.disabled = true;
    sortDescBtn.disabled = true;
    
    // Store original array
    originalArrayForSort = [...myArray];
    
    // Show sorting visualization
    showSortingVisualization(order);
}
// NEW: Show Sorting Visualization
function showSortingVisualization(order) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Sort Array ${order === 'asc' ? 'Ascending' : 'Descending'}</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalArrayOp"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Sorted Array</div>
            <div class="transformed-array-container" id="transformedArrayOp"></div>
        </div>
        
        <div class="sorting-explanation">
            <p class="mb-2"><strong>Sorting Algorithm:</strong> Bubble Sort (Step-by-Step)</p>
            <p class="mb-0" id="sortExplanation">Starting ${order === 'asc' ? 'ascending' : 'descending'} sort...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="algorithmStepsContainer">
            <h6 class="text-center">Sorting Steps</h6>
            <div class="steps-container" id="sortStepsContainer"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSort" style="display: none;">
            <i class="fas fa-play me-1"></i>Continue with Sorted Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSort, 'originalArrayOp');
    renderArrayInContainer([...originalArrayForSort], 'transformedArrayOp');
    
    performSortingAnimation(order);
}
// NEW: Perform Sorting Animation (Bubble Sort)
function performSortingAnimation(order) {
    const originalContainer = document.getElementById('originalArrayOp');
    const transformedContainer = document.getElementById('transformedArrayOp');
    const explanation = document.getElementById('sortExplanation');
    const stepsContainer = document.getElementById('sortStepsContainer');
    const continueButton = document.getElementById('continueAfterSort');
    
    const array = [...originalArrayForSort];
    const n = array.length;
    let sortedArray = [...array];
    let currentPass = 1;
    let currentComparison = 0;
    let totalSwaps = 0;
    
    // Convert to numbers for comparison if possible
    const isNumeric = !array.some(item => isNaN(parseFloat(item)));
    
    function performSortStep() {
        if (currentPass > n - 1) {
            // Sorting completed
            explanation.innerHTML = `<strong>Sorting Completed!</strong> Array sorted in ${order === 'asc' ? 'ascending' : 'descending'} order. Total passes: ${n-1}, Total swaps: ${totalSwaps}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Sorting completed! Array is now sorted.
                </div>
            `;
            
            // Highlight all elements as sorted
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                const valueDiv = el.querySelector('.element-value');
                setTimeout(() => {
                    valueDiv.classList.add('sorting-sorted');
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            const autoProceedTimer = setTimeout(() => {
                proceedWithSortedArray(order, sortedArray);
            }, 3000);
            
            continueButton.addEventListener('click', () => {
                clearTimeout(autoProceedTimer);
                proceedWithSortedArray(order, sortedArray);
            });
            
            return;
        }
        
        if (currentComparison >= n - currentPass) {
            // Pass completed
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Pass ${currentPass} Complete:</strong> Largest ${order === 'asc' ? '' : 'smallest'} element bubbled to position ${n - currentPass}
                </div>
            `;
            
            // Highlight the last sorted element
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const sortedElement = transformedElements[n - currentPass].querySelector('.element-value');
            sortedElement.classList.add('sorting-sorted');
            
            currentPass++;
            currentComparison = 0;
            performSortStep();
            return;
        }
        
        const i = currentComparison;
        const j = i + 1;
        
        // Update explanation
        explanation.innerHTML = `Pass ${currentPass}: Comparing elements at indices ${i} and ${j}`;
        
        // Highlight elements being compared
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const elementI = originalElements[i].querySelector('.element-value');
        const elementJ = originalElements[j].querySelector('.element-value');
        
        elementI.classList.add('sorting-current');
        elementJ.classList.add('sorting-compared');
        
        // Compare values
        let shouldSwap = false;
        if (isNumeric) {
            const valI = parseFloat(sortedArray[i]);
            const valJ = parseFloat(sortedArray[j]);
            shouldSwap = order === 'asc' ? valI > valJ : valI < valJ;
        } else {
            shouldSwap = order === 'asc' ? sortedArray[i] > sortedArray[j] : sortedArray[i] < sortedArray[j];
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${shouldSwap ? 'active' : ''}">
                <strong>Step:</strong> Compare [${i}]="${sortedArray[i]}" and [${j}]="${sortedArray[j]}" - 
                ${shouldSwap ? 'SWAP needed' : 'No swap needed'}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            if (shouldSwap) {
                // Perform swap
                explanation.innerHTML = `Pass ${currentPass}: Swapping elements at indices ${i} and ${j}`;
                
                elementI.classList.remove('sorting-current');
                elementJ.classList.remove('sorting-compared');
                elementI.classList.add('sorting-swap');
                elementJ.classList.add('sorting-swap');
                
                // Calculate swap distance for animation
                const rectI = originalElements[i].getBoundingClientRect();
                const rectJ = originalElements[j].getBoundingClientRect();
                const swapDistance = rectJ.left - rectI.left;
                
                elementI.style.setProperty('--swap-distance', `${swapDistance}px`);
                elementJ.style.setProperty('--swap-distance', `-${swapDistance}px`);
                
                setTimeout(() => {
                    elementI.classList.add('swap-animation');
                    elementJ.classList.add('swap-animation');
                    
                    setTimeout(() => {
                        // Swap the elements
                        [sortedArray[i], sortedArray[j]] = [sortedArray[j], sortedArray[i]];
                        totalSwaps++;
                        
                        // Update transformed array display
                        renderArrayInContainer(sortedArray, 'transformedArrayOp');
                        
                        // Remove highlights
                        elementI.classList.remove('sorting-swap', 'swap-animation');
                        elementJ.classList.remove('sorting-swap', 'swap-animation');
                        
                        currentComparison++;
                        performSortStep();
                    }, 1000);
                }, 500);
            } else {
                // No swap needed
                elementI.classList.remove('sorting-current');
                elementJ.classList.remove('sorting-compared');
                
                currentComparison++;
                performSortStep();
            }
        }, 1500);
    }
    
    // Start sorting process
    performSortStep();
}
// NEW: Proceed with Sorted Array
function proceedWithSortedArray(order, sortedArray) {
    // Apply the sorted array
    myArray = sortedArray;
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    logOperation(`Array sorted in ${order === 'asc' ? 'ascending' : 'descending'} order`, 'success');
    showNotification(`Array sorted in ${order === 'asc' ? 'ascending' : 'descending'} order successfully`, 'success');
    
    // Reset sorting state
    isSortingRunning = false;
    sortAscBtn.disabled = false;
    sortDescBtn.disabled = false;
    
    // Auto-reset after 10 seconds
    setTimeout(() => {
        resetAfterSortOperation();
    }, 10000);
}

// NEW: Reset after Sort Operation
function resetAfterSortOperation() {
    if (originalArrayForSort.length === 0) {
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayForSort];
    originalArrayForSort = [];
    
    renderArray();
    updateStats();
    
    logOperation('Reset to original array after sorting', 'info');
    showNotification('Automatically reset to original array', 'info');
}
// NEW: Check if Array is Sorted Handler
function handleCheckSorted() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isValidationRunning) {
        showNotification('A validation operation is already in progress', 'warning');
        return;
    }
    
    isValidationRunning = true;
    checkSortedBtn.disabled = true;
    
    // Reset all elements first
    const elements = document.querySelectorAll('.array-element');
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('sorted-correct', 'sorted-incorrect');
    });
    
    // Check if array is sorted and show visualization
    checkArraySorted();
}

// NEW: Partial Sort Handler
function handlePartialSort() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isPartialSortRunning) {
        showNotification('A partial sort operation is already in progress', 'warning');
        return;
    }
    
    // Show input for number of elements
    partialSortInputGroup.style.display = 'flex';
    partialSortCount.placeholder = `Enter K (1 to ${myArray.length})`;
    partialSortCount.max = myArray.length;
    partialSortCount.focus();
}

// NEW: Confirm Partial Sort Handler
function handleConfirmPartialSort() {
    const k = parseInt(partialSortCount.value);
    
    if (isNaN(k) || k < 1 || k > myArray.length) {
        showNotification(`Please enter a valid number between 1 and ${myArray.length}`, 'danger');
        partialSortCount.focus();
        return;
    }
    
    // Hide input group
    partialSortInputGroup.style.display = 'none';
    partialSortCount.value = '';
    
    // Store original array
    originalArrayForPartialSort = [...myArray];
    
    // Perform partial sort visualization
    performPartialSort(k);
}

// NEW: Cancel Partial Sort Handler
function handleCancelPartialSort() {
    partialSortInputGroup.style.display = 'none';
    partialSortCount.value = '';
}
// NEW: Check Array Sorted with Visualization
function checkArraySorted() {
    const elements = document.querySelectorAll('.array-element');
    let isAscending = true;
    let isDescending = true;
    const incorrectPairs = [];
    
    // Check ascending order
    for (let i = 1; i < myArray.length; i++) {
        const prev = parseFloat(myArray[i-1]);
        const curr = parseFloat(myArray[i]);
        
        // Try numeric comparison first
        if (!isNaN(prev) && !isNaN(curr)) {
            if (prev > curr) {
                isAscending = false;
                incorrectPairs.push({index1: i-1, index2: i, reason: `Number ${prev} > ${curr}`});
            }
        } else {
            // String comparison
            if (myArray[i-1] > myArray[i]) {
                isAscending = false;
                incorrectPairs.push({index1: i-1, index2: i, reason: `String "${myArray[i-1]}" > "${myArray[i]}"`});
            }
        }
    }
    
    // Check descending order
    for (let i = 1; i < myArray.length; i++) {
        const prev = parseFloat(myArray[i-1]);
        const curr = parseFloat(myArray[i]);
        
        // Try numeric comparison first
        if (!isNaN(prev) && !isNaN(curr)) {
            if (prev < curr) {
                isDescending = false;
            }
        } else {
            // String comparison
            if (myArray[i-1] < myArray[i]) {
                isDescending = false;
            }
        }
    }
    
    // Show validation visualization
    showSortedValidation(isAscending, isDescending, incorrectPairs);
}

// NEW: Show Sorted Validation with Animation
function showSortedValidation(isAscending, isDescending, incorrectPairs) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    
    let resultMessage = '';
    let resultType = '';
    
    if (isAscending) {
        resultMessage = 'Array is sorted in ASCENDING order';
        resultType = 'success';
    } else if (isDescending) {
        resultMessage = 'Array is sorted in DESCENDING order';
        resultType = 'success';
    } else {
        resultMessage = 'Array is NOT sorted';
        resultType = 'danger';
    }
    
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Array Sorting Validation</h5>
        
        <div class="array-group">
            <div class="array-label">Array to Validate</div>
            <div class="original-array-container" id="validationArray"></div>
        </div>
        
        <div class="validation-explanation">
            <p class="mb-2"><strong>Validation Result:</strong> ${resultMessage}</p>
            <p class="mb-0" id="validationExplanation">Starting validation check...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="validationStepsContainer">
            <h6 class="text-center">Validation Steps</h6>
            <div class="steps-container" id="validationSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterValidation">
            <i class="fas fa-play me-1"></i>Continue
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(myArray, 'validationArray');
    
    performValidationAnimation(isAscending, isDescending, incorrectPairs, resultMessage);
}

// NEW: Perform Validation Animation
function performValidationAnimation(isAscending, isDescending, incorrectPairs, resultMessage) {
    const validationContainer = document.getElementById('validationArray');
    const explanation = document.getElementById('validationExplanation');
    const stepsContainer = document.getElementById('validationSteps');
    const continueButton = document.getElementById('continueAfterValidation');
    
    const elements = validationContainer.querySelectorAll('.array-element');
    let currentStep = 0;
    
    function performValidationStep() {
        if (currentStep >= myArray.length - 1) {
            // Validation completed
            explanation.innerHTML = `<strong>Validation Complete!</strong> ${resultMessage}`;
            
            // Highlight final result
            if (isAscending || isDescending) {
                // All elements are sorted - highlight all green
                elements.forEach((el, index) => {
                    const valueDiv = el.querySelector('.element-value');
                    setTimeout(() => {
                        valueDiv.classList.add('sorted-correct');
                    }, index * 200);
                });
            } else {
                // Highlight incorrect pairs in red
                incorrectPairs.forEach(pair => {
                    const valueDiv1 = elements[pair.index1].querySelector('.element-value');
                    const valueDiv2 = elements[pair.index2].querySelector('.element-value');
                    valueDiv1.classList.add('sorted-incorrect');
                    valueDiv2.classList.add('sorted-incorrect');
                });
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> ${resultMessage}
                </div>
            `;
            
            continueButton.style.display = 'block';
            continueButton.addEventListener('click', resetAfterValidation);
            
            return;
        }
        
        const i = currentStep;
        const j = i + 1;
        
        // Update explanation
        explanation.innerHTML = `Checking elements at indices ${i} and ${j}: "${myArray[i]}" and "${myArray[j]}"`;
        
        // Highlight elements being compared
        const elementI = elements[i].querySelector('.element-value');
        const elementJ = elements[j].querySelector('.element-value');
        
        elementI.classList.add('sorting-current');
        elementJ.classList.add('sorting-compared');
        
        // Check if this pair is incorrect
        const isIncorrect = incorrectPairs.some(pair => 
            (pair.index1 === i && pair.index2 === j) || 
            (pair.index1 === j && pair.index2 === i)
        );
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${isIncorrect ? 'active' : ''}">
                <strong>Step ${currentStep + 1}:</strong> Compare [${i}]="${myArray[i]}" and [${j}]="${myArray[j]}" - 
                ${isIncorrect ? 'NOT in order' : 'in correct order'}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            if (isIncorrect) {
                // Mark as incorrect
                elementI.classList.remove('sorting-current', 'sorting-compared');
                elementI.classList.add('sorted-incorrect');
                elementJ.classList.add('sorted-incorrect');
            } else {
                // Mark as correct
                elementI.classList.remove('sorting-current', 'sorting-compared');
                elementI.classList.add('sorted-correct');
                elementJ.classList.add('sorted-correct');
            }
            
            currentStep++;
            performValidationStep();
        }, 1500);
    }
    
    // Start validation process
    performValidationStep();
}

// NEW: Reset after Validation
function resetAfterValidation() {
    isValidationRunning = false;
    checkSortedBtn.disabled = false;
    
    // Remove validation visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    
    logOperation('Array sorting validation completed', 'info');
}

// NEW: Perform Partial Sort
function performPartialSort(k) {
    if (isPartialSortRunning) {
        showNotification('A partial sort operation is already in progress', 'warning');
        return;
    }
    
    isPartialSortRunning = true;
    partialSortBtn.disabled = true;
    
    // Show partial sort visualization
    showPartialSortVisualization(k);
}

// NEW: Show Partial Sort Visualization
function showPartialSortVisualization(k) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Partial Sort - First ${k} Elements</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalPartialArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After Partial Sort</div>
            <div class="transformed-array-container" id="transformedPartialArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Partial Sort:</strong> Sorting first ${k} elements in ascending order</p>
            <p class="mb-0" id="partialSortExplanation">Starting partial sort...</p>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPartialSort" style="display: none;">
            <i class="fas fa-play me-1"></i>Continue with Partially Sorted Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForPartialSort, 'originalPartialArray');
    renderArrayInContainer([...originalArrayForPartialSort], 'transformedPartialArray');
    
    performPartialSortAnimation(k);
}

// NEW: Perform Partial Sort Animation
function performPartialSortAnimation(k) {
    const originalContainer = document.getElementById('originalPartialArray');
    const transformedContainer = document.getElementById('transformedPartialArray');
    const explanation = document.getElementById('partialSortExplanation');
    const continueButton = document.getElementById('continueAfterPartialSort');
    
    const array = [...originalArrayForPartialSort];
    let sortedArray = [...array];
    
    // Perform selection sort on first k elements
    function performPartialSortStep(i) {
        if (i >= k) {
            // Partial sort completed
            explanation.innerHTML = `<strong>Partial Sort Completed!</strong> First ${k} elements are now sorted`;
            
            // Highlight the sorted portion
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            for (let j = 0; j < k; j++) {
                const valueDiv = transformedElements[j].querySelector('.element-value');
                valueDiv.classList.add('partial-sorted');
            }
            
            continueButton.style.display = 'block';
            const autoProceedTimer = setTimeout(() => {
                proceedWithPartialSort(sortedArray);
            }, 3000);
            
            continueButton.addEventListener('click', () => {
                clearTimeout(autoProceedTimer);
                proceedWithPartialSort(sortedArray);
            });
            
            return;
        }
        
        // Find minimum in the remaining unsorted portion (within first k elements)
        let minIndex = i;
        
        explanation.innerHTML = `Finding minimum in remaining unsorted portion (indices ${i} to ${k-1})`;
        
        // Highlight current search for minimum
        const originalElements = originalContainer.querySelectorAll('.array-element');
        for (let j = i; j < k; j++) {
            setTimeout(() => {
                const valueDiv = originalElements[j].querySelector('.element-value');
                valueDiv.classList.add('sorting-compared');
                
                if (j === i) {
                    valueDiv.classList.add('sorting-current');
                }
            }, (j - i) * 300);
        }
        
        setTimeout(() => {
            // Actually find the minimum
            for (let j = i + 1; j < k; j++) {
                const currentVal = parseFloat(sortedArray[j]);
                const minVal = parseFloat(sortedArray[minIndex]);
                
                if (!isNaN(currentVal) && !isNaN(minVal)) {
                    if (currentVal < minVal) minIndex = j;
                } else {
                    if (sortedArray[j] < sortedArray[minIndex]) minIndex = j;
                }
            }
            
            // Swap if needed
            if (minIndex !== i) {
                explanation.innerHTML = `Swapping elements at indices ${i} and ${minIndex}`;
                
                // Highlight the swap
                const valueDivI = originalElements[i].querySelector('.element-value');
                const valueDivMin = originalElements[minIndex].querySelector('.element-value');
                
                valueDivI.classList.remove('sorting-current');
                valueDivMin.classList.remove('sorting-compared');
                valueDivI.classList.add('sorting-swap');
                valueDivMin.classList.add('sorting-swap');
                
                // Perform swap
                [sortedArray[i], sortedArray[minIndex]] = [sortedArray[minIndex], sortedArray[i]];
                
                // Update transformed array
                renderArrayInContainer(sortedArray, 'transformedPartialArray');
                
                // Remove highlights and move to next step
                setTimeout(() => {
                    valueDivI.classList.remove('sorting-swap');
                    valueDivMin.classList.remove('sorting-swap');
                    performPartialSortStep(i + 1);
                }, 1000);
            } else {
                // No swap needed, move to next step
                explanation.innerHTML = `No swap needed - element at index ${i} is already the minimum`;
                
                // Remove highlights
                for (let j = i; j < k; j++) {
                    const valueDiv = originalElements[j].querySelector('.element-value');
                    valueDiv.classList.remove('sorting-current', 'sorting-compared', 'sorting-swap');
                }
                
                performPartialSortStep(i + 1);
            }
        }, (k - i) * 300 + 500);
    }
    
    // Start partial sort process
    performPartialSortStep(0);
}

// NEW: Proceed with Partial Sort
function proceedWithPartialSort(sortedArray) {
    // Apply the partial sort to the actual array
    myArray = sortedArray;
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isPartialSortRunning = false;
    partialSortBtn.disabled = false;
    
    logOperation(`Partially sorted first ${originalArrayForPartialSort.length} elements`, 'success');
    showNotification(`Partially sorted first ${originalArrayForPartialSort.length} elements successfully`, 'success');
    
    // Auto-reset after 10 seconds
    setTimeout(() => {
        resetAfterPartialSort();
    }, 10000);
}

// NEW: Reset after Partial Sort
function resetAfterPartialSort() {
    if (originalArrayForPartialSort.length === 0) {
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayForPartialSort];
    originalArrayForPartialSort = [];
    
    renderArray();
    updateStats();
    
    logOperation('Reset to original array after partial sort', 'info');
    showNotification('Automatically reset to original array', 'info');
}
// NEW: Fixed-size Sliding Window Handler
function handleFixedWindow() {
    const k = parseInt(fixedWindowSize.value);
    
    if (isNaN(k) || k < 1 || k > myArray.length) {
        showNotification(`Please enter a valid window size between 1 and ${myArray.length}`, 'danger');
        fixedWindowSize.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Sliding window operations require all array elements to be numbers', 'danger');
        return;
    }
    
    if (isWindowOperationRunning) {
        showNotification('A window operation is already in progress', 'warning');
        return;
    }
    
    isWindowOperationRunning = true;
    
    // Store original array
    originalArrayForWindow = [...myArray];
    
    // Perform fixed window visualization
    performFixedWindowVisualization(k);
}

// NEW: Variable-size Sliding Window Handler
function handleVariableWindow() {
    const targetSum = parseFloat(variableWindowSum.value);
    
    if (isNaN(targetSum)) {
        showNotification('Please enter a valid target sum', 'danger');
        variableWindowSum.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Sliding window operations require all array elements to be numbers', 'danger');
        return;
    }
    
    if (isWindowOperationRunning) {
        showNotification('A window operation is already in progress', 'warning');
        return;
    }
    
    isWindowOperationRunning = true;
    
    // Store original array
    originalArrayForWindow = [...myArray];
    
    // Perform variable window visualization
    performVariableWindowVisualization(targetSum);
}
// NEW: Perform Fixed Window Visualization
function performFixedWindowVisualization(k) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Fixed-size Sliding Window (k = ${k})</h5>
        
        <div class="array-group">
            <div class="array-label">Array</div>
            <div class="original-array-container" id="windowArray"></div>
        </div>
        
        <div class="window-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find maximum sum of any contiguous subarray of length ${k}</p>
            <p class="mb-0" id="windowExplanation">Initializing sliding window...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="windowStepsContainer">
            <h6 class="text-center">Sliding Window Steps</h6>
            <div class="steps-container" id="windowSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Maximum Sum Found</div>
            <div class="stats-value" id="maxSumValue">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterWindow" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForWindow, 'windowArray');
    
    executeFixedWindowAlgorithm(k);
}

// NEW: Execute Fixed Window Algorithm with Animation
function executeFixedWindowAlgorithm(k) {
    const arrayContainer = document.getElementById('windowArray');
    const explanation = document.getElementById('windowExplanation');
    const stepsContainer = document.getElementById('windowSteps');
    const maxSumValue = document.getElementById('maxSumValue');
    const continueButton = document.getElementById('continueAfterWindow');
    
    const arr = originalArrayForWindow.map(val => parseFloat(val));
    let maxSum = 0;
    let currentSum = 0;
    let maxStart = 0;
    let step = 0;
    
    function executeStep() {
        if (step === 0) {
            // Step 1: Calculate first window
            explanation.innerHTML = `Calculating sum of first window (indices 0 to ${k-1})`;
            
            for (let i = 0; i < k; i++) {
                setTimeout(() => {
                    const elements = arrayContainer.querySelectorAll('.array-element');
                    const valueDiv = elements[i].querySelector('.element-value');
                    valueDiv.classList.add('window-included');
                }, i * 300);
            }
            
            setTimeout(() => {
                for (let i = 0; i < k; i++) {
                    currentSum += arr[i];
                }
                maxSum = currentSum;
                maxStart = 0;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> First window sum = ${currentSum} (indices 0-${k-1})
                    </div>
                `;
                
                maxSumValue.textContent = maxSum;
                step++;
                executeStep();
            }, k * 300 + 500);
            
        } else if (step <= arr.length - k) {
            const i = step + k - 1; // Current right pointer
            
            explanation.innerHTML = `Sliding window: Removing [${i-k}]=${arr[i-k]}, Adding [${i}]=${arr[i]}`;
            
            // Highlight the elements being swapped in the window
            const elements = arrayContainer.querySelectorAll('.array-element');
            
            // Remove left element highlight
            const leftElement = elements[i - k].querySelector('.element-value');
            leftElement.classList.remove('window-included');
            leftElement.classList.add('window-left');
            
            // Add right element highlight
            const rightElement = elements[i].querySelector('.element-value');
            rightElement.classList.add('window-right');
            
            setTimeout(() => {
                // Update sum
                currentSum += arr[i] - arr[i - k];
                
                // Remove temporary highlights
                leftElement.classList.remove('window-left');
                rightElement.classList.remove('window-right');
                rightElement.classList.add('window-included');
                
                // Update all window elements
                for (let j = i - k + 1; j <= i; j++) {
                    elements[j].querySelector('.element-value').classList.add('window-included');
                }
                
                // Check if this is new maximum
                if (currentSum > maxSum) {
                    maxSum = currentSum;
                    maxStart = i - k + 1;
                    
                    // Highlight the new maximum window
                    for (let j = maxStart; j < maxStart + k; j++) {
                        elements[j].querySelector('.element-value').classList.add('window-max');
                    }
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step + 1}:</strong> New max sum = ${maxSum} (indices ${maxStart}-${maxStart + k - 1})
                        </div>
                    `;
                } else {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step + 1}:</strong> Current sum = ${currentSum}, Max sum = ${maxSum}
                        </div>
                    `;
                }
                
                maxSumValue.textContent = maxSum;
                step++;
                executeStep();
            }, 1000);
            
        } else {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Maximum sum = ${maxSum} in window [${maxStart}-${maxStart + k - 1}]`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Maximum sum of any ${k}-length subarray = ${maxSum}
                </div>
            `;
            
            // Highlight the final maximum window
            const elements = arrayContainer.querySelectorAll('.array-element');
            for (let j = maxStart; j < maxStart + k; j++) {
                elements[j].querySelector('.element-value').classList.add('window-max');
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterWindow();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterWindow);
        }
    }
    
    // Start execution
    executeStep();
}

// NEW: Perform Variable Window Visualization
function performVariableWindowVisualization(targetSum) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Variable-size Sliding Window (Sum  ${targetSum})</h5>
        
        <div class="array-group">
            <div class="array-label">Array</div>
            <div class="original-array-container" id="varWindowArray"></div>
        </div>
        
        <div class="window-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find longest subarray with sum  ${targetSum}</p>
            <p class="mb-0" id="varWindowExplanation">Initializing sliding window...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="varWindowStepsContainer">
            <h6 class="text-center">Sliding Window Steps</h6>
            <div class="steps-container" id="varWindowSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Longest Subarray Length</div>
            <div class="stats-value" id="longestLengthValue">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterVarWindow" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForWindow, 'varWindowArray');
    
    executeVariableWindowAlgorithm(targetSum);
}

// NEW: Execute Variable Window Algorithm with Animation
function executeVariableWindowAlgorithm(targetSum) {
    const arrayContainer = document.getElementById('varWindowArray');
    const explanation = document.getElementById('varWindowExplanation');
    const stepsContainer = document.getElementById('varWindowSteps');
    const longestLengthValue = document.getElementById('longestLengthValue');
    const continueButton = document.getElementById('continueAfterVarWindow');
    
    const arr = originalArrayForWindow.map(val => parseFloat(val));
    let left = 0;
    let currentSum = 0;
    let maxLength = 0;
    let maxStart = 0;
    let step = 0;
    
    function executeStep(right) {
        if (right >= arr.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Longest subarray length = ${maxLength}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Longest subarray with sum  ${targetSum} has length = ${maxLength}
                </div>
            `;
            
            // Highlight the final longest subarray
            const elements = arrayContainer.querySelectorAll('.array-element');
            for (let j = maxStart; j < maxStart + maxLength; j++) {
                elements[j].querySelector('.element-value').classList.add('window-max');
            }
            
            longestLengthValue.textContent = maxLength;
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterWindow();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterWindow);
            
            return;
        }
        
        // Add current element to window
        explanation.innerHTML = `Adding element [${right}]=${arr[right]} to window`;
        
        const elements = arrayContainer.querySelectorAll('.array-element');
        const rightElement = elements[right].querySelector('.element-value');
        rightElement.classList.add('window-right');
        
        setTimeout(() => {
            currentSum += arr[right];
            rightElement.classList.remove('window-right');
            rightElement.classList.add('window-included');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step + 1}:</strong> Added [${right}]=${arr[right]}, Current sum = ${currentSum}
                </div>
            `;
            
            step++;
            
            // Shrink window from left if sum exceeds target
            if (currentSum > targetSum) {
                explanation.innerHTML = `Sum ${currentSum} > ${targetSum}, shrinking window from left`;
                
                const shrinkStep = () => {
                    if (currentSum > targetSum && left <= right) {
                        const leftElement = elements[left].querySelector('.element-value');
                        leftElement.classList.add('window-left');
                        
                        setTimeout(() => {
                            currentSum -= arr[left];
                            leftElement.classList.remove('window-left', 'window-included');
                            
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step">
                                    <strong>Step ${step + 1}:</strong> Removed [${left}]=${arr[left]}, New sum = ${currentSum}
                                </div>
                            `;
                            
                            step++;
                            left++;
                            shrinkStep();
                        }, 800);
                    } else {
                        // Continue with next right pointer
                        checkMaxLength(right);
                    }
                };
                
                shrinkStep();
            } else {
                checkMaxLength(right);
            }
            
            function checkMaxLength(right) {
                // Update max length if current window is valid and longer
                if (currentSum <= targetSum && (right - left + 1) > maxLength) {
                    maxLength = right - left + 1;
                    maxStart = left;
                    
                    // Highlight the new longest subarray
                    for (let j = maxStart; j <= right; j++) {
                        elements[j].querySelector('.element-value').classList.add('window-max');
                    }
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step + 1}:</strong> New longest subarray! Length = ${maxLength} (indices ${left}-${right})
                        </div>
                    `;
                }
                
                longestLengthValue.textContent = maxLength;
                
                // Move to next right pointer
                setTimeout(() => {
                    executeStep(right + 1);
                }, 1000);
            }
        }, 800);
    }
    
    // Start execution
    executeStep(0);
}

// NEW: Return to Original after Window Operations
function returnToOriginalAfterWindow() {
    // Reset to original array
    myArray = [...originalArrayForWindow];
    originalArrayForWindow = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isWindowOperationRunning = false;
    
    // Clear inputs
    fixedWindowSize.value = '';
    variableWindowSum.value = '';
    
    logOperation('Window operation completed - returned to original array', 'info');
    showNotification('Returned to original array after window operation', 'success');
}
// NEW: Two-Pointer Sort Handler
function handleTwoPointerSort() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isTwoPointerSortRunning) {
        showNotification('Two-pointer sort is already in progress', 'warning');
        return;
    }
    
    // Store original array
    originalArrayForTwoPointerSort = [...myArray];
    
    // Show two-pointer sort visualization
    showTwoPointerSortVisualization();
}

// NEW: Show Two-Pointer Sort Visualization
function showTwoPointerSortVisualization() {
    isTwoPointerSortRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Two-Pointer Sorting Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalTwoPointerArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Two-Pointer Sorting Process</div>
            <div class="transformed-array-container" id="transformedTwoPointerArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Two-Pointer Sorting:</strong> Using left and right pointers to sort the array efficiently</p>
            <p class="mb-0" id="twoPointerSortExplanation">Initializing two-pointer sort...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="twoPointerSortStepsContainer">
            <h6 class="text-center">Two-Pointer Sort Steps</h6>
            <div class="steps-container" id="twoPointerSortSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterTwoPointerSort" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForTwoPointerSort, 'originalTwoPointerArray');
    renderArrayInContainer([...originalArrayForTwoPointerSort], 'transformedTwoPointerArray');
    
    performTwoPointerSortAnimation();
}

// NEW: Perform Two-Pointer Sort Animation
function performTwoPointerSortAnimation() {
    const originalContainer = document.getElementById('originalTwoPointerArray');
    const transformedContainer = document.getElementById('transformedTwoPointerArray');
    const explanation = document.getElementById('twoPointerSortExplanation');
    const stepsContainer = document.getElementById('twoPointerSortSteps');
    const continueButton = document.getElementById('continueAfterTwoPointerSort');
    
    let array = [...originalArrayForTwoPointerSort];
    const n = array.length;
    let left = 0;
    let right = n - 1;
    let step = 0;
    let sorted = false;
    
    // Convert to numbers if possible for comparison
    const isNumeric = !array.some(item => isNaN(parseFloat(item)));
    
    function performSortStep() {
        if (left >= right) {
            // Sorting completed
            explanation.innerHTML = `<strong>Two-Pointer Sort Completed!</strong> Array is now sorted.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Array completely sorted using two-pointer approach
                </div>
            `;
            
            // Highlight all elements as sorted
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('two-pointer-sort-sorted');
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterTwoPointerSort();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterTwoPointerSort);
            
            return;
        }
        
        step++;
        explanation.innerHTML = `Step ${step}: Left pointer at ${left}, Right pointer at ${right}`;
        
        // Highlight current pointers
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        const leftElement = transformedElements[left].querySelector('.element-value');
        const rightElement = transformedElements[right].querySelector('.element-value');
        
        leftElement.classList.add('two-pointer-sort-left');
        rightElement.classList.add('two-pointer-sort-right');
        
        // Compare and potentially swap
        let leftVal = isNumeric ? parseFloat(array[left]) : array[left];
        let rightVal = isNumeric ? parseFloat(array[right]) : array[right];
        
        let shouldSwap = false;
        let comparison = '';
        
        if (isNumeric) {
            shouldSwap = leftVal > rightVal;
            comparison = `${leftVal} ${shouldSwap ? '>' : '<='} ${rightVal}`;
        } else {
            shouldSwap = array[left] > array[right];
            comparison = `"${array[left]}" ${shouldSwap ? '>' : '<='} "${array[right]}"`;
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${shouldSwap ? 'active' : ''}">
                <strong>Step ${step}:</strong> Compare [${left}]=${array[left]} and [${right}]=${array[right]} - 
                ${comparison} - ${shouldSwap ? 'SWAPPING' : 'No swap needed'}
            </div>
        `;
        
        setTimeout(() => {
            if (shouldSwap) {
                // Perform swap
                explanation.innerHTML = `Step ${step}: Swapping elements at indices ${left} and ${right}`;
                
                leftElement.classList.remove('two-pointer-sort-left');
                rightElement.classList.remove('two-pointer-sort-right');
                leftElement.classList.add('two-pointer-sort-swap');
                rightElement.classList.add('two-pointer-sort-swap');
                
                // Calculate swap distance for animation
                const rectLeft = transformedElements[left].getBoundingClientRect();
                const rectRight = transformedElements[right].getBoundingClientRect();
                const swapDistance = rectRight.left - rectLeft.left;
                
                leftElement.style.setProperty('--swap-distance', `${swapDistance}px`);
                rightElement.style.setProperty('--swap-distance', `-${swapDistance}px`);
                
                setTimeout(() => {
                    leftElement.classList.add('swap-animation');
                    rightElement.classList.add('swap-animation');
                    
                    setTimeout(() => {
                        // Swap the elements
                        [array[left], array[right]] = [array[right], array[left]];
                        
                        // Update transformed array display
                        renderArrayInContainer(array, 'transformedTwoPointerArray');
                        
                        // Remove highlights
                        leftElement.classList.remove('two-pointer-sort-swap', 'swap-animation');
                        rightElement.classList.remove('two-pointer-sort-swap', 'swap-animation');
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Swap ${step}:</strong> Elements swapped successfully
                            </div>
                        `;
                        
                        // Move pointers
                        left++;
                        right--;
                        
                        // Continue sorting
                        performSortStep();
                    }, 1000);
                }, 500);
            } else {
                // No swap needed
                leftElement.classList.remove('two-pointer-sort-left');
                rightElement.classList.remove('two-pointer-sort-right');
                
                // Move pointers based on values
                if (isNumeric) {
                    if (leftVal <= rightVal) {
                        left++;
                    } else {
                        right--;
                    }
                } else {
                    if (array[left] <= array[right]) {
                        left++;
                    } else {
                        right--;
                    }
                }
                
                performSortStep();
            }
        }, 1500);
    }
    
    // Start two-pointer sort process
    performSortStep();
}

// NEW: Return to Original after Two-Pointer Sort
function returnToOriginalAfterTwoPointerSort() {
    // Reset to original array
    myArray = [...originalArrayForTwoPointerSort];
    originalArrayForTwoPointerSort = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isTwoPointerSortRunning = false;
    
    logOperation('Two-pointer sort completed - returned to original array', 'info');
    showNotification('Returned to original array after two-pointer sort', 'success');
}
// NEW: Kadane's Algorithm Handler
function handleKadaneAlgorithm() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isKadaneAlgorithmRunning) {
        showNotification('Kadane\'s algorithm is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Kadane\'s algorithm requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForKadane = [...myArray];
    
    // Show Kadane's algorithm visualization
    showKadaneAlgorithmVisualization();
}

// NEW: Show Kadane's Algorithm Visualization
function showKadaneAlgorithmVisualization() {
    isKadaneAlgorithmRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Kadane's Algorithm - Maximum Subarray Sum</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalKadaneArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Kadane's Algorithm Process</div>
            <div class="transformed-array-container" id="transformedKadaneArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Kadane's Algorithm:</strong> Finding the contiguous subarray with maximum sum</p>
            <p class="mb-0" id="kadaneExplanation">Initializing Kadane's algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="kadaneStepsContainer">
            <h6 class="text-center">Kadane's Algorithm Steps</h6>
            <div class="steps-container" id="kadaneSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Maximum Subarray Sum</div>
            <div class="stats-value" id="maxSubarraySumValue">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Subarray Indices</div>
            <div class="stats-value" id="maxSubarrayIndices">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterKadane" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForKadane, 'originalKadaneArray');
    renderArrayInContainer([...originalArrayForKadane], 'transformedKadaneArray');
    
    performKadaneAlgorithmAnimation();
}

// NEW: Perform Kadane's Algorithm Animation
function performKadaneAlgorithmAnimation() {
    const originalContainer = document.getElementById('originalKadaneArray');
    const transformedContainer = document.getElementById('transformedKadaneArray');
    const explanation = document.getElementById('kadaneExplanation');
    const stepsContainer = document.getElementById('kadaneSteps');
    const maxSubarraySumValue = document.getElementById('maxSubarraySumValue');
    const maxSubarrayIndices = document.getElementById('maxSubarrayIndices');
    const continueButton = document.getElementById('continueAfterKadane');
    
    const arr = originalArrayForKadane.map(val => parseFloat(val));
    let maxEndingHere = arr[0];
    let maxSoFar = arr[0];
    let start = 0;
    let end = 0;
    let tempStart = 0;
    let step = 0;
    
    function performKadaneStep(i) {
        if (i >= arr.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Kadane's Algorithm Completed!</strong> Maximum subarray sum found.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Maximum subarray sum = ${maxSoFar} from indices ${start} to ${end}
                </div>
            `;
            
            // Highlight the maximum subarray
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            for (let j = start; j <= end; j++) {
                setTimeout(() => {
                    transformedElements[j].querySelector('.element-value').classList.add('kadane-max-subarray');
                }, (j - start) * 200);
            }
            
            maxSubarraySumValue.textContent = maxSoFar;
            maxSubarrayIndices.textContent = `${start} to ${end} ([${arr.slice(start, end + 1).join(', ')}])`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterKadane();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterKadane);
            
            return;
        }
        
        step++;
        
        if (i === 0) {
            // First element
            explanation.innerHTML = `Step ${step}: Initialize with first element = ${arr[i]}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Initialize maxEndingHere = ${arr[i]}, maxSoFar = ${arr[i]}
                </div>
            `;
            
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements[i].querySelector('.element-value').classList.add('kadane-current');
            
            maxSubarraySumValue.textContent = maxSoFar;
            maxSubarrayIndices.textContent = `${start} to ${end}`;
            
        } else {
            explanation.innerHTML = `Step ${step}: Processing element at index ${i} = ${arr[i]}`;
            
            // Highlight current element
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements[i].querySelector('.element-value').classList.add('kadane-current');
            
            // Calculate new maxEndingHere
            const newMaxEndingHere = Math.max(arr[i], maxEndingHere + arr[i]);
            const decision = newMaxEndingHere === arr[i] ? 'start new subarray' : 'extend current subarray';
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> maxEndingHere = max(${arr[i]}, ${maxEndingHere} + ${arr[i]}) = ${newMaxEndingHere} (${decision})
                </div>
            `;
            
            setTimeout(() => {
                if (newMaxEndingHere === arr[i]) {
                    // Start new subarray
                    tempStart = i;
                    explanation.innerHTML = `Step ${step}: Starting new subarray at index ${i}`;
                } else {
                    // Extend current subarray
                    explanation.innerHTML = `Step ${step}: Extending current subarray to include index ${i}`;
                }
                
                maxEndingHere = newMaxEndingHere;
                
                // Highlight elements in current subarray
                for (let j = tempStart; j <= i; j++) {
                    transformedElements[j].querySelector('.element-value').classList.add('kadane-included');
                }
                
                // Update maxSoFar if needed
                if (maxEndingHere > maxSoFar) {
                    maxSoFar = maxEndingHere;
                    start = tempStart;
                    end = i;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Update:</strong> New maximum found! maxSoFar = ${maxSoFar} (indices ${start}-${end})
                        </div>
                    `;
                    
                    explanation.innerHTML = `Step ${step}: New maximum subarray sum found = ${maxSoFar}`;
                    
                    // Highlight the new maximum subarray
                    for (let j = start; j <= end; j++) {
                        transformedElements[j].querySelector('.element-value').classList.add('kadane-max-subarray');
                    }
                }
                
                maxSubarraySumValue.textContent = maxSoFar;
                maxSubarrayIndices.textContent = `${start} to ${end}`;
                
                // Remove current highlight and move to next
                transformedElements[i].querySelector('.element-value').classList.remove('kadane-current');
                
                // Continue to next element
                performKadaneStep(i + 1);
            }, 2000);
            
            return;
        }
        
        // Continue to next element
        setTimeout(() => {
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements[i].querySelector('.element-value').classList.remove('kadane-current');
            performKadaneStep(i + 1);
        }, 1500);
    }
    
    // Start Kadane's algorithm
    performKadaneStep(0);
}

// NEW: Return to Original after Kadane's Algorithm
function returnToOriginalAfterKadane() {
    // Reset to original array
    myArray = [...originalArrayForKadane];
    originalArrayForKadane = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isKadaneAlgorithmRunning = false;
    
    logOperation('Kadane\'s algorithm completed - returned to original array', 'info');
    showNotification('Returned to original array after Kadane\'s algorithm', 'success');
}
// NEW: Move Zeros Handler
function handleMoveZeros(direction) {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isZeroMovementRunning) {
        showNotification('A zero movement operation is already in progress', 'warning');
        return;
    }
    
    // Store original array
    originalArrayForZeroMovement = [...myArray];
    
    // Show zero movement visualization
    showZeroMovementVisualization(direction);
}

// NEW: Show Zero Movement Visualization
function showZeroMovementVisualization(direction) {
    isZeroMovementRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Move Zeros to ${direction === 'end' ? 'End' : 'Front'}</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalZeroArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After Moving Zeros</div>
            <div class="transformed-array-container" id="transformedZeroArray"></div>
        </div>
        
        <div class="zero-movement-explanation">
            <p class="mb-2"><strong>Zero Movement:</strong> Moving all zero elements to the ${direction === 'end' ? 'end' : 'front'} while maintaining relative order of non-zero elements</p>
            <p class="mb-0" id="zeroMovementExplanation">Initializing zero movement...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="zeroMovementStepsContainer">
            <h6 class="text-center">Zero Movement Steps</h6>
            <div class="steps-container" id="zeroMovementSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterZeroMovement" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForZeroMovement, 'originalZeroArray');
    renderArrayInContainer([...originalArrayForZeroMovement], 'transformedZeroArray');
    
    performZeroMovementAnimation(direction);
}

// NEW: Perform Zero Movement Animation
function performZeroMovementAnimation(direction) {
    const originalContainer = document.getElementById('originalZeroArray');
    const transformedContainer = document.getElementById('transformedZeroArray');
    const explanation = document.getElementById('zeroMovementExplanation');
    const stepsContainer = document.getElementById('zeroMovementSteps');
    const continueButton = document.getElementById('continueAfterZeroMovement');
    
    let array = [...originalArrayForZeroMovement];
    let step = 0;
    
    // Count zeros
    const zeroCount = array.filter(val => val === '0' || val === 0).length;
    
    function performZeroMovementStep() {
        if (step === 0) {
            // Initial step - identify zeros
            explanation.innerHTML = `Step ${step + 1}: Identifying zero elements in the array`;
            
            // Highlight all zero elements
            const originalElements = originalContainer.querySelectorAll('.array-element');
            array.forEach((val, index) => {
                if (val === '0' || val === 0) {
                    const element = originalElements[index].querySelector('.element-value');
                    element.classList.add('zero-element');
                }
            });
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step + 1}:</strong> Found ${zeroCount} zero element(s) in the array
                </div>
            `;
            
            step++;
            setTimeout(performZeroMovementStep, 1500);
            
        } else if (step === 1) {
            // Show the movement strategy
            explanation.innerHTML = `Step ${step + 1}: Strategy - Move all zeros to the ${direction === 'end' ? 'end' : 'front'} while maintaining order of non-zero elements`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step + 1}:</strong> Using two-pointer approach to move zeros
                </div>
            `;
            
            step++;
            setTimeout(performZeroMovementStep, 1500);
            
        } else {
            // Perform the actual zero movement
            if (direction === 'end') {
                moveZerosToEndWithAnimation();
            } else {
                moveZerosToFrontWithAnimation();
            }
        }
    }
    
    // NEW: Move Zeros to End with Animation
    function moveZerosToEndWithAnimation() {
        let writePointer = 0;
        let zeroPointer = array.length - 1;
        let currentIndex = 0;
        
        function moveNextZero() {
            if (currentIndex >= array.length) {
                // Movement completed
                explanation.innerHTML = `<strong>Zero Movement Completed!</strong> All ${zeroCount} zero(s) moved to the end`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> All zeros moved to the end successfully
                    </div>
                `;
                
                // Highlight the final result
                const transformedElements = transformedContainer.querySelectorAll('.array-element');
                for (let i = array.length - zeroCount; i < array.length; i++) {
                    transformedElements[i].querySelector('.element-value').classList.add('zero-element');
                }
                
                continueButton.style.display = 'block';
                
                // Auto-return after 5 seconds
                setTimeout(() => {
                    returnToOriginalAfterZeroMovement();
                }, 5000);
                
                continueButton.addEventListener('click', returnToOriginalAfterZeroMovement);
                
                return;
            }
            
            const currentValue = array[currentIndex];
            const isZero = currentValue === '0' || currentValue === 0;
            
            explanation.innerHTML = `Step ${step + 1}: Processing element at index ${currentIndex} = "${currentValue}"`;
            
            // Highlight current element
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const currentElement = transformedElements[currentIndex].querySelector('.element-value');
            currentElement.classList.add('zero-movement-current');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${!isZero ? 'active' : ''}">
                    <strong>Step ${step + 1}:</strong> [${currentIndex}]="${currentValue}" - ${isZero ? 'Zero found, will move to end' : 'Non-zero, keeping in position'}
                </div>
            `;
            
            setTimeout(() => {
                currentElement.classList.remove('zero-movement-current');
                
                if (!isZero) {
                    // Non-zero element - keep it in position
                    if (writePointer !== currentIndex) {
                        // Move non-zero element to writePointer position
                        array[writePointer] = array[currentIndex];
                        array[currentIndex] = '0'; // Temporarily mark as zero for visualization
                        
                        // Update transformed array
                        renderArrayInContainer([...array], 'transformedZeroArray');
                        
                        // Highlight the movement
                        const newElement = transformedContainer.querySelectorAll('.array-element')[writePointer].querySelector('.element-value');
                        newElement.classList.add('zero-movement-target');
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Move:</strong> Moved non-zero element "${currentValue}" from [${currentIndex}] to [${writePointer}]
                            </div>
                        `;
                        
                        writePointer++;
                    } else {
                        writePointer++;
                    }
                } else {
                    // Zero element - it will naturally move to end as we shift non-zeros left
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Zero:</strong> Zero element at [${currentIndex}] will be moved to end
                        </div>
                    `;
                }
                
                currentIndex++;
                step++;
                
                // Continue to next element
                moveNextZero();
            }, 1500);
        }
        
        // Start moving zeros to end
        moveNextZero();
    }
    
    // NEW: Move Zeros to Front with Animation
    function moveZerosToFrontWithAnimation() {
        let writePointer = array.length - 1;
        let currentIndex = array.length - 1;
        
        function moveNextZero() {
            if (currentIndex < 0) {
                // Movement completed
                explanation.innerHTML = `<strong>Zero Movement Completed!</strong> All ${zeroCount} zero(s) moved to the front`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> All zeros moved to the front successfully
                    </div>
                `;
                
                // Highlight the final result
                const transformedElements = transformedContainer.querySelectorAll('.array-element');
                for (let i = 0; i < zeroCount; i++) {
                    transformedElements[i].querySelector('.element-value').classList.add('zero-element');
                }
                
                continueButton.style.display = 'block';
                
                // Auto-return after 5 seconds
                setTimeout(() => {
                    returnToOriginalAfterZeroMovement();
                }, 5000);
                
                continueButton.addEventListener('click', returnToOriginalAfterZeroMovement);
                
                return;
            }
            
            const currentValue = array[currentIndex];
            const isZero = currentValue === '0' || currentValue === 0;
            
            explanation.innerHTML = `Step ${step + 1}: Processing element at index ${currentIndex} = "${currentValue}"`;
            
            // Highlight current element
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const currentElement = transformedElements[currentIndex].querySelector('.element-value');
            currentElement.classList.add('zero-movement-current');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${!isZero ? 'active' : ''}">
                    <strong>Step ${step + 1}:</strong> [${currentIndex}]="${currentValue}" - ${isZero ? 'Zero found, will move to front' : 'Non-zero, keeping in position'}
                </div>
            `;
            
            setTimeout(() => {
                currentElement.classList.remove('zero-movement-current');
                
                if (!isZero) {
                    // Non-zero element - move it to the writePointer position
                    if (writePointer !== currentIndex) {
                        array[writePointer] = array[currentIndex];
                        array[currentIndex] = '0'; // Temporarily mark as zero for visualization
                        
                        // Update transformed array
                        renderArrayInContainer([...array], 'transformedZeroArray');
                        
                        // Highlight the movement
                        const newElement = transformedContainer.querySelectorAll('.array-element')[writePointer].querySelector('.element-value');
                        newElement.classList.add('zero-movement-target');
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Move:</strong> Moved non-zero element "${currentValue}" from [${currentIndex}] to [${writePointer}]
                            </div>
                        `;
                        
                        writePointer--;
                    } else {
                        writePointer--;
                    }
                } else {
                    // Zero element - it will naturally move to front as we shift non-zeros right
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Zero:</strong> Zero element at [${currentIndex}] will be moved to front
                        </div>
                    `;
                }
                
                currentIndex--;
                step++;
                
                // Continue to next element
                moveNextZero();
            }, 1500);
        }
        
        // Start moving zeros to front
        moveNextZero();
    }
    
    // Start zero movement process
    performZeroMovementStep();
}

// NEW: Return to Original after Zero Movement
function returnToOriginalAfterZeroMovement() {
    // Reset to original array
    myArray = [...originalArrayForZeroMovement];
    originalArrayForZeroMovement = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isZeroMovementRunning = false;
    
    logOperation('Zero movement completed - returned to original array', 'info');
    showNotification('Returned to original array after zero movement', 'success');
}
// NEW: Count Subarrays Handler
function handleCountSubarrays() {
    const input = subarrayInput.value.trim();
    
    if (input === '') {
        // Use current array if no input provided
        if (myArray.length === 0) {
            showNotification('Please enter array values or add elements to the array', 'warning');
            return;
        }
        processSubarrayCalculation(myArray);
        return;
    }
    
    // Parse input string (comma-separated values)
    const inputArray = input.split(',').map(item => item.trim()).filter(item => item !== '');
    
    if (inputArray.length === 0) {
        showNotification('Please enter valid array values', 'danger');
        subarrayInput.focus();
        return;
    }
    
    processSubarrayCalculation(inputArray);
}

// NEW: Generate Subarrays Handler
function handleGenerateSubarrays() {
    const input = subarrayInput.value.trim();
    let targetArray;
    
    if (input === '') {
        // Use current array if no input provided
        if (myArray.length === 0) {
            showNotification('Please enter array values or add elements to the array', 'warning');
            return;
        }
        targetArray = myArray;
    } else {
        // Parse input string
        targetArray = input.split(',').map(item => item.trim()).filter(item => item !== '');
    }
    
    if (targetArray.length === 0) {
        showNotification('Please enter valid array values', 'danger');
        return;
    }
    
    generateAllSubarrays(targetArray);
}

// NEW: Process subarray calculation
function processSubarrayCalculation(array) {
    const totalSubarrays = calculateTotalSubarrays(array.length);
    
    // Show results section
    subarraysResults.style.display = 'block';
    subarrayCount.textContent = totalSubarrays;
    
    // Update input field to show the array being used
    subarrayInput.value = array.join(', ');
    
    logOperation(`Calculated subarrays for [${array.join(', ')}] - total: ${totalSubarrays}`, 'info');
    showNotification(`Total subarrays: ${totalSubarrays}`, 'success');
}

// NEW: Generate and display all subarrays
function generateAllSubarrays(array) {
    const allSubarrays = getAllSubarrays(array);
    const totalSubarrays = allSubarrays.length;
    
    // Show results section
    subarraysResults.style.display = 'block';
    subarrayCount.textContent = totalSubarrays;
    
    // Display all subarrays
    let subarraysHTML = '<div class="subarrays-container" style="max-height: 300px; overflow-y: auto;">';
    subarraysHTML += '<p><strong>All Subarrays:</strong></p>';
    subarraysHTML += '<div class="d-flex flex-wrap gap-2">';
    
    allSubarrays.forEach((subarray, index) => {
        subarraysHTML += `
            <div class="subarray-item bg-primary rounded px-2 py-1 small">
                [${subarray.join(', ')}]
            </div>
        `;
    });
    
    subarraysHTML += '</div></div>';
    subarraysList.innerHTML = subarraysHTML;
    
    // Update input field to show the array being used
    subarrayInput.value = array.join(', ');
    
    logOperation(`Generated ${totalSubarrays} subarrays for [${array.join(', ')}]`, 'success');
    showNotification(`Generated ${totalSubarrays} subarrays`, 'success');
}

// NEW: Calculate total number of subarrays
function calculateTotalSubarrays(n) {
    // Formula: n*(n+1)/2
    return n * (n + 1) / 2;
}

// NEW: Generate all possible subarrays
function getAllSubarrays(array) {
    const subarrays = [];
    const n = array.length;
    
    // Pick starting point
    for (let i = 0; i < n; i++) {
        // Pick ending point
        for (let j = i; j < n; j++) {
            // Get subarray from i to j
            const subarray = [];
            for (let k = i; k <= j; k++) {
                subarray.push(array[k]);
            }
            subarrays.push(subarray);
        }
    }
    
    return subarrays;
}
// NEW: Rearrange Positive and Negative Values Handler
function handleRearrangePositiveNegative() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isRearrangeRunning) {
        showNotification('A rearrange operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Rearrange operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForRearrange = [...myArray];
    
    // Start rearrange visualization
    showRearrangeVisualization();
}
// NEW: Show Rearrange Visualization
function showRearrangeVisualization() {
    isRearrangeRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Rearrange Positive & Negative Values</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalRearrangeArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Rearranged Array (Negatives First)</div>
            <div class="transformed-array-container" id="transformedRearrangeArray"></div>
        </div>
        
        <div class="rearrange-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Move all negative values to the front while maintaining relative order</p>
            <p class="mb-0" id="rearrangeExplanation">Initializing rearrangement process...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="rearrangeStepsContainer">
            <h6 class="text-center">Rearrangement Steps</h6>
            <div class="steps-container" id="rearrangeSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterRearrange" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForRearrange, 'originalRearrangeArray');
    renderArrayInContainer([...originalArrayForRearrange], 'transformedRearrangeArray');
    
    performRearrangeAnimation();
}

// NEW: Perform Rearrange Animation
function performRearrangeAnimation() {
    const originalContainer = document.getElementById('originalRearrangeArray');
    const transformedContainer = document.getElementById('transformedRearrangeArray');
    const explanation = document.getElementById('rearrangeExplanation');
    const stepsContainer = document.getElementById('rearrangeSteps');
    const continueButton = document.getElementById('continueAfterRearrange');
    
    let array = [...originalArrayForRearrange];
    const n = array.length;
    let step = 0;
    
    // First, classify elements as negative or positive
    explanation.innerHTML = 'Step 1: Classifying elements as negative or positive';
    
    setTimeout(() => {
        // Highlight negative and positive values
        const originalElements = originalContainer.querySelectorAll('.array-element');
        originalElements.forEach((element, index) => {
            const value = parseFloat(array[index]);
            const valueDiv = element.querySelector('.element-value');
            
            if (value < 0) {
                valueDiv.classList.add('negative-value');
            } else {
                valueDiv.classList.add('positive-value');
            }
        });
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step 1:</strong> Classified elements - Negative values in blue, Positive values in yellow
            </div>
        `;
        
        step++;
        performRearrangeStep();
    }, 2000);
    
    function performRearrangeStep() {
        if (step === 1) {
            explanation.innerHTML = 'Step 2: Starting rearrangement - Moving negatives to front';
            
            // Use two-pointer approach to rearrange
            let left = 0;
            let right = 0;
            
            function rearrangeNext() {
                if (right >= n) {
                    // Rearrangement completed
                    explanation.innerHTML = '<strong>Rearrangement Completed!</strong> All negative values moved to the front.';
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Final:</strong> Rearrangement completed! Negative values: ${array.filter(val => parseFloat(val) < 0).length}, Positive values: ${array.filter(val => parseFloat(val) >= 0).length}
                        </div>
                    `;
                    
                    // Highlight the final rearranged array
                    const transformedElements = transformedContainer.querySelectorAll('.array-element');
                    transformedElements.forEach((element, index) => {
                        const value = parseFloat(array[index]);
                        const valueDiv = element.querySelector('.element-value');
                        
                        setTimeout(() => {
                            if (value < 0) {
                                valueDiv.classList.add('negative-value', 'bounce');
                            } else {
                                valueDiv.classList.add('positive-value', 'bounce');
                            }
                        }, index * 100);
                    });
                    
                    continueButton.style.display = 'block';
                    
                    // Auto-return after 5 seconds
                    setTimeout(() => {
                        returnToOriginalAfterRearrange();
                    }, 5000);
                    
                    continueButton.addEventListener('click', returnToOriginalAfterRearrange);
                    
                    return;
                }
                
                const currentValue = parseFloat(array[right]);
                
                if (currentValue < 0) {
                    // This is a negative value that needs to be moved to the front
                    explanation.innerHTML = `Step ${step + 1}: Found negative value at index ${right} = ${array[right]}, moving to position ${left}`;
                    
                    // Highlight the current negative value
                    const originalElements = originalContainer.querySelectorAll('.array-element');
                    const currentElement = originalElements[right].querySelector('.element-value');
                    const targetElement = originalElements[left].querySelector('.element-value');
                    
                    currentElement.classList.add('rearrange-current');
                    targetElement.classList.add('rearrange-target');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step + 1}:</strong> Moving negative value ${array[right]} from index ${right} to index ${left}
                        </div>
                    `;
                    
                    setTimeout(() => {
                        // Swap elements
                        [array[left], array[right]] = [array[right], array[left]];
                        
                        // Update transformed array
                        renderArrayInContainer(array, 'transformedRearrangeArray');
                        
                        // Remove highlights
                        currentElement.classList.remove('rearrange-current');
                        targetElement.classList.remove('rearrange-target');
                        
                        // Re-highlight the transformed array
                        const transformedElements = transformedContainer.querySelectorAll('.array-element');
                        transformedElements.forEach((element, index) => {
                            const value = parseFloat(array[index]);
                            const valueDiv = element.querySelector('.element-value');
                            
                            if (value < 0) {
                                valueDiv.classList.add('negative-value');
                            } else {
                                valueDiv.classList.add('positive-value');
                            }
                        });
                        
                        left++;
                        right++;
                        step++;
                        
                        rearrangeNext();
                    }, 2000);
                } else {
                    // Positive value, just move right pointer
                    explanation.innerHTML = `Step ${step + 1}: Positive value at index ${right} = ${array[right]}, keeping in place`;
                    
                    const originalElements = originalContainer.querySelectorAll('.array-element');
                    const currentElement = originalElements[right].querySelector('.element-value');
                    currentElement.classList.add('rearrange-current');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step + 1}:</strong> Positive value ${array[right]} at index ${right} - keeping in current position
                        </div>
                    `;
                    
                    setTimeout(() => {
                        currentElement.classList.remove('rearrange-current');
                        right++;
                        step++;
                        rearrangeNext();
                    }, 1500);
                }
            }
            
            // Start the rearrangement process
            rearrangeNext();
        }
    }
}

// NEW: Return to Original after Rearrange
function returnToOriginalAfterRearrange() {
    // Reset to original array
    myArray = [...originalArrayForRearrange];
    originalArrayForRearrange = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isRearrangeRunning = false;
    
    logOperation('Rearrange positive/negative values completed - returned to original array', 'info');
    showNotification('Returned to original array after rearrangement', 'success');
}
// NEW: Segregate Even & Odd Numbers Handler
function handleSegregateEvenOdd() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isSegregateRunning) {
        showNotification('Segregation operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Segregation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isSegregateRunning = true;
    
    // Store original array
    originalArrayForSegregate = [...myArray];
    
    // Show segregation visualization
    showSegregateVisualization();
}
// NEW: Show Segregate Visualization
function showSegregateVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Segregate Even & Odd Numbers</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalSegregateArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Segregated Array (Even First)</div>
            <div class="transformed-array-container" id="transformedSegregateArray"></div>
        </div>
        
        <div class="segregate-explanation">
            <p class="mb-2"><strong>Segregation Algorithm:</strong> Move all even numbers to the front while maintaining relative order</p>
            <p class="mb-0" id="segregateExplanation">Initializing segregation process...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="segregateStepsContainer">
            <h6 class="text-center">Segregation Steps</h6>
            <div class="steps-container" id="segregateSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSegregate" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSegregate, 'originalSegregateArray');
    renderArrayInContainer([...originalArrayForSegregate], 'transformedSegregateArray');
    
    performSegregateAnimation();
}
// NEW: Perform Segregate Animation
function performSegregateAnimation() {
    const originalContainer = document.getElementById('originalSegregateArray');
    const transformedContainer = document.getElementById('transformedSegregateArray');
    const explanation = document.getElementById('segregateExplanation');
    const stepsContainer = document.getElementById('segregateSteps');
    const continueButton = document.getElementById('continueAfterSegregate');
    
    const array = [...originalArrayForSegregate];
    const numericArray = array.map(val => parseInt(val));
    let segregatedArray = [...numericArray];
    let nextEvenPos = 0;
    let step = 0;
    
    function performSegregateStep(i) {
        if (i >= segregatedArray.length) {
            // Segregation completed
            explanation.innerHTML = `<strong>Segregation Completed!</strong> All even numbers moved to the front.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Segregation completed! Even numbers: ${segregatedArray.filter(x => x % 2 === 0).length}, Odd numbers: ${segregatedArray.filter(x => x % 2 !== 0).length}
                </div>
            `;
            
            // Highlight even and odd sections
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const evenCount = segregatedArray.filter(x => x % 2 === 0).length;
            
            transformedElements.forEach((el, index) => {
                setTimeout(() => {
                    const valueDiv = el.querySelector('.element-value');
                    if (index < evenCount) {
                        valueDiv.classList.add('even-number');
                    } else {
                        valueDiv.classList.add('odd-number');
                    }
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterSegregate();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSegregate);
            
            return;
        }
        
        step++;
        const currentNumber = segregatedArray[i];
        const isEven = currentNumber % 2 === 0;
        
        explanation.innerHTML = `Step ${step}: Checking element [${i}] = ${currentNumber} (${isEven ? 'EVEN' : 'ODD'})`;
        
        // Highlight current element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[i].querySelector('.element-value');
        currentElement.classList.add('segregate-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${isEven ? 'active' : ''}">
                <strong>Step ${step}:</strong> Checking [${i}] = ${currentNumber} - ${isEven ? 'EVEN (will move to position ' + nextEvenPos + ')' : 'ODD (stays in current position)'}
            </div>
        `;
        
        setTimeout(() => {
            if (isEven && i !== nextEvenPos) {
                // Need to move this even number to nextEvenPos
                explanation.innerHTML = `Step ${step}: Moving EVEN number ${currentNumber} from position ${i} to ${nextEvenPos}`;
                
                // Highlight the target position
                const targetElement = originalElements[nextEvenPos].querySelector('.element-value');
                targetElement.classList.add('segregate-target');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Action:</strong> Moving EVEN number ${currentNumber} from index ${i} to ${nextEvenPos}
                    </div>
                `;
                
                setTimeout(() => {
                    // Perform the swap in segregated array
                    // Move current even number to nextEvenPos, shifting others
                    for (let j = i; j > nextEvenPos; j--) {
                        segregatedArray[j] = segregatedArray[j - 1];
                    }
                    segregatedArray[nextEvenPos] = currentNumber;
                    
                    // Update transformed array display
                    renderArrayInContainer(segregatedArray, 'transformedSegregateArray');
                    
                    // Remove highlights
                    currentElement.classList.remove('segregate-current');
                    targetElement.classList.remove('segregate-target');
                    
                    // Update nextEvenPos
                    nextEvenPos++;
                    
                    // Continue with next element
                    performSegregateStep(nextEvenPos);
                }, 1500);
                
            } else {
                if (isEven) {
                    // Even number already in correct position
                    explanation.innerHTML = `Step ${step}: EVEN number ${currentNumber} already at correct position ${nextEvenPos}`;
                    nextEvenPos++;
                } else {
                    // Odd number, no action needed
                    explanation.innerHTML = `Step ${step}: ODD number ${currentNumber} stays at position ${i}`;
                }
                
                // Remove highlight
                currentElement.classList.remove('segregate-current');
                
                // Continue with next element
                performSegregateStep(i + 1);
            }
        }, 1500);
    }
    
    // Start segregation process
    performSegregateStep(0);
}
// NEW: Return to Original after Segregate
function returnToOriginalAfterSegregate() {
    // Reset to original array
    myArray = [...originalArrayForSegregate];
    originalArrayForSegregate = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isSegregateRunning = false;
    
    logOperation('Even-odd segregation completed - returned to original array', 'info');
    showNotification('Returned to original array after segregation', 'success');
}
// NEW: Count Element Frequency Handler
function handleCountElementFrequency() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }

    if (isFrequencyCountRunning) {
        showNotification('Frequency count is already in progress', 'warning');
        return;
    }

    isFrequencyCountRunning = true;
    originalArrayForFrequency = [...myArray];

    // Show frequency count visualization
    showFrequencyCountVisualization();
}

// NEW: Show Frequency Count Visualization
function showFrequencyCountVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Element Frequency Analysis</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalFrequencyArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-chart-bar"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Frequency Analysis Results</div>
            <div id="frequencyResultsContainer" class="mt-3" style="width: 100%;"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Frequency Analysis:</strong> Counting occurrences of each element in the array</p>
            <p class="mb-0" id="frequencyExplanation">Starting frequency analysis...</p>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterFrequency" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;

    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);

    renderArrayInContainer(originalArrayForFrequency, 'originalFrequencyArray');
    performFrequencyAnalysis();
}

// NEW: Perform Frequency Analysis with Animation
function performFrequencyAnalysis() {
    const originalContainer = document.getElementById('originalFrequencyArray');
    const resultsContainer = document.getElementById('frequencyResultsContainer');
    const explanation = document.getElementById('frequencyExplanation');
    const continueButton = document.getElementById('continueAfterFrequency');

    const frequencyMap = new Map();
    let currentIndex = 0;
    let totalElements = originalArrayForFrequency.length;
    let uniqueElements = 0;

    function processNextElement() {
        if (currentIndex >= totalElements) {
            // Analysis completed
            displayFrequencyResults(frequencyMap);
            explanation.innerHTML = `<strong>Frequency Analysis Completed!</strong> Found ${uniqueElements} unique elements out of ${totalElements} total elements.`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterFrequency();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterFrequency);
            
            return;
        }

        const currentElement = originalArrayForFrequency[currentIndex];
        explanation.innerHTML = `Processing element [${currentIndex}]: "${currentElement}"`;

        // Highlight current element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElementDiv = originalElements[currentIndex].querySelector('.element-value');
        currentElementDiv.classList.add('frequency-highlight');

        setTimeout(() => {
            // Update frequency count
            if (frequencyMap.has(currentElement)) {
                frequencyMap.set(currentElement, frequencyMap.get(currentElement) + 1);
                explanation.innerHTML = `Element "${currentElement}" count increased to ${frequencyMap.get(currentElement)}`;
            } else {
                frequencyMap.set(currentElement, 1);
                uniqueElements++;
                explanation.innerHTML = `New element found: "${currentElement}" (first occurrence)`;
            }

            // Remove highlight and move to next
            currentElementDiv.classList.remove('frequency-highlight');
            currentIndex++;
            
            // Update progress display
            if (currentIndex % 3 === 0 || currentIndex === totalElements) {
                displayIntermediateResults(frequencyMap, currentIndex, totalElements);
            }
            
            processNextElement();
        }, 800);
    }

    // Start processing
    processNextElement();
}

// NEW: Display Intermediate Results
function displayIntermediateResults(frequencyMap, currentIndex, totalElements) {
    const resultsContainer = document.getElementById('frequencyResultsContainer');
    const progress = Math.floor((currentIndex / totalElements) * 100);
    
    resultsContainer.innerHTML = `
        <div class="stats-highlight">
            Progress: ${progress}% (${currentIndex}/${totalElements} elements processed)
        </div>
        <div class="table-container">
            <table class="frequency-table table-animation">
                <thead>
                    <tr>
                        <th>Element</th>
                        <th>Frequency</th>
                        <th>Percentage</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody>
                    ${Array.from(frequencyMap.entries()).map(([element, count]) => `
                        <tr>
                            <td>${element}</td>
                            <td>${count}</td>
                            <td>${((count / currentIndex) * 100).toFixed(1)}%</td>
                            <td>
                                ${count > 1 ? 
                                    '<span class="text-warning">Duplicate</span>' : 
                                    '<span class="text-success">Unique</span>'
                                }
                            </td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        </div>
    `;
}

// NEW: Display Final Frequency Results
function displayFrequencyResults(frequencyMap) {
    const resultsContainer = document.getElementById('frequencyResultsContainer');
    const totalElements = originalArrayForFrequency.length;
    const uniqueElements = frequencyMap.size;
    const duplicateElements = Array.from(frequencyMap.values()).filter(count => count > 1).length;
    
    // Sort by frequency (descending)
    const sortedFrequencies = Array.from(frequencyMap.entries())
        .sort((a, b) => b[1] - a[1]);
    
    const mostFrequent = sortedFrequencies[0];
    const leastFrequent = sortedFrequencies[sortedFrequencies.length - 1];
    
    resultsContainer.innerHTML = `
        <div class="row text-center mb-3">
            <div class="col-md-3">
                <div class="stats-card">
                    <div>Total Elements</div>
                    <div class="stats-value">${totalElements}</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="stats-card">
                    <div>Unique Elements</div>
                    <div class="stats-value">${uniqueElements}</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="stats-card">
                    <div>Duplicate Elements</div>
                    <div class="stats-value">${duplicateElements}</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="stats-card">
                    <div>Most Frequent</div>
                    <div class="stats-value">${mostFrequent[0]} (${mostFrequent[1]})</div>
                </div>
            </div>
        </div>
        
        <div class="table-container">
            <table class="frequency-table table-animation">
                <thead>
                    <tr>
                        <th>Element</th>
                        <th>Frequency</th>
                        <th>Percentage</th>
                        <th>Status</th>
                        <th>Bar Chart</th>
                    </tr>
                </thead>
                <tbody>
                    ${sortedFrequencies.map(([element, count]) => {
                        const percentage = ((count / totalElements) * 100).toFixed(1);
                        const barWidth = (count / mostFrequent[1]) * 100;
                        const rowClass = count > 1 ? 'frequency-duplicate' : 'frequency-unique';
                        const statusText = count > 1 ? 
                            `<span class="text-warning"><i class="fas fa-clone me-1"></i>Duplicate (${count}x)</span>` : 
                            `<span class="text-success"><i class="fas fa-star me-1"></i>Unique</span>`;
                        
                        return `
                            <tr class="${rowClass}">
                                <td><strong>${element}</strong></td>
                                <td>${count}</td>
                                <td>${percentage}%</td>
                                <td>${statusText}</td>
                                <td>
                                    <div style="background: rgba(255,255,255,0.2); border-radius: 5px; height: 20px; width: 100%;">
                                        <div style="background: var(${count > 1 ? '--warning-color' : '--success-color'}); 
                                                    height: 100%; width: ${barWidth}%; border-radius: 5px; 
                                                    transition: width 1s ease;"></div>
                                    </div>
                                </td>
                            </tr>
                        `;
                    }).join('')}
                </tbody>
            </table>
        </div>
        
        <div class="stats-highlight mt-3">
            <i class="fas fa-chart-pie me-2"></i>
            Analysis Summary: ${duplicateElements} duplicate element(s) found. 
            Most frequent: "${mostFrequent[0]}" (${mostFrequent[1]} occurrences)
        </div>
    `;
    
    // Animate the bar charts
    setTimeout(() => {
        const bars = resultsContainer.querySelectorAll('td div div');
        bars.forEach(bar => {
            bar.style.width = bar.style.width;
        });
    }, 100);
}

// NEW: Return to Original after Frequency Analysis
function returnToOriginalAfterFrequency() {
    // Reset to original array
    myArray = [...originalArrayForFrequency];
    originalArrayForFrequency = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isFrequencyCountRunning = false;
    
    logOperation('Frequency analysis completed - returned to original array', 'info');
    showNotification('Returned to original array after frequency analysis', 'success');
}

// NEW: Find Duplicate Elements Handler
function handleFindDuplicates() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }

    if (isFindDuplicatesRunning) {
        showNotification('Duplicate search is already in progress', 'warning');
        return;
    }

    isFindDuplicatesRunning = true;
    originalArrayForDuplicates = [...myArray];

    // Show duplicate elements visualization
    showDuplicatesVisualization();
}

// NEW: Show Duplicates Visualization
function showDuplicatesVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Duplicate Elements Detection</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalDuplicatesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-clone"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Duplicate Analysis Results</div>
            <div id="duplicatesResultsContainer" class="mt-3" style="width: 100%;"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Duplicate Detection:</strong> Finding and highlighting all duplicate elements</p>
            <p class="mb-0" id="duplicatesExplanation">Starting duplicate detection...</p>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterDuplicates" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;

    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);

    renderArrayInContainer(originalArrayForDuplicates, 'originalDuplicatesArray');
    performDuplicatesDetection();
}

// NEW: Perform Duplicates Detection with Animation
function performDuplicatesDetection() {
    const originalContainer = document.getElementById('originalDuplicatesArray');
    const resultsContainer = document.getElementById('duplicatesResultsContainer');
    const explanation = document.getElementById('duplicatesExplanation');
    const continueButton = document.getElementById('continueAfterDuplicates');

    const elementPositions = new Map();
    const duplicates = new Map();
    let currentIndex = 0;
    let totalElements = originalArrayForDuplicates.length;

    function processNextElement() {
        if (currentIndex >= totalElements) {
            // Detection completed
            displayDuplicatesResults(duplicates, elementPositions);
            explanation.innerHTML = `<strong>Duplicate Detection Completed!</strong> Found ${duplicates.size} duplicate element(s).`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterDuplicates();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterDuplicates);
            
            return;
        }

        const currentElement = originalArrayForDuplicates[currentIndex];
        explanation.innerHTML = `Checking element [${currentIndex}]: "${currentElement}" for duplicates`;

        // Highlight current element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElementDiv = originalElements[currentIndex].querySelector('.element-value');
        currentElementDiv.classList.add('duplicate-highlight');

        setTimeout(() => {
            // Check for duplicates
            if (elementPositions.has(currentElement)) {
                // This is a duplicate
                const positions = elementPositions.get(currentElement);
                positions.push(currentIndex);
                
                if (!duplicates.has(currentElement)) {
                    duplicates.set(currentElement, [...positions]);
                } else {
                    duplicates.set(currentElement, positions);
                }
                
                explanation.innerHTML = `Duplicate found! "${currentElement}" at positions: ${positions.join(', ')}`;
                
                // Highlight all occurrences of this duplicate
                positions.forEach(pos => {
                    if (pos !== currentIndex) {
                        originalElements[pos].querySelector('.element-value').classList.add('duplicate-highlight');
                    }
                });
                
            } else {
                // First occurrence
                elementPositions.set(currentElement, [currentIndex]);
                explanation.innerHTML = `First occurrence of "${currentElement}"`;
            }

            // Remove current highlight and move to next
            setTimeout(() => {
                currentElementDiv.classList.remove('duplicate-highlight');
                currentIndex++;
                
                // Update progress
                if (currentIndex % 2 === 0 || currentIndex === totalElements) {
                    displayIntermediateDuplicates(duplicates, currentIndex, totalElements);
                }
                
                processNextElement();
            }, 500);
            
        }, 1000);
    }

    // Start processing
    processNextElement();
}

// NEW: Display Intermediate Duplicates Results
function displayIntermediateDuplicates(duplicates, currentIndex, totalElements) {
    const resultsContainer = document.getElementById('duplicatesResultsContainer');
    const progress = Math.floor((currentIndex / totalElements) * 100);
    
    resultsContainer.innerHTML = `
        <div class="stats-highlight">
            Progress: ${progress}% (${currentIndex}/${totalElements} elements checked)
        </div>
        <div class="table-container">
            <table class="frequency-table table-animation">
                <thead>
                    <tr>
                        <th>Duplicate Element</th>
                        <th>Occurrences</th>
                        <th>Positions</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody>
                    ${Array.from(duplicates.entries()).map(([element, positions]) => `
                        <tr class="frequency-duplicate">
                            <td><strong>${element}</strong></td>
                            <td>${positions.length}</td>
                            <td>[${positions.join(', ')}]</td>
                            <td><span class="text-warning">Duplicate Found</span></td>
                        </tr>
                    `).join('')}
                    ${duplicates.size === 0 ? `
                        <tr>
                            <td colspan="4" class="text-center text-muted">No duplicates found yet...</td>
                        </tr>
                    ` : ''}
                </tbody>
            </table>
        </div>
    `;
}

// NEW: Display Final Duplicates Results
function displayDuplicatesResults(duplicates, elementPositions) {
    const resultsContainer = document.getElementById('duplicatesResultsContainer');
    const totalElements = originalArrayForDuplicates.length;
    const uniqueElements = elementPositions.size;
    const totalDuplicates = Array.from(duplicates.values()).reduce((sum, positions) => sum + positions.length, 0);
    const duplicateElements = duplicates.size;
    
    // Sort by number of occurrences (descending)
    const sortedDuplicates = Array.from(duplicates.entries())
        .sort((a, b) => b[1].length - a[1].length);
    
    resultsContainer.innerHTML = `
        <div class="row text-center mb-3">
            <div class="col-md-3">
                <div class="stats-card">
                    <div>Total Elements</div>
                    <div class="stats-value">${totalElements}</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="stats-card">
                    <div>Unique Elements</div>
                    <div class="stats-value">${uniqueElements}</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="stats-card">
                    <div>Duplicate Elements</div>
                    <div class="stats-value">${duplicateElements}</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="stats-card">
                    <div>Total Occurrences</div>
                    <div class="stats-value">${totalDuplicates}</div>
                </div>
            </div>
        </div>
        
        <div class="table-container">
            <table class="frequency-table table-animation">
                <thead>
                    <tr>
                        <th>Duplicate Element</th>
                        <th>Total Occurrences</th>
                        <th>Positions in Array</th>
                        <th>Duplicate Type</th>
                        <th>Visual Map</th>
                    </tr>
                </thead>
                <tbody>
                    ${sortedDuplicates.map(([element, positions]) => {
                        const occurrenceCount = positions.length;
                        const isMultiple = occurrenceCount > 2;
                        const typeText = isMultiple ? 'Multiple Duplicates' : 'Pair Duplicate';
                        const typeIcon = isMultiple ? 'fa-clone' : 'fa-copy';
                        
                        // Create visual representation
                        const visualMap = originalArrayForDuplicates.map((val, idx) => 
                            positions.includes(idx) ? 
                                `<span class="text-warning"><i class="fas fa-circle"></i></span>` : 
                                `<span class="text-muted"><i class="far fa-circle"></i></span>`
                        ).join(' ');
                        
                        return `
                            <tr class="frequency-duplicate">
                                <td><strong>${element}</strong></td>
                                <td>
                                    <span class="badge bg-warning">${occurrenceCount} occurrences</span>
                                </td>
                                <td>[${positions.join(', ')}]</td>
                                <td>
                                    <span class="text-warning">
                                        <i class="fas ${typeIcon} me-1"></i>${typeText}
                                    </span>
                                </td>
                                <td>
                                    <div style="font-size: 0.8rem; letter-spacing: 2px;">
                                        ${visualMap}
                                    </div>
                                </td>
                            </tr>
                        `;
                    }).join('')}
                    ${duplicates.size === 0 ? `
                        <tr class="frequency-unique">
                            <td colspan="5" class="text-center">
                                <i class="fas fa-check-circle text-success me-2"></i>
                                No duplicate elements found! All elements are unique.
                            </td>
                        </tr>
                    ` : ''}
                </tbody>
            </table>
        </div>
        
        ${duplicates.size > 0 ? `
            <div class="stats-highlight mt-3">
                <i class="fas fa-exclamation-triangle me-2"></i>
                Duplicate Analysis: Found ${duplicateElements} duplicate element(s) with ${totalDuplicates} total occurrences.
                ${sortedDuplicates[0] ? `Most duplicated: "${sortedDuplicates[0][0]}" (${sortedDuplicates[0][1].length} times)` : ''}
            </div>
        ` : `
            <div class="stats-highlight mt-3 bg-success">
                <i class="fas fa-check-circle me-2"></i>
                Excellent! No duplicate elements found. All ${uniqueElements} elements are unique.
            </div>
        `}
    `;
}

// NEW: Return to Original after Duplicates Detection
function returnToOriginalAfterDuplicates() {
    // Reset to original array
    myArray = [...originalArrayForDuplicates];
    originalArrayForDuplicates = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isFindDuplicatesRunning = false;
    
    logOperation('Duplicate detection completed - returned to original array', 'info');
    showNotification('Returned to original array after duplicate detection', 'success');
}
// NEW: First Non-Repeating Element Handler
function handleFirstNonRepeating() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isNonRepeatingRunning) {
        showNotification('Non-repeating element search is already in progress', 'warning');
        return;
    }
    
    isNonRepeatingRunning = true;
    
    // Store original array
    originalArrayForUniqueness = [...myArray];
    
    // Perform first non-repeating element search
    performFirstNonRepeatingSearch();
}

// NEW: Find Unique Elements Handler
// NEW: Find All Unique Elements Handler
function handleFindUniqueElements() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isUniqueElementsRunning) {
        showNotification('Unique elements analysis is already in progress', 'warning');
        return;
    }
    
    isUniqueElementsRunning = true;
    
    // Store original array
    originalArrayForUniqueness = [...myArray];
    
    // Show unique elements visualization with table
    showUniqueElementsVisualization();
}
// NEW: Show Unique Elements Visualization with Table
function showUniqueElementsVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find All Unique Elements</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalUniqueArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Unique Elements Analysis</div>
            <div class="transformed-array-container" id="transformedUniqueArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Unique Elements Algorithm:</strong> Finding all elements that appear exactly once in the array</p>
            <p class="mb-0" id="uniqueExplanation">Starting unique elements analysis...</p>
        </div>

        <!-- ADD THIS TABLE CONTAINER -->
        <div class="table-container mt-3" id="uniqueElementsTableContainer" style="display: none;">
            <h6 class="text-center mb-3">Unique Elements Analysis Table</h6>
            <table class="unique-elements-table table-animation">
                <thead>
                    <tr>
                        <th>Element</th>
                        <th>Frequency</th>
                        <th>Status</th>
                        <th>First Occurrence</th>
                    </tr>
                </thead>
                <tbody id="uniqueElementsTableBody">
                    <!-- Table rows will be inserted here dynamically -->
                </tbody>
            </table>
        </div>
        
        <div class="algorithm-steps mt-3" id="uniqueStepsContainer">
            <h6 class="text-center">Analysis Steps</h6>
            <div class="steps-container" id="uniqueSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Total Unique Elements</div>
            <div class="stats-value" id="uniqueCountValue">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterUnique" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForUniqueness, 'originalUniqueArray');
    renderArrayInContainer([...originalArrayForUniqueness], 'transformedUniqueArray');
    
    performUniqueElementsAnalysis();
}
// NEW: Perform Unique Elements Analysis with Table
function performUniqueElementsAnalysis() {
    const originalContainer = document.getElementById('originalUniqueArray');
    const transformedContainer = document.getElementById('transformedUniqueArray');
    const explanation = document.getElementById('uniqueExplanation');
    const stepsContainer = document.getElementById('uniqueSteps');
    const uniqueCountValue = document.getElementById('uniqueCountValue');
    const continueButton = document.getElementById('continueAfterUnique');
    const tableContainer = document.getElementById('uniqueElementsTableContainer');
    const tableBody = document.getElementById('uniqueElementsTableBody');
    
    const arr = [...originalArrayForUniqueness];
    let frequencyMap = new Map();
    let step = 0;
    
    // First pass: Count frequencies
    explanation.innerHTML = "Step 1: Counting frequency of each element...";
    
    function performAnalysisStep() {
        if (step === 0) {
            // Count frequencies
            arr.forEach(element => {
                frequencyMap.set(element, (frequencyMap.get(element) || 0) + 1);
            });
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Frequency counting completed
                </div>
            `;
            
            step++;
            setTimeout(performAnalysisStep, 1000);
            
        } else if (step === 1) {
            // Show the frequency table
            explanation.innerHTML = "Step 2: Displaying frequency analysis table...";
            
            // Populate the table
            tableBody.innerHTML = '';
            let uniqueCount = 0;
            
            frequencyMap.forEach((frequency, element) => {
                const row = document.createElement('tr');
                const status = frequency === 1 ? 'Unique' : 'Duplicate';
                const statusClass = frequency === 1 ? 'frequency-unique' : 'frequency-duplicate';
                
                // Find first occurrence index
                const firstIndex = arr.indexOf(element);
                
                row.innerHTML = `
                    <td>${element}</td>
                    <td>${frequency}</td>
                    <td class="${statusClass}">${status}</td>
                    <td>Index ${firstIndex}</td>
                `;
                tableBody.appendChild(row);
                
                if (frequency === 1) {
                    uniqueCount++;
                }
            });
            
            // Show the table
            tableContainer.style.display = 'block';
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 2:</strong> Frequency analysis table displayed
                </div>
            `;
            
            uniqueCountValue.textContent = uniqueCount;
            step++;
            setTimeout(performAnalysisStep, 2000);
            
        } else if (step === 2) {
            // Highlight unique elements in the array
            explanation.innerHTML = "Step 3: Highlighting unique elements in the array...";
            
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            let highlightedCount = 0;
            
            arr.forEach((element, index) => {
                if (frequencyMap.get(element) === 1) {
                    setTimeout(() => {
                        transformedElements[index].querySelector('.element-value').classList.add('unique-element');
                        highlightedCount++;
                        
                        if (highlightedCount === Array.from(frequencyMap).filter(([_, freq]) => freq === 1).length) {
                            step++;
                            setTimeout(performAnalysisStep, 1000);
                        }
                    }, index * 300);
                }
            });
            
        } else {
            // Analysis completed
            explanation.innerHTML = `<strong>Analysis Completed!</strong> Found ${uniqueCountValue.textContent} unique elements.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Unique elements analysis completed. ${uniqueCountValue.textContent} unique elements found.
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterUniqueAnalysis();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterUniqueAnalysis);
        }
    }
    
    // Start analysis
    performAnalysisStep();
}

// NEW: Perform First Non-Repeating Element Search with Animation
function performFirstNonRepeatingSearch() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find First Non-Repeating Element</h5>
        
        <div class="array-group">
            <div class="array-label">Array Analysis</div>
            <div class="original-array-container" id="nonRepeatingArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find the first element that appears only once in the array</p>
            <p class="mb-0" id="nonRepeatingExplanation">Starting analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="nonRepeatingStepsContainer">
            <h6 class="text-center">Analysis Steps</h6>
            <div class="steps-container" id="nonRepeatingSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>First Non-Repeating Element</div>
            <div class="stats-value" id="firstNonRepeatingResult">-</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Found at Index</div>
            <div class="stats-value" id="firstNonRepeatingIndex">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterNonRepeating" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForUniqueness, 'nonRepeatingArray');
    
    executeFirstNonRepeatingAlgorithm();
}

// NEW: Execute First Non-Repeating Algorithm
function executeFirstNonRepeatingAlgorithm() {
    const arrayContainer = document.getElementById('nonRepeatingArray');
    const explanation = document.getElementById('nonRepeatingExplanation');
    const stepsContainer = document.getElementById('nonRepeatingSteps');
    const resultElement = document.getElementById('firstNonRepeatingResult');
    const resultIndex = document.getElementById('firstNonRepeatingIndex');
    const continueButton = document.getElementById('continueAfterNonRepeating');
    
    const arr = [...originalArrayForUniqueness];
    const frequency = new Map();
    let currentIndex = 0;
    let step = 0;
    let foundElement = null;
    let foundIndex = -1;
    
    function executeStep() {
        if (currentIndex >= arr.length) {
            // Analysis completed - find first non-repeating
            explanation.innerHTML = 'Frequency analysis completed. Finding first non-repeating element...';
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step + 1}:</strong> Frequency analysis completed. Finding first element with count = 1
                </div>
            `;
            
            // Find first non-repeating element
            for (let i = 0; i < arr.length; i++) {
                if (frequency.get(arr[i]) === 1) {
                    foundElement = arr[i];
                    foundIndex = i;
                    break;
                }
            }
            
            setTimeout(() => {
                if (foundElement !== null) {
                    explanation.innerHTML = `<strong>Found!</strong> First non-repeating element: "${foundElement}" at index ${foundIndex}`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Result:</strong> First non-repeating element found: "${foundElement}" at index ${foundIndex}
                        </div>
                    `;
                    
                    // Highlight the found element
                    const elements = arrayContainer.querySelectorAll('.array-element');
                    elements[foundIndex].querySelector('.element-value').classList.add('non-repeating');
                    
                    resultElement.textContent = foundElement;
                    resultIndex.textContent = foundIndex;
                    
                } else {
                    explanation.innerHTML = '<strong>No non-repeating element found!</strong> All elements repeat.';
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Result:</strong> No non-repeating element found - all elements repeat at least once
                        </div>
                    `;
                    
                    resultElement.textContent = 'None';
                    resultIndex.textContent = '-1';
                }
                
                continueButton.style.display = 'block';
                
                // Auto-return after 5 seconds
                setTimeout(() => {
                    returnToOriginalAfterUniqueness();
                }, 5000);
                
                continueButton.addEventListener('click', returnToOriginalAfterUniqueness);
                
            }, 1500);
            
            return;
        }
        
        step++;
        const currentElement = arr[currentIndex];
        
        explanation.innerHTML = `Step ${step}: Analyzing element at index ${currentIndex}: "${currentElement}"`;
        
        // Highlight current element
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentValueDiv = elements[currentIndex].querySelector('.element-value');
        currentValueDiv.classList.add('checked-element');
        
        // Update frequency
        const currentCount = frequency.get(currentElement) || 0;
        frequency.set(currentElement, currentCount + 1);
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Element "${currentElement}" at index ${currentIndex} - Count: ${currentCount + 1}
            </div>
        `;
        
        // Check if this element repeats
        if (currentCount > 0) {
            // Mark as repeating
            setTimeout(() => {
                currentValueDiv.classList.remove('checked-element');
                currentValueDiv.classList.add('repeating');
                
                // Also mark previous occurrences
                for (let i = 0; i < currentIndex; i++) {
                    if (arr[i] === currentElement) {
                        elements[i].querySelector('.element-value').classList.add('repeating');
                    }
                }
                
                currentIndex++;
                executeStep();
            }, 1000);
        } else {
            setTimeout(() => {
                currentValueDiv.classList.remove('checked-element');
                currentIndex++;
                executeStep();
            }, 1000);
        }
    }
    
    // Start execution
    executeStep();
}

// NEW: Perform Unique Elements Search with Animation
function performUniqueElementsSearch() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find All Unique Elements</h5>
        
        <div class="array-group">
            <div class="array-label">Array Analysis</div>
            <div class="original-array-container" id="uniqueElementsArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find all elements that appear exactly once in the array</p>
            <p class="mb-0" id="uniqueElementsExplanation">Starting frequency analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="uniqueElementsStepsContainer">
            <h6 class="text-center">Analysis Steps</h6>
            <div class="steps-container" id="uniqueElementsSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Total Unique Elements Found</div>
            <div class="stats-value" id="uniqueElementsCount">0</div>
        </div>
        
        <div class="table-container mt-3" id="uniqueElementsTableContainer" style="display: none;">
            <h6 class="text-center">Unique Elements</h6>
            <table class="unique-elements-table">
                <thead>
                    <tr>
                        <th>Element</th>
                        <th>Index</th>
                        <th>Frequency</th>
                    </tr>
                </thead>
                <tbody id="uniqueElementsTableBody">
                </tbody>
            </table>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterUniqueElements" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForUniqueness, 'uniqueElementsArray');
    
    executeUniqueElementsAlgorithm();
}

// NEW: Execute Unique Elements Algorithm
function executeUniqueElementsAlgorithm() {
    const arrayContainer = document.getElementById('uniqueElementsArray');
    const explanation = document.getElementById('uniqueElementsExplanation');
    const stepsContainer = document.getElementById('uniqueElementsSteps');
    const countElement = document.getElementById('uniqueElementsCount');
    const tableContainer = document.getElementById('uniqueElementsTableContainer');
    const tableBody = document.getElementById('uniqueElementsTableBody');
    const continueButton = document.getElementById('continueAfterUniqueElements');
    
    const arr = [...originalArrayForUniqueness];
    const frequency = new Map();
    const elementIndices = new Map(); // Store first occurrence index for each element
    let currentIndex = 0;
    let step = 0;
    const uniqueElements = [];
    
    function executeStep() {
        if (currentIndex >= arr.length) {
            // Analysis completed - find unique elements
            explanation.innerHTML = 'Frequency analysis completed. Identifying unique elements...';
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step + 1}:</strong> Frequency analysis completed. Finding elements with count = 1
                </div>
            `;
            
            // Find all unique elements
            for (let i = 0; i < arr.length; i++) {
                if (frequency.get(arr[i]) === 1) {
                    uniqueElements.push({
                        element: arr[i],
                        index: i,
                        frequency: 1
                    });
                }
            }
            
            setTimeout(() => {
                explanation.innerHTML = `<strong>Analysis Complete!</strong> Found ${uniqueElements.length} unique element(s)`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Result:</strong> Found ${uniqueElements.length} unique element(s) in the array
                    </div>
                `;
                
                // Highlight all unique elements in the array
                const elements = arrayContainer.querySelectorAll('.array-element');
                uniqueElements.forEach(unique => {
                    elements[unique.index].querySelector('.element-value').classList.add('unique-element');
                });
                
                countElement.textContent = uniqueElements.length;
                
                // Display results in table
                if (uniqueElements.length > 0) {
                    tableBody.innerHTML = '';
                    uniqueElements.forEach(unique => {
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td>${unique.element}</td>
                            <td>${unique.index}</td>
                            <td>${unique.frequency}</td>
                        `;
                        tableBody.appendChild(row);
                    });
                    tableContainer.style.display = 'block';
                }
                
                continueButton.style.display = 'block';
                
                // Auto-return after 5 seconds
                setTimeout(() => {
                    returnToOriginalAfterUniqueness();
                }, 5000);
                
                continueButton.addEventListener('click', returnToOriginalAfterUniqueness);
                
            }, 1500);
            
            return;
        }
        
        step++;
        const currentElement = arr[currentIndex];
        
        explanation.innerHTML = `Step ${step}: Analyzing element at index ${currentIndex}: "${currentElement}"`;
        
        // Highlight current element
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentValueDiv = elements[currentIndex].querySelector('.element-value');
        currentValueDiv.classList.add('checked-element');
        
        // Update frequency and store first occurrence index
        const currentCount = frequency.get(currentElement) || 0;
        frequency.set(currentElement, currentCount + 1);
        
        if (currentCount === 0) {
            elementIndices.set(currentElement, currentIndex);
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Element "${currentElement}" at index ${currentIndex} - Count: ${currentCount + 1}
            </div>
        `;
        
        // Check if this element repeats
        if (currentCount > 0) {
            // Mark as repeating
            setTimeout(() => {
                currentValueDiv.classList.remove('checked-element');
                currentValueDiv.classList.add('repeating');
                
                // Also mark previous occurrences
                for (let i = 0; i < currentIndex; i++) {
                    if (arr[i] === currentElement) {
                        elements[i].querySelector('.element-value').classList.add('repeating');
                    }
                }
                
                currentIndex++;
                executeStep();
            }, 1000);
        } else {
            setTimeout(() => {
                currentValueDiv.classList.remove('checked-element');
                currentIndex++;
                executeStep();
            }, 1000);
        }
    }
    
    // Start execution
    executeStep();
}

// NEW: Return to Original after Uniqueness Operations
function returnToOriginalAfterUniqueness() {
    // Reset to original array
    myArray = [...originalArrayForUniqueness];
    originalArrayForUniqueness = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset states
    isNonRepeatingRunning = false;
    isUniqueElementsRunning = false;
    
    logOperation('Uniqueness operation completed - returned to original array', 'info');
    showNotification('Returned to original array after uniqueness analysis', 'success');
}
// NEW: Find Majority Element Handler
function handleFindMajorityElement() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isMajoritySearchRunning) {
        showNotification('Majority element search is already in progress', 'warning');
        return;
    }
    
    // Store original array
    originalArrayForMajority = [...myArray];
    
    // Show majority element visualization
    showMajorityElementVisualization();
}
// NEW: Show Majority Element Visualization
function showMajorityElementVisualization() {
    isMajoritySearchRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Boyer-Moore Voting Algorithm - Find Majority Element</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalMajorityArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Algorithm Process</div>
            <div class="transformed-array-container" id="processMajorityArray"></div>
        </div>
        
        <div class="majority-explanation">
            <p class="mb-2"><strong>Boyer-Moore Voting Algorithm:</strong> Finds element appearing more than n/2 times</p>
            <p class="mb-0" id="majorityExplanation">Initializing algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="majorityStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="majoritySteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Current Candidate</div>
            <div class="stats-value" id="currentCandidate">-</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Current Count</div>
            <div class="stats-value" id="currentCount">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Majority Element</div>
            <div class="stats-value" id="majorityElement">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMajority" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForMajority, 'originalMajorityArray');
    renderArrayInContainer([...originalArrayForMajority], 'processMajorityArray');
    
    performMajorityAlgorithmAnimation();
}
// NEW: Perform Majority Algorithm Animation
function performMajorityAlgorithmAnimation() {
    const originalContainer = document.getElementById('originalMajorityArray');
    const processContainer = document.getElementById('processMajorityArray');
    const explanation = document.getElementById('majorityExplanation');
    const stepsContainer = document.getElementById('majoritySteps');
    const currentCandidate = document.getElementById('currentCandidate');
    const currentCount = document.getElementById('currentCount');
    const majorityElement = document.getElementById('majorityElement');
    const continueButton = document.getElementById('continueAfterMajority');
    
    const arr = [...originalArrayForMajority];
    let candidate = null;
    let count = 0;
    let step = 0;
    
    // Phase 1: Find candidate
    function performPhase1Step(i) {
        if (i >= arr.length) {
            // Phase 1 completed
            explanation.innerHTML = `<strong>Phase 1 Completed!</strong> Candidate found: ${candidate || 'None'}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Phase 1 Complete:</strong> Candidate = ${candidate || 'None'}, Final Count = ${count}
                </div>
            `;
            
            // Proceed to verification phase
            setTimeout(() => {
                performVerificationPhase();
            }, 2000);
            
            return;
        }
        
        step++;
        
        if (step === 1) {
            // First element
            explanation.innerHTML = `Step ${step}: Initialize with first element = "${arr[i]}"`;
            
            candidate = arr[i];
            count = 1;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Initialize candidate = "${candidate}", count = ${count}
                </div>
            `;
            
            updateDisplay();
            highlightCurrentElement(i, 'initialize');
            
        } else {
            explanation.innerHTML = `Step ${step}: Processing element [${i}] = "${arr[i]}"`;
            
            const processElements = processContainer.querySelectorAll('.array-element');
            const currentElement = processElements[i].querySelector('.element-value');
            
            if (count === 0) {
                // New candidate
                explanation.innerHTML = `Step ${step}: Count is 0, new candidate = "${arr[i]}"`;
                
                candidate = arr[i];
                count = 1;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> Count was 0  New candidate = "${candidate}", count = ${count}
                    </div>
                `;
                
                currentElement.classList.add('majority-candidate');
                
            } else if (arr[i] === candidate) {
                // Same candidate, increase count
                explanation.innerHTML = `Step ${step}: Same as candidate, increasing count`;
                
                count++;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> Element matches candidate  count++ = ${count}
                    </div>
                `;
                
                currentElement.classList.add('majority-count-increase');
                
            } else {
                // Different element, decrease count
                explanation.innerHTML = `Step ${step}: Different from candidate, decreasing count`;
                
                count--;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> Element different  count-- = ${count}
                    </div>
                `;
                
                currentElement.classList.add('majority-count-decrease');
            }
            
            updateDisplay();
            highlightCurrentElement(i, 'process');
        }
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Continue to next element after delay
        setTimeout(() => {
            performPhase1Step(i + 1);
        }, 2000);
    }
    
    // Phase 2: Verify candidate
    function performVerificationPhase() {
        if (candidate === null) {
            explanation.innerHTML = `<strong>No candidate found!</strong> Array has no majority element.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Verification:</strong> No candidate found  No majority element exists
                </div>
            `;
            
            majorityElement.textContent = 'None';
            completeAlgorithm();
            return;
        }
        
        explanation.innerHTML = `<strong>Phase 2:</strong> Verifying candidate "${candidate}"`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Phase 2:</strong> Verify if "${candidate}" appears more than n/2 times (${arr.length}/2 = ${Math.floor(arr.length/2)})
            </div>
        `;
        
        let actualCount = 0;
        let verificationStep = 0;
        
        function performVerificationStep(i) {
            if (i >= arr.length) {
                // Verification completed
                const isMajority = actualCount > Math.floor(arr.length / 2);
                
                if (isMajority) {
                    explanation.innerHTML = `<strong>Verification Complete!</strong> "${candidate}" is majority element (appears ${actualCount} times > ${Math.floor(arr.length/2)})`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Verification Result:</strong> "${candidate}" appears ${actualCount} times > ${Math.floor(arr.length/2)}  MAJORITY ELEMENT FOUND!
                        </div>
                    `;
                    
                    majorityElement.textContent = `${candidate} (${actualCount} occurrences)`;
                    highlightMajorityElements();
                    
                } else {
                    explanation.innerHTML = `<strong>Verification Complete!</strong> "${candidate}" is not majority element (appears ${actualCount} times  ${Math.floor(arr.length/2)})`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Verification Result:</strong> "${candidate}" appears ${actualCount} times  ${Math.floor(arr.length/2)}  NO MAJORITY ELEMENT
                        </div>
                    `;
                    
                    majorityElement.textContent = 'None';
                }
                
                completeAlgorithm();
                return;
            }
            
            verificationStep++;
            
            if (arr[i] === candidate) {
                actualCount++;
                
                explanation.innerHTML = `Verification Step ${verificationStep}: [${i}] = "${arr[i]}" matches candidate  count = ${actualCount}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step ${arr[i] === candidate ? 'active' : ''}">
                        <strong>Verification ${verificationStep}:</strong> [${i}] = "${arr[i]}" ${arr[i] === candidate ? 'MATCHES' : 'different'}  count = ${actualCount}
                    </div>
                `;
                
                const processElements = processContainer.querySelectorAll('.array-element');
                processElements[i].querySelector('.element-value').classList.add('majority-current');
            }
            
            // Scroll steps container
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            // Continue to next element after delay
            setTimeout(() => {
                performVerificationStep(i + 1);
            }, 1500);
        }
        
        performVerificationStep(0);
    }
    
    function highlightCurrentElement(index, phase) {
        const processElements = processContainer.querySelectorAll('.array-element');
        
        // Remove previous highlights
        processElements.forEach(el => {
            const valueDiv = el.querySelector('.element-value');
            valueDiv.classList.remove(
                'majority-current', 
                'majority-candidate', 
                'majority-count-increase', 
                'majority-count-decrease'
            );
        });
        
        // Highlight current element
        if (index < processElements.length) {
            const currentElement = processElements[index].querySelector('.element-value');
            currentElement.classList.add('majority-current');
        }
        
        // Highlight candidate elements
        if (candidate) {
            processElements.forEach((el, i) => {
                if (i <= index && arr[i] === candidate) {
                    el.querySelector('.element-value').classList.add('majority-candidate');
                }
            });
        }
    }
    
    function highlightMajorityElements() {
        const processElements = processContainer.querySelectorAll('.array-element');
        
        processElements.forEach((el, i) => {
            if (arr[i] === candidate) {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('majority-found');
                }, (i * 100));
            }
        });
    }
    
    function updateDisplay() {
        currentCandidate.textContent = candidate || '-';
        currentCount.textContent = count;
    }
    
    function completeAlgorithm() {
        continueButton.style.display = 'block';
        
        // Auto-return to original after 5 seconds
        setTimeout(() => {
            returnToOriginalAfterMajority();
        }, 5000);
        
        continueButton.addEventListener('click', returnToOriginalAfterMajority);
    }
    
    // Start phase 1
    performPhase1Step(0);
}
// NEW: Return to Original after Majority Search
function returnToOriginalAfterMajority() {
    // Reset to original array
    myArray = [...originalArrayForMajority];
    originalArrayForMajority = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMajoritySearchRunning = false;
    
    logOperation('Majority element search completed - returned to original array', 'info');
    showNotification('Returned to original array after majority element search', 'success');
}
// NEW: Dutch National Flag Sort Handler
function handleDutchNationalFlagSort() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isDutchSortRunning) {
        showNotification('A Dutch National Flag sort is already in progress', 'warning');
        return;
    }
    
    // Validate that array contains only 0s, 1s, and 2s
    let isValid = true;
    for (let i = 0; i < myArray.length; i++) {
        const value = myArray[i].toString().trim();
        if (value !== '0' && value !== '1' && value !== '2') {
            isValid = false;
            break;
        }
    }
    
    if (!isValid) {
        showNotification('Please enter elements containing only 0s, 1s, and 2s', 'danger');
        return;
    }
    
    isDutchSortRunning = true;
    sortDutchNationalFlagBtn.disabled = true;
    
    // Store original array
    originalArrayForDutch = [...myArray];
    
    // Show Dutch National Flag visualization
    showDutchNationalFlagVisualization();
}
// NEW: Show Dutch National Flag Visualization
function showDutchNationalFlagVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Dutch National Flag Problem - Sort 0s, 1s, 2s</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array (0s, 1s, 2s)</div>
            <div class="original-array-container" id="originalDutchArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-flag"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Sorted Array (Three-Pointer Technique)</div>
            <div class="transformed-array-container" id="transformedDutchArray"></div>
        </div>
        
        <div class="dutch-explanation">
            <p class="mb-2"><strong>Dutch National Flag Algorithm:</strong> Sort array in single pass using three pointers (low, mid, high)</p>
            <p class="mb-0" id="dutchExplanation">Starting Dutch National Flag sort...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="dutchStepsContainer">
            <h6 class="text-center">Three-Pointer Technique Steps</h6>
            <div class="steps-container" id="dutchSteps"></div>
        </div>
        
        <div class="pointers-info mt-3" id="pointersInfo">
            <div class="row text-center">
                <div class="col-4">
                    <div class="pointer-item dutch-low p-2 rounded">Low Pointer</div>
                </div>
                <div class="col-4">
                    <div class="pointer-item dutch-mid p-2 rounded">Mid Pointer</div>
                </div>
                <div class="col-4">
                    <div class="pointer-item dutch-high p-2 rounded">High Pointer</div>
                </div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterDutchSort" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForDutch, 'originalDutchArray');
    renderArrayInContainer([...originalArrayForDutch], 'transformedDutchArray');
    
    performDutchNationalFlagSort();
}
// NEW: Perform Dutch National Flag Sort with Visualization
function performDutchNationalFlagSort() {
    const originalContainer = document.getElementById('originalDutchArray');
    const transformedContainer = document.getElementById('transformedDutchArray');
    const explanation = document.getElementById('dutchExplanation');
    const stepsContainer = document.getElementById('dutchSteps');
    const continueButton = document.getElementById('continueAfterDutchSort');
    
    const array = [...originalArrayForDutch].map(val => parseInt(val));
    let low = 0;
    let mid = 0;
    let high = array.length - 1;
    let stepCount = 0;
    
    function performDutchStep() {
        if (mid > high) {
            // Sorting completed
            explanation.innerHTML = `<strong>Dutch National Flag Sort Completed!</strong> Array sorted in single pass.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${++stepCount}:</strong> Sorting Complete! All elements are in correct positions.
                </div>
            `;
            
            // Highlight all elements as sorted
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                const valueDiv = el.querySelector('.element-value');
                setTimeout(() => {
                    valueDiv.classList.add('dutch-sorted');
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return to original after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterDutchSort();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterDutchSort);
            
            return;
        }
        
        stepCount++;
        const currentValue = array[mid];
        
        // Update pointers visualization
        updateDutchPointers(low, mid, high);
        
        switch (currentValue) {
            case 0:
                // Swap array[low] and array[mid], increment both
                explanation.innerHTML = `Step ${stepCount}: Found 0 at mid=${mid}. Swapping with low=${low}`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${stepCount}:</strong> array[${mid}] = 0  Swap with array[${low}]  low++, mid++
                    </div>
                `;
                
                performDutchSwap(low, mid, () => {
                    // Perform the swap
                    [array[low], array[mid]] = [array[mid], array[low]];
                    low++;
                    mid++;
                    setTimeout(performDutchStep, 1500);
                });
                break;
                
            case 1:
                // Just increment mid
                explanation.innerHTML = `Step ${stepCount}: Found 1 at mid=${mid}. No swap needed, mid++`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${stepCount}:</strong> array[${mid}] = 1  No swap needed  mid++
                    </div>
                `;
                
                // Highlight mid element as correct (1)
                const elements = transformedContainer.querySelectorAll('.array-element');
                const midElement = elements[mid].querySelector('.element-value');
                midElement.classList.add('dutch-mid');
                
                setTimeout(() => {
                    midElement.classList.remove('dutch-mid');
                    mid++;
                    performDutchStep();
                }, 1000);
                break;
                
            case 2:
                // Swap array[mid] and array[high], decrement high
                explanation.innerHTML = `Step ${stepCount}: Found 2 at mid=${mid}. Swapping with high=${high}`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${stepCount}:</strong> array[${mid}] = 2  Swap with array[${high}]  high--
                    </div>
                `;
                
                performDutchSwap(mid, high, () => {
                    // Perform the swap
                    [array[mid], array[high]] = [array[high], array[mid]];
                    high--;
                    setTimeout(performDutchStep, 1500);
                });
                break;
        }
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
    }
    
    function performDutchSwap(i, j, callback) {
        const elements = transformedContainer.querySelectorAll('.array-element');
        const elementI = elements[i].querySelector('.element-value');
        const elementJ = elements[j].querySelector('.element-value');
        
        elementI.classList.add('dutch-swap');
        elementJ.classList.add('dutch-swap');
        
        // Calculate swap distance for animation
        const rectI = elements[i].getBoundingClientRect();
        const rectJ = elements[j].getBoundingClientRect();
        const swapDistance = rectJ.left - rectI.left;
        
        elementI.style.setProperty('--swap-distance', `${swapDistance}px`);
        elementJ.style.setProperty('--swap-distance', `-${swapDistance}px`);
        
        setTimeout(() => {
            elementI.classList.add('swap-animation');
            elementJ.classList.add('swap-animation');
            
            setTimeout(() => {
                // Update the transformed array display
                renderArrayInContainer(array.map(val => val.toString()), 'transformedDutchArray');
                
                // Remove swap highlights
                elementI.classList.remove('dutch-swap', 'swap-animation');
                elementJ.classList.remove('dutch-swap', 'swap-animation');
                
                callback();
            }, 1000);
        }, 500);
    }
    
    function updateDutchPointers(low, mid, high) {
        const elements = transformedContainer.querySelectorAll('.array-element');
        
        // Reset all pointer highlights
        elements.forEach(el => {
            const valueDiv = el.querySelector('.element-value');
            valueDiv.classList.remove('dutch-low', 'dutch-mid', 'dutch-high');
        });
        
        // Highlight current pointers
        if (low < elements.length) {
            elements[low].querySelector('.element-value').classList.add('dutch-low');
        }
        if (mid < elements.length) {
            elements[mid].querySelector('.element-value').classList.add('dutch-mid');
        }
        if (high < elements.length && high >= 0) {
            elements[high].querySelector('.element-value').classList.add('dutch-high');
        }
    }
    
    // Start the Dutch National Flag sort
    performDutchStep();
}
// NEW: Return to Original after Dutch National Flag Sort
function returnToOriginalAfterDutchSort() {
    // Reset to original array
    myArray = [...originalArrayForDutch];
    originalArrayForDutch = [];
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isDutchSortRunning = false;
    sortDutchNationalFlagBtn.disabled = false;
    
    // Show original positions with animation
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation('Dutch National Flag sort demonstration completed - returned to original array', 'info');
    showNotification('Returned to original array after Dutch National Flag sort', 'success');
}
// NEW: Shift Left After Deletion Handler
function handleShiftLeftAfterDelete() {
    const index = parseInt(shiftDeleteIndex.value);
    
    // Validation
    if (isNaN(index) || index < 0 || index >= myArray.length) {
        showNotification(`Please enter a valid index between 0 and ${myArray.length - 1}`, 'danger');
        shiftDeleteIndex.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isShiftDeleteRunning) {
        showNotification('A shift delete operation is already in progress', 'warning');
        return;
    }
    
    isShiftDeleteRunning = true;
    shiftLeftAfterDeleteBtn.disabled = true;
    
    // Store original array
    originalArrayBeforeShiftDelete = [...myArray];
    
    // Show shift delete visualization
    showShiftDeleteVisualization(index);
}
// NEW: Show Shift Delete Visualization
function showShiftDeleteVisualization(index) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Shift Left After Deletion</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalShiftDeleteArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After Deletion & Shift Left</div>
            <div class="transformed-array-container" id="transformedShiftDeleteArray"></div>
        </div>
        
        <div class="shift-delete-explanation">
            <p class="mb-2"><strong>Operation:</strong> Delete element at index ${index} and shift all subsequent elements left</p>
            <p class="mb-0" id="shiftDeleteExplanation">Starting shift left after deletion...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="shiftDeleteStepsContainer">
            <h6 class="text-center">Shift Left After Deletion Steps</h6>
            <div class="steps-container" id="shiftDeleteSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterShiftDelete" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayBeforeShiftDelete, 'originalShiftDeleteArray');
    renderArrayInContainer([...originalArrayBeforeShiftDelete], 'transformedShiftDeleteArray');
    
    performShiftDeleteAnimation(index);
}
// NEW: Perform Shift Delete Animation
function performShiftDeleteAnimation(index) {
    const originalContainer = document.getElementById('originalShiftDeleteArray');
    const transformedContainer = document.getElementById('transformedShiftDeleteArray');
    const explanation = document.getElementById('shiftDeleteExplanation');
    const stepsContainer = document.getElementById('shiftDeleteSteps');
    const continueButton = document.getElementById('continueAfterShiftDelete');
    
    const array = [...originalArrayBeforeShiftDelete];
    const deletedValue = array[index];
    let currentStep = 0;
    
    function performShiftDeleteStep() {
        if (currentStep === 0) {
            // Step 1: Highlight the element to be deleted
            explanation.innerHTML = `<strong>Step 1:</strong> Identify element at index ${index} for deletion`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Mark element at index ${index} ("${deletedValue}") for deletion
                </div>
            `;
            
            const originalElements = originalContainer.querySelectorAll('.array-element');
            const targetElement = originalElements[index].querySelector('.element-value');
            targetElement.classList.add('shift-delete-target');
            
            currentStep++;
            setTimeout(performShiftDeleteStep, 1500);
            
        } else if (currentStep === 1) {
            // Step 2: Show deletion and start shifting
            explanation.innerHTML = `<strong>Step 2:</strong> Delete element and begin shifting left`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 2:</strong> Remove element at index ${index} - creating gap
                </div>
            `;
            
            // Create new array with the element removed
            const newArray = [...array];
            newArray.splice(index, 1);
            
            // Update transformed array (show gap or placeholder)
            const tempArray = [...array];
            tempArray[index] = ''; // Show deletion marker
            renderArrayInContainer(tempArray, 'transformedShiftDeleteArray');
            
            // Highlight the deletion
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const deletedElement = transformedElements[index].querySelector('.element-value');
            deletedElement.classList.add('shift-delete-target');
            
            currentStep++;
            setTimeout(performShiftDeleteStep, 1500);
            
        } else if (currentStep === 2) {
            // Step 3: Animate shifting of each subsequent element
            explanation.innerHTML = `<strong>Step 3:</strong> Shifting elements left to fill the gap`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 3:</strong> Shift elements from index ${index + 1} to ${array.length - 1} left by one position
                </div>
            `;
            
            animateElementShifting(index, array, stepsContainer, explanation, () => {
                currentStep++;
                performShiftDeleteStep();
            });
            
        } else if (currentStep === 3) {
            // Step 4: Show final result
            explanation.innerHTML = `<strong>Step 4:</strong> Shift left completed - array size reduced by 1`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 4:</strong> Final array after deletion and shift left operation
                </div>
            `;
            
            // Show final array
            const finalArray = [...array];
            finalArray.splice(index, 1);
            renderArrayInContainer(finalArray, 'transformedShiftDeleteArray');
            
            // Highlight all shifted elements
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            for (let i = index; i < transformedElements.length; i++) {
                const valueDiv = transformedElements[i].querySelector('.element-value');
                setTimeout(() => {
                    valueDiv.classList.add('shift-left-completed');
                }, i * 100);
            }
            
            // Update the actual array
            myArray = finalArray;
            updateStats();
            
            logOperation(`Deleted element at index ${index} ("${deletedValue}") and shifted left`, 'warning');
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterShiftDelete();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterShiftDelete);
        }
    }
    
    // Start the animation
    performShiftDeleteStep();
}
// NEW: Animate Element Shifting
function animateElementShifting(startIndex, originalArray, stepsContainer, explanation, callback) {
    const transformedContainer = document.getElementById('transformedShiftDeleteArray');
    const n = originalArray.length;
    
    let currentShiftIndex = startIndex + 1;
    
    function shiftNextElement() {
        if (currentShiftIndex >= n) {
            // All elements shifted
            callback();
            return;
        }
        
        explanation.innerHTML = `<strong>Step 3:</strong> Shifting element from index ${currentShiftIndex} to ${currentShiftIndex - 1}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Shift:</strong> Move element "${originalArray[currentShiftIndex]}" from index ${currentShiftIndex} to ${currentShiftIndex - 1}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Create temporary array showing current shift
        const tempArray = [...originalArray];
        for (let i = startIndex; i < currentShiftIndex; i++) {
            tempArray[i] = originalArray[i + 1];
        }
        tempArray[currentShiftIndex] = '___'; // Show empty slot
        
        renderArrayInContainer(tempArray, 'transformedShiftDeleteArray');
        
        // Highlight the moving element
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        if (currentShiftIndex - 1 < transformedElements.length) {
            const movingElement = transformedElements[currentShiftIndex - 1].querySelector('.element-value');
            movingElement.classList.add('shift-left-moving');
        }
        
        currentShiftIndex++;
        setTimeout(shiftNextElement, 1000);
    }
    
    shiftNextElement();
}
// NEW: Return to Original after Shift Delete
function returnToOriginalAfterShiftDelete() {
    // Reset to original array
    myArray = [...originalArrayBeforeShiftDelete];
    originalArrayBeforeShiftDelete = [];
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isShiftDeleteRunning = false;
    shiftLeftAfterDeleteBtn.disabled = false;
    shiftDeleteIndex.value = '';
    
    // Show original array with animation
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation('Returned to original array after shift delete demonstration', 'info');
    showNotification('Returned to original array', 'success');
}
// NEW: Find Pivot in Rotated Array Handler
function handleFindPivot() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - pivot is the element itself', 'info');
        highlightElement(0, 'search');
        return;
    }
    
    if (isPivotSearchRunning) {
        showNotification('A pivot search is already in progress', 'warning');
        return;
    }
    
    isPivotSearchRunning = true;
    findPivotBtn.disabled = true;
    
    // Store original array
    originalArrayForPivot = [...myArray];
    
    // Check if array is sorted and rotated
    if (!isArraySortedAndRotated(myArray)) {
        showNotification('Array is not rotated. Auto-rotating for pivot search...', 'warning');
        performAutoRotation();
    } else {
        // Array is already rotated, proceed with pivot search
        performPivotSearch();
    }
}

// NEW: Check if array is sorted and rotated
function isArraySortedAndRotated(arr) {
    if (arr.length <= 1) return true;
    
    // Count how many times the array decreases (should be exactly 1 for a rotated sorted array)
    let decreaseCount = 0;
    for (let i = 1; i < arr.length; i++) {
        const current = parseFloat(arr[i]);
        const prev = parseFloat(arr[i-1]);
        
        if (!isNaN(current) && !isNaN(prev)) {
            if (current < prev) decreaseCount++;
        } else {
            if (arr[i] < arr[i-1]) decreaseCount++;
        }
    }
    
    // Check first and last elements
    const first = parseFloat(arr[0]);
    const last = parseFloat(arr[arr.length - 1]);
    
    if (!isNaN(first) && !isNaN(last)) {
        if (first < last) decreaseCount++;
    } else {
        if (arr[0] < arr[arr.length - 1]) decreaseCount++;
    }
    
    return decreaseCount === 1;
}

// NEW: Perform Auto Rotation
function performAutoRotation() {
    const rotationPoint = Math.floor(Math.random() * (myArray.length - 1)) + 1;
    
    // Create rotated array
    const rotatedArray = [
        ...myArray.slice(rotationPoint),
        ...myArray.slice(0, rotationPoint)
    ];
    
    // Show rotation animation
    showRotationAnimation(rotationPoint, rotatedArray);
}

// NEW: Show Rotation Animation
function showRotationAnimation(rotationPoint, rotatedArray) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Auto-Rotating Array for Pivot Search</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalRotationArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-sync-alt fa-spin"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Rotated Array</div>
            <div class="transformed-array-container" id="transformedRotationArray"></div>
        </div>
        
        <div class="pivot-explanation">
            <p class="mb-2"><strong>Rotation Point:</strong> Index ${rotationPoint}</p>
            <p class="mb-0" id="rotationExplanation">Rotating array for pivot search demonstration...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="rotationStepsContainer">
            <h6 class="text-center">Rotation Steps</h6>
            <div class="steps-container" id="rotationSteps"></div>
        </div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForPivot, 'originalRotationArray');
    renderArrayInContainer(new Array(originalArrayForPivot.length).fill('?'), 'transformedRotationArray');
    
    performStepByStepRotation(rotationPoint, rotatedArray);
}

// NEW: Perform Step-by-Step Rotation
function performStepByStepRotation(rotationPoint, rotatedArray) {
    const originalContainer = document.getElementById('originalRotationArray');
    const transformedContainer = document.getElementById('transformedRotationArray');
    const explanation = document.getElementById('rotationExplanation');
    const stepsContainer = document.getElementById('rotationSteps');
    
    let currentStep = 0;
    
    function performRotationStep(index) {
        if (index >= rotatedArray.length) {
            // Rotation completed
            explanation.innerHTML = `<strong>Rotation Complete!</strong> Array rotated at index ${rotationPoint}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${currentStep}:</strong> Rotation completed! Array is now properly rotated.
                </div>
            `;
            
            // Update the actual array and proceed with pivot search
            setTimeout(() => {
                myArray = rotatedArray;
                removeDualVisualization();
                performPivotSearch();
            }, 2000);
            
            return;
        }
        
        // Calculate original index for this position in rotated array
        const originalIndex = (index < myArray.length - rotationPoint) ? 
            rotationPoint + index : 
            index - (myArray.length - rotationPoint);
        
        // Update step explanation
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentStep}:</strong> 
                Position [${index}]  Original [${originalIndex}] = "${originalArrayForPivot[originalIndex]}"
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Highlight original element being moved
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const originalValueDiv = originalElements[originalIndex].querySelector('.element-value');
        originalValueDiv.classList.add('rotation-highlight');
        
        // After a delay, update the rotated array
        setTimeout(() => {
            // Update rotated array element
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const transformedValueDiv = transformedElements[index].querySelector('.element-value');
            transformedValueDiv.textContent = rotatedArray[index];
            transformedValueDiv.classList.add('rotation-highlight');
            
            // Remove highlight from original element
            originalValueDiv.classList.remove('rotation-highlight');
            
            // Remove highlight from transformed element after animation
            setTimeout(() => {
                transformedValueDiv.classList.remove('rotation-highlight');
            }, 1000);
            
            // Move to next step
            currentStep++;
            performRotationStep(index + 1);
        }, 1000);
    }
    
    // Start rotation process
    performRotationStep(0);
}

// NEW: Perform Pivot Search with Visualization
function performPivotSearch() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find Pivot in Rotated Sorted Array</h5>
        
        <div class="array-group">
            <div class="array-label">Rotated Array</div>
            <div class="original-array-container" id="pivotSearchArray"></div>
        </div>
        
        <div class="pivot-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Binary Search for Pivot (Smallest Element)</p>
            <p class="mb-0" id="pivotExplanation">Starting pivot search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="pivotStepsContainer">
            <h6 class="text-center">Pivot Search Steps</h6>
            <div class="steps-container" id="pivotSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPivot" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(myArray, 'pivotSearchArray');
    
    performBinaryPivotSearch(0, myArray.length - 1);
}

// NEW: Perform Binary Pivot Search with Animation
function performBinaryPivotSearch(left, right) {
    const arrayContainer = document.getElementById('pivotSearchArray');
    const explanation = document.getElementById('pivotExplanation');
    const stepsContainer = document.getElementById('pivotSteps');
    const continueButton = document.getElementById('continueAfterPivot');
    
    // Convert array to numbers for comparison
    const numArray = myArray.map(val => parseFloat(val));
    const isNumeric = !numArray.some(isNaN);
    
    function searchPivot(low, high, stepCount) {
        if (low > high) {
            // Should not happen in a properly rotated sorted array
            explanation.innerHTML = `<strong>Error:</strong> Pivot not found. Array may not be properly rotated.`;
            resetPivotSearchState();
            return;
        }
        
        if (low === high) {
            // Pivot found
            const pivotIndex = low;
            const pivotValue = myArray[pivotIndex];
            
            // Highlight the pivot
            highlightPivotFound(pivotIndex, pivotValue);
            
            explanation.innerHTML = `<strong>Pivot Found!</strong> Smallest element at index ${pivotIndex}: ${pivotValue}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${stepCount}:</strong> 
                    Pivot FOUND! Index [${pivotIndex}] = "${pivotValue}" is the smallest element
                </div>
            `;
            
            logOperation(`Found pivot at index ${pivotIndex} with value "${pivotValue}"`, 'success');
            
            continueButton.style.display = 'block';
            continueButton.addEventListener('click', returnToOriginalAfterPivot);
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterPivot();
            }, 5000);
            
            return;
        }
        
        const mid = Math.floor((low + high) / 2);
        
        // Update explanation
        explanation.innerHTML = `Searching: low=${low}, high=${high}, mid=${mid}`;
        
        // Highlight current search space
        highlightPivotSearchSpace(low, high, mid);
        
        // Add step to steps container
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${stepCount}:</strong> 
                low=[${low}]="${myArray[low]}", high=[${high}]="${myArray[high]}", mid=[${mid}]="${myArray[mid]}"
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Compare mid element with high element
        setTimeout(() => {
            let comparisonText = '';
            let newLow = low, newHigh = high;
            
            if (isNumeric) {
                if (numArray[mid] > numArray[high]) {
                    comparisonText = `mid(${numArray[mid]}) > high(${numArray[high]})  pivot in right half`;
                    newLow = mid + 1;
                } else {
                    comparisonText = `mid(${numArray[mid]})  high(${numArray[high]})  pivot in left half`;
                    newHigh = mid;
                }
            } else {
                if (myArray[mid] > myArray[high]) {
                    comparisonText = `mid("${myArray[mid]}") > high("${myArray[high]}")  pivot in right half`;
                    newLow = mid + 1;
                } else {
                    comparisonText = `mid("${myArray[mid]}")  high("${myArray[high]}")  pivot in left half`;
                    newHigh = mid;
                }
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Comparison:</strong> ${comparisonText}
                </div>
            `;
            
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            // Continue search with new bounds
            setTimeout(() => {
                searchPivot(newLow, newHigh, stepCount + 1);
            }, 1500);
            
        }, 1500);
    }
    
    // Start pivot search
    searchPivot(left, right, 1);
}

// NEW: Highlight Pivot Search Space
function highlightPivotSearchSpace(low, high, mid) {
    const arrayContainer = document.getElementById('pivotSearchArray');
    const elements = arrayContainer.querySelectorAll('.array-element');
    
    // Reset all elements
    elements.forEach((el, index) => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('pivot-low', 'pivot-high', 'pivot-mid', 'pivot-found');
        
        if (index >= low && index <= high) {
            if (index === low) {
                valueDiv.classList.add('pivot-low');
            } else if (index === high) {
                valueDiv.classList.add('pivot-high');
            } else if (index === mid) {
                valueDiv.classList.add('pivot-mid');
            }
        }
    });
}

// NEW: Highlight Found Pivot
function highlightPivotFound(index, value) {
    const arrayContainer = document.getElementById('pivotSearchArray');
    const elements = arrayContainer.querySelectorAll('.array-element');
    const valueDiv = elements[index].querySelector('.element-value');
    
    valueDiv.classList.remove('pivot-low', 'pivot-high', 'pivot-mid');
    valueDiv.classList.add('pivot-found');
}

// NEW: Return to Original after Pivot Search
function returnToOriginalAfterPivot() {
    // Reset to original array
    if (originalArrayForPivot.length > 0) {
        myArray = [...originalArrayForPivot];
        originalArrayForPivot = [];
    }
    
    // Remove dual visualization and return to normal view
    removeDualVisualization();
    renderArray();
    updateStats();
    
    // Reset state
    isPivotSearchRunning = false;
    findPivotBtn.disabled = false;
    
    logOperation('Pivot search completed - returned to original array', 'info');
    showNotification('Returned to original array after pivot search', 'success');
}

// NEW: Remove Dual Visualization (helper function)
function removeDualVisualization() {
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
}
// NEW: Search in Rotated Sorted Array Handler
function handleRotatedSearch() {
    if (isRotatedSearchRunning) {
        showNotification('A rotated search is already in progress', 'warning');
        return;
    }
    
    const element = rotatedSearchElement.value.trim();
    if (element === '') {
        showNotification('Please enter an element to search', 'warning');
        rotatedSearchElement.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    isRotatedSearchRunning = true;
    rotatedSearchBtn.disabled = true;
    
    // Store original array
    originalArrayForRotatedSearch = [...myArray];
    
    // Prepare array for rotated search (ensure it's sorted and rotated)
    prepareArrayForRotatedSearch(element);
}

// NEW: Prepare Array for Rotated Search
function prepareArrayForRotatedSearch(target) {
    // Check if array is already sorted
    if (!isArraySorted(myArray)) {
        showNotification('Array is not sorted. Auto-sorting and rotating for search...', 'warning');
        
        // Sort the array
        myArray.sort((a, b) => {
            const numA = parseFloat(a);
            const numB = parseFloat(b);
            if (!isNaN(numA) && !isNaN(numB)) {
                return numA - numB;
            }
            return a.toString().localeCompare(b.toString());
        });
        
        renderArray();
        
        // Rotate the array after sorting
        setTimeout(() => {
            rotateArrayForSearch(target);
        }, 1000);
    } else {
        // Array is already sorted, just rotate it
        rotateArrayForSearch(target);
    }
}

// NEW: Rotate Array for Search
function rotateArrayForSearch(target) {
    const rotationPoint = Math.floor(Math.random() * (myArray.length - 1)) + 1;
    
    // Create rotated array
    rotatedArray = [
        ...myArray.slice(rotationPoint),
        ...myArray.slice(0, rotationPoint)
    ];
    
    // Update the displayed array
    myArray = [...rotatedArray];
    renderArray();
    
    // Highlight the rotation
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'update');
        });
        
        // Start the rotated search after rotation animation
        setTimeout(() => {
            performRotatedSearch(target, 0, myArray.length - 1);
        }, 1000);
    }, 500);
    
    logOperation(`Array rotated at pivot point ${rotationPoint} for rotated search demonstration`, 'info');
}

// NEW: Perform Rotated Search with Visualization
function performRotatedSearch(target, left, right) {
    if (left > right) {
        // Element not found
        searchResults.innerHTML = `<p class="text-center mb-0">Element "${target}" not found in the rotated array</p>`;
        logOperation(`Rotated search for "${target}" - not found`, 'info');
        
        resetRotatedSearchState();
        return;
    }
    
    const mid = Math.floor((left + right) / 2);
    const steps = document.querySelectorAll('#rotatedSearchSteps .algorithm-step');
    
    // Reset all steps
    steps.forEach(step => step.classList.remove('active'));
    
    // Update current step
    steps[0].classList.add('active'); // Step 1: Find mid index
    
    // Highlight current search space
    highlightRotatedSearchSpace(left, right, mid);
    
    // Update search results
    searchResults.innerHTML = `
        <div class="rotated-search-explanation">
            <p class="mb-1"><strong>Searching in Rotated Sorted Array</strong></p>
            <p class="mb-1">Target: "${target}"</p>
            <p class="mb-1">Search space: indices ${left} to ${right}</p>
            <p class="mb-1">Mid index: ${mid}, Value: "${myArray[mid]}"</p>
            <p class="mb-0" id="rotatedSearchDetail">Calculating which half is sorted...</p>
        </div>
    `;
    
    setTimeout(() => {
        if (myArray[mid] === target) {
            // Element found
            steps[1].classList.add('active'); // Step 2: Check if mid equals target
            
            highlightRotatedSearchFound(mid);
            
            searchResults.innerHTML = `
                <div class="rotated-search-explanation">
                    <p class="mb-1"><strong>Element Found!</strong></p>
                    <p class="mb-1">Target: "${target}"</p>
                    <p class="mb-1">Found at index: ${mid}</p>
                    <p class="mb-1">Value: "${myArray[mid]}"</p>
                    <p class="mb-0">Algorithm: Binary Search in Rotated Sorted Array</p>
                </div>
            `;
            
            logOperation(`Rotated search found "${target}" at index ${mid}`, 'success');
            
            setTimeout(() => {
                resetRotatedSearchState();
            }, 3000);
            
        } else {
            // Continue search
            steps[2].classList.add('active'); // Step 3: Determine which half is sorted
            
            const detailElement = document.getElementById('rotatedSearchDetail');
            
            // Determine which half is sorted
            if (myArray[left] <= myArray[mid]) {
                // Left half is sorted
                detailElement.innerHTML = `Left half [${left}-${mid}] is sorted: [${myArray[left]}  ${myArray[mid]}]`;
                
                setTimeout(() => {
                    steps[3].classList.add('active'); // Step 4: Check if target in sorted half
                    
                    // Check if target is in left sorted half
                    if (myArray[left] <= target && target < myArray[mid]) {
                        detailElement.innerHTML = `Target "${target}" is in left sorted half [${left}-${mid-1}]`;
                        steps[4].classList.add('active'); // Step 5: Adjust boundaries
                        
                        setTimeout(() => {
                            performRotatedSearch(target, left, mid - 1);
                        }, 1500);
                    } else {
                        detailElement.innerHTML = `Target "${target}" is NOT in left sorted half, searching right half [${mid+1}-${right}]`;
                        steps[4].classList.add('active'); // Step 5: Adjust boundaries
                        
                        setTimeout(() => {
                            performRotatedSearch(target, mid + 1, right);
                        }, 1500);
                    }
                }, 1000);
            } else {
                // Right half is sorted
                detailElement.innerHTML = `Right half [${mid}-${right}] is sorted: [${myArray[mid]}  ${myArray[right]}]`;
                
                setTimeout(() => {
                    steps[3].classList.add('active'); // Step 4: Check if target in sorted half
                    
                    // Check if target is in right sorted half
                    if (myArray[mid] < target && target <= myArray[right]) {
                        detailElement.innerHTML = `Target "${target}" is in right sorted half [${mid+1}-${right}]`;
                        steps[4].classList.add('active'); // Step 5: Adjust boundaries
                        
                        setTimeout(() => {
                            performRotatedSearch(target, mid + 1, right);
                        }, 1500);
                    } else {
                        detailElement.innerHTML = `Target "${target}" is NOT in right sorted half, searching left half [${left}-${mid-1}]`;
                        steps[4].classList.add('active'); // Step 5: Adjust boundaries
                        
                        setTimeout(() => {
                            performRotatedSearch(target, left, mid - 1);
                        }, 1500);
                    }
                }, 1000);
            }
            
            steps[5].classList.add('active'); // Step 6: Repeat
        }
    }, 1000);
}

// NEW: Helper function to highlight rotated search space
function highlightRotatedSearchSpace(left, right, mid) {
    const elements = document.querySelectorAll('.array-element');
    
    // Reset all elements
    elements.forEach((el, index) => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove(
            'rotated-search-current', 
            'rotated-search-boundary', 
            'rotated-search-mid',
            'rotated-search-found',
            'rotated-sorted-half'
        );
        
        if (index >= left && index <= right) {
            // In current search space
            if (index === mid) {
                valueDiv.classList.add('rotated-search-mid');
            } else if (index === left || index === right) {
                valueDiv.classList.add('rotated-search-boundary');
            } else {
                valueDiv.classList.add('rotated-search-current');
            }
        }
    });
}

// NEW: Helper function to highlight found element
function highlightRotatedSearchFound(index) {
    const elements = document.querySelectorAll('.array-element');
    const valueDiv = elements[index].querySelector('.element-value');
    valueDiv.classList.remove('rotated-search-mid', 'rotated-search-boundary', 'rotated-search-current');
    valueDiv.classList.add('rotated-search-found');
}

// NEW: Reset rotated search state
function resetRotatedSearchState() {
    isRotatedSearchRunning = false;
    rotatedSearchBtn.disabled = false;
    rotatedSearchElement.value = '';
    
    // Reset to original array
    if (originalArrayForRotatedSearch.length > 0) {
        myArray = [...originalArrayForRotatedSearch];
        originalArrayForRotatedSearch = [];
        renderArray();
        updateStats();
    }
    
    // Reset all rotated search highlights
    const elements = document.querySelectorAll('.array-element');
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove(
            'rotated-search-current', 
            'rotated-search-boundary', 
            'rotated-search-mid',
            'rotated-search-found',
            'rotated-sorted-half'
        );
    });
}
// NEW: Show Progression Input Group
function showProgressionInput(type) {
    if (isProgressionOperation) {
        showNotification('A progression operation is already in progress', 'warning');
        return;
    }
    
    // Store original array
    originalArrayBeforeProgression = [...myArray];
    
    // Show appropriate input group
    if (type === 'ap') {
        apInputGroup.style.display = 'block';
        gpInputGroup.style.display = 'none';
        currentProgressionType = 'ap';
    } else {
        apInputGroup.style.display = 'none';
        gpInputGroup.style.display = 'block';
        currentProgressionType = 'gp';
    }
    
    cancelProgressionGroup.style.display = 'block';
    isProgressionOperation = true;
}
// NEW: Create Arithmetic Progression Handler
function handleCreateAP() {
    const firstTerm = parseFloat(apFirstTerm.value);
    const commonDiff = parseFloat(apCommonDiff.value);
    const numTerms = parseInt(apNumTerms.value);
    
    // Validation
    if (isNaN(firstTerm)) {
        showNotification('Please enter a valid first term', 'warning');
        apFirstTerm.focus();
        return;
    }
    
    if (isNaN(commonDiff)) {
        showNotification('Please enter a valid common difference', 'warning');
        apCommonDiff.focus();
        return;
    }
    
    if (isNaN(numTerms) || numTerms < 1 || numTerms > 50) {
        showNotification('Please enter a valid number of terms (1-50)', 'warning');
        apNumTerms.focus();
        return;
    }
    
    // Create AP array with animation
    createArithmeticProgression(firstTerm, commonDiff, numTerms);
}

// NEW: Create Geometric Progression Handler
function handleCreateGP() {
    const firstTerm = parseFloat(gpFirstTerm.value);
    const commonRatio = parseFloat(gpCommonRatio.value);
    const numTerms = parseInt(gpNumTerms.value);
    
    // Validation
    if (isNaN(firstTerm) || firstTerm < 1) {
        showNotification('Please enter a valid first term (1)', 'warning');
        gpFirstTerm.focus();
        return;
    }
    
    if (isNaN(commonRatio)) {
        showNotification('Please enter a valid common ratio', 'warning');
        gpCommonRatio.focus();
        return;
    }
    
    if (isNaN(numTerms) || numTerms < 1 || numTerms > 50) {
        showNotification('Please enter a valid number of terms (1-50)', 'warning');
        gpNumTerms.focus();
        return;
    }
    
    // Create GP array with animation
    createGeometricProgression(firstTerm, commonRatio, numTerms);
}

// NEW: Create Arithmetic Progression with Animation
function createArithmeticProgression(firstTerm, commonDiff, numTerms) {
    // Create dual visualization container
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Arithmetic Progression Creation</h5>
        
        <div class="progression-formula-display">
            <strong>Formula:</strong> a = a + (n-1)d<br>
            <strong>Where:</strong> a = ${firstTerm}, d = ${commonDiff}, n = ${numTerms}
        </div>
        
        <div class="array-group">
            <div class="array-label">Arithmetic Progression Generation</div>
            <div class="transformed-array-container" id="apArrayContainer"></div>
        </div>
        
        <div class="progression-explanation">
            <p class="mb-2" id="apExplanation">Starting AP generation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="apStepsContainer">
            <h6 class="text-center">AP Generation Steps</h6>
            <div class="steps-container" id="apSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterAP" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    const explanation = document.getElementById('apExplanation');
    const stepsContainer = document.getElementById('apSteps');
    const continueButton = document.getElementById('continueAfterAP');
    
    // Generate AP step by step
    const apArray = [];
    let currentTerm = 0;
    
    function generateNextTerm() {
        if (currentTerm >= numTerms) {
            // AP generation completed
            explanation.innerHTML = `<strong>AP Generation Complete!</strong> Created ${numTerms} terms: [${apArray.join(', ')}]`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Arithmetic Progression created successfully!
                </div>
            `;
            
            // Update the actual array
            myArray = [...apArray];
            updateStats();
            
            continueButton.style.display = 'block';
            
            // Auto-return to original after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterProgression();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterProgression);
            
            return;
        }
        
        // Calculate current term
        const termValue = firstTerm + (currentTerm * commonDiff);
        apArray.push(termValue.toString());
        
        // Update steps
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Term ${currentTerm + 1}:</strong> a = ${firstTerm} + (${currentTerm}  ${commonDiff}) = ${termValue}
            </div>
        `;
        
        // Update explanation
        explanation.innerHTML = `Generating term ${currentTerm + 1}: ${firstTerm} + (${currentTerm}  ${commonDiff}) = ${termValue}`;
        
        // Render current AP array
        renderArrayInContainer(apArray, 'apArrayContainer', true, 'ap');
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Highlight the newly added term
        const container = document.getElementById('apArrayContainer');
        const elements = container.querySelectorAll('.array-element');
        if (elements.length > 0) {
            const newElement = elements[elements.length - 1].querySelector('.element-value');
            newElement.classList.add('ap-term');
            
            // Remove highlight after animation
            setTimeout(() => {
                newElement.classList.remove('ap-term');
            }, 1500);
        }
        
        currentTerm++;
        
        // Generate next term after delay
        setTimeout(generateNextTerm, 2000);
    }
    
    // Start AP generation
    generateNextTerm();
    
    logOperation(`Created Arithmetic Progression: first term=${firstTerm}, common difference=${commonDiff}, terms=${numTerms}`, 'success');
}

// NEW: Create Geometric Progression with Animation
function createGeometricProgression(firstTerm, commonRatio, numTerms) {
    // Create dual visualization container
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Geometric Progression Creation</h5>
        
        <div class="progression-formula-display">
            <strong>Formula:</strong> a = a  r<br>
            <strong>Where:</strong> a = ${firstTerm}, r = ${commonRatio}, n = ${numTerms}
        </div>
        
        <div class="array-group">
            <div class="array-label">Geometric Progression Generation</div>
            <div class="transformed-array-container" id="gpArrayContainer"></div>
        </div>
        
        <div class="progression-explanation">
            <p class="mb-2" id="gpExplanation">Starting GP generation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="gpStepsContainer">
            <h6 class="text-center">GP Generation Steps</h6>
            <div class="steps-container" id="gpSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterGP" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    const explanation = document.getElementById('gpExplanation');
    const stepsContainer = document.getElementById('gpSteps');
    const continueButton = document.getElementById('continueAfterGP');
    
    // Generate GP step by step
    const gpArray = [];
    let currentTerm = 0;
    
    function generateNextTerm() {
        if (currentTerm >= numTerms) {
            // GP generation completed
            explanation.innerHTML = `<strong>GP Generation Complete!</strong> Created ${numTerms} terms: [${gpArray.join(', ')}]`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Geometric Progression created successfully!
                </div>
            `;
            
            // Update the actual array
            myArray = [...gpArray];
            updateStats();
            
            continueButton.style.display = 'block';
            
            // Auto-return to original after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterProgression();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterProgression);
            
            return;
        }
        
        // Calculate current term
        const termValue = firstTerm * Math.pow(commonRatio, currentTerm);
        gpArray.push(termValue.toString());
        
        // Update steps
        let stepExplanation = `Term ${currentTerm + 1}: `;
        if (currentTerm === 0) {
            stepExplanation += `${firstTerm} (first term)`;
        } else {
            stepExplanation += `${firstTerm}  ${commonRatio}${currentTerm > 1 ? `^${currentTerm}` : ''} = ${termValue}`;
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Term ${currentTerm + 1}:</strong> ${stepExplanation}
            </div>
        `;
        
        // Update explanation
        explanation.innerHTML = stepExplanation;
        
        // Render current GP array
        renderArrayInContainer(gpArray, 'gpArrayContainer', true, 'gp');
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Highlight the newly added term
        const container = document.getElementById('gpArrayContainer');
        const elements = container.querySelectorAll('.array-element');
        if (elements.length > 0) {
            const newElement = elements[elements.length - 1].querySelector('.element-value');
            newElement.classList.add('gp-term');
            
            // Remove highlight after animation
            setTimeout(() => {
                newElement.classList.remove('gp-term');
            }, 1500);
        }
        
        currentTerm++;
        
        // Generate next term after delay
        setTimeout(generateNextTerm, 2000);
    }
    
    // Start GP generation
    generateNextTerm();
    
    logOperation(`Created Geometric Progression: first term=${firstTerm}, common ratio=${commonRatio}, terms=${numTerms}`, 'success');
}

// NEW: Return to Original Array after Progression
function returnToOriginalAfterProgression() {
    if (originalArrayBeforeProgression.length === 0) {
        showNotification('No original array to return to', 'info');
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayBeforeProgression];
    originalArrayBeforeProgression = [];
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset progression state
    resetProgressionState();
    
    // Show original positions with animation
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation('Returned to original array after progression operation', 'info');
    showNotification('Returned to original array successfully', 'success');
}

// NEW: Cancel Progression Operation
function handleCancelProgression() {
    resetProgressionState();
    showNotification('Progression operation cancelled', 'info');
}

// NEW: Reset Progression State
function resetProgressionState() {
    // Hide input groups
    apInputGroup.style.display = 'none';
    gpInputGroup.style.display = 'none';
    cancelProgressionGroup.style.display = 'none';
    
    // Clear inputs
    apFirstTerm.value = '';
    apCommonDiff.value = '';
    apNumTerms.value = '';
    gpFirstTerm.value = '';
    gpCommonRatio.value = '';
    gpNumTerms.value = '';
    
    // Reset state
    isProgressionOperation = false;
    currentProgressionType = null;
    
    // If we're in the middle of a progression visualization, return to normal view
    if (originalArrayBeforeProgression.length > 0) {
        returnToOriginalAfterProgression();
    }
}
// NEW: Kth Element Operation Handler
function handleKthOperation(type) {
    if (isKthOperationRunning) {
        showNotification('A kth element operation is already in progress', 'warning');
        return;
    }
    
    const k = parseInt(kthElementInput.value);
    
    // Validation
    if (isNaN(k) || k < 1) {
        showNotification('Please enter a valid k value ( 1)', 'danger');
        kthElementInput.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (k > myArray.length) {
        searchResults.innerHTML = `
            <div class="alert alert-danger">
                <strong>Error:</strong> Please enter k between 1 and ${myArray.length} (array length)
            </div>
        `;
        showNotification(`k must be between 1 and ${myArray.length}`, 'danger');
        kthElementInput.focus();
        return;
    }
    
    isKthOperationRunning = true;
    kthOperationType = type;
    kthValue = k;
    
    // Store original array
    originalArrayForKth = [...myArray];
    
    // Disable buttons during operation
    kthSmallestBtn.disabled = true;
    kthLargestBtn.disabled = true;
    
    // Reset search results
    searchResults.innerHTML = '<p class="text-center mb-0">Starting kth element search...</p>';
    
    // Perform kth element operation
    if (type === 'smallest') {
        performKthSmallest();
    } else {
        performKthLargest();
    }
}

// NEW: Get Ordinal Suffix
function getOrdinalSuffix(k) {
    if (k % 10 === 1 && k % 100 !== 11) return 'st';
    if (k % 10 === 2 && k % 100 !== 12) return 'nd';
    if (k % 10 === 3 && k % 100 !== 13) return 'rd';
    return 'th';
}

// NEW: Perform Kth Smallest Operation
function performKthSmallest() {
    const k = kthValue;
    const ordinal = getOrdinalSuffix(k);
    
    // Check if array needs sorting
    if (!isArraySorted(myArray)) {
        showNotification('Array is not sorted. Auto-sorting for kth smallest...', 'warning');
        
        // Sort the array
        myArray.sort((a, b) => {
            const numA = parseFloat(a);
            const numB = parseFloat(b);
            if (!isNaN(numA) && !isNaN(numB)) {
                return numA - numB;
            }
            return a.toString().localeCompare(b.toString());
        });
        
        renderArray();
        
        // Highlight that array was sorted
        setTimeout(() => {
            myArray.forEach((_, index) => {
                highlightElement(index, 'update');
            });
            
            // Start kth smallest after sorting animation
            setTimeout(() => {
                findKthSmallestSorted();
            }, 1000);
        }, 500);
        
    } else {
        // Array is already sorted
        findKthSmallestSorted();
    }
}

// NEW: Find Kth Smallest in Sorted Array
function findKthSmallestSorted() {
    const k = kthValue;
    const ordinal = getOrdinalSuffix(k);
    
    // Create visualization container
    const container = document.createElement('div');
    container.className = 'kth-explanation';
    container.innerHTML = `
        <h5>Finding ${k}${ordinal} Smallest Element in Sorted Array</h5>
        <p class="mb-2">In a sorted array, the kth smallest element is simply the element at index k-1</p>
        <div class="algorithm-steps" id="kthSteps"></div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    const oldContent = mainContainer.innerHTML;
    mainContainer.innerHTML = '';
    mainContainer.appendChild(container);
    
    // Show the array visualization
    const arrayVis = document.createElement('div');
    arrayVis.className = 'array-container';
    arrayVis.id = 'kthArrayVisualization';
    mainContainer.appendChild(arrayVis);
    
    renderArrayInContainer(myArray, 'kthArrayVisualization');
    
    const stepsContainer = document.getElementById('kthSteps');
    
    // Step 1: Explain the approach
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Step 1:</strong> Array is sorted in ascending order
        </div>
        <div class="algorithm-step">
            <strong>Step 2:</strong> In sorted array, kth smallest element = element at position (k-1)
        </div>
        <div class="algorithm-step">
            <strong>Step 3:</strong> Finding element at index ${k-1}
        </div>
    `;
    
    // Highlight the kth smallest element
    setTimeout(() => {
        const elements = document.querySelectorAll('#kthArrayVisualization .array-element');
        const targetIndex = k - 1;
        
        // Highlight all elements up to the target
        for (let i = 0; i <= targetIndex; i++) {
            setTimeout(() => {
                const valueDiv = elements[i].querySelector('.element-value');
                
                if (i === targetIndex) {
                    valueDiv.classList.add('kth-target');
                    
                    // Final step
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 4:</strong> Found! ${k}${ordinal} smallest element = "${myArray[targetIndex]}" at index ${targetIndex}
                        </div>
                    `;
                    
                    // Display result
                    searchResults.innerHTML = `
                        <div class="alert alert-success">
                            <strong>Success!</strong> ${k}${ordinal} smallest element is <strong>"${myArray[targetIndex]}"</strong> at index ${targetIndex}
                        </div>
                    `;
                    
                    logOperation(`Found ${k}${ordinal} smallest element: "${myArray[targetIndex]}"`, 'success');
                    
                    // Auto-return after delay
                    setTimeout(() => {
                        returnToOriginalAfterKthOperation();
                    }, 4000);
                    
                } else {
                    valueDiv.classList.add('kth-compared');
                }
            }, i * 800);
        }
    }, 1500);
}

// NEW: Perform Kth Largest Operation
function performKthLargest() {
    const k = kthValue;
    const ordinal = getOrdinalSuffix(k);
    
    // Create visualization container
    const container = document.createElement('div');
    container.className = 'kth-explanation';
    container.innerHTML = `
        <h5>Finding ${k}${ordinal} Largest Element in Unsorted Array</h5>
        <p class="mb-2">Using selection algorithm to find kth largest without fully sorting the array</p>
        <div class="algorithm-steps" id="kthSteps"></div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    const oldContent = mainContainer.innerHTML;
    mainContainer.innerHTML = '';
    mainContainer.appendChild(container);
    
    // Show the array visualization
    const arrayVis = document.createElement('div');
    arrayVis.className = 'array-container';
    arrayVis.id = 'kthArrayVisualization';
    mainContainer.appendChild(arrayVis);
    
    renderArrayInContainer(myArray, 'kthArrayVisualization');
    
    // Perform kth largest using selection algorithm
    findKthLargestSelection();
}

// NEW: Find Kth Largest using Selection Algorithm
function findKthLargestSelection() {
    const k = kthValue;
    const ordinal = getOrdinalSuffix(k);
    const stepsContainer = document.getElementById('kthSteps');
    const arrayCopy = [...myArray];
    
    // Convert to numbers if possible
    const isNumeric = !arrayCopy.some(item => isNaN(parseFloat(item)));
    
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Step 1:</strong> kth largest = (n-k+1)th smallest element
        </div>
        <div class="algorithm-step">
            <strong>Step 2:</strong> Using selection algorithm to find element
        </div>
    `;
    
    // Implementation of quickselect algorithm
    performQuickSelect(arrayCopy, 0, arrayCopy.length - 1, arrayCopy.length - k, 0);
}

// NEW: QuickSelect Algorithm with Visualization
function performQuickSelect(arr, left, right, k, depth) {
    const stepsContainer = document.getElementById('kthSteps');
    const currentK = kthValue;
    const ordinal = getOrdinalSuffix(currentK);
    
    if (left === right) {
        // Base case: found the kth largest
        const resultIndex = findOriginalIndex(arr[left]);
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${depth + 3}:</strong> Found! ${currentK}${ordinal} largest element = "${arr[left]}"
            </div>
        `;
        
        // Highlight the result
        setTimeout(() => {
            const elements = document.querySelectorAll('#kthArrayVisualization .array-element');
            const valueDiv = elements[resultIndex].querySelector('.element-value');
            valueDiv.classList.add('kth-target');
            
            // Display result
            searchResults.innerHTML = `
                <div class="alert alert-success">
                    <strong>Success!</strong> ${currentK}${ordinal} largest element is <strong>"${arr[left]}"</strong>
                </div>
            `;
            
            logOperation(`Found ${currentK}${ordinal} largest element: "${arr[left]}"`, 'success');
            
            // Auto-return after delay
            setTimeout(() => {
                returnToOriginalAfterKthOperation();
            }, 4000);
        }, 1000);
        
        return;
    }
    
    // Choose random pivot
    const pivotIndex = Math.floor(Math.random() * (right - left + 1)) + left;
    const pivotValue = arr[pivotIndex];
    const pivotOriginalIndex = findOriginalIndex(pivotValue);
    
    // Highlight pivot
    setTimeout(() => {
        const elements = document.querySelectorAll('#kthArrayVisualization .array-element');
        const pivotDiv = elements[pivotOriginalIndex].querySelector('.element-value');
        pivotDiv.classList.add('kth-partition');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${depth + 3}:</strong> Selected pivot = "${pivotValue}" at index ${pivotOriginalIndex}
            </div>
        `;
        
        // Partition the array
        setTimeout(() => {
            const partitionIndex = partition(arr, left, right, pivotIndex, depth);
            pivotDiv.classList.remove('kth-partition');
            
            if (k === partitionIndex) {
                // Found the kth element
                const resultIndex = findOriginalIndex(arr[k]);
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${depth + 4}:</strong> Partition index equals k - element found!
                    </div>
                `;
                
                // Highlight the result
                const resultDiv = elements[resultIndex].querySelector('.element-value');
                resultDiv.classList.add('kth-target');
                
                // Display result
                searchResults.innerHTML = `
                    <div class="alert alert-success">
                        <strong>Success!</strong> ${currentK}${ordinal} largest element is <strong>"${arr[k]}"</strong>
                    </div>
                `;
                
                logOperation(`Found ${currentK}${ordinal} largest element: "${arr[k]}"`, 'success');
                
                // Auto-return after delay
                setTimeout(() => {
                    returnToOriginalAfterKthOperation();
                }, 4000);
                
            } else if (k < partitionIndex) {
                // Search left side
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${depth + 4}:</strong> k < partition index, searching left subarray
                    </div>
                `;
                
                performQuickSelect(arr, left, partitionIndex - 1, k, depth + 1);
            } else {
                // Search right side
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${depth + 4}:</strong> k > partition index, searching right subarray
                    </div>
                `;
                
                performQuickSelect(arr, partitionIndex + 1, right, k, depth + 1);
            }
        }, 1500);
    }, 1000);
}

// NEW: Partition Function for QuickSelect
function partition(arr, left, right, pivotIndex, depth) {
    const pivotValue = arr[pivotIndex];
    const stepsContainer = document.getElementById('kthSteps');
    
    // Move pivot to end
    [arr[pivotIndex], arr[right]] = [arr[right], arr[pivotIndex]];
    
    let storeIndex = left;
    
    stepsContainer.innerHTML += `
        <div class="algorithm-step">
            <strong>Partition ${depth + 1}:</strong> Moving elements  "${pivotValue}" to left
        </div>
    `;
    
    for (let i = left; i < right; i++) {
        const shouldSwap = parseFloat(arr[i]) <= parseFloat(pivotValue);
        
        if (shouldSwap) {
            [arr[storeIndex], arr[i]] = [arr[i], arr[storeIndex]];
            storeIndex++;
        }
    }
    
    // Move pivot to its final place
    [arr[storeIndex], arr[right]] = [arr[right], arr[storeIndex]];
    
    return storeIndex;
}

// NEW: Find Original Index of Element
function findOriginalIndex(value) {
    for (let i = 0; i < originalArrayForKth.length; i++) {
        if (originalArrayForKth[i] === value) {
            return i;
        }
    }
    return -1;
}

// NEW: Return to Original after Kth Operation
function returnToOriginalAfterKthOperation() {
    // Reset to original array
    myArray = [...originalArrayForKth];
    originalArrayForKth = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isKthOperationRunning = false;
    kthOperationType = null;
    kthSmallestBtn.disabled = false;
    kthLargestBtn.disabled = false;
    kthElementInput.value = '';
    
    // Show completion message
    showNotification('Returned to original array after kth element operation', 'success');
}
// NEW: Selection Sort Handler
function handleSelectionSort() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - already sorted', 'info');
        return;
    }
    
    if (isSelectionSortRunning) {
        showNotification('A selection sort operation is already in progress', 'warning');
        return;
    }
    
    isSelectionSortRunning = true;
    selectionSortBtn.disabled = true;
    
    // Store original array
    originalArrayForSelectionSort = [...myArray];
    
    // Show selection sort visualization
    showSelectionSortVisualization();
}

// NEW: Insertion Sort Handler
function handleInsertionSort() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - already sorted', 'info');
        return;
    }
    
    if (isInsertionSortRunning) {
        showNotification('An insertion sort operation is already in progress', 'warning');
        return;
    }
    
    isInsertionSortRunning = true;
    insertionSortBtn.disabled = true;
    
    // Store original array
    originalArrayForInsertionSort = [...myArray];
    
    // Show insertion sort visualization
    showInsertionSortVisualization();
}

// NEW: Show Selection Sort Visualization
function showSelectionSortVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Selection Sort Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalSelectionArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Selection Sort Progress</div>
            <div class="transformed-array-container" id="transformedSelectionArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Selection Sort:</strong> Repeatedly find the minimum element and place it at the beginning</p>
            <p class="mb-0" id="selectionSortExplanation">Starting selection sort animation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="selectionSortStepsContainer">
            <h6 class="text-center">Selection Sort Steps</h6>
            <div class="steps-container" id="selectionSortSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSelectionSort" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSelectionSort, 'originalSelectionArray');
    renderArrayInContainer([...originalArrayForSelectionSort], 'transformedSelectionArray');
    
    performSelectionSortAnimation();
}

// NEW: Show Insertion Sort Visualization
function showInsertionSortVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Insertion Sort Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalInsertionArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Insertion Sort Progress</div>
            <div class="transformed-array-container" id="transformedInsertionArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Insertion Sort:</strong> Build the sorted array one element at a time by inserting each element in its correct position</p>
            <p class="mb-0" id="insertionSortExplanation">Starting insertion sort animation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="insertionSortStepsContainer">
            <h6 class="text-center">Insertion Sort Steps</h6>
            <div class="steps-container" id="insertionSortSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterInsertionSort" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForInsertionSort, 'originalInsertionArray');
    renderArrayInContainer([...originalArrayForInsertionSort], 'transformedInsertionArray');
    
    performInsertionSortAnimation();
}

// NEW: Perform Selection Sort Animation
function performSelectionSortAnimation() {
    const originalContainer = document.getElementById('originalSelectionArray');
    const transformedContainer = document.getElementById('transformedSelectionArray');
    const explanation = document.getElementById('selectionSortExplanation');
    const stepsContainer = document.getElementById('selectionSortSteps');
    const continueButton = document.getElementById('continueAfterSelectionSort');
    
    const array = [...originalArrayForSelectionSort];
    const n = array.length;
    let sortedArray = [...array];
    let currentPass = 0;
    let currentComparison = 0;
    let minIndex = 0;
    let totalSwaps = 0;
    
    // Convert array to numbers for comparison if possible
    const isNumeric = !array.some(item => isNaN(parseFloat(item)));
    
    function performSelectionSortStep() {
        if (currentPass >= n - 1) {
            // Sorting completed
            explanation.innerHTML = `<strong>Selection Sort Completed!</strong> Array sorted in ${n-1} passes with ${totalSwaps} swaps`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Selection sort completed! The array is now fully sorted.
                </div>
            `;
            
            // Highlight all elements as sorted
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                const valueDiv = el.querySelector('.element-value');
                setTimeout(() => {
                    valueDiv.classList.add('selection-sorted');
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return to original after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterSelectionSort();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSelectionSort);
            
            return;
        }
        
        if (currentComparison === 0) {
            // Start of a new pass
            minIndex = currentPass;
            explanation.innerHTML = `Pass ${currentPass + 1}: Finding minimum element in unsorted portion (indices ${currentPass} to ${n-1})`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Pass ${currentPass + 1}:</strong> Finding minimum element in unsorted portion
                </div>
            `;
            
            // Highlight current pass boundary
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            for (let i = 0; i < n; i++) {
                const valueDiv = transformedElements[i].querySelector('.element-value');
                valueDiv.classList.remove('selection-current', 'selection-min', 'selection-compared', 'selection-swap');
                
                if (i < currentPass) {
                    valueDiv.classList.add('selection-sorted');
                } else if (i === currentPass) {
                    valueDiv.classList.add('selection-current');
                }
            }
            
            currentComparison = currentPass + 1;
            performSelectionSortStep();
            return;
        }
        
        if (currentComparison >= n) {
            // Found minimum element for this pass
            explanation.innerHTML = `Pass ${currentPass + 1}: Minimum element found at index ${minIndex} (value: ${sortedArray[minIndex]})`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Pass ${currentPass + 1}:</strong> Minimum element found at index ${minIndex} (${sortedArray[minIndex]})
                </div>
            `;
            
            // Highlight the minimum element
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const minElement = transformedElements[minIndex].querySelector('.element-value');
            minElement.classList.remove('selection-compared');
            minElement.classList.add('selection-min');
            
            // Check if swap is needed
            if (minIndex !== currentPass) {
                explanation.innerHTML = `Pass ${currentPass + 1}: Swapping elements at indices ${currentPass} and ${minIndex}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Pass ${currentPass + 1}:</strong> Swapping ${sortedArray[currentPass]} (index ${currentPass}) with ${sortedArray[minIndex]} (index ${minIndex})
                    </div>
                `;
                
                // Animate the swap
                const currentElement = transformedElements[currentPass].querySelector('.element-value');
                minElement.classList.add('selection-swap');
                currentElement.classList.add('selection-swap');
                
                setTimeout(() => {
                    // Perform the swap
                    [sortedArray[currentPass], sortedArray[minIndex]] = [sortedArray[minIndex], sortedArray[currentPass]];
                    totalSwaps++;
                    
                    // Update the display
                    renderArrayInContainer(sortedArray, 'transformedSelectionArray');
                    
                    // Highlight the swapped elements
                    const newTransformedElements = transformedContainer.querySelectorAll('.array-element');
                    newTransformedElements[currentPass].querySelector('.element-value').classList.add('selection-sorted');
                    
                    currentPass++;
                    currentComparison = 0;
                    performSelectionSortStep();
                }, 1500);
            } else {
                // No swap needed
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Pass ${currentPass + 1}:</strong> Minimum element already at correct position, no swap needed
                    </div>
                `;
                
                const transformedElements = transformedContainer.querySelectorAll('.array-element');
                transformedElements[currentPass].querySelector('.element-value').classList.add('selection-sorted');
                
                currentPass++;
                currentComparison = 0;
                setTimeout(performSelectionSortStep, 1000);
            }
            
            return;
        }
        
        // Compare current element with minimum
        explanation.innerHTML = `Pass ${currentPass + 1}: Comparing element at index ${currentComparison} (${sortedArray[currentComparison]}) with current minimum at index ${minIndex} (${sortedArray[minIndex]})`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Pass ${currentPass + 1}:</strong> Comparing [${currentComparison}]="${sortedArray[currentComparison]}" with current minimum [${minIndex}]="${sortedArray[minIndex]}"
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Highlight elements being compared
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        const currentElement = transformedElements[currentComparison].querySelector('.element-value');
        const minElement = transformedElements[minIndex].querySelector('.element-value');
        
        currentElement.classList.add('selection-compared');
        minElement.classList.add('selection-min');
        
        // Compare values
        let isNewMin = false;
        if (isNumeric) {
            isNewMin = parseFloat(sortedArray[currentComparison]) < parseFloat(sortedArray[minIndex]);
        } else {
            isNewMin = sortedArray[currentComparison] < sortedArray[minIndex];
        }
        
        if (isNewMin) {
            explanation.innerHTML = `Pass ${currentPass + 1}: New minimum found at index ${currentComparison} (${sortedArray[currentComparison]})`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Pass ${currentPass + 1}:</strong> New minimum found! Updating minimum index to ${currentComparison}
                </div>
            `;
            
            minIndex = currentComparison;
        }
        
        setTimeout(() => {
            // Remove comparison highlights
            currentElement.classList.remove('selection-compared');
            minElement.classList.remove('selection-min');
            
            currentComparison++;
            performSelectionSortStep();
        }, 1500);
    }
    
    // Start selection sort process
    performSelectionSortStep();
}
// NEW: Insertion Sort Handler
function handleInsertionSort() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - already sorted', 'info');
        return;
    }
    
    if (isInsertionSortRunning) {
        showNotification('An insertion sort operation is already in progress', 'warning');
        return;
    }
    
    isInsertionSortRunning = true;
    insertionSortBtn.disabled = true;
    
    // Store original array
    originalArrayForInsertionSort = [...myArray];
    
    // Show insertion sort visualization
    showInsertionSortVisualization();
}

// NEW: Show Insertion Sort Visualization
function showInsertionSortVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Insertion Sort Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalInsertionArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Insertion Sort Progress</div>
            <div class="transformed-array-container" id="transformedInsertionArray"></div>
        </div>
        
        <div class="sorting-explanation">
            <p class="mb-2"><strong>Insertion Sort:</strong> Builds the sorted array one element at a time</p>
            <p class="mb-0" id="insertionSortExplanation">Starting insertion sort...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="insertionSortStepsContainer">
            <h6 class="text-center">Insertion Sort Steps</h6>
            <div class="steps-container" id="insertionSortSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterInsertionSort" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForInsertionSort, 'originalInsertionArray');
    renderArrayInContainer([...originalArrayForInsertionSort], 'transformedInsertionArray');
    
    performInsertionSortAnimation();
}

// NEW: Perform Insertion Sort Animation
function performInsertionSortAnimation() {
    const originalContainer = document.getElementById('originalInsertionArray');
    const transformedContainer = document.getElementById('transformedInsertionArray');
    const explanation = document.getElementById('insertionSortExplanation');
    const stepsContainer = document.getElementById('insertionSortSteps');
    const continueButton = document.getElementById('continueAfterInsertionSort');
    
    const array = [...originalArrayForInsertionSort];
    const n = array.length;
    let currentIndex = 1; // Start from second element
    
    function performInsertionStep() {
        if (currentIndex >= n) {
            // Sorting completed
            explanation.innerHTML = `<strong>Insertion Sort Completed!</strong> Array is now fully sorted.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Insertion sort completed! Array is now sorted.
                </div>
            `;
            
            // Highlight all elements as sorted
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                const valueDiv = el.querySelector('.element-value');
                setTimeout(() => {
                    valueDiv.classList.add('insertion-sorted');
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return to original after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterInsertionSort();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterInsertionSort);
            
            return;
        }
        
        const key = array[currentIndex];
        let j = currentIndex - 1;
        
        explanation.innerHTML = `Processing element at index ${currentIndex}: "${key}"`;
        
        // Highlight current key element
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        const keyElement = transformedElements[currentIndex].querySelector('.element-value');
        keyElement.classList.add('insertion-key');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex}:</strong> Processing element [${currentIndex}] = "${key}"
            </div>
        `;
        
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Start shifting elements
        performShiftStep(currentIndex, j, key);
    }
    
    function performShiftStep(currentIdx, compareIdx, keyValue) {
        if (compareIdx < 0) {
            // Found the position to insert
            array[compareIdx + 1] = keyValue;
            updateTransformedArray();
            
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const insertedElement = transformedElements[compareIdx + 1].querySelector('.element-value');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Insert:</strong> Inserting "${keyValue}" at position ${compareIdx + 1}
                </div>
            `;
            
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            insertedElement.classList.add('insertion-sorted');
            
            currentIndex++;
            setTimeout(performInsertionStep, 1000);
            return;
        }
        
        const compareValue = array[compareIdx];
        const shouldShift = parseFloat(compareValue) > parseFloat(keyValue);
        
        if (shouldShift) {
            // Shift element to the right
            explanation.innerHTML = `Shifting element "${compareValue}" from index ${compareIdx} to ${compareIdx + 1}`;
            
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const shiftElement = transformedElements[compareIdx].querySelector('.element-value');
            shiftElement.classList.add('insertion-shift');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Shift:</strong> "${compareValue}" > "${keyValue}", shifting right
                </div>
            `;
            
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            setTimeout(() => {
                array[compareIdx + 1] = array[compareIdx];
                updateTransformedArray();
                
                shiftElement.classList.remove('insertion-shift');
                
                performShiftStep(currentIdx, compareIdx - 1, keyValue);
            }, 1000);
        } else {
            // Found the position to insert
            array[compareIdx + 1] = keyValue;
            updateTransformedArray();
            
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const insertedElement = transformedElements[compareIdx + 1].querySelector('.element-value');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Insert:</strong> "${compareValue}"  "${keyValue}", inserting at position ${compareIdx + 1}
                </div>
            `;
            
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            insertedElement.classList.add('insertion-sorted');
            
            currentIndex++;
            setTimeout(performInsertionStep, 1000);
        }
    }
    
    function updateTransformedArray() {
        renderArrayInContainer([...array], 'transformedInsertionArray');
    }
    
    function returnToOriginalAfterInsertionSort() {
        // Reset to original array
        myArray = [...originalArrayForInsertionSort];
        originalArrayForInsertionSort = [];
        isInsertionSortRunning = false;
        insertionSortBtn.disabled = false;
        
        // Return to normal view
        const mainContainer = document.getElementById('arrayContainer');
        mainContainer.innerHTML = '';
        renderArray();
        updateStats();
        
        logOperation('Insertion sort completed - returned to original array', 'info');
        showNotification('Returned to original array after insertion sort', 'success');
    }
    
    // Start the insertion sort
    performInsertionStep();
}

// NEW: Return to Original after Selection Sort
function returnToOriginalAfterSelectionSort() {
    // Reset to original array
    myArray = [...originalArrayForSelectionSort];
    originalArrayForSelectionSort = [];
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isSelectionSortRunning = false;
    selectionSortBtn.disabled = false;
    
    logOperation('Selection sort demonstration completed - returned to original array', 'info');
    showNotification('Returned to original array after selection sort demonstration', 'success');
}

// NEW: Return to Original after Insertion Sort
function returnToOriginalAfterInsertionSort() {
    // Reset to original array
    myArray = [...originalArrayForInsertionSort];
    originalArrayForInsertionSort = [];
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isInsertionSortRunning = false;
    insertionSortBtn.disabled = false;
    
    logOperation('Insertion sort demonstration completed - returned to original array', 'info');
    showNotification('Returned to original array after insertion sort demonstration', 'success');
}
// NEW: Handle Cyclic Shift Operation
function handleCyclicShiftOperation(direction) {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - cannot perform cyclic shift', 'info');
        return;
    }
    
    if (isCyclicShiftRunning) {
        showNotification('A cyclic shift operation is already in progress', 'warning');
        return;
    }
    
    currentCyclicShiftType = direction;
    cyclicShiftInputGroup.style.display = 'flex';
    
    // Update button text based on direction
    const directionText = direction === 'left' ? 'Left' : 'Right';
    confirmCyclicShiftBtn.innerHTML = `<i class="fas fa-play me-2"></i>Apply Cyclic Shift ${directionText}`;
    
    // Set placeholder with array length info
    cyclicShiftPositionsInput.placeholder = `Enter positions (1 to ${myArray.length})`;
    cyclicShiftPositionsInput.max = myArray.length;
    
    cyclicShiftPositionsInput.focus();
}

// NEW: Confirm Cyclic Shift
function handleConfirmCyclicShift() {
    const positions = parseInt(cyclicShiftPositionsInput.value);
    
    if (isNaN(positions) || positions < 1 || positions > myArray.length) {
        // Show error message in red color
        searchResults.innerHTML = `
            <div class="alert alert-danger mb-0">
                <strong>Error:</strong> Please enter positions between 1 and ${myArray.length}
            </div>
        `;
        showNotification(`Please enter positions between 1 and ${myArray.length}`, 'danger');
        cyclicShiftPositionsInput.focus();
        return;
    }
    
    cyclicShiftPositions = positions;
    
    // Store original array
    originalArrayForCyclicShift = [...myArray];
    
    // Hide input group
    cyclicShiftInputGroup.style.display = 'none';
    cyclicShiftPositionsInput.value = '';
    
    // Start cyclic shift animation
    performCyclicShiftAnimation();
}

// NEW: Cancel Cyclic Shift
function handleCancelCyclicShift() {
    cyclicShiftInputGroup.style.display = 'none';
    cyclicShiftPositionsInput.value = '';
    currentCyclicShiftType = null;
    cyclicShiftPositions = 0;
    
    showNotification('Cyclic shift operation cancelled', 'info');
}

// NEW: Perform Cyclic Shift Animation
function performCyclicShiftAnimation() {
    if (isCyclicShiftRunning) return;
    
    isCyclicShiftRunning = true;
    cyclicShiftLeftBtn.disabled = true;
    cyclicShiftRightBtn.disabled = true;
    
    const directionText = currentCyclicShiftType === 'left' ? 'Left' : 'Right';
    
    // Create dual visualization
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Cyclic Shift ${directionText} by ${cyclicShiftPositions} Positions</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalCyclicArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After Cyclic Shift ${directionText}</div>
            <div class="transformed-array-container" id="transformedCyclicArray"></div>
        </div>
        
        <div class="cyclic-shift-explanation">
            <p class="mb-2"><strong>Cyclic Shift ${directionText}:</strong> Elements wrap around when they reach the end of the array</p>
            <p class="mb-0" id="cyclicShiftExplanation">Preparing cyclic shift animation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="cyclicShiftStepsContainer">
            <h6 class="text-center">Cyclic Shift Steps</h6>
            <div class="steps-container" id="cyclicShiftSteps"></div>
        </div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Render both arrays
    renderArrayInContainer(originalArrayForCyclicShift, 'originalCyclicArray');
    renderArrayInContainer([...originalArrayForCyclicShift], 'transformedCyclicArray');
    
    // Start the step-by-step animation
    performStepByStepCyclicShift();
}

// NEW: Perform Step-by-Step Cyclic Shift
function performStepByStepCyclicShift() {
    const originalContainer = document.getElementById('originalCyclicArray');
    const transformedContainer = document.getElementById('transformedCyclicArray');
    const explanation = document.getElementById('cyclicShiftExplanation');
    const stepsContainer = document.getElementById('cyclicShiftSteps');
    
    const n = myArray.length;
    const k = cyclicShiftPositions;
    const direction = currentCyclicShiftType;
    
    // Calculate the shifted array
    let shiftedArray;
    if (direction === 'left') {
        shiftedArray = [...originalArrayForCyclicShift.slice(k), ...originalArrayForCyclicShift.slice(0, k)];
    } else {
        shiftedArray = [...originalArrayForCyclicShift.slice(n - k), ...originalArrayForCyclicShift.slice(0, n - k)];
    }
    
    explanation.innerHTML = `<strong>Cyclic Shift ${direction === 'left' ? 'Left' : 'Right'}:</strong> Moving ${k} position(s) ${direction === 'left' ? 'left' : 'right'} with wrap-around`;
    
    // Show the algorithm explanation
    stepsContainer.innerHTML = `
        <div class="algorithm-step active">
            <strong>Algorithm:</strong> 
            ${direction === 'left' ? 
                `shiftedArray = array[${k}:] + array[:${k}]` : 
                `shiftedArray = array[${n-k}:] + array[:${n-k}]`
            }
        </div>
        <div class="algorithm-step">
            <strong>Step 1:</strong> Identify elements that will move ${direction === 'left' ? 'left' : 'right'} by ${k} positions
        </div>
        <div class="algorithm-step">
            <strong>Step 2:</strong> Elements reaching the ${direction === 'left' ? 'beginning' : 'end'} wrap around to the ${direction === 'left' ? 'end' : 'beginning'}
        </div>
        <div class="algorithm-step">
            <strong>Step 3:</strong> Update array with new positions
        </div>
    `;
    
    let currentStep = 0;
    
    function performNextStep() {
        if (currentStep >= n) {
            // Animation completed
            explanation.innerHTML = `<strong>Cyclic Shift ${direction === 'left' ? 'Left' : 'Right'} Completed!</strong> All ${n} elements shifted by ${k} positions`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Cyclic shift completed! Array will automatically return to original in 5 seconds.
                </div>
            `;
            
            // Update the actual array
            myArray = [...shiftedArray];
            
            // Auto-return to original after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterCyclicShift();
            }, 5000);
            
            return;
        }
        
        const originalIndex = currentStep;
        let newIndex;
        
        if (direction === 'left') {
            newIndex = (originalIndex - k + n) % n;
        } else {
            newIndex = (originalIndex + k) % n;
        }
        
        // Highlight the moving element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        
        const originalElement = originalElements[originalIndex];
        const transformedElement = transformedElements[newIndex];
        
        const originalValueDiv = originalElement.querySelector('.element-value');
        const transformedValueDiv = transformedElement.querySelector('.element-value');
        
        // Show movement with animation
        originalValueDiv.classList.add('cyclic-shift-moving');
        transformedValueDiv.classList.add('cyclic-shift-new-position');
        
        // Update step explanation
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Move ${currentStep + 1}:</strong> Element "${originalArrayForCyclicShift[originalIndex]}" at [${originalIndex}] 
                 [${newIndex}] ${direction === 'left' ? '(left shift)' : '(right shift)'}
            </div>
        `;
        
        // Scroll to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Update transformed array display
        transformedValueDiv.textContent = originalArrayForCyclicShift[originalIndex];
        
        setTimeout(() => {
            // Remove highlights
            originalValueDiv.classList.remove('cyclic-shift-moving');
            transformedValueDiv.classList.remove('cyclic-shift-new-position');
            transformedValueDiv.classList.add('cyclic-shift-original');
            
            currentStep++;
            performNextStep();
        }, 1000);
    }
    
    // Start the animation
    performNextStep();
}

// NEW: Return to Original Array after Cyclic Shift
function returnToOriginalAfterCyclicShift() {
    if (originalArrayForCyclicShift.length === 0) {
        showNotification('No original array to return to', 'info');
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayForCyclicShift];
    originalArrayForCyclicShift = [];
    
    // Reset the main array display
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset operation state
    isCyclicShiftRunning = false;
    cyclicShiftLeftBtn.disabled = false;
    cyclicShiftRightBtn.disabled = false;
    currentCyclicShiftType = null;
    cyclicShiftPositions = 0;
    
    // Show completion message
    searchResults.innerHTML = `
        <div class="alert alert-success mb-0">
            <strong>Success:</strong> Cyclic shift operation completed and array automatically returned to original state
        </div>
    `;
    
    logOperation(`Cyclic shift ${currentCyclicShiftType} by ${cyclicShiftPositions} positions completed and reset`, 'success');
    showNotification('Array returned to original state after cyclic shift', 'success');
    
    // Highlight all elements to show reset
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
}
// NEW: In-place Negation Handler
function handleInPlaceNegation() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isNegationRunning) {
        showNotification('A negation operation is already in progress', 'warning');
        return;
    }
    
    // Check if all elements are numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('In-place negation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isNegationRunning = true;
    inPlaceNegationBtn.disabled = true;
    
    // Store original array
    originalArrayForNegation = [...myArray];
    
    // Show negation visualization
    showNegationVisualization();
}

// NEW: Show Negation Visualization
function showNegationVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">In-place Negation Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalNegationArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After In-place Negation</div>
            <div class="transformed-array-container" id="transformedNegationArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>In-place Negation:</strong> Negates every element of a mutable numeric sequence</p>
            <p class="mb-0" id="negationExplanation">Starting in-place negation operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="negationStepsContainer">
            <h6 class="text-center">Negation Operation Steps</h6>
            <div class="steps-container" id="negationSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterNegation" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForNegation, 'originalNegationArray');
    renderArrayInContainer([...originalArrayForNegation], 'transformedNegationArray');
    
    performNegationAnimation();
}

// NEW: Perform Negation Animation
function performNegationAnimation() {
    const originalContainer = document.getElementById('originalNegationArray');
    const transformedContainer = document.getElementById('transformedNegationArray');
    const explanation = document.getElementById('negationExplanation');
    const stepsContainer = document.getElementById('negationSteps');
    const continueButton = document.getElementById('continueAfterNegation');
    
    const array = [...originalArrayForNegation];
    const n = array.length;
    let currentIndex = 0;
    
    function performNegationStep() {
        if (currentIndex >= n) {
            // Negation completed
            explanation.innerHTML = `<strong>In-place Negation Completed!</strong> All elements have been negated.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${currentIndex + 1}:</strong> In-place negation completed! All ${n} elements have been negated.
                </div>
            `;
            
            // Update the actual array
            myArray = array.map(val => (-parseFloat(val)).toString());
            
            // Show continue button
            continueButton.style.display = 'block';
            
            // Auto-return to original after 5 seconds
            const autoReturnTimer = setTimeout(() => {
                returnToOriginalAfterNegation();
            }, 5000);
            
            // Manual click handler
            continueButton.addEventListener('click', () => {
                clearTimeout(autoReturnTimer);
                returnToOriginalAfterNegation();
            });
            
            return;
        }
        
        // Highlight current element in original array
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const originalValueDiv = originalElements[currentIndex].querySelector('.element-value');
        originalValueDiv.classList.add('negation-current');
        
        // Get current value
        const currentValue = parseFloat(array[currentIndex]);
        const negatedValue = -currentValue;
        
        // Update step explanation
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex + 1}:</strong> 
                Negating element at index [${currentIndex}]<br>
                Original: ${currentValue}  Negated: ${negatedValue}<br>
                Operation: ${currentValue}  (-1) = ${negatedValue}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Update explanation
        explanation.innerHTML = `Negating element at index ${currentIndex}: ${currentValue}  ${negatedValue}`;
        
        // After a delay, update the transformed array
        setTimeout(() => {
            // Update transformed array element
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const transformedValueDiv = transformedElements[currentIndex].querySelector('.element-value');
            transformedValueDiv.textContent = negatedValue;
            transformedValueDiv.classList.add('negation-highlight', 'transform-animation');
            
            // Remove highlight from original element
            originalValueDiv.classList.remove('negation-current');
            
            // Move to next step
            currentIndex++;
            performNegationStep();
        }, 1500);
    }
    
    // Start the step-by-step negation
    performNegationStep();
}

// NEW: Return to Original After Negation
function returnToOriginalAfterNegation() {
    // Reset to original array
    myArray = [...originalArrayForNegation];
    originalArrayForNegation = [];
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isNegationRunning = false;
    inPlaceNegationBtn.disabled = false;
    
    logOperation('In-place negation completed and array reset to original', 'success');
    showNotification('In-place negation completed and array reset to original', 'success');
}

// NEW: Find Elements Appearing > n/3 Times Handler
function handleFindNBy3Elements() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isNBy3OperationRunning) {
        showNotification('An n/3 elements operation is already in progress', 'warning');
        return;
    }
    
    isNBy3OperationRunning = true;
    findNBy3ElementsBtn.disabled = true;
    
    // Store original array
    originalArrayForNBy3 = [...myArray];
    
    // Show n/3 elements visualization
    showNBy3ElementsVisualization();
}

// NEW: Show N/3 Elements Visualization
function showNBy3ElementsVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find Elements Appearing More Than n/3 Times</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array (n = ${myArray.length}, n/3 = ${Math.floor(myArray.length/3)})</div>
            <div class="original-array-container" id="originalN3Array"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Boyer-Moore Majority Vote Algorithm</div>
            <div class="transformed-array-container" id="transformedN3Array"></div>
        </div>
        
        <div class="n3-explanation">
            <p class="mb-2"><strong>Boyer-Moore Majority Vote Algorithm:</strong> Finds elements that appear more than n/3 times using O(1) space</p>
            <p class="mb-0" id="n3AlgorithmExplanation">Initializing algorithm with two candidates and counts...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="n3StepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="n3Steps"></div>
        </div>
        
        <div class="candidates-display mt-3" id="candidatesDisplay">
            <h6 class="text-center">Current Candidates</h6>
            <div class="d-flex justify-content-center gap-3" id="candidatesContainer"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterN3" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForNBy3, 'originalN3Array');
    renderArrayInContainer([...originalArrayForNBy3], 'transformedN3Array');
    
    performNBy3AlgorithmAnimation();
}

// NEW: Perform N/3 Algorithm Animation
function performNBy3AlgorithmAnimation() {
    const transformedContainer = document.getElementById('transformedN3Array');
    const n3Steps = document.getElementById('n3Steps');
    const n3AlgorithmExplanation = document.getElementById('n3AlgorithmExplanation');
    const candidatesContainer = document.getElementById('candidatesContainer');
    const continueButton = document.getElementById('continueAfterN3');
    
    let candidate1 = null, candidate2 = null;
    let count1 = 0, count2 = 0;
    let currentIndex = 0;
    let foundElements = [];
    
    // Initialize candidates display
    function updateCandidatesDisplay() {
        candidatesContainer.innerHTML = '';
        
        if (candidate1 !== null) {
            const candidate1Element = document.createElement('div');
            candidate1Element.className = 'stats-card';
            candidate1Element.innerHTML = `
                <div>Candidate 1</div>
                <div class="stats-value">${candidate1}</div>
                <div>Count: ${count1}</div>
            `;
            candidatesContainer.appendChild(candidate1Element);
        }
        
        if (candidate2 !== null) {
            const candidate2Element = document.createElement('div');
            candidate2Element.className = 'stats-card';
            candidate2Element.innerHTML = `
                <div>Candidate 2</div>
                <div class="stats-value">${candidate2}</div>
                <div>Count: ${count2}</div>
            `;
            candidatesContainer.appendChild(candidate2Element);
        }
    }
    
    // Perform one step of the algorithm
    function performStep() {
        if (currentIndex >= myArray.length) {
            // Algorithm completed - verify candidates
            n3Steps.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${currentIndex + 1}:</strong> Algorithm completed. Verifying candidates...
                </div>
            `;
            
            n3AlgorithmExplanation.textContent = 'Algorithm completed. Now verifying if candidates appear more than n/3 times...';
            
            setTimeout(() => {
                verifyCandidates();
            }, 1500);
            return;
        }
        
        const currentElement = myArray[currentIndex];
        const elements = transformedContainer.querySelectorAll('.array-element');
        const currentValueDiv = elements[currentIndex].querySelector('.element-value');
        
        // Highlight current element
        currentValueDiv.classList.add('n3-current');
        
        n3Steps.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex + 1}:</strong> Processing element [${currentIndex}] = ${currentElement}
            </div>
        `;
        
        n3Steps.scrollTop = n3Steps.scrollHeight;
        
        setTimeout(() => {
            // Algorithm logic
            if (candidate1 !== null && candidate1 === currentElement) {
                count1++;
                currentValueDiv.classList.remove('n3-current');
                currentValueDiv.classList.add('n3-count-increase', 'n3-candidate-1');
                n3Steps.innerHTML += `
                    <div class="algorithm-step">
                        &nbsp;&nbsp; Matches candidate1 (${candidate1}), increasing count1 to ${count1}
                    </div>
                `;
                n3AlgorithmExplanation.textContent = `Element matches candidate1. Increasing count1 to ${count1}`;
            } else if (candidate2 !== null && candidate2 === currentElement) {
                count2++;
                currentValueDiv.classList.remove('n3-current');
                currentValueDiv.classList.add('n3-count-increase', 'n3-candidate-2');
                n3Steps.innerHTML += `
                    <div class="algorithm-step">
                        &nbsp;&nbsp; Matches candidate2 (${candidate2}), increasing count2 to ${count2}
                    </div>
                `;
                n3AlgorithmExplanation.textContent = `Element matches candidate2. Increasing count2 to ${count2}`;
            } else if (count1 === 0) {
                candidate1 = currentElement;
                count1 = 1;
                currentValueDiv.classList.remove('n3-current');
                currentValueDiv.classList.add('n3-candidate-1');
                n3Steps.innerHTML += `
                    <div class="algorithm-step">
                        &nbsp;&nbsp; count1 is 0, setting candidate1 to ${currentElement} with count1 = 1
                    </div>
                `;
                n3AlgorithmExplanation.textContent = `count1 is 0. Setting candidate1 to ${currentElement}`;
            } else if (count2 === 0) {
                candidate2 = currentElement;
                count2 = 1;
                currentValueDiv.classList.remove('n3-current');
                currentValueDiv.classList.add('n3-candidate-2');
                n3Steps.innerHTML += `
                    <div class="algorithm-step">
                        &nbsp;&nbsp; count2 is 0, setting candidate2 to ${currentElement} with count2 = 1
                    </div>
                `;
                n3AlgorithmExplanation.textContent = `count2 is 0. Setting candidate2 to ${currentElement}`;
            } else {
                count1--;
                count2--;
                currentValueDiv.classList.remove('n3-current');
                currentValueDiv.classList.add('n3-count-decrease');
                n3Steps.innerHTML += `
                    <div class="algorithm-step">
                        &nbsp;&nbsp; No match, decreasing both counts: count1=${count1}, count2=${count2}
                    </div>
                `;
                n3AlgorithmExplanation.textContent = `No match with candidates. Decreasing both counts: count1=${count1}, count2=${count2}`;
            }
            
            // Update candidates display
            updateCandidatesDisplay();
            
            n3Steps.scrollTop = n3Steps.scrollHeight;
            
            // Remove highlight after animation
            setTimeout(() => {
                currentValueDiv.classList.remove('n3-count-increase', 'n3-count-decrease', 'n3-candidate-1', 'n3-candidate-2');
                
                // Move to next element
                currentIndex++;
                performStep();
            }, 1500);
        }, 1000);
    }
    
    // Verify candidates after algorithm completion
    function verifyCandidates() {
        n3Steps.innerHTML += `
            <div class="algorithm-step active">
                <strong>Verification:</strong> Counting actual occurrences of candidates...
            </div>
        `;
        
        // Count actual occurrences
        let countCandidate1 = 0;
        let countCandidate2 = 0;
        
        for (let i = 0; i < myArray.length; i++) {
            if (candidate1 !== null && myArray[i] === candidate1) countCandidate1++;
            if (candidate2 !== null && myArray[i] === candidate2) countCandidate2++;
        }
        
        const threshold = Math.floor(myArray.length / 3);
        foundElements = [];
        
        if (candidate1 !== null && countCandidate1 > threshold) {
            foundElements.push(candidate1);
        }
        if (candidate2 !== null && countCandidate2 > threshold) {
            foundElements.push(candidate2);
        }
        
        // Highlight found elements
        const elements = transformedContainer.querySelectorAll('.array-element');
        for (let i = 0; i < myArray.length; i++) {
            if (foundElements.includes(myArray[i])) {
                const valueDiv = elements[i].querySelector('.element-value');
                valueDiv.classList.add('n3-found');
            }
        }
        
        // Display results
        if (foundElements.length > 0) {
            n3Steps.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Result:</strong> Found ${foundElements.length} element(s) appearing more than n/3 times: ${foundElements.join(', ')}
                </div>
            `;
            n3AlgorithmExplanation.textContent = `Found ${foundElements.length} element(s) appearing more than n/3 times: ${foundElements.join(', ')}`;
        } else {
            n3Steps.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Result:</strong> No elements found appearing more than n/3 times
                </div>
            `;
            n3AlgorithmExplanation.textContent = 'No elements found appearing more than n/3 times';
        }
        
        // Show continue button
        continueButton.style.display = 'block';
        
        // Auto-proceed after 5 seconds
        const autoProceedTimer = setTimeout(() => {
            proceedAfterN3();
        }, 5000);
        
        // Manual click handler
        continueButton.addEventListener('click', () => {
            clearTimeout(autoProceedTimer);
            proceedAfterN3();
        });
    }
    
    // Proceed after N/3 operation
    function proceedAfterN3() {
        // Reset to original array
        myArray = [...originalArrayForNBy3];
        isNBy3OperationRunning = false;
        findNBy3ElementsBtn.disabled = false;
        
        // Remove dual visualization and return to normal view
        const mainContainer = document.getElementById('arrayContainer');
        mainContainer.innerHTML = '';
        renderArray();
        updateStats();
        
        logOperation(`Completed n/3 elements search. Found: ${foundElements.length > 0 ? foundElements.join(', ') : 'none'}`, 'success');
        showNotification(`Returned to original array after n/3 elements search`, 'info');
    }
    
    // Start the algorithm
    performStep();
}
// NEW: Next Greater Element Handler
function handleNextGreaterElement() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isNextGreaterElementRunning) {
        showNotification('Next Greater Element operation is already in progress', 'warning');
        return;
    }
    
    isNextGreaterElementRunning = true;
    nextGreaterElementBtn.disabled = true;
    
    // Store original array
    originalArrayForNGE = [...myArray];
    
    // Reset all elements first
    const elements = document.querySelectorAll('.array-element');
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('nge-current', 'nge-processed', 'nge-found', 'nge-no-greater');
    });
    
    // Create dual visualization and start algorithm immediately
    showNextGreaterElementVisualization();
}

// NEW: Show Next Greater Element Visualization
function showNextGreaterElementVisualization() {
    // Create dual container for array and stack
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Next Greater Element Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalArrayNGE"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Result Array (Next Greater Elements)</div>
            <div class="transformed-array-container" id="resultArrayNGE"></div>
        </div>
        
        <div class="stack-container mt-3" id="stackContainerNGE">
            <div class="stack-label">Stack (stores indices)</div>
            <div class="stack-elements" id="stackElements"></div>
        </div>
        
        <div class="nge-explanation mt-3">
            <p class="mb-2"><strong>Algorithm Explanation:</strong></p>
            <p class="mb-1"> Stack stores indices of elements for which we haven't found next greater element yet</p>
            <p class="mb-1"> For each element, we check if it's greater than stack top element</p>
            <p class="mb-1"> If yes, we found next greater element for stack top</p>
            <p class="mb-0"> If no, we push current element index to stack</p>
        </div>
        
        <div class="calculation-steps mt-3" id="calculationStepsNGE">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="stepsContainerNGE"></div>
        </div>
        
        <div class="text-center mt-3">
            <div class="spinner-border text-primary" role="status" id="ngeSpinner">
                <span class="visually-hidden">Processing...</span>
            </div>
            <p class="mt-2 text-info">Algorithm in progress...</p>
        </div>
    `;
    
    // Replace the main array container with dual visualization
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Render original array
    renderArrayInContainer(originalArrayForNGE, 'originalArrayNGE');
    
    // Render empty result array
    const resultArray = new Array(originalArrayForNGE.length).fill(-1);
    renderArrayInContainer(resultArray.map(val => val === -1 ? '?' : val), 'resultArrayNGE');
    
    // Start algorithm immediately after a short delay to allow rendering
    setTimeout(() => {
        performNextGreaterElementAlgorithm();
    }, 500);
}

// NEW: Perform Next Greater Element Algorithm with Visualization
function performNextGreaterElementAlgorithm() {
    const stepsContainer = document.getElementById('stepsContainerNGE');
    const originalContainer = document.getElementById('originalArrayNGE');
    const resultContainer = document.getElementById('resultArrayNGE');
    const stackElements = document.getElementById('stackElements');
    
    const n = originalArrayForNGE.length;
    const result = new Array(n).fill(-1); // Initialize result with -1 (no greater element)
    const stack = []; // Stack to store indices
    let currentIndex = 0;
    let stepCounter = 1;
    
    // Function to update stack visualization
    function updateStackVisualization() {
        stackElements.innerHTML = '';
        
        if (stack.length === 0) {
            const emptyStack = document.createElement('div');
            emptyStack.className = 'stack-element';
            emptyStack.textContent = 'Empty';
            emptyStack.style.background = 'rgba(255,255,255,0.1)';
            stackElements.appendChild(emptyStack);
            return;
        }
        
        // Show stack from top to bottom
        for (let i = stack.length - 1; i >= 0; i--) {
            const stackIndex = stack[i];
            const stackValue = originalArrayForNGE[stackIndex];
            const stackElement = document.createElement('div');
            stackElement.className = 'stack-element';
            stackElement.textContent = `[${stackIndex}]: ${stackValue}`;
            stackElements.appendChild(stackElement);
        }
    }
    
    // Function to perform one algorithm step
    function performStep() {
        if (currentIndex >= n) {
            // Algorithm completed
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${stepCounter}:</strong> All array elements processed!
                </div>
            `;
            
            // Process remaining elements in stack
            processRemainingStack();
            return;
        }
        
        const currentValue = originalArrayForNGE[currentIndex];
        
        // Highlight current element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentIndex];
        const currentValueDiv = currentElement.querySelector('.element-value');
        currentValueDiv.classList.add('nge-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${stepCounter}:</strong> Processing index ${currentIndex} (value: ${currentValue})
            </div>
        `;
        
        stepCounter++;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Check stack and find next greater elements
        processStackWithCurrentElement();
    }
    
    // Function to process stack with current element
    function processStackWithCurrentElement() {
        const currentValue = parseFloat(originalArrayForNGE[currentIndex]);
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const resultElements = resultContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentIndex];
        const currentValueDiv = currentElement.querySelector('.element-value');
        
        setTimeout(() => {
            if (stack.length === 0) {
                // Stack is empty, just push current index
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${stepCounter}:</strong> Stack is empty, pushing index ${currentIndex} to stack
                    </div>
                `;
                
                stack.push(currentIndex);
                updateStackVisualization();
                currentValueDiv.classList.remove('nge-current');
                currentValueDiv.classList.add('nge-processed');
                
                stepCounter++;
                currentIndex++;
                setTimeout(performStep, 1000);
                return;
            }
            
            let stackTopIndex = stack[stack.length - 1];
            let stackTopValue = parseFloat(originalArrayForNGE[stackTopIndex]);
            
            // Highlight stack top element
            const stackTopElement = originalElements[stackTopIndex];
            const stackTopValueDiv = stackTopElement.querySelector('.element-value');
            stackTopValueDiv.classList.add('nge-processed');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${stepCounter}:</strong> Comparing current value ${currentValue} with stack top [${stackTopIndex}]: ${stackTopValue}
                </div>
            `;
            
            stepCounter++;
            
            if (currentValue > stackTopValue) {
                // Current element is greater than stack top - found next greater element
                setTimeout(() => {
                    result[stackTopIndex] = currentValue;
                    
                    // Update result array visualization
                    const resultValueDiv = resultElements[stackTopIndex].querySelector('.element-value');
                    resultValueDiv.textContent = currentValue;
                    resultValueDiv.classList.add('nge-found', 'transform-animation');
                    
                    // Highlight the found relationship
                    stackTopValueDiv.classList.remove('nge-processed');
                    stackTopValueDiv.classList.add('nge-found');
                    currentValueDiv.classList.add('nge-found');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${stepCounter}:</strong> Found! Next greater element for [${stackTopIndex}] is ${currentValue} at index ${currentIndex}
                        </div>
                    `;
                    
                    stepCounter++;
                    
                    // Pop from stack
                    stack.pop();
                    updateStackVisualization();
                    
                    // Remove highlights after a moment
                    setTimeout(() => {
                        stackTopValueDiv.classList.remove('nge-found');
                        currentValueDiv.classList.remove('nge-found', 'nge-current');
                        currentValueDiv.classList.add('nge-processed');
                        
                        // Continue processing stack with same current element
                        processStackWithCurrentElement();
                    }, 1000);
                }, 1000);
            } else {
                // Current element is not greater than stack top
                setTimeout(() => {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${stepCounter}:</strong> ${currentValue}  ${stackTopValue}, pushing index ${currentIndex} to stack
                        </div>
                    `;
                    
                    stack.push(currentIndex);
                    updateStackVisualization();
                    
                    currentValueDiv.classList.remove('nge-current');
                    currentValueDiv.classList.add('nge-processed');
                    stackTopValueDiv.classList.remove('nge-processed');
                    
                    stepCounter++;
                    currentIndex++;
                    setTimeout(performStep, 1000);
                }, 1000);
            }
        }, 1000);
    }
    
    // Function to process remaining elements in stack
    function processRemainingStack() {
        if (stack.length === 0) {
            finishAlgorithm();
            return;
        }
        
        const stackTopIndex = stack[stack.length - 1];
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const resultElements = resultContainer.querySelectorAll('.array-element');
        const stackTopElement = originalElements[stackTopIndex];
        const stackTopValueDiv = stackTopElement.querySelector('.element-value');
        
        stackTopValueDiv.classList.add('nge-no-greater');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${stepCounter}:</strong> No next greater element for [${stackTopIndex}]: ${originalArrayForNGE[stackTopIndex]} (setting to -1)
            </div>
        `;
        
        result[stackTopIndex] = -1;
        const resultValueDiv = resultElements[stackTopIndex].querySelector('.element-value');
        resultValueDiv.textContent = '-1';
        resultValueDiv.classList.add('nge-no-greater', 'transform-animation');
        
        stepCounter++;
        
        stack.pop();
        updateStackVisualization();
        
        setTimeout(() => {
            stackTopValueDiv.classList.remove('nge-no-greater');
            processRemainingStack();
        }, 1000);
    }
    
    // Function to finish algorithm
    function finishAlgorithm() {
        // Hide the spinner
        const spinner = document.getElementById('ngeSpinner');
        if (spinner) {
            spinner.style.display = 'none';
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${stepCounter}:</strong> Algorithm finished successfully!
            </div>
        `;
        
        // Show final result
        setTimeout(() => {
            const resultString = result.map((val, idx) => 
                `NGE[${idx}] = ${val}`
            ).join(', ');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active success-color text-white p-2 rounded">
                    <strong>Final Result:</strong> ${resultString}
                </div>
            `;
            
            // Add auto-reset message
            stepsContainer.innerHTML += `
                <div class="algorithm-step active info-color text-white p-2 rounded mt-2">
                    <strong>Note:</strong> Will return to original array view in 5 seconds...
                </div>
            `;
            
            logOperation('Next Greater Element algorithm completed', 'success');
            
            // Reset after delay
            setTimeout(() => {
                resetNextGreaterElementState();
            }, 5000);
        }, 1500);
    }
    
    // Initialize stack visualization and start algorithm
    updateStackVisualization();
    performStep();
}

// NEW: Reset Next Greater Element State
function resetNextGreaterElementState() {
    isNextGreaterElementRunning = false;
    nextGreaterElementBtn.disabled = false;
    
    // Return to normal array view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    
    logOperation('Next Greater Element visualization completed', 'info');
}
// NEW: Shallow Copy Handler
function handleShallowCopy() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    const count = parseInt(shallowCopyCount.value);
    const n = myArray.length;
    
    // Validation
    if (isNaN(count) || count < 1 || count > n) {
        showNotification(`Please enter a valid number between 1 and ${n}`, 'danger');
        shallowCopyCount.focus();
        return;
    }
    
    // Show input group for modifications
    shallowCopyInputGroup.style.display = 'block';
    shallowCopyInputs.innerHTML = '';
    shallowCopyModifications = [];
    
    // Create input fields for each modification
    for (let i = 0; i < count; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Index ${i}</span>
            <input type="number" class="form-control shallow-copy-index" 
                   placeholder="Index (0 to ${n-1})" min="0" max="${n-1}" 
                   data-modification-index="${i}">
            <input type="text" class="form-control shallow-copy-value" 
                   placeholder="New value" data-modification-index="${i}">
        `;
        shallowCopyInputs.appendChild(inputGroup);
    }
    
    // Add event listeners for inputs
    const indexInputs = shallowCopyInputs.querySelectorAll('.shallow-copy-index');
    const valueInputs = shallowCopyInputs.querySelectorAll('.shallow-copy-value');
    
    indexInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput) nextInput.focus();
            }
        });
    });
    
    valueInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const modIndex = parseInt(input.dataset.modificationIndex);
                const nextGroup = input.closest('.input-group').nextElementSibling;
                if (nextGroup) {
                    nextGroup.querySelector('.shallow-copy-index').focus();
                } else {
                    confirmShallowCopyBtn.focus();
                }
            }
        });
    });
    
    logOperation(`Started shallow copy operation with ${count} modifications`, 'info');
}

// NEW: Confirm Shallow Copy Handler
function handleConfirmShallowCopy() {
    const indexInputs = shallowCopyInputs.querySelectorAll('.shallow-copy-index');
    const valueInputs = shallowCopyInputs.querySelectorAll('.shallow-copy-value');
    
    shallowCopyModifications = [];
    
    // Validate all inputs
    for (let i = 0; i < indexInputs.length; i++) {
        const index = parseInt(indexInputs[i].value);
        const value = valueInputs[i].value.trim();
        
        if (isNaN(index) || index < 0 || index >= myArray.length) {
            showNotification(`Please enter a valid index between 0 and ${myArray.length-1} for modification ${i+1}`, 'danger');
            indexInputs[i].focus();
            return;
        }
        
        if (value === '') {
            showNotification(`Please enter a value for modification ${i+1}`, 'warning');
            valueInputs[i].focus();
            return;
        }
        
        shallowCopyModifications.push({ index, value });
    }
    
    // Check for duplicate indices
    const indices = shallowCopyModifications.map(mod => mod.index);
    const uniqueIndices = new Set(indices);
    if (uniqueIndices.size !== indices.length) {
        showNotification('Duplicate indices found. Please use different indices for each modification.', 'danger');
        return;
    }
    
    // Hide input group
    shallowCopyInputGroup.style.display = 'none';
    shallowCopyCount.value = '';
    
    // Store original array
    originalArrayForShallowCopy = [...myArray];
    
    // Show shallow copy visualization
    showShallowCopyVisualization();
}

// NEW: Cancel Shallow Copy Handler
function handleCancelShallowCopy() {
    shallowCopyInputGroup.style.display = 'none';
    shallowCopyCount.value = '';
    shallowCopyInputs.innerHTML = '';
    shallowCopyModifications = [];
    
    logOperation('Cancelled shallow copy operation', 'info');
    showNotification('Shallow copy operation cancelled', 'info');
}

// NEW: Show Shallow Copy Visualization
function showShallowCopyVisualization() {
    isShallowCopyRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Shallow Copy Demonstration</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array (Reference)</div>
            <div class="original-array-container" id="originalShallowArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-copy"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Shallow Copied Array (Same Reference)</div>
            <div class="transformed-array-container" id="shallowCopiedArray"></div>
        </div>
        
        <div class="shallow-copy-explanation">
            <p class="mb-2"><strong>Shallow Copy Concept:</strong> Both arrays reference the same objects in memory</p>
            <p class="mb-0" id="shallowCopyExplanation">Starting shallow copy demonstration...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="shallowCopyStepsContainer">
            <h6 class="text-center">Shallow Copy Operation Steps</h6>
            <div class="steps-container" id="shallowCopySteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterShallowCopy" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // For shallow copy demonstration, we'll use object references
    // Create an array with objects to demonstrate reference sharing
    const arrayWithObjects = originalArrayForShallowCopy.map((value, index) => ({
        id: index,
        value: value,
        display: value // Changed from `Obj${index}(${value})` to just `value`
    }));
    
    // Store the object array for the demonstration
    window.shallowCopyDemoArray = arrayWithObjects;
    
    // Render both arrays with object display
    renderObjectArrayInContainer(arrayWithObjects, 'originalShallowArray');
    renderObjectArrayInContainer([...arrayWithObjects], 'shallowCopiedArray');
    
    // Perform shallow copy demonstration
    performShallowCopyDemonstration(arrayWithObjects);
}
// NEW: Render Object Array in Container (for shallow copy demo)
function renderObjectArrayInContainer(objectArray, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    objectArray.forEach((obj, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value shallow-copy-original" data-index="${index}" data-object-id="${obj.id}">
                ${obj.value} <!-- Changed from obj.display to obj.value -->
            </div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}
// NEW: Perform Shallow Copy Demonstration
function performShallowCopyDemonstration(originalArray) {
    const originalContainer = document.getElementById('originalShallowArray');
    const shallowContainer = document.getElementById('shallowCopiedArray');
    const explanation = document.getElementById('shallowCopyExplanation');
    const stepsContainer = document.getElementById('shallowCopySteps');
    const continueButton = document.getElementById('continueAfterShallowCopy');
    
    // Create shallow copy (both arrays reference same objects)
    const shallowCopyArray = originalArray; // This is the key - same reference!
    
    let currentStep = 0;
    
    function performShallowCopyStep() {
        switch (currentStep) {
            case 0:
                // Step 1: Show original array with objects
                explanation.innerHTML = 'Step 1: Original array created with objects';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Original array created with object references
                    </div>
                `;
                
                // Highlight all elements as original
                const allElements = document.querySelectorAll('.element-value');
                allElements.forEach(el => {
                    el.classList.add('shallow-copy-original');
                });
                break;
                
            case 1:
                // Step 2: Demonstrate shallow copy assignment
                explanation.innerHTML = 'Step 2: Shallow copy created - let shallowCopy = originalArray';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Shallow copy shares same object references
                    </div>
                `;
                
                // Highlight both arrays to show they share references
                const originalElements = originalContainer.querySelectorAll('.array-element');
                const shallowElements = shallowContainer.querySelectorAll('.array-element');
                
                originalElements.forEach((el, index) => {
                    const valueDiv = el.querySelector('.element-value');
                    valueDiv.classList.remove('shallow-copy-original');
                    valueDiv.classList.add('shallow-copy-reference');
                });
                
                shallowElements.forEach((el, index) => {
                    const valueDiv = el.querySelector('.element-value');
                    valueDiv.classList.remove('shallow-copy-original');
                    valueDiv.classList.add('shallow-copy-reference');
                });
                break;
                
            case 2:
                // Step 3: Show modification through shallow copy
                explanation.innerHTML = 'Step 3: Modifying objects through shallow copy array';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Modifying objects affects both arrays (same references)
                    </div>
                `;
                
                // Process each modification
                processModificationsSequentially(0);
                return; // Don't increment step yet
                
            case 3:
                // Step 4: Show that original array is also affected
                explanation.innerHTML = '<strong>Shallow Copy Demonstration Complete!</strong> Both arrays show changes because they share object references.';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 4:</strong> Shallow copy demonstration completed! Both arrays affected by modifications.
                    </div>
                `;
                
                // Show final comparison
const finalOriginal = originalArray.map(obj => obj.value).join(', '); // Changed from obj.display to obj.value
const finalShallow = shallowCopyArray.map(obj => obj.value).join(', '); // Changed from obj.display to obj.value

stepsContainer.innerHTML += `
    <div class="algorithm-step active">
        <strong>Result:</strong> 
        Original: [${finalOriginal}] | 
        Shallow Copy: [${finalShallow}]
    </div>
    <div class="algorithm-step active">
        <strong>Conclusion:</strong> Both arrays are identical because they reference the same objects!
    </div>
                `;
                
                continueButton.style.display = 'block';
                
                // Auto-return after 5 seconds
                setTimeout(() => {
                    returnToOriginalAfterShallowCopy();
                }, 5000);
                
                continueButton.addEventListener('click', returnToOriginalAfterShallowCopy);
                return;
        }
        
        currentStep++;
        setTimeout(performShallowCopyStep, 2000);
    }
    
    // Helper function to process modifications sequentially with animations
    function processModificationsSequentially(modIndex) {
        if (modIndex >= shallowCopyModifications.length) {
            currentStep++;
            performShallowCopyStep();
            return;
        }
        
        const modification = shallowCopyModifications[modIndex];
        const { index, value } = modification;
        
        explanation.innerHTML = `Modification ${modIndex + 1}: Changing object at index ${index} to "${value}"`;
        
        // Highlight the element being modified in both arrays
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const shallowElements = shallowContainer.querySelectorAll('.array-element');
        
        const originalElement = originalElements[index].querySelector('.element-value');
        const shallowElement = shallowElements[index].querySelector('.element-value');
        
        originalElement.classList.remove('shallow-copy-reference');
        shallowElement.classList.remove('shallow-copy-reference');
        originalElement.classList.add('shallow-copy-modified');
        shallowElement.classList.add('shallow-copy-modified');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Modification ${modIndex + 1}:</strong> Changing shallowCopy[${index}] to "${value}"
            </div>
        `;
        
        setTimeout(() => {
            // Modify the object (this affects both arrays since they share references)
            const objectToModify = originalArray[index];
            objectToModify.value = value;
            objectToModify.display = value;
            
            // Update both array displays
            renderObjectArrayInContainer(originalArray, 'originalShallowArray');
            renderObjectArrayInContainer(shallowCopyArray, 'shallowCopiedArray');
            
            // Highlight both arrays to show they're both affected
            const updatedOriginalElements = originalContainer.querySelectorAll('.array-element');
            const updatedShallowElements = shallowContainer.querySelectorAll('.array-element');
            
            updatedOriginalElements.forEach(el => {
                el.querySelector('.element-value').classList.add('shallow-copy-affected');
            });
            
            updatedShallowElements.forEach(el => {
                el.querySelector('.element-value').classList.add('shallow-copy-affected');
            });
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Effect:</strong> Both arrays updated! Original array also shows the change.
                </div>
            `;
            
            // Process next modification after delay
            setTimeout(() => {
                processModificationsSequentially(modIndex + 1);
            }, 2000);
        }, 1500);
    }
    
    // Start the demonstration
    performShallowCopyStep();
}
// NEW: Return to Original after Shallow Copy
function returnToOriginalAfterShallowCopy() {
    // Reset to original array
    myArray = [...originalArrayForShallowCopy];
    originalArrayForShallowCopy = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isShallowCopyRunning = false;
    
    // Clear any demo data
    window.shallowCopyDemoArray = null;
    
    logOperation('Shallow copy demonstration completed - returned to original array', 'info');
    showNotification('Returned to original array after shallow copy demonstration', 'success');
}
// NEW: In-Place Merge Sort Handler
function handleInPlaceMergeSort() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - already sorted', 'info');
        return;
    }
    
    if (isInPlaceMergeSortRunning) {
        showNotification('In-place merge sort is already in progress', 'warning');
        return;
    }
    
    isInPlaceMergeSortRunning = true;
    inPlaceMergeSortBtn.disabled = true;
    
    // Store original array
    originalArrayForInPlaceMerge = [...myArray];
    
    // Show in-place merge sort visualization
    showInPlaceMergeSortVisualization();
}
// NEW: Show In-Place Merge Sort Visualization
function showInPlaceMergeSortVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">In-Place Merge Sort Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalInPlaceMergeArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">In-Place Sorting Process</div>
            <div class="transformed-array-container" id="transformedInPlaceMergeArray"></div>
        </div>
        
        <div class="inplace-merge-explanation">
            <p class="mb-2"><strong>In-Place Merge Sort:</strong> Sorts array without using extra space, modifying original array directly</p>
            <p class="mb-0" id="inPlaceMergeExplanation">Starting in-place merge sort...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="inPlaceMergeStepsContainer">
            <h6 class="text-center">In-Place Merge Sort Steps</h6>
            <div class="steps-container" id="inPlaceMergeSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterInPlaceMerge" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForInPlaceMerge, 'originalInPlaceMergeArray');
    renderArrayInContainer([...originalArrayForInPlaceMerge], 'transformedInPlaceMergeArray');
    
    performInPlaceMergeSortAnimation();
}
// NEW: Perform In-Place Merge Sort Animation
function performInPlaceMergeSortAnimation() {
    const originalContainer = document.getElementById('originalInPlaceMergeArray');
    const transformedContainer = document.getElementById('transformedInPlaceMergeArray');
    const explanation = document.getElementById('inPlaceMergeExplanation');
    const stepsContainer = document.getElementById('inPlaceMergeSteps');
    const continueButton = document.getElementById('continueAfterInPlaceMerge');
    
    let array = [...originalArrayForInPlaceMerge];
    const n = array.length;
    let stepCounter = 0;
    
    // Convert to numbers for comparison if possible
    const isNumeric = !array.some(item => isNaN(parseFloat(item)));
    
    async function inPlaceMergeSort(start, end) {
        if (start >= end) return;
        
        const mid = Math.floor((start + end) / 2);
        
        // Update explanation for division
        explanation.innerHTML = `Dividing: Sorting subarray [${start}-${end}], Midpoint = ${mid}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${++stepCounter}:</strong> Divide - Sorting subarray [${start}-${end}], Midpoint = ${mid}
            </div>
        `;
        
        // Highlight current subarray being processed
        await highlightSubarray(transformedContainer, start, end, 'inplace-merge-current');
        
        // Recursively sort left half
        await inPlaceMergeSort(start, mid);
        
        // Recursively sort right half
        await inPlaceMergeSort(mid + 1, end);
        
        // Merge the two halves in-place
        await inPlaceMerge(start, mid, end);
    }
    
    async function inPlaceMerge(start, mid, end) {
        explanation.innerHTML = `Merging: Combining sorted halves [${start}-${mid}] and [${mid+1}-${end}]`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${++stepCounter}:</strong> Merge - Combining [${start}-${mid}] and [${mid+1}-${end}]
            </div>
        `;
        
        let i = start;
        let j = mid + 1;
        
        // Highlight the two halves being merged
        await highlightSubarray(transformedContainer, start, mid, 'inplace-merge-left');
        await highlightSubarray(transformedContainer, mid + 1, end, 'inplace-merge-right');
        
        while (i <= mid && j <= end) {
            // Compare elements
            explanation.innerHTML = `Comparing: array[${i}] = ${array[i]} vs array[${j}] = ${array[j]}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${++stepCounter}:</strong> Compare array[${i}]="${array[i]}" and array[${j}]="${array[j]}"
                </div>
            `;
            
            // Highlight elements being compared
            await highlightElements(transformedContainer, [i, j], 'inplace-merge-compared');
            
            let shouldSwap = false;
            if (isNumeric) {
                shouldSwap = parseFloat(array[i]) > parseFloat(array[j]);
            } else {
                shouldSwap = array[i] > array[j];
            }
            
            if (shouldSwap) {
                // Swap elements
                explanation.innerHTML = `Swapping: ${array[i]} and ${array[j]} (out of order)`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${++stepCounter}:</strong> Swap needed - ${array[i]} > ${array[j]}
                    </div>
                `;
                
                await swapElements(transformedContainer, i, j);
                [array[i], array[j]] = [array[j], array[i]];
                
                // After swap, we need to maintain the sorted order in the left half
                let k = j;
                while (k > i + 1) {
                    explanation.innerHTML = `Maintaining order: Checking array[${k-1}] and array[${k}]`;
                    
                    await highlightElements(transformedContainer, [k-1, k], 'inplace-merge-compared');
                    
                    let shouldSwapInner = false;
                    if (isNumeric) {
                        shouldSwapInner = parseFloat(array[k-1]) > parseFloat(array[k]);
                    } else {
                        shouldSwapInner = array[k-1] > array[k];
                    }
                    
                    if (shouldSwapInner) {
                        await swapElements(transformedContainer, k-1, k);
                        [array[k-1], array[k]] = [array[k], array[k-1]];
                        k--;
                    } else {
                        break;
                    }
                }
                
                j++;
                if (j > end) break;
            } else {
                i++;
            }
            
            // Update the display
            renderArrayInContainer(array, 'transformedInPlaceMergeArray');
            
            // Small delay for animation
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
        // Mark subarray as sorted
        await highlightSubarray(transformedContainer, start, end, 'inplace-merge-sorted');
        
        explanation.innerHTML = `Subarray [${start}-${end}] successfully merged and sorted`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${++stepCounter}:</strong> Subarray [${start}-${end}] merged successfully
            </div>
        `;
    }
    
    // Helper function to highlight a subarray
    async function highlightSubarray(container, start, end, className) {
        const elements = container.querySelectorAll('.array-element');
        for (let i = start; i <= end; i++) {
            if (i < elements.length) {
                elements[i].querySelector('.element-value').classList.add(className);
            }
        }
        await new Promise(resolve => setTimeout(resolve, 800));
        
        // Remove highlight after delay
        for (let i = start; i <= end; i++) {
            if (i < elements.length) {
                elements[i].querySelector('.element-value').classList.remove(className);
            }
        }
    }
    
    // Helper function to highlight specific elements
    async function highlightElements(container, indices, className) {
        const elements = container.querySelectorAll('.array-element');
        indices.forEach(index => {
            if (index < elements.length) {
                elements[index].querySelector('.element-value').classList.add(className);
            }
        });
        await new Promise(resolve => setTimeout(resolve, 800));
        
        // Remove highlight
        indices.forEach(index => {
            if (index < elements.length) {
                elements[index].querySelector('.element-value').classList.remove(className);
            }
        });
    }
    
    // Helper function to swap elements with animation
    async function swapElements(container, i, j) {
        const elements = container.querySelectorAll('.array-element');
        const elementI = elements[i].querySelector('.element-value');
        const elementJ = elements[j].querySelector('.element-value');
        
        elementI.classList.add('inplace-merge-swapped');
        elementJ.classList.add('inplace-merge-swapped');
        
        // Calculate swap distance for animation
        const rectI = elements[i].getBoundingClientRect();
        const rectJ = elements[j].getBoundingClientRect();
        const swapDistance = rectJ.left - rectI.left;
        
        elementI.style.setProperty('--swap-distance', `${swapDistance}px`);
        elementJ.style.setProperty('--swap-distance', `-${swapDistance}px`);
        
        elementI.classList.add('swap-animation');
        elementJ.classList.add('swap-animation');
        
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        elementI.classList.remove('inplace-merge-swapped', 'swap-animation');
        elementJ.classList.remove('inplace-merge-swapped', 'swap-animation');
    }
    
    // Start the in-place merge sort
    inPlaceMergeSort(0, n - 1).then(() => {
        // Sorting completed
        explanation.innerHTML = `<strong>In-Place Merge Sort Completed!</strong> Array sorted successfully without extra space.`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Final:</strong> In-place merge sort completed! Total steps: ${stepCounter}
            </div>
        `;
        
        // Highlight the entire sorted array
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        transformedElements.forEach((el, index) => {
            setTimeout(() => {
                el.querySelector('.element-value').classList.add('inplace-merge-sorted');
            }, index * 100);
        });
        
        continueButton.style.display = 'block';
        
        // Auto-return to original after 30 seconds
        setTimeout(() => {
            returnToOriginalAfterInPlaceMerge();
        }, 30000);
        
        continueButton.addEventListener('click', returnToOriginalAfterInPlaceMerge);
    });
}
// NEW: Return to Original after In-Place Merge Sort
function returnToOriginalAfterInPlaceMerge() {
    // Reset to original array
    myArray = [...originalArrayForInPlaceMerge];
    originalArrayForInPlaceMerge = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isInPlaceMergeSortRunning = false;
    inPlaceMergeSortBtn.disabled = false;
    
    logOperation('In-place merge sort completed - returned to original array', 'info');
    showNotification('Returned to original array after in-place merge sort', 'success');
}
// NEW: Insert Sorted Handler
function handleInsertSorted() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isInsertSortedRunning) {
        showNotification('Insert sorted operation is already in progress', 'warning');
        return;
    }
    
    // Show input group
    insertSortedGroup.style.display = 'block';
    insertSortedCountInput.focus();
    
    // Reset inputs
    insertSortedCountInput.value = '';
    insertSortedInputs.innerHTML = '';
    performInsertSortedBtn.style.display = 'none';
    insertSortedElements = [];
    
    logOperation('Started insert sorted operation', 'info');
}

// NEW: Confirm Insert Sorted Count Handler
function handleConfirmInsertSortedCount() {
    const count = parseInt(insertSortedCountInput.value);
    
    if (isNaN(count) || count < 1 || count > 10) {
        showNotification('Please enter a valid number between 1 and 10', 'danger');
        insertSortedCountInput.focus();
        return;
    }
    
    insertSortedCount = count;
    insertSortedElements = [];
    
    // Create input fields for elements to insert
    insertSortedInputs.innerHTML = '<label class="form-label">Enter elements to insert (in any order):</label>';
    for (let i = 0; i < count; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i + 1}</span>
            <input type="text" class="form-control insert-sorted-element" 
                   placeholder="Enter value" data-index="${i}">
        `;
        insertSortedInputs.appendChild(inputGroup);
    }
    
    // Add event listeners for input fields
    const elementInputs = insertSortedInputs.querySelectorAll('.insert-sorted-element');
    elementInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('insert-sorted-element')) {
                    nextInput.focus();
                } else {
                    performInsertSortedBtn.focus();
                }
            }
        });
    });
    
    // Show perform button
    performInsertSortedBtn.style.display = 'block';
    
    showNotification(`Please enter ${count} elements to insert`, 'success');
    logOperation(`Insert sorted count set to ${count}`, 'info');
}

// NEW: Perform Insert Sorted Handler
function handlePerformInsertSorted() {
    // Collect elements to insert
    const elementInputs = document.querySelectorAll('.insert-sorted-element');
    insertSortedElements = [];
    
    for (let i = 0; i < elementInputs.length; i++) {
        const value = elementInputs[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all elements. Missing element at position ${i + 1}`, 'danger');
            elementInputs[i].focus();
            return;
        }
        insertSortedElements.push(value);
    }
    
    // Validate that we have exactly the requested number of elements
    if (insertSortedElements.length !== insertSortedCount) {
        showNotification(`Please enter exactly ${insertSortedCount} elements`, 'danger');
        return;
    }
    
    // Store original array
    originalArrayForInsertSorted = [...myArray];
    
    // Hide input group
    insertSortedGroup.style.display = 'none';
    
    // Start insert sorted visualization
    showInsertSortedVisualization();
}

// NEW: Cancel Insert Sorted Handler
function handleCancelInsertSorted() {
    insertSortedGroup.style.display = 'none';
    insertSortedCountInput.value = '';
    insertSortedInputs.innerHTML = '';
    performInsertSortedBtn.style.display = 'none';
    
    insertSortedElements = [];
    insertSortedCount = 0;
    
    logOperation('Cancelled insert sorted operation', 'info');
    showNotification('Insert sorted operation cancelled', 'info');
}

// NEW: Show Insert Sorted Visualization
function showInsertSortedVisualization() {
    isInsertSortedRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Insert Sorted (Maintain Order)</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalInsertSortedArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After Insert Sorted Operation</div>
            <div class="transformed-array-container" id="transformedInsertSortedArray"></div>
        </div>
        
        <div class="insert-sorted-explanation">
            <p class="mb-2"><strong>Insert Sorted Process:</strong> Inserting elements while maintaining sorted order</p>
            <p class="mb-0" id="insertSortedExplanation">Starting insert sorted operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="insertSortedStepsContainer">
            <h6 class="text-center">Insert Sorted Steps</h6>
            <div class="steps-container" id="insertSortedSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterInsertSorted" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForInsertSorted, 'originalInsertSortedArray');
    renderArrayInContainer([...originalArrayForInsertSorted], 'transformedInsertSortedArray');
    
    performInsertSortedAnimation();
}

// NEW: Perform Insert Sorted Animation
function performInsertSortedAnimation() {
    const originalContainer = document.getElementById('originalInsertSortedArray');
    const transformedContainer = document.getElementById('transformedInsertSortedArray');
    const explanation = document.getElementById('insertSortedExplanation');
    const stepsContainer = document.getElementById('insertSortedSteps');
    const continueButton = document.getElementById('continueAfterInsertSorted');
    
    let currentArray = [...originalArrayForInsertSorted];
    const elementsToInsert = [...insertSortedElements];
    let currentElementIndex = 0;
    let totalSteps = 0;
    
    // Check if array needs to be sorted first
    const isNumeric = !currentArray.some(item => isNaN(parseFloat(item)));
    let isSorted = true;
    
    // Check if array is already sorted
    for (let i = 1; i < currentArray.length; i++) {
        let prevVal = isNumeric ? parseFloat(currentArray[i-1]) : currentArray[i-1];
        let currVal = isNumeric ? parseFloat(currentArray[i]) : currentArray[i];
        
        if ((isNumeric && prevVal > currVal) || (!isNumeric && prevVal > currVal)) {
            isSorted = false;
            break;
        }
    }
    
    function performInsertStep() {
        if (currentElementIndex >= elementsToInsert.length) {
            // All elements inserted
            explanation.innerHTML = `<strong>Insert Sorted Completed!</strong> All ${elementsToInsert.length} elements inserted while maintaining order.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Insert sorted operation completed successfully
                </div>
            `;
            
            // Highlight all new elements
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            setTimeout(() => {
                for (let i = 0; i < transformedElements.length; i++) {
                    if (currentArray.includes(elementsToInsert.find(el => el === currentArray[i]))) {
                        transformedElements[i].querySelector('.element-value').classList.add('create', 'bounce');
                    }
                }
            }, 500);
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterInsertSorted();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterInsertSorted);
            
            return;
        }
        
        totalSteps++;
        const elementToInsert = elementsToInsert[currentElementIndex];
        
        if (!isSorted && currentElementIndex === 0) {
            // First element and array is not sorted - sort the array first
            explanation.innerHTML = `Step ${totalSteps}: Array is not sorted. Sorting array first...`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${totalSteps}:</strong> Array not sorted - performing sort first
                </div>
            `;
            
            // Sort the array
            if (isNumeric) {
                currentArray.sort((a, b) => parseFloat(a) - parseFloat(b));
            } else {
                currentArray.sort();
            }
            
            // Update transformed array
            setTimeout(() => {
                renderArrayInContainer(currentArray, 'transformedInsertSortedArray');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Sort Complete:</strong> Array is now sorted
                    </div>
                `;
                
                isSorted = true;
                performInsertStep();
            }, 2000);
            
            return;
        }
        
        explanation.innerHTML = `Step ${totalSteps}: Finding position to insert "${elementToInsert}"`;
        
        // Show the element to insert
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${totalSteps}:</strong> Inserting element: "${elementToInsert}"
            </div>
        `;
        
        // Create a visual representation of the element to insert
        const newElementDiv = document.createElement('div');
        newElementDiv.className = 'array-element';
        newElementDiv.innerHTML = `
            <div class="element-value insert-sorted-new-element">${elementToInsert}</div>
            <div class="element-index">New Element</div>
        `;
        
        const explanationDiv = document.querySelector('.insert-sorted-explanation');
        explanationDiv.appendChild(newElementDiv);
        
        // Find insertion position
        let insertPosition = currentArray.length;
        
        function findInsertionPosition(index) {
            if (index >= currentArray.length) {
                // Insert at end
                insertPosition = currentArray.length;
                performInsertion();
                return;
            }
            
            explanation.innerHTML = `Step ${totalSteps}.${index + 1}: Comparing "${elementToInsert}" with [${index}]="${currentArray[index]}"`;
            
            // Highlight current comparison
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            if (index < transformedElements.length) {
                transformedElements[index].querySelector('.element-value').classList.add('insert-sorted-compared');
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${totalSteps}.${index + 1}:</strong> Compare "${elementToInsert}" with [${index}]="${currentArray[index]}"
                </div>
            `;
            
            // Compare values
            let shouldInsertBefore = false;
            if (isNumeric) {
                const insertVal = parseFloat(elementToInsert);
                const currentVal = parseFloat(currentArray[index]);
                shouldInsertBefore = insertVal <= currentVal;
            } else {
                shouldInsertBefore = elementToInsert <= currentArray[index];
            }
            
            setTimeout(() => {
                // Remove highlight
                if (index < transformedElements.length) {
                    transformedElements[index].querySelector('.element-value').classList.remove('insert-sorted-compared');
                }
                
                if (shouldInsertBefore) {
                    insertPosition = index;
                    performInsertion();
                } else {
                    findInsertionPosition(index + 1);
                }
            }, 1500);
        }
        
        function performInsertion() {
            explanation.innerHTML = `Step ${totalSteps}.Final: Inserting "${elementToInsert}" at position ${insertPosition}`;
            
            // Highlight insertion position
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            if (insertPosition < transformedElements.length) {
                transformedElements[insertPosition].querySelector('.element-value').classList.add('insert-sorted-position');
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${totalSteps}.Final:</strong> Inserting at position ${insertPosition}
                </div>
            `;
            
            setTimeout(() => {
                // Remove the new element visual
                newElementDiv.remove();
                
                // Perform insertion
                currentArray.splice(insertPosition, 0, elementToInsert);
                
                // Update transformed array
                renderArrayInContainer(currentArray, 'transformedInsertSortedArray');
                
                // Highlight the newly inserted element
                const updatedElements = transformedContainer.querySelectorAll('.array-element');
                updatedElements[insertPosition].querySelector('.element-value').classList.add('create', 'bounce');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Inserted:</strong> "${elementToInsert}" successfully inserted at position ${insertPosition}
                    </div>
                `;
                
                // Move to next element
                currentElementIndex++;
                performInsertStep();
            }, 2000);
        }
        
        // Start finding insertion position
        findInsertionPosition(0);
    }
    
    // Start insert sorted process
    performInsertStep();
}

// NEW: Return to Original after Insert Sorted
function returnToOriginalAfterInsertSorted() {
    // Reset to original array
    myArray = [...originalArrayForInsertSorted];
    originalArrayForInsertSorted = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isInsertSortedRunning = false;
    
    // Clear all insert sorted data
    insertSortedElements = [];
    insertSortedCount = 0;
    
    logOperation('Insert sorted operation completed - returned to original array', 'info');
    showNotification('Returned to original array after insert sorted operation', 'success');
}
// Helper function to render array in specific container
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = `
            <div class="array-empty-state">
                <i class="fas fa-layer-group"></i>
                <h4>Array is Empty</h4>
                <p>Add some elements to get started!</p>
            </div>
        `;
        return;
    }
    
    array.forEach((value, index) => {
        const elementDiv = document.createElement('div');
        elementDiv.className = 'array-element';
        elementDiv.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(elementDiv);
    });
}
// NEW: Generate Random Array Handler
function handleGenerateRandomArray() {
    const size = parseInt(randomArraySize.value);
    
    // Validation
    if (isNaN(size) || size < 1) {
        // Show error message in red color
        searchResults.innerHTML = `
            <div class="alert alert-danger">
                <i class="fas fa-exclamation-triangle me-2"></i>
                <strong>Error:</strong> Array size must be a positive number ( 1). 
                Negative numbers and 0 are not accepted.
            </div>
        `;
        showNotification('Invalid array size! Please enter a positive number  1', 'danger');
        logOperation('Attempted to generate random array with invalid size - failed', 'danger');
        randomArraySize.focus();
        return;
    }
    
    if (size > 100) {
        showNotification('Array size is too large! Maximum allowed is 100', 'warning');
        randomArraySize.focus();
        return;
    }
    
    if (isRandomArrayGenerationRunning) {
        showNotification('Random array generation is already in progress', 'warning');
        return;
    }
    
    isRandomArrayGenerationRunning = true;
    
    // Store original array
    originalArrayBeforeRandom = [...myArray];
    
    // Show random array generation visualization
    showRandomArrayGenerationVisualization(size);
}
// NEW: Show Random Array Generation Visualization
function showRandomArrayGenerationVisualization(size) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Generate Random Array (Size: ${size})</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalRandomArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">New Random Array</div>
            <div class="transformed-array-container" id="transformedRandomArray"></div>
        </div>
        
        <div class="random-array-explanation">
            <p class="mb-2"><strong>Random Generation Process:</strong> Creating array with ${size} random numbers</p>
            <p class="mb-0" id="randomArrayExplanation">Starting random array generation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="randomArrayStepsContainer">
            <h6 class="text-center">Generation Steps</h6>
            <div class="steps-container" id="randomArraySteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterRandomArray" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayBeforeRandom, 'originalRandomArray');
    renderArrayInContainer([], 'transformedRandomArray');
    
    performRandomArrayGeneration(size);
}
// NEW: Perform Random Array Generation with Animation
function performRandomArrayGeneration(size) {
    const originalContainer = document.getElementById('originalRandomArray');
    const transformedContainer = document.getElementById('transformedRandomArray');
    const explanation = document.getElementById('randomArrayExplanation');
    const stepsContainer = document.getElementById('randomArraySteps');
    const continueButton = document.getElementById('continueAfterRandomArray');
    
    const newArray = [];
    let currentStep = 0;
    
    function generateRandomNumber() {
        // Generate random number between -100 and 100 for small numbers initially
        // With 70% probability for small numbers (-20 to 20)
        if (Math.random() < 0.7) {
            return Math.floor(Math.random() * 41) - 20; // -20 to 20
        } else {
            // 30% probability for larger numbers
            const isPositive = Math.random() < 0.5;
            const base = Math.floor(Math.random() * 100) + 1; // 1 to 100
            const exponent = Math.floor(Math.random() * 3) + 1; // 1 to 3 (small exponents)
            const value = base * Math.pow(10, exponent);
            return isPositive ? value : -value;
        }
    }
    
    function performGenerationStep() {
        if (currentStep >= size) {
            // Generation completed
            explanation.innerHTML = `<strong>Random Array Generation Completed!</strong> Created array with ${size} random numbers.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Random array generation completed! Array: [${newArray.join(', ')}]
                </div>
            `;
            
            // Highlight all generated elements
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('random-generated');
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return to original after 8 seconds
            setTimeout(() => {
                returnToOriginalAfterRandomGeneration();
            }, 8000);
            
            continueButton.addEventListener('click', returnToOriginalAfterRandomGeneration);
            
            return;
        }
        
        const stepNumber = currentStep + 1;
        
        // Generate random number
        const randomNum = generateRandomNumber();
        newArray.push(randomNum);
        
        // Update explanation
        explanation.innerHTML = `Step ${stepNumber}: Generated random number ${randomNum} for position ${currentStep}`;
        
        // Add step to steps container
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${stepNumber}:</strong> Generated random number: ${randomNum} at index ${currentStep}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Update transformed array display
        renderArrayInContainer(newArray, 'transformedRandomArray');
        
        // Highlight the newly added element
        setTimeout(() => {
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            if (transformedElements[currentStep]) {
                const newElement = transformedElements[currentStep].querySelector('.element-value');
                newElement.classList.add('random-generated');
                
                // Remove highlight after animation
                setTimeout(() => {
                    newElement.classList.remove('random-generated');
                }, 1000);
            }
            
            currentStep++;
            performGenerationStep();
        }, 800);
    }
    
    // Start generation process
    performGenerationStep();
}
// NEW: Return to Original after Random Generation
function returnToOriginalAfterRandomGeneration() {
    // Apply the new random array
    const size = parseInt(randomArraySize.value);
    const finalArray = [];
    
    // Regenerate the same random numbers for consistency
    function generateRandomNumber() {
        if (Math.random() < 0.7) {
            return Math.floor(Math.random() * 41) - 20;
        } else {
            const isPositive = Math.random() < 0.5;
            const base = Math.floor(Math.random() * 100) + 1;
            const exponent = Math.floor(Math.random() * 3) + 1;
            const value = base * Math.pow(10, exponent);
            return isPositive ? value : -value;
        }
    }
    
    for (let i = 0; i < size; i++) {
        finalArray.push(generateRandomNumber().toString());
    }
    
    myArray = finalArray;
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Clear input
    randomArraySize.value = '';
    
    // Reset state
    isRandomArrayGenerationRunning = false;
    
    // Show success message
    searchResults.innerHTML = `
        <div class="alert alert-success">
            <i class="fas fa-check-circle me-2"></i>
            <strong>Success:</strong> Random array generated with ${size} elements
        </div>
    `;
    
    logOperation(`Generated random array with ${size} elements`, 'success');
    showNotification(`Random array with ${size} elements generated successfully`, 'success');
    
    // Auto-reset after 10 seconds
    setTimeout(() => {
        resetAfterRandomGeneration();
    }, 10000);
}

// NEW: Reset after Random Generation
function resetAfterRandomGeneration() {
    if (originalArrayBeforeRandom.length === 0) {
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayBeforeRandom];
    originalArrayBeforeRandom = [];
    
    renderArray();
    updateStats();
    
    logOperation('Reset to original array after random generation', 'info');
    showNotification('Automatically reset to original array', 'info');
}
// NEW: Convert to Char Array Handler
function handleConvertToCharArray() {
    if (isCharArrayConversionRunning) {
        showNotification('Char array conversion is already in progress', 'warning');
        return;
    }
    
    // Show input group
    stringInputGroup.style.display = 'block';
    inputString.focus();
    
    logOperation('Started string to char array conversion', 'info');
}

// NEW: Confirm String Handler
function handleConfirmString() {
    const inputStr = inputString.value.trim();
    
    if (inputStr === '') {
        showNotification('Please enter a string to convert', 'danger');
        inputString.focus();
        return;
    }
    
    if (inputStr.length > 50) {
        showNotification('String too long. Please enter a string with 50 characters or less.', 'warning');
        inputString.focus();
        return;
    }
    
    // Store original array
    originalArrayForCharConversion = [...myArray];
    
    // Hide input group
    stringInputGroup.style.display = 'none';
    inputString.value = '';
    
    // Start char array conversion visualization
    showCharArrayConversion(inputStr);
}

// NEW: Cancel String Handler
function handleCancelString() {
    stringInputGroup.style.display = 'none';
    inputString.value = '';
    
    logOperation('Cancelled char array conversion', 'info');
}

// NEW: Show Char Array Conversion Visualization
function showCharArrayConversion(inputStr) {
    isCharArrayConversionRunning = true;
    
    const conversionContainer = document.createElement('div');
    conversionContainer.className = 'dual-operation-container';
    conversionContainer.innerHTML = `
        <h5 class="text-center mb-3">String to Char Array Conversion</h5>
        
        <div class="array-group">
            <div class="array-label">Original String</div>
            <div class="string-display" id="originalStringDisplay">"${inputStr}"</div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Character Array</div>
            <div class="char-array-container" id="charArrayDisplay"></div>
        </div>
        
        <div class="conversion-explanation">
            <p class="mb-2"><strong>Conversion Process:</strong> Converting string to array of characters</p>
            <p class="mb-0" id="conversionExplanation">Starting conversion process...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="conversionStepsContainer">
            <h6 class="text-center">Conversion Steps</h6>
            <div class="steps-container" id="conversionSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterConversion" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(conversionContainer);
    
    performCharArrayConversion(inputStr);
}

// NEW: Perform Char Array Conversion with Animation
function performCharArrayConversion(inputStr) {
    const charArrayDisplay = document.getElementById('charArrayDisplay');
    const explanation = document.getElementById('conversionExplanation');
    const stepsContainer = document.getElementById('conversionSteps');
    const continueButton = document.getElementById('continueAfterConversion');
    
    const chars = [];
    let currentIndex = 0;
    let step = 0;
    
    // Clear the display container and set up horizontal layout
    charArrayDisplay.innerHTML = '';
    charArrayDisplay.style.display = 'flex';
    charArrayDisplay.style.flexWrap = 'wrap';
    charArrayDisplay.style.justifyContent = 'center';
    charArrayDisplay.style.alignItems = 'flex-end';
    
    function performConversionStep() {
        if (currentIndex >= inputStr.length) {
            // Conversion completed
            explanation.innerHTML = `<strong>Conversion Completed!</strong> String converted to ${chars.length} characters.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> String "${inputStr}" converted to char array: [${chars.map(c => `'${c}'`).join(', ')}]
                </div>
            `;
            
            // Update the actual array
            myArray = [...chars];
            updateStats();
            
            // Show success message and highlight the entire array
            setTimeout(() => {
                // Highlight all characters in the array
                const charWrappers = charArrayDisplay.querySelectorAll('.char-element-wrapper');
                charWrappers.forEach((wrapper, index) => {
                    setTimeout(() => {
                        const charElement = wrapper.querySelector('.char-element');
                        charElement.classList.add('highlight', 'bounce');
                    }, index * 100);
                });
                
                continueButton.style.display = 'block';
                
                // Auto-return after 5 seconds
                setTimeout(() => {
                    returnToOriginalAfterConversion();
                }, 5000);
                
                continueButton.addEventListener('click', returnToOriginalAfterConversion);
            }, 1000);
            
            return;
        }
        
        step++;
        const currentChar = inputStr[currentIndex];
        const charCode = inputStr.charCodeAt(currentIndex);
        
        // Update explanation
        explanation.innerHTML = `Step ${step}: Processing character at position ${currentIndex} - '${currentChar}' (ASCII: ${charCode})`;
        
        // Create character element with wrapper for horizontal layout
        const charWrapper = document.createElement('div');
        charWrapper.className = 'char-element-wrapper';
        charWrapper.innerHTML = `
            <div class="char-element ${currentChar === ' ' ? 'space-char' : /[^a-zA-Z0-9]/.test(currentChar) ? 'special-char' : ''}">
                ${currentChar === ' ' ? '' : currentChar}
            </div>
            <div class="char-index">[${currentIndex}]</div>
            <div class="char-code">ASCII: ${charCode}</div>
        `;
        
        // Add to display with animation
        charArrayDisplay.appendChild(charWrapper);
        
        // Animate the new character
        setTimeout(() => {
            const valueDiv = charWrapper.querySelector('.char-element');
            valueDiv.classList.add('highlight', 'slide-in');
            
            // Add to chars array
            chars.push(currentChar);
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Character '${currentChar === ' ' ? '' : currentChar}' (ASCII: ${charCode}) added to array at index ${currentIndex}
                </div>
            `;
            
            // Scroll steps container to bottom
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            // Remove highlight after animation but keep the slide-in effect
            setTimeout(() => {
                valueDiv.classList.remove('highlight');
            }, 1000);
            
            currentIndex++;
            setTimeout(performConversionStep, 800); // Increased delay for better visualization
        }, 100);
    }
    
    // Start conversion process
    performConversionStep();
}
// NEW: Return to Original after Conversion
function returnToOriginalAfterConversion() {
    // Reset to original array
    myArray = [...originalArrayForCharConversion];
    originalArrayForCharConversion = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isCharArrayConversionRunning = false;
    
    logOperation('Char array conversion completed - returned to original array', 'info');
    showNotification('Returned to original array after char array conversion', 'success');
}
// Initialize event listeners
function initializeEventListeners() {
    customComparatorSortBtn.addEventListener('click', handleCustomComparatorSort);
    createDictionaryBtn.addEventListener('click', handleCreateDictionary);
    confirmFieldCountBtn.addEventListener('click', handleConfirmFieldCount);
    addRecordBtn.addEventListener('click', handleAddRecord);
    finishDataEntryBtn.addEventListener('click', handleFinishDataEntry);
    updateDictionaryBtn.addEventListener('click', handleUpdateDictionary);
    dropDictionaryBtn.addEventListener('click', handleDropDictionary);
    performSortBtn.addEventListener('click', handlePerformSort);
    resetAfterSortBtn.addEventListener('click', handleResetAfterSort);
    cancelCustomSortBtn.addEventListener('click', handleCancelCustomSort);
}
// ENHANCED: Improved event delegation
function setupEventDelegation() {
    // Use document as the delegation point to handle dynamically created elements
    document.addEventListener('click', function(e) {
        const target = e.target;
        
        // Handle edit button clicks
        if (target.closest('.edit-record')) {
            const button = target.closest('.edit-record');
            const index = parseInt(button.getAttribute('data-index'));
            console.log('Edit button clicked for index:', index);
            if (!isNaN(index)) {
                handleEditRecord(index);
            }
            return;
        }
        
        // Handle delete button clicks
        if (target.closest('.delete-record')) {
            const button = target.closest('.delete-record');
            const index = parseInt(button.getAttribute('data-index'));
            console.log('Delete button clicked for index:', index);
            if (!isNaN(index)) {
                handleDeleteRecord(index);
            }
            return;
        }
        
        // Handle inline edit field clicks
        if (target.classList.contains('editable-field')) {
            const td = target;
            const fieldName = td.getAttribute('data-field');
            const recordIndex = parseInt(td.getAttribute('data-index'));
            console.log('Field clicked for editing:', fieldName, 'index:', recordIndex);
            if (!isNaN(recordIndex)) {
                startEditField(td, fieldName, recordIndex);
            }
            return;
        }
    });
}

// MODIFIED: Update the DOMContentLoaded event listener
document.addEventListener('DOMContentLoaded', function() {
    initializeEventListeners();
    initializeTableReferences(); // Initialize table references first
    setupEventDelegation();
});
// ENHANCED: Improved initialization to ensure table references are set
function initializeTableReferences() {
    // Initialize global table element references
    window.dictionaryTableHeader = document.getElementById('dictionaryTableHeader');
    window.dictionaryTableBody = document.getElementById('dictionaryTableBody');
    window.dictionaryTableContainer = document.getElementById('dictionaryTableContainer');
    
    console.log('Table references initialized:', {
        header: !!dictionaryTableHeader,
        body: !!dictionaryTableBody,
        container: !!dictionaryTableContainer
    });
    
    // If table container doesn't exist, create it
    if (!dictionaryTableContainer) {
        console.error('Dictionary table container not found!');
        // You might want to create it dynamically or show an error
    }
}

// NEW: Custom Comparator Sort Handler
function handleCustomComparatorSort() {
    if (isCustomSortRunning) {
        showNotification('Custom comparator sort is already in progress', 'warning');
        return;
    }

    isCustomSortRunning = true;
    customComparatorContainer.style.display = 'block';
    
    // Reset dictionary
    currentDictionary = {
        name: '',
        fields: [],
        data: [],
        originalData: []
    };
    
    // Show only dictionary creation section initially
    dictionaryStructureSection.style.display = 'none';
    dataEntrySection.style.display = 'none';
    dictionaryOperationsSection.style.display = 'none';
    dictionaryDisplaySection.style.display = 'none';
    sortVisualizationSection.style.display = 'none';
    
    logOperation('Started custom comparator sort operation', 'info');
}

// NEW: Create Dictionary Handler
function handleCreateDictionary() {
    const name = dictionaryName.value.trim();
    
    if (name === '') {
        showNotification('Please enter a dictionary name', 'danger');
        dictionaryName.focus();
        return;
    }
    
    currentDictionary.name = name;
    
    // Show structure section
    dictionaryStructureSection.style.display = 'block';
    fieldCount.focus();
    
    showNotification(`Dictionary "${name}" created. Now define the structure.`, 'success');
    logOperation(`Created dictionary "${name}"`, 'success');
}

// NEW: Confirm Field Count Handler
function handleConfirmFieldCount() {
    const count = parseInt(fieldCount.value);
    
    if (isNaN(count) || count < 1 || count > 10) {
        showNotification('Please enter a valid number of fields between 1 and 10', 'danger');
        fieldCount.focus();
        return;
    }
    
    // Clear previous field definitions
    fieldDefinitions.innerHTML = '';
    currentDictionary.fields = [];
    
    // Create field definition inputs
    for (let i = 0; i < count; i++) {
        const fieldGroup = document.createElement('div');
        fieldGroup.className = 'row mb-3';
        fieldGroup.innerHTML = `
            <div class="col-md-4">
                <label class="form-label">Field ${i + 1} Name</label>
                <input type="text" class="form-control field-name" placeholder="Enter field name" data-index="${i}">
            </div>
            <div class="col-md-4">
                <label class="form-label">Field ${i + 1} Data Type</label>
                <select class="form-control field-type" data-index="${i}">
                    <option value="string">String</option>
                    <option value="int">Integer</option>
                    <option value="float">Float</option>
                </select>
            </div>
            <div class="col-md-4">
                <label class="form-label">Sample Value</label>
                <input type="text" class="form-control field-sample" placeholder="Sample value" data-index="${i}">
            </div>
        `;
        fieldDefinitions.appendChild(fieldGroup);
    }
    
    // Add confirm button
    const confirmButton = document.createElement('button');
    confirmButton.className = 'btn btn-glow mt-2';
    confirmButton.innerHTML = '<i class="fas fa-check me-2"></i>Confirm Field Definitions';
    confirmButton.addEventListener('click', handleConfirmFieldDefinitions);
    fieldDefinitions.appendChild(confirmButton);
    
    showNotification(`Defined ${count} fields for dictionary`, 'info');
}

// NEW: Confirm Field Definitions Handler
function handleConfirmFieldDefinitions() {
    const fieldNames = document.querySelectorAll('.field-name');
    const fieldTypes = document.querySelectorAll('.field-type');
    const fieldSamples = document.querySelectorAll('.field-sample');
    
    currentDictionary.fields = [];
    
    for (let i = 0; i < fieldNames.length; i++) {
        const name = fieldNames[i].value.trim();
        const type = fieldTypes[i].value;
        const sample = fieldSamples[i].value.trim();
        
        if (name === '') {
            showNotification(`Please enter name for field ${i + 1}`, 'danger');
            fieldNames[i].focus();
            return;
        }
        
        if (sample === '') {
            showNotification(`Please enter sample value for field ${i + 1}`, 'danger');
            fieldSamples[i].focus();
            return;
        }
        
        currentDictionary.fields.push({
            name: name,
            type: type,
            sample: sample
        });
    }
    
    // Show data entry section
    dataEntrySection.style.display = 'block';
    createDataEntryForm();
    
    showNotification('Field definitions confirmed. Now add data records.', 'success');
    logOperation(`Defined ${currentDictionary.fields.length} fields for dictionary`, 'info');
}

// NEW: Create Data Entry Form
function createDataEntryForm() {
    dataEntryForm.innerHTML = '';
    
    currentDictionary.fields.forEach((field, index) => {
        const fieldGroup = document.createElement('div');
        fieldGroup.className = 'row mb-2';
        fieldGroup.innerHTML = `
            <div class="col-md-12">
                <label class="form-label">${field.name} (${field.type})</label>
                <input type="text" class="form-control data-field" 
                       data-field="${field.name}" data-type="${field.type}"
                       placeholder="Enter ${field.type} value" 
                       value="${field.sample}">
            </div>
        `;
        dataEntryForm.appendChild(fieldGroup);
    });
}

// NEW: Add Record Handler
function handleAddRecord() {
    const dataFields = document.querySelectorAll('.data-field');
    const record = {};
    let isValid = true;
    
    currentDictionary.fields.forEach(field => {
        const fieldInput = document.querySelector(`.data-field[data-field="${field.name}"]`);
        const value = fieldInput.value.trim();
        
        if (value === '') {
            showNotification(`Please enter value for ${field.name}`, 'danger');
            fieldInput.focus();
            isValid = false;
            return;
        }
        
        // Validate data type
        if (field.type === 'int') {
            if (!/^-?\d+$/.test(value)) {
                showNotification(`${field.name} must be an integer`, 'danger');
                fieldInput.focus();
                isValid = false;
                return;
            }
            record[field.name] = parseInt(value);
        } else if (field.type === 'float') {
            if (!/^-?\d*\.?\d+$/.test(value)) {
                showNotification(`${field.name} must be a float`, 'danger');
                fieldInput.focus();
                isValid = false;
                return;
            }
            record[field.name] = parseFloat(value);
        } else {
            record[field.name] = value;
        }
    });
    
    if (!isValid) return;
    
    // Add record to dictionary
    currentDictionary.data.push(record);
    
    // Clear form
    dataFields.forEach(field => {
        field.value = '';
    });
    
    showNotification('Record added successfully', 'success');
    logOperation(`Added record to dictionary "${currentDictionary.name}"`, 'success');
    
    // Update display if data entry is finished
    if (dictionaryDisplaySection.style.display !== 'none') {
        updateDictionaryDisplay();
    }
}

// MODIFIED: Update the finishDataEntryHandler
function handleFinishDataEntry() {
    if (currentDictionary.data.length === 0) {
        showNotification('Please add at least one record before finishing', 'warning');
        return;
    }
    
    // Store original data for reset
    currentDictionary.originalData = JSON.parse(JSON.stringify(currentDictionary.data));
    
    // Show operations and display sections
    dictionaryOperationsSection.style.display = 'block';
    dictionaryDisplaySection.style.display = 'block';
    
    // Create table structure if it doesn't exist
    if (!document.getElementById('dictionaryTableHeader')) {
        dictionaryTableContainer.innerHTML = `
            <table class="dictionary-table table table-striped table-hover">
                <thead class="table-dark">
                    <tr id="dictionaryTableHeader"></tr>
                </thead>
                <tbody id="dictionaryTableBody"></tbody>
            </table>
        `;
    }
    
    // Populate sort field select
    sortFieldSelect.innerHTML = '';
    currentDictionary.fields.forEach(field => {
        const option = document.createElement('option');
        option.value = field.name;
        option.textContent = field.name;
        sortFieldSelect.appendChild(option);
    });
    
    // Update display
    updateDictionaryDisplay();
    
    showNotification('Data entry completed. Dictionary is ready for operations.', 'success');
    logOperation(`Completed data entry for dictionary "${currentDictionary.name}" with ${currentDictionary.data.length} records`, 'info');
}

// NEW: Update Dictionary Display
function updateDictionaryDisplay() {
    console.log('Updating dictionary display with data:', currentDictionary.data);
    
    // Update table header
    dictionaryTableHeader.innerHTML = '';
    currentDictionary.fields.forEach(field => {
        const th = document.createElement('th');
        th.textContent = field.name;
        dictionaryTableHeader.appendChild(th);
    });
    
    // Add actions column header
    const actionsTh = document.createElement('th');
    actionsTh.textContent = 'Actions';
    actionsTh.style.width = '120px';
    dictionaryTableHeader.appendChild(actionsTh);
    
    // Update table body
    dictionaryTableBody.innerHTML = '';
    
    if (currentDictionary.data.length === 0) {
        const emptyRow = document.createElement('tr');
        const emptyCell = document.createElement('td');
        emptyCell.colSpan = currentDictionary.fields.length + 1;
        emptyCell.textContent = 'No records found';
        emptyCell.className = 'text-center text-muted py-3';
        emptyRow.appendChild(emptyCell);
        dictionaryTableBody.appendChild(emptyRow);
    } else {
        currentDictionary.data.forEach((record, index) => {
            const tr = document.createElement('tr');
            tr.setAttribute('data-index', index);
            
            currentDictionary.fields.forEach(field => {
                const td = document.createElement('td');
                td.className = 'editable-field';
                td.setAttribute('data-field', field.name);
                td.setAttribute('data-index', index);
                td.textContent = record[field.name] || '';
                tr.appendChild(td);
            });
            
            // Add actions column
            const actionsTd = document.createElement('td');
            actionsTd.className = 'action-buttons';
            actionsTd.innerHTML = `
                <button class="btn btn-sm btn-outline-warning edit-record" data-index="${index}">
                    <i class="fas fa-edit"></i>
                </button>
                <button class="btn btn-sm btn-outline-danger delete-record" data-index="${index}">
                    <i class="fas fa-trash"></i>
                </button>
            `;
            tr.appendChild(actionsTd);
            
            dictionaryTableBody.appendChild(tr);
        });
    }
    
    console.log('Dictionary display updated successfully');
}

// NEW: Start Edit Field (Inline Editing)
function startEditField(td, fieldName, recordIndex) {
    if (isEditingRecord) {
        console.log('Already editing a record, please finish current edit first');
        return;
    }
    
    console.log('Starting inline edit for field:', fieldName, 'record:', recordIndex);
    
    const currentValue = td.textContent;
    const field = currentDictionary.fields.find(f => f.name === fieldName);
    
    if (!field) {
        console.error('Field not found:', fieldName);
        return;
    }
    
    td.innerHTML = `<input type="text" class="form-control form-control-sm inline-edit" 
                          value="${currentValue}" data-field="${fieldName}" data-index="${recordIndex}">`;
    
    const input = td.querySelector('.inline-edit');
    input.focus();
    input.select();
    
    const finishEdit = () => finishEditField(input, field, recordIndex);
    const cancelEdit = () => {
        td.textContent = currentValue;
        isEditingRecord = false;
    };
    
    input.addEventListener('blur', finishEdit);
    input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            finishEdit();
        } else if (e.key === 'Escape') {
            cancelEdit();
        }
    });
    
    isEditingRecord = true;
}

// NEW: Finish Edit Field
function finishEditField(input, field, recordIndex) {
    const newValue = input.value.trim();
    const td = input.parentElement;
    
    if (newValue === '') {
        td.textContent = currentDictionary.data[recordIndex][field.name];
        isEditingRecord = false;
        return;
    }
    
    // Validate data type
    let validatedValue = newValue;
    if (field.type === 'int') {
        if (!/^-?\d+$/.test(newValue)) {
            showNotification(`${field.name} must be an integer`, 'danger');
            td.textContent = currentDictionary.data[recordIndex][field.name];
            isEditingRecord = false;
            return;
        }
        validatedValue = parseInt(newValue);
    } else if (field.type === 'float') {
        if (!/^-?\d*\.?\d+$/.test(newValue)) {
            showNotification(`${field.name} must be a float`, 'danger');
            td.textContent = currentDictionary.data[recordIndex][field.name];
            isEditingRecord = false;
            return;
        }
        validatedValue = parseFloat(newValue);
    }
    
    // Update record
    currentDictionary.data[recordIndex][field.name] = validatedValue;
    td.textContent = validatedValue;
    
    showNotification(`Field "${field.name}" updated successfully`, 'success');
    logOperation(`Updated field "${field.name}" in record ${recordIndex}`, 'info');
    isEditingRecord = false;
}

// NEW: Edit Record Handler
function handleEditRecord(index) {
    console.log('Edit record handler called for index:', index);
    
    if (isEditingRecord) {
        showNotification('Please finish current edit before starting a new one', 'warning');
        return;
    }
    
    if (index < 0 || index >= currentDictionary.data.length) {
        showNotification('Invalid record index', 'danger');
        return;
    }
    
    isEditingRecord = true;
    editingRecordIndex = index;
    
    const record = currentDictionary.data[index];
    console.log('Editing record:', record);
    
    // Create edit form
    const editForm = document.createElement('div');
    editForm.className = 'edit-form-container';
    editForm.innerHTML = `
        <h6>Edit Record ${index}</h6>
        <div class="preview-highlight p-3 mb-3">
            <strong>Current Data:</strong><br>
            ${Object.entries(record).map(([key, value]) => `${key}: ${value}`).join('<br>')}
        </div>
        <div id="editRecordForm"></div>
        <div class="d-flex gap-2 mt-3">
            <button class="btn btn-glow" id="saveRecordBtn">
                <i class="fas fa-save me-2"></i>Save Changes
            </button>
            <button class="btn btn-outline-light" id="cancelEditBtn">
                <i class="fas fa-times me-2"></i>Cancel
            </button>
        </div>
    `;
    
    // Replace table with edit form temporarily
    const tableContainer = dictionaryDisplaySection.querySelector('.table-container');
    const originalTable = tableContainer.innerHTML;
    tableContainer.innerHTML = '';
    tableContainer.appendChild(editForm);
    
    // Create edit form fields
    const editRecordForm = document.getElementById('editRecordForm');
    currentDictionary.fields.forEach(field => {
        const fieldGroup = document.createElement('div');
        fieldGroup.className = 'mb-3';
        fieldGroup.innerHTML = `
            <label class="form-label">${field.name} (${field.type})</label>
            <input type="text" class="form-control edit-field" 
                   data-field="${field.name}" 
                   value="${record[field.name] || ''}">
        `;
        editRecordForm.appendChild(fieldGroup);
    });
    
    // Add event listeners
    document.getElementById('saveRecordBtn').addEventListener('click', handleSaveRecord);
    document.getElementById('cancelEditBtn').addEventListener('click', () => {
        tableContainer.innerHTML = originalTable;
        updateDictionaryDisplay();
        isEditingRecord = false;
        editingRecordIndex = -1;
        showNotification('Edit cancelled', 'info');
    });
}

// NEW: Save Record Handler
// NEW: Save Record Handler (Alternative robust version)
function handleSaveRecord() {
    console.log('Save record handler called');
    
    const editFields = document.querySelectorAll('.edit-field');
    const updatedRecord = {};
    let isValid = true;
    
    currentDictionary.fields.forEach(field => {
        const fieldInput = document.querySelector(`.edit-field[data-field="${field.name}"]`);
        const value = fieldInput.value.trim();
        
        if (value === '') {
            showNotification(`Please enter value for ${field.name}`, 'danger');
            fieldInput.focus();
            isValid = false;
            return;
        }
        
        // Validate data type
        if (field.type === 'int') {
            if (!/^-?\d+$/.test(value)) {
                showNotification(`${field.name} must be an integer`, 'danger');
                fieldInput.focus();
                isValid = false;
                return;
            }
            updatedRecord[field.name] = parseInt(value);
        } else if (field.type === 'float') {
            if (!/^-?\d*\.?\d+$/.test(value)) {
                showNotification(`${field.name} must be a float`, 'danger');
                fieldInput.focus();
                isValid = false;
                return;
            }
            updatedRecord[field.name] = parseFloat(value);
        } else {
            updatedRecord[field.name] = value;
        }
    });
    
    if (!isValid) return;
    
    // Update record
    currentDictionary.data[editingRecordIndex] = updatedRecord;
    
    // Simply restore the original table structure without complex HTML manipulation
    const tableContainer = dictionaryDisplaySection.querySelector('.table-container');
    
    // Create a fresh table
    tableContainer.innerHTML = `
        <table class="dictionary-table" id="dictionaryTable">
            <thead>
                <tr id="dictionaryTableHeader"></tr>
            </thead>
            <tbody id="dictionaryTableBody"></tbody>
        </table>
    `;
    
    // Get fresh references to the table elements
    const newHeader = document.getElementById('dictionaryTableHeader');
    const newBody = document.getElementById('dictionaryTableBody');
    
    // Update the display manually without relying on global variables
    updateTableDisplay(newHeader, newBody);
    
    isEditingRecord = false;
    editingRecordIndex = -1;
    
    showNotification('Record updated successfully', 'success');
    logOperation(`Updated record ${editingRecordIndex} in dictionary`, 'success');
}

// Helper function to update table display without relying on global variables
function updateTableDisplay(headerElement, bodyElement) {
    console.log('Updating table display with data:', currentDictionary.data);
    
    // Update table header
    headerElement.innerHTML = '';
    currentDictionary.fields.forEach(field => {
        const th = document.createElement('th');
        th.textContent = field.name;
        headerElement.appendChild(th);
    });
    
    // Add actions column header
    const actionsTh = document.createElement('th');
    actionsTh.textContent = 'Actions';
    actionsTh.style.width = '120px';
    headerElement.appendChild(actionsTh);
    
    // Update table body
    bodyElement.innerHTML = '';
    
    if (currentDictionary.data.length === 0) {
        const emptyRow = document.createElement('tr');
        const emptyCell = document.createElement('td');
        emptyCell.colSpan = currentDictionary.fields.length + 1;
        emptyCell.textContent = 'No records found';
        emptyCell.className = 'text-center text-muted py-3';
        emptyRow.appendChild(emptyCell);
        bodyElement.appendChild(emptyRow);
    } else {
        currentDictionary.data.forEach((record, index) => {
            const tr = document.createElement('tr');
            tr.setAttribute('data-index', index);
            
            currentDictionary.fields.forEach(field => {
                const td = document.createElement('td');
                td.className = 'editable-field';
                td.setAttribute('data-field', field.name);
                td.setAttribute('data-index', index);
                td.textContent = record[field.name] || '';
                tr.appendChild(td);
            });
            
            // Add actions column
            const actionsTd = document.createElement('td');
            actionsTd.className = 'action-buttons';
            actionsTd.innerHTML = `
                <button class="btn btn-sm btn-outline-warning edit-record" data-index="${index}">
                    <i class="fas fa-edit"></i>
                </button>
                <button class="btn btn-sm btn-outline-danger delete-record" data-index="${index}">
                    <i class="fas fa-trash"></i>
                </button>
            `;
            tr.appendChild(actionsTd);
            
            bodyElement.appendChild(tr);
        });
    }
    
    console.log('Table display updated successfully');
}

// WORKING: Delete Record Handler with guaranteed event handling
function handleDeleteRecord(index) {
    console.log('Delete record handler called for index:', index);
    
    if (index < 0 || index >= currentDictionary.data.length) {
        showNotification('Invalid record index', 'danger');
        return;
    }
    
    const record = currentDictionary.data[index];
    const recordSummary = Object.entries(record).map(([key, value]) => `${key}: ${value}`).join(', ');
    
    // Create overlay
    const overlay = document.createElement('div');
    overlay.className = 'confirmation-overlay';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
    `;
    
    // Create confirmation dialog
    const confirmation = document.createElement('div');
    confirmation.className = 'confirmation-dialog bg-dark p-4 rounded border border-warning';
    confirmation.style.cssText = `
        max-width: 500px;
        width: 90%;
        box-shadow: 0 0 30px rgba(255,193,7,0.3);
    `;
    
    // Create the HTML content
    confirmation.innerHTML = `
        <h6 class="text-warning mb-3">
            <i class="fas fa-exclamation-triangle me-2"></i>Confirm Deletion
        </h6>
        <p class="text-light mb-2">Are you sure you want to delete this record?</p>
        <div class="preview-highlight p-3 mb-3 bg-secondary text-light rounded">
            <strong class="text-warning">Record Details:</strong><br>
            ${recordSummary}
        </div>
        <div class="d-flex gap-2 justify-content-center">
            <button class="btn btn-danger flex-fill" id="confirmDeleteBtn">
                <i class="fas fa-check me-2"></i>Yes, Delete
            </button>
            <button class="btn btn-outline-light flex-fill" id="cancelDeleteBtn">
                <i class="fas fa-times me-2"></i>No, Cancel
            </button>
        </div>
    `;
    
    // Add to DOM
    overlay.appendChild(confirmation);
    document.body.appendChild(overlay);
    
    // **IMMEDIATELY attach event listeners after adding to DOM**
    const confirmBtn = confirmation.querySelector('#confirmDeleteBtn');
    const cancelBtn = confirmation.querySelector('#cancelDeleteBtn');
    
    // Function to remove overlay and clean up
    function removeOverlay() {
        if (document.body.contains(overlay)) {
            document.body.removeChild(overlay);
        }
    }
    
    // Confirm deletion function
    const onConfirm = () => {
        console.log('User confirmed deletion for record:', index);
        
        // Remove the record from data
        currentDictionary.data.splice(index, 1);
        
        // Remove overlay
        removeOverlay();
        
        // Show success notification
        showNotification('Record deleted successfully', 'success');
        logOperation(`Deleted record ${index} from dictionary`, 'warning');
        
        // Update the display
        updateDictionaryDisplay();
        
        console.log('Record deleted successfully');
    };
    
    // Cancel deletion function
    const onCancel = () => {
        console.log('User cancelled deletion');
        removeOverlay();
        showNotification('Deletion cancelled', 'info');
    };
    
    // Attach event listeners DIRECTLY
    confirmBtn.onclick = onConfirm;
    cancelBtn.onclick = onCancel; // This will now work properly
    
    // Close when clicking outside the dialog
    overlay.onclick = (e) => {
        if (e.target === overlay) {
            onCancel();
        }
    };
    
    // Prevent dialog clicks from closing the overlay
    confirmation.onclick = (e) => {
        e.stopPropagation();
    };
}
// NEW: Function to reinitialize table references
function reinitializeTableReferences() {
    // Re-initialize global table element references
    window.dictionaryTableHeader = document.getElementById('dictionaryTableHeader');
    window.dictionaryTableBody = document.getElementById('dictionaryTableBody');
    window.dictionaryTableContainer = document.getElementById('dictionaryTableContainer');
    
    console.log('Table references reinitialized:', {
        header: !!dictionaryTableHeader,
        body: !!dictionaryTableBody,
        container: !!dictionaryTableContainer
    });
}
// NEW: Simple and reliable table restoration approach
function restoreTableAfterOperation() {
    const container = dictionaryTableContainer;
    if (!container) {
        console.error('Table container not found');
        return;
    }
    
    // Simple table structure
    container.innerHTML = `
        <table class="dictionary-table table table-striped table-hover">
            <thead class="table-dark">
                <tr id="dictionaryTableHeader"></tr>
            </thead>
            <tbody id="dictionaryTableBody"></tbody>
        </table>
    `;
    
    // Re-initialize references
    reinitializeTableReferences();
    
    // Update display
    updateDictionaryDisplay();
}
// NEW: SIMPLE updateDictionaryDisplay function
function updateDictionaryDisplay() {
    console.log('Updating dictionary display with data:', currentDictionary.data);
    
    // Get fresh references to table elements
    const header = document.getElementById('dictionaryTableHeader');
    const body = document.getElementById('dictionaryTableBody');
    
    if (!header || !body) {
        console.error('Table elements not found!');
        return;
    }
    
    // Clear existing content
    header.innerHTML = '';
    body.innerHTML = '';
    
    // Create header
    currentDictionary.fields.forEach(field => {
        const th = document.createElement('th');
        th.textContent = field.name;
        th.setAttribute('data-field', field.name);
        header.appendChild(th);
    });
    
    // Add actions column header
    const actionsTh = document.createElement('th');
    actionsTh.textContent = 'Actions';
    actionsTh.style.width = '120px';
    actionsTh.className = 'text-center';
    header.appendChild(actionsTh);
    
    // Create body rows
    if (currentDictionary.data.length === 0) {
        const emptyRow = document.createElement('tr');
        const emptyCell = document.createElement('td');
        emptyCell.colSpan = currentDictionary.fields.length + 1;
        emptyCell.textContent = 'No records found';
        emptyCell.className = 'text-center text-muted py-4';
        emptyRow.appendChild(emptyCell);
        body.appendChild(emptyRow);
    } else {
        currentDictionary.data.forEach((record, index) => {
            const tr = document.createElement('tr');
            tr.setAttribute('data-index', index);
            
            // Create data cells
            currentDictionary.fields.forEach(field => {
                const td = document.createElement('td');
                td.className = 'editable-field align-middle';
                td.setAttribute('data-field', field.name);
                td.setAttribute('data-index', index);
                td.setAttribute('data-type', field.type);
                td.textContent = record[field.name] || '';
                tr.appendChild(td);
            });
            
            // Create actions cell
            const actionsTd = document.createElement('td');
            actionsTd.className = 'action-buttons text-center align-middle';
            actionsTd.innerHTML = `
                <button class="btn btn-sm btn-outline-warning edit-record me-1" data-index="${index}" title="Edit Record">
                    <i class="fas fa-edit"></i>
                </button>
                <button class="btn btn-sm btn-outline-danger delete-record" data-index="${index}" title="Delete Record">
                    <i class="fas fa-trash"></i>
                </button>
            `;
            tr.appendChild(actionsTd);
            
            body.appendChild(tr);
        });
    }
    
    console.log('Dictionary display updated successfully with', currentDictionary.data.length, 'records');
}

// NEW: Helper function to restore table structure if needed
function restoreTableStructure() {
    const container = dictionaryTableContainer;
    container.innerHTML = `
        <table class="dictionary-table table table-striped table-hover">
            <thead class="table-dark">
                <tr id="dictionaryTableHeader"></tr>
            </thead>
            <tbody id="dictionaryTableBody"></tbody>
        </table>
    `;
    
    // Re-initialize global references
    window.dictionaryTableHeader = document.getElementById('dictionaryTableHeader');
    window.dictionaryTableBody = document.getElementById('dictionaryTableBody');
    
    console.log('Table structure restored');
}


// NEW: Update Dictionary Handler
function handleUpdateDictionary() {
    // Create update form
    const updateForm = document.createElement('div');
    updateForm.className = 'edit-form-container';
    updateForm.innerHTML = `
        <h6>Update Dictionary "${currentDictionary.name}"</h6>
        <div class="mb-3">
            <label class="form-label">Dictionary Name</label>
            <input type="text" class="form-control" id="updateDictionaryName" value="${currentDictionary.name}">
        </div>
        <div id="updateFieldsForm"></div>
        <div class="d-flex gap-2 mt-3">
            <button class="btn btn-glow" id="saveDictionaryBtn">
                <i class="fas fa-save me-2"></i>Save Changes
            </button>
            <button class="btn btn-outline-light" id="cancelUpdateBtn">
                <i class="fas fa-times me-2"></i>Cancel
            </button>
        </div>
    `;
    
    // Replace operations section with update form temporarily
    const operationsSection = dictionaryOperationsSection.innerHTML;
    dictionaryOperationsSection.innerHTML = '';
    dictionaryOperationsSection.appendChild(updateForm);
    
    // Create update fields form
    const updateFieldsForm = document.getElementById('updateFieldsForm');
    currentDictionary.fields.forEach((field, index) => {
        const fieldGroup = document.createElement('div');
        fieldGroup.className = 'row mb-3';
        fieldGroup.innerHTML = `
            <div class="col-md-4">
                <label class="form-label">Field ${index + 1} Name</label>
                <input type="text" class="form-control update-field-name" value="${field.name}" data-index="${index}">
            </div>
            <div class="col-md-4">
                <label class="form-label">Field ${index + 1} Type</label>
                <select class="form-control update-field-type" data-index="${index}">
                    <option value="string" ${field.type === 'string' ? 'selected' : ''}>String</option>
                    <option value="int" ${field.type === 'int' ? 'selected' : ''}>Integer</option>
                    <option value="float" ${field.type === 'float' ? 'selected' : ''}>Float</option>
                </select>
            </div>
        `;
        updateFieldsForm.appendChild(fieldGroup);
    });
    
    // Add event listeners
    document.getElementById('saveDictionaryBtn').addEventListener('click', handleSaveDictionary);
    document.getElementById('cancelUpdateBtn').addEventListener('click', () => {
        dictionaryOperationsSection.innerHTML = operationsSection;
        // Reattach event listeners
        document.getElementById('updateDictionaryBtn').addEventListener('click', handleUpdateDictionary);
        document.getElementById('dropDictionaryBtn').addEventListener('click', handleDropDictionary);
        document.getElementById('performSortBtn').addEventListener('click', handlePerformSort);
    });
}

// NEW: Save Dictionary Handler
function handleSaveDictionary() {
    const newName = document.getElementById('updateDictionaryName').value.trim();
    const fieldNames = document.querySelectorAll('.update-field-name');
    const fieldTypes = document.querySelectorAll('.update-field-type');
    
    if (newName === '') {
        showNotification('Please enter a dictionary name', 'danger');
        return;
    }
    
    // Update dictionary name
    const oldName = currentDictionary.name;
    currentDictionary.name = newName;
    
    // Update fields
    let hasError = false;
    currentDictionary.fields.forEach((field, index) => {
        const newFieldName = fieldNames[index].value.trim();
        const newFieldType = fieldTypes[index].value;
        
        if (newFieldName === '') {
            showNotification(`Please enter name for field ${index + 1}`, 'danger');
            hasError = true;
            return;
        }
        
        // Update field in dictionary structure
        field.name = newFieldName;
        field.type = newFieldType;
        
        // Update field in all records
        if (newFieldName !== field.name) {
            currentDictionary.data.forEach(record => {
                record[newFieldName] = record[field.name];
                delete record[field.name];
            });
        }
    });
    
    if (hasError) return;
    
    // Update sort field select
    sortFieldSelect.innerHTML = '';
    currentDictionary.fields.forEach(field => {
        const option = document.createElement('option');
        option.value = field.name;
        option.textContent = field.name;
        sortFieldSelect.appendChild(option);
    });
    
    // Update display
    updateDictionaryDisplay();
    
    showNotification(`Dictionary "${oldName}" updated to "${newName}" successfully`, 'success');
    logOperation(`Updated dictionary from "${oldName}" to "${newName}"`, 'info');
    
    // Reload the page section to reset event listeners
    handleCancelCustomSort();
    handleCustomComparatorSort();
    // Skip to operations section
    dictionaryStructureSection.style.display = 'none';
    dataEntrySection.style.display = 'none';
    dictionaryOperationsSection.style.display = 'block';
    dictionaryDisplaySection.style.display = 'block';
}

// NEW: Drop Dictionary Handler
function handleDropDictionary() {
    // Create confirmation dialog
    const confirmation = document.createElement('div');
    confirmation.className = 'confirmation-dialog';
    confirmation.innerHTML = `
        <h6><i class="fas fa-exclamation-triangle text-danger me-2"></i>Confirm Dictionary Drop</h6>
        <p>Are you sure you want to drop the entire dictionary "${currentDictionary.name}"?</p>
        <p class="text-warning"><strong>This action cannot be undone!</strong></p>
        <div class="d-flex gap-2 justify-content-center">
            <button class="btn btn-danger" id="confirmDropBtn">
                <i class="fas fa-trash me-2"></i>Yes, Drop Dictionary
            </button>
            <button class="btn btn-outline-light" id="cancelDropBtn">
                <i class="fas fa-times me-2"></i>No, Cancel
            </button>
        </div>
    `;
    
    // Replace operations section with confirmation temporarily
    const operationsSection = dictionaryOperationsSection.innerHTML;
    dictionaryOperationsSection.innerHTML = '';
    dictionaryOperationsSection.appendChild(confirmation);
    
    // Add event listeners
    document.getElementById('confirmDropBtn').addEventListener('click', () => {
        showNotification(`Dictionary "${currentDictionary.name}" dropped successfully`, 'success');
        logOperation(`Dropped dictionary "${currentDictionary.name}"`, 'warning');
        handleCancelCustomSort();
    });
    
    document.getElementById('cancelDropBtn').addEventListener('click', () => {
        dictionaryOperationsSection.innerHTML = operationsSection;
        // Reattach event listeners
        document.getElementById('updateDictionaryBtn').addEventListener('click', handleUpdateDictionary);
        document.getElementById('dropDictionaryBtn').addEventListener('click', handleDropDictionary);
        document.getElementById('performSortBtn').addEventListener('click', handlePerformSort);
        showNotification('Dictionary drop cancelled', 'info');
    });
}

// NEW: Perform Sort Handler
async function handlePerformSort() {
    const sortField = sortFieldSelect.value;
    const sortOrder = sortOrderSelect.value;
    
    if (!sortField) {
        showNotification('Please select a field to sort by', 'danger');
        return;
    }
    
    // Show visualization section
    sortVisualizationSection.style.display = 'block';
    sortStepsContainer.innerHTML = '';
    
    // Get the field type for comparison
    const field = currentDictionary.fields.find(f => f.name === sortField);
    const fieldType = field ? field.type : 'string';
    
    // Create custom comparator
    const customComparator = (a, b) => {
        let aValue = a[sortField];
        let bValue = b[sortField];
        
        // Convert to numbers if field type is numeric
        if (fieldType === 'int' || fieldType === 'float') {
            aValue = fieldType === 'int' ? parseInt(aValue) : parseFloat(aValue);
            bValue = fieldType === 'int' ? parseInt(bValue) : parseFloat(bValue);
        }
        
        if (aValue < bValue) return sortOrder === 'asc' ? -1 : 1;
        if (aValue > bValue) return sortOrder === 'asc' ? 1 : -1;
        return 0;
    };
    
    // Start sorting visualization
    await visualizeSortProcess(customComparator, sortField, sortOrder, fieldType);
}

// NEW: Visualize Sort Process
async function visualizeSortProcess(comparator, sortField, sortOrder, fieldType) {
    const data = [...currentDictionary.data];
    const steps = [];
    
    // Add initial step
    steps.push({
        step: 0,
        description: `Starting custom comparator sort by field "${sortField}" in ${sortOrder === 'asc' ? 'ascending' : 'descending'} order`,
        data: [...data],
        highlighted: []
    });
    
    // Use bubble sort for visualization (easy to follow)
    for (let i = 0; i < data.length - 1; i++) {
        for (let j = 0; j < data.length - i - 1; j++) {
            // Highlight current comparison
            steps.push({
                step: steps.length,
                description: `Comparing records ${j} and ${j + 1}: ${data[j][sortField]} vs ${data[j + 1][sortField]}`,
                data: [...data],
                highlighted: [j, j + 1]
            });
            
            if (comparator(data[j], data[j + 1]) > 0) {
                // Swap needed
                [data[j], data[j + 1]] = [data[j + 1], data[j]];
                
                steps.push({
                    step: steps.length,
                    description: `Swapped records ${j} and ${j + 1} because ${data[j + 1][sortField]} ${sortOrder === 'asc' ? '>' : '<'} ${data[j][sortField]}`,
                    data: [...data],
                    highlighted: [j, j + 1],
                    swapped: true
                });
            }
        }
        
        // Mark sorted element
        steps.push({
            step: steps.length,
            description: `Record ${data.length - i - 1} is now in its final position`,
            data: [...data],
            highlighted: [data.length - i - 1],
            sorted: true
        });
    }
    
    // Final step
    steps.push({
        step: steps.length,
        description: `Sorting completed! All records are now sorted by "${sortField}" in ${sortOrder === 'asc' ? 'ascending' : 'descending'} order`,
        data: [...data],
        highlighted: [],
        completed: true
    });
    
    // Display steps with animation
    for (let i = 0; i < steps.length; i++) {
        await displaySortStep(steps[i], i);
        await new Promise(resolve => setTimeout(resolve, 1000)); // Delay between steps
    }
    
    // Update the actual data
    currentDictionary.data = data;
    updateDictionaryDisplay();
    
    showNotification(`Custom comparator sort completed successfully`, 'success');
    logOperation(`Performed custom comparator sort by "${sortField}" (${sortOrder})`, 'success');
}

// NEW: Display Sort Step
async function displaySortStep(step, stepIndex) {
    sortStepsContainer.innerHTML = '';
    
    const stepElement = document.createElement('div');
    stepElement.className = `sort-step ${step.completed ? 'active' : ''}`;
    stepElement.innerHTML = `
        <strong>Step ${step.step}:</strong> ${step.description}
    `;
    sortStepsContainer.appendChild(stepElement);
    
    // Update the table display to show current state
    dictionaryTableBody.innerHTML = '';
    step.data.forEach((record, index) => {
        const tr = document.createElement('tr');
        tr.setAttribute('data-index', index);
        
        if (step.highlighted.includes(index)) {
            tr.className = step.swapped ? 'dictionary-record-highlight' : 'dictionary-record-sorted';
        }
        
        currentDictionary.fields.forEach(field => {
            const td = document.createElement('td');
            td.textContent = record[field.name];
            tr.appendChild(td);
        });
        
        // Add empty actions column for visualization
        const actionsTd = document.createElement('td');
        actionsTd.innerHTML = '-';
        tr.appendChild(actionsTd);
        
        dictionaryTableBody.appendChild(tr);
    });
    
    // Scroll to the current step
    stepElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

// NEW: Reset After Sort Handler
function handleResetAfterSort() {
    // Restore original data
    currentDictionary.data = JSON.parse(JSON.stringify(currentDictionary.originalData));
    updateDictionaryDisplay();
    
    // Hide visualization section
    sortVisualizationSection.style.display = 'none';
    
    showNotification('Data restored to original order', 'info');
    logOperation('Reset dictionary data to original order', 'info');
}

// NEW: Cancel Custom Sort Handler
function handleCancelCustomSort() {
    isCustomSortRunning = false;
    customComparatorContainer.style.display = 'none';
    
    // Reset all inputs
    dictionaryName.value = '';
    fieldCount.value = '';
    fieldDefinitions.innerHTML = '';
    dataEntryForm.innerHTML = '';
    
    // Reset dictionary
    currentDictionary = {
        name: '',
        fields: [],
        data: [],
        originalData: []
    };
    
    showNotification('Custom comparator sort cancelled', 'warning');
    logOperation('Cancelled custom comparator sort operation', 'warning');
}

// ENHANCED: Improved showNotification function
function showNotification(message, type) {
    // Remove any existing notifications first
    const existingNotifications = document.querySelectorAll('.custom-notification');
    existingNotifications.forEach(notification => notification.remove());
    
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `custom-notification alert alert-${type} alert-dismissible fade show position-fixed`;
    notification.style.cssText = `
        top: 20px;
        right: 20px;
        z-index: 9999;
        min-width: 300px;
    `;
    notification.innerHTML = `
        <strong>${type.toUpperCase()}:</strong> ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    document.body.appendChild(notification);
    
    // Auto remove after 4 seconds
    setTimeout(() => {
        if (notification.parentElement) {
            notification.remove();
        }
    }, 4000);
    
    console.log(`${type.toUpperCase()}: ${message}`);
}

function logOperation(message, level) {
    // Your logging implementation
    console.log(`${level}: ${message}`);
}

// NEW: Quick Sort Handler
function handleQuickSort() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - already sorted', 'info');
        return;
    }
    
    if (isQuickSortRunning) {
        showNotification('Quick sort is already in progress', 'warning');
        return;
    }
    
    isQuickSortRunning = true;
    
    // Store original array
    originalArrayForQuickSort = [...myArray];
    
    // Show quick sort visualization
    showQuickSortVisualization();
}

// NEW: Heap Sort Handler
function handleHeapSort() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - already sorted', 'info');
        return;
    }
    
    if (isHeapSortRunning) {
        showNotification('Heap sort is already in progress', 'warning');
        return;
    }
    
    isHeapSortRunning = true;
    
    // Store original array
    originalArrayForHeapSort = [...myArray];
    
    // Show heap sort visualization
    showHeapSortVisualization();
}
// NEW: Show Quick Sort Visualization
function showQuickSortVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Quick Sort Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalQuickSortArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Quick Sort Process</div>
            <div class="transformed-array-container" id="transformedQuickSortArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Quick Sort:</strong> Divide and conquer algorithm using pivots</p>
            <p class="mb-0" id="quickSortExplanation">Initializing quick sort...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="quickSortStepsContainer">
            <h6 class="text-center">Quick Sort Steps</h6>
            <div class="steps-container" id="quickSortSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterQuickSort" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForQuickSort, 'originalQuickSortArray');
    renderArrayInContainer([...originalArrayForQuickSort], 'transformedQuickSortArray');
    
    performQuickSortAnimation();
}

// NEW: Show Heap Sort Visualization
function showHeapSortVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Heap Sort Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalHeapSortArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Heap Sort Process</div>
            <div class="transformed-array-container" id="transformedHeapSortArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Heap Sort:</strong> Build max heap and repeatedly extract maximum element</p>
            <p class="mb-0" id="heapSortExplanation">Initializing heap sort...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="heapSortStepsContainer">
            <h6 class="text-center">Heap Sort Steps</h6>
            <div class="steps-container" id="heapSortSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterHeapSort" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForHeapSort, 'originalHeapSortArray');
    renderArrayInContainer([...originalArrayForHeapSort], 'transformedHeapSortArray');
    
    performHeapSortAnimation();
}
// NEW: Perform Quick Sort Animation
async function performQuickSortAnimation() {
    const originalContainer = document.getElementById('originalQuickSortArray');
    const transformedContainer = document.getElementById('transformedQuickSortArray');
    const explanation = document.getElementById('quickSortExplanation');
    const stepsContainer = document.getElementById('quickSortSteps');
    const continueButton = document.getElementById('continueAfterQuickSort');
    
    let array = [...originalArrayForQuickSort];
    let stepCount = 0;
    
    // Convert to numbers for comparison if possible
    const isNumeric = !array.some(item => isNaN(parseFloat(item)));
    
    async function quickSort(arr, low, high) {
        if (low < high) {
            stepCount++;
            explanation.innerHTML = `Step ${stepCount}: Partitioning subarray from index ${low} to ${high}`;
            
            // Highlight current subarray
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            for (let i = low; i <= high; i++) {
                transformedElements[i].querySelector('.element-value').classList.add('quick-sort-partition');
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${stepCount}:</strong> Partitioning subarray [${low}-${high}]
                </div>
            `;
            
            await new Promise(resolve => setTimeout(resolve, 1500));
            
            const pivotIndex = await partition(arr, low, high);
            
            // Remove highlights
            for (let i = low; i <= high; i++) {
                transformedElements[i].querySelector('.element-value').classList.remove('quick-sort-partition');
            }
            
            await quickSort(arr, low, pivotIndex - 1);
            await quickSort(arr, pivotIndex + 1, high);
        } else if (low === high) {
            // Single element subarray is sorted
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements[low].querySelector('.element-value').classList.add('quick-sort-sorted');
        }
    }
    
    async function partition(arr, low, high) {
        // Choose last element as pivot
        const pivot = isNumeric ? parseFloat(arr[high]) : arr[high];
        let i = low - 1;
        
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        
        // Highlight pivot
        transformedElements[high].querySelector('.element-value').classList.add('quick-sort-pivot');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Partition:</strong> Pivot = ${arr[high]} at index ${high}
            </div>
        `;
        
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        for (let j = low; j < high; j++) {
            const currentVal = isNumeric ? parseFloat(arr[j]) : arr[j];
            const shouldSwap = isNumeric ? currentVal <= pivot : arr[j] <= pivot;
            
            // Highlight current element being compared
            transformedElements[j].querySelector('.element-value').classList.add('sorting-current');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Compare:</strong> arr[${j}]=${arr[j]} ${shouldSwap ? '' : '>'} pivot=${arr[high]}
                </div>
            `;
            
            await new Promise(resolve => setTimeout(resolve, 800));
            
            if (shouldSwap) {
                i++;
                
                if (i !== j) {
                    // Swap elements
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Swap:</strong> arr[${i}]=${arr[i]}  arr[${j}]=${arr[j]}
                        </div>
                    `;
                    
                    // Highlight elements being swapped
                    transformedElements[i].querySelector('.element-value').classList.add('sorting-swap');
                    transformedElements[j].querySelector('.element-value').classList.add('sorting-swap');
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                    renderArrayInContainer(arr, 'transformedQuickSortArray');
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            }
            
            // Remove highlights
            transformedElements[j].querySelector('.element-value').classList.remove('sorting-current', 'sorting-swap');
            if (i >= 0) {
                transformedElements[i].querySelector('.element-value').classList.remove('sorting-swap');
            }
        }
        
        // Swap pivot with element at i+1
        if (i + 1 !== high) {
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final Swap:</strong> Moving pivot to correct position at index ${i + 1}
                </div>
            `;
            
            [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
            renderArrayInContainer(arr, 'transformedQuickSortArray');
        }
        
        // Remove pivot highlight and mark as sorted
        transformedElements[high].querySelector('.element-value').classList.remove('quick-sort-pivot');
        transformedElements[i + 1].querySelector('.element-value').classList.add('quick-sort-sorted');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Partition Complete:</strong> Pivot ${arr[i + 1]} at final position ${i + 1}
            </div>
        `;
        
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        return i + 1;
    }
    
    // Start quick sort
    await quickSort(array, 0, array.length - 1);
    
    // Algorithm completed
    explanation.innerHTML = `<strong>Quick Sort Completed!</strong> Array is now sorted.`;
    
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Final:</strong> Quick sort completed successfully!
        </div>
    `;
    
    continueButton.style.display = 'block';
    
    // Auto-return after 5 seconds
    setTimeout(() => {
        returnToOriginalAfterQuickSort();
    }, 5000);
    
    continueButton.addEventListener('click', returnToOriginalAfterQuickSort);
}

// NEW: Perform Heap Sort Animation
async function performHeapSortAnimation() {
    const originalContainer = document.getElementById('originalHeapSortArray');
    const transformedContainer = document.getElementById('transformedHeapSortArray');
    const explanation = document.getElementById('heapSortExplanation');
    const stepsContainer = document.getElementById('heapSortSteps');
    const continueButton = document.getElementById('continueAfterHeapSort');
    
    let array = [...originalArrayForHeapSort];
    let stepCount = 0;
    const n = array.length;
    
    // Convert to numbers for comparison if possible
    const isNumeric = !array.some(item => isNaN(parseFloat(item)));
    
    async function heapify(arr, n, i) {
        let largest = i;
        const left = 2 * i + 1;
        const right = 2 * i + 2;
        
        stepCount++;
        explanation.innerHTML = `Step ${stepCount}: Heapifying node at index ${i}`;
        
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        
        // Highlight current parent and children
        transformedElements[i].querySelector('.element-value').classList.add('heap-sort-parent');
        if (left < n) transformedElements[left].querySelector('.element-value').classList.add('heap-sort-child');
        if (right < n) transformedElements[right].querySelector('.element-value').classList.add('heap-sort-child');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${stepCount}:</strong> Heapifying node ${i} (value: ${arr[i]})
            </div>
        `;
        
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Check left child
        if (left < n) {
            const shouldSwap = isNumeric ? 
                parseFloat(arr[left]) > parseFloat(arr[largest]) : 
                arr[left] > arr[largest];
                
            if (shouldSwap) {
                largest = left;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Left Child:</strong> arr[${left}]=${arr[left]} > current largest
                    </div>
                `;
            }
        }
        
        // Check right child
        if (right < n) {
            const shouldSwap = isNumeric ? 
                parseFloat(arr[right]) > parseFloat(arr[largest]) : 
                arr[right] > arr[largest];
                
            if (shouldSwap) {
                largest = right;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Right Child:</strong> arr[${right}]=${arr[right]} > current largest
                    </div>
                `;
            }
        }
        
        // If largest is not root
        if (largest !== i) {
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Swap Needed:</strong> Swapping parent ${arr[i]} with child ${arr[largest]}
                </div>
            `;
            
            // Highlight swap
            transformedElements[i].querySelector('.element-value').classList.add('sorting-swap');
            transformedElements[largest].querySelector('.element-value').classList.add('sorting-swap');
            
            await new Promise(resolve => setTimeout(resolve, 800));
            
            [arr[i], arr[largest]] = [arr[largest], arr[i]];
            renderArrayInContainer(arr, 'transformedHeapSortArray');
            
            await new Promise(resolve => setTimeout(resolve, 800));
            
            // Recursively heapify the affected sub-tree
            await heapify(arr, n, largest);
        } else {
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Heapify Complete:</strong> Node ${i} satisfies heap property
                </div>
            `;
        }
        
        // Remove highlights and mark as heapified
        transformedElements[i].querySelector('.element-value').classList.remove('heap-sort-parent', 'sorting-swap');
        transformedElements[i].querySelector('.element-value').classList.add('heap-sort-heapified');
        if (left < n) transformedElements[left].querySelector('.element-value').classList.remove('heap-sort-child');
        if (right < n) transformedElements[right].querySelector('.element-value').classList.remove('heap-sort-child');
        
        await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    // Build max heap
    explanation.innerHTML = "Building max heap...";
    stepsContainer.innerHTML += `<div class="algorithm-step"><strong>Phase 1:</strong> Building Max Heap</div>`;
    
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
        await heapify(array, n, i);
    }
    
    stepsContainer.innerHTML += `<div class="algorithm-step active"><strong>Max Heap Built:</strong> Heap construction complete</div>`;
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // Extract elements from heap one by one
    explanation.innerHTML = "Extracting elements from heap...";
    stepsContainer.innerHTML += `<div class="algorithm-step"><strong>Phase 2:</strong> Sorting by Extraction</div>`;
    
    for (let i = n - 1; i > 0; i--) {
        stepCount++;
        explanation.innerHTML = `Step ${stepCount}: Moving current root to sorted position`;
        
        // Move current root to end
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Extract:</strong> Moving root ${array[0]} to sorted position ${i}
            </div>
        `;
        
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        transformedElements[0].querySelector('.element-value').classList.add('sorting-swap');
        transformedElements[i].querySelector('.element-value').classList.add('sorting-swap');
        
        await new Promise(resolve => setTimeout(resolve, 800));
        
        [array[0], array[i]] = [array[i], array[0]];
        renderArrayInContainer(array, 'transformedHeapSortArray');
        
        await new Promise(resolve => setTimeout(resolve, 800));
        
        // Mark the moved element as sorted
        transformedElements[i].querySelector('.element-value').classList.remove('sorting-swap');
        transformedElements[i].querySelector('.element-value').classList.add('quick-sort-sorted');
        
        // Call heapify on the reduced heap
        await heapify(array, i, 0);
    }
    
    // Mark first element as sorted
    const transformedElements = transformedContainer.querySelectorAll('.array-element');
    transformedElements[0].querySelector('.element-value').classList.add('quick-sort-sorted');
    
    // Algorithm completed
    explanation.innerHTML = `<strong>Heap Sort Completed!</strong> Array is now sorted.`;
    
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Final:</strong> Heap sort completed successfully!
        </div>
    `;
    
    continueButton.style.display = 'block';
    
    // Auto-return after 5 seconds
    setTimeout(() => {
        returnToOriginalAfterHeapSort();
    }, 5000);
    
    continueButton.addEventListener('click', returnToOriginalAfterHeapSort);
}
// NEW: Return to Original after Quick Sort
function returnToOriginalAfterQuickSort() {
    // Reset to original array
    myArray = [...originalArrayForQuickSort];
    originalArrayForQuickSort = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isQuickSortRunning = false;
    
    logOperation('Quick sort completed - returned to original array', 'info');
    showNotification('Returned to original array after quick sort', 'success');
}

// NEW: Return to Original after Heap Sort
function returnToOriginalAfterHeapSort() {
    // Reset to original array
    myArray = [...originalArrayForHeapSort];
    originalArrayForHeapSort = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isHeapSortRunning = false;
    
    logOperation('Heap sort completed - returned to original array', 'info');
    showNotification('Returned to original array after heap sort', 'success');
}
// NEW: Sort Even Before Odd Handler
function handleSortEvenBeforeOdd() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isEvenOddSortRunning) {
        showNotification('Even-odd sort is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Even-odd sort requires all array elements to be numbers', 'danger');
        return;
    }
    
    isEvenOddSortRunning = true;
    
    // Store original array
    originalArrayForSpecialSort = [...myArray];
    
    // Show even-odd sort visualization
    showEvenOddSortVisualization();
}
// NEW: Sort by Absolute Value Handler
function handleSortByAbsoluteValue() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isAbsoluteSortRunning) {
        showNotification('Absolute value sort is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Absolute value sort requires all array elements to be numbers', 'danger');
        return;
    }
    
    isAbsoluteSortRunning = true;
    
    // Store original array
    originalArrayForSpecialSort = [...myArray];
    
    // Show absolute value sort visualization
    showAbsoluteSortVisualization();
}

// NEW: Sort by Absolute Value Handler
function handleSortAbsoluteValue() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isAbsoluteValueSortRunning) {
        showNotification('Absolute value sort is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Absolute value sorting requires all array elements to be numbers', 'danger');
        return;
    }
    
    isAbsoluteValueSortRunning = true;
    
    // Store original array
    originalArrayForSpecialSort = [...myArray];
    
    // Show absolute value sort visualization
    showAbsoluteValueSortVisualization();
}
// NEW: Show Even-Odd Sort Visualization
function showEvenOddSortVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Sort Even Numbers Before Odd Numbers</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalSpecialArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Even-Odd Sorted Array</div>
            <div class="transformed-array-container" id="transformedSpecialArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Separate even numbers to the front, odd numbers to the back</p>
            <p class="mb-0" id="specialSortExplanation">Starting even-odd sort animation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="specialSortStepsContainer">
            <h6 class="text-center">Even-Odd Sort Steps</h6>
            <div class="steps-container" id="specialSortSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSpecialSort" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSpecialSort, 'originalSpecialArray');
    renderArrayInContainer([...originalArrayForSpecialSort], 'transformedSpecialArray');
    
    performEvenOddSortAnimation();
}

// NEW: Show Absolute Value Sort Visualization
function showAbsoluteValueSortVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Sort by Absolute Value</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalSpecialArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Absolute Value Sorted Array</div>
            <div class="transformed-array-container" id="transformedSpecialArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Absolute Value Sorting:</strong> Sorting numbers by their absolute values</p>
            <p class="mb-0" id="specialSortExplanation">Starting absolute value sort animation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="specialSortStepsContainer">
            <h6 class="text-center">Absolute Value Sorting Steps</h6>
            <div class="steps-container" id="specialSortSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSpecialSort" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSpecialSort, 'originalSpecialArray');
    renderArrayInContainer([...originalArrayForSpecialSort], 'transformedSpecialArray');
    
    performAbsoluteValueSortAnimation();
}

// NEW: Perform Even-Odd Sort Animation
function performEvenOddSortAnimation() {
    const originalContainer = document.getElementById('originalSpecialArray');
    const transformedContainer = document.getElementById('transformedSpecialArray');
    const explanation = document.getElementById('specialSortExplanation');
    const stepsContainer = document.getElementById('specialSortSteps');
    const continueButton = document.getElementById('continueAfterSpecialSort');
    
    const arr = originalArrayForSpecialSort.map(val => parseFloat(val));
    let step = 0;
    let currentIndex = 0;
    let evenPointer = 0;
    
    function performEvenOddStep() {
        if (currentIndex >= arr.length) {
            // Sorting completed
            explanation.innerHTML = `<strong>Even-Odd Sort Completed!</strong> All even numbers moved to the front.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Even-odd sorting completed! ${evenPointer} even number(s) found.
                </div>
            `;
            
            // Highlight even and odd numbers differently
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                const value = parseFloat(el.querySelector('.element-value').textContent);
                setTimeout(() => {
                    if (value % 2 === 0) {
                        el.querySelector('.element-value').classList.add('even-number-sorted');
                    } else {
                        el.querySelector('.element-value').classList.add('odd-number-sorted');
                    }
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterSpecialSort();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSpecialSort);
            
            return;
        }
        
        step++;
        const currentValue = arr[currentIndex];
        const isEven = currentValue % 2 === 0;
        
        explanation.innerHTML = `Step ${step}: Checking element [${currentIndex}] = ${currentValue} - ${isEven ? 'EVEN' : 'ODD'}`;
        
        // Highlight current element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentIndex].querySelector('.element-value');
        currentElement.classList.add(isEven ? 'even-number' : 'odd-number');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${isEven ? 'active' : ''}">
                <strong>Step ${step}:</strong> [${currentIndex}] = ${currentValue} - ${isEven ? 'EVEN' : 'ODD'} number
                ${isEven ? ` Moving to position ${evenPointer}` : ' Staying in place'}
            </div>
        `;
        
        setTimeout(() => {
            if (isEven && currentIndex !== evenPointer) {
                // Move even number to the evenPointer position
                explanation.innerHTML = `Step ${step}: Moving even number ${currentValue} to position ${evenPointer}`;
                
                // Swap elements
                [arr[currentIndex], arr[evenPointer]] = [arr[evenPointer], arr[currentIndex]];
                
                // Update transformed array
                renderArrayInContainer(arr, 'transformedSpecialArray');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Move:</strong> Even number ${currentValue} moved from [${currentIndex}] to [${evenPointer}]
                    </div>
                `;
                
                evenPointer++;
                currentIndex++;
            } else if (isEven) {
                // Already in correct position
                evenPointer++;
                currentIndex++;
            } else {
                // Odd number, leave in place
                currentIndex++;
            }
            
            // Remove highlight
            currentElement.classList.remove('even-number', 'odd-number');
            
            // Continue to next step
            performEvenOddStep();
        }, 1500);
    }
    
    // Start even-odd sort process
    performEvenOddStep();
}

// NEW: Perform Absolute Value Sort Animation
function performAbsoluteSortAnimation() {
    const originalContainer = document.getElementById('originalSpecialArray');
    const transformedContainer = document.getElementById('transformedSpecialArray');
    const explanation = document.getElementById('specialSortExplanation');
    const stepsContainer = document.getElementById('specialSortSteps');
    const continueButton = document.getElementById('continueAfterSpecialSort');
    
    const arr = originalArrayForSpecialSort.map(val => parseFloat(val));
    let step = 0;
    
    // Create array with absolute values and original indices
    const elementsWithAbs = arr.map((value, index) => ({
        value: value,
        absValue: Math.abs(value),
        originalIndex: index
    }));
    
    function performAbsoluteStep(pass = 0, comparison = 0) {
        const n = elementsWithAbs.length;
        
        if (pass >= n - 1) {
            // Sorting completed
            explanation.innerHTML = `<strong>Absolute Value Sort Completed!</strong> Array sorted by absolute values.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Array sorted by absolute values (distance from zero)
                </div>
            `;
            
            // Highlight all elements
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                const value = parseFloat(el.querySelector('.element-value').textContent);
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('absolute-sorted');
                    if (value >= 0) {
                        el.querySelector('.element-value').classList.add('positive-value-sorted');
                    } else {
                        el.querySelector('.element-value').classList.add('negative-value-sorted');
                    }
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterSpecialSort();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSpecialSort);
            
            return;
        }
        
        if (comparison >= n - pass - 1) {
            // Pass completed
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Pass ${pass + 1} Complete:</strong> Largest absolute value bubbled to end
                </div>
            `;
            
            pass++;
            comparison = 0;
            performAbsoluteStep(pass, comparison);
            return;
        }
        
        step++;
        const i = comparison;
        const j = i + 1;
        
        explanation.innerHTML = `Step ${step}: Comparing |${elementsWithAbs[i].value}| and |${elementsWithAbs[j].value}|`;
        
        // Highlight elements being compared
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const elementI = originalElements[i].querySelector('.element-value');
        const elementJ = originalElements[j].querySelector('.element-value');
        
        elementI.classList.add('sorting-current');
        elementJ.classList.add('sorting-compared');
        
        // Compare absolute values
        const shouldSwap = elementsWithAbs[i].absValue > elementsWithAbs[j].absValue;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${shouldSwap ? 'active' : ''}">
                <strong>Step ${step}:</strong> |${elementsWithAbs[i].value}| = ${elementsWithAbs[i].absValue} 
                ${shouldSwap ? '>' : '<='} |${elementsWithAbs[j].value}| = ${elementsWithAbs[j].absValue}
                ${shouldSwap ? ' SWAPPING' : ' No swap needed'}
            </div>
        `;
        
        setTimeout(() => {
            if (shouldSwap) {
                // Perform swap
                explanation.innerHTML = `Step ${step}: Swapping based on absolute values`;
                
                [elementsWithAbs[i], elementsWithAbs[j]] = [elementsWithAbs[j], elementsWithAbs[i]];
                
                // Update array for display
                const currentArray = elementsWithAbs.map(item => item.value);
                renderArrayInContainer(currentArray, 'transformedSpecialArray');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Swap:</strong> Elements swapped based on absolute values
                    </div>
                `;
            }
            
            // Remove highlights
            elementI.classList.remove('sorting-current', 'sorting-compared');
            elementJ.classList.remove('sorting-current', 'sorting-compared');
            
            // Continue to next comparison
            comparison++;
            performAbsoluteStep(pass, comparison);
        }, 1500);
    }
    
    // Start absolute value sort process
    performAbsoluteStep();
}

// NEW: Return to Original after Special Sort
function returnToOriginalAfterSpecialSort() {
    // Reset to original array
    myArray = [...originalArrayForSpecialSort];
    originalArrayForSpecialSort = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset states
    isEvenOddSortRunning = false;
    isAbsoluteSortRunning = false;
    
    logOperation('Special sort completed - returned to original array', 'info');
    showNotification('Returned to original array after special sort', 'success');
}
// NEW: Perform Absolute Value Sort Animation
function performAbsoluteSortAnimation() {
    const originalContainer = document.getElementById('originalSpecialArray');
    const transformedContainer = document.getElementById('transformedSpecialArray');
    const explanation = document.getElementById('specialSortExplanation');
    const stepsContainer = document.getElementById('specialSortSteps');
    const continueButton = document.getElementById('continueAfterSpecialSort');
    
    const arr = originalArrayForSpecialSort.map(val => parseFloat(val));
    let step = 0;
    
    // Create array with absolute values and original indices
    const elementsWithAbs = arr.map((value, index) => ({
        value: value,
        absValue: Math.abs(value),
        originalIndex: index
    }));
    
    function performAbsoluteStep(pass = 0, comparison = 0) {
        const n = elementsWithAbs.length;
        
        if (pass >= n - 1) {
            // Sorting completed
            explanation.innerHTML = `<strong>Absolute Value Sort Completed!</strong> Array sorted by absolute values.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Array sorted by absolute values (distance from zero)
                </div>
            `;
            
            // Highlight all elements
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                const value = parseFloat(el.querySelector('.element-value').textContent);
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('absolute-sorted');
                    if (value >= 0) {
                        el.querySelector('.element-value').classList.add('positive-value-sorted');
                    } else {
                        el.querySelector('.element-value').classList.add('negative-value-sorted');
                    }
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterSpecialSort();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSpecialSort);
            
            return;
        }
        
        if (comparison >= n - pass - 1) {
            // Pass completed
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Pass ${pass + 1} Complete:</strong> Largest absolute value bubbled to end
                </div>
            `;
            
            pass++;
            comparison = 0;
            performAbsoluteStep(pass, comparison);
            return;
        }
        
        step++;
        const i = comparison;
        const j = i + 1;
        
        explanation.innerHTML = `Step ${step}: Comparing |${elementsWithAbs[i].value}| and |${elementsWithAbs[j].value}|`;
        
        // Highlight elements being compared
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const elementI = originalElements[i].querySelector('.element-value');
        const elementJ = originalElements[j].querySelector('.element-value');
        
        elementI.classList.add('sorting-current');
        elementJ.classList.add('sorting-compared');
        
        // Compare absolute values
        const shouldSwap = elementsWithAbs[i].absValue > elementsWithAbs[j].absValue;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${shouldSwap ? 'active' : ''}">
                <strong>Step ${step}:</strong> |${elementsWithAbs[i].value}| = ${elementsWithAbs[i].absValue} 
                ${shouldSwap ? '>' : '<='} |${elementsWithAbs[j].value}| = ${elementsWithAbs[j].absValue}
                ${shouldSwap ? ' SWAPPING' : ' No swap needed'}
            </div>
        `;
        
        setTimeout(() => {
            if (shouldSwap) {
                // Perform swap
                explanation.innerHTML = `Step ${step}: Swapping based on absolute values`;
                
                [elementsWithAbs[i], elementsWithAbs[j]] = [elementsWithAbs[j], elementsWithAbs[i]];
                
                // Update array for display
                const currentArray = elementsWithAbs.map(item => item.value);
                renderArrayInContainer(currentArray, 'transformedSpecialArray');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Swap:</strong> Elements swapped based on absolute values
                    </div>
                `;
            }
            
            // Remove highlights
            elementI.classList.remove('sorting-current', 'sorting-compared');
            elementJ.classList.remove('sorting-current', 'sorting-compared');
            
            // Continue to next comparison
            comparison++;
            performAbsoluteStep(pass, comparison);
        }, 1500);
    }
    
    // Start absolute value sort process
    performAbsoluteStep();
}
// NEW: Return to Original after Special Sort
function returnToOriginalAfterSpecialSort() {
    // Reset to original array
    myArray = [...originalArrayForSpecialSort];
    originalArrayForSpecialSort = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset states
    isEvenOddSortRunning = false;
    isAbsoluteSortRunning = false;
    
    logOperation('Special sort completed - returned to original array', 'info');
    showNotification('Returned to original array after special sort', 'success');
}
// NEW: Pop First Element Handler
function handlePopFirst() {
    if (myArray.length === 0) {
        // Show error message
        searchResults.innerHTML = `
            <p class="mb-1 text-danger"><strong>Error: No elements in array</strong></p>
            <p class="mb-0 text-danger">Array is empty. Please add elements first.</p>
        `;
        showNotification('Array is empty. Cannot pop first element.', 'danger');
        logOperation('Attempted to pop first element from empty array - failed', 'danger');
        return;
    }
    
    const firstElement = myArray[0];
    
    // Highlight the first element before popping
    highlightElement(0, 'delete', () => {
        myArray.shift(); // Remove first element
        renderArray();
        updateStats();
        
        // Show success message
        searchResults.innerHTML = `
            <p class="mb-1 text-success"><strong>Success: First Element Popped</strong></p>
            <p class="mb-1">Popped Element: "${firstElement}"</p>
            <p class="mb-0">New array length: ${myArray.length}</p>
        `;
        
        logOperation(`Popped first element: "${firstElement}"`, 'success');
        showNotification(`First element "${firstElement}" popped successfully`, 'success');
    });
}

// NEW: Shift Right for Insertion Handler
function handleShiftRightInsert() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Show input group
    shiftRightInsertGroup.style.display = 'block';
    insertShiftIndex.focus();
    
    logOperation('Started shift right for insertion operation', 'info');
}

// NEW: Confirm Shift Insert Handler
function handleConfirmShiftInsert() {
    const index = parseInt(insertShiftIndex.value);
    const value = insertShiftValue.value.trim();
    
    // Validation
    if (isNaN(index) || index < 0 || index > myArray.length) {
        showNotification(`Please enter a valid index between 0 and ${myArray.length}`, 'danger');
        insertShiftIndex.focus();
        return;
    }
    
    if (value === '') {
        showNotification('Please enter a value to insert', 'warning');
        insertShiftValue.focus();
        return;
    }
    
    // Store original array
    originalArrayForShiftInsert = [...myArray];
    
    // Hide input group
    shiftRightInsertGroup.style.display = 'none';
    insertShiftIndex.value = '';
    insertShiftValue.value = '';
    
    // Show shift right insertion visualization
    showShiftRightInsertVisualization(index, value);
}

// NEW: Cancel Shift Insert Handler
function handleCancelShiftInsert() {
    shiftRightInsertGroup.style.display = 'none';
    insertShiftIndex.value = '';
    insertShiftValue.value = '';
    logOperation('Cancelled shift right insertion operation', 'info');
}
// NEW: Show Shift Right Insert Visualization
function showShiftRightInsertVisualization(index, value) {
    isShiftInsertRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Shift Right for Insertion at Index ${index}</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalShiftInsertArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-right"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After Insertion with Shift</div>
            <div class="transformed-array-container" id="transformedShiftInsertArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Shift Right Process:</strong> Making space for new element at index ${index}</p>
            <p class="mb-0" id="shiftInsertExplanation">Starting shift right insertion...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="shiftInsertStepsContainer">
            <h6 class="text-center">Shift Right Insertion Steps</h6>
            <div class="steps-container" id="shiftInsertSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterShiftInsert" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForShiftInsert, 'originalShiftInsertArray');
    renderArrayInContainer([...originalArrayForShiftInsert], 'transformedShiftInsertArray');
    
    performShiftRightInsertAnimation(index, value);
}

// NEW: Perform Shift Right Insert Animation
function performShiftRightInsertAnimation(index, value) {
    const originalContainer = document.getElementById('originalShiftInsertArray');
    const transformedContainer = document.getElementById('transformedShiftInsertArray');
    const explanation = document.getElementById('shiftInsertExplanation');
    const stepsContainer = document.getElementById('shiftInsertSteps');
    const continueButton = document.getElementById('continueAfterShiftInsert');
    
    const array = [...originalArrayForShiftInsert];
    let currentStep = 0;
    
    function performShiftStep() {
        if (currentStep === 0) {
            // Step 1: Show original array
            explanation.innerHTML = `Step 1: Original array with ${array.length} elements`;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Original array: [${array.join(', ')}]
                </div>
            `;
            currentStep++;
            setTimeout(performShiftStep, 1500);
            
        } else if (currentStep === 1) {
            // Step 2: Show where we're inserting
            explanation.innerHTML = `Step 2: Preparing to insert "${value}" at index ${index}`;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 2:</strong> Will insert "${value}" at position ${index}
                </div>
            `;
            
            // Highlight the insertion point
            const originalElements = originalContainer.querySelectorAll('.array-element');
            if (index < originalElements.length) {
                originalElements[index].querySelector('.element-value').classList.add('warning-color');
            }
            
            currentStep++;
            setTimeout(performShiftStep, 2000);
            
        } else if (currentStep === 2) {
            // Step 3: Show shift right process
            explanation.innerHTML = `Step 3: Shifting elements from index ${index} to the right`;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 3:</strong> Shifting elements right to make space
                </div>
            `;
            
            // Create new array with space for insertion
            const newArray = [...array];
            newArray.length += 1; // Increase array size
            
            // Shift elements to the right
            for (let i = newArray.length - 1; i > index; i--) {
                newArray[i] = newArray[i - 1];
            }
            
            // Update transformed array display
            renderArrayInContainer(newArray, 'transformedShiftInsertArray');
            
            // Highlight shifted elements
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            for (let i = index + 1; i < newArray.length; i++) {
                if (transformedElements[i]) {
                    transformedElements[i].querySelector('.element-value').classList.add('shift-highlight');
                }
            }
            
            currentStep++;
            setTimeout(performShiftStep, 2000);
            
        } else if (currentStep === 3) {
            // Step 4: Insert the new value
            explanation.innerHTML = `Step 4: Inserting "${value}" at index ${index}`;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 4:</strong> Inserting new value "${value}" at position ${index}
                </div>
            `;
            
            // Create final array with inserted value
            const finalArray = [...array];
            finalArray.splice(index, 0, value); // Insert at specified index
            
            // Update transformed array display
            renderArrayInContainer(finalArray, 'transformedShiftInsertArray');
            
            // Highlight the inserted element
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            if (transformedElements[index]) {
                transformedElements[index].querySelector('.element-value').classList.add('create', 'bounce');
            }
            
            currentStep++;
            setTimeout(performShiftStep, 2000);
            
        } else if (currentStep === 4) {
            // Step 5: Show completion
            explanation.innerHTML = `<strong>Insertion Complete!</strong> Successfully inserted "${value}" at index ${index}`;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 5:</strong> Insertion completed! Array length: ${array.length + 1}
                </div>
                <div class="algorithm-step active">
                    <strong>Result:</strong> New array: [${[...array].splice(index, 0, value) && [...array, value].join(', ')}]
                </div>
            `;
            
            // Update the actual array
            myArray.splice(index, 0, value);
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterShiftInsert();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterShiftInsert);
        }
    }
    
    // Start the shift right process
    performShiftStep();
}

// NEW: Return to Original after Shift Insert
function returnToOriginalAfterShiftInsert() {
    // Reset to original array
    myArray = [...originalArrayForShiftInsert];
    originalArrayForShiftInsert = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isShiftInsertRunning = false;
    
    logOperation('Shift right insertion completed - returned to original array', 'info');
    showNotification('Returned to original array after shift insertion', 'success');
}
// NEW: Find Triplets Handler
function handleFindTriplets() {
    const targetSum = parseInt(tripletSumInput.value);
    
    if (isNaN(targetSum)) {
        showNotification('Please enter a valid target sum', 'danger');
        tripletSumInput.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Triplet sum operations require all array elements to be numbers', 'danger');
        return;
    }
    
    if (myArray.length < 3) {
        showNotification('Array must have at least 3 elements for triplet sum', 'warning');
        return;
    }
    
    if (isTripletOperationRunning) {
        showNotification('A triplet operation is already in progress', 'warning');
        return;
    }
    
    isTripletOperationRunning = true;
    
    // Store original array
    originalArrayForTriplet = [...myArray];
    
    // Perform triplet sum visualization
    performTripletSumVisualization(targetSum);
}

// NEW: Find Quadruplets Handler
function handleFindQuadruplets() {
    const targetSum = parseInt(quadrupletSumInput.value);
    
    if (isNaN(targetSum)) {
        showNotification('Please enter a valid target sum', 'danger');
        quadrupletSumInput.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Quadruplet sum operations require all array elements to be numbers', 'danger');
        return;
    }
    
    if (myArray.length < 4) {
        showNotification('Array must have at least 4 elements for quadruplet sum', 'warning');
        return;
    }
    
    if (isQuadrupletOperationRunning) {
        showNotification('A quadruplet operation is already in progress', 'warning');
        return;
    }
    
    isQuadrupletOperationRunning = true;
    
    // Store original array
    originalArrayForQuadruplet = [...myArray];
    
    // Perform quadruplet sum visualization
    performQuadrupletSumVisualization(targetSum);
}

// NEW: Perform Triplet Sum Visualization
function performTripletSumVisualization(targetSum) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Triplet Sum (Target = ${targetSum})</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalTripletArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find all unique triplets that sum to ${targetSum}</p>
            <p class="mb-0" id="tripletExplanation">Initializing triplet search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="tripletStepsContainer">
            <h6 class="text-center">Triplet Search Steps</h6>
            <div class="steps-container" id="tripletSteps"></div>
        </div>
        
        <div class="triplet-results mt-3" id="tripletResults" style="display: none;">
            <h6 class="text-center">Found Triplets</h6>
            <div id="tripletsList" class="mt-2"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterTriplet" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForTriplet, 'originalTripletArray');
    
    executeTripletSumAlgorithm(targetSum);
}

// NEW: Execute Triplet Sum Algorithm with Animation
function executeTripletSumAlgorithm(targetSum) {
    const arrayContainer = document.getElementById('originalTripletArray');
    const explanation = document.getElementById('tripletExplanation');
    const stepsContainer = document.getElementById('tripletSteps');
    const tripletResults = document.getElementById('tripletResults');
    const tripletsList = document.getElementById('tripletsList');
    const continueButton = document.getElementById('continueAfterTriplet');
    
    const arr = originalArrayForTriplet.map(val => parseFloat(val));
    const sortedArr = [...arr].sort((a, b) => a - b);
    const triplets = [];
    let step = 0;
    
    function executeTripletStep(i) {
        if (i >= sortedArr.length - 2) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Triplet Search Completed!</strong> Found ${triplets.length} unique triplets.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Triplet search completed. Found ${triplets.length} unique triplets.
                </div>
            `;
            
            // Display results
            if (triplets.length > 0) {
                tripletResults.style.display = 'block';
                tripletsList.innerHTML = '';
                triplets.forEach((triplet, index) => {
                    const tripletElement = document.createElement('div');
                    tripletElement.className = 'triplet-item';
                    tripletElement.textContent = `[${triplet.join(', ')}]`;
                    tripletsList.appendChild(tripletElement);
                });
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterTriplet();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterTriplet);
            
            return;
        }
        
        // Skip duplicates
        if (i > 0 && sortedArr[i] === sortedArr[i - 1]) {
            executeTripletStep(i + 1);
            return;
        }
        
        step++;
        explanation.innerHTML = `Step ${step}: Fixing element at index ${i} = ${sortedArr[i]}`;
        
        // Highlight current fixed element
        const elements = arrayContainer.querySelectorAll('.array-element');
        const originalIndex = arr.indexOf(sortedArr[i]);
        elements[originalIndex].querySelector('.element-value').classList.add('triplet-current');
        
        let left = i + 1;
        let right = sortedArr.length - 1;
        let innerStep = 0;
        
        function executeInnerTripletStep() {
            if (left >= right) {
                // Move to next fixed element
                elements[originalIndex].querySelector('.element-value').classList.remove('triplet-current');
                executeTripletStep(i + 1);
                return;
            }
            
            innerStep++;
            const currentSum = sortedArr[i] + sortedArr[left] + sortedArr[right];
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}.${innerStep}:</strong> Checking [${i}]=${sortedArr[i]}, [${left}]=${sortedArr[left]}, [${right}]=${sortedArr[right]}  Sum = ${currentSum}
                </div>
            `;
            
            // Highlight current triplet being checked
            const leftOriginalIndex = arr.indexOf(sortedArr[left]);
            const rightOriginalIndex = arr.indexOf(sortedArr[right]);
            
            elements[leftOriginalIndex].querySelector('.element-value').classList.add('triplet-highlight');
            elements[rightOriginalIndex].querySelector('.element-value').classList.add('triplet-highlight');
            
            setTimeout(() => {
                if (currentSum === targetSum) {
                    // Found a triplet
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>FOUND TRIPLET:</strong> [${sortedArr[i]}, ${sortedArr[left]}, ${sortedArr[right]}] = ${targetSum}
                        </div>
                    `;
                    
                    triplets.push([sortedArr[i], sortedArr[left], sortedArr[right]]);
                    
                    // Highlight the found triplet
                    elements[originalIndex].querySelector('.element-value').classList.add('success-color');
                    elements[leftOriginalIndex].querySelector('.element-value').classList.add('success-color');
                    elements[rightOriginalIndex].querySelector('.element-value').classList.add('success-color');
                    
                    // Skip duplicates
                    while (left < right && sortedArr[left] === sortedArr[left + 1]) left++;
                    while (left < right && sortedArr[right] === sortedArr[right - 1]) right--;
                    
                    left++;
                    right--;
                } else if (currentSum < targetSum) {
                    left++;
                } else {
                    right--;
                }
                
                // Remove temporary highlights
                elements[leftOriginalIndex].querySelector('.element-value').classList.remove('triplet-highlight');
                elements[rightOriginalIndex].querySelector('.element-value').classList.remove('triplet-highlight');
                
                executeInnerTripletStep();
            }, 1500);
        }
        
        executeInnerTripletStep();
    }
    
    // Start triplet search
    executeTripletStep(0);
}

// NEW: Perform Quadruplet Sum Visualization
function performQuadrupletSumVisualization(targetSum) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Quadruplet Sum (Target = ${targetSum})</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalQuadrupletArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find all unique quadruplets that sum to ${targetSum}</p>
            <p class="mb-0" id="quadrupletExplanation">Initializing quadruplet search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="quadrupletStepsContainer">
            <h6 class="text-center">Quadruplet Search Steps</h6>
            <div class="steps-container" id="quadrupletSteps"></div>
        </div>
        
        <div class="quadruplet-results mt-3" id="quadrupletResults" style="display: none;">
            <h6 class="text-center">Found Quadruplets</h6>
            <div id="quadrupletsList" class="mt-2"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterQuadruplet" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForQuadruplet, 'originalQuadrupletArray');
    
    executeQuadrupletSumAlgorithm(targetSum);
}

// NEW: Execute Quadruplet Sum Algorithm with Animation
function executeQuadrupletSumAlgorithm(targetSum) {
    const arrayContainer = document.getElementById('originalQuadrupletArray');
    const explanation = document.getElementById('quadrupletExplanation');
    const stepsContainer = document.getElementById('quadrupletSteps');
    const quadrupletResults = document.getElementById('quadrupletResults');
    const quadrupletsList = document.getElementById('quadrupletsList');
    const continueButton = document.getElementById('continueAfterQuadruplet');
    
    const arr = originalArrayForQuadruplet.map(val => parseFloat(val));
    const sortedArr = [...arr].sort((a, b) => a - b);
    const quadruplets = [];
    let step = 0;
    
    function executeQuadrupletStep(i) {
        if (i >= sortedArr.length - 3) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Quadruplet Search Completed!</strong> Found ${quadruplets.length} unique quadruplets.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Quadruplet search completed. Found ${quadruplets.length} unique quadruplets.
                </div>
            `;
            
            // Display results
            if (quadruplets.length > 0) {
                quadrupletResults.style.display = 'block';
                quadrupletsList.innerHTML = '';
                quadruplets.forEach((quadruplet, index) => {
                    const quadrupletElement = document.createElement('div');
                    quadrupletElement.className = 'quadruplet-item';
                    quadrupletElement.textContent = `[${quadruplet.join(', ')}]`;
                    quadrupletsList.appendChild(quadrupletElement);
                });
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterQuadruplet();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterQuadruplet);
            
            return;
        }
        
        // Skip duplicates
        if (i > 0 && sortedArr[i] === sortedArr[i - 1]) {
            executeQuadrupletStep(i + 1);
            return;
        }
        
        step++;
        explanation.innerHTML = `Step ${step}: Fixing first element at index ${i} = ${sortedArr[i]}`;
        
        // Highlight current fixed element
        const elements = arrayContainer.querySelectorAll('.array-element');
        const originalIndex = arr.indexOf(sortedArr[i]);
        elements[originalIndex].querySelector('.element-value').classList.add('quadruplet-current');
        
        function executeInnerQuadrupletStep(j) {
            if (j >= sortedArr.length - 2) {
                // Move to next fixed element
                elements[originalIndex].querySelector('.element-value').classList.remove('quadruplet-current');
                executeQuadrupletStep(i + 1);
                return;
            }
            
            // Skip duplicates for second element
            if (j > i + 1 && sortedArr[j] === sortedArr[j - 1]) {
                executeInnerQuadrupletStep(j + 1);
                return;
            }
            
            const innerStep = step + '.' + (j - i);
            explanation.innerHTML = `Step ${innerStep}: Fixing elements at [${i}]=${sortedArr[i]}, [${j}]=${sortedArr[j]}`;
            
            // Highlight second fixed element
            const jOriginalIndex = arr.indexOf(sortedArr[j]);
            elements[jOriginalIndex].querySelector('.element-value').classList.add('quadruplet-current');
            
            let left = j + 1;
            let right = sortedArr.length - 1;
            let innerInnerStep = 0;
            
            function executeInnerInnerQuadrupletStep() {
                if (left >= right) {
                    // Move to next second element
                    elements[jOriginalIndex].querySelector('.element-value').classList.remove('quadruplet-current');
                    executeInnerQuadrupletStep(j + 1);
                    return;
                }
                
                innerInnerStep++;
                const currentSum = sortedArr[i] + sortedArr[j] + sortedArr[left] + sortedArr[right];
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${innerStep}.${innerInnerStep}:</strong> Checking [${i}]=${sortedArr[i]}, [${j}]=${sortedArr[j]}, [${left}]=${sortedArr[left]}, [${right}]=${sortedArr[right]}  Sum = ${currentSum}
                    </div>
                `;
                
                // Highlight current quadruplet being checked
                const leftOriginalIndex = arr.indexOf(sortedArr[left]);
                const rightOriginalIndex = arr.indexOf(sortedArr[right]);
                
                elements[leftOriginalIndex].querySelector('.element-value').classList.add('quadruplet-highlight');
                elements[rightOriginalIndex].querySelector('.element-value').classList.add('quadruplet-highlight');
                
                setTimeout(() => {
                    if (currentSum === targetSum) {
                        // Found a quadruplet
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>FOUND QUADRUPLET:</strong> [${sortedArr[i]}, ${sortedArr[j]}, ${sortedArr[left]}, ${sortedArr[right]}] = ${targetSum}
                            </div>
                        `;
                        
                        quadruplets.push([sortedArr[i], sortedArr[j], sortedArr[left], sortedArr[right]]);
                        
                        // Highlight the found quadruplet
                        elements[originalIndex].querySelector('.element-value').classList.add('success-color');
                        elements[jOriginalIndex].querySelector('.element-value').classList.add('success-color');
                        elements[leftOriginalIndex].querySelector('.element-value').classList.add('success-color');
                        elements[rightOriginalIndex].querySelector('.element-value').classList.add('success-color');
                        
                        // Skip duplicates
                        while (left < right && sortedArr[left] === sortedArr[left + 1]) left++;
                        while (left < right && sortedArr[right] === sortedArr[right - 1]) right--;
                        
                        left++;
                        right--;
                    } else if (currentSum < targetSum) {
                        left++;
                    } else {
                        right--;
                    }
                    
                    // Remove temporary highlights
                    elements[leftOriginalIndex].querySelector('.element-value').classList.remove('quadruplet-highlight');
                    elements[rightOriginalIndex].querySelector('.element-value').classList.remove('quadruplet-highlight');
                    
                    executeInnerInnerQuadrupletStep();
                }, 1500);
            }
            
            executeInnerInnerQuadrupletStep();
        }
        
        executeInnerQuadrupletStep(i + 1);
    }
    
    // Start quadruplet search
    executeQuadrupletStep(0);
}

// NEW: Return to Original after Triplet Operation
function returnToOriginalAfterTriplet() {
    // Reset to original array
    myArray = [...originalArrayForTriplet];
    originalArrayForTriplet = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isTripletOperationRunning = false;
    
    // Clear input
    tripletSumInput.value = '';
    
    logOperation('Triplet sum operation completed - returned to original array', 'info');
    showNotification('Returned to original array after triplet sum operation', 'success');
}

// NEW: Return to Original after Quadruplet Operation
function returnToOriginalAfterQuadruplet() {
    // Reset to original array
    myArray = [...originalArrayForQuadruplet];
    originalArrayForQuadruplet = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isQuadrupletOperationRunning = false;
    
    // Clear input
    quadrupletSumInput.value = '';
    
    logOperation('Quadruplet sum operation completed - returned to original array', 'info');
    showNotification('Returned to original array after quadruplet sum operation', 'success');
}
// NEW: Equilibrium Point Handler
function handleEquilibriumPoint() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isEquilibriumRunning) {
        showNotification('Equilibrium point search is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Equilibrium point calculation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isEquilibriumRunning = true;
    
    // Store original array
    originalArrayForEquilibrium = [...myArray];
    
    // Show equilibrium point visualization
    showEquilibriumVisualization();
}
// NEW: Show Equilibrium Visualization
function showEquilibriumVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Equilibrium Point Detection</h5>
        
        <div class="array-group">
            <div class="array-label">Array</div>
            <div class="original-array-container" id="equilibriumArray"></div>
        </div>
        
        <div class="equilibrium-explanation">
            <p class="mb-2"><strong>Equilibrium Point:</strong> Find index where sum of left elements equals sum of right elements</p>
            <p class="mb-0" id="equilibriumExplanation">Initializing equilibrium point search...</p>
        </div>
        
        <div class="equilibrium-stats" id="equilibriumStats">
            <div class="equilibrium-stat">
                <div>Left Sum</div>
                <div class="equilibrium-stat-value" id="leftSumValue">0</div>
            </div>
            <div class="equilibrium-stat">
                <div>Right Sum</div>
                <div class="equilibrium-stat-value" id="rightSumValue">0</div>
            </div>
            <div class="equilibrium-stat">
                <div>Current Index</div>
                <div class="equilibrium-stat-value" id="currentIndexValue">-</div>
            </div>
        </div>
        
        <div class="algorithm-steps mt-3" id="equilibriumStepsContainer">
            <h6 class="text-center">Equilibrium Point Algorithm Steps</h6>
            <div class="steps-container" id="equilibriumSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterEquilibrium" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForEquilibrium, 'equilibriumArray');
    
    performEquilibriumAlgorithm();
}
// NEW: Perform Equilibrium Algorithm with Animation
function performEquilibriumAlgorithm() {
    const arrayContainer = document.getElementById('equilibriumArray');
    const explanation = document.getElementById('equilibriumExplanation');
    const stepsContainer = document.getElementById('equilibriumSteps');
    const leftSumValue = document.getElementById('leftSumValue');
    const rightSumValue = document.getElementById('rightSumValue');
    const currentIndexValue = document.getElementById('currentIndexValue');
    const continueButton = document.getElementById('continueAfterEquilibrium');
    
    const arr = originalArrayForEquilibrium.map(val => parseFloat(val));
    const n = arr.length;
    
    // Calculate total sum first
    const totalSum = arr.reduce((sum, val) => sum + val, 0);
    let leftSum = 0;
    let equilibriumFound = false;
    let equilibriumIndex = -1;
    let currentIndex = 0;
    
    function performEquilibriumStep() {
        if (currentIndex >= n) {
            // Algorithm completed
            if (!equilibriumFound) {
                explanation.innerHTML = `<strong>Algorithm Completed!</strong> No equilibrium point found in the array.`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Final:</strong> No equilibrium point exists in the array
                    </div>
                `;
            } else {
                explanation.innerHTML = `<strong>Algorithm Completed!</strong> Equilibrium point found at index ${equilibriumIndex} (1-based position: ${equilibriumIndex + 1})`;
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterEquilibrium();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterEquilibrium);
            
            return;
        }
        
        // Update current index display
        currentIndexValue.textContent = currentIndex;
        
        // Calculate right sum for current index
        const rightSum = totalSum - leftSum - arr[currentIndex];
        
        // Update sum displays
        leftSumValue.textContent = leftSum;
        rightSumValue.textContent = rightSum;
        
        // Highlight current elements
        const elements = arrayContainer.querySelectorAll('.array-element');
        
        // Reset all highlights first
        elements.forEach(el => {
            const valueDiv = el.querySelector('.element-value');
            valueDiv.classList.remove('equilibrium-left', 'equilibrium-right', 'equilibrium-point');
        });
        
        // Highlight left elements (0 to currentIndex-1)
        for (let i = 0; i < currentIndex; i++) {
            elements[i].querySelector('.element-value').classList.add('equilibrium-left');
        }
        
        // Highlight right elements (currentIndex+1 to n-1)
        for (let i = currentIndex + 1; i < n; i++) {
            elements[i].querySelector('.element-value').classList.add('equilibrium-right');
        }
        
        // Highlight current element
        elements[currentIndex].querySelector('.element-value').classList.add('equilibrium-point');
        
        // Update explanation
        explanation.innerHTML = `Checking index ${currentIndex}: Left Sum = ${leftSum}, Right Sum = ${rightSum}`;
        
        // Add step to steps container
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${leftSum === rightSum ? 'active' : ''}">
                <strong>Step ${currentIndex + 1}:</strong> Index ${currentIndex} - 
                Left Sum: ${leftSum}, Right Sum: ${rightSum} - 
                ${leftSum === rightSum ? 'EQUILIBRIUM FOUND!' : 'Not equal'}
            </div>
        `;
        
        // Scroll to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Check if equilibrium found
        if (leftSum === rightSum) {
            equilibriumFound = true;
            equilibriumIndex = currentIndex;
            
            // Special highlight for equilibrium point
            elements[currentIndex].querySelector('.element-value').classList.add('equilibrium-point');
            
            setTimeout(() => {
                explanation.innerHTML = `<strong>EQUILIBRIUM FOUND!</strong> At index ${currentIndex} (1-based position: ${currentIndex + 1})`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>SUCCESS:</strong> Equilibrium point found at position ${currentIndex + 1}!
                    </div>
                `;
                
                // Move to next step after showing success
                setTimeout(() => {
                    leftSum += arr[currentIndex];
                    currentIndex++;
                    performEquilibriumStep();
                }, 2000);
            }, 1500);
        } else {
            // Continue to next index
            setTimeout(() => {
                leftSum += arr[currentIndex];
                currentIndex++;
                performEquilibriumStep();
            }, 1500);
        }
    }
    
    // Add initial explanation
    stepsContainer.innerHTML += `
        <div class="algorithm-step">
            <strong>Algorithm:</strong> For each index i, check if sum(arr[0..i-1]) == sum(arr[i+1..n-1])
        </div>
        <div class="algorithm-step">
            <strong>Total Array Sum:</strong> ${totalSum}
        </div>
    `;
    
    // Start the algorithm
    performEquilibriumStep();
}
// NEW: Return to Original after Equilibrium
function returnToOriginalAfterEquilibrium() {
    // Reset to original array
    myArray = [...originalArrayForEquilibrium];
    originalArrayForEquilibrium = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isEquilibriumRunning = false;
    
    logOperation('Equilibrium point search completed - returned to original array', 'info');
    showNotification('Returned to original array after equilibrium point search', 'success');
}
// NEW: Container With Most Water Handler
function handleContainerWithMostWater() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isWaterProblemRunning) {
        showNotification('A water problem is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Water problems require all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForWater = [...myArray];
    
    // Show container with most water visualization
    showContainerWithMostWaterVisualization();
}

// NEW: Trapping Rain Water Handler
function handleTrappingRainWater() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isWaterProblemRunning) {
        showNotification('A water problem is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Water problems require all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForWater = [...myArray];
    
    // Show trapping rain water visualization
    showTrappingRainWaterVisualization();
}
// NEW: Show Container With Most Water Visualization
function showContainerWithMostWaterVisualization() {
    isWaterProblemRunning = true;
    
    const waterContainer = document.createElement('div');
    waterContainer.className = 'water-container';
    waterContainer.innerHTML = `
        <h5 class="text-center mb-3">Container With Most Water Problem</h5>
        
        <div class="array-group">
            <div class="array-label">Height Array (Bars represent heights)</div>
            <div class="original-array-container" id="waterBarsContainer"></div>
        </div>
        
        <div class="algorithm-explanation mt-3">
            <p class="mb-2" id="waterExplanation">Initializing container with most water algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="waterStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="waterSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Maximum Water Area</div>
            <div class="stats-value" id="maxWaterArea">0 units</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterWater" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(waterContainer);
    
    renderWaterBars(originalArrayForWater, 'waterBarsContainer');
    performContainerWithMostWaterAnimation();
}

// NEW: Show Trapping Rain Water Visualization
function showTrappingRainWaterVisualization() {
    isWaterProblemRunning = true;
    
    const waterContainer = document.createElement('div');
    waterContainer.className = 'water-container';
    waterContainer.innerHTML = `
        <h5 class="text-center mb-3">Trapping Rain Water Problem</h5>
        
        <div class="array-group">
            <div class="array-label">Elevation Map (Blue represents trapped water)</div>
            <div class="original-array-container" id="waterBarsContainer"></div>
        </div>
        
        <div class="algorithm-explanation mt-3">
            <p class="mb-2" id="waterExplanation">Initializing trapping rain water algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="waterStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="waterSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Total Trapped Water</div>
            <div class="stats-value" id="trappedWater">0 units</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterWater" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(waterContainer);
    
    renderWaterBars(originalArrayForWater, 'waterBarsContainer');
    performTrappingRainWaterAnimation();
}

// NEW: Render Water Bars (Vertical bars for water problems)
function renderWaterBars(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    container.style.alignItems = 'flex-end';
    container.style.minHeight = '200px';
    
    const maxHeight = Math.max(...array.map(val => parseFloat(val)));
    const scaleFactor = 150 / (maxHeight || 1); // Scale to fit container
    
    array.forEach((value, index) => {
        const barContainer = document.createElement('div');
        barContainer.className = 'array-element';
        barContainer.style.flexDirection = 'column-reverse';
        barContainer.style.alignItems = 'center';
        
        const height = parseFloat(value);
        const barHeight = height * scaleFactor;
        
        barContainer.innerHTML = `
            <div class="water-bar" style="height: ${barHeight}px; width: 40px; position: relative;">
                <div class="element-value" style="position: absolute; bottom: 0; width: 100%; background: var(--info-color);">
                    ${value}
                </div>
            </div>
            <div class="element-index">${index}</div>
        `;
        
        container.appendChild(barContainer);
    });
}

// NEW: Perform Container With Most Water Animation
function performContainerWithMostWaterAnimation() {
    const barsContainer = document.getElementById('waterBarsContainer');
    const explanation = document.getElementById('waterExplanation');
    const stepsContainer = document.getElementById('waterSteps');
    const maxWaterArea = document.getElementById('maxWaterArea');
    const continueButton = document.getElementById('continueAfterWater');
    
    const height = originalArrayForWater.map(val => parseFloat(val));
    let left = 0;
    let right = height.length - 1;
    let maxArea = 0;
    let step = 0;
    
    function performWaterStep() {
        if (left >= right) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Maximum water area = ${maxArea} units`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Maximum water that can be contained = ${maxArea} units
                </div>
            `;
            
            maxWaterArea.textContent = `${maxArea} units`;
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterWater();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterWater);
            
            return;
        }
        
        step++;
        
        // Calculate current area
        const currentArea = Math.min(height[left], height[right]) * (right - left);
        const isNewMax = currentArea > maxArea;
        
        if (isNewMax) {
            maxArea = currentArea;
        }
        
        explanation.innerHTML = `Step ${step}: Left=${left}, Right=${right}, Area=${Math.min(height[left], height[right])}  ${right - left} = ${currentArea}`;
        
        // Highlight current pointers and area
        const bars = barsContainer.querySelectorAll('.array-element');
        const leftBar = bars[left].querySelector('.water-bar');
        const rightBar = bars[right].querySelector('.water-bar');
        
        leftBar.classList.add('water-pointer-left');
        rightBar.classList.add('water-pointer-right');
        
        // Visualize the water area
        const waterLevel = Math.min(height[left], height[right]);
        visualizeWaterArea(left, right, waterLevel, isNewMax);
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${isNewMax ? 'active' : ''}">
                <strong>Step ${step}:</strong> Left[${left}]=${height[left]}, Right[${right}]=${height[right]}, 
                Area = min(${height[left]}, ${height[right]})  (${right} - ${left}) = ${currentArea}
                ${isNewMax ? '  NEW MAXIMUM!' : ''}
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Remove highlights
            leftBar.classList.remove('water-pointer-left');
            rightBar.classList.remove('water-pointer-right');
            clearWaterVisualization();
            
            // Move pointers
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
            
            maxWaterArea.textContent = `${maxArea} units`;
            performWaterStep();
        }, 2000);
    }
    
    function visualizeWaterArea(leftIdx, rightIdx, waterLevel, isNewMax) {
        const bars = barsContainer.querySelectorAll('.array-element');
        const maxHeight = Math.max(...height);
        const scaleFactor = 150 / (maxHeight || 1);
        
        for (let i = leftIdx + 1; i < rightIdx; i++) {
            const bar = bars[i].querySelector('.water-bar');
            const currentHeight = height[i];
            
            if (currentHeight < waterLevel) {
                const waterHeight = (waterLevel - currentHeight) * scaleFactor;
                const waterDiv = document.createElement('div');
                waterDiv.className = `water-filled ${isNewMax ? 'water-current-area' : ''}`;
                waterDiv.style.height = `${waterHeight}px`;
                waterDiv.title = `Water: ${waterLevel - currentHeight} units`;
                bar.appendChild(waterDiv);
            }
        }
        
        // Add water level line
        const waterLevelDiv = document.createElement('div');
        waterLevelDiv.className = 'water-level';
        waterLevelDiv.style.position = 'absolute';
        waterLevelDiv.style.left = `${leftIdx * 60}px`;
        waterLevelDiv.style.width = `${(rightIdx - leftIdx) * 60}px`;
        waterLevelDiv.style.height = '2px';
        waterLevelDiv.style.top = `${150 - waterLevel * scaleFactor}px`;
        barsContainer.appendChild(waterLevelDiv);
    }
    
    function clearWaterVisualization() {
        const bars = barsContainer.querySelectorAll('.water-bar');
        bars.forEach(bar => {
            const waterElements = bar.querySelectorAll('.water-filled');
            waterElements.forEach(el => el.remove());
        });
        
        const waterLevels = barsContainer.querySelectorAll('.water-level');
        waterLevels.forEach(el => el.remove());
    }
    
    // Start algorithm
    performWaterStep();
}

// NEW: Perform Trapping Rain Water Animation
function performTrappingRainWaterAnimation() {
    const barsContainer = document.getElementById('waterBarsContainer');
    const explanation = document.getElementById('waterExplanation');
    const stepsContainer = document.getElementById('waterSteps');
    const trappedWater = document.getElementById('trappedWater');
    const continueButton = document.getElementById('continueAfterWater');
    
    const height = originalArrayForWater.map(val => parseFloat(val));
    let left = 0;
    let right = height.length - 1;
    let leftMax = 0;
    let rightMax = 0;
    let totalWater = 0;
    let step = 0;
    
    function performTrapStep() {
        if (left >= right) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Total trapped water = ${totalWater} units`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Total water trapped between bars = ${totalWater} units
                </div>
            `;
            
            trappedWater.textContent = `${totalWater} units`;
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterWater();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterWater);
            
            return;
        }
        
        step++;
        
        if (height[left] < height[right]) {
            // Process left side
            leftMax = Math.max(leftMax, height[left]);
            const waterAtLeft = leftMax - height[left];
            
            explanation.innerHTML = `Step ${step}: Left=${left}, Height=${height[left]}, LeftMax=${leftMax}, Water=${waterAtLeft}`;
            
            // Highlight and visualize
            const bars = barsContainer.querySelectorAll('.array-element');
            const leftBar = bars[left].querySelector('.water-bar');
            leftBar.classList.add('water-pointer-left');
            
            visualizeTrappedWater(left, waterAtLeft, 'left');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Processing left side. LeftMax=${leftMax}, Water at [${left}] = ${leftMax} - ${height[left]} = ${waterAtLeft}
                </div>
            `;
            
            totalWater += waterAtLeft;
            left++;
            
        } else {
            // Process right side
            rightMax = Math.max(rightMax, height[right]);
            const waterAtRight = rightMax - height[right];
            
            explanation.innerHTML = `Step ${step}: Right=${right}, Height=${height[right]}, RightMax=${rightMax}, Water=${waterAtRight}`;
            
            // Highlight and visualize
            const bars = barsContainer.querySelectorAll('.array-element');
            const rightBar = bars[right].querySelector('.water-bar');
            rightBar.classList.add('water-pointer-right');
            
            visualizeTrappedWater(right, waterAtRight, 'right');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Processing right side. RightMax=${rightMax}, Water at [${right}] = ${rightMax} - ${height[right]} = ${waterAtRight}
                </div>
            `;
            
            totalWater += waterAtRight;
            right--;
        }
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        trappedWater.textContent = `${totalWater} units`;
        
        setTimeout(() => {
            // Remove highlights and continue
            const bars = barsContainer.querySelectorAll('.water-bar');
            bars.forEach(bar => {
                bar.classList.remove('water-pointer-left', 'water-pointer-right');
            });
            performTrapStep();
        }, 1500);
    }
    
    function visualizeTrappedWater(index, waterAmount, side) {
        if (waterAmount > 0) {
            const bars = barsContainer.querySelectorAll('.array-element');
            const bar = bars[index].querySelector('.water-bar');
            const maxHeight = Math.max(...height);
            const scaleFactor = 150 / (maxHeight || 1);
            
            const waterHeight = waterAmount * scaleFactor;
            const waterDiv = document.createElement('div');
            waterDiv.className = 'water-filled';
            waterDiv.style.height = `${waterHeight}px`;
            waterDiv.title = `Trapped water: ${waterAmount} units`;
            waterDiv.style.background = side === 'left' ? 'var(--warning-color)' : 'var(--success-color)';
            bar.appendChild(waterDiv);
        }
    }
    
    // Start algorithm
    performTrapStep();
}

// NEW: Return to Original after Water Problems
function returnToOriginalAfterWater() {
    // Reset to original array
    myArray = [...originalArrayForWater];
    originalArrayForWater = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isWaterProblemRunning = false;
    
    logOperation('Water problem completed - returned to original array', 'info');
    showNotification('Returned to original array after water problem', 'success');
}
// NEW: Two Sum Handler
function handleTwoSum() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isTwoSumRunning) {
        showNotification('Two Sum operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Two Sum problem requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Show input group
    twoSumInputGroup.style.display = 'block';
    twoSumTargetInput.focus();
    
    logOperation('Started Two Sum problem', 'info');
}

// NEW: Confirm Two Sum Handler
function handleConfirmTwoSum() {
    const target = parseFloat(twoSumTargetInput.value);
    
    if (isNaN(target)) {
        showNotification('Please enter a valid target sum', 'danger');
        twoSumTargetInput.focus();
        return;
    }
    
    twoSumTarget = target;
    
    // Store original array
    originalArrayForTwoSum = [...myArray];
    
    // Hide input group
    twoSumInputGroup.style.display = 'none';
    twoSumTargetInput.value = '';
    
    // Start Two Sum visualization
    showTwoSumVisualization();
}

// NEW: Cancel Two Sum Handler
function handleCancelTwoSum() {
    twoSumInputGroup.style.display = 'none';
    twoSumTargetInput.value = '';
    
    logOperation('Cancelled Two Sum operation', 'info');
    showNotification('Two Sum operation cancelled', 'info');
}

// NEW: Show Two Sum Visualization
function showTwoSumVisualization() {
    isTwoSumRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Two Sum Problem - Target: ${twoSumTarget}</h5>
        
        <div class="array-group">
            <div class="array-label">Array</div>
            <div class="original-array-container" id="twoSumArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Two Sum Problem:</strong> Find all pairs of indices where array[i] + array[j] = ${twoSumTarget}</p>
            <p class="mb-0" id="twoSumExplanation">Initializing Two Sum algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="twoSumStepsContainer">
            <h6 class="text-center">Two Sum Algorithm Steps</h6>
            <div class="steps-container" id="twoSumSteps"></div>
        </div>
        
        <div class="two-sum-results mt-3" id="twoSumResults" style="display: none;">
            <h6 class="text-center">Two Sum Results</h6>
            <div id="twoSumPairsList" class="text-center"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterTwoSum" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForTwoSum, 'twoSumArray');
    
    performTwoSumAlgorithm();
}
// NEW: Perform Two Sum Algorithm with Animation
function performTwoSumAlgorithm() {
    const arrayContainer = document.getElementById('twoSumArray');
    const explanation = document.getElementById('twoSumExplanation');
    const stepsContainer = document.getElementById('twoSumSteps');
    const resultsContainer = document.getElementById('twoSumResults');
    const pairsList = document.getElementById('twoSumPairsList');
    const continueButton = document.getElementById('continueAfterTwoSum');
    
    const arr = originalArrayForTwoSum.map(val => parseFloat(val));
    const pairs = [];
    let step = 0;
    
    function executeTwoSumStep(i, j) {
        if (i >= arr.length - 1) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Two Sum Algorithm Completed!</strong> Found ${pairs.length} pair(s).`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Two Sum algorithm completed. Found ${pairs.length} pair(s) that sum to ${twoSumTarget}.
                </div>
            `;
            
            // Display results
            if (pairs.length > 0) {
                resultsContainer.style.display = 'block';
                pairsList.innerHTML = '<p><strong>Output:</strong></p>';
                pairs.forEach(pair => {
                    const pairElement = document.createElement('div');
                    pairElement.className = 'two-sum-pair';
                    pairElement.textContent = `[${pair[0]}, ${pair[1]}]`;
                    pairElement.title = `Values: ${arr[pair[0]]} + ${arr[pair[1]]} = ${twoSumTarget}`;
                    pairsList.appendChild(pairElement);
                });
            } else {
                pairsList.innerHTML = '<p class="text-warning">No pairs found that sum to the target.</p>';
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterTwoSum();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterTwoSum);
            
            return;
        }
        
        if (j >= arr.length) {
            // Move to next i
            executeTwoSumStep(i + 1, i + 2);
            return;
        }
        
        step++;
        explanation.innerHTML = `Step ${step}: Checking indices [${i}, ${j}] - Values: ${arr[i]} + ${arr[j]}`;
        
        // Highlight current elements being checked
        const elements = arrayContainer.querySelectorAll('.array-element');
        const elementI = elements[i].querySelector('.element-value');
        const elementJ = elements[j].querySelector('.element-value');
        
        elementI.classList.add('two-sum-current');
        elementJ.classList.add('two-sum-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Checking [${i}]=${arr[i]} and [${j}]=${arr[j]} - Sum = ${arr[i] + arr[j]}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            if (arr[i] + arr[j] === twoSumTarget) {
                // Found a pair
                explanation.innerHTML = `Step ${step}: FOUND! [${i}, ${j}] - ${arr[i]} + ${arr[j]} = ${twoSumTarget}`;
                
                elementI.classList.remove('two-sum-current');
                elementJ.classList.remove('two-sum-current');
                elementI.classList.add('two-sum-found');
                elementJ.classList.add('two-sum-found');
                
                pairs.push([i, j]);
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>FOUND PAIR:</strong> [${i}, ${j}] - ${arr[i]} + ${arr[j]} = ${twoSumTarget}
                    </div>
                `;
                
                // Continue with next j
                setTimeout(() => {
                    elementI.classList.remove('two-sum-found');
                    elementJ.classList.remove('two-sum-found');
                    elementI.classList.add('two-sum-checked');
                    elementJ.classList.add('two-sum-checked');
                    
                    executeTwoSumStep(i, j + 1);
                }, 2000);
                
            } else {
                // Not a pair
                elementI.classList.remove('two-sum-current');
                elementJ.classList.remove('two-sum-current');
                elementI.classList.add('two-sum-checked');
                elementJ.classList.add('two-sum-checked');
                
                executeTwoSumStep(i, j + 1);
            }
        }, 1500);
    }
    
    // Start Two Sum algorithm
    executeTwoSumStep(0, 1);
}
// NEW: Return to Original after Two Sum
function returnToOriginalAfterTwoSum() {
    // Reset to original array
    myArray = [...originalArrayForTwoSum];
    originalArrayForTwoSum = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isTwoSumRunning = false;
    
    logOperation('Two Sum problem completed - returned to original array', 'info');
    showNotification('Returned to original array after Two Sum problem', 'success');
}
// NEW: Find GCD Handler
function handleFindGCD() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isGcdOperationRunning) {
        showNotification('GCD operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('GCD calculation requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Check for non-negative integers
    for (let i = 0; i < myArray.length; i++) {
        const num = parseFloat(myArray[i]);
        if (num < 0 || !Number.isInteger(num)) {
            showNotification('GCD calculation requires non-negative integers', 'danger');
            return;
        }
    }
    
    isGcdOperationRunning = true;
    
    // Store original array
    originalArrayForGcdLcm = [...myArray];
    
    // Perform GCD visualization
    performGCDVisualization();
}

// NEW: Find LCM Handler
function handleFindLCM() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isLcmOperationRunning) {
        showNotification('LCM operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('LCM calculation requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Check for positive integers
    for (let i = 0; i < myArray.length; i++) {
        const num = parseFloat(myArray[i]);
        if (num <= 0 || !Number.isInteger(num)) {
            showNotification('LCM calculation requires positive integers', 'danger');
            return;
        }
    }
    
    isLcmOperationRunning = true;
    
    // Store original array
    originalArrayForGcdLcm = [...myArray];
    
    // Perform LCM visualization
    performLCMVisualization();
}
// NEW: Perform GCD Visualization
function performGCDVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find GCD (Greatest Common Divisor) of Array</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalGcdArray"></div>
        </div>
        
        <div class="gcd-lcm-explanation">
            <p class="mb-2"><strong>GCD Algorithm:</strong> Finding the largest number that divides all elements</p>
            <p class="mb-0" id="gcdExplanation">Starting GCD calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="gcdStepsContainer">
            <h6 class="text-center">GCD Calculation Steps</h6>
            <div class="steps-container" id="gcdSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>GCD of Array</div>
            <div class="stats-value" id="gcdResultValue">Calculating...</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterGcd" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForGcdLcm, 'originalGcdArray');
    
    executeGCDAlgorithm();
}

// NEW: Perform LCM Visualization
function performLCMVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find LCM (Least Common Multiple) of Array</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalLcmArray"></div>
        </div>
        
        <div class="gcd-lcm-explanation">
            <p class="mb-2"><strong>LCM Algorithm:</strong> Finding the smallest number divisible by all elements</p>
            <p class="mb-0" id="lcmExplanation">Starting LCM calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="lcmStepsContainer">
            <h6 class="text-center">LCM Calculation Steps</h6>
            <div class="steps-container" id="lcmSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>LCM of Array</div>
            <div class="stats-value" id="lcmResultValue">Calculating...</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterLcm" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForGcdLcm, 'originalLcmArray');
    
    executeLCMAlgorithm();
}
// NEW: Execute GCD Algorithm with Animation
function executeGCDAlgorithm() {
    const arrayContainer = document.getElementById('originalGcdArray');
    const explanation = document.getElementById('gcdExplanation');
    const stepsContainer = document.getElementById('gcdSteps');
    const gcdResultValue = document.getElementById('gcdResultValue');
    const continueButton = document.getElementById('continueAfterGcd');
    
    const arr = originalArrayForGcdLcm.map(val => parseInt(val));
    let step = 0;
    
    function calculateGCD(a, b) {
        if (b === 0) return a;
        return calculateGCD(b, a % b);
    }
    
    function executeGCDStep(currentGCD, nextIndex) {
        if (nextIndex >= arr.length) {
            // GCD calculation completed
            explanation.innerHTML = `<strong>GCD Calculation Completed!</strong>`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> GCD of array [${originalArrayForGcdLcm.join(', ')}] is ${currentGCD}
                </div>
            `;
            
            // Highlight all elements and show result
            const elements = arrayContainer.querySelectorAll('.array-element');
            elements.forEach((el, index) => {
                setTimeout(() => {
                    const valueDiv = el.querySelector('.element-value');
                    valueDiv.classList.add('gcd-highlight');
                    
                    // Show which elements are divisible by GCD
                    if (arr[index] % currentGCD === 0) {
                        setTimeout(() => {
                            valueDiv.classList.add('gcd-lcm-result');
                        }, 500);
                    }
                }, index * 300);
            });
            
            gcdResultValue.textContent = currentGCD;
            gcdResultValue.classList.add('gcd-lcm-result');
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterGcdLcm();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterGcdLcm);
            
            return;
        }
        
        step++;
        const nextNum = arr[nextIndex];
        
        explanation.innerHTML = `Step ${step}: Calculating GCD(${currentGCD}, ${nextNum})`;
        
        // Highlight current numbers being compared
        const elements = arrayContainer.querySelectorAll('.array-element');
        
        // Highlight all previous elements that contributed to current GCD
        for (let i = 0; i < nextIndex; i++) {
            elements[i].querySelector('.element-value').classList.add('gcd-highlight');
        }
        
        // Highlight the next number
        elements[nextIndex].querySelector('.element-value').classList.add('gcd-highlight');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> GCD(${currentGCD}, ${nextNum}) = 
            </div>
        `;
        
        setTimeout(() => {
            const newGCD = calculateGCD(currentGCD, nextNum);
            
            stepsContainer.innerHTML = stepsContainer.innerHTML.replace(
                `GCD(${currentGCD}, ${nextNum}) = `,
                `GCD(${currentGCD}, ${nextNum}) = ${newGCD}`
            );
            
            explanation.innerHTML = `Step ${step}: GCD(${currentGCD}, ${nextNum}) = ${newGCD}`;
            
            // Remove highlights for next step
            elements[nextIndex].querySelector('.element-value').classList.remove('gcd-highlight');
            
            // Continue with next number
            setTimeout(() => {
                executeGCDStep(newGCD, nextIndex + 1);
            }, 1500);
            
        }, 1000);
    }
    
    // Start with first element
    explanation.innerHTML = `Starting with first element: ${arr[0]}`;
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Initial:</strong> Start with first element = ${arr[0]}
        </div>
    `;
    
    const elements = arrayContainer.querySelectorAll('.array-element');
    elements[0].querySelector('.element-value').classList.add('gcd-highlight');
    
    setTimeout(() => {
        executeGCDStep(arr[0], 1);
    }, 1000);
}

// NEW: Execute LCM Algorithm with Animation
function executeLCMAlgorithm() {
    const arrayContainer = document.getElementById('originalLcmArray');
    const explanation = document.getElementById('lcmExplanation');
    const stepsContainer = document.getElementById('lcmSteps');
    const lcmResultValue = document.getElementById('lcmResultValue');
    const continueButton = document.getElementById('continueAfterLcm');
    
    const arr = originalArrayForGcdLcm.map(val => parseInt(val));
    let step = 0;
    
    function calculateGCD(a, b) {
        if (b === 0) return a;
        return calculateGCD(b, a % b);
    }
    
    function calculateLCM(a, b) {
        return (a * b) / calculateGCD(a, b);
    }
    
    function executeLCMStep(currentLCM, nextIndex) {
        if (nextIndex >= arr.length) {
            // LCM calculation completed
            explanation.innerHTML = `<strong>LCM Calculation Completed!</strong>`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> LCM of array [${originalArrayForGcdLcm.join(', ')}] is ${currentLCM}
                </div>
            `;
            
            // Highlight all elements and show result
            const elements = arrayContainer.querySelectorAll('.array-element');
            elements.forEach((el, index) => {
                setTimeout(() => {
                    const valueDiv = el.querySelector('.element-value');
                    valueDiv.classList.add('lcm-highlight');
                    
                    // Show that LCM is multiple of each element
                    if (currentLCM % arr[index] === 0) {
                        setTimeout(() => {
                            valueDiv.classList.add('gcd-lcm-result');
                        }, 500);
                    }
                }, index * 300);
            });
            
            lcmResultValue.textContent = currentLCM;
            lcmResultValue.classList.add('gcd-lcm-result');
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterGcdLcm();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterGcdLcm);
            
            return;
        }
        
        step++;
        const nextNum = arr[nextIndex];
        
        explanation.innerHTML = `Step ${step}: Calculating LCM(${currentLCM}, ${nextNum})`;
        
        // Highlight current numbers being compared
        const elements = arrayContainer.querySelectorAll('.array-element');
        
        // Highlight all previous elements that contributed to current LCM
        for (let i = 0; i < nextIndex; i++) {
            elements[i].querySelector('.element-value').classList.add('lcm-highlight');
        }
        
        // Highlight the next number
        elements[nextIndex].querySelector('.element-value').classList.add('lcm-highlight');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> LCM(${currentLCM}, ${nextNum}) = 
            </div>
        `;
        
        setTimeout(() => {
            const newLCM = calculateLCM(currentLCM, nextNum);
            
            stepsContainer.innerHTML = stepsContainer.innerHTML.replace(
                `LCM(${currentLCM}, ${nextNum}) = `,
                `LCM(${currentLCM}, ${nextNum}) = ${newLCM}`
            );
            
            explanation.innerHTML = `Step ${step}: LCM(${currentLCM}, ${nextNum}) = ${newLCM}`;
            
            // Show calculation details
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Calculation:</strong> (${currentLCM}  ${nextNum})  GCD(${currentLCM}, ${nextNum}) = ${newLCM}
                </div>
            `;
            
            // Remove highlights for next step
            elements[nextIndex].querySelector('.element-value').classList.remove('lcm-highlight');
            
            // Continue with next number
            setTimeout(() => {
                executeLCMStep(newLCM, nextIndex + 1);
            }, 2000);
            
        }, 1000);
    }
    
    // Start with first element
    explanation.innerHTML = `Starting with first element: ${arr[0]}`;
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Initial:</strong> Start with first element = ${arr[0]}
        </div>
    `;
    
    const elements = arrayContainer.querySelectorAll('.array-element');
    elements[0].querySelector('.element-value').classList.add('lcm-highlight');
    
    setTimeout(() => {
        executeLCMStep(arr[0], 1);
    }, 1000);
}
// NEW: Return to Original after GCD/LCM Operations
function returnToOriginalAfterGcdLcm() {
    // Reset to original array
    myArray = [...originalArrayForGcdLcm];
    originalArrayForGcdLcm = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset states
    isGcdOperationRunning = false;
    isLcmOperationRunning = false;
    
    logOperation('GCD/LCM operation completed - returned to original array', 'info');
    showNotification('Returned to original array after mathematical operation', 'success');
}
// NEW: Prime Sieve Handler
function handlePrimeSieve() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isPrimeSieveRunning) {
        showNotification('Prime sieve operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Prime sieve requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Check for positive integers
    for (let i = 0; i < myArray.length; i++) {
        const num = parseFloat(myArray[i]);
        if (num < 0 || !Number.isInteger(num)) {
            showNotification('Prime sieve requires positive integers', 'danger');
            return;
        }
    }
    
    isPrimeSieveRunning = true;
    
    // Store original array
    originalArrayForPrimeSieve = [...myArray];
    
    // Perform prime sieve visualization
    performPrimeSieveVisualization();
}
// NEW: Perform Prime Sieve Visualization
function performPrimeSieveVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Prime Sieve - Identify Prime Numbers</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalPrimeArray"></div>
        </div>
        
        <div class="prime-sieve-explanation">
            <p class="mb-2"><strong>Sieve Algorithm:</strong> Identifying prime numbers (green) and composite numbers (red)</p>
            <p class="mb-0" id="sieveExplanation">Starting prime sieve analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="sieveStepsContainer">
            <h6 class="text-center">Sieve Process Steps</h6>
            <div class="steps-container" id="sieveSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Prime Numbers Found</div>
            <div class="stats-value" id="primesCount">0</div>
        </div>
        
        <div class="primes-list" id="primesListContainer" style="display: none;">
            <h6 class="text-center mb-3">Prime Numbers in Array</h6>
            <div id="primesList"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSieve" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForPrimeSieve, 'originalPrimeArray');
    
    executePrimeSieveAlgorithm();
}
// NEW: Execute Prime Sieve Algorithm with Animation
function executePrimeSieveAlgorithm() {
    const arrayContainer = document.getElementById('originalPrimeArray');
    const explanation = document.getElementById('sieveExplanation');
    const stepsContainer = document.getElementById('sieveSteps');
    const primesCount = document.getElementById('primesCount');
    const primesListContainer = document.getElementById('primesListContainer');
    const primesList = document.getElementById('primesList');
    const continueButton = document.getElementById('continueAfterSieve');
    
    const arr = originalArrayForPrimeSieve.map(val => parseInt(val));
    let step = 0;
    let primes = [];
    
    // Helper function to check if a number is prime
    function isPrime(num) {
        if (num <= 1) return false;
        if (num <= 3) return true;
        if (num % 2 === 0 || num % 3 === 0) return false;
        
        for (let i = 5; i * i <= num; i += 6) {
            if (num % i === 0 || num % (i + 2) === 0) return false;
        }
        return true;
    }
    
    function executeSieveStep(index) {
        if (index >= arr.length) {
            // Sieve completed
            explanation.innerHTML = `<strong>Prime Sieve Completed!</strong> Found ${primes.length} prime numbers.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Analysis complete. Found ${primes.length} prime numbers in the array.
                </div>
            `;
            
            // Show primes list
            primesListContainer.style.display = 'block';
            primesList.innerHTML = '';
            primes.forEach(prime => {
                const primeElement = document.createElement('span');
                primeElement.className = 'prime-item';
                primeElement.textContent = prime;
                primeElement.style.animationDelay = `${primes.indexOf(prime) * 100}ms`;
                primesList.appendChild(primeElement);
            });
            
            primesCount.textContent = primes.length;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterPrimeSieve();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterPrimeSieve);
            
            return;
        }
        
        step++;
        const currentNum = arr[index];
        
        explanation.innerHTML = `Step ${step}: Checking if ${currentNum} is prime`;
        
        // Highlight current number being checked
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElement = elements[index].querySelector('.element-value');
        currentElement.classList.add('sieve-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Checking number ${currentNum}...
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Check if the number is prime
            const primeCheck = isPrime(currentNum);
            
            if (primeCheck) {
                // It's a prime number
                currentElement.classList.remove('sieve-current');
                currentElement.classList.add('prime-number');
                primes.push(currentNum);
                
                stepsContainer.innerHTML = stepsContainer.innerHTML.replace(
                    `Checking number ${currentNum}...`,
                    ` ${currentNum} is a PRIME number`
                );
                
                explanation.innerHTML = `Step ${step}: ${currentNum} is a PRIME number `;
                
            } else {
                // It's a composite number
                currentElement.classList.remove('sieve-current');
                currentElement.classList.add('composite-number');
                
                stepsContainer.innerHTML = stepsContainer.innerHTML.replace(
                    `Checking number ${currentNum}...`,
                    ` ${currentNum} is a COMPOSITE number`
                );
                
                explanation.innerHTML = `Step ${step}: ${currentNum} is a COMPOSITE number `;
            }
            
            // Update primes count
            primesCount.textContent = primes.length;
            
            // Show special cases
            if (currentNum === 0 || currentNum === 1) {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Note:</strong> ${currentNum} is neither prime nor composite
                    </div>
                `;
            }
            
            // Move to next number
            setTimeout(() => {
                executeSieveStep(index + 1);
            }, 1500);
            
        }, 1000);
    }
    
    // Start the sieve process
    explanation.innerHTML = `Starting prime sieve analysis for ${arr.length} numbers...`;
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Initial:</strong> Beginning prime number analysis for array: [${arr.join(', ')}]
        </div>
    `;
    
    // Initial highlight of all elements
    const elements = arrayContainer.querySelectorAll('.array-element');
    elements.forEach((el, idx) => {
        setTimeout(() => {
            el.querySelector('.element-value').classList.add('sieve-multiple');
        }, idx * 100);
    });
    
    setTimeout(() => {
        // Remove initial highlights and start checking
        elements.forEach(el => {
            el.querySelector('.element-value').classList.remove('sieve-multiple');
        });
        executeSieveStep(0);
    }, 1000);
}
// NEW: Enhanced Prime Sieve with Sieve of Eratosthenes
function performEnhancedPrimeSieve() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Sieve of Eratosthenes - Prime Number Identification</h5>
        
        <div class="array-group">
            <div class="array-label">Number Array</div>
            <div class="original-array-container" id="enhancedPrimeArray"></div>
        </div>
        
        <div class="prime-sieve-explanation">
            <p class="mb-2"><strong>Sieve of Eratosthenes:</strong> Classical algorithm for finding all primes up to a given limit</p>
            <p class="mb-0" id="enhancedSieveExplanation">Initializing sieve algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="enhancedSieveStepsContainer">
            <h6 class="text-center">Sieve Algorithm Steps</h6>
            <div class="steps-container" id="enhancedSieveSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Prime Numbers Found</div>
            <div class="stats-value" id="enhancedPrimesCount">0</div>
        </div>
        
        <div class="primes-list" id="enhancedPrimesListContainer" style="display: none;">
            <h6 class="text-center mb-3">Prime Numbers Identified</h6>
            <div id="enhancedPrimesList"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterEnhancedSieve" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForPrimeSieve, 'enhancedPrimeArray');
    
    executeEnhancedSieveAlgorithm();
}

// NEW: Execute Enhanced Sieve Algorithm
function executeEnhancedSieveAlgorithm() {
    const arrayContainer = document.getElementById('enhancedPrimeArray');
    const explanation = document.getElementById('enhancedSieveExplanation');
    const stepsContainer = document.getElementById('enhancedSieveSteps');
    const primesCount = document.getElementById('enhancedPrimesCount');
    const primesListContainer = document.getElementById('enhancedPrimesListContainer');
    const primesList = document.getElementById('enhancedPrimesList');
    const continueButton = document.getElementById('continueAfterEnhancedSieve');
    
    const arr = originalArrayForPrimeSieve.map(val => parseInt(val));
    const maxNum = Math.max(...arr);
    let step = 0;
    let primes = [];
    
    // Create a sieve array
    let sieve = Array(maxNum + 1).fill(true);
    sieve[0] = sieve[1] = false;
    
    function executeEnhancedStep(p) {
        if (p * p > maxNum) {
            // Mark remaining primes in the original array
            markPrimesInOriginalArray();
            return;
        }
        
        if (sieve[p]) {
            step++;
            explanation.innerHTML = `Step ${step}: ${p} is prime - marking its multiples`;
            
            // Highlight current prime
            const elements = arrayContainer.querySelectorAll('.array-element');
            elements.forEach((el, index) => {
                if (arr[index] === p) {
                    el.querySelector('.element-value').classList.add('prime-number');
                }
            });
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> ${p} is prime  Marking multiples: 
                </div>
            `;
            
            let multiples = [];
            // Mark multiples of p
            for (let i = p * p; i <= maxNum; i += p) {
                if (sieve[i]) {
                    sieve[i] = false;
                    multiples.push(i);
                    
                    // Highlight multiples in the array
                    elements.forEach((el, index) => {
                        if (arr[index] === i) {
                            setTimeout(() => {
                                el.querySelector('.element-value').classList.add('composite-number');
                            }, multiples.length * 200);
                        }
                    });
                }
            }
            
            stepsContainer.innerHTML = stepsContainer.innerHTML.replace(
                'Marking multiples: ',
                `Marking multiples: ${multiples.join(', ')}`
            );
            
            setTimeout(() => {
                executeEnhancedStep(p + 1);
            }, 1000 + multiples.length * 200);
            
        } else {
            executeEnhancedStep(p + 1);
        }
    }
    
    function markPrimesInOriginalArray() {
        // Final marking of all numbers in the original array
        const elements = arrayContainer.querySelectorAll('.array-element');
        let finalPrimes = [];
        
        elements.forEach((el, index) => {
            const num = arr[index];
            setTimeout(() => {
                if (sieve[num]) {
                    el.querySelector('.element-value').classList.add('prime-number');
                    finalPrimes.push(num);
                } else if (num > 1) {
                    el.querySelector('.element-value').classList.add('composite-number');
                }
            }, index * 200);
        });
        
        setTimeout(() => {
            // Sieve completed
            explanation.innerHTML = `<strong>Sieve of Eratosthenes Completed!</strong> Found ${finalPrimes.length} prime numbers.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Algorithm complete. Identified all prime numbers using Sieve of Eratosthenes.
                </div>
            `;
            
            // Show primes list
            primesListContainer.style.display = 'block';
            primesList.innerHTML = '';
            finalPrimes.forEach(prime => {
                const primeElement = document.createElement('span');
                primeElement.className = 'prime-item';
                primeElement.textContent = prime;
                primesList.appendChild(primeElement);
            });
            
            primesCount.textContent = finalPrimes.length;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterPrimeSieve();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterPrimeSieve);
        }, arr.length * 200 + 1000);
    }
    
    // Start the enhanced sieve process
    explanation.innerHTML = `Starting Sieve of Eratosthenes for numbers up to ${maxNum}...`;
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Algorithm:</strong> Sieve of Eratosthenes - Classical prime finding algorithm
        </div>
    `;
    
    setTimeout(() => {
        executeEnhancedStep(2);
    }, 1000);
}
// NEW: Longest Substring Without Repeating Characters Handler
function handleFindLongestSubstring() {
    const inputString = substringInput.value.trim();
    
    if (inputString === '') {
        showNotification('Please enter a string to analyze', 'warning');
        substringInput.focus();
        return;
    }
    
    if (isLongestSubstringRunning) {
        showNotification('Longest substring operation is already in progress', 'warning');
        return;
    }
    
    isLongestSubstringRunning = true;
    
    // Store original array
    originalArrayForSubstring = [...myArray];
    
    // Convert string to character array for visualization
    const charArray = inputString.split('');
    
    // Show longest substring visualization
    showLongestSubstringVisualization(inputString, charArray);
}

// NEW: Show Longest Substring Visualization
function showLongestSubstringVisualization(inputString, charArray) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Longest Substring Without Repeating Characters</h5>
        
        <div class="array-group">
            <div class="array-label">Input String: "${inputString}"</div>
            <div class="char-array-container" id="charArrayDisplay"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Sliding Window Process</div>
            <div id="slidingWindowContainer"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Sliding window with character frequency tracking</p>
            <p class="mb-0" id="substringExplanation">Initializing sliding window algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="substringStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="substringSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Longest Substring Length</div>
            <div class="stats-value" id="currentMaxLength">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Current Longest Substring</div>
            <div class="stats-value" id="currentLongestSubstring">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSubstring" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Render character array
    renderCharArray(charArray, 'charArrayDisplay');
    
    // Start the algorithm animation
    performLongestSubstringAlgorithm(inputString, charArray);
}

// NEW: Render Character Array
function renderCharArray(charArray, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    charArray.forEach((char, index) => {
        const charElement = document.createElement('div');
        charElement.className = 'char-element';
        charElement.innerHTML = `
            <div class="char-value" data-index="${index}">${char}</div>
            <div class="char-index">[${index}]</div>
        `;
        container.appendChild(charElement);
    });
}

// NEW: Perform Longest Substring Algorithm with Animation
function performLongestSubstringAlgorithm(inputString, charArray) {
    const charContainer = document.getElementById('charArrayDisplay');
    const slidingWindowContainer = document.getElementById('slidingWindowContainer');
    const explanation = document.getElementById('substringExplanation');
    const stepsContainer = document.getElementById('substringSteps');
    const currentMaxLength = document.getElementById('currentMaxLength');
    const currentLongestSubstring = document.getElementById('currentLongestSubstring');
    const continueButton = document.getElementById('continueAfterSubstring');
    
    let maxLength = 0;
    let start = 0;
    let charMap = new Map();
    let currentSubstring = '';
    let step = 0;
    let maxStart = 0;
    let maxEnd = 0;
    
    function performAlgorithmStep(end) {
        if (end >= charArray.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Longest substring found.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Longest substring without repeating characters: "${inputString.substring(maxStart, maxEnd + 1)}" (length: ${maxLength})
                </div>
            `;
            
            // Highlight the final longest substring in the character array
            const charElements = charContainer.querySelectorAll('.char-value');
            for (let i = maxStart; i <= maxEnd; i++) {
                setTimeout(() => {
                    charElements[i].classList.add('substring-max');
                }, (i - maxStart) * 200);
            }
            
            // Show final results
            longestSubstringResults.style.display = 'block';
            longestSubstringLength.textContent = maxLength;
            longestSubstringValue.textContent = `"${inputString.substring(maxStart, maxEnd + 1)}"`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterSubstring();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSubstring);
            
            return;
        }
        
        step++;
        const currentChar = charArray[end];
        
        // Update explanation
        explanation.innerHTML = `Step ${step}: Processing character at index ${end} = "${currentChar}"`;
        
        // Highlight current character
        const charElements = charContainer.querySelectorAll('.char-value');
        charElements[end].classList.add('substring-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Processing index ${end} = "${currentChar}"
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            if (charMap.has(currentChar) && charMap.get(currentChar) >= start) {
                // Duplicate character found
                const duplicateIndex = charMap.get(currentChar);
                explanation.innerHTML = `Step ${step}: Duplicate character "${currentChar}" found at index ${duplicateIndex}`;
                
                // Highlight duplicate character
                charElements[duplicateIndex].classList.add('substring-duplicate');
                charElements[end].classList.add('substring-duplicate');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> Duplicate "${currentChar}" found! Moving start from ${start} to ${duplicateIndex + 1}
                    </div>
                `;
                
                setTimeout(() => {
                    // Remove duplicate highlights
                    charElements[duplicateIndex].classList.remove('substring-duplicate');
                    charElements[end].classList.remove('substring-duplicate');
                    
                    // Move start pointer
                    start = charMap.get(currentChar) + 1;
                    
                    // Update current substring
                    currentSubstring = inputString.substring(start, end + 1);
                    
                    // Update sliding window visualization
                    updateSlidingWindowVisualization(start, end, currentSubstring);
                    
                    // Continue algorithm
                    charMap.set(currentChar, end);
                    checkMaxLength(end);
                }, 1500);
                
            } else {
                // No duplicate, extend window
                currentSubstring = inputString.substring(start, end + 1);
                explanation.innerHTML = `Step ${step}: No duplicate. Current substring: "${currentSubstring}"`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step}:</strong> No duplicate. Window extended to: "${currentSubstring}"
                    </div>
                `;
                
                // Update sliding window visualization
                updateSlidingWindowVisualization(start, end, currentSubstring);
                
                // Add character to map and check max length
                charMap.set(currentChar, end);
                checkMaxLength(end);
            }
            
            function checkMaxLength(end) {
                const currentLength = end - start + 1;
                
                if (currentLength > maxLength) {
                    maxLength = currentLength;
                    maxStart = start;
                    maxEnd = end;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>New Maximum!</strong> Length: ${maxLength}, Substring: "${inputString.substring(start, end + 1)}"
                        </div>
                    `;
                    
                    // Highlight the new maximum substring
                    const allCharElements = charContainer.querySelectorAll('.char-value');
                    for (let i = start; i <= end; i++) {
                        allCharElements[i].classList.add('substring-max');
                    }
                    
                    // Remove max highlight from previous substrings after a delay
                    setTimeout(() => {
                        for (let i = 0; i < allCharElements.length; i++) {
                            if (i < start || i > end) {
                                allCharElements[i].classList.remove('substring-max');
                            }
                        }
                    }, 1000);
                }
                
                // Update current stats
                currentMaxLength.textContent = maxLength;
                currentLongestSubstring.textContent = `"${inputString.substring(maxStart, maxEnd + 1)}"`;
                
                // Remove current highlight and continue
                charElements[end].classList.remove('substring-current');
                
                // Continue to next character
                setTimeout(() => {
                    performAlgorithmStep(end + 1);
                }, 1000);
            }
        }, 1000);
    }
    
    // Start algorithm
    performAlgorithmStep(0);
}

// NEW: Update Sliding Window Visualization
function updateSlidingWindowVisualization(start, end, currentSubstring) {
    const slidingWindowContainer = document.getElementById('slidingWindowContainer');
    
    const windowElement = document.createElement('div');
    windowElement.className = 'substring-window';
    windowElement.innerHTML = `
        <div class="substring-window-label">Window [${start}-${end}]</div>
        <div class="char-array-container">
            ${currentSubstring.split('').map((char, index) => `
                <div class="char-element">
                    <div class="char-value substring-included">${char}</div>
                    <div class="char-index">[${start + index}]</div>
                </div>
            `).join('')}
        </div>
        <div class="text-center mt-2">
            <small>Current Substring: "${currentSubstring}" (Length: ${end - start + 1})</small>
        </div>
    `;
    
    // Clear previous window and add new one
    slidingWindowContainer.innerHTML = '';
    slidingWindowContainer.appendChild(windowElement);
}

// NEW: Return to Original after Substring Operation
function returnToOriginalAfterSubstring() {
    // Reset to original array
    myArray = [...originalArrayForSubstring];
    originalArrayForSubstring = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isLongestSubstringRunning = false;
    
    // Clear input and hide results
    substringInput.value = '';
    longestSubstringResults.style.display = 'none';
    
    logOperation('Longest substring operation completed - returned to original array', 'info');
    showNotification('Returned to original array after longest substring operation', 'success');
}
// NEW: Subarray Product Less Than K Handler
function handleSubarrayProduct() {
    const k = parseFloat(subarrayProductK.value);
    
    if (isNaN(k) || k <= 0) {
        showNotification('Please enter a valid positive k value', 'danger');
        subarrayProductK.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Subarray product operations require all array elements to be numbers', 'danger');
        return;
    }
    
    if (isSubarrayProductRunning) {
        showNotification('A subarray product operation is already in progress', 'warning');
        return;
    }
    
    isSubarrayProductRunning = true;
    
    // Store original array
    originalArrayForProduct = [...myArray];
    
    // Perform subarray product visualization
    performSubarrayProductVisualization(k);
}
// NEW: Perform Subarray Product Visualization
function performSubarrayProductVisualization(k) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Subarray Product Less Than ${k}</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalProductArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Subarray Product Analysis</div>
            <div class="transformed-array-container" id="transformedProductArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find all contiguous subarrays with product less than ${k}</p>
            <p class="mb-0" id="productExplanation">Initializing subarray product analysis...</p>
        </div>
        
        <!-- Valid Subarrays Count and List - Placed between analysis and steps -->
        <div class="stats-card mt-3">
            <div>Valid Subarrays Count</div>
            <div class="stats-value" id="validSubarraysCount">0</div>
        </div>
        
        <div class="subarrays-results mt-3" id="productSubarraysResults">
            <h6 class="text-center">Valid Subarrays (Product < ${k})</h6>
            <div id="productSubarraysList" class="mt-2 text-center">No valid subarrays found yet...</div>
        </div>
        
        <div class="algorithm-steps mt-3" id="productStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="productSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterProduct" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForProduct, 'originalProductArray');
    renderArrayInContainer([...originalArrayForProduct], 'transformedProductArray');
    
    executeSubarrayProductAlgorithm(k);
}
// NEW: Execute Subarray Product Algorithm with Animation
// NEW: Execute Subarray Product Algorithm with Animation
function executeSubarrayProductAlgorithm(k) {
    const arrayContainer = document.getElementById('transformedProductArray');
    const originalContainer = document.getElementById('originalProductArray');
    const explanation = document.getElementById('productExplanation');
    const stepsContainer = document.getElementById('productSteps');
    const validSubarraysCount = document.getElementById('validSubarraysCount');
    const productSubarraysResults = document.getElementById('productSubarraysResults');
    const productSubarraysList = document.getElementById('productSubarraysList');
    const continueButton = document.getElementById('continueAfterProduct');
    
    const arr = originalArrayForProduct.map(val => parseFloat(val));
    let validSubarrays = [];
    let step = 0;
    let totalValid = 0;
    
    // Algorithm: Sliding window approach for subarray product less than k
    function executeProductStep(left, right, currentProduct) {
        if (left >= arr.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Found ${totalValid} subarrays with product < ${k}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Total ${totalValid} valid subarrays found with product less than ${k}
                </div>
            `;
            
            validSubarraysCount.textContent = totalValid;
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterProduct();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterProduct);
            
            return;
        }
        
        step++;
        
        if (right >= arr.length) {
            // Move to next starting position
            executeProductStep(left + 1, left + 1, 1);
            return;
        }
        
        // Calculate current product
        let newProduct = currentProduct * arr[right];
        
        // Update explanation
        explanation.innerHTML = `Checking subarray [${left}-${right}]: product = ${newProduct.toFixed(2)}`;
        
        // Highlight current window
        const elements = arrayContainer.querySelectorAll('.array-element');
        const originalElements = originalContainer.querySelectorAll('.array-element');
        
        // Clear previous highlights
        elements.forEach(el => {
            const valueDiv = el.querySelector('.element-value');
            valueDiv.classList.remove('product-window-current', 'product-window-included', 
                                   'product-window-valid', 'product-window-invalid');
        });
        
        // Highlight current window
        for (let i = left; i <= right; i++) {
            if (i < elements.length) {
                const valueDiv = elements[i].querySelector('.element-value');
                const originalValueDiv = originalElements[i].querySelector('.element-value');
                
                valueDiv.classList.add('product-window-included');
                originalValueDiv.classList.add('product-window-included');
            }
        }
        
        // Highlight current right pointer
        if (right < elements.length) {
            const rightElement = elements[right].querySelector('.element-value');
            const originalRightElement = originalElements[right].querySelector('.element-value');
            
            rightElement.classList.add('product-window-current');
            originalRightElement.classList.add('product-window-current');
        }
        
        // Check if product is valid
        if (newProduct < k) {
            // Valid subarray found
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Subarray [${left}-${right}] product = ${newProduct.toFixed(2)} < ${k}  VALID
                </div>
            `;
            
            // Highlight as valid
            for (let i = left; i <= right; i++) {
                if (i < elements.length) {
                    const valueDiv = elements[i].querySelector('.element-value');
                    const originalValueDiv = originalElements[i].querySelector('.element-value');
                    
                    valueDiv.classList.add('product-window-valid');
                    originalValueDiv.classList.add('product-window-valid');
                }
            }
            
            // Add to valid subarrays
            validSubarrays.push({
                start: left,
                end: right,
                values: arr.slice(left, right + 1),
                product: newProduct
            });
            totalValid++;
            validSubarraysCount.textContent = totalValid;
            
            // Update valid subarrays display in real-time
            updateValidSubarraysDisplay();
            
            // Continue expanding window
            setTimeout(() => {
                executeProductStep(left, right + 1, newProduct);
            }, 1500);
            
        } else {
            // Invalid subarray
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}:</strong> Subarray [${left}-${right}] product = ${newProduct.toFixed(2)}  ${k}  INVALID
                </div>
            `;
            
            // Highlight as invalid
            for (let i = left; i <= right; i++) {
                if (i < elements.length) {
                    const valueDiv = elements[i].querySelector('.element-value');
                    const originalValueDiv = originalElements[i].querySelector('.element-value');
                    
                    valueDiv.classList.add('product-window-invalid');
                    originalValueDiv.classList.add('product-window-invalid');
                }
            }
            
            // Move to next starting position
            setTimeout(() => {
                executeProductStep(left + 1, left + 1, 1);
            }, 1500);
        }
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
    }
    
    // Function to update valid subarrays display in real-time
    function updateValidSubarraysDisplay() {
        if (validSubarrays.length > 0) {
            productSubarraysResults.style.display = 'block';
            productSubarraysList.innerHTML = '';
            
            validSubarrays.forEach((subarray, index) => {
                const subarrayItem = document.createElement('span');
                subarrayItem.className = 'product-subarray-item';
                subarrayItem.textContent = `[${subarray.values.join(', ')}]`;
                subarrayItem.title = `Product: ${subarray.product.toFixed(2)}, Indices: ${subarray.start}-${subarray.end}`;
                productSubarraysList.appendChild(subarrayItem);
                
                // Add space between items
                if (index < validSubarrays.length - 1) {
                    productSubarraysList.appendChild(document.createTextNode(' '));
                }
            });
        }
    }
    
    // Initialize the display
    productSubarraysResults.style.display = 'block';
    productSubarraysList.innerHTML = 'No valid subarrays found yet...';
    validSubarraysCount.textContent = '0';
    
    // Start algorithm execution
    executeProductStep(0, 0, 1);
}

// NEW: Return to Original after Product Operation
function returnToOriginalAfterProduct() {
    // Reset to original array
    myArray = [...originalArrayForProduct];
    originalArrayForProduct = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isSubarrayProductRunning = false;
    
    // Clear input
    subarrayProductK.value = '';
    
    logOperation('Subarray product operation completed - returned to original array', 'info');
    showNotification('Returned to original array after subarray product operation', 'success');
}
// NEW: Leader in Array Handler
function handleLeaderInArray() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isLeaderOperationRunning) {
        showNotification('Leader operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Leader operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForLeader = [...myArray];
    
    // Show leader visualization
    showLeaderVisualization();
}
// NEW: Show Leader Visualization
function showLeaderVisualization() {
    isLeaderOperationRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Leader in Array Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalLeaderArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Leader Detection Process</div>
            <div class="transformed-array-container" id="transformedLeaderArray"></div>
        </div>

        <!-- Leader Positions Display - Added between Process and Steps -->
        <div class="array-group mt-4">
            <div class="array-label">Leader Positions</div>
            <div class="subarrays-container" id="leaderPositionsContainer">
                <div class="text-center text-muted" id="leaderPositionsPlaceholder">
                    Leaders will be displayed here as they are found...
                </div>
                <div class="d-flex flex-wrap justify-content-center mt-2" id="leaderPositionsDisplay"></div>
            </div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Leader Definition:</strong> An element is a leader if it's greater than all elements to its right</p>
            <p class="mb-0" id="leaderExplanation">Starting leader detection algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="leaderStepsContainer">
            <h6 class="text-center">Leader Detection Steps</h6>
            <div class="steps-container" id="leaderSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Leaders Found</div>
            <div class="stats-value" id="leadersFoundValue">0</div>
        </div>
        
        <div class="table-container mt-3" id="leaderTableContainer" style="display: none;">
            <h6 class="text-center">Leader Positions Table</h6>
            <table class="leader-table">
                <thead>
                    <tr>
                        <th>Element</th>
                        <th>Index</th>
                        <th>Is Leader</th>
                        <th>Reason</th>
                    </tr>
                </thead>
                <tbody id="leaderTableBody">
                </tbody>
            </table>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterLeader" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForLeader, 'originalLeaderArray');
    renderArrayInContainer([...originalArrayForLeader], 'transformedLeaderArray');
    
    performLeaderDetectionAnimation();
}
// NEW: Perform Leader Detection Animation
function performLeaderDetectionAnimation() {
    const originalContainer = document.getElementById('originalLeaderArray');
    const transformedContainer = document.getElementById('transformedLeaderArray');
    const explanation = document.getElementById('leaderExplanation');
    const stepsContainer = document.getElementById('leaderSteps');
    const leadersFoundValue = document.getElementById('leadersFoundValue');
    const leaderTableContainer = document.getElementById('leaderTableContainer');
    const leaderTableBody = document.getElementById('leaderTableBody');
    const leaderPositionsDisplay = document.getElementById('leaderPositionsDisplay');
    const leaderPositionsPlaceholder = document.getElementById('leaderPositionsPlaceholder');
    const continueButton = document.getElementById('continueAfterLeader');
    
    const arr = originalArrayForLeader.map(val => parseFloat(val));
    const leaders = [];
    const leaderIndices = []; // Store both value and index
    let maxFromRight = -Infinity;
    let step = 0;
    let currentIndex = arr.length - 1;
    
    // Initialize table
    leaderTableBody.innerHTML = '';
    for (let i = 0; i < arr.length; i++) {
        leaderTableBody.innerHTML += `
            <tr>
                <td>${arr[i]}</td>
                <td>${i}</td>
                <td>Checking...</td>
                <td>-</td>
            </tr>
        `;
    }
    
    // Function to update leader positions display
    function updateLeaderPositionsDisplay() {
        if (leaders.length === 0) {
            leaderPositionsPlaceholder.style.display = 'block';
            leaderPositionsDisplay.innerHTML = '';
            return;
        }
        
        leaderPositionsPlaceholder.style.display = 'none';
        leaderPositionsDisplay.innerHTML = '';
        
        // Display leaders in the order they were found (from right to left)
        leaders.forEach((leader, index) => {
            const leaderIndex = arr.indexOf(leader);
            const leaderElement = document.createElement('div');
            leaderElement.className = 'array-element mx-2';
            leaderElement.innerHTML = `
                <div class="element-value leader-element" style="animation-delay: ${index * 0.2}s">
                    ${leader}
                </div>
                <div class="element-index">Index: ${leaderIndex}</div>
            `;
            leaderPositionsDisplay.appendChild(leaderElement);
        });
    }
    
    function performLeaderStep() {
        if (currentIndex < 0) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Leader Detection Completed!</strong> Found ${leaders.length} leaders.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Leaders found: [${leaders.reverse().join(', ')}]
                </div>
            `;
            
            // Update final leader positions display
            updateLeaderPositionsDisplay();
            
            // Show final table
            leaderTableContainer.style.display = 'block';
            
            // Highlight all leaders in final display
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            leaders.forEach((leader, index) => {
                const leaderIndex = arr.indexOf(leader);
                setTimeout(() => {
                    transformedElements[leaderIndex].querySelector('.element-value').classList.add('leader-element');
                }, index * 500);
            });
            
            leadersFoundValue.textContent = leaders.length;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterLeader();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterLeader);
            
            return;
        }
        
        step++;
        const currentElement = arr[currentIndex];
        
        explanation.innerHTML = `Step ${step}: Checking element at index ${currentIndex} = ${currentElement}`;
        
        // Highlight current element
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        const currentElementDiv = transformedElements[currentIndex].querySelector('.element-value');
        currentElementDiv.classList.add('leader-candidate');
        
        // Update table
        const tableRows = leaderTableBody.querySelectorAll('tr');
        tableRows[currentIndex].cells[2].textContent = 'Checking...';
        tableRows[currentIndex].cells[3].textContent = `Comparing with maxFromRight (${maxFromRight})`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Checking arr[${currentIndex}] = ${currentElement}, maxFromRight = ${maxFromRight === -Infinity ? '-' : maxFromRight}
            </div>
        `;
        
        setTimeout(() => {
            if (currentElement >= maxFromRight) {
                // Current element is a leader
                leaders.push(currentElement);
                leaderIndices.push({value: currentElement, index: currentIndex});
                maxFromRight = currentElement;
                
                explanation.innerHTML = `Step ${step}: Element ${currentElement} at index ${currentIndex} is a LEADER!`;
                
                currentElementDiv.classList.remove('leader-candidate');
                currentElementDiv.classList.add('leader-element');
                
                // Update table
                tableRows[currentIndex].cells[2].textContent = 'YES';
                tableRows[currentIndex].cells[2].className = 'leader-position';
                tableRows[currentIndex].cells[3].textContent = `Greater than all elements to the right (maxFromRight = ${maxFromRight})`;
                
                // Update leader positions display
                updateLeaderPositionsDisplay();
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Leader Found!</strong> arr[${currentIndex}] = ${currentElement} is a leader. New maxFromRight = ${maxFromRight}
                    </div>
                `;
                
            } else {
                // Current element is not a leader
                explanation.innerHTML = `Step ${step}: Element ${currentElement} at index ${currentIndex} is NOT a leader`;
                
                currentElementDiv.classList.remove('leader-candidate');
                currentElementDiv.classList.add('non-leader');
                
                // Update table
                tableRows[currentIndex].cells[2].textContent = 'NO';
                tableRows[currentIndex].cells[3].textContent = `Not greater than maxFromRight (${maxFromRight})`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Not a Leader:</strong> arr[${currentIndex}] = ${currentElement}  maxFromRight (${maxFromRight})
                    </div>
                `;
            }
            
            leadersFoundValue.textContent = leaders.length;
            
            // Move to next element (from right to left)
            currentIndex--;
            
            // Continue to next step
            setTimeout(performLeaderStep, 2000);
        }, 1500);
    }
    
    // Start from the rightmost element
    performLeaderStep();
}
// NEW: Return to Original after Leader Operation
function returnToOriginalAfterLeader() {
    // Reset to original array
    myArray = [...originalArrayForLeader];
    originalArrayForLeader = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isLeaderOperationRunning = false;
    
    logOperation('Leader detection completed - returned to original array', 'info');
    showNotification('Returned to original array after leader detection', 'success');
}
// NEW: Jump Game Handler
function handleJumpGame() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isJumpGameRunning) {
        showNotification('Jump Game is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseInt(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Jump Game requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForJumpGame = [...myArray];
    
    // Show Jump Game visualization
    showJumpGameVisualization();
}

// NEW: Show Jump Game Visualization
function showJumpGameVisualization() {
    isJumpGameRunning = true;
    
    const jumpGameContainer = document.createElement('div');
    jumpGameContainer.className = 'dual-operation-container';
    jumpGameContainer.innerHTML = `
        <h5 class="text-center mb-3">Jump Game - Can Reach Final Position?</h5>
        
        <div class="array-group">
            <div class="array-label">Jump Array (Maximum jump length at each position)</div>
            <div class="original-array-container" id="jumpGameArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Problem:</strong> Starting at index 0, can you reach the last index?</p>
            <p class="mb-0" id="jumpGameExplanation">Initializing Jump Game analysis...</p>
        </div>
        
        <div class="table-container">
            <table class="jump-game-table" id="jumpGameTable">
                <thead>
                    <tr>
                        <th>Step</th>
                        <th>Current Position</th>
                        <th>Max Reach</th>
                        <th>Can Reach End?</th>
                        <th>Next Possible Positions</th>
                    </tr>
                </thead>
                <tbody id="jumpGameTableBody">
                </tbody>
            </table>
        </div>
        
        <div class="jump-game-result" id="jumpGameResult" style="display: none;">
            <!-- Result will be displayed here -->
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterJumpGame" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(jumpGameContainer);
    
    renderArrayInContainer(originalArrayForJumpGame, 'jumpGameArray');
    
    performJumpGameAnalysis();
}

// NEW: Perform Jump Game Analysis with Animation
function performJumpGameAnalysis() {
    const arrayContainer = document.getElementById('jumpGameArray');
    const explanation = document.getElementById('jumpGameExplanation');
    const tableBody = document.getElementById('jumpGameTableBody');
    const resultDiv = document.getElementById('jumpGameResult');
    const continueButton = document.getElementById('continueAfterJumpGame');
    
    const nums = originalArrayForJumpGame.map(val => parseInt(val));
    const n = nums.length;
    let maxReach = 0;
    let step = 0;
    let canReachEnd = false;
    
    function performJumpStep(i) {
        if (i >= n) {
            // Analysis completed
            const finalResult = maxReach >= n - 1;
            canReachEnd = finalResult;
            
            explanation.innerHTML = `<strong>Jump Game Analysis Completed!</strong>`;
            
            // Add final result to table
            tableBody.innerHTML += `
                <tr>
                    <td>Final</td>
                    <td>-</td>
                    <td>${maxReach}</td>
                    <td class="${finalResult ? 'jump-game-reachable-cell' : 'jump-game-unreachable-cell'}">
                        ${finalResult ? 'YES' : 'NO'}
                    </td>
                    <td>-</td>
                </tr>
            `;
            
            // Show final result
            if (finalResult) {
                resultDiv.innerHTML = `
                    <div class="jump-game-success">
                        <i class="fas fa-check-circle me-2"></i>
                        REACHING FINAL POSITION: <span style="color: var(--success-color);">POSSIBLE</span>
                        <p class="mt-2 mb-0" style="font-size: 0.9rem;">Successfully reached the last index!</p>
                    </div>
                `;
                
                // Highlight the path or show success animation
                const elements = arrayContainer.querySelectorAll('.array-element');
                elements[n - 1].querySelector('.element-value').classList.add('jump-game-possible');
                
            } else {
                resultDiv.innerHTML = `
                    <div class="jump-game-failure">
                        <i class="fas fa-times-circle me-2"></i>
                        REACHING FINAL POSITION: <span style="color: var(--danger-color);">NOT POSSIBLE</span>
                        <p class="mt-2 mb-0" style="font-size: 0.9rem;">Cannot reach the last index from first index</p>
                    </div>
                `;
                
                // Highlight the unreachable state
                const elements = arrayContainer.querySelectorAll('.array-element');
                elements[n - 1].querySelector('.element-value').classList.add('jump-game-unreachable');
            }
            
            resultDiv.style.display = 'block';
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterJumpGame();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterJumpGame);
            
            return;
        }
        
        step++;
        
        // Update explanation
        explanation.innerHTML = `Step ${step}: At position ${i}, max reach = ${maxReach}`;
        
        // Highlight current position
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElement = elements[i].querySelector('.element-value');
        currentElement.classList.add('jump-game-current');
        
        // Calculate next possible positions
        const currentJump = nums[i];
        const nextPositions = [];
        for (let j = 1; j <= currentJump; j++) {
            if (i + j < n) {
                nextPositions.push(i + j);
            }
        }
        
        // Update max reach
        const newMaxReach = Math.max(maxReach, i + nums[i]);
        const maxReachUpdated = newMaxReach > maxReach;
        
        // Add to table
        tableBody.innerHTML += `
            <tr class="${maxReachUpdated ? 'jump-game-current-cell' : ''}">
                <td>${step}</td>
                <td>${i} (jump: ${nums[i]})</td>
                <td>${newMaxReach}</td>
                <td class="${newMaxReach >= n - 1 ? 'jump-game-reachable-cell' : ''}">
                    ${newMaxReach >= n - 1 ? 'YES' : 'NO'}
                </td>
                <td>${nextPositions.length > 0 ? nextPositions.join(', ') : 'None'}</td>
            </tr>
        `;
        
        // Scroll table to bottom
        const tableContainer = tableBody.parentElement.parentElement;
        tableContainer.scrollTop = tableContainer.scrollHeight;
        
        // Highlight reachable positions
        setTimeout(() => {
            for (let j = i + 1; j <= Math.min(i + currentJump, n - 1); j++) {
                elements[j].querySelector('.element-value').classList.add('jump-game-reachable');
            }
            
            setTimeout(() => {
                // Remove current highlight
                currentElement.classList.remove('jump-game-current');
                
                // Update max reach
                maxReach = newMaxReach;
                
                // Move to next position
                if (i < maxReach && i < n - 1) {
                    performJumpStep(i + 1);
                } else {
                    performJumpStep(n); // End analysis
                }
            }, 1500);
        }, 1000);
    }
    
    // Clear table
    tableBody.innerHTML = '';
    
    // Start analysis from position 0
    performJumpStep(0);
}

// NEW: Return to Original after Jump Game
function returnToOriginalAfterJumpGame() {
    // Reset to original array
    myArray = [...originalArrayForJumpGame];
    originalArrayForJumpGame = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isJumpGameRunning = false;
    
    logOperation('Jump Game analysis completed - returned to original array', 'info');
    showNotification('Returned to original array after Jump Game analysis', 'success');
}
// NEW: Best Time to Buy and Sell Stock Handler
function handleBestTimeStock() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isStockOperationRunning) {
        showNotification('Stock operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains valid numbers (stock prices)
    let allValidNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        const num = parseFloat(myArray[i]);
        if (isNaN(num) || num < 0) {
            allValidNumbers = false;
            break;
        }
    }
    
    if (!allValidNumbers) {
        showNotification('Stock prices must be valid positive numbers', 'danger');
        return;
    }
    
    if (myArray.length < 2) {
        showNotification('Need at least 2 days of stock prices', 'warning');
        return;
    }
    
    isStockOperationRunning = true;
    
    // Store original array
    originalArrayForStock = [...myArray];
    
    // Show stock problem visualization
    showStockProblemVisualization();
}
// NEW: Show Stock Problem Visualization
function showStockProblemVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Best Time to Buy and Sell Stock</h5>
        
        <!-- Results at the TOP -->
        <div class="row mb-4" id="stockResultsTop" style="display: none;">
            <div class="col-md-4">
                <div class="stats-card">
                    <div><i class="fas fa-shopping-cart me-2"></i>Buy Day</div>
                    <div class="stats-value" id="buyDayValueTop">-</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="stats-card">
                    <div><i class="fas fa-cash-register me-2"></i>Sell Day</div>
                    <div class="stats-value" id="sellDayValueTop">-</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="stats-card">
                    <div><i class="fas fa-chart-line me-2"></i>Maximum Profit</div>
                    <div class="stats-value text-success" id="maxProfitValueTop">0</div>
                </div>
            </div>
        </div>
        
        <div class="profit-highlight text-center mb-4" id="profitSummaryTop" style="display: none;">
            <h4 class="mb-1">Maximum Profit: <span class="text-success" id="profitAmountTop">0</span></h4>
            <p class="mb-0">Buy on Day <span id="buyDaySummary">-</span>, Sell on Day <span id="sellDaySummary">-</span></p>
        </div>
        
        <div class="array-group">
            <div class="array-label">Stock Prices (Day 0 to ${myArray.length-1})</div>
            <div class="original-array-container" id="stockPricesArray"></div>
        </div>
        
        <div class="stock-explanation">
            <p class="mb-2"><strong>Problem:</strong> Find the maximum profit from buying and selling stocks</p>
            <p class="mb-0" id="stockExplanation">Initializing stock analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="stockStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="stockSteps"></div>
        </div>
        
        <!-- Original stats cards (kept for reference but will be hidden when top results show) -->
        <div class="row mt-3" id="originalStatsCards">
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Buy Day</div>
                    <div class="stats-value" id="buyDayValue">-</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Sell Day</div>
                    <div class="stats-value" id="sellDayValue">-</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Maximum Profit</div>
                    <div class="stats-value" id="maxProfitValue">0</div>
                </div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterStock" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForStock, 'stockPricesArray');
    
    performStockAlgorithmAnimation();
}
// NEW: Perform Stock Algorithm Animation
function performStockAlgorithmAnimation() {
    const arrayContainer = document.getElementById('stockPricesArray');
    const explanation = document.getElementById('stockExplanation');
    const stepsContainer = document.getElementById('stockSteps');
    
    // Original stats cards
    const buyDayValue = document.getElementById('buyDayValue');
    const sellDayValue = document.getElementById('sellDayValue');
    const maxProfitValue = document.getElementById('maxProfitValue');
    
    // Top position elements
    const stockResultsTop = document.getElementById('stockResultsTop');
    const buyDayValueTop = document.getElementById('buyDayValueTop');
    const sellDayValueTop = document.getElementById('sellDayValueTop');
    const maxProfitValueTop = document.getElementById('maxProfitValueTop');
    const profitSummaryTop = document.getElementById('profitSummaryTop');
    const profitAmountTop = document.getElementById('profitAmountTop');
    const buyDaySummary = document.getElementById('buyDaySummary');
    const sellDaySummary = document.getElementById('sellDaySummary');
    
    const continueButton = document.getElementById('continueAfterStock');
    
    const prices = originalArrayForStock.map(val => parseFloat(val));
    let minPrice = Infinity;
    let maxProfit = 0;
    let buyDay = 0;
    let sellDay = 0;
    let currentMinDay = 0;
    let step = 0;
    
    function performStockStep(day) {
        if (day >= prices.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Maximum profit calculated.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Buy on day ${buyDay} (price ${prices[buyDay]}), Sell on day ${sellDay} (price ${prices[sellDay]})
                </div>
                <div class="algorithm-step active">
                    <strong>Profit:</strong> ${prices[sellDay]} - ${prices[buyDay]} = ${maxProfit}
                </div>
            `;
            
            // Show top results
            setTimeout(() => {
                stockResultsTop.style.display = 'flex';
                profitSummaryTop.style.display = 'block';
                
                // Update top position values
                buyDayValueTop.textContent = `Day ${buyDay} (Price: ${prices[buyDay]})`;
                sellDayValueTop.textContent = `Day ${sellDay} (Price: ${prices[sellDay]})`;
                maxProfitValueTop.textContent = maxProfit;
                
                profitAmountTop.textContent = maxProfit;
                buyDaySummary.textContent = buyDay;
                sellDaySummary.textContent = sellDay;
                
                // Update original stats cards as well
                buyDayValue.textContent = `Day ${buyDay} (Price: ${prices[buyDay]})`;
                sellDayValue.textContent = `Day ${sellDay} (Price: ${prices[sellDay]})`;
                maxProfitValue.textContent = maxProfit;
            }, 500);
            
            // Highlight final buy and sell days
            const elements = arrayContainer.querySelectorAll('.array-element');
            
            // Highlight buy day
            setTimeout(() => {
                elements[buyDay].querySelector('.element-value').classList.add('buy-day');
            }, 1000);
            
            // Highlight sell day
            setTimeout(() => {
                elements[sellDay].querySelector('.element-value').classList.add('sell-day');
            }, 1500);
            
            continueButton.style.display = 'block';
            
            // Auto-return after 8 seconds
            setTimeout(() => {
                returnToOriginalAfterStock();
            }, 8000);
            
            continueButton.addEventListener('click', returnToOriginalAfterStock);
            
            return;
        }
        
        step++;
        const currentPrice = prices[day];
        
        // Update explanation
        explanation.innerHTML = `Day ${day}: Current price = ${currentPrice}`;
        
        // Highlight current day
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElement = elements[day].querySelector('.element-value');
        currentElement.classList.add('profit-calculation');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Day ${day}, Price = ${currentPrice}
            </div>
        `;
        
        setTimeout(() => {
            // Check if this is a new minimum price
            if (currentPrice < minPrice) {
                minPrice = currentPrice;
                currentMinDay = day;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>New Minimum:</strong> Day ${day} is new lowest price (${currentPrice})
                    </div>
                `;
                
                // Highlight as new minimum
                currentElement.classList.remove('profit-calculation');
                currentElement.classList.add('current-min');
                
                // Remove previous minimum highlight if any
                if (day > 0) {
                    elements[currentMinDay - 1]?.querySelector('.element-value')?.classList.remove('current-min');
                }
                
            } else {
                // Calculate potential profit
                const potentialProfit = currentPrice - minPrice;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Profit Check:</strong> Current price ${currentPrice} - Min price ${minPrice} = ${potentialProfit}
                    </div>
                `;
                
                if (potentialProfit > maxProfit) {
                    maxProfit = potentialProfit;
                    buyDay = currentMinDay;
                    sellDay = day;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>New Maximum Profit!</strong> ${potentialProfit} (Buy: Day ${buyDay}, Sell: Day ${day})
                        </div>
                    `;
                    
                    // Update display values in real-time (both top and original)
                    buyDayValue.textContent = `Day ${buyDay} (Price: ${prices[buyDay]})`;
                    sellDayValue.textContent = `Day ${day} (Price: ${currentPrice})`;
                    maxProfitValue.textContent = maxProfit;
                    
                    // Update top values if they're visible
                    if (stockResultsTop.style.display === 'flex') {
                        buyDayValueTop.textContent = `Day ${buyDay} (Price: ${prices[buyDay]})`;
                        sellDayValueTop.textContent = `Day ${day} (Price: ${currentPrice})`;
                        maxProfitValueTop.textContent = maxProfit;
                        profitAmountTop.textContent = maxProfit;
                        buyDaySummary.textContent = buyDay;
                        sellDaySummary.textContent = day;
                    }
                    
                    // Highlight buy and sell days temporarily
                    if (buyDay !== day) {
                        elements[buyDay].querySelector('.element-value').classList.add('buy-day');
                        currentElement.classList.add('sell-day');
                        
                        // Remove temporary highlights after delay
                        setTimeout(() => {
                            elements[buyDay].querySelector('.element-value').classList.remove('buy-day');
                            currentElement.classList.remove('sell-day');
                        }, 1000);
                    }
                }
                
                currentElement.classList.remove('profit-calculation');
            }
            
            // Scroll to bottom of steps
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            // Move to next day
            performStockStep(day + 1);
        }, 2000);
    }
    
    // Start algorithm execution
    performStockStep(0);
}

// NEW: Return to Original after Stock Operation
function returnToOriginalAfterStock() {
    // Reset to original array
    myArray = [...originalArrayForStock];
    originalArrayForStock = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isStockOperationRunning = false;
    
    logOperation('Best Time to Buy/Sell Stock analysis completed', 'info');
    showNotification('Returned to original array after stock analysis', 'success');
}
// NEW: Find Subarray with Sum Closest to Zero Handler
function handleFindSubarrayNearZero() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isNearZeroRunning) {
        showNotification('Near zero subarray search is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('This operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isNearZeroRunning = true;
    
    // Store original array
    originalArrayForNearZero = [...myArray];
    
    // Show near zero subarray visualization
    showNearZeroSubarrayVisualization();
}

// NEW: Show Near Zero Subarray Visualization
function showNearZeroSubarrayVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find Subarray with Sum Closest to Zero</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalNearZeroArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Subarray Search Process</div>
            <div class="transformed-array-container" id="transformedNearZeroArray"></div>
        </div>

        <!-- Subarrays Results Section - Moved between process and algorithm steps -->
        <div class="near-zero-results mt-3" id="nearZeroResults">
            <h6 class="text-center">Subarrays with Sum Near Zero</h6>
            <div class="row">
                <div class="col-md-6">
                    <div class="stats-card">
                        <div>Total Subarrays Found</div>
                        <div class="stats-value" id="nearZeroCount">0</div>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="stats-card">
                        <div>Best Subarray (Closest to Zero)</div>
                        <div class="stats-value" id="bestSubarrayInfo">-</div>
                    </div>
                </div>
            </div>
            <div class="mt-3">
                <h6 class="text-center mb-3">All Subarrays Found:</h6>
                <div id="nearZeroSubarraysList" class="text-center" style="max-height: 200px; overflow-y: auto; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 10px;"></div>
            </div>
        </div>
        
        <div class="algorithm-explanation mt-3">
            <p class="mb-2"><strong>Algorithm:</strong> Find contiguous subarray with sum closest to zero</p>
            <p class="mb-0" id="nearZeroExplanation">Initializing subarray search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="nearZeroStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="nearZeroSteps" style="max-height: 300px; overflow-y: auto;"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterNearZero" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForNearZero, 'originalNearZeroArray');
    renderArrayInContainer([...originalArrayForNearZero], 'transformedNearZeroArray');
    
    performNearZeroSubarraySearch();
}

// NEW: Perform Near Zero Subarray Search with Animation
function performNearZeroSubarraySearch() {
    const originalContainer = document.getElementById('originalNearZeroArray');
    const transformedContainer = document.getElementById('transformedNearZeroArray');
    const explanation = document.getElementById('nearZeroExplanation');
    const stepsContainer = document.getElementById('nearZeroSteps');
    const resultsContainer = document.getElementById('nearZeroResults');
    const nearZeroCount = document.getElementById('nearZeroCount');
    const bestSubarrayInfo = document.getElementById('bestSubarrayInfo');
    const nearZeroSubarraysList = document.getElementById('nearZeroSubarraysList');
    const continueButton = document.getElementById('continueAfterNearZero');
    
    const arr = originalArrayForNearZero.map(val => parseFloat(val));
    const n = arr.length;
    let prefixSum = [];
    let cumulativeSum = 0;
    let step = 0;
    let subarrays = [];
    let bestSubarray = null;
    let minDiff = Infinity;
    
    // Initialize results display
    nearZeroCount.textContent = '0';
    bestSubarrayInfo.textContent = 'Searching...';
    nearZeroSubarraysList.innerHTML = '<div class="text-muted">No subarrays found yet...</div>';
    
    // Calculate prefix sums
    explanation.innerHTML = 'Step 1: Calculating prefix sums...';
    stepsContainer.innerHTML = `
        <div class="algorithm-step active">
            <strong>Step 1:</strong> Calculate prefix sums for efficient subarray sum calculation
        </div>
    `;
    
    function performSearchStep() {
        if (step === 0) {
            // Calculate prefix sums with animation
            prefixSum = [{ sum: 0, index: -1 }];
            cumulativeSum = 0;
            
            function calculatePrefixStep(i) {
                if (i >= n) {
                    step++;
                    performSearchStep();
                    return;
                }
                
                cumulativeSum += arr[i];
                prefixSum.push({ sum: cumulativeSum, index: i });
                
                explanation.innerHTML = `Step 1: Calculating prefix sum up to index ${i} = ${cumulativeSum.toFixed(2)}`;
                
                // Highlight current element
                const elements = transformedContainer.querySelectorAll('.array-element');
                const currentElement = elements[i].querySelector('.element-value');
                currentElement.classList.add('prefix-highlight');
                
                setTimeout(() => {
                    currentElement.classList.remove('prefix-highlight');
                    calculatePrefixStep(i + 1);
                }, 800);
            }
            
            calculatePrefixStep(0);
            
        } else if (step === 1) {
            // Sort prefix sums to find closest pairs
            explanation.innerHTML = 'Step 2: Sorting prefix sums to find closest pairs...';
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 2:</strong> Sort prefix sums array to find pairs with minimum difference
                </div>
            `;
            
            // Sort prefix sums
            prefixSum.sort((a, b) => a.sum - b.sum);
            
            setTimeout(() => {
                step++;
                performSearchStep();
            }, 1500);
            
        } else if (step === 2) {
            // Find closest pairs and corresponding subarrays
            explanation.innerHTML = 'Step 3: Finding subarrays with sums closest to zero...';
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 3:</strong> Iterate through sorted prefix sums to find minimum differences
                </div>
            `;
            
            let pairIndex = 0;
            let foundSubarraysCount = 0;
            
            function findClosestPairs(i) {
                if (i >= prefixSum.length - 1) {
                    step++;
                    performSearchStep();
                    return;
                }
                
                const diff = Math.abs(prefixSum[i + 1].sum - prefixSum[i].sum);
                const startIdx = Math.min(prefixSum[i].index, prefixSum[i + 1].index) + 1;
                const endIdx = Math.max(prefixSum[i].index, prefixSum[i + 1].index);
                
                if (startIdx <= endIdx) {
                    const subarray = arr.slice(startIdx, endIdx + 1);
                    const subarraySum = subarray.reduce((a, b) => a + b, 0);
                    
                    subarrays.push({
                        start: startIdx,
                        end: endIdx,
                        sum: subarraySum,
                        diff: Math.abs(subarraySum),
                        elements: subarray
                    });
                    
                    foundSubarraysCount++;
                    
                    // Update best subarray if this is closer to zero
                    if (Math.abs(subarraySum) < minDiff) {
                        minDiff = Math.abs(subarraySum);
                        bestSubarray = { 
                            start: startIdx, 
                            end: endIdx, 
                            sum: subarraySum,
                            elements: subarray
                        };
                    }
                    
                    // Update results display in real-time
                    nearZeroCount.textContent = foundSubarraysCount;
                    
                    // Update best subarray info
                    if (bestSubarray) {
                        bestSubarrayInfo.textContent = `[${bestSubarray.start}-${bestSubarray.end}] = ${bestSubarray.sum.toFixed(2)}`;
                    }
                    
                    // Update subarrays list
                    updateSubarraysList();
                    
                    explanation.innerHTML = `Step 3: Found subarray [${startIdx}-${endIdx}] with sum = ${subarraySum.toFixed(2)}`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step ${Math.abs(subarraySum) === minDiff ? 'active' : ''}">
                            <strong>Pair ${i + 1}:</strong> Subarray [${startIdx}-${endIdx}] = [${subarray.join(', ')}], Sum = ${subarraySum.toFixed(2)}
                        </div>
                    `;
                    
                    // Highlight the subarray
                    const elements = transformedContainer.querySelectorAll('.array-element');
                    for (let j = startIdx; j <= endIdx; j++) {
                        setTimeout(() => {
                            elements[j].querySelector('.element-value').classList.add('subarray-candidate');
                        }, (j - startIdx) * 200);
                    }
                    
                    // Scroll steps container
                    stepsContainer.scrollTop = stepsContainer.scrollHeight;
                }
                
                pairIndex++;
                setTimeout(() => findClosestPairs(i + 1), 1000);
            }
            
            // Function to update the subarrays list display
            function updateSubarraysList() {
                nearZeroSubarraysList.innerHTML = '';
                
                // Display all found subarrays
                subarrays.forEach((sub, index) => {
                    const subarrayItem = document.createElement('div');
                    subarrayItem.className = `near-zero-item ${sub.diff === minDiff ? 'near-zero-best' : ''}`;
                    subarrayItem.style.margin = '5px';
                    subarrayItem.style.padding = '8px 12px';
                    subarrayItem.style.borderRadius = '5px';
                    subarrayItem.style.display = 'inline-block';
                    subarrayItem.style.fontSize = '0.9rem';
                    
                    subarrayItem.innerHTML = `
                        <strong>[${sub.start}-${sub.end}]</strong>: [${sub.elements.join(', ')}] = <strong>${sub.sum.toFixed(2)}</strong>
                    `;
                    
                    nearZeroSubarraysList.appendChild(subarrayItem);
                    
                    // Add space between items
                    if (index < subarrays.length - 1) {
                        nearZeroSubarraysList.appendChild(document.createTextNode(' '));
                    }
                });
                
                // Scroll to bottom of subarrays list
                nearZeroSubarraysList.scrollTop = nearZeroSubarraysList.scrollHeight;
            }
            
            findClosestPairs(0);
            
        } else {
            // Algorithm completed
            explanation.innerHTML = `<strong>Search Completed!</strong> Found ${subarrays.length} subarrays with sums near zero.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Best subarray found with sum closest to zero = ${bestSubarray.sum.toFixed(2)}
                </div>
                <div class="algorithm-step active">
                    <strong>Total Subarrays:</strong> ${subarrays.length} subarrays analyzed
                </div>
            `;
            
            // Final update of results
            nearZeroCount.textContent = subarrays.length;
            bestSubarrayInfo.textContent = `[${bestSubarray.start}-${bestSubarray.end}] = ${bestSubarray.sum.toFixed(2)}`;
            
            // Highlight the best subarray in the array
            const elements = transformedContainer.querySelectorAll('.array-element');
            for (let j = bestSubarray.start; j <= bestSubarray.end; j++) {
                setTimeout(() => {
                    elements[j].querySelector('.element-value').classList.add('subarray-near-zero');
                }, (j - bestSubarray.start) * 200);
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterNearZero();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterNearZero);
        }
    }
    
    // Start the search process
    performSearchStep();
}

// NEW: Return to Original after Near Zero Search
function returnToOriginalAfterNearZero() {
    // Reset to original array
    myArray = [...originalArrayForNearZero];
    originalArrayForNearZero = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isNearZeroRunning = false;
    
    logOperation('Near zero subarray search completed - returned to original array', 'info');
    showNotification('Returned to original array after near zero subarray search', 'success');
}
// NEW: Minimum Window Substring Handler
function handleMinWindowSubstring() {
    if (isMinWindowRunning) {
        showNotification('Minimum window operation is already in progress', 'warning');
        return;
    }

    // Show input group
    minWindowGroup.style.display = 'block';
    mainStringInput.focus();
    
    // Clear previous inputs
    mainStringInput.value = '';
    targetStringInput.value = '';
    
    logOperation('Started minimum window substring operation', 'info');
}

// NEW: Perform Minimum Window Handler
function handlePerformMinWindow() {
    mainString = mainStringInput.value.trim();
    targetString = targetStringInput.value.trim();
    
    if (mainString === '') {
        showNotification('Please enter the main string', 'danger');
        mainStringInput.focus();
        return;
    }
    
    if (targetString === '') {
        showNotification('Please enter the target string', 'danger');
        targetStringInput.focus();
        return;
    }
    
    if (targetString.length > mainString.length) {
        showNotification('Target string cannot be longer than main string', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForMinWindow = [...myArray];
    
    // Hide input group
    minWindowGroup.style.display = 'none';
    
    // Start minimum window visualization
    showMinWindowVisualization();
}

// NEW: Cancel Minimum Window Handler
function handleCancelMinWindow() {
    minWindowGroup.style.display = 'none';
    mainStringInput.value = '';
    targetStringInput.value = '';
    
    mainString = "";
    targetString = "";
    
    logOperation('Cancelled minimum window operation', 'info');
    showNotification('Minimum window operation cancelled', 'info');
}

// NEW: Show Minimum Window Visualization
function showMinWindowVisualization() {
    isMinWindowRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Minimum Window Substring Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Main String: "${mainString}"</div>
            <div class="char-array-container" id="mainStringArray"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Target String: "${targetString}"</div>
            <div class="char-array-container" id="targetStringArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Sliding Window Process</div>
            <div class="char-array-container" id="windowProcessArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find minimum window in main string that contains all characters of target string</p>
            <p class="mb-0" id="minWindowExplanation">Initializing sliding window algorithm...</p>
        </div>
        
        <div class="frequency-display" id="frequencyDisplay">
            <h6>Character Frequency Requirements</h6>
            <div id="frequencyContent"></div>
        </div>
        
        <div class="algorithm-steps mt-3" id="minWindowStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="minWindowSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Minimum Window Found</div>
            <div class="stats-value" id="minWindowResult">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMinWindow" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display the strings as character arrays
    renderCharArray(mainString.split(''), 'mainStringArray');
    renderCharArray(targetString.split(''), 'targetStringArray');
    renderCharArray(mainString.split(''), 'windowProcessArray');
    
    // Start the algorithm animation
    performMinWindowAlgorithm();
}

// NEW: Render Character Array
function renderCharArray(charArray, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    charArray.forEach((char, index) => {
        const charElement = document.createElement('div');
        charElement.className = 'char-element';
        charElement.innerHTML = `
            <div class="char-value">${char}</div>
            <div class="char-index">${index}</div>
        `;
        container.appendChild(charElement);
    });
}

// NEW: Perform Minimum Window Algorithm with Animation
function performMinWindowAlgorithm() {
    const mainArrayContainer = document.getElementById('mainStringArray');
    const targetArrayContainer = document.getElementById('targetStringArray');
    const windowContainer = document.getElementById('windowProcessArray');
    const explanation = document.getElementById('minWindowExplanation');
    const stepsContainer = document.getElementById('minWindowSteps');
    const frequencyContent = document.getElementById('frequencyContent');
    const minWindowResult = document.getElementById('minWindowResult');
    const continueButton = document.getElementById('continueAfterMinWindow');
    
    const s = mainString;
    const t = targetString;
    let minWindow = "";
    let step = 0;
    
    // Calculate frequency requirements for target string
    const targetFreq = {};
    for (let char of t) {
        targetFreq[char] = (targetFreq[char] || 0) + 1;
    }
    
    // Display frequency requirements
    frequencyContent.innerHTML = '';
    for (let char in targetFreq) {
        const freqItem = document.createElement('span');
        freqItem.className = 'frequency-item';
        freqItem.textContent = `${char}: ${targetFreq[char]}`;
        frequencyContent.appendChild(freqItem);
    }
    
    let requiredChars = Object.keys(targetFreq).length;
    let left = 0, right = 0;
    let formed = 0;
    const windowFreq = {};
    let result = [0, s.length + 1]; // [start, end]
    
    function performAlgorithmStep() {
        if (right > s.length) {
            // Algorithm completed
            if (result[1] > s.length) {
                explanation.innerHTML = `<strong>Algorithm Completed!</strong> No window found containing all characters.`;
                minWindowResult.textContent = "No solution found";
            } else {
                minWindow = s.substring(result[0], result[1] + 1);
                explanation.innerHTML = `<strong>Algorithm Completed!</strong> Minimum window found: "${minWindow}"`;
                minWindowResult.textContent = `"${minWindow}" (indices ${result[0]}-${result[1]})`;
                
                // Highlight the minimum window
                const windowElements = windowContainer.querySelectorAll('.char-element');
                for (let i = result[0]; i <= result[1]; i++) {
                    setTimeout(() => {
                        windowElements[i].querySelector('.char-value').classList.add('window-minimum');
                    }, (i - result[0]) * 200);
                }
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> ${minWindow ? `Minimum window: "${minWindow}"` : 'No solution found'}
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterMinWindow();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterMinWindow);
            
            return;
        }
        
        step++;
        
        if (formed < requiredChars) {
            // Expand window to the right
            if (right < s.length) {
                const char = s[right];
                explanation.innerHTML = `Step ${step}: Expanding window - adding character '${char}' at position ${right}`;
                
                // Highlight current right pointer
                const windowElements = windowContainer.querySelectorAll('.char-element');
                if (right < windowElements.length) {
                    windowElements[right].querySelector('.char-value').classList.add('window-current');
                }
                
                // Update window frequency
                windowFreq[char] = (windowFreq[char] || 0) + 1;
                
                // Check if this character satisfies requirement
                if (targetFreq[char] && windowFreq[char] === targetFreq[char]) {
                    formed++;
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step}:</strong> Added '${char}' - Now have required count of '${char}' (${windowFreq[char]})
                        </div>
                    `;
                    
                    // Highlight as satisfied
                    if (right < windowElements.length) {
                        windowElements[right].querySelector('.char-value').classList.add('window-satisfied');
                    }
                } else {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step}:</strong> Added '${char}' - Current count: ${windowFreq[char]}, Required: ${targetFreq[char] || 0}
                        </div>
                    `;
                    
                    // Highlight as included
                    if (right < windowElements.length) {
                        windowElements[right].querySelector('.char-value').classList.add('window-included');
                    }
                }
                
                setTimeout(() => {
                    // Remove temporary highlight
                    if (right < windowElements.length) {
                        windowElements[right].querySelector('.char-value').classList.remove('window-current');
                    }
                    
                    right++;
                    performAlgorithmStep();
                }, 1500);
            } else {
                right++;
                performAlgorithmStep();
            }
        } else {
            // Contract window from left
            const char = s[left];
            explanation.innerHTML = `Step ${step}: Contracting window - removing character '${char}' from position ${left}`;
            
            // Highlight current left pointer
            const windowElements = windowContainer.querySelectorAll('.char-element');
            if (left < windowElements.length) {
                windowElements[left].querySelector('.char-value').classList.add('window-current');
            }
            
            // Update result if current window is smaller
            if (right - left < result[1] - result[0] + 1) {
                result[0] = left;
                result[1] = right - 1;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> New minimum window found: indices ${left}-${right-1}
                    </div>
                `;
            } else {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step}:</strong> Removing '${char}' from left, current window: ${left}-${right-1}
                    </div>
                `;
            }
            
            // Update window frequency
            windowFreq[char]--;
            if (targetFreq[char] && windowFreq[char] < targetFreq[char]) {
                formed--;
            }
            
            setTimeout(() => {
                // Remove temporary highlight
                if (left < windowElements.length) {
                    windowElements[left].querySelector('.char-value').classList.remove('window-current', 'window-included', 'window-satisfied');
                }
                
                left++;
                performAlgorithmStep();
            }, 1500);
        }
    }
    
    // Start algorithm execution
    performAlgorithmStep();
}

// NEW: Return to Original after Minimum Window
function returnToOriginalAfterMinWindow() {
    // Reset to original array
    myArray = [...originalArrayForMinWindow];
    originalArrayForMinWindow = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMinWindowRunning = false;
    
    // Clear inputs
    mainStringInput.value = '';
    targetStringInput.value = '';
    mainString = "";
    targetString = "";
    
    logOperation('Minimum window operation completed - returned to original array', 'info');
    showNotification('Returned to original array after minimum window operation', 'success');
}
// NEW: K Consecutive Elements Handler
function handleKConsecutive(operation) {
    const k = parseInt(kConsecutiveSize.value);
    
    if (isNaN(k) || k < 1 || k > myArray.length) {
        showNotification(`Please enter a valid k value between 1 and ${myArray.length}`, 'danger');
        kConsecutiveSize.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('K consecutive sum operations require all array elements to be numbers', 'danger');
        return;
    }
    
    if (isKConsecutiveRunning) {
        showNotification('A k consecutive operation is already in progress', 'warning');
        return;
    }
    
    isKConsecutiveRunning = true;
    
    // Store original array
    originalArrayForKConsecutive = [...myArray];
    
    // Perform k consecutive visualization
    performKConsecutiveVisualization(k, operation);
}

// NEW: Perform K Consecutive Visualization
function performKConsecutiveVisualization(k, operation) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">${operation === 'max' ? 'Maximum' : 'Minimum'} Sum of ${k} Consecutive Elements</h5>
        
        <div class="array-group">
            <div class="array-label">Array</div>
            <div class="original-array-container" id="kConsecutiveArray"></div>
        </div>
        
        <div class="k-consecutive-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find ${operation === 'max' ? 'maximum' : 'minimum'} sum of any ${k} consecutive elements</p>
            <p class="mb-0" id="kConsecutiveExplanation">Initializing algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="kConsecutiveStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="kConsecutiveSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>${operation === 'max' ? 'Maximum' : 'Minimum'} Sum Found</div>
            <div class="stats-value" id="kConsecutiveSumValue">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Subarray Indices</div>
            <div class="stats-value" id="kConsecutiveIndices">-</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Subarray Elements</div>
            <div class="stats-value" id="kConsecutiveElements">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterKConsecutive" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForKConsecutive, 'kConsecutiveArray');
    
    executeKConsecutiveAlgorithm(k, operation);
}

// NEW: Execute K Consecutive Algorithm with Animation
function executeKConsecutiveAlgorithm(k, operation) {
    const arrayContainer = document.getElementById('kConsecutiveArray');
    const explanation = document.getElementById('kConsecutiveExplanation');
    const stepsContainer = document.getElementById('kConsecutiveSteps');
    const sumValue = document.getElementById('kConsecutiveSumValue');
    const indicesValue = document.getElementById('kConsecutiveIndices');
    const elementsValue = document.getElementById('kConsecutiveElements');
    const continueButton = document.getElementById('continueAfterKConsecutive');
    
    const arr = originalArrayForKConsecutive.map(val => parseFloat(val));
    let bestSum = operation === 'max' ? -Infinity : Infinity;
    let bestStart = 0;
    let bestEnd = k - 1;
    let currentSum = 0;
    let step = 0;
    
    function executeStep(start) {
        if (start > arr.length - k) {
            // Algorithm completed
            const bestSubarray = arr.slice(bestStart, bestEnd + 1);
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> ${operation === 'max' ? 'Maximum' : 'Minimum'} sum = ${bestSum}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> ${operation === 'max' ? 'Maximum' : 'Minimum'} sum of ${k} consecutive elements = ${bestSum} at indices [${bestStart}-${bestEnd}]
                </div>
            `;
            
            // Highlight the best subarray
            const elements = arrayContainer.querySelectorAll('.array-element');
            for (let j = bestStart; j <= bestEnd; j++) {
                setTimeout(() => {
                    const valueDiv = elements[j].querySelector('.element-value');
                    valueDiv.classList.add(operation === 'max' ? 'k-consecutive-max' : 'k-consecutive-min');
                }, (j - bestStart) * 200);
            }
            
            sumValue.textContent = bestSum;
            indicesValue.textContent = `${bestStart} to ${bestEnd}`;
            elementsValue.textContent = `[${bestSubarray.join(', ')}]`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterKConsecutive();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterKConsecutive);
            
            return;
        }
        
        const end = start + k - 1;
        step++;
        
        if (start === 0) {
            // First window - calculate initial sum
            explanation.innerHTML = `Calculating sum of first window (indices ${start} to ${end})`;
            
            // Highlight the first window
            const elements = arrayContainer.querySelectorAll('.array-element');
            for (let i = start; i <= end; i++) {
                setTimeout(() => {
                    elements[i].querySelector('.element-value').classList.add('k-consecutive-included');
                }, (i - start) * 200);
            }
            
            setTimeout(() => {
                for (let i = start; i <= end; i++) {
                    currentSum += arr[i];
                }
                bestSum = currentSum;
                bestStart = start;
                bestEnd = end;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> First window sum = ${currentSum} (indices ${start}-${end})
                    </div>
                `;
                
                sumValue.textContent = bestSum;
                indicesValue.textContent = `${bestStart} to ${bestEnd}`;
                elementsValue.textContent = `[${arr.slice(bestStart, bestEnd + 1).join(', ')}]`;
                
                executeStep(start + 1);
            }, k * 200 + 500);
            
        } else {
            // Slide the window
            explanation.innerHTML = `Sliding window: Removing [${start-1}]=${arr[start-1]}, Adding [${end}]=${arr[end]}`;
            
            const elements = arrayContainer.querySelectorAll('.array-element');
            
            // Remove left element highlight
            const leftElement = elements[start - 1].querySelector('.element-value');
            leftElement.classList.remove('k-consecutive-included');
            leftElement.classList.add('k-consecutive-current');
            
            // Add right element highlight
            const rightElement = elements[end].querySelector('.element-value');
            rightElement.classList.add('k-consecutive-current');
            
            setTimeout(() => {
                // Update sum
                currentSum += arr[end] - arr[start - 1];
                
                // Remove temporary highlights and update window
                leftElement.classList.remove('k-consecutive-current');
                rightElement.classList.remove('k-consecutive-current');
                rightElement.classList.add('k-consecutive-included');
                
                // Update all window elements
                for (let j = start; j <= end; j++) {
                    elements[j].querySelector('.element-value').classList.add('k-consecutive-included');
                }
                
                // Check if this is new best
                const isNewBest = operation === 'max' ? currentSum > bestSum : currentSum < bestSum;
                
                if (isNewBest) {
                    bestSum = currentSum;
                    bestStart = start;
                    bestEnd = end;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step}:</strong> New ${operation === 'max' ? 'maximum' : 'minimum'} sum = ${bestSum} (indices ${start}-${end})
                        </div>
                    `;
                } else {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step}:</strong> Current sum = ${currentSum}, ${operation === 'max' ? 'Maximum' : 'Minimum'} sum = ${bestSum}
                        </div>
                    `;
                }
                
                sumValue.textContent = bestSum;
                indicesValue.textContent = `${bestStart} to ${bestEnd}`;
                elementsValue.textContent = `[${arr.slice(bestStart, bestEnd + 1).join(', ')}]`;
                
                executeStep(start + 1);
            }, 1000);
        }
    }
    
    // Start execution
    executeStep(0);
}

// NEW: Return to Original after K Consecutive Operations
function returnToOriginalAfterKConsecutive() {
    // Reset to original array
    myArray = [...originalArrayForKConsecutive];
    originalArrayForKConsecutive = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isKConsecutiveRunning = false;
    
    // Clear input
    kConsecutiveSize.value = '';
    
    logOperation('K consecutive sum operation completed - returned to original array', 'info');
    showNotification('Returned to original array after k consecutive sum operation', 'success');
}
// NEW: Rearrange Array (Min, Max) Alternately Handler
function handleRearrangeMinMax() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isRearrangeMinMaxRunning) {
        showNotification('A rearrange operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Rearrange operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isRearrangeMinMaxRunning = true;
    
    // Store original array
    originalArrayForMinMax = [...myArray];
    
    // Show rearrange visualization
    showRearrangeMinMaxVisualization();
}
// NEW: Show Rearrange MinMax Visualization
function showRearrangeMinMaxVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Rearrange Array Alternately (Max, Min, 2nd Max, 2nd Min, ...)</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array ${isCurrentlySorted ? '(Already Sorted)' : '(Will Be Sorted First)'}</div>
            <div class="original-array-container" id="originalMinMaxArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-random"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Rearranged Array</div>
            <div class="transformed-array-container" id="transformedMinMaxArray"></div>
        </div>
        
        <div class="rearrange-minmax-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Rearrange sorted array as: max, min, 2nd max, 2nd min, ...</p>
            <p class="mb-0" id="minMaxExplanation">Starting rearrangement process...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="minMaxStepsContainer">
            <h6 class="text-center">Rearrangement Steps</h6>
            <div class="steps-container" id="minMaxSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMinMax" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForMinMax, 'originalMinMaxArray');
    renderArrayInContainer([...originalArrayForMinMax], 'transformedMinMaxArray');
    
    performRearrangeMinMaxAnimation();
}
// NEW: Perform Rearrange MinMax Animation
function performRearrangeMinMaxAnimation() {
    const originalContainer = document.getElementById('originalMinMaxArray');
    const transformedContainer = document.getElementById('transformedMinMaxArray');
    const explanation = document.getElementById('minMaxExplanation');
    const stepsContainer = document.getElementById('minMaxSteps');
    const continueButton = document.getElementById('continueAfterMinMax');
    
    let array = [...originalArrayForMinMax].map(val => parseFloat(val));
    const n = array.length;
    let step = 0;
    
    // First, sort the array if needed
    function sortArrayIfNeeded() {
        // Check if array is already sorted
        let isSorted = true;
        for (let i = 1; i < array.length; i++) {
            if (array[i] < array[i-1]) {
                isSorted = false;
                break;
            }
        }
        
        if (!isSorted) {
            explanation.innerHTML = 'Array is not sorted. Sorting array first...';
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Array not sorted. Sorting in ascending order...
                </div>
            `;
            
            setTimeout(() => {
                array.sort((a, b) => a - b);
                renderArrayInContainer(array, 'originalMinMaxArray');
                renderArrayInContainer([...array], 'transformedMinMaxArray');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1 Complete:</strong> Array sorted: [${array.join(', ')}]
                    </div>
                `;
                
                startRearrangement();
            }, 2000);
        } else {
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step 1:</strong> Array is already sorted: [${array.join(', ')}]
                </div>
            `;
            startRearrangement();
        }
    }
    
    function startRearrangement() {
        explanation.innerHTML = 'Starting alternate rearrangement: max, min, 2nd max, 2nd min, ...';
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step 2:</strong> Begin rearrangement process
            </div>
        `;
        
        const result = new Array(n);
        let left = 0;
        let right = n - 1;
        let index = 0;
        
        function rearrangeStep() {
            if (left > right) {
                // Rearrangement completed
                explanation.innerHTML = `<strong>Rearrangement Completed!</strong> Array rearranged alternately.`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Rearrangement completed! Result: [${result.join(', ')}]
                    </div>
                `;
                
                // Highlight the final rearranged array
                const transformedElements = transformedContainer.querySelectorAll('.array-element');
                transformedElements.forEach((el, idx) => {
                    setTimeout(() => {
                        const valueDiv = el.querySelector('.element-value');
                        if (idx % 2 === 0) {
                            valueDiv.classList.add('rearrange-max'); // Even positions are max elements
                        } else {
                            valueDiv.classList.add('rearrange-min'); // Odd positions are min elements
                        }
                    }, idx * 200);
                });
                
                continueButton.style.display = 'block';
                
                // Auto-return to original after 8 seconds
                setTimeout(() => {
                    returnToOriginalAfterMinMax();
                }, 8000);
                
                continueButton.addEventListener('click', returnToOriginalAfterMinMax);
                
                return;
            }
            
            step++;
            
            if (index % 2 === 0) {
                // Even position - take max from right
                explanation.innerHTML = `Step ${step + 2}: Position ${index} - Taking max element [${right}]=${array[right]}`;
                
                // Highlight the current max element
                const originalElements = originalContainer.querySelectorAll('.array-element');
                const maxElement = originalElements[right].querySelector('.element-value');
                maxElement.classList.add('rearrange-current');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step + 2}:</strong> Position ${index}  Max element [${right}]=${array[right]}
                    </div>
                `;
                
                setTimeout(() => {
                    result[index] = array[right];
                    right--;
                    
                    // Update transformed array
                    renderArrayInContainer(result.filter(val => val !== undefined), 'transformedMinMaxArray');
                    
                    // Remove highlight
                    maxElement.classList.remove('rearrange-current');
                    
                    // Highlight the placed element
                    const transformedElements = transformedContainer.querySelectorAll('.array-element');
                    if (transformedElements[index]) {
                        transformedElements[index].querySelector('.element-value').classList.add('rearrange-max');
                    }
                    
                    index++;
                    rearrangeStep();
                }, 1500);
                
            } else {
                // Odd position - take min from left
                explanation.innerHTML = `Step ${step + 2}: Position ${index} - Taking min element [${left}]=${array[left]}`;
                
                // Highlight the current min element
                const originalElements = originalContainer.querySelectorAll('.array-element');
                const minElement = originalElements[left].querySelector('.element-value');
                minElement.classList.add('rearrange-current');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step + 2}:</strong> Position ${index}  Min element [${left}]=${array[left]}
                    </div>
                `;
                
                setTimeout(() => {
                    result[index] = array[left];
                    left++;
                    
                    // Update transformed array
                    renderArrayInContainer(result.filter(val => val !== undefined), 'transformedMinMaxArray');
                    
                    // Remove highlight
                    minElement.classList.remove('rearrange-current');
                    
                    // Highlight the placed element
                    const transformedElements = transformedContainer.querySelectorAll('.array-element');
                    if (transformedElements[index]) {
                        transformedElements[index].querySelector('.element-value').classList.add('rearrange-min');
                    }
                    
                    index++;
                    rearrangeStep();
                }, 1500);
            }
        }
        
        // Start rearrangement
        rearrangeStep();
    }
    
    // Start the process
    sortArrayIfNeeded();
}
// NEW: Return to Original after MinMax Rearrangement
function returnToOriginalAfterMinMax() {
    // Reset to original array
    myArray = [...originalArrayForMinMax];
    originalArrayForMinMax = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isRearrangeMinMaxRunning = false;
    
    logOperation('Min-Max rearrangement completed - returned to original array', 'info');
    showNotification('Returned to original array after rearrangement', 'success');
}
// NEW: Next Permutation Handler
function handleNextPermutation() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isNextPermutationRunning) {
        showNotification('Next permutation operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Next permutation requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForPermutation = [...myArray];
    
    // Show next permutation visualization
    showNextPermutationVisualization();
}

// NEW: Show Next Permutation Visualization
function showNextPermutationVisualization() {
    isNextPermutationRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Next Permutation Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalPermutationArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Next Permutation</div>
            <div class="transformed-array-container" id="transformedPermutationArray"></div>
        </div>
        
        <div class="permutation-explanation">
            <p class="mb-2"><strong>Next Permutation:</strong> Find lexicographically next greater permutation</p>
            <p class="mb-0" id="permutationExplanation">Starting next permutation algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="permutationStepsContainer">
            <h6 class="text-center">Next Permutation Steps</h6>
            <div class="steps-container" id="permutationSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPermutation" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForPermutation, 'originalPermutationArray');
    renderArrayInContainer([...originalArrayForPermutation], 'transformedPermutationArray');
    
    performNextPermutationAnimation();
}

// NEW: Perform Next Permutation Animation
function performNextPermutationAnimation() {
    const originalContainer = document.getElementById('originalPermutationArray');
    const transformedContainer = document.getElementById('transformedPermutationArray');
    const explanation = document.getElementById('permutationExplanation');
    const stepsContainer = document.getElementById('permutationSteps');
    const continueButton = document.getElementById('continueAfterPermutation');
    
    const arr = originalArrayForPermutation.map(val => parseFloat(val));
    const n = arr.length;
    let step = 0;
    let found = false;
    
    function performPermutationStep() {
        if (step === 0) {
            // Step 1: Find the first decreasing element from the right
            explanation.innerHTML = "Step 1: Find first index where arr[i] < arr[i+1] (from right)";
            
            let i = n - 2;
            let pivotIndex = -1;
            
            function findPivot() {
                if (i < 0) {
                    // No pivot found - array is in descending order
                    explanation.innerHTML = "No pivot found - array is in descending order. Reversing entire array.";
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 1:</strong> No decreasing element found - array is in descending order
                        </div>
                    `;
                    step = 3; // Skip to reverse step
                    performPermutationStep();
                    return;
                }
                
                // Highlight current comparison
                const elements = transformedContainer.querySelectorAll('.array-element');
                if (i + 1 < elements.length) {
                    elements[i].querySelector('.element-value').classList.add('permutation-pivot');
                    elements[i + 1].querySelector('.element-value').classList.add('sorting-compared');
                }
                
                explanation.innerHTML = `Comparing [${i}]=${arr[i]} and [${i+1}]=${arr[i+1]}`;
                
                setTimeout(() => {
                    if (arr[i] < arr[i + 1]) {
                        pivotIndex = i;
                        explanation.innerHTML = `Pivot found at index ${i} (${arr[i]} < ${arr[i+1]})`;
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Step 1:</strong> Pivot found at index ${i} (${arr[i]} < ${arr[i+1]})
                            </div>
                        `;
                        
                        // Highlight the pivot
                        elements[i].querySelector('.element-value').classList.remove('permutation-pivot');
                        elements[i].querySelector('.element-value').classList.add('permutation-pivot');
                        elements[i + 1].querySelector('.element-value').classList.remove('sorting-compared');
                        
                        step++;
                        performPermutationStep(pivotIndex);
                    } else {
                        // Remove highlights and continue searching
                        elements[i].querySelector('.element-value').classList.remove('permutation-pivot');
                        elements[i + 1].querySelector('.element-value').classList.remove('sorting-compared');
                        
                        i--;
                        findPivot();
                    }
                }, 1500);
            }
            
            findPivot();
            
        } else if (step === 1) {
            const pivotIndex = arguments[0];
            
            // Step 2: Find the smallest element greater than pivot from the right
            explanation.innerHTML = `Step 2: Find smallest element > ${arr[pivotIndex]} from right`;
            
            let j = n - 1;
            let swapIndex = -1;
            
            function findSwapCandidate() {
                if (j <= pivotIndex) {
                    step++;
                    performPermutationStep(pivotIndex, pivotIndex); // No swap candidate found
                    return;
                }
                
                // Highlight current candidate
                const elements = transformedContainer.querySelectorAll('.array-element');
                elements[j].querySelector('.element-value').classList.add('sorting-compared');
                
                explanation.innerHTML = `Comparing [${j}]=${arr[j]} with pivot ${arr[pivotIndex]}`;
                
                setTimeout(() => {
                    if (arr[j] > arr[pivotIndex]) {
                        swapIndex = j;
                        explanation.innerHTML = `Swap candidate found at index ${j} (${arr[j]} > ${arr[pivotIndex]})`;
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Step 2:</strong> Swap candidate found at index ${j} (${arr[j]} > ${arr[pivotIndex]})
                            </div>
                        `;
                        
                        // Highlight the swap candidate
                        elements[j].querySelector('.element-value').classList.remove('sorting-compared');
                        elements[j].querySelector('.element-value').classList.add('permutation-swap');
                        
                        step++;
                        performPermutationStep(pivotIndex, swapIndex);
                    } else {
                        // Remove highlight and continue searching
                        elements[j].querySelector('.element-value').classList.remove('sorting-compared');
                        
                        j--;
                        findSwapCandidate();
                    }
                }, 1500);
            }
            
            findSwapCandidate();
            
        } else if (step === 2) {
            const pivotIndex = arguments[0];
            const swapIndex = arguments[1];
            
            // Step 3: Swap pivot and swap candidate
            explanation.innerHTML = `Step 3: Swap pivot [${pivotIndex}]=${arr[pivotIndex]} with [${swapIndex}]=${arr[swapIndex]}`;
            
            const elements = transformedContainer.querySelectorAll('.array-element');
            const pivotElement = elements[pivotIndex].querySelector('.element-value');
            const swapElement = elements[swapIndex].querySelector('.element-value');
            
            pivotElement.classList.add('permutation-swap');
            swapElement.classList.add('permutation-swap');
            
            // Calculate swap distance for animation
            const rectPivot = elements[pivotIndex].getBoundingClientRect();
            const rectSwap = elements[swapIndex].getBoundingClientRect();
            const swapDistance = rectSwap.left - rectPivot.left;
            
            pivotElement.style.setProperty('--swap-distance', `${swapDistance}px`);
            swapElement.style.setProperty('--swap-distance', `-${swapDistance}px`);
            
            setTimeout(() => {
                pivotElement.classList.add('swap-animation');
                swapElement.classList.add('swap-animation');
                
                setTimeout(() => {
                    // Perform the swap
                    [arr[pivotIndex], arr[swapIndex]] = [arr[swapIndex], arr[pivotIndex]];
                    
                    // Update transformed array display
                    renderArrayInContainer(arr, 'transformedPermutationArray');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 3:</strong> Swapped elements at indices ${pivotIndex} and ${swapIndex}
                        </div>
                    `;
                    
                    // Remove highlights
                    pivotElement.classList.remove('permutation-swap', 'swap-animation');
                    swapElement.classList.remove('permutation-swap', 'swap-animation');
                    
                    step++;
                    performPermutationStep(pivotIndex);
                }, 1000);
            }, 500);
            
        } else if (step === 3) {
            const pivotIndex = arguments[0] !== undefined ? arguments[0] : -1;
            
            // Step 4: Reverse the suffix (elements after pivot)
            if (pivotIndex === -1) {
                // Entire array needs to be reversed (no next permutation case)
                explanation.innerHTML = "Step 4: Reverse entire array (no next permutation exists)";
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 4:</strong> Reversing entire array (lowest possible order)
                    </div>
                `;
                
                // Reverse the entire array with animation
                reverseSuffixWithAnimation(0, n - 1, true);
                
            } else {
                explanation.innerHTML = `Step 4: Reverse suffix after pivot (indices ${pivotIndex + 1} to ${n - 1})`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 4:</strong> Reversing elements from index ${pivotIndex + 1} to ${n - 1}
                    </div>
                `;
                
                // Reverse the suffix with animation
                reverseSuffixWithAnimation(pivotIndex + 1, n - 1, false);
            }
        }
    }
    
    // Helper function to reverse suffix with animation
    function reverseSuffixWithAnimation(left, right, isFullReverse) {
        const elements = transformedContainer.querySelectorAll('.array-element');
        let currentLeft = left;
        let currentRight = right;
        
        function reverseStep() {
            if (currentLeft >= currentRight) {
                // Reverse completed
                explanation.innerHTML = `<strong>Next Permutation Found!</strong> ${isFullReverse ? 'Array reversed to lowest order' : 'Next permutation generated'}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Next permutation algorithm completed successfully
                    </div>
                `;
                
                // Highlight the final array
                const finalElements = transformedContainer.querySelectorAll('.array-element');
                finalElements.forEach((el, index) => {
                    setTimeout(() => {
                        el.querySelector('.element-value').classList.add('create', 'bounce');
                    }, index * 100);
                });
                
                continueButton.style.display = 'block';
                
                // Auto-return after 30 seconds
                setTimeout(() => {
                    returnToOriginalAfterPermutation(arr);
                }, 30000);
                
                continueButton.addEventListener('click', () => {
                    returnToOriginalAfterPermutation(arr);
                });
                
                return;
            }
            
            // Highlight elements being swapped
            const leftElement = elements[currentLeft].querySelector('.element-value');
            const rightElement = elements[currentRight].querySelector('.element-value');
            
            leftElement.classList.add('permutation-reverse');
            rightElement.classList.add('permutation-reverse');
            
            explanation.innerHTML = `Reversing: swapping [${currentLeft}]=${arr[currentLeft]} and [${currentRight}]=${arr[currentRight]}`;
            
            setTimeout(() => {
                // Calculate swap distance for animation
                const rectLeft = elements[currentLeft].getBoundingClientRect();
                const rectRight = elements[currentRight].getBoundingClientRect();
                const swapDistance = rectRight.left - rectLeft.left;
                
                leftElement.style.setProperty('--swap-distance', `${swapDistance}px`);
                rightElement.style.setProperty('--swap-distance', `-${swapDistance}px`);
                
                leftElement.classList.add('swap-animation');
                rightElement.classList.add('swap-animation');
                
                setTimeout(() => {
                    // Perform the swap
                    [arr[currentLeft], arr[currentRight]] = [arr[currentRight], arr[currentLeft]];
                    
                    // Update transformed array display
                    renderArrayInContainer(arr, 'transformedPermutationArray');
                    
                    // Remove highlights
                    leftElement.classList.remove('permutation-reverse', 'swap-animation');
                    rightElement.classList.remove('permutation-reverse', 'swap-animation');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Reverse Step:</strong> Swapped [${currentLeft}] and [${currentRight}]
                        </div>
                    `;
                    
                    currentLeft++;
                    currentRight--;
                    reverseStep();
                }, 1000);
            }, 500);
        }
        
        reverseStep();
    }
    
    // Start the permutation process
    performPermutationStep();
}

// NEW: Return to Original after Permutation
function returnToOriginalAfterPermutation(nextPermutation) {
    // Apply the next permutation to the actual array
    myArray = nextPermutation.map(val => val.toString());
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isNextPermutationRunning = false;
    
    logOperation('Next permutation operation completed', 'info');
    showNotification('Next permutation applied successfully', 'success');
    
    // Auto-reset to original after 10 seconds
    setTimeout(() => {
        resetToOriginalAfterPermutation();
    }, 10000);
}

// NEW: Reset to original array after permutation
function resetToOriginalAfterPermutation() {
    if (originalArrayForPermutation.length === 0) {
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayForPermutation];
    originalArrayForPermutation = [];
    
    renderArray();
    updateStats();
    
    logOperation('Reset to original array after permutation', 'info');
    showNotification('Automatically reset to original array', 'info');
}
// NEW: Longest Consecutive Sequence Handler
function handleLongestConsecutiveSequence() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isConsecutiveOperationRunning) {
        showNotification('A consecutive sequence operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Longest consecutive sequence requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForConsecutive = [...myArray];
    
    // Perform longest consecutive sequence visualization
    performLongestConsecutiveSequence();
}

// NEW: Maximum Consecutive Ones Handler
function handleMaxConsecutiveOnes() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isConsecutiveOperationRunning) {
        showNotification('A consecutive sequence operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains only 0s and 1s
    let isBinaryArray = true;
    for (let i = 0; i < myArray.length; i++) {
        const value = myArray[i].toString();
        if (value !== '0' && value !== '1') {
            isBinaryArray = false;
            break;
        }
    }
    
    if (!isBinaryArray) {
        showNotification('Maximum consecutive 1s operation requires a binary array (only 0s and 1s)', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForConsecutive = [...myArray];
    
    // Perform maximum consecutive ones visualization
    performMaxConsecutiveOnes();
}

// NEW: Perform Longest Consecutive Sequence
function performLongestConsecutiveSequence() {
    isConsecutiveOperationRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Longest Consecutive Sequence</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalConsecutiveArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Longest Consecutive Sequence</div>
            <div class="transformed-array-container" id="consecutiveSequenceArray"></div>
        </div>
        
        <div class="consecutive-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find the longest sequence of consecutive numbers</p>
            <p class="mb-0" id="consecutiveExplanation">Starting longest consecutive sequence search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="consecutiveStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="consecutiveSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Longest Consecutive Sequence Length</div>
            <div class="stats-value" id="consecutiveLengthValue">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Sequence Values</div>
            <div class="stats-value" id="consecutiveValues">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterConsecutive" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForConsecutive, 'originalConsecutiveArray');
    renderArrayInContainer([], 'consecutiveSequenceArray');
    
    executeLongestConsecutiveSequence();
}

// NEW: Execute Longest Consecutive Sequence Algorithm
function executeLongestConsecutiveSequence() {
    const originalContainer = document.getElementById('originalConsecutiveArray');
    const sequenceContainer = document.getElementById('consecutiveSequenceArray');
    const explanation = document.getElementById('consecutiveExplanation');
    const stepsContainer = document.getElementById('consecutiveSteps');
    const consecutiveLengthValue = document.getElementById('consecutiveLengthValue');
    const consecutiveValues = document.getElementById('consecutiveValues');
    const continueButton = document.getElementById('continueAfterConsecutive');
    
    const arr = originalArrayForConsecutive.map(val => parseInt(val));
    const numSet = new Set(arr);
    let longestSequence = [];
    let currentSequence = [];
    let step = 0;
    
    function executeStep() {
        if (step >= arr.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Longest consecutive sequence found.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Longest consecutive sequence length = ${longestSequence.length}
                </div>
            `;
            
            // Display the longest sequence
            renderArrayInContainer(longestSequence, 'consecutiveSequenceArray');
            
            // Highlight the longest sequence in the original array
            const originalElements = originalContainer.querySelectorAll('.array-element');
            arr.forEach((value, index) => {
                if (longestSequence.includes(value)) {
                    setTimeout(() => {
                        originalElements[index].querySelector('.element-value').classList.add('consecutive-max');
                    }, (index % longestSequence.length) * 200);
                }
            });
            
            consecutiveLengthValue.textContent = longestSequence.length;
            consecutiveValues.textContent = `[${longestSequence.join(', ')}]`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterConsecutive();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterConsecutive);
            
            return;
        }
        
        const currentNum = arr[step];
        
        // Skip if this number is part of a longer sequence we've already checked
        if (numSet.has(currentNum - 1)) {
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step + 1}:</strong> Number ${currentNum} skipped (${currentNum - 1} exists, so it's not the start of a sequence)
                </div>
            `;
            
            // Highlight current number briefly
            const originalElements = originalContainer.querySelectorAll('.array-element');
            const currentElement = originalElements[step].querySelector('.element-value');
            currentElement.classList.add('consecutive-current');
            
            setTimeout(() => {
                currentElement.classList.remove('consecutive-current');
                step++;
                executeStep();
            }, 1000);
            
            return;
        }
        
        explanation.innerHTML = `Step ${step + 1}: Checking sequence starting from ${currentNum}`;
        
        // Highlight current starting number
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const startElement = originalElements[step].querySelector('.element-value');
        startElement.classList.add('consecutive-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step + 1}:</strong> Found potential sequence start at ${currentNum}
            </div>
        `;
        
        setTimeout(() => {
            // Build the sequence
            currentSequence = [currentNum];
            let nextNum = currentNum + 1;
            let sequenceStep = 0;
            
            function buildSequence() {
                if (numSet.has(nextNum)) {
                    currentSequence.push(nextNum);
                    
                    // Highlight the current sequence number
                    const nextIndex = arr.indexOf(nextNum);
                    if (nextIndex !== -1) {
                        const nextElement = originalElements[nextIndex].querySelector('.element-value');
                        nextElement.classList.add('consecutive-sequence');
                    }
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Sequence ${step + 1}.${sequenceStep + 1}:</strong> Added ${nextNum} to sequence. Current: [${currentSequence.join(', ')}]
                        </div>
                    `;
                    
                    nextNum++;
                    sequenceStep++;
                    
                    setTimeout(buildSequence, 800);
                } else {
                    // Sequence complete
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Sequence ${step + 1} Complete:</strong> Sequence [${currentSequence.join(', ')}] (length: ${currentSequence.length})
                        </div>
                    `;
                    
                    // Update longest sequence if current is longer
                    if (currentSequence.length > longestSequence.length) {
                        longestSequence = [...currentSequence];
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>New Longest Sequence!</strong> Length: ${longestSequence.length}
                            </div>
                        `;
                        
                        consecutiveLengthValue.textContent = longestSequence.length;
                        consecutiveValues.textContent = `[${longestSequence.join(', ')}]`;
                        
                        // Update sequence display
                        renderArrayInContainer(longestSequence, 'consecutiveSequenceArray');
                        
                        // Highlight the new longest sequence
                        const sequenceElements = sequenceContainer.querySelectorAll('.array-element');
                        sequenceElements.forEach((el, idx) => {
                            setTimeout(() => {
                                el.querySelector('.element-value').classList.add('consecutive-max');
                            }, idx * 200);
                        });
                    }
                    
                    // Remove highlights from start element
                    startElement.classList.remove('consecutive-current');
                    
                    // Move to next number
                    step++;
                    executeStep();
                }
            }
            
            buildSequence();
        }, 1500);
    }
    
    // Start execution
    executeStep();
}

// NEW: Perform Maximum Consecutive Ones
function performMaxConsecutiveOnes() {
    isConsecutiveOperationRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Maximum Consecutive 1s in Binary Array</h5>
        
        <div class="array-group">
            <div class="array-label">Binary Array</div>
            <div class="original-array-container" id="originalConsecutiveArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Maximum Consecutive 1s Sequence</div>
            <div class="transformed-array-container" id="consecutiveSequenceArray"></div>
        </div>
        
        <div class="consecutive-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find the longest sequence of consecutive 1s</p>
            <p class="mb-0" id="consecutiveExplanation">Starting maximum consecutive 1s search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="consecutiveStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="consecutiveSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Maximum Consecutive 1s Length</div>
            <div class="stats-value" id="consecutiveLengthValue">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Sequence Positions</div>
            <div class="stats-value" id="consecutiveValues">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterConsecutive" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForConsecutive, 'originalConsecutiveArray');
    renderArrayInContainer([], 'consecutiveSequenceArray');
    
    executeMaxConsecutiveOnes();
}

// NEW: Execute Maximum Consecutive Ones Algorithm
function executeMaxConsecutiveOnes() {
    const originalContainer = document.getElementById('originalConsecutiveArray');
    const sequenceContainer = document.getElementById('consecutiveSequenceArray');
    const explanation = document.getElementById('consecutiveExplanation');
    const stepsContainer = document.getElementById('consecutiveSteps');
    const consecutiveLengthValue = document.getElementById('consecutiveLengthValue');
    const consecutiveValues = document.getElementById('consecutiveValues');
    const continueButton = document.getElementById('continueAfterConsecutive');
    
    const arr = originalArrayForConsecutive.map(val => parseInt(val));
    let maxCount = 0;
    let currentCount = 0;
    let maxStart = -1;
    let currentStart = -1;
    let step = 0;
    
    function executeStep() {
        if (step >= arr.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Maximum consecutive 1s found.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Maximum consecutive 1s = ${maxCount}
                </div>
            `;
            
            // Display the sequence of 1s
            const onesSequence = Array(maxCount).fill('1');
            renderArrayInContainer(onesSequence, 'consecutiveSequenceArray');
            
            // Highlight the maximum sequence in the original array
            const originalElements = originalContainer.querySelectorAll('.array-element');
            for (let i = maxStart; i < maxStart + maxCount; i++) {
                setTimeout(() => {
                    originalElements[i].querySelector('.element-value').classList.add('consecutive-max');
                }, (i - maxStart) * 200);
            }
            
            consecutiveLengthValue.textContent = maxCount;
            consecutiveValues.textContent = `Positions ${maxStart} to ${maxStart + maxCount - 1}`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterConsecutive();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterConsecutive);
            
            return;
        }
        
        const currentValue = arr[step];
        
        explanation.innerHTML = `Step ${step + 1}: Checking position ${step}, value = ${currentValue}`;
        
        // Highlight current element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[step].querySelector('.element-value');
        
        if (currentValue === 1) {
            currentElement.classList.add('consecutive-current');
            
            if (currentCount === 0) {
                currentStart = step;
            }
            currentCount++;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step + 1}:</strong> Found 1 at position ${step}. Current consecutive count = ${currentCount}
                </div>
            `;
            
            // Update max if needed
            if (currentCount > maxCount) {
                maxCount = currentCount;
                maxStart = currentStart;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>New Maximum!</strong> Consecutive 1s count = ${maxCount}
                    </div>
                `;
                
                consecutiveLengthValue.textContent = maxCount;
                consecutiveValues.textContent = `Positions ${maxStart} to ${maxStart + maxCount - 1}`;
            }
            
        } else {
            currentElement.classList.add('consecutive-sequence');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step + 1}:</strong> Found 0 at position ${step}. Resetting consecutive count
                </div>
            `;
            
            currentCount = 0;
            currentStart = -1;
            
            setTimeout(() => {
                currentElement.classList.remove('consecutive-sequence');
            }, 500);
        }
        
        setTimeout(() => {
            currentElement.classList.remove('consecutive-current');
            step++;
            executeStep();
        }, 1000);
    }
    
    // Start execution
    executeStep();
}

// NEW: Return to Original after Consecutive Operations
function returnToOriginalAfterConsecutive() {
    // Reset to original array
    myArray = [...originalArrayForConsecutive];
    originalArrayForConsecutive = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isConsecutiveOperationRunning = false;
    
    logOperation('Consecutive sequence operation completed - returned to original array', 'info');
    showNotification('Returned to original array after consecutive sequence operation', 'success');
}
// NEW: Merge Intervals Handler
function handleMergeIntervals() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }

    if (isMergeIntervalsRunning) {
        showNotification('Merge intervals operation is already in progress', 'warning');
        return;
    }

    // Check if array contains valid intervals (pairs of numbers)
    let validIntervals = true;
    let intervals = [];
    
    try {
        // Try to parse array as intervals
        if (myArray.length % 2 !== 0) {
            throw new Error('Array length must be even for intervals');
        }
        
        for (let i = 0; i < myArray.length; i += 2) {
            const start = parseFloat(myArray[i]);
            const end = parseFloat(myArray[i + 1]);
            
            if (isNaN(start) || isNaN(end)) {
                throw new Error('All interval values must be numbers');
            }
            
            if (start > end) {
                throw new Error('Interval start cannot be greater than end');
            }
            
            intervals.push([start, end]);
        }
    } catch (error) {
        showNotification(`Invalid intervals format: ${error.message}. Please provide pairs of numbers [start, end, start, end, ...]`, 'danger');
        return;
    }

    isMergeIntervalsRunning = true;
    
    // Store original array
    originalArrayForMergeIntervals = [...myArray];
    
    // Show merge intervals visualization
    showMergeIntervalsVisualization(intervals);
}

// NEW: Show Merge Intervals Visualization
function showMergeIntervalsVisualization(intervals) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Merge Intervals Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Intervals</div>
            <div class="original-array-container" id="originalIntervalsArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Merged Intervals</div>
            <div class="transformed-array-container" id="mergedIntervalsArray"></div>
        </div>
        
        <div class="interval-visualization" id="intervalVisualization">
            <h6 class="text-center">Interval Visualization</h6>
            <div id="intervalLinesContainer"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Merge Intervals:</strong> Combine overlapping intervals into single intervals</p>
            <p class="mb-0" id="mergeIntervalsExplanation">Starting merge intervals algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="mergeIntervalsStepsContainer">
            <h6 class="text-center">Merge Intervals Steps</h6>
            <div class="steps-container" id="mergeIntervalsSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMergeIntervals" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;

    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);

    // Display original intervals
    renderIntervalsArray(intervals, 'originalIntervalsArray');
    
    // Create visualization lines
    createIntervalVisualization(intervals);
    
    // Start merge intervals animation
    performMergeIntervalsAnimation(intervals);
}

// NEW: Render Intervals Array
function renderIntervalsArray(intervals, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    intervals.forEach((interval, index) => {
        const intervalElement = document.createElement('div');
        intervalElement.className = 'array-element';
        intervalElement.innerHTML = `
            <div class="element-value interval-item" data-interval-index="${index}">
                [${interval[0]}, ${interval[1]}]
            </div>
            <div class="element-index">Interval ${index}</div>
        `;
        container.appendChild(intervalElement);
    });
}

// NEW: Create Interval Visualization
function createIntervalVisualization(intervals) {
    const container = document.getElementById('intervalLinesContainer');
    container.innerHTML = '';
    
    // Find min and max values for scaling
    let minVal = Infinity;
    let maxVal = -Infinity;
    
    intervals.forEach(interval => {
        minVal = Math.min(minVal, interval[0]);
        maxVal = Math.max(maxVal, interval[1]);
    });
    
    const range = maxVal - minVal || 1;
    
    intervals.forEach((interval, index) => {
        const line = document.createElement('div');
        line.className = 'interval-line';
        
        const startPos = ((interval[0] - minVal) / range) * 100;
        const endPos = ((interval[1] - minVal) / range) * 100;
        const width = endPos - startPos;
        
        line.innerHTML = `
            <div class="interval-label">Interval ${index}</div>
            <div class="interval-range">
                <div class="interval-segment original" 
                     style="left: ${startPos}%; width: ${width}%;"
                     data-interval-index="${index}">
                </div>
            </div>
            <div class="interval-values">[${interval[0]}, ${interval[1]}]</div>
        `;
        
        container.appendChild(line);
    });
}

// NEW: Perform Merge Intervals Animation
function performMergeIntervalsAnimation(intervals) {
    const originalContainer = document.getElementById('originalIntervalsArray');
    const mergedContainer = document.getElementById('mergedIntervalsArray');
    const explanation = document.getElementById('mergeIntervalsExplanation');
    const stepsContainer = document.getElementById('mergeIntervalsSteps');
    const continueButton = document.getElementById('continueAfterMergeIntervals');
    const visualizationContainer = document.getElementById('intervalLinesContainer');
    
    // Sort intervals by start time
    const sortedIntervals = [...intervals].sort((a, b) => a[0] - b[0]);
    let merged = [];
    let currentStep = 0;
    
    function performMergeStep(i) {
        if (i >= sortedIntervals.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Merge Intervals Completed!</strong> Found ${merged.length} merged intervals.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Algorithm completed. ${merged.length} merged intervals found.
                </div>
            `;
            
            // Display final merged intervals
            renderIntervalsArray(merged, 'mergedIntervalsArray');
            
            // Highlight final merged intervals
            setTimeout(() => {
                const mergedElements = mergedContainer.querySelectorAll('.array-element');
                mergedElements.forEach((el, index) => {
                    setTimeout(() => {
                        el.querySelector('.element-value').classList.add('interval-merged');
                    }, index * 300);
                });
            }, 500);
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterMergeIntervals();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterMergeIntervals);
            
            return;
        }
        
        currentStep++;
        
        if (i === 0) {
            // First interval
            explanation.innerHTML = `Step ${currentStep}: Start with first interval [${sortedIntervals[i][0]}, ${sortedIntervals[i][1]}]`;
            
            // Highlight first interval
            highlightInterval(originalContainer, i, 'interval-start');
            highlightVisualizationSegment(i, 'interval-start');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${currentStep}:</strong> Start with first interval [${sortedIntervals[i][0]}, ${sortedIntervals[i][1]}]
                </div>
            `;
            
            merged.push([...sortedIntervals[i]]);
            
            setTimeout(() => {
                performMergeStep(i + 1);
            }, 2000);
            
        } else {
            const currentInterval = sortedIntervals[i];
            const lastMerged = merged[merged.length - 1];
            
            explanation.innerHTML = `Step ${currentStep}: Compare [${lastMerged[0]}, ${lastMerged[1]}] with [${currentInterval[0]}, ${currentInterval[1]}]`;
            
            // Highlight both intervals being compared
            highlightInterval(originalContainer, i, 'interval-start');
            highlightVisualizationSegment(i, 'interval-start');
            
            // Find and highlight the last merged interval in original array
            const originalIndex = intervals.findIndex(interval => 
                interval[0] === lastMerged[0] && interval[1] === lastMerged[1]);
            if (originalIndex !== -1) {
                highlightInterval(originalContainer, originalIndex, 'interval-end');
                highlightVisualizationSegment(originalIndex, 'interval-end');
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${currentStep}:</strong> Comparing [${lastMerged[0]}, ${lastMerged[1]}] with [${currentInterval[0]}, ${currentInterval[1]}]
                </div>
            `;
            
            setTimeout(() => {
                if (currentInterval[0] <= lastMerged[1]) {
                    // Overlapping intervals - merge them
                    explanation.innerHTML = `Step ${currentStep}: Intervals OVERLAP! Merging into [${lastMerged[0]}, ${Math.max(lastMerged[1], currentInterval[1])}]`;
                    
                    // Highlight overlap
                    highlightInterval(originalContainer, i, 'interval-overlap');
                    highlightVisualizationSegment(i, 'interval-overlap');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${currentStep}:</strong> Intervals overlap! Merging into [${lastMerged[0]}, ${Math.max(lastMerged[1], currentInterval[1])}]
                        </div>
                    `;
                    
                    // Update the merged interval
                    lastMerged[1] = Math.max(lastMerged[1], currentInterval[1]);
                    
                    // Update visualization for merged interval
                    updateMergedVisualization(merged);
                    
                } else {
                    // Non-overlapping interval
                    explanation.innerHTML = `Step ${currentStep}: No overlap. Adding new interval [${currentInterval[0]}, ${currentInterval[1]}]`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${currentStep}:</strong> No overlap. Adding new interval to merged list
                        </div>
                    `;
                    
                    merged.push([...currentInterval]);
                }
                
                // Update merged intervals display
                renderIntervalsArray(merged, 'mergedIntervalsArray');
                
                // Scroll steps container
                stepsContainer.scrollTop = stepsContainer.scrollHeight;
                
                setTimeout(() => {
                    performMergeStep(i + 1);
                }, 2500);
            }, 2000);
        }
    }
    
    // Start merge intervals process
    performMergeStep(0);
}

// NEW: Helper function to highlight intervals
function highlightInterval(container, index, className) {
    const elements = container.querySelectorAll('.array-element');
    if (elements[index]) {
        const valueElement = elements[index].querySelector('.element-value');
        valueElement.classList.add(className);
        
        // Remove highlight after animation
        setTimeout(() => {
            valueElement.classList.remove(className);
        }, 2000);
    }
}

// NEW: Helper function to highlight visualization segments
function highlightVisualizationSegment(index, className) {
    const segments = document.querySelectorAll(`.interval-segment[data-interval-index="${index}"]`);
    segments.forEach(segment => {
        segment.classList.add(className);
        
        // Remove highlight after animation
        setTimeout(() => {
            segment.classList.remove(className);
        }, 2000);
    });
}

// NEW: Update merged visualization
function updateMergedVisualization(merged) {
    const visualizationContainer = document.getElementById('intervalLinesContainer');
    
    // Clear existing merged visualization
    const existingMerged = visualizationContainer.querySelectorAll('.interval-segment.merged');
    existingMerged.forEach(segment => segment.remove());
    
    // Find min and max values for scaling
    let minVal = Infinity;
    let maxVal = -Infinity;
    
    merged.forEach(interval => {
        minVal = Math.min(minVal, interval[0]);
        maxVal = Math.max(maxVal, interval[1]);
    });
    
    const range = maxVal - minVal || 1;
    
    // Add merged intervals to visualization
    merged.forEach((interval, index) => {
        const startPos = ((interval[0] - minVal) / range) * 100;
        const endPos = ((interval[1] - minVal) / range) * 100;
        const width = endPos - startPos;
        
        const mergedSegment = document.createElement('div');
        mergedSegment.className = 'interval-segment merged';
        mergedSegment.style.cssText = `left: ${startPos}%; width: ${width}%;`;
        mergedSegment.setAttribute('data-merged-index', index);
        
        visualizationContainer.appendChild(mergedSegment);
    });
}

// NEW: Return to Original after Merge Intervals
function returnToOriginalAfterMergeIntervals() {
    // Reset to original array
    myArray = [...originalArrayForMergeIntervals];
    originalArrayForMergeIntervals = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMergeIntervalsRunning = false;
    
    logOperation('Merge intervals completed - returned to original array', 'info');
    showNotification('Returned to original array after merge intervals', 'success');
}
// NEW: Set Operation Handler
function handleSetOperation(operation) {
    if (isSetOperationRunning) {
        showNotification('A set operation is already in progress', 'warning');
        return;
    }

    // Reset arrays
    setArrays = [];
    currentSetOperation = operation;
    
    // Show input group
    setOperationsGroup.style.display = 'block';
    numArrays.focus();
    
    // Hide perform button initially
    performSetOperationBtn.style.display = 'none';
    
    // Update button text based on operation
    performSetOperationBtn.innerHTML = 
        operation === 'union' 
            ? '<i class="fas fa-object-group me-2"></i>Find Union' 
            : '<i class="fas fa-bezier-curve me-2"></i>Find Intersection';
    
    logOperation(`Started ${operation} operation`, 'info');
}

// NEW: Confirm Number of Arrays Handler
function handleConfirmNumArrays() {
    const num = parseInt(numArrays.value);
    
    if (isNaN(num) || num < 1 || num > 3) {
        showNotification('Please enter a valid number between 1 and 3', 'danger');
        numArrays.focus();
        return;
    }
    
    setArrays = Array(num).fill().map(() => []);
    
    // Create input fields for each array
    setArraysInputs.innerHTML = '';
    for (let i = 0; i < num; i++) {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'mb-3';
        arrayGroup.innerHTML = `
            <label class="form-label">Array ${i + 1} Details</label>
            <div class="input-group mb-2">
                <input type="number" class="form-control array-size" 
                       data-array-index="${i}" placeholder="Size of array ${i + 1}" min="1" max="20">
                <button class="btn btn-glow confirm-array-size-btn" data-array-index="${i}">
                    <i class="fas fa-check me-2"></i>Set Array ${i + 1} Size
                </button>
            </div>
            <div class="array-inputs" id="arrayInputs${i}"></div>
        `;
        setArraysInputs.appendChild(arrayGroup);
    }
    
    // Add event listeners for array size buttons
    const confirmSizeButtons = setArraysInputs.querySelectorAll('.confirm-array-size-btn');
    confirmSizeButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
            const arrayIndex = parseInt(e.target.dataset.arrayIndex);
            handleConfirmArraySize(arrayIndex);
        });
    });
    
    // Add Enter key support for array size inputs
    const arraySizeInputs = setArraysInputs.querySelectorAll('.array-size');
    arraySizeInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const arrayIndex = parseInt(e.target.dataset.arrayIndex);
                handleConfirmArraySize(arrayIndex);
            }
        });
    });
    
    showNotification(`Number of arrays set to ${num}. Please set sizes for each array.`, 'success');
    logOperation(`Number of arrays set to ${num}`, 'info');
}

// NEW: Confirm Array Size Handler
function handleConfirmArraySize(arrayIndex) {
    const sizeInput = document.querySelector(`.array-size[data-array-index="${arrayIndex}"]`);
    const size = parseInt(sizeInput.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        sizeInput.focus();
        return;
    }
    
    // Create input fields for array elements
    const arrayInputsContainer = document.getElementById(`arrayInputs${arrayIndex}`);
    arrayInputsContainer.innerHTML = `<label class="form-label">Enter ${size} elements for Array ${arrayIndex + 1}:</label>`;
    
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="text" class="form-control set-array-element" 
                   data-array-index="${arrayIndex}" data-element-index="${i}" 
                   placeholder="Enter value">
        `;
        arrayInputsContainer.appendChild(inputGroup);
    }
    
    // Add event listeners for array element inputs
    const elementInputs = arrayInputsContainer.querySelectorAll('.set-array-element');
    elementInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('set-array-element')) {
                    nextInput.focus();
                }
            }
        });
    });
    
    // Check if all arrays are ready
    checkAllArraysReady();
    
    showNotification(`Array ${arrayIndex + 1} size set to ${size}. Please enter ${size} elements.`, 'success');
    logOperation(`Array ${arrayIndex + 1} size set to ${size}`, 'info');
}

// NEW: Check if all arrays are ready
function checkAllArraysReady() {
    const num = parseInt(numArrays.value);
    let allReady = true;
    
    for (let i = 0; i < num; i++) {
        const arrayInputs = document.querySelectorAll(`.set-array-element[data-array-index="${i}"]`);
        if (arrayInputs.length === 0) {
            allReady = false;
            break;
        }
    }
    
    if (allReady) {
        performSetOperationBtn.style.display = 'block';
    }
}

// NEW: Perform Set Operation Handler
function handlePerformSetOperation() {
    const num = parseInt(numArrays.value);
    
    // Collect all array elements
    for (let i = 0; i < num; i++) {
        const elementInputs = document.querySelectorAll(`.set-array-element[data-array-index="${i}"]`);
        setArrays[i] = [];
        
        for (let j = 0; j < elementInputs.length; j++) {
            const value = elementInputs[j].value.trim();
            if (value === '') {
                showNotification(`Please enter all elements for array ${i + 1}. Missing element at position ${j}`, 'danger');
                elementInputs[j].focus();
                return;
            }
            setArrays[i].push(value);
        }
    }
    
    // Store original array
    originalArrayBeforeSetOperation = [...myArray];
    
    // Hide input group
    setOperationsGroup.style.display = 'none';
    
    // Start set operation visualization
    showSetOperationVisualization();
}

// NEW: Cancel Set Operation Handler
function handleCancelSetOperation() {
    setOperationsGroup.style.display = 'none';
    numArrays.value = '';
    setArraysInputs.innerHTML = '';
    performSetOperationBtn.style.display = 'none';
    
    setArrays = [];
    currentSetOperation = null;
    
    logOperation('Cancelled set operation', 'info');
    showNotification('Set operation cancelled', 'info');
}

// NEW: Show Set Operation Visualization
function showSetOperationVisualization() {
    isSetOperationRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">${currentSetOperation === 'union' ? 'Union' : 'Intersection'} of Arrays</h5>
        
        <div class="array-group">
            <div class="array-label">Input Arrays</div>
            <div id="inputArraysDisplay" class="mb-4"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">${currentSetOperation === 'union' ? 'Union' : 'Intersection'} Result</div>
            <div class="transformed-array-container" id="setResultArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>${currentSetOperation === 'union' ? 'Union' : 'Intersection'} Process:</strong> ${currentSetOperation === 'union' ? 'Combining all unique elements from all arrays' : 'Finding common elements across all arrays'}</p>
            <p class="mb-0" id="setOperationExplanation">Starting ${currentSetOperation} operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="setOperationStepsContainer">
            <h6 class="text-center">${currentSetOperation === 'union' ? 'Union' : 'Intersection'} Steps</h6>
            <div class="steps-container" id="setOperationSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSetOperation" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display input arrays
    displayInputArrays();
    renderArrayInContainer([], 'setResultArray');
    
    // Start set operation animation
    performSetOperationAnimation();
}
// NEW: Display Input Arrays
function displayInputArrays() {
    const inputArraysContainer = document.getElementById('inputArraysDisplay');
    inputArraysContainer.innerHTML = '';
    
    // Add horizontal container styling
    inputArraysContainer.style.display = 'flex';
    inputArraysContainer.style.flexWrap = 'wrap';
    inputArraysContainer.style.gap = '50px';
    inputArraysContainer.style.justifyContent = 'center';
    inputArraysContainer.style.alignItems = 'flex-start';
    
    setArrays.forEach((array, index) => {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'horizontal-array-group';
        arrayGroup.style.flex = '0 0 auto';
        arrayGroup.style.textAlign = 'center';
        arrayGroup.innerHTML = `
            <div class="array-label" style="margin-bottom: 10px; font-weight: bold;">Array ${index + 1}</div>
            <div class="horizontal-array-elements" id="inputArray${index}" style="display: flex; gap: 10px; justify-content: center;"></div>
        `;
        inputArraysContainer.appendChild(arrayGroup);
        renderHorizontalArrayInContainer(array, `inputArray${index}`);
    });
}

// NEW: Render array horizontally for set operations
function renderHorizontalArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    array.forEach((element, index) => {
        const elementDiv = document.createElement('div');
        elementDiv.className = 'array-element horizontal-element';
        elementDiv.style.display = 'flex';
        elementDiv.style.flexDirection = 'column';
        elementDiv.style.alignItems = 'center';
        elementDiv.style.margin = '0 5px';
        
        elementDiv.innerHTML = `
            <div class="element-value" style="min-width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 8px; font-weight: bold; font-size: 16px; margin-bottom: 5px;">
                ${element}
            </div>
            <div class="element-index" style="font-size: 12px; color: #666; background: #f8f9fa; padding: 2px 8px; border-radius: 4px;">
                [${index}]
            </div>
        `;
        
        container.appendChild(elementDiv);
    });
}
// NEW: Perform Set Operation Animation
function performSetOperationAnimation() {
    const explanation = document.getElementById('setOperationExplanation');
    const stepsContainer = document.getElementById('setOperationSteps');
    const continueButton = document.getElementById('continueAfterSetOperation');
    
    let resultArray = [];
    let step = 0;
    
    function performSetStep() {
        if (currentSetOperation === 'union') {
            performUnionStep();
        } else {
            performIntersectionStep();
        }
    }
    
    function performUnionStep() {
        if (step === 0) {
            explanation.innerHTML = 'Step 1: Initialize empty set for union';
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Initialize empty set to collect unique elements
                </div>
            `;
            step++;
            setTimeout(performUnionStep, 1500);
            return;
        }
        
        if (step === 1) {
            explanation.innerHTML = 'Step 2: Processing arrays to find union';
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 2:</strong> Processing ${setArrays.length} arrays for union
                </div>
            `;
            
            // Create a Set for union
            const unionSet = new Set();
            let currentArrayIndex = 0;
            let currentElementIndex = 0;
            
            function processNextElement() {
                if (currentArrayIndex >= setArrays.length) {
                    // Union completed
                    resultArray = Array.from(unionSet);
                    renderArrayInContainer(resultArray, 'setResultArray');
                    
                    explanation.innerHTML = `<strong>Union Completed!</strong> Found ${resultArray.length} unique elements.`;
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Final:</strong> Union completed! Total unique elements: ${resultArray.length}
                        </div>
                    `;
                    
                    // Highlight the result
                    const resultElements = document.querySelectorAll('#setResultArray .array-element');
                    resultElements.forEach((el, index) => {
                        setTimeout(() => {
                            el.querySelector('.element-value').classList.add('create', 'bounce');
                        }, index * 200);
                    });
                    
                    continueButton.style.display = 'block';
                    setTimeout(() => {
                        returnToOriginalAfterSetOperation();
                    }, 5000);
                    continueButton.addEventListener('click', returnToOriginalAfterSetOperation);
                    return;
                }
                
                if (currentElementIndex >= setArrays[currentArrayIndex].length) {
                    // Move to next array
                    currentArrayIndex++;
                    currentElementIndex = 0;
                    processNextElement();
                    return;
                }
                
                const currentElement = setArrays[currentArrayIndex][currentElementIndex];
                explanation.innerHTML = `Processing Array ${currentArrayIndex + 1}[${currentElementIndex}] = "${currentElement}"`;
                
                // Highlight current element in input array
                const inputArray = document.getElementById(`inputArray${currentArrayIndex}`);
                const inputElements = inputArray.querySelectorAll('.array-element');
                if (currentElementIndex < inputElements.length) {
                    inputElements[currentElementIndex].querySelector('.element-value').classList.add('window-current');
                }
                
                setTimeout(() => {
                    // Add to union set
                    const isNewElement = !unionSet.has(currentElement);
                    unionSet.add(currentElement);
                    
                    if (isNewElement) {
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Step:</strong> Added "${currentElement}" to union (new element)
                            </div>
                        `;
                        // Update result array
                        resultArray = Array.from(unionSet);
                        renderArrayInContainer(resultArray, 'setResultArray');
                    } else {
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Step:</strong> Element "${currentElement}" already in union (duplicate)
                            </div>
                        `;
                    }
                    
                    // Remove highlight
                    if (currentElementIndex < inputElements.length) {
                        inputElements[currentElementIndex].querySelector('.element-value').classList.remove('window-current');
                    }
                    
                    currentElementIndex++;
                    processNextElement();
                }, 1000);
            }
            
            processNextElement();
        }
    }
    
    function performIntersectionStep() {
        if (step === 0) {
            explanation.innerHTML = 'Step 1: Initialize with first array';
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Start with first array as initial intersection
                </div>
            `;
            
            if (setArrays.length === 0) {
                resultArray = [];
            } else {
                resultArray = [...new Set(setArrays[0])]; // Remove duplicates from first array
            }
            
            renderArrayInContainer(resultArray, 'setResultArray');
            step++;
            setTimeout(performIntersectionStep, 1500);
            return;
        }
        
        if (step <= setArrays.length) {
            const currentArrayIndex = step;
            
            if (currentArrayIndex >= setArrays.length) {
                // Intersection completed
                explanation.innerHTML = `<strong>Intersection Completed!</strong> Found ${resultArray.length} common elements.`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Intersection completed! Common elements: ${resultArray.length}
                    </div>
                `;
                
                // Highlight the result
                const resultElements = document.querySelectorAll('#setResultArray .array-element');
                resultElements.forEach((el, index) => {
                    setTimeout(() => {
                        el.querySelector('.element-value').classList.add('create', 'bounce');
                    }, index * 200);
                });
                
                continueButton.style.display = 'block';
                setTimeout(() => {
                    returnToOriginalAfterSetOperation();
                }, 5000);
                continueButton.addEventListener('click', returnToOriginalAfterSetOperation);
                return;
            }
            
            explanation.innerHTML = `Step ${step + 1}: Intersecting with Array ${currentArrayIndex + 1}`;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step + 1}:</strong> Finding common elements with Array ${currentArrayIndex + 1}
                </div>
            `;
            
            const currentArray = setArrays[currentArrayIndex];
            const newIntersection = [];
            let elementIndex = 0;
            
            function processIntersectionElement() {
                if (elementIndex >= resultArray.length) {
                    // Finished processing current intersection
                    resultArray = [...new Set(newIntersection)]; // Remove duplicates
                    renderArrayInContainer(resultArray, 'setResultArray');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Result:</strong> After Array ${currentArrayIndex + 1}, common elements: ${resultArray.length}
                        </div>
                    `;
                    
                    step++;
                    setTimeout(performIntersectionStep, 1500);
                    return;
                }
                
                const currentElement = resultArray[elementIndex];
                explanation.innerHTML = `Checking element "${currentElement}" in Array ${currentArrayIndex + 1}`;
                
                // Highlight in result array
                const resultContainer = document.getElementById('setResultArray');
                const resultElements = resultContainer.querySelectorAll('.array-element');
                if (elementIndex < resultElements.length) {
                    resultElements[elementIndex].querySelector('.element-value').classList.add('window-current');
                }
                
                setTimeout(() => {
                    const existsInCurrentArray = currentArray.includes(currentElement);
                    
                    if (existsInCurrentArray) {
                        newIntersection.push(currentElement);
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Keep:</strong> "${currentElement}" exists in Array ${currentArrayIndex + 1}
                            </div>
                        `;
                    } else {
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Remove:</strong> "${currentElement}" not in Array ${currentArrayIndex + 1}
                            </div>
                        `;
                    }
                    
                    // Remove highlight
                    if (elementIndex < resultElements.length) {
                        resultElements[elementIndex].querySelector('.element-value').classList.remove('window-current');
                    }
                    
                    elementIndex++;
                    processIntersectionElement();
                }, 1000);
            }
            
            processIntersectionElement();
        }
    }
    
    // Start set operation
    performSetStep();
}

// NEW: Return to Original after Set Operation
function returnToOriginalAfterSetOperation() {
    // Reset to original array
    myArray = [...originalArrayBeforeSetOperation];
    originalArrayBeforeSetOperation = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isSetOperationRunning = false;
    
    // Clear all set operation data
    setArrays = [];
    currentSetOperation = null;
    
    // Reset input groups
    setOperationsGroup.style.display = 'none';
    numArrays.value = '';
    setArraysInputs.innerHTML = '';
    performSetOperationBtn.style.display = 'none';
    
    logOperation('Set operation completed - returned to original array', 'info');
    showNotification('Returned to original array after set operation', 'success');
}
// NEW: Handle Set Operation
function handleSetOperation(operationType) {
    if (isSetOpRunning) {
        showNotification('A set operation is already in progress', 'warning');
        return;
    }

    currentSetOpType = operationType;
    setOpArrays = [];
    
    // Show input group
    setOperationsGroup.style.display = 'block';
    numArrays.focus();
    
    // Hide perform button initially
    performSetOperationBtn.style.display = 'none';
    
    const operationName = operationType === 'difference' ? 'Set Difference' : 'Symmetric Difference';
    logOperation(`Started ${operationName} operation`, 'info');
}

// NEW: Confirm Number of Arrays for Set Operation
function handleConfirmNumArrays() {
    const count = parseInt(numArrays.value);
    
    if (isNaN(count) || count !== 2) {
        showNotification('Set operations require exactly 2 arrays', 'danger');
        numArrays.focus();
        return;
    }
    
    // Create input fields for arrays
    setArraysInputs.innerHTML = '';
    
    for (let i = 0; i < count; i++) {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'mb-3';
        arrayGroup.innerHTML = `
            <label class="form-label">Array ${String.fromCharCode(65 + i)} Details</label>
            <div class="input-group mb-2">
                <input type="number" class="form-control set-array-size" 
                       data-array-index="${i}" placeholder="Size of Array ${String.fromCharCode(65 + i)}" min="1" max="20">
                <button class="btn btn-glow confirm-array-size-btn" data-array-index="${i}">
                    <i class="fas fa-check me-2"></i>Set Size
                </button>
            </div>
            <div class="array-inputs-container" id="arrayInputs${i}"></div>
        `;
        setArraysInputs.appendChild(arrayGroup);
    }
    
    // Add event listeners for array size buttons
    const sizeButtons = setArraysInputs.querySelectorAll('.confirm-array-size-btn');
    sizeButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
            const arrayIndex = parseInt(e.target.getAttribute('data-array-index'));
            handleConfirmArraySize(arrayIndex);
        });
    });
    
    // Add Enter key support for size inputs
    const sizeInputs = setArraysInputs.querySelectorAll('.set-array-size');
    sizeInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const arrayIndex = parseInt(e.target.getAttribute('data-array-index'));
                handleConfirmArraySize(arrayIndex);
            }
        });
    });
    
    showNotification(`Set up ${count} arrays for set operation`, 'success');
}

// NEW: Confirm Array Size for Set Operation
function handleConfirmArraySize(arrayIndex) {
    const sizeInput = document.querySelector(`.set-array-size[data-array-index="${arrayIndex}"]`);
    const size = parseInt(sizeInput.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification(`Please enter a valid size between 1 and 20 for Array ${String.fromCharCode(65 + arrayIndex)}`, 'danger');
        sizeInput.focus();
        return;
    }
    
    // Create input fields for array elements
    const inputsContainer = document.getElementById(`arrayInputs${arrayIndex}`);
    inputsContainer.innerHTML = `<label class="form-label">Enter elements for Array ${String.fromCharCode(65 + arrayIndex)}:</label>`;
    
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="text" class="form-control set-array-element" 
                   data-array-index="${arrayIndex}" data-element-index="${i}" placeholder="Enter value">
        `;
        inputsContainer.appendChild(inputGroup);
    }
    
    // Disable size input and button
    sizeInput.disabled = true;
    document.querySelector(`.confirm-array-size-btn[data-array-index="${arrayIndex}"]`).disabled = true;
    
    // Add event listeners for element inputs
    const elementInputs = inputsContainer.querySelectorAll('.set-array-element');
    elementInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('set-array-element')) {
                    nextInput.focus();
                }
            }
        });
    });
    
    // Check if all arrays are ready
    checkAllArraysReady();
}

// NEW: Check if all arrays are ready for set operation
function checkAllArraysReady() {
    const allSizeInputs = setArraysInputs.querySelectorAll('.set-array-size');
    let allReady = true;
    
    for (let i = 0; i < allSizeInputs.length; i++) {
        if (!allSizeInputs[i].disabled) {
            allReady = false;
            break;
        }
    }
    
    if (allReady) {
        performSetOperationBtn.style.display = 'block';
        showNotification('All arrays are ready. Click "Perform Set Operation" to continue.', 'success');
    }
}

// NEW: Perform Set Operation
function handlePerformSetOperation() {
    const arrayCount = parseInt(numArrays.value);
    setOpArrays = [];
    
    // Collect all array elements
    for (let i = 0; i < arrayCount; i++) {
        const elementInputs = document.querySelectorAll(`.set-array-element[data-array-index="${i}"]`);
        const array = [];
        
        for (let j = 0; j < elementInputs.length; j++) {
            const value = elementInputs[j].value.trim();
            if (value === '') {
                showNotification(`Please enter all elements for Array ${String.fromCharCode(65 + i)}. Missing element at position ${j}`, 'danger');
                elementInputs[j].focus();
                return;
            }
            array.push(value);
        }
        
        setOpArrays.push(array);
    }
    
    // Store original array
    originalArrayBeforeSetOp = [...myArray];
    
    // Hide input group
    setOperationsGroup.style.display = 'none';
    
    // Start set operation visualization
    showSetOperationVisualization();
}

// NEW: Cancel Set Operation
function handleCancelSetOperation() {
    setOperationsGroup.style.display = 'none';
    numArrays.value = '2';
    setArraysInputs.innerHTML = '';
    performSetOperationBtn.style.display = 'none';
    
    setOpArrays = [];
    currentSetOpType = null;
    
    logOperation('Cancelled set operation', 'info');
    showNotification('Set operation cancelled', 'info');
}

// NEW: Show Set Operation Visualization
function showSetOperationVisualization() {
    isSetOpRunning = true;
    
    const operationName = currentSetOpType === 'difference' ? 'Set Difference (A - B)' : 'Symmetric Difference';
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">${operationName}</h5>
        
        <div class="array-group">
            <div class="array-label">Array A</div>
            <div class="original-array-container" id="setArrayA"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Array B</div>
            <div class="original-array-container" id="setArrayB"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">${operationName} Result</div>
            <div class="transformed-array-container" id="setResultArray"></div>
        </div>
        
        <div class="set-operation-explanation">
            <p class="mb-2"><strong>Set Operation:</strong> ${getSetOperationExplanation()}</p>
            <p class="mb-0" id="setOpExplanation">Starting set operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="setOpStepsContainer">
            <h6 class="text-center">Set Operation Steps</h6>
            <div class="steps-container" id="setOpSteps"></div>
        </div>
        
        <div class="set-operation-result mt-3" id="setOpResult" style="display: none;">
            <h6 class="text-center">Final Result</h6>
            <div id="setOpResultContent"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSetOp" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display the input arrays
    renderArrayInContainer(setOpArrays[0], 'setArrayA');
    renderArrayInContainer(setOpArrays[1], 'setArrayB');
    renderArrayInContainer([], 'setResultArray');
    
    // Start set operation animation
    performSetOperationAnimation();
}

// NEW: Get Set Operation Explanation
function getSetOperationExplanation() {
    if (currentSetOpType === 'difference') {
        return 'A - B: Elements in A but not in B';
    } else {
        return '(A - B)  (B - A): Elements in either A or B but not in both';
    }
}

// NEW: Perform Set Operation Animation
function performSetOperationAnimation() {
    const arrayAContainer = document.getElementById('setArrayA');
    const arrayBContainer = document.getElementById('setArrayB');
    const resultContainer = document.getElementById('setResultArray');
    const explanation = document.getElementById('setOpExplanation');
    const stepsContainer = document.getElementById('setOpSteps');
    const resultDiv = document.getElementById('setOpResult');
    const resultContent = document.getElementById('setOpResultContent');
    const continueButton = document.getElementById('continueAfterSetOp');
    
    const arrayA = [...setOpArrays[0]];
    const arrayB = [...setOpArrays[1]];
    let resultArray = [];
    let step = 0;
    
    function performSetOpStep() {
        if (currentSetOpType === 'difference') {
            performDifferenceOperation();
        } else {
            performSymmetricDifferenceOperation();
        }
    }
    
    function performDifferenceOperation() {
        if (step === 0) {
            explanation.innerHTML = 'Step 1: Finding elements in Array A that are not in Array B';
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Initialize Set Difference operation (A - B)
                </div>
            `;
            step++;
            setTimeout(performDifferenceOperation, 1500);
            return;
        }
        
        if (step <= arrayA.length) {
            const currentIndex = step - 1;
            const currentElement = arrayA[currentIndex];
            
            explanation.innerHTML = `Step ${step + 1}: Checking if "${currentElement}" from Array A exists in Array B`;
            
            // Highlight current element in A
            const elementsA = arrayAContainer.querySelectorAll('.array-element');
            const currentElementA = elementsA[currentIndex].querySelector('.element-value');
            currentElementA.classList.add('set-operation-highlight');
            
            // Check if element exists in B
            const existsInB = arrayB.includes(currentElement);
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${!existsInB ? 'active' : ''}">
                    <strong>Step ${step + 1}:</strong> "${currentElement}" ${existsInB ? 'exists' : 'does not exist'} in Array B - ${existsInB ? 'EXCLUDE' : 'INCLUDE'}
                </div>
            `;
            
            setTimeout(() => {
                if (!existsInB) {
                    // Element doesn't exist in B - include in result
                    resultArray.push(currentElement);
                    renderArrayInContainer(resultArray, 'setResultArray');
                    
                    // Highlight as included
                    currentElementA.classList.remove('set-operation-highlight');
                    currentElementA.classList.add('set-operation-included');
                    
                    // Highlight in result
                    const resultElements = resultContainer.querySelectorAll('.array-element');
                    const newResultElement = resultElements[resultElements.length - 1].querySelector('.element-value');
                    newResultElement.classList.add('create', 'bounce');
                } else {
                    // Element exists in B - exclude from result
                    currentElementA.classList.remove('set-operation-highlight');
                    currentElementA.classList.add('set-operation-excluded');
                    
                    // Highlight corresponding element in B
                    const elementsB = arrayBContainer.querySelectorAll('.array-element');
                    const indexInB = arrayB.indexOf(currentElement);
                    if (indexInB !== -1) {
                        elementsB[indexInB].querySelector('.element-value').classList.add('set-operation-highlight');
                        setTimeout(() => {
                            elementsB[indexInB].querySelector('.element-value').classList.remove('set-operation-highlight');
                        }, 1000);
                    }
                }
                
                step++;
                performDifferenceOperation();
            }, 2000);
            
        } else {
            // Operation completed
            explanation.innerHTML = `<strong>Set Difference Completed!</strong> Found ${resultArray.length} elements in A but not in B`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> A - B = [${resultArray.join(', ')}]
                </div>
            `;
            
            // Show final result
            resultDiv.style.display = 'block';
            resultContent.innerHTML = `
                <p><strong>A - B:</strong> [${resultArray.join(', ')}]</p>
                <p><strong>B - A:</strong> [${arrayB.filter(x => !arrayA.includes(x)).join(', ')}]</p>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterSetOp();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSetOp);
        }
    }
    
    function performSymmetricDifferenceOperation() {
        if (step === 0) {
            explanation.innerHTML = 'Step 1: Calculating Symmetric Difference = (A - B)  (B - A)';
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Initialize Symmetric Difference operation
                </div>
            `;
            step++;
            setTimeout(performSymmetricDifferenceOperation, 1500);
            return;
        }
        
        if (step === 1) {
            // Calculate A - B
            explanation.innerHTML = 'Step 2: First, calculate A - B (elements in A but not in B)';
            
            const aMinusB = arrayA.filter(x => !arrayB.includes(x));
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 2:</strong> A - B = [${aMinusB.join(', ')}]
                </div>
            `;
            
            // Highlight A - B elements
            const elementsA = arrayAContainer.querySelectorAll('.array-element');
            arrayA.forEach((element, index) => {
                if (!arrayB.includes(element)) {
                    elementsA[index].querySelector('.element-value').classList.add('set-operation-included');
                }
            });
            
            step++;
            setTimeout(performSymmetricDifferenceOperation, 2000);
            return;
        }
        
        if (step === 2) {
            // Calculate B - A
            explanation.innerHTML = 'Step 3: Next, calculate B - A (elements in B but not in A)';
            
            const bMinusA = arrayB.filter(x => !arrayA.includes(x));
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 3:</strong> B - A = [${bMinusA.join(', ')}]
                </div>
            `;
            
            // Highlight B - A elements
            const elementsB = arrayBContainer.querySelectorAll('.array-element');
            arrayB.forEach((element, index) => {
                if (!arrayA.includes(element)) {
                    elementsB[index].querySelector('.element-value').classList.add('set-operation-included');
                }
            });
            
            step++;
            setTimeout(performSymmetricDifferenceOperation, 2000);
            return;
        }
        
        if (step === 3) {
            // Combine both differences
            explanation.innerHTML = 'Step 4: Combine A - B and B - A for Symmetric Difference';
            
            const aMinusB = arrayA.filter(x => !arrayB.includes(x));
            const bMinusA = arrayB.filter(x => !arrayA.includes(x));
            resultArray = [...aMinusB, ...bMinusA];
            
            renderArrayInContainer(resultArray, 'setResultArray');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 4:</strong> Symmetric Difference = (A - B)  (B - A) = [${resultArray.join(', ')}]
                </div>
            `;
            
            // Highlight result elements
            const resultElements = resultContainer.querySelectorAll('.array-element');
            resultElements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('create', 'bounce');
                }, index * 200);
            });
            
            step++;
            setTimeout(performSymmetricDifferenceOperation, 3000);
            return;
        }
        
        // Operation completed
        explanation.innerHTML = `<strong>Symmetric Difference Completed!</strong> Found ${resultArray.length} unique elements`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Final:</strong> A  B = [${resultArray.join(', ')}]
            </div>
        `;
        
        // Show final result
        resultDiv.style.display = 'block';
        resultContent.innerHTML = `
            <p><strong>A - B:</strong> [${arrayA.filter(x => !arrayB.includes(x)).join(', ')}]</p>
            <p><strong>B - A:</strong> [${arrayB.filter(x => !arrayA.includes(x)).join(', ')}]</p>
            <p><strong>A  B (Symmetric Difference):</strong> [${resultArray.join(', ')}]</p>
        `;
        
        continueButton.style.display = 'block';
        
        // Auto-return after 30 seconds
        setTimeout(() => {
            returnToOriginalAfterSetOp();
        }, 30000);
        
        continueButton.addEventListener('click', returnToOriginalAfterSetOp);
    }
    
    // Start set operation
    performSetOpStep();
}

// NEW: Return to Original after Set Operation
function returnToOriginalAfterSetOp() {
    // Reset to original array
    myArray = [...originalArrayBeforeSetOp];
    originalArrayBeforeSetOp = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isSetOpRunning = false;
    
    // Clear all set operation data
    setOpArrays = [];
    currentSetOpType = null;
    
    // Reset input groups
    setOperationsGroup.style.display = 'none';
    numArrays.value = '2';
    setArraysInputs.innerHTML = '';
    performSetOperationBtn.style.display = 'none';
    
    const operationName = currentSetOpType === 'difference' ? 'Set Difference' : 'Symmetric Difference';
    logOperation(`${operationName} completed - returned to original array`, 'info');
    showNotification(`Returned to original array after ${operationName.toLowerCase()} operation`, 'success');
}
// NEW: Check Subset Handler
function handleCheckSubsetComp() {
    if (isSubsetCompRunning) {
        showNotification('A subset check operation is already in progress', 'warning');
        return;
    }

    // Reset arrays
    subsetCompArrays = [];
    
    // Show input group
    subsetCompInputGroup.style.display = 'block';
    numArraysSubsetComp.focus();
    
    // Hide perform button initially
    performSubsetCompBtn.style.display = 'none';
    
    logOperation('Started subset comparison operation', 'info');
}

// NEW: Check Superset Handler
function handleCheckSupersetComp() {
    if (isSupersetCompRunning) {
        showNotification('A superset check operation is already in progress', 'warning');
        return;
    }

    // Reset arrays
    supersetCompArrays = [];
    
    // Show input group
    supersetCompInputGroup.style.display = 'block';
    numArraysSupersetComp.focus();
    
    // Hide perform button initially
    performSupersetCompBtn.style.display = 'none';
    
    logOperation('Started superset comparison operation', 'info');
}

// NEW: Confirm Number of Arrays for Subset
function handleConfirmNumArraysSubsetComp() {
    const numArrays = parseInt(numArraysSubsetComp.value);
    
    if (isNaN(numArrays) || numArrays < 2 || numArrays > 5) {
        showNotification('Please enter a valid number of arrays between 2 and 5', 'danger');
        numArraysSubsetComp.focus();
        return;
    }
    
    // Create input fields for each array
    subsetCompArraysInputs.innerHTML = '<h6>Enter Array Details:</h6>';
    for (let i = 0; i < numArrays; i++) {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'mb-3 subset-comp-container';
        arrayGroup.innerHTML = `
            <label class="form-label">Array ${i + 1} Details</label>
            <div class="input-group mb-2">
                <input type="number" class="form-control subset-comp-size" 
                       data-array-index="${i}" placeholder="Size of Array ${i + 1}" min="1" max="20">
                <button class="btn btn-glow confirm-subset-comp-size-btn" data-array-index="${i}">
                    <i class="fas fa-check me-2"></i>Set Size
                </button>
            </div>
            <div class="subset-comp-elements-inputs" id="subsetCompElementsInputs${i}"></div>
        `;
        subsetCompArraysInputs.appendChild(arrayGroup);
    }
    
    // Add event listeners for size confirmation buttons
    const sizeButtons = subsetCompArraysInputs.querySelectorAll('.confirm-subset-comp-size-btn');
    sizeButtons.forEach(btn => {
        btn.addEventListener('click', function() {
            const arrayIndex = parseInt(this.getAttribute('data-array-index'));
            handleConfirmSubsetCompSize(arrayIndex);
        });
    });
    
    // Add event listeners for size inputs
    const sizeInputs = subsetCompArraysInputs.querySelectorAll('.subset-comp-size');
    sizeInputs.forEach(input => {
        input.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                const arrayIndex = parseInt(this.getAttribute('data-array-index'));
                handleConfirmSubsetCompSize(arrayIndex);
            }
        });
    });
    
    showNotification(`Set up ${numArrays} arrays for subset comparison`, 'success');
}

// NEW: Confirm Number of Arrays for Superset
function handleConfirmNumArraysSupersetComp() {
    const numArrays = parseInt(numArraysSupersetComp.value);
    
    if (isNaN(numArrays) || numArrays < 2 || numArrays > 5) {
        showNotification('Please enter a valid number of arrays between 2 and 5', 'danger');
        numArraysSupersetComp.focus();
        return;
    }
    
    // Create input fields for each array
    supersetCompArraysInputs.innerHTML = '<h6>Enter Array Details:</h6>';
    for (let i = 0; i < numArrays; i++) {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'mb-3 superset-comp-container';
        arrayGroup.innerHTML = `
            <label class="form-label">Array ${i + 1} Details</label>
            <div class="input-group mb-2">
                <input type="number" class="form-control superset-comp-size" 
                       data-array-index="${i}" placeholder="Size of Array ${i + 1}" min="1" max="20">
                <button class="btn btn-glow confirm-superset-comp-size-btn" data-array-index="${i}">
                    <i class="fas fa-check me-2"></i>Set Size
                </button>
            </div>
            <div class="superset-comp-elements-inputs" id="supersetCompElementsInputs${i}"></div>
        `;
        supersetCompArraysInputs.appendChild(arrayGroup);
    }
    
    // Add event listeners for size confirmation buttons
    const sizeButtons = supersetCompArraysInputs.querySelectorAll('.confirm-superset-comp-size-btn');
    sizeButtons.forEach(btn => {
        btn.addEventListener('click', function() {
            const arrayIndex = parseInt(this.getAttribute('data-array-index'));
            handleConfirmSupersetCompSize(arrayIndex);
        });
    });
    
    // Add event listeners for size inputs
    const sizeInputs = supersetCompArraysInputs.querySelectorAll('.superset-comp-size');
    sizeInputs.forEach(input => {
        input.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                const arrayIndex = parseInt(this.getAttribute('data-array-index'));
                handleConfirmSupersetCompSize(arrayIndex);
            }
        });
    });
    
    showNotification(`Set up ${numArrays} arrays for superset comparison`, 'success');
}

// NEW: Confirm Subset Comparison Size
function handleConfirmSubsetCompSize(arrayIndex) {
    const sizeInput = document.querySelector(`.subset-comp-size[data-array-index="${arrayIndex}"]`);
    const size = parseInt(sizeInput.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification(`Please enter a valid size for Array ${arrayIndex + 1} between 1 and 20`, 'danger');
        sizeInput.focus();
        return;
    }
    
    // Create element input fields
    const elementsContainer = document.getElementById(`subsetCompElementsInputs${arrayIndex}`);
    elementsContainer.innerHTML = `<label class="form-label">Enter ${size} elements for Array ${arrayIndex + 1}:</label>`;
    
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="text" class="form-control subset-comp-element" 
                   data-array-index="${arrayIndex}" data-element-index="${i}" 
                   placeholder="Enter value">
        `;
        elementsContainer.appendChild(inputGroup);
    }
    
    // Add event listeners for element inputs
    const elementInputs = elementsContainer.querySelectorAll('.subset-comp-element');
    elementInputs.forEach(input => {
        input.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                // Auto-focus next input
                const nextInput = this.nextElementSibling;
                if (nextInput && nextInput.classList.contains('subset-comp-element')) {
                    nextInput.focus();
                }
            }
        });
    });
    
    showNotification(`Size ${size} set for Array ${arrayIndex + 1}. Please enter elements.`, 'success');
    
    // Check if all arrays have sizes set and show perform button
    checkAllSubsetCompSizesSet();
}

// NEW: Confirm Superset Comparison Size
function handleConfirmSupersetCompSize(arrayIndex) {
    const sizeInput = document.querySelector(`.superset-comp-size[data-array-index="${arrayIndex}"]`);
    const size = parseInt(sizeInput.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification(`Please enter a valid size for Array ${arrayIndex + 1} between 1 and 20`, 'danger');
        sizeInput.focus();
        return;
    }
    
    // Create element input fields
    const elementsContainer = document.getElementById(`supersetCompElementsInputs${arrayIndex}`);
    elementsContainer.innerHTML = `<label class="form-label">Enter ${size} elements for Array ${arrayIndex + 1}:</label>`;
    
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="text" class="form-control superset-comp-element" 
                   data-array-index="${arrayIndex}" data-element-index="${i}" 
                   placeholder="Enter value">
        `;
        elementsContainer.appendChild(inputGroup);
    }
    
    // Add event listeners for element inputs
    const elementInputs = elementsContainer.querySelectorAll('.superset-comp-element');
    elementInputs.forEach(input => {
        input.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                // Auto-focus next input
                const nextInput = this.nextElementSibling;
                if (nextInput && nextInput.classList.contains('superset-comp-element')) {
                    nextInput.focus();
                }
            }
        });
    });
    
    showNotification(`Size ${size} set for Array ${arrayIndex + 1}. Please enter elements.`, 'success');
    
    // Check if all arrays have sizes set and show perform button
    checkAllSupersetCompSizesSet();
}

// NEW: Check if all subset comparison sizes are set
function checkAllSubsetCompSizesSet() {
    const numArrays = parseInt(numArraysSubsetComp.value);
    let allSizesSet = true;
    
    for (let i = 0; i < numArrays; i++) {
        const elementsContainer = document.getElementById(`subsetCompElementsInputs${i}`);
        if (!elementsContainer || elementsContainer.innerHTML === '') {
            allSizesSet = false;
            break;
        }
    }
    
    if (allSizesSet) {
        performSubsetCompBtn.style.display = 'block';
    }
}

// NEW: Check if all superset comparison sizes are set
function checkAllSupersetCompSizesSet() {
    const numArrays = parseInt(numArraysSupersetComp.value);
    let allSizesSet = true;
    
    for (let i = 0; i < numArrays; i++) {
        const elementsContainer = document.getElementById(`supersetCompElementsInputs${i}`);
        if (!elementsContainer || elementsContainer.innerHTML === '') {
            allSizesSet = false;
            break;
        }
    }
    
    if (allSizesSet) {
        performSupersetCompBtn.style.display = 'block';
    }
}

// NEW: Perform Subset Check
function handlePerformSubsetComp() {
    const numArrays = parseInt(numArraysSubsetComp.value);
    subsetCompArrays = [];
    
    // Collect all arrays
    for (let i = 0; i < numArrays; i++) {
        const elementInputs = document.querySelectorAll(`.subset-comp-element[data-array-index="${i}"]`);
        const array = [];
        
        for (let j = 0; j < elementInputs.length; j++) {
            const value = elementInputs[j].value.trim();
            if (value === '') {
                showNotification(`Please enter all elements for Array ${i + 1}. Missing element at position ${j}`, 'danger');
                elementInputs[j].focus();
                return;
            }
            array.push(value);
        }
        
        subsetCompArrays.push(array);
    }
    
    // Store original array
    originalArrayForSubsetComp = [...myArray];
    
    // Hide input group
    subsetCompInputGroup.style.display = 'none';
    
    // Start subset comparison visualization
    showSubsetCompVisualization();
}

// NEW: Perform Superset Check
function handlePerformSupersetComp() {
    const numArrays = parseInt(numArraysSupersetComp.value);
    supersetCompArrays = [];
    
    // Collect all arrays
    for (let i = 0; i < numArrays; i++) {
        const elementInputs = document.querySelectorAll(`.superset-comp-element[data-array-index="${i}"]`);
        const array = [];
        
        for (let j = 0; j < elementInputs.length; j++) {
            const value = elementInputs[j].value.trim();
            if (value === '') {
                showNotification(`Please enter all elements for Array ${i + 1}. Missing element at position ${j}`, 'danger');
                elementInputs[j].focus();
                return;
            }
            array.push(value);
        }
        
        supersetCompArrays.push(array);
    }
    
    // Store original array
    originalArrayForSupersetComp = [...myArray];
    
    // Hide input group
    supersetCompInputGroup.style.display = 'none';
    
    // Start superset comparison visualization
    showSupersetCompVisualization();
}

// NEW: Cancel Subset Check
function handleCancelSubsetComp() {
    subsetCompInputGroup.style.display = 'none';
    numArraysSubsetComp.value = '2';
    subsetCompArraysInputs.innerHTML = '';
    performSubsetCompBtn.style.display = 'none';
    subsetCompArrays = [];
    
    logOperation('Cancelled subset comparison operation', 'info');
    showNotification('Subset comparison cancelled', 'info');
}

// NEW: Cancel Superset Check
function handleCancelSupersetComp() {
    supersetCompInputGroup.style.display = 'none';
    numArraysSupersetComp.value = '2';
    supersetCompArraysInputs.innerHTML = '';
    performSupersetCompBtn.style.display = 'none';
    supersetCompArrays = [];
    
    logOperation('Cancelled superset comparison operation', 'info');
    showNotification('Superset comparison cancelled', 'info');
}

// NEW: Show Subset Comparison Visualization
function showSubsetCompVisualization() {
    isSubsetCompRunning = true;
    
    const container = document.createElement('div');
    container.className = 'dual-operation-container';
    container.innerHTML = `
        <h5 class="text-center mb-3">Subset Comparison Operation</h5>
        
        <div id="subsetCompArraysDisplay" class="mb-4"></div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Subset Check:</strong> Checking if arrays are subsets of each other</p>
            <p class="mb-0" id="subsetCompExplanation">Starting subset comparison...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="subsetCompStepsContainer">
            <h6 class="text-center">Subset Comparison Steps</h6>
            <div class="steps-container" id="subsetCompSteps"></div>
        </div>
        
        <div id="subsetCompResults" class="mt-3"></div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSubsetComp">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(container);
    
    // Display all arrays
    displaySubsetCompArrays();
    
    // Start subset comparison animation
    performSubsetCompAnimation();
}

// NEW: Show Superset Comparison Visualization
function showSupersetCompVisualization() {
    isSupersetCompRunning = true;
    
    const container = document.createElement('div');
    container.className = 'dual-operation-container';
    container.innerHTML = `
        <h5 class="text-center mb-3">Superset Comparison Operation</h5>
        
        <div id="supersetCompArraysDisplay" class="mb-4"></div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Superset Check:</strong> Checking if arrays are supersets of each other</p>
            <p class="mb-0" id="supersetCompExplanation">Starting superset comparison...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="supersetCompStepsContainer">
            <h6 class="text-center">Superset Comparison Steps</h6>
            <div class="steps-container" id="supersetCompSteps"></div>
        </div>
        
        <div id="supersetCompResults" class="mt-3"></div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSupersetComp">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(container);
    
    // Display all arrays
    displaySupersetCompArrays();
    
    // Start superset comparison animation
    performSupersetCompAnimation();
}

// NEW: Display Subset Comparison Arrays
function displaySubsetCompArrays() {
    const displayContainer = document.getElementById('subsetCompArraysDisplay');
    displayContainer.innerHTML = '';
    
    subsetCompArrays.forEach((array, index) => {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'array-group mb-4';
        arrayGroup.innerHTML = `
            <div class="array-label">Array ${index + 1} (Size: ${array.length})</div>
            <div class="original-array-container" id="subsetCompArray${index}"></div>
        `;
        displayContainer.appendChild(arrayGroup);
        renderArrayInContainer(array, `subsetCompArray${index}`);
    });
}

// NEW: Display Superset Comparison Arrays
function displaySupersetCompArrays() {
    const displayContainer = document.getElementById('supersetCompArraysDisplay');
    displayContainer.innerHTML = '';
    
    supersetCompArrays.forEach((array, index) => {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'array-group mb-4';
        arrayGroup.innerHTML = `
            <div class="array-label">Array ${index + 1} (Size: ${array.length})</div>
            <div class="original-array-container" id="supersetCompArray${index}"></div>
        `;
        displayContainer.appendChild(arrayGroup);
        renderArrayInContainer(array, `supersetCompArray${index}`);
    });
}

// NEW: Perform Subset Comparison Animation
function performSubsetCompAnimation() {
    const explanation = document.getElementById('subsetCompExplanation');
    const stepsContainer = document.getElementById('subsetCompSteps');
    const resultsContainer = document.getElementById('subsetCompResults');
    const continueButton = document.getElementById('continueAfterSubsetComp');
    
    let currentComparison = 0;
    const totalComparisons = subsetCompArrays.length * (subsetCompArrays.length - 1);
    
    function performComparisonStep() {
        if (currentComparison >= totalComparisons) {
            // All comparisons completed
            explanation.innerHTML = '<strong>Subset Comparison Completed!</strong>';
            
            // Show final results
            displaySubsetCompFinalResults(resultsContainer);
            
            continueButton.style.display = 'block';
            continueButton.addEventListener('click', returnToOriginalAfterSubsetComp);
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterSubsetComp();
            }, 10000);
            
            return;
        }
        
        const i = Math.floor(currentComparison / (subsetCompArrays.length - 1));
        const j = currentComparison % (subsetCompArrays.length - 1);
        const actualJ = j >= i ? j + 1 : j;
        
        if (i !== actualJ) {
            explanation.innerHTML = `Checking if Array ${i + 1} is subset of Array ${actualJ + 1}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${currentComparison + 1}:</strong> Checking if Array ${i + 1}  Array ${actualJ + 1}
                </div>
            `;
            
            // Perform the subset check with animation
            checkSubsetWithAnimation(i, actualJ, stepsContainer, () => {
                currentComparison++;
                performComparisonStep();
            });
        } else {
            currentComparison++;
            performComparisonStep();
        }
    }
    
    // Start comparison process
    performComparisonStep();
}

// NEW: Perform Superset Comparison Animation
function performSupersetCompAnimation() {
    const explanation = document.getElementById('supersetCompExplanation');
    const stepsContainer = document.getElementById('supersetCompSteps');
    const resultsContainer = document.getElementById('supersetCompResults');
    const continueButton = document.getElementById('continueAfterSupersetComp');
    
    let currentComparison = 0;
    const totalComparisons = supersetCompArrays.length * (supersetCompArrays.length - 1);
    
    function performComparisonStep() {
        if (currentComparison >= totalComparisons) {
            // All comparisons completed
            explanation.innerHTML = '<strong>Superset Comparison Completed!</strong>';
            
            // Show final results
            displaySupersetCompFinalResults(resultsContainer);
            
            continueButton.style.display = 'block';
            continueButton.addEventListener('click', returnToOriginalAfterSupersetComp);
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterSupersetComp();
            }, 10000);
            
            return;
        }
        
        const i = Math.floor(currentComparison / (supersetCompArrays.length - 1));
        const j = currentComparison % (supersetCompArrays.length - 1);
        const actualJ = j >= i ? j + 1 : j;
        
        if (i !== actualJ) {
            explanation.innerHTML = `Checking if Array ${i + 1} is superset of Array ${actualJ + 1}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${currentComparison + 1}:</strong> Checking if Array ${i + 1}  Array ${actualJ + 1}
                </div>
            `;
            
            // Perform the superset check with animation
            checkSupersetWithAnimation(i, actualJ, stepsContainer, () => {
                currentComparison++;
                performComparisonStep();
            });
        } else {
            currentComparison++;
            performComparisonStep();
        }
    }
    
    // Start comparison process
    performComparisonStep();
}

// NEW: Check Subset with Animation
function checkSubsetWithAnimation(i, j, stepsContainer, callback) {
    const arr1 = subsetCompArrays[i];
    const arr2 = subsetCompArrays[j];
    let allElementsFound = true;
    let currentElement = 0;
    
    function checkNextElement() {
        if (currentElement >= arr1.length) {
            // All elements checked
            const result = allElementsFound;
            const message = result ? 
                `<span class="text-success">Yes, it is true! Array ${i + 1} is subset of Array ${j + 1}</span>` :
                `<span class="text-danger">No, it is false! Array ${i + 1} is not subset of Array ${j + 1}</span>`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${result ? 'active' : ''}">
                    <strong>Result:</strong> ${message}
                </div>
            `;
            
            callback();
            return;
        }
        
        const element = arr1[currentElement];
        let found = false;
        
        // Highlight current element in arr1
        const arr1Container = document.getElementById(`subsetCompArray${i}`);
        const arr1Elements = arr1Container.querySelectorAll('.array-element');
        arr1Elements[currentElement].querySelector('.element-value').classList.add('subset-comp-element-match');
        
        // Search for element in arr2
        searchElementInArray(j, element, (foundIndex) => {
            if (foundIndex !== -1) {
                found = true;
            } else {
                allElementsFound = false;
                arr1Elements[currentElement].querySelector('.element-value').classList.remove('subset-comp-element-match');
                arr1Elements[currentElement].querySelector('.element-value').classList.add('subset-comp-element-not-found');
            }
            
            currentElement++;
            setTimeout(checkNextElement, 1000);
        });
    }
    
    // Start checking elements
    checkNextElement();
}

// NEW: Check Superset with Animation
function checkSupersetWithAnimation(i, j, stepsContainer, callback) {
    const arr1 = supersetCompArrays[i];
    const arr2 = supersetCompArrays[j];
    let allElementsFound = true;
    let currentElement = 0;
    
    function checkNextElement() {
        if (currentElement >= arr2.length) {
            // All elements checked
            const result = allElementsFound;
            const message = result ? 
                `<span class="text-success">Yes, it is true! Array ${i + 1} is superset of Array ${j + 1}</span>` :
                `<span class="text-danger">No, it is false! Array ${i + 1} is not superset of Array ${j + 1}</span>`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${result ? 'active' : ''}">
                    <strong>Result:</strong> ${message}
                </div>
            `;
            
            callback();
            return;
        }
        
        const element = arr2[currentElement];
        let found = false;
        
        // Highlight current element in arr2
        const arr2Container = document.getElementById(`supersetCompArray${j}`);
        const arr2Elements = arr2Container.querySelectorAll('.array-element');
        arr2Elements[currentElement].querySelector('.element-value').classList.add('superset-comp-element-match');
        
        // Search for element in arr1
        searchElementInSupersetArray(i, element, (foundIndex) => {
            if (foundIndex !== -1) {
                found = true;
            } else {
                allElementsFound = false;
                arr2Elements[currentElement].querySelector('.element-value').classList.remove('superset-comp-element-match');
                arr2Elements[currentElement].querySelector('.element-value').classList.add('subset-comp-element-not-found');
            }
            
            currentElement++;
            setTimeout(checkNextElement, 1000);
        });
    }
    
    // Start checking elements
    checkNextElement();
}

// NEW: Search Element in Array for Subset
function searchElementInArray(arrayIndex, element, callback) {
    const arr = subsetCompArrays[arrayIndex];
    const container = document.getElementById(`subsetCompArray${arrayIndex}`);
    const elements = container.querySelectorAll('.array-element');
    let currentIndex = 0;
    
    function searchNext() {
        if (currentIndex >= arr.length) {
            callback(-1); // Element not found
            return;
        }
        
        // Highlight current element being checked
        elements[currentIndex].querySelector('.element-value').classList.add('search');
        
        setTimeout(() => {
            if (arr[currentIndex] === element) {
                // Element found
                elements[currentIndex].querySelector('.element-value').classList.remove('search');
                elements[currentIndex].querySelector('.element-value').classList.add('subset-comp-element-match');
                callback(currentIndex);
            } else {
                // Element not found at this position
                elements[currentIndex].querySelector('.element-value').classList.remove('search');
                currentIndex++;
                searchNext();
            }
        }, 500);
    }
    
    searchNext();
}

// NEW: Search Element in Array for Superset
function searchElementInSupersetArray(arrayIndex, element, callback) {
    const arr = supersetCompArrays[arrayIndex];
    const container = document.getElementById(`supersetCompArray${arrayIndex}`);
    const elements = container.querySelectorAll('.array-element');
    let currentIndex = 0;
    
    function searchNext() {
        if (currentIndex >= arr.length) {
            callback(-1); // Element not found
            return;
        }
        
        // Highlight current element being checked
        elements[currentIndex].querySelector('.element-value').classList.add('search');
        
        setTimeout(() => {
            if (arr[currentIndex] === element) {
                // Element found
                elements[currentIndex].querySelector('.element-value').classList.remove('search');
                elements[currentIndex].querySelector('.element-value').classList.add('superset-comp-element-match');
                callback(currentIndex);
            } else {
                // Element not found at this position
                elements[currentIndex].querySelector('.element-value').classList.remove('search');
                currentIndex++;
                searchNext();
            }
        }, 500);
    }
    
    searchNext();
}

// NEW: Display Subset Comparison Final Results
function displaySubsetCompFinalResults(container) {
    let resultsHTML = '<h6 class="text-center">Subset Comparison Results</h6>';
    
    for (let i = 0; i < subsetCompArrays.length; i++) {
        for (let j = 0; j < subsetCompArrays.length; j++) {
            if (i !== j) {
                const isSubset = isArraySubset(subsetCompArrays[i], subsetCompArrays[j]);
                const resultClass = isSubset ? 'text-success' : 'text-danger';
                const resultText = isSubset ? 'Yes' : 'No';
                resultsHTML += `
                    <div class="algorithm-step ${isSubset ? 'active' : ''}">
                        <strong>Array ${i + 1}  Array ${j + 1}:</strong> 
                        <span class="${resultClass}">${resultText}</span>
                    </div>
                `;
            }
        }
    }
    
    container.innerHTML = resultsHTML;
}

// NEW: Display Superset Comparison Final Results
function displaySupersetCompFinalResults(container) {
    let resultsHTML = '<h6 class="text-center">Superset Comparison Results</h6>';
    
    for (let i = 0; i < supersetCompArrays.length; i++) {
        for (let j = 0; j < supersetCompArrays.length; j++) {
            if (i !== j) {
                const isSuperset = isArraySubset(supersetCompArrays[j], supersetCompArrays[i]); // A is superset of B if B is subset of A
                const resultClass = isSuperset ? 'text-success' : 'text-danger';
                const resultText = isSuperset ? 'Yes' : 'No';
                resultsHTML += `
                    <div class="algorithm-step ${isSuperset ? 'active' : ''}">
                        <strong>Array ${i + 1}  Array ${j + 1}:</strong> 
                        <span class="${resultClass}">${resultText}</span>
                    </div>
                `;
            }
        }
    }
    
    container.innerHTML = resultsHTML;
}

// NEW: Utility function to check if array is subset
function isArraySubset(arr1, arr2) {
    // Create copies to avoid modifying original arrays
    const copyArr2 = [...arr2];
    
    for (let element of arr1) {
        const index = copyArr2.indexOf(element);
        if (index === -1) {
            return false;
        }
        // Remove the found element to handle duplicates
        copyArr2.splice(index, 1);
    }
    return true;
}

// NEW: Return to Original after Subset Comparison
function returnToOriginalAfterSubsetComp() {
    // Reset to original array
    myArray = [...originalArrayForSubsetComp];
    originalArrayForSubsetComp = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isSubsetCompRunning = false;
    
    // Clear all subset comparison data
    subsetCompArrays = [];
    
    logOperation('Subset comparison completed - returned to original array', 'info');
    showNotification('Returned to original array after subset comparison', 'success');
}

// NEW: Return to Original after Superset Comparison
function returnToOriginalAfterSupersetComp() {
    // Reset to original array
    myArray = [...originalArrayForSupersetComp];
    originalArrayForSupersetComp = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isSupersetCompRunning = false;
    
    // Clear all superset comparison data
    supersetCompArrays = [];
    
    logOperation('Superset comparison completed - returned to original array', 'info');
    showNotification('Returned to original array after superset comparison', 'success');
}
// NEW: Generate Memory Address
function generateMemoryAddress() {
    // Generate a realistic-looking memory address
    const prefix = '0x';
    const address = Math.floor(Math.random() * 0xFFFFFFFF).toString(16).toUpperCase().padStart(8, '0');
    return prefix + address;
}

// NEW: Update Memory Address Display
function updateMemoryAddress() {
    if (myArray.length === 0) {
        memoryAddress.textContent = '-';
        currentMemoryAddress = '';
        return;
    }
    
    // Generate or retrieve memory address for current array
    const arrayKey = myArray.join(',');
    if (!memoryAddresses.has(arrayKey)) {
        memoryAddresses.set(arrayKey, generateMemoryAddress());
    }
    
    currentMemoryAddress = memoryAddresses.get(arrayKey);
    memoryAddress.textContent = currentMemoryAddress;
}

// NEW: Show Memory Address Details
function showMemoryAddressDetails() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    const detailsContainer = document.createElement('div');
    detailsContainer.className = 'memory-address-details';
    detailsContainer.innerHTML = `
        <h5 class="text-center mb-3">Memory Address Details</h5>
        
        <div class="stats-card mb-3">
            <div>Base Memory Address</div>
            <div class="stats-value">${currentMemoryAddress}</div>
        </div>
        
        <div class="memory-address-table-container">
            <table class="memory-address-table">
                <thead>
                    <tr>
                        <th>Index</th>
                        <th>Element</th>
                        <th>Memory Address</th>
                        <th>Offset</th>
                    </tr>
                </thead>
                <tbody id="memoryAddressTableBody">
                    <!-- Memory addresses will be populated here -->
                </tbody>
            </table>
        </div>
        
        <div class="algorithm-explanation mt-3">
            <h6>Memory Addressing Explanation</h6>
            <p>Each array element is stored in consecutive memory locations:</p>
            <div class="code-snippet">
                Base Address: ${currentMemoryAddress}<br>
                Element Size: 4 bytes (typical for integers)<br>
                Address Calculation: Base + (Index  Element Size)
            </div>
        </div>
        
        <div class="d-grid gap-2 mt-3">
            <button class="btn btn-glow" id="goBackToArrayBtn">
                <i class="fas fa-arrow-left me-2"></i>Go Back to Original Array
            </button>
        </div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(detailsContainer);
    
    // Populate memory address table
    populateMemoryAddressTable();
    
    // Add go back button event listener
    document.getElementById('goBackToArrayBtn').addEventListener('click', () => {
        renderArray();
        updateStats();
    });
}

// NEW: Populate Memory Address Table
function populateMemoryAddressTable() {
    const tableBody = document.getElementById('memoryAddressTableBody');
    tableBody.innerHTML = '';
    
    const baseAddress = parseInt(currentMemoryAddress, 16);
    const elementSize = 4; // 4 bytes per element
    
    myArray.forEach((element, index) => {
        const offset = index * elementSize;
        const elementAddress = '0x' + (baseAddress + offset).toString(16).toUpperCase().padStart(8, '0');
        
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${index}</td>
            <td>${element}</td>
            <td>${elementAddress}</td>
            <td>+${offset} bytes</td>
        `;
        tableBody.appendChild(row);
    });
}

// NEW: Highlight Memory Address in Array

// NEW: Highlight Memory Address with Timeout Display
function highlightMemoryAddressWithTimeout(index) {
    const elements = document.querySelectorAll('.array-element');
    if (index >= 0 && index < elements.length) {
        // Remove previous highlights and memory address displays
        elements.forEach(el => {
            el.querySelector('.element-value').classList.remove('memory-address-highlight');
            // Remove any existing memory address display
            const existingDisplay = el.querySelector('.memory-display-temp');
            if (existingDisplay) {
                existingDisplay.remove();
            }
        });
        
        // Highlight current element
        const element = elements[index];
        const elementValue = element.querySelector('.element-value');
        elementValue.classList.add('memory-address-highlight');
        
        // Calculate memory address
        const baseAddress = parseInt(currentMemoryAddress, 16);
        const elementAddress = '0x' + (baseAddress + (index * 4)).toString(16).toUpperCase().padStart(8, '0');
        
        // Create memory address display below the element
        const memoryDisplay = document.createElement('div');
        memoryDisplay.className = 'memory-display-temp';
        memoryDisplay.innerHTML = `
            <div class="memory-address-popup">
                <div class="memory-address-title">Memory Address:</div>
                <div class="memory-address-value">${elementAddress}</div>
                <div class="memory-address-offset">Offset: +${index * 4} bytes</div>
                <div class="memory-address-timer">
                    <div class="progress">
                        <div class="progress-bar bg-success" role="progressbar" style="width: 100%"></div>
                    </div>
                    <small class="text-muted">Disappearing in <span class="timer-count">10</span>s</small>
                </div>
            </div>
        `;
        
        // Insert after the array element
        element.parentNode.insertBefore(memoryDisplay, element.nextSibling);
        
        // Start countdown timer
        let countdown = 10;
        const timerElement = memoryDisplay.querySelector('.timer-count');
        const progressBar = memoryDisplay.querySelector('.progress-bar');
        
        const timerInterval = setInterval(() => {
            countdown--;
            timerElement.textContent = countdown;
            progressBar.style.width = `${(countdown / 10) * 100}%`;
            
            if (countdown <= 0) {
                clearInterval(timerInterval);
            }
        }, 1000);
        
        // Set timeout to remove highlight and display after 10 seconds
        setTimeout(() => {
            // Remove highlight
            elementValue.classList.remove('memory-address-highlight');
            
            // Fade out animation for memory display
            memoryDisplay.style.opacity = '0';
            memoryDisplay.style.transform = 'translateY(-10px)';
            memoryDisplay.style.transition = 'all 0.3s ease';
            
            // Remove after animation completes
            setTimeout(() => {
                if (memoryDisplay && memoryDisplay.parentNode) {
                    memoryDisplay.parentNode.removeChild(memoryDisplay);
                }
            }, 300);
            
            // Clear interval just in case
            clearInterval(timerInterval);
            
        }, 10000);
        
        // Also update search results
        searchResults.innerHTML = `
            <p class="mb-1 text-success"><strong>Memory Address Found</strong></p>
            <p class="mb-1">Element: "${myArray[index]}" at index ${index}</p>
            <p class="mb-1">Memory Address: ${elementAddress}</p>
            <p class="mb-0">Offset: +${index * 4} bytes from base ${currentMemoryAddress}</p>
        `;
    }
}
// Add this CSS to your existing styles
const memoryDisplayStyles = document.createElement('style');
memoryDisplayStyles.textContent = `
    .memory-display-temp {
        margin-top: 5px;
        margin-bottom: 15px;
        animation: slideDown 0.3s ease;
    }
    
    .memory-address-popup {
        background: linear-gradient(135deg, #e8f5e9, #c8e6c9);
        border: 1px solid #4caf50;
        border-radius: 8px;
        padding: 12px;
        box-shadow: 0 4px 12px rgba(76, 175, 80, 0.2);
    }
    
    .memory-address-title {
        font-size: 12px;
        color: #2e7d32;
        font-weight: bold;
        margin-bottom: 4px;
    }
    
    .memory-address-value {
        font-family: 'Courier New', monospace;
        font-size: 14px;
        font-weight: bold;
        color: #1b5e20;
        background: rgba(255, 255, 255, 0.7);
        padding: 4px 8px;
        border-radius: 4px;
        margin-bottom: 4px;
    }
    
    .memory-address-offset {
        font-size: 11px;
        color: #388e3c;
        margin-bottom: 8px;
    }
    
    .memory-address-timer .progress {
        height: 5px;
        margin-bottom: 4px;
    }
    
    .memory-address-timer small {
        font-size: 10px;
        display: block;
        text-align: center;
    }
    
    .timer-count {
        font-weight: bold;
        color: #d32f2f;
    }
    
    @keyframes slideDown {
        from {
            opacity: 0;
            transform: translateY(-20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    .memory-address-highlight {
        box-shadow: 0 0 0 3px #4caf50 !important;
        border-color: #2e7d32 !important;
        transform: scale(1.05);
        transition: all 0.3s ease;
        position: relative;
        z-index: 10;
    }
`;
document.head.appendChild(memoryDisplayStyles);
// NEW: Add Memory Address Button to UI
function addMemoryAddressButton() {
    // Add button to Read tab
    const readTab = document.getElementById('read');
    const memoryButton = document.createElement('div');
    memoryButton.className = 'mb-3';
    memoryButton.innerHTML = `
        <label class="form-label">Memory Address Operations</label>
        <div class="input-group mb-2">
            <button class="btn btn-glow" id="showMemoryDetailsBtn">
                <i class="fas fa-memory me-2"></i>Show Memory Addresses
            </button>
        </div>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="memoryIndex" placeholder="Index to check memory" min="0">
            <button class="btn btn-glow" id="checkMemoryAddressBtn">
                <i class="fas fa-search me-2"></i>Check Memory Address
            </button>
        </div>
    `;
    
    // Insert after existing content in Read tab
    const existingContent = readTab.querySelector('.mb-3:last-child');
    existingContent.parentNode.insertBefore(memoryButton, existingContent.nextSibling);
    
    // Add event listeners
    document.getElementById('showMemoryDetailsBtn').addEventListener('click', showMemoryAddressDetails);
    document.getElementById('checkMemoryAddressBtn').addEventListener('click', handleCheckMemoryAddress);
    
    // Add Enter key support
    document.getElementById('memoryIndex').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') handleCheckMemoryAddress();
    });
}
// NEW: Handle Check Memory Address
function handleCheckMemoryAddress() {
    const index = parseInt(document.getElementById('memoryIndex').value);
    
    if (isNaN(index) || index < 0 || index >= myArray.length) {
        showNotification(`Please enter a valid index between 0 and ${myArray.length - 1}`, 'danger');
        document.getElementById('memoryIndex').focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Highlight and show memory address below the element
    highlightMemoryAddressWithTimeout(index);
    logOperation(`Checked memory address for element at index ${index}`, 'info');
    
    // Clear the input field after operation
    document.getElementById('memoryIndex').value = '';
}


// Update the updateStats function to include memory address
function updateStats() {
    arrayLength.textContent = myArray.length;
    firstElement.textContent = myArray.length > 0 ? myArray[0] : '-';
    lastElement.textContent = myArray.length > 0 ? myArray[myArray.length - 1] : '-';
    totalOperations.textContent = operationCount;
    
    // Calculate sum and product
    let sum = 0;
    let product = 1;
    let allNumbers = true;
    
    myArray.forEach(element => {
        const num = parseFloat(element);
        if (!isNaN(num)) {
            sum += num;
            product *= num;
        } else {
            allNumbers = false;
        }
    });
    
    if (allNumbers && myArray.length > 0) {
        sumElements.textContent = sum;
        productElements.textContent = product;
    } else {
        sumElements.textContent = 'N/A';
        productElements.textContent = 'N/A';
    }
    
    // Update memory address
    updateMemoryAddress();
}
// Initialize memory address system
function initializeMemorySystem() {
    addMemoryAddressButton();
    updateMemoryAddress();
}
// Call this after DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    // ... existing initialization code ...
    initializeMemorySystem();
});   
// NEW: Find First Element > x or Last Element < x Handler
function handleFindComparison(type) {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isComparisonRunning) {
        showNotification('A comparison operation is already in progress', 'warning');
        return;
    }
    
    // Get the x value based on the type
    const xInput = type === 'greater' ? comparisonValue.value.trim() : comparisonValueLess.value.trim();
    
    if (xInput === '') {
        showNotification(`Please enter a value for x`, 'danger');
        if (type === 'greater') {
            comparisonValue.focus();
        } else {
            comparisonValueLess.focus();
        }
        return;
    }
    
    // Try to convert to number, but keep as string if not numeric
    let x;
    const isNumeric = !isNaN(parseFloat(xInput)) && isFinite(xInput);
    if (isNumeric) {
        x = parseFloat(xInput);
    } else {
        x = xInput;
    }
    
    // Store original array
    originalArrayForComparison = [...myArray];
    
    // Perform comparison search
    performComparisonSearch(type, x, isNumeric);
}

// NEW: Perform Comparison Search with Animation
function performComparisonSearch(type, x, isNumeric) {
    isComparisonRunning = true;
    
    const operationName = type === 'greater' ? 'First Element > x' : 'Last Element < x';
    const comparisonSymbol = type === 'greater' ? '>' : '<';
    
    // Create visualization container
    const visualContainer = document.createElement('div');
    visualContainer.className = 'dual-operation-container';
    visualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find ${operationName} (${comparisonSymbol} ${x})</h5>
        
        <div class="array-group">
            <div class="array-label">Searching Array</div>
            <div class="original-array-container" id="comparisonArray"></div>
        </div>
        
        <div class="comparison-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Finding ${type === 'greater' ? 'first element greater than' : 'last element less than'} ${x}</p>
            <p class="mb-0" id="comparisonExplanation">Starting search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="comparisonStepsContainer">
            <h6 class="text-center">Search Steps</h6>
            <div class="steps-container" id="comparisonSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Result</div>
            <div class="stats-value" id="comparisonResult">Searching...</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterComparison" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(visualContainer);
    
    renderArrayInContainer(originalArrayForComparison, 'comparisonArray');
    
    executeComparisonSearch(type, x, isNumeric);
}

// NEW: Execute Comparison Search Algorithm
function executeComparisonSearch(type, x, isNumeric) {
    const arrayContainer = document.getElementById('comparisonArray');
    const explanation = document.getElementById('comparisonExplanation');
    const stepsContainer = document.getElementById('comparisonSteps');
    const resultElement = document.getElementById('comparisonResult');
    const continueButton = document.getElementById('continueAfterComparison');
    
    const arr = [...originalArrayForComparison];
    let foundIndex = -1;
    let foundValue = null;
    let currentStep = 0;
    
    function executeComparisonStep(i) {
        if (type === 'greater') {
            // Find first element > x
            if (i >= arr.length) {
                // Search completed - not found
                explanation.innerHTML = `<strong>Search Completed!</strong> No element found that is greater than ${x}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> No element greater than ${x} found in the array
                    </div>
                `;
                
                resultElement.innerHTML = `<span class="text-danger">Not Found</span>`;
                resultElement.classList.add('text-danger');
                
                // Highlight all elements as checked but not found
                const elements = arrayContainer.querySelectorAll('.array-element');
                elements.forEach(el => {
                    el.querySelector('.element-value').classList.add('comparison-checked');
                });
                
                continueButton.style.display = 'block';
                continueButton.addEventListener('click', returnToOriginalAfterComparison);
                
                // Auto-return after 5 seconds
                setTimeout(() => {
                    returnToOriginalAfterComparison();
                }, 5000);
                
                return;
            }
            
            currentStep++;
            explanation.innerHTML = `Step ${currentStep}: Checking element at index ${i} = ${arr[i]}`;
            
            // Highlight current element
            const elements = arrayContainer.querySelectorAll('.array-element');
            const currentElement = elements[i].querySelector('.element-value');
            currentElement.classList.add('comparison-current');
            
            // Compare values
            let comparisonResult;
            if (isNumeric) {
                const currentVal = parseFloat(arr[i]);
                comparisonResult = currentVal > x;
            } else {
                comparisonResult = arr[i] > x;
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${comparisonResult ? 'active' : ''}">
                    <strong>Step ${currentStep}:</strong> Compare ${arr[i]} ${comparisonResult ? '>' : ''} ${x} - 
                    ${comparisonResult ? 'FOUND!' : 'Continue searching...'}
                </div>
            `;
            
            setTimeout(() => {
                if (comparisonResult) {
                    // Element found
                    foundIndex = i;
                    foundValue = arr[i];
                    
                    explanation.innerHTML = `<strong>Element Found!</strong> First element greater than ${x} is at index ${i}: ${arr[i]}`;
                    
                    // Highlight found element
                    currentElement.classList.remove('comparison-current');
                    currentElement.classList.add('comparison-found');
                    
                    // Highlight previous checked elements
                    for (let j = 0; j < i; j++) {
                        elements[j].querySelector('.element-value').classList.add('comparison-checked');
                    }
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Success:</strong> Found ${arr[i]} at index ${i} (first element > ${x})
                        </div>
                    `;
                    
                    resultElement.innerHTML = `Found: ${arr[i]} at index ${i}`;
                    resultElement.classList.add('text-success');
                    
                    continueButton.style.display = 'block';
                    continueButton.addEventListener('click', returnToOriginalAfterComparison);
                    
                    // Auto-return after 5 seconds
                    setTimeout(() => {
                        returnToOriginalAfterComparison();
                    }, 5000);
                    
                } else {
                    // Continue searching
                    currentElement.classList.remove('comparison-current');
                    currentElement.classList.add('comparison-checked');
                    
                    // Move to next element
                    executeComparisonStep(i + 1);
                }
            }, 1500);
            
        } else {
            // Find last element < x
            if (i < 0) {
                // Search completed - not found
                explanation.innerHTML = `<strong>Search Completed!</strong> No element found that is less than ${x}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> No element less than ${x} found in the array
                    </div>
                `;
                
                resultElement.innerHTML = `<span class="text-danger">Not Found</span>`;
                resultElement.classList.add('text-danger');
                
                // Highlight all elements as checked but not found
                const elements = arrayContainer.querySelectorAll('.array-element');
                elements.forEach(el => {
                    el.querySelector('.element-value').classList.add('comparison-checked');
                });
                
                continueButton.style.display = 'block';
                continueButton.addEventListener('click', returnToOriginalAfterComparison);
                
                // Auto-return after 5 seconds
                setTimeout(() => {
                    returnToOriginalAfterComparison();
                }, 5000);
                
                return;
            }
            
            currentStep++;
            explanation.innerHTML = `Step ${currentStep}: Checking element at index ${i} = ${arr[i]}`;
            
            // Highlight current element
            const elements = arrayContainer.querySelectorAll('.array-element');
            const currentElement = elements[i].querySelector('.element-value');
            currentElement.classList.add('comparison-current');
            
            // Compare values
            let comparisonResult;
            if (isNumeric) {
                const currentVal = parseFloat(arr[i]);
                comparisonResult = currentVal < x;
            } else {
                comparisonResult = arr[i] < x;
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${comparisonResult ? 'active' : ''}">
                    <strong>Step ${currentStep}:</strong> Compare ${arr[i]} ${comparisonResult ? '<' : ''} ${x} - 
                    ${comparisonResult ? 'FOUND!' : 'Continue searching...'}
                </div>
            `;
            
            setTimeout(() => {
                if (comparisonResult) {
                    // Element found
                    foundIndex = i;
                    foundValue = arr[i];
                    
                    explanation.innerHTML = `<strong>Element Found!</strong> Last element less than ${x} is at index ${i}: ${arr[i]}`;
                    
                    // Highlight found element
                    currentElement.classList.remove('comparison-current');
                    currentElement.classList.add('comparison-found');
                    
                    // Highlight remaining checked elements
                    for (let j = arr.length - 1; j > i; j--) {
                        elements[j].querySelector('.element-value').classList.add('comparison-checked');
                    }
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Success:</strong> Found ${arr[i]} at index ${i} (last element < ${x})
                        </div>
                    `;
                    
                    resultElement.innerHTML = `Found: ${arr[i]} at index ${i}`;
                    resultElement.classList.add('text-success');
                    
                    continueButton.style.display = 'block';
                    continueButton.addEventListener('click', returnToOriginalAfterComparison);
                    
                    // Auto-return after 5 seconds
                    setTimeout(() => {
                        returnToOriginalAfterComparison();
                    }, 5000);
                    
                } else {
                    // Continue searching
                    currentElement.classList.remove('comparison-current');
                    currentElement.classList.add('comparison-checked');
                    
                    // Move to previous element
                    executeComparisonStep(i - 1);
                }
            }, 1500);
        }
    }
    
    // Start search from appropriate end based on type
    if (type === 'greater') {
        // Start from beginning for first element > x
        executeComparisonStep(0);
    } else {
        // Start from end for last element < x
        executeComparisonStep(arr.length - 1);
    }
}

// NEW: Return to Original after Comparison Search
function returnToOriginalAfterComparison() {
    // Reset to original array
    myArray = [...originalArrayForComparison];
    originalArrayForComparison = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isComparisonRunning = false;
    
    // Clear inputs
    comparisonValue.value = '';
    comparisonValueLess.value = '';
    
    logOperation('Comparison search completed - returned to original array', 'info');
    showNotification('Returned to original array after comparison search', 'success');
}
// NEW: Handle Statistical Operation
function handleStatisticalOperation(operation) {
    if (isStatisticalOperationRunning) {
        showNotification('A statistical operation is already in progress', 'warning');
        return;
    }

    currentStatisticalOperation = operation;
    statisticalArrays = [];
    statisticalArrayNames = [];
    
    // Show input group
    covarianceCorrelationGroup.style.display = 'block';
    operationTitle.textContent = operation === 'covariance' ? 'Covariance Operation' : 'Correlation Coefficient Operation';
    
    // Reset and focus on array count input
    arrayCountInput.value = '2';
    arrayDetailsContainer.innerHTML = '';
    performStatisticalOperationBtn.style.display = 'none';
    arrayCountInput.focus();

    logOperation(`Started ${operation} operation`, 'info');
}

// NEW: Confirm Array Count Handler
function handleConfirmArrayCount() {
    const arrayCount = parseInt(arrayCountInput.value);
    
    if (isNaN(arrayCount) || arrayCount < 2 || arrayCount > 5) {
        showNotification('Please enter a valid number of arrays between 2 and 5', 'danger');
        arrayCountInput.focus();
        return;
    }

    arrayDetailsContainer.innerHTML = '<h6>Array Details:</h6>';
    
    // Create input fields for each array
    for (let i = 0; i < arrayCount; i++) {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'mb-3';
        arrayGroup.innerHTML = `
            <label class="form-label">Array ${i + 1}</label>
            <div class="input-group mb-2">
                <span class="input-group-text">Name</span>
                <input type="text" class="form-control statistical-array-name" 
                       placeholder="e.g., Temperature" data-index="${i}" 
                       value="${i === 0 ? 'Array_X' : i === 1 ? 'Array_Y' : `Array_${String.fromCharCode(65 + i)}`}">
            </div>
            <div class="input-group mb-2">
                <span class="input-group-text">Size</span>
                <input type="number" class="form-control statistical-array-size" 
                       placeholder="Size" data-index="${i}" min="2" max="20" value="5">
            </div>
            <div class="statistical-array-elements" id="statisticalArrayElements${i}"></div>
        `;
        arrayDetailsContainer.appendChild(arrayGroup);

        // Add event listeners for size input
        const sizeInput = arrayGroup.querySelector('.statistical-array-size');
        sizeInput.addEventListener('change', () => handleStatisticalArraySizeChange(i));
        sizeInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleStatisticalArraySizeChange(i);
        });

        // Add event listeners for name input
        const nameInput = arrayGroup.querySelector('.statistical-array-name');
        nameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleStatisticalArraySizeChange(i);
        });

        // Initialize elements for this array
        handleStatisticalArraySizeChange(i);
    }

    performStatisticalOperationBtn.style.display = 'block';
    showNotification(`Please enter details for ${arrayCount} arrays`, 'success');
}

// NEW: Handle Statistical Array Size Change
function handleStatisticalArraySizeChange(index) {
    const sizeInput = document.querySelector(`.statistical-array-size[data-index="${index}"]`);
    const size = parseInt(sizeInput.value);
    const elementsContainer = document.getElementById(`statisticalArrayElements${index}`);
    
    if (isNaN(size) || size < 2 || size > 20) {
        showNotification('Please enter a valid array size between 2 and 20', 'danger');
        sizeInput.focus();
        return;
    }

    elementsContainer.innerHTML = '<div class="form-label">Elements:</div>';
    
    // Create input fields for array elements
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="number" class="form-control statistical-array-element" 
                   placeholder="Enter number" data-array="${index}" data-index="${i}" 
                   step="any" value="${Math.floor(Math.random() * 100) + 1}">
        `;
        elementsContainer.appendChild(inputGroup);
    }

    // Add event listeners for element inputs
    const elementInputs = elementsContainer.querySelectorAll('.statistical-array-element');
    elementInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.parentElement.nextElementSibling?.querySelector('.statistical-array-element');
                if (nextInput) nextInput.focus();
            }
        });
    });
}

// NEW: Perform Statistical Operation Handler
function handlePerformStatisticalOperation() {
    // Collect array names and elements
    statisticalArrayNames = [];
    statisticalArrays = [];
    
    const nameInputs = document.querySelectorAll('.statistical-array-name');
    const arrayCount = nameInputs.length;
    
    let allValid = true;
    
    for (let i = 0; i < arrayCount; i++) {
        const name = nameInputs[i].value.trim() || `Array_${i + 1}`;
        statisticalArrayNames.push(name);
        
        const elements = [];
        const elementInputs = document.querySelectorAll(`.statistical-array-element[data-array="${i}"]`);
        
        for (let j = 0; j < elementInputs.length; j++) {
            const value = parseFloat(elementInputs[j].value);
            if (isNaN(value)) {
                showNotification(`Please enter valid numbers for ${name}`, 'danger');
                elementInputs[j].focus();
                allValid = false;
                break;
            }
            elements.push(value);
        }
        
        if (!allValid) break;
        
        // Check if all arrays have same length
        if (i > 0 && elements.length !== statisticalArrays[0].length) {
            showNotification('All arrays must have the same length for statistical operations', 'danger');
            allValid = false;
            break;
        }
        
        statisticalArrays.push(elements);
    }
    
    if (!allValid) return;
    
    // Store original array
    originalArrayForStatistical = [...myArray];
    
    // Hide input group
    covarianceCorrelationGroup.style.display = 'none';
    
    // Start statistical operation visualization
    if (currentStatisticalOperation === 'covariance') {
        performCovarianceCalculation();
    } else {
        performCorrelationCalculation();
    }
}

// NEW: Cancel Statistical Operation Handler
function handleCancelStatisticalOperation() {
    covarianceCorrelationGroup.style.display = 'none';
    arrayCountInput.value = '2';
    arrayDetailsContainer.innerHTML = '';
    performStatisticalOperationBtn.style.display = 'none';
    
    statisticalArrays = [];
    statisticalArrayNames = [];
    currentStatisticalOperation = null;
    
    logOperation('Cancelled statistical operation', 'info');
    showNotification('Statistical operation cancelled', 'info');
}

// NEW: Perform Covariance Calculation with Visualization
function performCovarianceCalculation() {
    isStatisticalOperationRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Covariance Calculation</h5>
        
        <div class="array-group">
            <div class="array-label">Input Arrays</div>
            <div id="covarianceArraysContainer" class="multiple-arrays-container"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Covariance Calculation Steps</div>
            <div id="covarianceCalculationContainer" class="calculation-container"></div>
        </div>
        
        <div class="statistical-explanation">
            <p class="mb-2"><strong>Covariance Formula:</strong> Measures how two variables change together</p>
            <p class="mb-0" id="covarianceExplanation">Starting covariance calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="covarianceStepsContainer">
            <h6 class="text-center">Covariance Calculation Steps</h6>
            <div class="steps-container" id="covarianceSteps"></div>
        </div>
        
        <div class="stats-card mt-3" id="covarianceResultContainer" style="display: none;">
            <div>Covariance Result</div>
            <div class="stats-value" id="covarianceResultValue">0</div>
            <div id="covarianceInterpretation"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterCovariance" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderCovarianceArrays();
    performCovarianceStepByStep();
}

// NEW: Render Covariance Arrays
function renderCovarianceArrays() {
    const container = document.getElementById('covarianceArraysContainer');
    container.innerHTML = '';
    
    statisticalArrays.forEach((array, index) => {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'mb-3';
        arrayGroup.innerHTML = `
            <div class="array-title">${statisticalArrayNames[index]}</div>
            <div class="original-array-container" id="covarianceArray${index}"></div>
        `;
        container.appendChild(arrayGroup);
        
        renderStatisticalArrayInContainer(array, `covarianceArray${index}`, statisticalArrayNames[index]);
    });
}

// NEW: Perform Covariance Step by Step
function performCovarianceStepByStep() {
    const explanation = document.getElementById('covarianceExplanation');
    const stepsContainer = document.getElementById('covarianceSteps');
    const calculationContainer = document.getElementById('covarianceCalculationContainer');
    const resultContainer = document.getElementById('covarianceResultContainer');
    const resultValue = document.getElementById('covarianceResultValue');
    const interpretation = document.getElementById('covarianceInterpretation');
    const continueButton = document.getElementById('continueAfterCovariance');
    
    const array1 = statisticalArrays[0];
    const array2 = statisticalArrays[1];
    const n = array1.length;
    
    let step = 0;
    let means = [];
    let deviations = [];
    let products = [];
    
    function performCovarianceStep() {
        switch (step) {
            case 0:
                // Step 1: Calculate means
                explanation.innerHTML = 'Step 1: Calculate means of both arrays';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Calculate means (average) of both arrays
                    </div>
                `;
                
                means = statisticalArrays.map(array => {
                    const sum = array.reduce((a, b) => a + b, 0);
                    return sum / n;
                });
                
                calculationContainer.innerHTML = `
                    <div class="statistical-formula">
                        Mean(${statisticalArrayNames[0]}) = (${array1.join(' + ')}) / ${n} = ${means[0].toFixed(2)}<br>
                        Mean(${statisticalArrayNames[1]}) = (${array2.join(' + ')}) / ${n} = ${means[1].toFixed(2)}
                    </div>
                `;
                
                // Highlight means in arrays
                highlightStatisticalMeans();
                break;
                
            case 1:
                // Step 2: Calculate deviations from mean
                explanation.innerHTML = 'Step 2: Calculate deviations from mean for each element';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Calculate deviations (element - mean) for both arrays
                    </div>
                `;
                
                deviations = statisticalArrays.map((array, idx) => 
                    array.map(val => val - means[idx])
                );
                
                calculationContainer.innerHTML += `
                    <div class="statistical-formula mt-3">
                        Deviation = Element - Mean<br>
                        ${statisticalArrayNames[0]} deviations: [${deviations[0].map(d => d.toFixed(2)).join(', ')}]<br>
                        ${statisticalArrayNames[1]} deviations: [${deviations[1].map(d => d.toFixed(2)).join(', ')}]
                    </div>
                `;
                
                // Highlight deviations
                highlightStatisticalDeviations();
                break;
                
            case 2:
                // Step 3: Calculate product of deviations
                explanation.innerHTML = 'Step 3: Calculate product of deviations for each pair';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Multiply deviations for each corresponding pair
                    </div>
                `;
                
                products = [];
                for (let i = 0; i < n; i++) {
                    products.push(deviations[0][i] * deviations[1][i]);
                }
                
                calculationContainer.innerHTML += `
                    <div class="statistical-formula mt-3">
                        Product of deviations:<br>
                        ${products.map((p, i) => `(${deviations[0][i].toFixed(2)}  ${deviations[1][i].toFixed(2)} = ${p.toFixed(2)})`).join(', ')}
                    </div>
                `;
                
                // Highlight products
                highlightStatisticalProducts();
                break;
                
            case 3:
        // Step 4: Calculate covariance
        explanation.innerHTML = 'Step 4: Calculate covariance (sum of products / n-1)';
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step 4:</strong> Sum all products and divide by (n-1)
            </div>
        `;
        
        const sumProducts = products.reduce((a, b) => a + b, 0);
        const covariance = sumProducts / (n - 1);
        
        calculationContainer.innerHTML += `
            <div class="statistical-formula mt-3">
                Covariance = (${products.map(p => p.toFixed(2)).join(' + ')}) / (${n} - 1)<br>
                = ${sumProducts.toFixed(2)} / ${n - 1} = ${covariance.toFixed(4)}
            </div>
        `;
        
        // Show final result with proper color coding
        resultContainer.style.display = 'block';
        resultValue.textContent = covariance.toFixed(4);
        
        // FIXED: Proper color coding for covariance
        if (covariance > 0) {
            resultValue.className = 'stats-value stats-positive';
        } else if (covariance < 0) {
            resultValue.className = 'stats-value stats-negative';
        } else {
            resultValue.className = 'stats-value stats-zero';
        }
        
        // Add interpretation with dynamic array names
        const arrayName1 = statisticalArrayNames[0];
        const arrayName2 = statisticalArrayNames[1];
        let interpretationText = '';
        
        if (covariance > 0) {
            interpretationText = `Covariance = ${covariance.toFixed(4)}  Positive number = they move together<br>`;
            interpretationText += ` When ${arrayName1} goes UP, ${arrayName2} also goes UP`;
        } else if (covariance < 0) {
            interpretationText = `Covariance = ${covariance.toFixed(4)}  Negative number = they move opposite<br>`;
            interpretationText += ` When ${arrayName1} goes UP, ${arrayName2} goes DOWN`;
        } else {
            interpretationText = `Covariance = ${covariance.toFixed(4)}  Zero = they are independent<br>`;
            interpretationText += ` No linear relationship between ${arrayName1} and ${arrayName2}`;
        }
        
        interpretation.innerHTML = interpretationText;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Final:</strong> Covariance = <span class="${covariance > 0 ? 'stats-positive' : covariance < 0 ? 'stats-negative' : 'stats-zero'}">${covariance.toFixed(4)}</span><br>
                ${interpretationText.replace(/<br>/g, ' - ')}
            </div>
        `;
        
        continueButton.style.display = 'block';
        continueButton.addEventListener('click', returnToOriginalAfterStatistical);
        
        // Auto-return after 10 seconds
        setTimeout(() => {
            returnToOriginalAfterStatistical();
        }, 10000);
        
        logOperation(`Covariance calculated: ${covariance.toFixed(4)} between ${arrayName1} and ${arrayName2}`, 'success');
        return;
    // ... rest of the code ...
}        
        step++;
        setTimeout(performCovarianceStep, 3000);
    }
    
    performCovarianceStep();
}

// NEW: Perform Correlation Calculation with Visualization
function performCorrelationCalculation() {
    isStatisticalOperationRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Correlation Coefficient Calculation</h5>
        
        <div class="array-group">
            <div class="array-label">Input Arrays</div>
            <div id="correlationArraysContainer" class="multiple-arrays-container"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Correlation Calculation Steps</div>
            <div id="correlationCalculationContainer" class="calculation-container"></div>
        </div>
        
        <div class="statistical-explanation">
            <p class="mb-2"><strong>Correlation Formula:</strong> Measures strength and direction of linear relationship</p>
            <p class="mb-0" id="correlationExplanation">Starting correlation calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="correlationStepsContainer">
            <h6 class="text-center">Correlation Calculation Steps</h6>
            <div class="steps-container" id="correlationSteps"></div>
        </div>
        
        <div class="stats-card mt-3" id="correlationResultContainer" style="display: none;">
            <div>Correlation Coefficient</div>
            <div class="stats-value" id="correlationResultValue">0</div>
            <div id="correlationInterpretation"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterCorrelation" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderCorrelationArrays();
    performCorrelationStepByStep();
}

// NEW: Perform Correlation Step by Step
function performCorrelationStepByStep() {
    const explanation = document.getElementById('correlationExplanation');
    const stepsContainer = document.getElementById('correlationSteps');
    const calculationContainer = document.getElementById('correlationCalculationContainer');
    const resultContainer = document.getElementById('correlationResultContainer');
    const resultValue = document.getElementById('correlationResultValue');
    const interpretation = document.getElementById('correlationInterpretation');
    const continueButton = document.getElementById('continueAfterCorrelation');
    
    const array1 = statisticalArrays[0];
    const array2 = statisticalArrays[1];
    const n = array1.length;
    
    let step = 0;
    let means = [];
    let stdDevs = [];
    let covariance = 0;
    
    function performCorrelationStep() {
        switch (step) {
            case 0:
                // Step 1: Calculate means
                explanation.innerHTML = 'Step 1: Calculate means of both arrays';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Calculate means (average) of both arrays
                    </div>
                `;
                
                means = statisticalArrays.map(array => {
                    const sum = array.reduce((a, b) => a + b, 0);
                    return sum / n;
                });
                
                calculationContainer.innerHTML = `
                    <div class="statistical-formula">
                        Mean(${statisticalArrayNames[0]}) = ${means[0].toFixed(2)}<br>
                        Mean(${statisticalArrayNames[1]}) = ${means[1].toFixed(2)}
                    </div>
                `;
                break;
                
            case 1:
                // Step 2: Calculate standard deviations
                explanation.innerHTML = 'Step 2: Calculate standard deviations';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Calculate standard deviation for both arrays
                    </div>
                `;
                
                stdDevs = statisticalArrays.map((array, idx) => {
                    const variance = array.reduce((sum, val) => sum + Math.pow(val - means[idx], 2), 0) / (n - 1);
                    return Math.sqrt(variance);
                });
                
                calculationContainer.innerHTML += `
                    <div class="statistical-formula mt-3">
                        StdDev(${statisticalArrayNames[0]}) = [(x - mean) / (n-1)] = ${stdDevs[0].toFixed(4)}<br>
                        StdDev(${statisticalArrayNames[1]}) = [(y - mean) / (n-1)] = ${stdDevs[1].toFixed(4)}
                    </div>
                `;
                break;
                
            case 2:
                // Step 3: Calculate covariance
                explanation.innerHTML = 'Step 3: Calculate covariance';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Calculate covariance between arrays
                    </div>
                `;
                
                let sumProducts = 0;
                for (let i = 0; i < n; i++) {
                    sumProducts += (array1[i] - means[0]) * (array2[i] - means[1]);
                }
                covariance = sumProducts / (n - 1);
                
                calculationContainer.innerHTML += `
                    <div class="statistical-formula mt-3">
                        Covariance = [(x - mean)(y - mean)] / (n-1) = ${covariance.toFixed(4)}
                    </div>
                `;
                break;
                
            case 3:
                // Step 4: Calculate correlation coefficient
                explanation.innerHTML = 'Step 4: Calculate correlation coefficient';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 4:</strong> Correlation = Covariance / (StdDev  StdDev)
                    </div>
                `;
                
                const correlation = covariance / (stdDevs[0] * stdDevs[1]);
                
                calculationContainer.innerHTML += `
                    <div class="statistical-formula mt-3">
                        Correlation = ${covariance.toFixed(4)} / (${stdDevs[0].toFixed(4)}  ${stdDevs[1].toFixed(4)})<br>
                        = ${covariance.toFixed(4)} / ${(stdDevs[0] * stdDevs[1]).toFixed(4)} = ${correlation.toFixed(4)}
                    </div>
                `;
                
                // Show final result
                resultContainer.style.display = 'block';
                resultValue.textContent = correlation.toFixed(4);
                
                // Color coding based on correlation value
                if (correlation > 0.7) {
                    resultValue.className = 'stats-value stats-positive';
                } else if (correlation > 0.3) {
                    resultValue.className = 'stats-value';
                } else if (correlation > -0.3) {
                    resultValue.className = 'stats-value stats-zero';
                } else if (correlation > -0.7) {
                    resultValue.className = 'stats-value';
                } else {
                    resultValue.className = 'stats-value stats-negative';
                }
                
                // Add interpretation
                let interpretationText = '';
                if (correlation >= 0.8) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Very strong positive relationship<br>`;
                    interpretationText += ` ${statisticalArrayNames[0]} and ${statisticalArrayNames[1]} are best friends  they move perfectly together!`;
                } else if (correlation >= 0.6) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Strong positive relationship<br>`;
                    interpretationText += ` When ${statisticalArrayNames[0]} changes, ${statisticalArrayNames[1]} strongly follows the same direction`;
                } else if (correlation >= 0.3) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Moderate positive relationship<br>`;
                    interpretationText += ` ${statisticalArrayNames[0]} and ${statisticalArrayNames[1]} tend to move together`;
                } else if (correlation >= -0.3) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Weak or no relationship<br>`;
                    interpretationText += ` Little to no linear relationship between ${statisticalArrayNames[0]} and ${statisticalArrayNames[1]}`;
                } else if (correlation >= -0.6) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Moderate negative relationship<br>`;
                    interpretationText += ` When ${statisticalArrayNames[0]} goes up, ${statisticalArrayNames[1]} tends to go down`;
                } else if (correlation >= -0.8) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Strong negative relationship<br>`;
                    interpretationText += ` ${statisticalArrayNames[0]} and ${statisticalArrayNames[1]} strongly move in opposite directions`;
                } else {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Very strong negative relationship<br>`;
                    interpretationText += ` Perfect opposites  when one goes up, the other goes down consistently!`;
                }
                
                interpretation.innerHTML = interpretationText;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Correlation = ${correlation.toFixed(4)}<br>
                        ${interpretationText.replace(/<br>/g, ' - ')}
                    </div>
                `;
                
                continueButton.style.display = 'block';
                continueButton.addEventListener('click', returnToOriginalAfterStatistical);
                
                // Auto-return after 10 seconds
                setTimeout(() => {
                    returnToOriginalAfterStatistical();
                }, 10000);
                
                logOperation(`Correlation calculated: ${correlation.toFixed(4)} between ${statisticalArrayNames[0]} and ${statisticalArrayNames[1]}`, 'success');
                return;
        }
        
        step++;
        setTimeout(performCorrelationStep, 3000);
    }
    
    performCorrelationStep();
}

// NEW: Helper function to render statistical arrays
function renderStatisticalArrayInContainer(array, containerId, arrayName) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    array.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value statistical-element" data-index="${index}">
                ${value}
            </div>
            <div class="element-index">${arrayName}[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}

// NEW: Highlight statistical means
function highlightStatisticalMeans() {
    statisticalArrays.forEach((array, arrayIndex) => {
        const mean = array.reduce((a, b) => a + b, 0) / array.length;
        const container = document.getElementById(`covarianceArray${arrayIndex}`);
        const elements = container.querySelectorAll('.statistical-element');
        
        elements.forEach(element => {
            const value = parseFloat(element.textContent);
            if (Math.abs(value - mean) < 0.01) { // Account for floating point precision
                element.classList.add('mean-highlight');
            }
        });
    });
}

// NEW: Highlight statistical deviations
function highlightStatisticalDeviations() {
    statisticalArrays.forEach((array, arrayIndex) => {
        const mean = array.reduce((a, b) => a + b, 0) / array.length;
        const container = document.getElementById(`covarianceArray${arrayIndex}`);
        const elements = container.querySelectorAll('.statistical-element');
        
        elements.forEach((element, index) => {
            const deviation = array[index] - mean;
            element.classList.add('deviation-highlight');
            // You could add tooltips or additional display for deviation values
        });
    });
}

// NEW: Highlight statistical products
function highlightStatisticalProducts() {
    // This would highlight the pairs being multiplied
    const container1 = document.getElementById('covarianceArray0');
    const container2 = document.getElementById('covarianceArray1');
    const elements1 = container1.querySelectorAll('.statistical-element');
    const elements2 = container2.querySelectorAll('.statistical-element');
    
    elements1.forEach((element, index) => {
        element.classList.add('statistical-highlight');
        if (elements2[index]) {
            elements2[index].classList.add('statistical-highlight');
        }
    });
}
// NEW: Render Correlation Arrays (Missing function)
function renderCorrelationArrays() {
    const container = document.getElementById('correlationArraysContainer');
    container.innerHTML = '';
    
    statisticalArrays.forEach((array, index) => {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'mb-3';
        arrayGroup.innerHTML = `
            <div class="array-title">${statisticalArrayNames[index]}</div>
            <div class="original-array-container" id="correlationArray${index}"></div>
        `;
        container.appendChild(arrayGroup);
        
        renderStatisticalArrayInContainer(array, `correlationArray${index}`, statisticalArrayNames[index]);
    });
}

// NEW: Fix the color coding in correlation calculation
function performCorrelationStepByStep() {
    const explanation = document.getElementById('correlationExplanation');
    const stepsContainer = document.getElementById('correlationSteps');
    const calculationContainer = document.getElementById('correlationCalculationContainer');
    const resultContainer = document.getElementById('correlationResultContainer');
    const resultValue = document.getElementById('correlationResultValue');
    const interpretation = document.getElementById('correlationInterpretation');
    const continueButton = document.getElementById('continueAfterCorrelation');
    
    const array1 = statisticalArrays[0];
    const array2 = statisticalArrays[1];
    const n = array1.length;
    
    let step = 0;
    let means = [];
    let stdDevs = [];
    let covariance = 0;
    
    function performCorrelationStep() {
        switch (step) {
            case 0:
                // Step 1: Calculate means
                explanation.innerHTML = 'Step 1: Calculate means of both arrays';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Calculate means (average) of both arrays
                    </div>
                `;
                
                means = statisticalArrays.map(array => {
                    const sum = array.reduce((a, b) => a + b, 0);
                    return sum / n;
                });
                
                calculationContainer.innerHTML = `
                    <div class="statistical-formula">
                        Mean(${statisticalArrayNames[0]}) = (${array1.join(' + ')}) / ${n} = ${means[0].toFixed(2)}<br>
                        Mean(${statisticalArrayNames[1]}) = (${array2.join(' + ')}) / ${n} = ${means[1].toFixed(2)}
                    </div>
                `;
                
                // Highlight means in arrays
                highlightCorrelationMeans();
                break;
                
            case 1:
                // Step 2: Calculate standard deviations
                explanation.innerHTML = 'Step 2: Calculate standard deviations';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Calculate standard deviation for both arrays
                    </div>
                `;
                
                stdDevs = statisticalArrays.map((array, idx) => {
                    const variance = array.reduce((sum, val) => sum + Math.pow(val - means[idx], 2), 0) / (n - 1);
                    return Math.sqrt(variance);
                });
                
                calculationContainer.innerHTML += `
                    <div class="statistical-formula mt-3">
                        StdDev(${statisticalArrayNames[0]}) = [(x - mean) / (n-1)] = ${stdDevs[0].toFixed(4)}<br>
                        StdDev(${statisticalArrayNames[1]}) = [(y - mean) / (n-1)] = ${stdDevs[1].toFixed(4)}
                    </div>
                `;
                break;
                
            case 2:
                // Step 3: Calculate covariance
                explanation.innerHTML = 'Step 3: Calculate covariance';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Calculate covariance between arrays
                    </div>
                `;
                
                let sumProducts = 0;
                for (let i = 0; i < n; i++) {
                    sumProducts += (array1[i] - means[0]) * (array2[i] - means[1]);
                }
                covariance = sumProducts / (n - 1);
                
                calculationContainer.innerHTML += `
                    <div class="statistical-formula mt-3">
                        Covariance = [(x - mean)(y - mean)] / (n-1) = ${covariance.toFixed(4)}
                    </div>
                `;
                break;
                
            case 3:
                // Step 4: Calculate correlation coefficient
                explanation.innerHTML = 'Step 4: Calculate correlation coefficient';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 4:</strong> Correlation = Covariance / (StdDev  StdDev)
                    </div>
                `;
                
                const correlation = covariance / (stdDevs[0] * stdDevs[1]);
                
                calculationContainer.innerHTML += `
                    <div class="statistical-formula mt-3">
                        Correlation = ${covariance.toFixed(4)} / (${stdDevs[0].toFixed(4)}  ${stdDevs[1].toFixed(4)})<br>
                        = ${covariance.toFixed(4)} / ${(stdDevs[0] * stdDevs[1]).toFixed(4)} = ${correlation.toFixed(4)}
                    </div>
                `;
                
                // Show final result with proper color coding
                resultContainer.style.display = 'block';
                resultValue.textContent = correlation.toFixed(4);
                
                // FIXED: Proper color coding for correlation coefficient
                if (correlation > 0) {
                    resultValue.className = 'stats-value stats-positive';
                } else if (correlation < 0) {
                    resultValue.className = 'stats-value stats-negative';
                } else {
                    resultValue.className = 'stats-value stats-zero';
                }
                
                // Add interpretation with dynamic array names
                let interpretationText = '';
                const arrayName1 = statisticalArrayNames[0];
                const arrayName2 = statisticalArrayNames[1];
                
                if (correlation >= 0.8) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Very strong positive relationship<br>`;
                    interpretationText += ` ${arrayName1} and ${arrayName2} are best friends  they move perfectly together!`;
                } else if (correlation >= 0.6) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Strong positive relationship<br>`;
                    interpretationText += ` When ${arrayName1} changes, ${arrayName2} strongly follows the same direction`;
                } else if (correlation >= 0.3) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Moderate positive relationship<br>`;
                    interpretationText += ` ${arrayName1} and ${arrayName2} tend to move together`;
                } else if (correlation > 0) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Weak positive relationship<br>`;
                    interpretationText += ` ${arrayName1} and ${arrayName2} have a slight tendency to move together`;
                } else if (correlation === 0) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  No relationship<br>`;
                    interpretationText += ` No linear relationship between ${arrayName1} and ${arrayName2}`;
                } else if (correlation >= -0.3) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Weak negative relationship<br>`;
                    interpretationText += ` ${arrayName1} and ${arrayName2} have a slight tendency to move opposite`;
                } else if (correlation >= -0.6) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Moderate negative relationship<br>`;
                    interpretationText += ` When ${arrayName1} goes up, ${arrayName2} tends to go down`;
                } else if (correlation >= -0.8) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Strong negative relationship<br>`;
                    interpretationText += ` ${arrayName1} and ${arrayName2} strongly move in opposite directions`;
                } else {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Very strong negative relationship<br>`;
                    interpretationText += ` Perfect opposites  when ${arrayName1} goes up, ${arrayName2} goes down consistently!`;
                }
                
                interpretation.innerHTML = interpretationText;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Correlation = <span class="${correlation > 0 ? 'stats-positive' : correlation < 0 ? 'stats-negative' : 'stats-zero'}">${correlation.toFixed(4)}</span><br>
                        ${interpretationText.replace(/<br>/g, ' - ')}
                    </div>
                `;
                
                continueButton.style.display = 'block';
                continueButton.addEventListener('click', returnToOriginalAfterStatistical);
                
                // Auto-return after 10 seconds
                setTimeout(() => {
                    returnToOriginalAfterStatistical();
                }, 10000);
                
                logOperation(`Correlation calculated: ${correlation.toFixed(4)} between ${arrayName1} and ${arrayName2}`, 'success');
                return;
        }
        
        step++;
        setTimeout(performCorrelationStep, 3000);
    }
    
    performCorrelationStep();
}

// NEW: Highlight correlation means
function highlightCorrelationMeans() {
    statisticalArrays.forEach((array, arrayIndex) => {
        const mean = array.reduce((a, b) => a + b, 0) / array.length;
        const container = document.getElementById(`correlationArray${arrayIndex}`);
        const elements = container.querySelectorAll('.statistical-element');
        
        elements.forEach(element => {
            const value = parseFloat(element.textContent);
            if (Math.abs(value - mean) < 0.01) {
                element.classList.add('mean-highlight');
            }
        });
    });
}

// NEW: Return to Original after Statistical Operations
function returnToOriginalAfterStatistical() {
    // Reset to original array
    myArray = [...originalArrayForStatistical];
    originalArrayForStatistical = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isStatisticalOperationRunning = false;
    currentStatisticalOperation = null;
    statisticalArrays = [];
    statisticalArrayNames = [];
    
    // Clear input groups
    covarianceCorrelationGroup.style.display = 'none';
    arrayCountInput.value = '2';
    arrayDetailsContainer.innerHTML = '';
    performStatisticalOperationBtn.style.display = 'none';
    
    logOperation('Statistical operation completed - returned to original array', 'info');
    showNotification('Returned to original array after statistical operation', 'success');
}
// NEW: Find Mean Handler
function handleFindMean() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isStatisticalCalculationRunning) {
        showNotification('A statistical operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Mean calculation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isStatisticalCalculationRunning = true;
    
    // Store original array
    originalArrayForStats = [...myArray];
    
    // Show mean calculation visualization
    showMeanCalculation();
}

// NEW: Find Median Handler
function handleFindMedian() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isStatisticalCalculationRunning) {
        showNotification('A statistical operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Median calculation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isStatisticalCalculationRunning = true;
    
    // Store original array
    originalArrayForStats = [...myArray];
    
    // Show median calculation visualization
    showMedianCalculation();
}

// NEW: Show Mean Calculation Visualization
function showMeanCalculation() {
    const statsContainer = document.createElement('div');
    statsContainer.className = 'dual-operation-container';
    statsContainer.innerHTML = `
        <h5 class="text-center mb-3">Calculate Mean (Average)</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="statsArray"></div>
        </div>
        
        <div class="stats-result-card">
            <p class="mb-2"><strong>Mean Calculation Process:</strong> Sum of all elements divided by number of elements</p>
            <p class="mb-0" id="statsExplanation">Starting mean calculation...</p>
        </div>
        
        <div class="calculation-steps mt-3" id="calculationSteps">
            <h6 class="text-center">Calculation Steps</h6>
            <div id="meanSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Mean (Average)</div>
            <div class="stats-value" id="meanValue">Calculating...</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterStats" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(statsContainer);
    
    renderArrayInContainer(originalArrayForStats, 'statsArray');
    
    performMeanCalculation();
}

// NEW: Perform Mean Calculation with Animation
function performMeanCalculation() {
    const arrayContainer = document.getElementById('statsArray');
    const explanation = document.getElementById('statsExplanation');
    const stepsContainer = document.getElementById('meanSteps');
    const meanValue = document.getElementById('meanValue');
    const continueButton = document.getElementById('continueAfterStats');
    
    const arr = originalArrayForStats.map(val => parseFloat(val));
    let sum = 0;
    let step = 0;
    
    function performMeanStep(i) {
        if (i >= arr.length) {
            // Calculation completed
            const mean = sum / arr.length;
            const meanRounded = Math.round(mean * 100) / 100; // Round to 2 decimal places
            
            explanation.innerHTML = `<strong>Mean Calculation Completed!</strong>`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step + 1}:</strong> Mean = Total Sum / Number of Elements = ${sum} / ${arr.length} = <strong>${meanRounded}</strong>
                </div>
            `;
            
            meanValue.textContent = meanRounded;
            meanValue.classList.add('highlight');
            
            // Highlight all elements as they contributed to the mean
            const elements = arrayContainer.querySelectorAll('.array-element');
            elements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('mean-element');
                }, index * 200);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterStats();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterStats);
            
            return;
        }
        
        step++;
        
        if (i === 0) {
            explanation.innerHTML = `Step ${step}: Start with first element = ${arr[i]}`;
        } else {
            explanation.innerHTML = `Step ${step}: Add element [${i}] = ${arr[i]} to running sum`;
        }
        
        // Highlight current element
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElement = elements[i].querySelector('.element-value');
        currentElement.classList.add('statistical-highlight');
        
        setTimeout(() => {
            // Add to sum
            const previousSum = sum;
            sum += arr[i];
            
            if (i === 0) {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> Initialize sum = ${arr[i]}
                    </div>
                `;
            } else {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> Sum = ${previousSum} + ${arr[i]} = <strong>${sum}</strong>
                    </div>
                `;
            }
            
            // Update mean value display with intermediate calculation
            const currentMean = sum / (i + 1);
            const currentMeanRounded = Math.round(currentMean * 100) / 100;
            meanValue.textContent = `Calculating... (Current: ${currentMeanRounded})`;
            
            // Remove highlight and mark as processed
            currentElement.classList.remove('statistical-highlight');
            currentElement.classList.add('mean-element');
            
            // Move to next element
            performMeanStep(i + 1);
        }, 1500);
    }
    
    // Start mean calculation
    performMeanStep(0);
}

// NEW: Show Median Calculation Visualization
function showMedianCalculation() {
    const statsContainer = document.createElement('div');
    statsContainer.className = 'dual-operation-container';
    statsContainer.innerHTML = `
        <h5 class="text-center mb-3">Calculate Median</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="statsArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Sorted Array (for Median)</div>
            <div class="transformed-array-container" id="sortedStatsArray"></div>
        </div>
        
        <div class="stats-result-card">
            <p class="mb-2"><strong>Median Calculation Process:</strong> Middle value of sorted array</p>
            <p class="mb-0" id="statsExplanation">Starting median calculation...</p>
        </div>
        
        <div class="calculation-steps mt-3" id="calculationSteps">
            <h6 class="text-center">Calculation Steps</h6>
            <div id="medianSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Median</div>
            <div class="stats-value" id="medianValue">Calculating...</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterStats" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(statsContainer);
    
    renderArrayInContainer(originalArrayForStats, 'statsArray');
    renderArrayInContainer([...originalArrayForStats], 'sortedStatsArray');
    
    performMedianCalculation();
}

// NEW: Perform Median Calculation with Animation
function performMedianCalculation() {
    const originalContainer = document.getElementById('statsArray');
    const sortedContainer = document.getElementById('sortedStatsArray');
    const explanation = document.getElementById('statsExplanation');
    const stepsContainer = document.getElementById('medianSteps');
    const medianValue = document.getElementById('medianValue');
    const continueButton = document.getElementById('continueAfterStats');
    
    const arr = originalArrayForStats.map(val => parseFloat(val));
    const sortedArr = [...arr].sort((a, b) => a - b);
    const n = sortedArr.length;
    let step = 0;
    
    function performMedianStep() {
        step++;
        
        if (step === 1) {
            // Step 1: Show original array
            explanation.innerHTML = `Step ${step}: Original array needs to be sorted for median calculation`;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Original array: [${arr.join(', ')}]
                </div>
            `;
            
            // Highlight original array
            const originalElements = originalContainer.querySelectorAll('.array-element');
            originalElements.forEach(el => {
                el.querySelector('.element-value').classList.add('statistical-highlight');
            });
            
            setTimeout(() => {
                performMedianStep();
            }, 2000);
            
        } else if (step === 2) {
            // Step 2: Show sorted array
            explanation.innerHTML = `Step ${step}: Array sorted in ascending order`;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Sorted array: [${sortedArr.join(', ')}]
                </div>
            `;
            
            // Update sorted array display
            renderArrayInContainer(sortedArr, 'sortedStatsArray');
            
            // Highlight sorted array
            const sortedElements = sortedContainer.querySelectorAll('.array-element');
            sortedElements.forEach(el => {
                el.querySelector('.element-value').classList.add('statistical-highlight');
            });
            
            setTimeout(() => {
                performMedianStep();
            }, 2000);
            
        } else if (step === 3) {
            // Step 3: Calculate median based on array length
            explanation.innerHTML = `Step ${step}: Calculate median (n = ${n} elements)`;
            
            let median;
            let calculation;
            
            if (n % 2 === 1) {
                // Odd number of elements
                const midIndex = Math.floor(n / 2);
                median = sortedArr[midIndex];
                calculation = `Median = element at position (n+1)/2 = element at index ${midIndex} = ${median}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> Odd number of elements (n = ${n})<br>
                        ${calculation}
                    </div>
                `;
                
                // Highlight the median element
                const sortedElements = sortedContainer.querySelectorAll('.array-element');
                sortedElements[midIndex].querySelector('.element-value').classList.add('median-element');
                
            } else {
                // Even number of elements
                const midIndex1 = n / 2 - 1;
                const midIndex2 = n / 2;
                median = (sortedArr[midIndex1] + sortedArr[midIndex2]) / 2;
                calculation = `Median = (element[${midIndex1}] + element[${midIndex2}]) / 2 = (${sortedArr[midIndex1]} + ${sortedArr[midIndex2]}) / 2 = ${median}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> Even number of elements (n = ${n})<br>
                        ${calculation}
                    </div>
                `;
                
                // Highlight the two middle elements
                const sortedElements = sortedContainer.querySelectorAll('.array-element');
                sortedElements[midIndex1].querySelector('.element-value').classList.add('median-element');
                sortedElements[midIndex2].querySelector('.element-value').classList.add('median-element');
            }
            
            const medianRounded = Math.round(median * 100) / 100;
            medianValue.textContent = medianRounded;
            medianValue.classList.add('highlight');
            
            explanation.innerHTML = `<strong>Median Calculation Completed!</strong> ${calculation}`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterStats();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterStats);
        }
    }
    
    // Start median calculation
    performMedianStep();
}

// NEW: Return to Original after Statistical Operations
function returnToOriginalAfterStats() {
    // Reset to original array
    myArray = [...originalArrayForStats];
    originalArrayForStats = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isStatisticalCalculationRunning = false;
    
    logOperation('Statistical operation completed - returned to original array', 'info');
    showNotification('Returned to original array after statistical operation', 'success');
}
// NEW: Element-wise Operation Handler
function handleElementWiseOperation(operation) {
    if (isElementWiseOperationRunning) {
        showNotification('An element-wise operation is already in progress', 'warning');
        return;
    }

    // Reset arrays
    elementWiseFirstArray = [];
    elementWiseSecondArray = [];
    elementWiseFirstArraySize = 0;
    elementWiseSecondArraySize = 0;
    currentElementWiseOperation = operation;
    
    // Show input group
    elementWiseGroup.style.display = 'block';
    firstArraySizeElementWise.focus();
    
    // Hide perform button initially
    performElementWiseBtn.style.display = 'none';
    
    // Update button text based on operation
    const operationName = operation === 'max' ? 'Maximum' : 'Minimum';
    performElementWiseBtn.innerHTML = `<i class="fas fa-play me-2"></i>Perform Element-wise ${operationName}`;
    
    logOperation(`Started element-wise ${operationName} operation`, 'info');
}

// NEW: Confirm First Array Size for Element-wise
function handleConfirmFirstArraySizeElementWise() {
    const size = parseInt(firstArraySizeElementWise.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        firstArraySizeElementWise.focus();
        return;
    }
    
    elementWiseFirstArraySize = size;
    elementWiseFirstArray = [];
    
    // Create input fields for first array
    firstArrayInputsElementWise.innerHTML = '<label class="form-label">Enter elements for First Array:</label>';
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="number" class="form-control first-array-element-wise" 
                   placeholder="Enter number" data-index="${i}" step="any">
        `;
        firstArrayInputsElementWise.appendChild(inputGroup);
    }
    
    showNotification(`First array size set to ${size}. Please enter ${size} numbers.`, 'success');
    logOperation(`First array size set to ${size} for element-wise operation`, 'info');
}

// NEW: Confirm Second Array Size for Element-wise
function handleConfirmSecondArraySizeElementWise() {
    const size = parseInt(secondArraySizeElementWise.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        secondArraySizeElementWise.focus();
        return;
    }
    
    if (size !== elementWiseFirstArraySize) {
        showNotification(`Both arrays must have the same size. First array size is ${elementWiseFirstArraySize}`, 'danger');
        return;
    }
    
    elementWiseSecondArraySize = size;
    elementWiseSecondArray = [];
    
    // Create input fields for second array
    secondArrayInputsElementWise.innerHTML = '<label class="form-label">Enter elements for Second Array:</label>';
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="number" class="form-control second-array-element-wise" 
                   placeholder="Enter number" data-index="${i}" step="any">
        `;
        secondArrayInputsElementWise.appendChild(inputGroup);
    }
    
    // Show perform button
    performElementWiseBtn.style.display = 'block';
    
    showNotification(`Second array size set to ${size}. Please enter ${size} numbers.`, 'success');
    logOperation(`Second array size set to ${size} for element-wise operation`, 'info');
}

// NEW: Perform Element-wise Operation
function handlePerformElementWise() {
    // Collect first array elements
    const firstArrayInputs = document.querySelectorAll('.first-array-element-wise');
    elementWiseFirstArray = [];
    
    for (let i = 0; i < firstArrayInputs.length; i++) {
        const value = firstArrayInputs[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all elements for first array. Missing element at position ${i}`, 'danger');
            firstArrayInputs[i].focus();
            return;
        }
        if (isNaN(parseFloat(value))) {
            showNotification(`Please enter valid numbers only. Invalid value at position ${i}`, 'danger');
            firstArrayInputs[i].focus();
            return;
        }
        elementWiseFirstArray.push(parseFloat(value));
    }
    
    // Collect second array elements
    const secondArrayInputs = document.querySelectorAll('.second-array-element-wise');
    elementWiseSecondArray = [];
    
    for (let i = 0; i < secondArrayInputs.length; i++) {
        const value = secondArrayInputs[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all elements for second array. Missing element at position ${i}`, 'danger');
            secondArrayInputs[i].focus();
            return;
        }
        if (isNaN(parseFloat(value))) {
            showNotification(`Please enter valid numbers only. Invalid value at position ${i}`, 'danger');
            secondArrayInputs[i].focus();
            return;
        }
        elementWiseSecondArray.push(parseFloat(value));
    }
    
    // Store original array
    originalArrayBeforeElementWise = [...myArray];
    
    // Hide input group
    elementWiseGroup.style.display = 'none';
    
    // Start element-wise visualization
    showElementWiseVisualization();
}

// NEW: Cancel Element-wise Operation
function handleCancelElementWise() {
    elementWiseGroup.style.display = 'none';
    firstArraySizeElementWise.value = '';
    secondArraySizeElementWise.value = '';
    firstArrayInputsElementWise.innerHTML = '';
    secondArrayInputsElementWise.innerHTML = '';
    performElementWiseBtn.style.display = 'none';
    
    elementWiseFirstArray = [];
    elementWiseSecondArray = [];
    elementWiseFirstArraySize = 0;
    elementWiseSecondArraySize = 0;
    currentElementWiseOperation = null;
    
    logOperation('Cancelled element-wise operation', 'info');
    showNotification('Element-wise operation cancelled', 'info');
}

// NEW: Show Element-wise Visualization
function showElementWiseVisualization() {
    isElementWiseOperationRunning = true;
    
    const operationName = currentElementWiseOperation === 'max' ? 'Maximum' : 'Minimum';
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Element-wise ${operationName} of Two Arrays</h5>
        
        <div class="array-group">
            <div class="array-label">First Array</div>
            <div class="original-array-container" id="firstArrayElementWise"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Second Array</div>
            <div class="original-array-container" id="secondArrayElementWise"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Element-wise ${operationName} Result</div>
            <div class="transformed-array-container" id="resultArrayElementWise"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Element-wise ${operationName}:</strong> Comparing corresponding elements and taking the ${currentElementWiseOperation === 'max' ? 'larger' : 'smaller'} value</p>
            <p class="mb-0" id="elementWiseExplanation">Starting element-wise ${operationName.toLowerCase()} operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="elementWiseStepsContainer">
            <h6 class="text-center">Element-wise ${operationName} Steps</h6>
            <div class="steps-container" id="elementWiseSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterElementWise" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display the input arrays
    renderArrayInContainer(elementWiseFirstArray, 'firstArrayElementWise');
    renderArrayInContainer(elementWiseSecondArray, 'secondArrayElementWise');
    renderArrayInContainer([], 'resultArrayElementWise');
    
    // Start element-wise animation
    performElementWiseAnimation();
}

// NEW: Perform Element-wise Animation
function performElementWiseAnimation() {
    const firstContainer = document.getElementById('firstArrayElementWise');
    const secondContainer = document.getElementById('secondArrayElementWise');
    const resultContainer = document.getElementById('resultArrayElementWise');
    const explanation = document.getElementById('elementWiseExplanation');
    const stepsContainer = document.getElementById('elementWiseSteps');
    const continueButton = document.getElementById('continueAfterElementWise');
    
    const operationName = currentElementWiseOperation === 'max' ? 'Maximum' : 'Minimum';
    let resultArray = [];
    let currentIndex = 0;
    
    function performElementWiseStep() {
        if (currentIndex >= elementWiseFirstArray.length) {
            // Operation completed
            explanation.innerHTML = `<strong>Element-wise ${operationName} Completed!</strong> All elements processed.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Element-wise ${operationName.toLowerCase()} operation completed. Result array: [${resultArray.join(', ')}]
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return to original after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterElementWise();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterElementWise);
            
            return;
        }
        
        const val1 = elementWiseFirstArray[currentIndex];
        const val2 = elementWiseSecondArray[currentIndex];
        
        // Update explanation
        explanation.innerHTML = `Comparing elements at index ${currentIndex}: ${val1} vs ${val2}`;
        
        // Highlight elements being compared
        const firstElements = firstContainer.querySelectorAll('.array-element');
        const secondElements = secondContainer.querySelectorAll('.array-element');
        
        firstElements[currentIndex].querySelector('.element-value').classList.add('element-wise-comparison');
        secondElements[currentIndex].querySelector('.element-value').classList.add('element-wise-comparison');
        
        // Determine result
        let resultValue;
        let sourceArray;
        
        if (currentElementWiseOperation === 'max') {
            resultValue = Math.max(val1, val2);
            sourceArray = val1 >= val2 ? 'first' : 'second';
        } else {
            resultValue = Math.min(val1, val2);
            sourceArray = val1 <= val2 ? 'first' : 'second';
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex + 1}:</strong> Compare [${currentIndex}]: ${val1} vs ${val2} - 
                ${operationName} = ${resultValue} (from ${sourceArray} array)
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Highlight the source element
            if (sourceArray === 'first') {
                firstElements[currentIndex].querySelector('.element-value').classList.add('element-wise-source');
            } else {
                secondElements[currentIndex].querySelector('.element-value').classList.add('element-wise-source');
            }
            
            setTimeout(() => {
                // Add result to result array
                resultArray.push(resultValue);
                
                // Update result array display
                renderArrayInContainer(resultArray, 'resultArrayElementWise');
                
                // Highlight the result element
                const resultElements = resultContainer.querySelectorAll('.array-element');
                const resultElement = resultElements[currentIndex].querySelector('.element-value');
                resultElement.classList.add(currentElementWiseOperation === 'max' ? 'element-wise-max-element' : 'element-wise-min-element');
                
                // Remove comparison highlights
                firstElements[currentIndex].querySelector('.element-value').classList.remove('element-wise-comparison', 'element-wise-source');
                secondElements[currentIndex].querySelector('.element-value').classList.remove('element-wise-comparison', 'element-wise-source');
                
                // Move to next index
                currentIndex++;
                performElementWiseStep();
            }, 1000);
        }, 1500);
    }
    
    // Start element-wise process
    performElementWiseStep();
}

// NEW: Return to Original after Element-wise Operation
function returnToOriginalAfterElementWise() {
    // Reset to original array
    myArray = [...originalArrayBeforeElementWise];
    originalArrayBeforeElementWise = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isElementWiseOperationRunning = false;
    
    // Clear all element-wise related data
    elementWiseFirstArray = [];
    elementWiseSecondArray = [];
    elementWiseFirstArraySize = 0;
    elementWiseSecondArraySize = 0;
    currentElementWiseOperation = null;
    
    // Reset input groups
    elementWiseGroup.style.display = 'none';
    firstArraySizeElementWise.value = '';
    secondArraySizeElementWise.value = '';
    firstArrayInputsElementWise.innerHTML = '';
    secondArrayInputsElementWise.innerHTML = '';
    performElementWiseBtn.style.display = 'none';
    
    const operationName = currentElementWiseOperation === 'max' ? 'maximum' : 'minimum';
    logOperation(`Element-wise ${operationName} operation completed - returned to original array`, 'info');
    showNotification('Returned to original array after element-wise operation', 'success');
}
// NEW: Handle Logical Operation
function handleLogicalOperation(operation) {
    if (isLogicalOperationRunning) {
        showNotification('A logical operation is already in progress', 'warning');
        return;
    }

    logicalOperationType = operation;
    logicalArrays = [];
    logicalArraysCount = 0;
    logicalArraysSizes = [];

    // Show input group
    logicalOperationsGroup.style.display = 'block';
    logicalArraysCountInput.focus();

    // Hide perform button initially
    performLogicalOperationBtn.style.display = 'none';

    logOperation(`Started element-wise logical ${operation} operation`, 'info');
    showNotification(`Please configure arrays for logical ${operation} operation`, 'info');
}

// NEW: Confirm Arrays Count Handler
function handleConfirmArraysCount() {
    const count = parseInt(logicalArraysCountInput.value);

    if (isNaN(count) || count < 2 || count > 5) {
        showNotification('Please enter a valid number of arrays between 2 and 5', 'danger');
        logicalArraysCountInput.focus();
        return;
    }

    logicalArraysCount = count;

    // Create size input fields for each array
    arraysSizeInputs.innerHTML = '<label class="form-label">Enter sizes for each array:</label>';
    for (let i = 0; i < count; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Array ${i + 1} Size</span>
            <input type="number" class="form-control logical-array-size" 
                   placeholder="Enter size" data-array="${i}" min="1" max="20">
        `;
        arraysSizeInputs.appendChild(inputGroup);
    }

    // Add event listeners for size inputs
    const sizeInputs = arraysSizeInputs.querySelectorAll('.logical-array-size');
    sizeInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('logical-array-size')) {
                    nextInput.focus();
                } else {
                    // All sizes entered, proceed to elements
                    handleConfirmArraysSizes();
                }
            }
        });
    });

    showNotification(`Configured ${count} arrays. Please enter sizes for each array.`, 'success');
}

// NEW: Handle Confirm Arrays Sizes
function handleConfirmArraysSizes() {
    const sizeInputs = arraysSizeInputs.querySelectorAll('.logical-array-size');
    logicalArraysSizes = [];

    // Collect sizes
    for (let i = 0; i < sizeInputs.length; i++) {
        const size = parseInt(sizeInputs[i].value);
        if (isNaN(size) || size < 1 || size > 20) {
            showNotification(`Please enter a valid size for Array ${i + 1} (1-20)`, 'danger');
            sizeInputs[i].focus();
            return;
        }
        logicalArraysSizes.push(size);
    }

    // Create element input fields
    arraysElementsInputs.innerHTML = '<label class="form-label">Enter elements for each array (0 or 1 for logical operations):</label>';
    
    for (let i = 0; i < logicalArraysCount; i++) {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'mb-3';
        arrayGroup.innerHTML = `<h6>Array ${i + 1} (Size: ${logicalArraysSizes[i]}):</h6>`;
        
        for (let j = 0; j < logicalArraysSizes[i]; j++) {
            const inputGroup = document.createElement('div');
            inputGroup.className = 'input-group mb-2';
            inputGroup.innerHTML = `
                <span class="input-group-text">Element ${j}</span>
                <input type="number" class="form-control logical-array-element" 
                       placeholder="Enter 0 or 1" data-array="${i}" data-index="${j}" min="0" max="1">
            `;
            arrayGroup.appendChild(inputGroup);
        }
        arraysElementsInputs.appendChild(arrayGroup);
    }

    // Add event listeners for element inputs
    const elementInputs = arraysElementsInputs.querySelectorAll('.logical-array-element');
    elementInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('logical-array-element')) {
                    nextInput.focus();
                }
            }
        });
    });

    // Show perform button
    performLogicalOperationBtn.style.display = 'block';
    performLogicalOperationBtn.innerHTML = `<i class="fas fa-play me-2"></i>Perform Logical ${logicalOperationType}`;

    showNotification(`Sizes confirmed. Please enter elements (0 or 1) for each array.`, 'success');
}

// NEW: Perform Logical Operation Handler
function handlePerformLogicalOperation() {
    logicalArrays = [];

    // Collect elements for each array
    for (let i = 0; i < logicalArraysCount; i++) {
        const arrayElements = [];
        const elements = arraysElementsInputs.querySelectorAll(`.logical-array-element[data-array="${i}"]`);
        
        for (let j = 0; j < elements.length; j++) {
            const value = elements[j].value.trim();
            if (value === '') {
                showNotification(`Please enter all elements for Array ${i + 1}. Missing element at position ${j}`, 'danger');
                elements[j].focus();
                return;
            }
            if (value !== '0' && value !== '1') {
                showNotification(`Please enter only 0 or 1 for logical operations. Invalid value at Array ${i + 1}, position ${j}`, 'danger');
                elements[j].focus();
                return;
            }
            arrayElements.push(parseInt(value));
        }
        logicalArrays.push(arrayElements);
    }

    // Check if all arrays have the same size
    const firstSize = logicalArrays[0].length;
    for (let i = 1; i < logicalArrays.length; i++) {
        if (logicalArrays[i].length !== firstSize) {
            showNotification('All arrays must have the same size for element-wise operations', 'danger');
            return;
        }
    }

    // Store original array
    originalArrayForLogical = [...myArray];

    // Hide input group
    logicalOperationsGroup.style.display = 'none';

    // Start logical operation visualization
    showLogicalOperationVisualization();
}

// NEW: Cancel Logical Operation Handler
function handleCancelLogicalOperation() {
    logicalOperationsGroup.style.display = 'none';
    logicalArraysCountInput.value = '';
    arraysSizeInputs.innerHTML = '';
    arraysElementsInputs.innerHTML = '';
    performLogicalOperationBtn.style.display = 'none';

    logicalArrays = [];
    logicalOperationType = '';
    logicalArraysCount = 0;
    logicalArraysSizes = [];

    logOperation('Cancelled logical operation', 'info');
    showNotification('Logical operation cancelled', 'info');
}

// NEW: Show Logical Operation Visualization
function showLogicalOperationVisualization() {
    isLogicalOperationRunning = true;

    const container = document.createElement('div');
    container.className = 'logical-operation-container';
    container.innerHTML = `
        <h5 class="text-center mb-3">Element-wise Logical ${logicalOperationType} Operation</h5>
        
        <div id="logicalArraysDisplay" class="mb-4"></div>
        
        <div class="operation-arrow text-center mb-3">
            <i class="fas fa-arrow-down fa-2x"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Result Array (Logical ${logicalOperationType})</div>
            <div class="transformed-array-container" id="logicalResultArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Logical ${logicalOperationType} Operation:</strong> Performing element-wise ${logicalOperationType.toLowerCase()} operation</p>
            <p class="mb-0" id="logicalExplanation">Starting logical operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="logicalStepsContainer">
            <h6 class="text-center">Logical Operation Steps</h6>
            <div class="steps-container" id="logicalSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterLogical" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;

    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(container);

    // Display input arrays
    displayLogicalArrays();

    // Start logical operation animation
    performLogicalOperationAnimation();
}

// NEW: Display Logical Arrays
function displayLogicalArrays() {
    const arraysDisplay = document.getElementById('logicalArraysDisplay');
    arraysDisplay.innerHTML = '';

    logicalArrays.forEach((array, index) => {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'array-group mb-3';
        arrayGroup.innerHTML = `
            <div class="array-label">Input Array ${index + 1}</div>
            <div class="original-array-container" id="logicalArray${index}"></div>
        `;
        arraysDisplay.appendChild(arrayGroup);
        renderArrayInContainer(array.map(val => val.toString()), `logicalArray${index}`);
    });
}

// NEW: Perform Logical Operation Animation
function performLogicalOperationAnimation() {
    const explanation = document.getElementById('logicalExplanation');
    const stepsContainer = document.getElementById('logicalSteps');
    const continueButton = document.getElementById('continueAfterLogical');

    const arraySize = logicalArrays[0].length;
    let resultArray = [];
    let currentIndex = 0;

    function performLogicalStep() {
        if (currentIndex >= arraySize) {
            // Operation completed
            explanation.innerHTML = `<strong>Logical ${logicalOperationType} Operation Completed!</strong>`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Logical ${logicalOperationType} operation completed. Result: [${resultArray.join(', ')}]
                </div>
            `;

            // Highlight the result array
            const resultElements = document.querySelectorAll('#logicalResultArray .array-element');
            resultElements.forEach((el, index) => {
                setTimeout(() => {
                    const valueDiv = el.querySelector('.element-value');
                    valueDiv.classList.add('logical-operation-result');
                }, index * 200);
            });

            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterLogical();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterLogical);
            
            return;
        }

        // Show current step
        explanation.innerHTML = `Processing element at index ${currentIndex}`;

        // Highlight current elements in all arrays
        for (let i = 0; i < logicalArraysCount; i++) {
            const arrayContainer = document.getElementById(`logicalArray${i}`);
            const elements = arrayContainer.querySelectorAll('.array-element');
            if (elements[currentIndex]) {
                const valueDiv = elements[currentIndex].querySelector('.element-value');
                valueDiv.classList.add('logical-operation-current');
                
                // Color based on value
                if (logicalArrays[i][currentIndex] === 1) {
                    valueDiv.classList.add('logical-true');
                } else {
                    valueDiv.classList.add('logical-false');
                }
            }
        }

        // Perform logical operation
        let result;
        if (logicalOperationType === 'AND') {
            result = logicalArrays.reduce((acc, array) => acc && array[currentIndex], 1);
        } else { // OR
            result = logicalArrays.reduce((acc, array) => acc || array[currentIndex], 0);
        }

        resultArray.push(result);

        // Update result array display
        renderArrayInContainer(resultArray.map(val => val.toString()), 'logicalResultArray');

        // Add step explanation
        const currentValues = logicalArrays.map(array => array[currentIndex]);
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex + 1}:</strong> 
                Values: [${currentValues.join(', ')}]  
                ${logicalOperationType} = ${result}
                (${currentValues.join(` ${logicalOperationType.toLowerCase()} `)} = ${result})
            </div>
        `;

        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;

        setTimeout(() => {
            // Remove highlights
            for (let i = 0; i < logicalArraysCount; i++) {
                const arrayContainer = document.getElementById(`logicalArray${i}`);
                const elements = arrayContainer.querySelectorAll('.array-element');
                if (elements[currentIndex]) {
                    const valueDiv = elements[currentIndex].querySelector('.element-value');
                    valueDiv.classList.remove('logical-operation-current', 'logical-true', 'logical-false');
                }
            }

            // Highlight result
            const resultContainer = document.getElementById('logicalResultArray');
            const resultElements = resultContainer.querySelectorAll('.array-element');
            if (resultElements[currentIndex]) {
                const resultValueDiv = resultElements[currentIndex].querySelector('.element-value');
                if (result === 1) {
                    resultValueDiv.classList.add('logical-true');
                } else {
                    resultValueDiv.classList.add('logical-false');
                }
            }

            currentIndex++;
            performLogicalStep();
        }, 2000);
    }

    // Start logical operation process
    performLogicalStep();
}

// NEW: Return to Original after Logical Operation
function returnToOriginalAfterLogical() {
    // Reset to original array
    myArray = [...originalArrayForLogical];
    originalArrayForLogical = [];

    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();

    // Reset state
    isLogicalOperationRunning = false;

    // Clear all logical operation data
    logicalArrays = [];
    logicalOperationType = '';
    logicalArraysCount = 0;
    logicalArraysSizes = [];

    // Reset input groups
    logicalOperationsGroup.style.display = 'none';
    logicalArraysCountInput.value = '';
    arraysSizeInputs.innerHTML = '';
    arraysElementsInputs.innerHTML = '';
    performLogicalOperationBtn.style.display = 'none';

    logOperation(`Logical ${logicalOperationType} operation completed - returned to original array`, 'info');
    showNotification(`Returned to original array after logical ${logicalOperationType} operation`, 'success');
}
// NEW: Calculate Standard Deviation Handler
function handleCalculateStdDev() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isStatsCalcRunning) {
        showNotification('A statistical operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Statistical operations require all array elements to be numbers', 'danger');
        return;
    }
    
    isStatsCalcRunning = true;
    
    // Store original array
    statsOriginalArray = [...myArray];
    
    // Show standard deviation visualization
    showStandardDeviationVisualization();
}

// NEW: Calculate Variance Handler
function handleCalculateVariance() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isStatsCalcRunning) {
        showNotification('A statistical operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Statistical operations require all array elements to be numbers', 'danger');
        return;
    }
    
    isStatsCalcRunning = true;
    
    // Store original array
    statsOriginalArray = [...myArray];
    
    // Show variance visualization
    showVarianceVisualization();
}

// NEW: Show Standard Deviation Visualization
function showStandardDeviationVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Standard Deviation Calculation</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalStatsArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Statistical Calculation Process</div>
            <div class="transformed-array-container" id="transformedStatsArray"></div>
        </div>
        
        <div class="statistical-results">
            <p class="mb-2"><strong>Standard Deviation Formula:</strong></p>
            <div class="statistical-formula">
                 = [ (x - ) / N ]
            </div>
            <p class="mb-0" id="statsExplanation">Starting standard deviation calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="statsStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="statsSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Standard Deviation ()</div>
            <div class="stats-value" id="stdDevValue">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterStats" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(statsOriginalArray, 'originalStatsArray');
    renderArrayInContainer([...statsOriginalArray], 'transformedStatsArray');
    
    performStandardDeviationCalculation();
}

// NEW: Show Variance Visualization
function showVarianceVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Variance Calculation</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalStatsArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Statistical Calculation Process</div>
            <div class="transformed-array-container" id="transformedStatsArray"></div>
        </div>
        
        <div class="statistical-results">
            <p class="mb-2"><strong>Variance Formula:</strong></p>
            <div class="statistical-formula">
                 = (x - ) / N
            </div>
            <p class="mb-0" id="statsExplanation">Starting variance calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="statsStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="statsSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Variance ()</div>
            <div class="stats-value" id="varianceValue">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterStats" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(statsOriginalArray, 'originalStatsArray');
    renderArrayInContainer([...statsOriginalArray], 'transformedStatsArray');
    
    performVarianceCalculation();
}

// NEW: Perform Standard Deviation Calculation with Animation
function performStandardDeviationCalculation() {
    const originalContainer = document.getElementById('originalStatsArray');
    const transformedContainer = document.getElementById('transformedStatsArray');
    const explanation = document.getElementById('statsExplanation');
    const stepsContainer = document.getElementById('statsSteps');
    const stdDevValue = document.getElementById('stdDevValue');
    const continueButton = document.getElementById('continueAfterStats');
    
    const arr = statsOriginalArray.map(val => parseFloat(val));
    const n = arr.length;
    let step = 0;
    let mean = 0;
    let sumSquaredDeviations = 0;
    let variance = 0;
    let stdDev = 0;
    
    function performCalculationStep() {
        switch (step) {
            case 0:
                // Step 1: Calculate mean
                explanation.innerHTML = "Step 1: Calculate the mean (average) of all elements";
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Calculate mean = (x) / N
                    </div>
                `;
                
                // Highlight all elements for mean calculation
                const originalElements = originalContainer.querySelectorAll('.array-element');
                originalElements.forEach((el, index) => {
                    setTimeout(() => {
                        el.querySelector('.element-value').classList.add('statistical-mean');
                    }, index * 200);
                });
                
                setTimeout(() => {
                    // Calculate mean
                    mean = arr.reduce((sum, val) => sum + val, 0) / n;
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Mean Calculation:</strong> (${arr.join(' + ')}) / ${n} = ${mean.toFixed(2)}
                        </div>
                    `;
                    step++;
                    performCalculationStep();
                }, n * 200 + 500);
                break;
                
            case 1:
                // Step 2: Calculate squared deviations
                explanation.innerHTML = "Step 2: Calculate squared deviations from mean for each element";
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Calculate (x - ) for each element
                    </div>
                `;
                
                let currentIndex = 0;
                
                function processDeviation(index) {
                    if (index >= n) {
                        step++;
                        performCalculationStep();
                        return;
                    }
                    
                    explanation.innerHTML = `Step 2: Calculating deviation for element [${index}] = ${arr[index]}`;
                    
                    const elements = transformedContainer.querySelectorAll('.array-element');
                    const currentElement = elements[index].querySelector('.element-value');
                    currentElement.classList.add('statistical-deviation');
                    
                    setTimeout(() => {
                        const deviation = arr[index] - mean;
                        const squaredDeviation = deviation * deviation;
                        sumSquaredDeviations += squaredDeviation;
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Element ${index}:</strong> (${arr[index]} - ${mean.toFixed(2)}) = ${squaredDeviation.toFixed(2)}
                            </div>
                        `;
                        
                        currentElement.classList.remove('statistical-deviation');
                        currentElement.classList.add('statistical-variance');
                        
                        processDeviation(index + 1);
                    }, 1000);
                }
                
                processDeviation(0);
                break;
                
            case 2:
                // Step 3: Calculate variance
                explanation.innerHTML = "Step 3: Calculate variance = (x - ) / N";
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Variance = ${sumSquaredDeviations.toFixed(2)} / ${n}
                    </div>
                `;
                
                setTimeout(() => {
                    variance = sumSquaredDeviations / n;
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Variance:</strong> ${variance.toFixed(2)}
                        </div>
                    `;
                    step++;
                    performCalculationStep();
                }, 1500);
                break;
                
            case 3:
                // Step 4: Calculate standard deviation
                explanation.innerHTML = "Step 4: Calculate standard deviation = variance";
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 4:</strong> Standard Deviation = ${variance.toFixed(2)}
                    </div>
                `;
                
                setTimeout(() => {
                    stdDev = Math.sqrt(variance);
                    stdDevValue.textContent = stdDev.toFixed(4);
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Standard Deviation:</strong> ${stdDev.toFixed(4)}
                        </div>
                    `;
                    
                    // Highlight final result
                    const elements = transformedContainer.querySelectorAll('.array-element');
                    elements.forEach(el => {
                        el.querySelector('.element-value').classList.add('statistical-stddev');
                    });
                    
                    explanation.innerHTML = `<strong>Calculation Complete!</strong> Standard Deviation = ${stdDev.toFixed(4)}`;
                    
                    continueButton.style.display = 'block';
                    
                    // Auto-return after 5 seconds
                    setTimeout(() => {
                        returnToOriginalAfterStats();
                    }, 5000);
                    
                    continueButton.addEventListener('click', returnToOriginalAfterStats);
                }, 1500);
                break;
        }
    }
    
    // Start calculation process
    performCalculationStep();
}

// NEW: Perform Variance Calculation with Animation
function performVarianceCalculation() {
    const originalContainer = document.getElementById('originalStatsArray');
    const transformedContainer = document.getElementById('transformedStatsArray');
    const explanation = document.getElementById('statsExplanation');
    const stepsContainer = document.getElementById('statsSteps');
    const varianceValue = document.getElementById('varianceValue');
    const continueButton = document.getElementById('continueAfterStats');
    
    const arr = statsOriginalArray.map(val => parseFloat(val));
    const n = arr.length;
    let step = 0;
    let mean = 0;
    let sumSquaredDeviations = 0;
    let variance = 0;
    
    function performCalculationStep() {
        switch (step) {
            case 0:
                // Step 1: Calculate mean
                explanation.innerHTML = "Step 1: Calculate the mean (average) of all elements";
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Calculate mean = (x) / N
                    </div>
                `;
                
                // Highlight all elements for mean calculation
                const originalElements = originalContainer.querySelectorAll('.array-element');
                originalElements.forEach((el, index) => {
                    setTimeout(() => {
                        el.querySelector('.element-value').classList.add('statistical-mean');
                    }, index * 200);
                });
                
                setTimeout(() => {
                    // Calculate mean
                    mean = arr.reduce((sum, val) => sum + val, 0) / n;
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Mean Calculation:</strong> (${arr.join(' + ')}) / ${n} = ${mean.toFixed(2)}
                        </div>
                    `;
                    step++;
                    performCalculationStep();
                }, n * 200 + 500);
                break;
                
            case 1:
                // Step 2: Calculate squared deviations
                explanation.innerHTML = "Step 2: Calculate squared deviations from mean for each element";
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Calculate (x - ) for each element
                    </div>
                `;
                
                let currentIndex = 0;
                
                function processDeviation(index) {
                    if (index >= n) {
                        step++;
                        performCalculationStep();
                        return;
                    }
                    
                    explanation.innerHTML = `Step 2: Calculating deviation for element [${index}] = ${arr[index]}`;
                    
                    const elements = transformedContainer.querySelectorAll('.array-element');
                    const currentElement = elements[index].querySelector('.element-value');
                    currentElement.classList.add('statistical-deviation');
                    
                    setTimeout(() => {
                        const deviation = arr[index] - mean;
                        const squaredDeviation = deviation * deviation;
                        sumSquaredDeviations += squaredDeviation;
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Element ${index}:</strong> (${arr[index]} - ${mean.toFixed(2)}) = ${squaredDeviation.toFixed(2)}
                            </div>
                        `;
                        
                        currentElement.classList.remove('statistical-deviation');
                        currentElement.classList.add('statistical-variance');
                        
                        processDeviation(index + 1);
                    }, 1000);
                }
                
                processDeviation(0);
                break;
                
            case 2:
                // Step 3: Calculate variance
                explanation.innerHTML = "Step 3: Calculate variance = (x - ) / N";
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Variance = ${sumSquaredDeviations.toFixed(2)} / ${n}
                    </div>
                `;
                
                setTimeout(() => {
                    variance = sumSquaredDeviations / n;
                    varianceValue.textContent = variance.toFixed(4);
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Variance:</strong> ${variance.toFixed(4)}
                        </div>
                    `;
                    
                    // Highlight final result
                    const elements = transformedContainer.querySelectorAll('.array-element');
                    elements.forEach(el => {
                        el.querySelector('.element-value').classList.add('statistical-variance');
                    });
                    
                    explanation.innerHTML = `<strong>Calculation Complete!</strong> Variance = ${variance.toFixed(4)}`;
                    
                    continueButton.style.display = 'block';
                    
                    // Auto-return after 5 seconds
                    setTimeout(() => {
                        returnToOriginalAfterStats();
                    }, 5000);
                    
                    continueButton.addEventListener('click', returnToOriginalAfterStats);
                }, 1500);
                break;
        }
    }
    
    // Start calculation process
    performCalculationStep();
}

// NEW: Return to Original after Statistical Operations
function returnToOriginalAfterStats() {
    // Reset to original array
    myArray = [...statsOriginalArray];
    statsOriginalArray = []; // Clear the stored array
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isStatsCalcRunning = false;
    
    logOperation('Statistical calculation completed - returned to original array', 'info');
    showNotification('Returned to original array after statistical calculation', 'success');
}
// NEW: Scalar Operations Handler
function handleScalarOperation(operation) {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isScalarOperationRunning) {
        showNotification('A scalar operation is already in progress', 'warning');
        return;
    }
    
    // Get the scalar value based on the operation
    let scalarInput;
    switch(operation) {
        case 'add': scalarInput = scalarValue; break;
        case 'subtract': scalarInput = scalarValueSubtract; break;
        case 'multiply': scalarInput = scalarValueMultiply; break;
        case 'divide': scalarInput = scalarValueDivide; break;
    }
    
    const scalar = parseFloat(scalarInput.value);
    
    if (isNaN(scalar)) {
        showNotification('Please enter a valid scalar value', 'danger');
        scalarInput.focus();
        return;
    }
    
    if (operation === 'divide' && scalar === 0) {
        showNotification('Cannot divide by zero', 'danger');
        scalarInput.focus();
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Scalar operations require all array elements to be numbers', 'danger');
        return;
    }
    
    isScalarOperationRunning = true;
    
    // Store original array
    originalArrayForScalar = [...myArray];
    
    // Perform scalar operation visualization
    performScalarOperationVisualization(operation, scalar);
}
// NEW: Perform Scalar Operation Visualization
function performScalarOperationVisualization(operation, scalar) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    
    const operationNames = {
        'add': 'Add',
        'subtract': 'Subtract', 
        'multiply': 'Multiply',
        'divide': 'Divide'
    };
    
    const operationSymbols = {
        'add': '+',
        'subtract': '-',
        'multiply': '',
        'divide': ''
    };
    
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Scalar Operation: ${operationNames[operation]} ${scalar}</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalScalarArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After ${operationNames[operation]} ${operationSymbols[operation]} ${scalar}</div>
            <div class="transformed-array-container" id="transformedScalarArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Scalar Operation:</strong> Applying ${operation} ${scalar} to every element</p>
            <p class="mb-0" id="scalarExplanation">Starting scalar operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="scalarStepsContainer">
            <h6 class="text-center">Scalar Operation Steps</h6>
            <div class="steps-container" id="scalarSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterScalar" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForScalar, 'originalScalarArray');
    renderArrayInContainer([...originalArrayForScalar], 'transformedScalarArray');
    
    performScalarOperationAnimation(operation, scalar);
}

// NEW: Perform Scalar Operation Animation
function performScalarOperationAnimation(operation, scalar) {
    const originalContainer = document.getElementById('originalScalarArray');
    const transformedContainer = document.getElementById('transformedScalarArray');
    const explanation = document.getElementById('scalarExplanation');
    const stepsContainer = document.getElementById('scalarSteps');
    const continueButton = document.getElementById('continueAfterScalar');
    
    const originalArray = [...originalArrayForScalar];
    let transformedArray = [...originalArray];
    let currentIndex = 0;
    
    function performScalarStep() {
        if (currentIndex >= originalArray.length) {
            // Operation completed
            explanation.innerHTML = `<strong>Scalar Operation Completed!</strong> Applied ${operation} ${scalar} to all elements.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Scalar operation completed on all ${originalArray.length} elements
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterScalar();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterScalar);
            
            return;
        }
        
        const originalValue = parseFloat(originalArray[currentIndex]);
        let newValue;
        
        switch(operation) {
            case 'add':
                newValue = originalValue + scalar;
                break;
            case 'subtract':
                newValue = originalValue - scalar;
                break;
            case 'multiply':
                newValue = originalValue * scalar;
                break;
            case 'divide':
                newValue = originalValue / scalar;
                break;
        }
        
        // Update explanation
        explanation.innerHTML = `Processing element [${currentIndex}]: ${originalValue} ${getOperationSymbol(operation)} ${scalar} = ${newValue.toFixed(2)}`;
        
        // Highlight current element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        
        const originalElement = originalElements[currentIndex].querySelector('.element-value');
        const transformedElement = transformedElements[currentIndex].querySelector('.element-value');
        
        originalElement.classList.add('transform-animation');
        transformedElement.classList.add('transform-animation');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex + 1}:</strong> [${currentIndex}] ${originalValue} ${getOperationSymbol(operation)} ${scalar} = ${newValue.toFixed(2)}
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Update the transformed array value
            transformedArray[currentIndex] = newValue.toString();
            renderArrayInContainer(transformedArray, 'transformedScalarArray');
            
            // Remove highlights
            originalElement.classList.remove('transform-animation');
            
            // Move to next element
            currentIndex++;
            performScalarStep();
        }, 1000);
    }
    
    // Helper function to get operation symbol
    function getOperationSymbol(op) {
        switch(op) {
            case 'add': return '+';
            case 'subtract': return '-';
            case 'multiply': return '';
            case 'divide': return '';
            default: return '?';
        }
    }
    
    // Start the scalar operation
    performScalarStep();
}

// NEW: Return to Original after Scalar Operation
function returnToOriginalAfterScalar() {
    // Reset to original array
    myArray = [...originalArrayForScalar];
    originalArrayForScalar = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isScalarOperationRunning = false;
    
    // Clear input fields
    scalarValue.value = '';
    scalarValueSubtract.value = '';
    scalarValueMultiply.value = '';
    scalarValueDivide.value = '';
    
    logOperation('Scalar operation completed - returned to original array', 'info');
    showNotification('Returned to original array after scalar operation', 'success');
}
// NEW: Trigonometric Operations Handler
function handleTrigOperation(operation) {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isTrigOperationRunning) {
        showNotification('A trigonometric operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains valid numbers for trigonometric operations
    let allValidNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        const num = parseFloat(myArray[i]);
        if (isNaN(num)) {
            allValidNumbers = false;
            break;
        }
    }
    
    if (!allValidNumbers) {
        showNotification('Trigonometric operations require all array elements to be valid numbers', 'danger');
        return;
    }
    
    isTrigOperationRunning = true;
    currentTrigOperation = operation;
    
    // Store original array
    originalArrayForTrig = [...myArray];
    
    // Show trigonometric operation visualization
    showTrigVisualization(operation);
}
// NEW: Show Trigonometric Visualization
function showTrigVisualization(operation) {
    const operationNames = {
        'sin': 'Sine',
        'cos': 'Cosine', 
        'tan': 'Tangent'
    };
    
    const operationIcons = {
        'sin': 'fa-wave-square',
        'cos': 'fa-wave-circle',
        'tan': 'fa-chart-line'
    };
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">${operationNames[operation]} Operation (in Radians)</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array (Radians)</div>
            <div class="original-array-container" id="originalTrigArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas ${operationIcons[operation]}"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">${operationNames[operation]} Values</div>
            <div class="transformed-array-container" id="transformedTrigArray"></div>
        </div>
        
        <div class="trig-explanation">
            <p class="mb-2"><strong>${operationNames[operation]} Function:</strong> Calculating ${operation} for each element in radians</p>
            <p class="mb-0" id="trigExplanation">Starting ${operationNames[operation].toLowerCase()} calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="trigStepsContainer">
            <h6 class="text-center">${operationNames[operation]} Calculation Steps</h6>
            <div class="steps-container" id="trigSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterTrig" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForTrig, 'originalTrigArray');
    renderArrayInContainer([...originalArrayForTrig], 'transformedTrigArray');
    
    performTrigAnimation(operation);
}
// NEW: Perform Trigonometric Animation
function performTrigAnimation(operation) {
    const originalContainer = document.getElementById('originalTrigArray');
    const transformedContainer = document.getElementById('transformedTrigArray');
    const explanation = document.getElementById('trigExplanation');
    const stepsContainer = document.getElementById('trigSteps');
    const continueButton = document.getElementById('continueAfterTrig');
    
    const operationNames = {
        'sin': 'Sine',
        'cos': 'Cosine',
        'tan': 'Tangent'
    };
    
    const operationFunctions = {
        'sin': (x) => Math.sin(x),
        'cos': (x) => Math.cos(x),
        'tan': (x) => Math.tan(x)
    };
    
    const originalArray = originalArrayForTrig.map(val => parseFloat(val));
    let transformedArray = [...originalArray];
    let currentIndex = 0;
    
    function performTrigStep() {
        if (currentIndex >= originalArray.length) {
            // Operation completed
            explanation.innerHTML = `<strong>${operationNames[operation]} Operation Completed!</strong> All elements processed.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> ${operationNames[operation]} calculation completed for all ${originalArray.length} elements
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterTrig();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterTrig);
            
            return;
        }
        
        const currentValue = originalArray[currentIndex];
        const trigValue = operationFunctions[operation](currentValue);
        
        // Update explanation
        explanation.innerHTML = `Calculating ${operation}(${currentValue}) = ${trigValue.toFixed(4)}`;
        
        // Highlight current element in original array
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentOriginalElement = originalElements[currentIndex].querySelector('.element-value');
        currentOriginalElement.classList.add('trig-operation-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex + 1}:</strong> ${operation}(${currentValue}) = ${trigValue.toFixed(4)}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Remove highlight from original element
            currentOriginalElement.classList.remove('trig-operation-current');
            currentOriginalElement.classList.add('trig-operation-original');
            
            // Update transformed array
            transformedArray[currentIndex] = trigValue.toFixed(4);
            renderArrayInContainer(transformedArray, 'transformedTrigArray');
            
            // Highlight the transformed element
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const currentTransformedElement = transformedElements[currentIndex].querySelector('.element-value');
            currentTransformedElement.classList.add('trig-operation-transformed');
            
            // Move to next element
            currentIndex++;
            performTrigStep();
        }, 2000);
    }
    
    // Start trigonometric operation
    performTrigStep();
}
// NEW: Return to Original after Trigonometric Operation
function returnToOriginalAfterTrig() {
    // Reset to original array
    myArray = [...originalArrayForTrig];
    originalArrayForTrig = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isTrigOperationRunning = false;
    currentTrigOperation = null;
    
    logOperation(`Trigonometric ${currentTrigOperation} operation completed - returned to original array`, 'info');
    showNotification('Returned to original array after trigonometric operation', 'success');
}
// NEW: Find Range Handler
function handleFindRange() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isRangeOperationRunning) {
        showNotification('A range operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Range calculation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isRangeOperationRunning = true;
    
    // Store original array
    originalArrayForRange = [...myArray];
    
    // Show range visualization
    showRangeVisualization();
}

// NEW: Show Range Visualization
function showRangeVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find Range (Max - Min) Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalRangeArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Range Finding Process</div>
            <div class="transformed-array-container" id="transformedRangeArray"></div>
        </div>
        
        <div class="range-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Linear Scan - Find minimum and maximum elements</p>
            <p class="mb-0" id="rangeExplanation">Initializing range calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="rangeStepsContainer">
            <h6 class="text-center">Range Calculation Steps</h6>
            <div class="steps-container" id="rangeSteps"></div>
        </div>
        
        <div class="range-result mt-3" id="rangeResult" style="display: none;">
            <h6 class="text-center">Range Result</h6>
            <div class="stats-card">
                <div>Minimum Element</div>
                <div class="stats-value" id="minValue">-</div>
            </div>
            <div class="stats-card">
                <div>Maximum Element</div>
                <div class="stats-value" id="maxValue">-</div>
            </div>
            <div class="stats-card">
                <div>Range (Max - Min)</div>
                <div class="stats-value" id="rangeValue">-</div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterRange" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForRange, 'originalRangeArray');
    renderArrayInContainer([...originalArrayForRange], 'transformedRangeArray');
    
    performRangeCalculation();
}

// NEW: Perform Range Calculation with Animation
function performRangeCalculation() {
    const originalContainer = document.getElementById('originalRangeArray');
    const transformedContainer = document.getElementById('transformedRangeArray');
    const explanation = document.getElementById('rangeExplanation');
    const stepsContainer = document.getElementById('rangeSteps');
    const rangeResult = document.getElementById('rangeResult');
    const minValue = document.getElementById('minValue');
    const maxValue = document.getElementById('maxValue');
    const rangeValue = document.getElementById('rangeValue');
    const continueButton = document.getElementById('continueAfterRange');
    
    const arr = originalArrayForRange.map(val => parseFloat(val));
    let min = arr[0];
    let max = arr[0];
    let minIndex = 0;
    let maxIndex = 0;
    let currentIndex = 0;
    let step = 0;
    
    function performRangeStep() {
        if (currentIndex >= arr.length) {
            // Range calculation completed
            const range = max - min;
            
            explanation.innerHTML = `<strong>Range Calculation Completed!</strong> Range = ${max} - ${min} = ${range}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Range = ${max} (max) - ${min} (min) = ${range}
                </div>
            `;
            
            // Highlight the final min and max elements
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            
            // Highlight min element
            setTimeout(() => {
                transformedElements[minIndex].querySelector('.element-value').classList.add('range-min');
            }, 500);
            
            // Highlight max element
            setTimeout(() => {
                transformedElements[maxIndex].querySelector('.element-value').classList.add('range-max');
            }, 1500);
            
            // Show results
            rangeResult.style.display = 'block';
            minValue.textContent = `${min} (index ${minIndex})`;
            maxValue.textContent = `${max} (index ${maxIndex})`;
            rangeValue.textContent = range;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterRange();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterRange);
            
            return;
        }
        
        step++;
        const currentValue = arr[currentIndex];
        
        explanation.innerHTML = `Step ${step}: Checking element at index ${currentIndex} = ${currentValue}`;
        
        // Highlight current element being checked
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        const currentElement = transformedElements[currentIndex].querySelector('.element-value');
        currentElement.classList.add('range-current');
        
        let stepDescription = '';
        let isNewMin = false;
        let isNewMax = false;
        
        if (currentValue < min) {
            min = currentValue;
            minIndex = currentIndex;
            stepDescription = `New minimum found! Min = ${min} at index ${minIndex}`;
            isNewMin = true;
        } else if (currentValue > max) {
            max = currentValue;
            maxIndex = currentIndex;
            stepDescription = `New maximum found! Max = ${max} at index ${maxIndex}`;
            isNewMax = true;
        } else {
            stepDescription = `Current: Min = ${min}, Max = ${max}`;
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${isNewMin || isNewMax ? 'active' : ''}">
                <strong>Step ${step}:</strong> [${currentIndex}] = ${currentValue} - ${stepDescription}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Remove current highlight
            currentElement.classList.remove('range-current');
            
            // Highlight if this is new min or max
            if (isNewMin) {
                // Remove previous min highlight if exists
                if (currentIndex !== minIndex) {
                    const previousMinElement = transformedElements[minIndex]?.querySelector('.element-value');
                    if (previousMinElement) {
                        previousMinElement.classList.remove('range-min');
                    }
                }
                currentElement.classList.add('range-min');
            }
            
            if (isNewMax) {
                // Remove previous max highlight if exists
                if (currentIndex !== maxIndex) {
                    const previousMaxElement = transformedElements[maxIndex]?.querySelector('.element-value');
                    if (previousMaxElement) {
                        previousMaxElement.classList.remove('range-max');
                    }
                }
                currentElement.classList.add('range-max');
            }
            
            // Move to next element
            currentIndex++;
            performRangeStep();
        }, 2000);
    }
    
    // Show algorithm explanation first
    explanation.innerHTML = `
        <strong>Linear Scan Algorithm:</strong><br>
        1. Initialize min and max with first element<br>
        2. Iterate through each element<br>
        3. Update min if current element is smaller<br>
        4. Update max if current element is larger<br>
        5. Calculate range = max - min
    `;
    
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Algorithm:</strong> Linear Scan - Time Complexity: O(n), Space Complexity: O(1)
        </div>
        <div class="algorithm-step active">
            <strong>Step 0:</strong> Initialize min = ${min}, max = ${max} (first element)
        </div>
    `;
    
    // Start with second element (index 1)
    currentIndex = 1;
    setTimeout(() => {
        performRangeStep();
    }, 3000);
}

// NEW: Return to Original after Range Operation
function returnToOriginalAfterRange() {
    // Reset to original array
    myArray = [...originalArrayForRange];
    originalArrayForRange = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isRangeOperationRunning = false;
    
    logOperation('Range calculation completed - returned to original array', 'info');
    showNotification('Returned to original array after range calculation', 'success');
}
// NEW: Mathematical Operations Handler
function handleMathOperation(operation) {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isMathOperationRunning) {
        showNotification('A mathematical operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains valid numbers
    let allValidNumbers = true;
    let hasInvalidForLog = false;
    
    for (let i = 0; i < myArray.length; i++) {
        const num = parseFloat(myArray[i]);
        if (isNaN(num)) {
            allValidNumbers = false;
            break;
        }
        // For log operations, check for non-positive numbers
        if ((operation === 'naturalLog' || operation === 'log10') && num <= 0) {
            hasInvalidForLog = true;
        }
    }
    
    if (!allValidNumbers) {
        showNotification('Mathematical operations require all array elements to be valid numbers', 'danger');
        return;
    }
    
    if (hasInvalidForLog) {
        showNotification('Logarithm operations require all array elements to be positive numbers (> 0)', 'danger');
        return;
    }
    
    isMathOperationRunning = true;
    currentMathOperation = operation;
    
    // Store original array
    originalArrayForMath = [...myArray];
    
    // Show mathematical operation visualization
    showMathOperationVisualization(operation);
}
// NEW: Show Mathematical Operation Visualization
function showMathOperationVisualization(operation) {
    const operationNames = {
        'exponential': 'Exponential (e^x)',
        'naturalLog': 'Natural Logarithm (ln x)',
        'log10': 'Base-10 Logarithm (log x)'
    };
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">${operationNames[operation]} Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalMathArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Transformed Array</div>
            <div class="transformed-array-container" id="transformedMathArray"></div>
        </div>
        
        <div class="math-explanation">
            <p class="mb-2"><strong>Mathematical Operation:</strong> Applying ${operationNames[operation]} to each element</p>
            <p class="mb-0" id="mathExplanation">Starting ${operationNames[operation]} calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="mathStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="mathSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMath" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForMath, 'originalMathArray');
    renderArrayInContainer([...originalArrayForMath], 'transformedMathArray');
    
    performMathOperationAnimation(operation);
}
// NEW: Perform Mathematical Operation Animation
function performMathOperationAnimation(operation) {
    const originalContainer = document.getElementById('originalMathArray');
    const transformedContainer = document.getElementById('transformedMathArray');
    const explanation = document.getElementById('mathExplanation');
    const stepsContainer = document.getElementById('mathSteps');
    const continueButton = document.getElementById('continueAfterMath');
    
    const originalArray = originalArrayForMath.map(val => parseFloat(val));
    let transformedArray = [...originalArray];
    let currentIndex = 0;
    
    const operationNames = {
        'exponential': 'Exponential',
        'naturalLog': 'Natural Logarithm',
        'log10': 'Base-10 Logarithm'
    };
    
    const operationSymbols = {
        'exponential': 'e^',
        'naturalLog': 'ln(',
        'log10': 'log('
    };
    
    function performMathStep() {
        if (currentIndex >= originalArray.length) {
            // Operation completed
            explanation.innerHTML = `<strong>${operationNames[operation]} Operation Completed!</strong> All elements processed.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> ${operationNames[operation]} operation completed on all ${originalArray.length} elements
                </div>
            `;
            
            // Highlight all transformed elements
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('math-operation-result');
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterMath();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterMath);
            
            return;
        }
        
        const originalValue = originalArray[currentIndex];
        let result;
        let calculation;
        
        // Perform the mathematical operation
        switch (operation) {
            case 'exponential':
                result = Math.exp(originalValue);
                calculation = `e^${originalValue} = ${result.toFixed(4)}`;
                break;
            case 'naturalLog':
                result = Math.log(originalValue);
                calculation = `ln(${originalValue}) = ${result.toFixed(4)}`;
                break;
            case 'log10':
                result = Math.log10(originalValue);
                calculation = `log(${originalValue}) = ${result.toFixed(4)}`;
                break;
        }
        
        // Update explanation
        explanation.innerHTML = `Processing element [${currentIndex}]: ${calculation}`;
        
        // Highlight current element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentIndex].querySelector('.element-value');
        currentElement.classList.add('math-operation-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex + 1}:</strong> ${operationSymbols[operation]}${originalValue}) = ${result.toFixed(4)}
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Update transformed array
            transformedArray[currentIndex] = result.toFixed(4);
            renderArrayInContainer(transformedArray, 'transformedMathArray');
            
            // Remove highlight from original and add to transformed
            currentElement.classList.remove('math-operation-current');
            
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const transformedElement = transformedElements[currentIndex].querySelector('.element-value');
            transformedElement.classList.add('math-operation-completed');
            
            // Move to next element
            currentIndex++;
            performMathStep();
        }, 1500);
    }
    
    // Add initial explanation
    stepsContainer.innerHTML = `
        <div class="algorithm-step active">
            <strong>Initialization:</strong> Starting ${operationNames[operation]} operation on array with ${originalArray.length} elements
        </div>
        <div class="algorithm-step">
            <strong>Formula:</strong> ${getMathFormula(operation)}
        </div>
    `;
    
    // Start the operation
    performMathStep();
}

// NEW: Get mathematical formula description
function getMathFormula(operation) {
    switch (operation) {
        case 'exponential':
            return 'f(x) = e^x, where e  2.71828 (Euler\'s number)';
        case 'naturalLog':
            return 'f(x) = ln(x), the natural logarithm (base e)';
        case 'log10':
            return 'f(x) = log(x), the base-10 logarithm';
        default:
            return '';
    }
}
// NEW: Return to Original after Math Operation
function returnToOriginalAfterMath() {
    // Reset to original array
    myArray = [...originalArrayForMath];
    originalArrayForMath = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMathOperationRunning = false;
    currentMathOperation = null;
    
    logOperation('Mathematical operation completed - returned to original array', 'info');
    showNotification('Returned to original array after mathematical operation', 'success');
}
// Pancake Sorting Handler
function handlePancakeSort() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isPancakeSortRunning) {
        showNotification('Pancake sort is already in progress', 'warning');
        return;
    }
    
    isPancakeSortRunning = true;
    
    // Store original array
    originalArrayForPancakeSort = [...myArray];
    
    // Show pancake sort visualization
    showPancakeSortVisualization();
}

// Show Pancake Sort Visualization
function showPancakeSortVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Pancake Sorting Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalPancakeArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Pancake Sorting Process</div>
            <div class="transformed-array-container" id="transformedPancakeArray"></div>
        </div>
        
        <div class="pancake-explanation">
            <p class="mb-2"><strong>Pancake Sorting:</strong> Sort array using only prefix reversals (flips)</p>
            <p class="mb-0" id="pancakeExplanation">Initializing pancake sort...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="pancakeStepsContainer">
            <h6 class="text-center">Pancake Sort Steps</h6>
            <div class="steps-container" id="pancakeSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPancake" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForPancakeSort, 'originalPancakeArray');
    renderArrayInContainer([...originalArrayForPancakeSort], 'transformedPancakeArray');
    
    performPancakeSortAnimation();
}

// Perform Pancake Sort Animation
function performPancakeSortAnimation() {
    const originalContainer = document.getElementById('originalPancakeArray');
    const transformedContainer = document.getElementById('transformedPancakeArray');
    const explanation = document.getElementById('pancakeExplanation');
    const stepsContainer = document.getElementById('pancakeSteps');
    const continueButton = document.getElementById('continueAfterPancake');
    
    let array = [...originalArrayForPancakeSort];
    const n = array.length;
    let currentSize = n;
    let step = 0;
    
    // Convert to numbers for comparison
    const isNumeric = !array.some(item => isNaN(parseFloat(item)));
    
    function performPancakeStep() {
        if (currentSize <= 1) {
            // Sorting completed
            explanation.innerHTML = `<strong>Pancake Sort Completed!</strong> Array sorted using prefix flips.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Array completely sorted using pancake sort algorithm
                </div>
            `;
            
            // Highlight all elements as sorted
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('pancake-sorted');
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterPancakeSort();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterPancakeSort);
            
            return;
        }
        
        step++;
        
        // Find the index of the maximum element in the current unsorted portion
        let maxIndex = 0;
        let maxValue = isNumeric ? parseFloat(array[0]) : array[0];
        
        for (let i = 1; i < currentSize; i++) {
            const currentValue = isNumeric ? parseFloat(array[i]) : array[i];
            if (currentValue > maxValue) {
                maxValue = currentValue;
                maxIndex = i;
            }
        }
        
        explanation.innerHTML = `Step ${step}: Find maximum element in unsorted portion (indices 0 to ${currentSize - 1})`;
        
        // Highlight the current unsorted portion and maximum element
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        
        // Highlight unsorted portion
        for (let i = 0; i < currentSize; i++) {
            transformedElements[i].querySelector('.element-value').classList.add('pancake-current');
        }
        
        // Highlight maximum element
        const maxElement = transformedElements[maxIndex].querySelector('.element-value');
        maxElement.classList.add('pancake-max');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> Found maximum element "${array[maxIndex]}" at index ${maxIndex} in unsorted portion [0-${currentSize - 1}]
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            if (maxIndex !== currentSize - 1) {
                // If maximum is not already at the end, we need to flip
                if (maxIndex !== 0) {
                    // Flip to bring maximum to the beginning
                    step++;
                    explanation.innerHTML = `Step ${step}: Flip prefix (0 to ${maxIndex}) to bring maximum to front`;
                    
                    // Highlight the flip range
                    for (let i = 0; i <= maxIndex; i++) {
                        transformedElements[i].querySelector('.element-value').classList.add('pancake-flip-range');
                        transformedElements[i].querySelector('.element-value').classList.add('pancake-flip-animation');
                    }
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step}:</strong> Flipping prefix from index 0 to ${maxIndex} to bring "${array[maxIndex]}" to front
                        </div>
                    `;
                    
                    setTimeout(() => {
                        // Perform the flip
                        for (let i = 0; i <= Math.floor(maxIndex / 2); i++) {
                            [array[i], array[maxIndex - i]] = [array[maxIndex - i], array[i]];
                        }
                        
                        // Update transformed array display
                        renderArrayInContainer(array, 'transformedPancakeArray');
                        
                        // Remove temporary highlights
                        const updatedElements = transformedContainer.querySelectorAll('.array-element');
                        for (let i = 0; i <= maxIndex; i++) {
                            updatedElements[i].querySelector('.element-value').classList.remove('pancake-flip-range', 'pancake-flip-animation');
                        }
                        
                        // Re-highlight unsorted portion
                        for (let i = 0; i < currentSize; i++) {
                            updatedElements[i].querySelector('.element-value').classList.add('pancake-current');
                        }
                        
                        // Now flip the entire unsorted portion to move maximum to the end
                        step++;
                        explanation.innerHTML = `Step ${step}: Flip entire unsorted portion (0 to ${currentSize - 1}) to move maximum to correct position`;
                        
                        // Highlight the flip range
                        for (let i = 0; i < currentSize; i++) {
                            updatedElements[i].querySelector('.element-value').classList.add('pancake-flip-range');
                            updatedElements[i].querySelector('.element-value').classList.add('pancake-flip-animation');
                        }
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Step ${step}:</strong> Flipping entire unsorted portion from index 0 to ${currentSize - 1} to move "${array[0]}" to its correct position
                            </div>
                        `;
                        
                        setTimeout(() => {
                            // Perform the flip
                            for (let i = 0; i < Math.floor(currentSize / 2); i++) {
                                [array[i], array[currentSize - 1 - i]] = [array[currentSize - 1 - i], array[i]];
                            }
                            
                            // Update transformed array display
                            renderArrayInContainer(array, 'transformedPancakeArray');
                            
                            // Mark the element at the end as sorted
                            const finalElements = transformedContainer.querySelectorAll('.array-element');
                            finalElements[currentSize - 1].querySelector('.element-value').classList.add('pancake-sorted');
                            
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step">
                                    <strong>Success:</strong> Maximum element "${array[currentSize - 1]}" now at correct position ${currentSize - 1}
                                </div>
                            `;
                            
                            // Reduce the unsorted portion size
                            currentSize--;
                            
                            // Continue to next step
                            performPancakeStep();
                        }, 1500);
                    }, 1500);
                } else {
                    // Maximum is already at the beginning, just flip the entire unsorted portion
                    step++;
                    explanation.innerHTML = `Step ${step}: Maximum is already at front, flip entire unsorted portion (0 to ${currentSize - 1})`;
                    
                    // Highlight the flip range
                    for (let i = 0; i < currentSize; i++) {
                        transformedElements[i].querySelector('.element-value').classList.add('pancake-flip-range');
                        transformedElements[i].querySelector('.element-value').classList.add('pancake-flip-animation');
                    }
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step}:</strong> Maximum is already at front, flipping entire unsorted portion from index 0 to ${currentSize - 1}
                        </div>
                    `;
                    
                    setTimeout(() => {
                        // Perform the flip
                        for (let i = 0; i < Math.floor(currentSize / 2); i++) {
                            [array[i], array[currentSize - 1 - i]] = [array[currentSize - 1 - i], array[i]];
                        }
                        
                        // Update transformed array display
                        renderArrayInContainer(array, 'transformedPancakeArray');
                        
                        // Mark the element at the end as sorted
                        const finalElements = transformedContainer.querySelectorAll('.array-element');
                        finalElements[currentSize - 1].querySelector('.element-value').classList.add('pancake-sorted');
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Success:</strong> Element "${array[currentSize - 1]}" now at correct position ${currentSize - 1}
                            </div>
                        `;
                        
                        // Reduce the unsorted portion size
                        currentSize--;
                        
                        // Continue to next step
                        performPancakeStep();
                    }, 1500);
                }
            } else {
                // Maximum is already at the correct position
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Skip:</strong> Maximum element "${array[maxIndex]}" is already at correct position ${currentSize - 1}
                    </div>
                `;
                
                // Mark as sorted
                transformedElements[currentSize - 1].querySelector('.element-value').classList.add('pancake-sorted');
                
                // Reduce the unsorted portion size
                currentSize--;
                
                // Continue to next step
                performPancakeStep();
            }
        }, 10000);
    }
    
    // Start pancake sort process
    performPancakeStep();
}

// Return to Original after Pancake Sort
function returnToOriginalAfterPancakeSort() {
    // Reset to original array
    myArray = [...originalArrayForPancakeSort];
    originalArrayForPancakeSort = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isPancakeSortRunning = false;
    
    logOperation('Pancake sort completed - returned to original array', 'info');
    showNotification('Returned to original array after pancake sort', 'success');
}
// NEW: Stock Span Problem Handler
function handleStockSpan() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isStockSpanRunning) {
        showNotification('Stock span calculation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers (prices)
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Stock span problem requires all array elements to be numbers (stock prices)', 'danger');
        return;
    }
    
    isStockSpanRunning = true;
    
    // Store original array
    originalArrayForStockSpan = [...myArray];
    
    // Show stock span visualization
    showStockSpanVisualization();
}
// NEW: Show Stock Span Visualization
function showStockSpanVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Stock Span Problem - Monotonic Stack Approach</h5>
        
        <div class="array-group">
            <div class="array-label">Stock Prices Array</div>
            <div class="original-array-container" id="stockPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Span Values</div>
            <div class="transformed-array-container" id="spanValuesArray"></div>
        </div>
        
        <div class="monotonic-stack-container">
            <div class="array-label">Monotonic Stack (Decreasing Order)</div>
            <div id="stackVisualization" class="mt-2"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Stock Span Problem:</strong> For each day, find how many consecutive days the price was less than or equal to current day</p>
            <p class="mb-0" id="stockSpanExplanation">Initializing stock span calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="stockSpanStepsContainer">
            <h6 class="text-center">Stock Span Calculation Steps</h6>
            <div class="steps-container" id="stockSpanSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterStockSpan" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderStockSpanArrays();
    performStockSpanAnimation();
}
// NEW: Render Stock Span Arrays
function renderStockSpanArrays() {
    const pricesArray = document.getElementById('stockPricesArray');
    const spanArray = document.getElementById('spanValuesArray');
    
    pricesArray.innerHTML = '';
    spanArray.innerHTML = '';
    
    originalArrayForStockSpan.forEach((price, index) => {
        // Price element
        const priceElement = document.createElement('div');
        priceElement.className = 'array-element';
        priceElement.innerHTML = `
            <div class="element-value">${price}</div>
            <div class="element-index">Day ${index}</div>
        `;
        pricesArray.appendChild(priceElement);
        
        // Span element (initially empty)
        const spanElement = document.createElement('div');
        spanElement.className = 'array-element';
        spanElement.innerHTML = `
            <div class="element-value">?</div>
            <div class="element-index">Span ${index}</div>
        `;
        spanArray.appendChild(spanElement);
    });
}

// NEW: Perform Stock Span Animation
function performStockSpanAnimation() {
    const pricesArray = document.getElementById('stockPricesArray');
    const spanArray = document.getElementById('spanValuesArray');
    const stackVisualization = document.getElementById('stackVisualization');
    const explanation = document.getElementById('stockSpanExplanation');
    const stepsContainer = document.getElementById('stockSpanSteps');
    const continueButton = document.getElementById('continueAfterStockSpan');
    
    const prices = originalArrayForStockSpan.map(val => parseFloat(val));
    const spans = new Array(prices.length).fill(0);
    const stack = [];
    let currentDay = 0;
    let step = 0;
    
    function performSpanStep() {
        if (currentDay >= prices.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Stock Span Calculation Completed!</strong> All span values calculated.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Stock span calculation completed for all ${prices.length} days
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterStockSpan();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterStockSpan);
            
            return;
        }
        
        step++;
        explanation.innerHTML = `Day ${currentDay}: Processing price ${prices[currentDay]}`;
        
        // Highlight current price
        const priceElements = pricesArray.querySelectorAll('.array-element');
        const currentPriceElement = priceElements[currentDay].querySelector('.element-value');
        currentPriceElement.classList.add('stock-span-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> Processing Day ${currentDay}, Price = ${prices[currentDay]}
            </div>
        `;
        
        setTimeout(() => {
            // Pop from stack while stack is not empty and top is less than current price
            let spanValue = 1;
            
            function processStack() {
                if (stack.length === 0) {
                    spans[currentDay] = currentDay + 1;
                    updateStackVisualization();
                    updateSpanDisplay();
                    moveToNextDay();
                    return;
                }
                
                const topIndex = stack[stack.length - 1];
                const topPrice = prices[topIndex];
                
                // Highlight comparison
                const topPriceElement = priceElements[topIndex].querySelector('.element-value');
                topPriceElement.classList.add('stock-span-compared');
                
                explanation.innerHTML = `Day ${currentDay}: Comparing with Day ${topIndex} (Price: ${topPrice})`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step}.${stack.length}:</strong> Compare with Day ${topIndex} (Price: ${topPrice})
                    </div>
                `;
                
                setTimeout(() => {
                    if (topPrice <= prices[currentDay]) {
                        // Pop from stack
                        stack.pop();
                        topPriceElement.classList.remove('stock-span-compared');
                        topPriceElement.classList.add('stock-span-greater');
                        
                        explanation.innerHTML = `Day ${currentDay}: Price ${topPrice}  ${prices[currentDay]}, popping from stack`;
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Step ${step}.${stack.length}:</strong> Popping Day ${topIndex} from stack
                            </div>
                        `;
                        
                        setTimeout(() => {
                            topPriceElement.classList.remove('stock-span-greater');
                            updateStackVisualization();
                            processStack();
                        }, 1000);
                    } else {
                        // Found greater price
                        spans[currentDay] = currentDay - topIndex;
                        topPriceElement.classList.remove('stock-span-compared');
                        
                        explanation.innerHTML = `Day ${currentDay}: Found greater price at Day ${topIndex}`;
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Step ${step}.${stack.length}:</strong> Found greater price, span = ${currentDay} - ${topIndex} = ${spans[currentDay]}
                            </div>
                        `;
                        
                        setTimeout(() => {
                            updateSpanDisplay();
                            moveToNextDay();
                        }, 1000);
                    }
                }, 1500);
            }
            
            function moveToNextDay() {
                // Push current day to stack
                stack.push(currentDay);
                currentPriceElement.classList.remove('stock-span-current');
                currentPriceElement.classList.add('stock-span-result');
                
                explanation.innerHTML = `Day ${currentDay}: Span = ${spans[currentDay]}, pushing to stack`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step}:</strong> Day ${currentDay} completed, span = ${spans[currentDay]}
                    </div>
                `;
                
                setTimeout(() => {
                    currentPriceElement.classList.remove('stock-span-result');
                    currentDay++;
                    updateStackVisualization();
                    performSpanStep();
                }, 1000);
            }
            
            function updateSpanDisplay() {
                const spanElements = spanArray.querySelectorAll('.array-element');
                const currentSpanElement = spanElements[currentDay].querySelector('.element-value');
                currentSpanElement.textContent = spans[currentDay];
                currentSpanElement.classList.add('stock-span-result');
                
                setTimeout(() => {
                    currentSpanElement.classList.remove('stock-span-result');
                }, 500);
            }
            
            function updateStackVisualization() {
                stackVisualization.innerHTML = '';
                stack.forEach(dayIndex => {
                    const stackItem = document.createElement('div');
                    stackItem.className = 'stack-item';
                    stackItem.textContent = `Day ${dayIndex}: ${prices[dayIndex]}`;
                    if (dayIndex === currentDay) {
                        stackItem.classList.add('active');
                    }
                    stackVisualization.appendChild(stackItem);
                });
            }
            
            // Start processing stack
            processStack();
            
        }, 1000);
    }
    
    // Start stock span calculation
    performSpanStep();
}

// NEW: Return to Original after Stock Span
function returnToOriginalAfterStockSpan() {
    // Reset to original array
    myArray = [...originalArrayForStockSpan];
    originalArrayForStockSpan = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isStockSpanRunning = false;
    
    logOperation('Stock span calculation completed - returned to original array', 'info');
    showNotification('Returned to original array after stock span calculation', 'success');
}
// NEW: Max Pair AND/OR Handler
function handleMaxPairAndOr() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isMaxPairAndOrRunning) {
        showNotification('Max pair AND/OR operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseInt(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('AND/OR operations require all array elements to be integers', 'danger');
        return;
    }
    
    isMaxPairAndOrRunning = true;
    
    // Store original array
    originalArrayForMaxPair = [...myArray];
    
    // Show AND/OR pair visualization
    showMaxPairAndOrVisualization();
}

// NEW: Show Max Pair AND/OR Visualization
function showMaxPairAndOrVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Maximum AND/OR Pair Operations</h5>
        
        <!-- Results Section at the Top -->
        <div class="logical-results mb-4" id="logicalResults" style="display: none;">
            <h6 class="text-center mb-3">Results</h6>
            <div class="row">
                <div class="col-md-6">
                    <div class="stats-card">
                        <div>Maximum AND Pair</div>
                        <div class="stats-value" id="andPairIndices">-</div>
                        <div class="stats-value" id="andPairValues">-</div>
                        <div class="stats-value" id="andPairBinary">-</div>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="stats-card">
                        <div>Maximum OR Pair</div>
                        <div class="stats-value" id="orPairIndices">-</div>
                        <div class="stats-value" id="orPairValues">-</div>
                        <div class="stats-value" id="orPairBinary">-</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalMaxPairArray"></div>
        </div>
        
        <div class="operation-explanation mt-3">
            <p class="mb-2"><strong>Logical Operations:</strong> Finding pairs with maximum AND and OR values</p>
            <p class="mb-0" id="maxPairExplanation">Initializing AND/OR pair search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="maxPairStepsContainer">
            <h6 class="text-center">AND/OR Pair Search Steps</h6>
            <div class="steps-container" id="maxPairSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMaxPair" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForMaxPair, 'originalMaxPairArray');
    
    performMaxPairAndOrAnimation();
}

// NEW: Perform Max Pair AND/OR Animation
function performMaxPairAndOrAnimation() {
    const arrayContainer = document.getElementById('originalMaxPairArray');
    const explanation = document.getElementById('maxPairExplanation');
    const stepsContainer = document.getElementById('maxPairSteps');
    const logicalResults = document.getElementById('logicalResults');
    const continueButton = document.getElementById('continueAfterMaxPair');
    
    // Result elements
    const andPairIndices = document.getElementById('andPairIndices');
    const andPairValues = document.getElementById('andPairValues');
    const andPairBinary = document.getElementById('andPairBinary');
    const orPairIndices = document.getElementById('orPairIndices');
    const orPairValues = document.getElementById('orPairValues');
    const orPairBinary = document.getElementById('orPairBinary');
    
    const arr = originalArrayForMaxPair.map(val => parseInt(val));
    let maxAndValue = -Infinity;
    let maxOrValue = -Infinity;
    let maxAndPair = [-1, -1];
    let maxOrPair = [-1, -1];
    let step = 0;
    let i = 0, j = 1;
    
    // Initialize results display
    logicalResults.style.display = 'block';
    andPairIndices.textContent = 'Searching...';
    andPairValues.textContent = '-';
    andPairBinary.textContent = '-';
    orPairIndices.textContent = 'Searching...';
    orPairValues.textContent = '-';
    orPairBinary.textContent = '-';
    
    function performAndOrStep() {
        if (i >= arr.length - 1) {
            // Algorithm completed
            explanation.innerHTML = `<strong>AND/OR Pair Search Completed!</strong> Found maximum AND and OR pairs.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Maximum AND pair: [${maxAndPair[0]},${maxAndPair[1]}] = ${maxAndValue}<br>
                    Maximum OR pair: [${maxOrPair[0]},${maxOrPair[1]}] = ${maxOrValue}
                </div>
            `;
            
            // Update final results
            updateResultsDisplay();
            
            // Highlight the results
            const elements = arrayContainer.querySelectorAll('.array-element');
            
            // Highlight AND pair
            setTimeout(() => {
                elements[maxAndPair[0]].querySelector('.element-value').classList.add('max-and-pair');
                elements[maxAndPair[1]].querySelector('.element-value').classList.add('max-and-pair');
            }, 500);
            
            // Highlight OR pair
            setTimeout(() => {
                elements[maxOrPair[0]].querySelector('.element-value').classList.add('max-or-pair');
                elements[maxOrPair[1]].querySelector('.element-value').classList.add('max-or-pair');
            }, 1500);
            
            continueButton.style.display = 'block';
            
            // Auto-return after 8 seconds
            setTimeout(() => {
                returnToOriginalAfterMaxPair();
            }, 8000);
            
            continueButton.addEventListener('click', returnToOriginalAfterMaxPair);
            
            return;
        }
        
        if (j >= arr.length) {
            // Move to next i
            i++;
            j = i + 1;
            performAndOrStep();
            return;
        }
        
        step++;
        
        // Update explanation
        explanation.innerHTML = `Step ${step}: Checking pair [${i},${j}] = (${arr[i]}, ${arr[j]})`;
        
        // Highlight current pair
        const elements = arrayContainer.querySelectorAll('.array-element');
        const elementI = elements[i].querySelector('.element-value');
        const elementJ = elements[j].querySelector('.element-value');
        
        elementI.classList.add('and-pair-current');
        elementJ.classList.add('and-pair-current');
        
        // Calculate AND and OR values
        const andValue = arr[i] & arr[j];
        const orValue = arr[i] | arr[j];
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Pair [${i},${j}] = (${arr[i]}, ${arr[j]})<br>
                AND: ${arr[i]} & ${arr[j]} = ${andValue}<br>
                OR: ${arr[i]} | ${arr[j]} = ${orValue}
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Remove current highlights
            elementI.classList.remove('and-pair-current');
            elementJ.classList.remove('and-pair-current');
            
            // Update maximum values
            let updatedAnd = false;
            let updatedOr = false;
            
            if (andValue > maxAndValue) {
                maxAndValue = andValue;
                maxAndPair = [i, j];
                updatedAnd = true;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>New Max AND:</strong> [${i},${j}] = ${andValue}
                    </div>
                `;
                
                // Update results display
                updateResultsDisplay();
                
                // Briefly highlight new max AND pair
                elementI.classList.add('max-and-pair');
                elementJ.classList.add('max-and-pair');
                setTimeout(() => {
                    elementI.classList.remove('max-and-pair');
                    elementJ.classList.remove('max-and-pair');
                }, 1000);
            }
            
            if (orValue > maxOrValue) {
                maxOrValue = orValue;
                maxOrPair = [i, j];
                updatedOr = true;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>New Max OR:</strong> [${i},${j}] = ${orValue}
                    </div>
                `;
                
                // Update results display
                updateResultsDisplay();
                
                // Briefly highlight new max OR pair
                elementI.classList.add('max-or-pair');
                elementJ.classList.add('max-or-pair');
                setTimeout(() => {
                    elementI.classList.remove('max-or-pair');
                    elementJ.classList.remove('max-or-pair');
                }, 1000);
            }
            
            // Move to next pair
            j++;
            performAndOrStep();
        }, 1500);
    }
    
    // Helper function to update results display
    function updateResultsDisplay() {
        // Update AND pair results
        if (maxAndPair[0] !== -1 && maxAndPair[1] !== -1) {
            andPairIndices.textContent = `Indices: [${maxAndPair[0]}, ${maxAndPair[1]}]`;
            andPairValues.textContent = `Values: ${arr[maxAndPair[0]]} & ${arr[maxAndPair[1]]} = ${maxAndValue}`;
            andPairBinary.textContent = `Binary: ${arr[maxAndPair[0]].toString(2)} & ${arr[maxAndPair[1]].toString(2)} = ${maxAndValue.toString(2)}`;
        }
        
        // Update OR pair results
        if (maxOrPair[0] !== -1 && maxOrPair[1] !== -1) {
            orPairIndices.textContent = `Indices: [${maxOrPair[0]}, ${maxOrPair[1]}]`;
            orPairValues.textContent = `Values: ${arr[maxOrPair[0]]} | ${arr[maxOrPair[1]]} = ${maxOrValue}`;
            orPairBinary.textContent = `Binary: ${arr[maxOrPair[0]].toString(2)} | ${arr[maxOrPair[1]].toString(2)} = ${maxOrValue.toString(2)}`;
        }
    }
    
    // Start the algorithm
    performAndOrStep();
}

// NEW: Return to Original after Max Pair Operation
function returnToOriginalAfterMaxPair() {
    // Reset to original array
    myArray = [...originalArrayForMaxPair];
    originalArrayForMaxPair = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMaxPairAndOrRunning = false;
    
    logOperation('Max pair AND/OR operation completed - returned to original array', 'info');
    showNotification('Returned to original array after AND/OR pair search', 'success');
}
// NEW: Largest Rectangle in Histogram Handler
function handleLargestRectangleHistogram() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isHistogramRunning) {
        showNotification('Histogram operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains positive numbers
    let allPositiveNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        const num = parseFloat(myArray[i]);
        if (isNaN(num) || num < 0) {
            allPositiveNumbers = false;
            break;
        }
    }
    
    if (!allPositiveNumbers) {
        showNotification('Histogram requires all array elements to be non-negative numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForHistogram = [...myArray];
    
    // Show histogram visualization
    showHistogramVisualization();
}

// NEW: Show Histogram Visualization
function showHistogramVisualization() {
    isHistogramRunning = true;
    
    const histogramContainer = document.createElement('div');
    histogramContainer.className = 'glass-card';
    histogramContainer.innerHTML = `
        <h4 class="text-center mb-4">Largest Rectangle in Histogram</h4>
        
        <div class="histogram-container" id="histogramBarsContainer">
            <!-- Histogram bars will be rendered here -->
        </div>
        
        <div class="row mt-4">
            <div class="col-md-6">
                <div class="stack-visualization">
                    <h6>Stack Status</h6>
                    <div id="stackContainer"></div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="area-calculation">
                    <h6>Current Calculation</h6>
                    <div id="currentCalculation"></div>
                    <div class="area-formula" id="areaFormula">
                        Area = height  width<br>
                        width = right - left - 1
                    </div>
                </div>
            </div>
        </div>
        
        <div class="algorithm-steps mt-3">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="histogramSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Maximum Area Found</div>
            <div class="stats-value" id="maxAreaValue">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Maximum Rectangle Indices</div>
            <div class="stats-value" id="maxAreaIndices">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3 w-100" id="continueAfterHistogram" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(histogramContainer);
    
    renderHistogramBars();
    performLargestRectangleAlgorithm();
}

// NEW: Render Histogram Bars
function renderHistogramBars() {
    const container = document.getElementById('histogramBarsContainer');
    container.innerHTML = '';
    
    const heights = originalArrayForHistogram.map(val => parseFloat(val));
    const maxHeight = Math.max(...heights);
    
    heights.forEach((height, index) => {
        const barContainer = document.createElement('div');
        barContainer.className = 'histogram-bar-container';
        
        const barHeight = (height / maxHeight) * 300;
        const bar = document.createElement('div');
        bar.className = 'element-value histogram-bar';
        bar.style.height = `${barHeight}px`;
        bar.style.setProperty('--bar-height', `${barHeight}px`);
        bar.textContent = height;
        bar.setAttribute('data-index', index);
        bar.setAttribute('data-height', height);
        
        const label = document.createElement('div');
        label.className = 'histogram-bar-label';
        label.textContent = `Index ${index}`;
        
        barContainer.appendChild(bar);
        barContainer.appendChild(label);
        container.appendChild(barContainer);
    });
}

// NEW: Perform Largest Rectangle Algorithm with Animation
function performLargestRectangleAlgorithm() {
    const heights = originalArrayForHistogram.map(val => parseFloat(val));
    const stack = [];
    let maxArea = 0;
    let maxStart = -1;
    let maxEnd = -1;
    let maxHeight = 0;
    let step = 0;
    let i = 0;
    
    const stepsContainer = document.getElementById('histogramSteps');
    const stackContainer = document.getElementById('stackContainer');
    const currentCalculation = document.getElementById('currentCalculation');
    const maxAreaValue = document.getElementById('maxAreaValue');
    const maxAreaIndices = document.getElementById('maxAreaIndices');
    const continueButton = document.getElementById('continueAfterHistogram');
    
    function updateStackVisualization() {
        stackContainer.innerHTML = '';
        stack.forEach((item, idx) => {
            const stackItem = document.createElement('div');
            stackItem.className = `stack-item ${idx === stack.length - 1 ? 'active' : ''}`;
            stackItem.textContent = `Index: ${item.index}, Height: ${heights[item.index]}`;
            stackContainer.appendChild(stackItem);
        });
        
        if (stack.length === 0) {
            const emptyMsg = document.createElement('div');
            emptyMsg.className = 'text-muted text-center';
            emptyMsg.textContent = 'Stack is empty';
            stackContainer.appendChild(emptyMsg);
        }
    }
    
    function highlightBar(index, className) {
        const bars = document.querySelectorAll('.histogram-bar');
        if (bars[index]) {
            bars[index].classList.add(className);
        }
    }
    
    function removeBarHighlight(index, className) {
        const bars = document.querySelectorAll('.histogram-bar');
        if (bars[index]) {
            bars[index].classList.remove(className);
        }
    }
    
    function removeAllHighlights() {
        const bars = document.querySelectorAll('.histogram-bar');
        bars.forEach(bar => {
            bar.classList.remove('histogram-current', 'histogram-in-stack', 'histogram-max-area', 
                               'histogram-left-boundary', 'histogram-right-boundary');
        });
    }
    
    function showAreaCalculation(index, height, left, right, area) {
        const formula = document.getElementById('areaFormula');
        formula.innerHTML = `
            Area = height  width<br>
            = ${height}  (${right} - ${left} - 1)<br>
            = ${height}  ${right - left - 1}<br>
            = ${area}
        `;
        
        // Highlight the area being calculated
        removeAllHighlights();
        highlightBar(index, 'histogram-current');
        
        for (let j = left + 1; j < right; j++) {
            if (j !== index) {
                highlightBar(j, 'histogram-in-stack');
            }
        }
        
        if (left >= 0) highlightBar(left, 'histogram-left-boundary');
        if (right < heights.length) highlightBar(right, 'histogram-right-boundary');
        
        // Show area visualization
        showAreaVisualization(left + 1, right - 1, height, area);
    }
    
    function showAreaVisualization(start, end, height, area) {
        // Remove existing area displays
        const existingAreas = document.querySelectorAll('.histogram-area-display');
        existingAreas.forEach(area => area.remove());
        
        if (start <= end) {
            const bars = document.querySelectorAll('.histogram-bar-container');
            const startRect = bars[start].getBoundingClientRect();
            const endRect = bars[end].getBoundingClientRect();
            const containerRect = document.getElementById('histogramBarsContainer').getBoundingClientRect();
            
            const areaDisplay = document.createElement('div');
            areaDisplay.className = 'histogram-area-display';
            areaDisplay.style.left = `${startRect.left - containerRect.left}px`;
            areaDisplay.style.top = `${containerRect.top - containerRect.top}px`;
            areaDisplay.style.width = `${endRect.right - startRect.left}px`;
            areaDisplay.textContent = `Area: ${area}`;
            
            document.getElementById('histogramBarsContainer').appendChild(areaDisplay);
        }
    }
    
    function performAlgorithmStep() {
        if (i <= heights.length) {
            const currentHeight = i < heights.length ? heights[i] : 0;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${i < heights.length ? 'active' : ''}">
                    <strong>Step ${step + 1}:</strong> 
                    ${i < heights.length ? 
                        `Processing index ${i}, height = ${currentHeight}` : 
                        'Processing remaining elements in stack'}
                </div>
            `;
            
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            // Highlight current bar
            if (i < heights.length) {
                removeAllHighlights();
                highlightBar(i, 'histogram-current');
                
                // Highlight stack elements
                stack.forEach(item => {
                    highlightBar(item.index, 'histogram-in-stack');
                });
            }
            
            setTimeout(() => {
                if (stack.length === 0 || (i < heights.length && heights[stack[stack.length - 1].index] <= currentHeight)) {
                    if (i < heights.length) {
                        stack.push({ index: i, height: currentHeight });
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Action:</strong> Pushed index ${i} to stack (height ${currentHeight})
                            </div>
                        `;
                        i++;
                        step++;
                        updateStackVisualization();
                        performAlgorithmStep();
                    } else {
                        i++;
                        performAlgorithmStep();
                    }
                } else {
                    // Pop from stack and calculate area
                    const top = stack.pop();
                    const height = heights[top.index];
                    const left = stack.length === 0 ? -1 : stack[stack.length - 1].index;
                    const right = i;
                    const width = right - left - 1;
                    const area = height * width;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Calculation:</strong> 
                            Popped index ${top.index}, height = ${height}<br>
                            Left boundary = ${left}, Right boundary = ${right}<br>
                            Width = ${right} - ${left} - 1 = ${width}<br>
                            Area = ${height}  ${width} = ${area}
                        </div>
                    `;
                    
                    showAreaCalculation(top.index, height, left, right, area);
                    
                    if (area > maxArea) {
                        maxArea = area;
                        maxStart = left + 1;
                        maxEnd = right - 1;
                        maxHeight = height;
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>New Maximum!</strong> 
                                Area ${area} > previous max ${maxArea - area + area}
                            </div>
                        `;
                        
                        maxAreaValue.textContent = maxArea;
                        maxAreaIndices.textContent = `Indices ${maxStart}-${maxEnd}, Height ${maxHeight}`;
                        
                        // Highlight the new maximum area
                        removeAllHighlights();
                        for (let j = maxStart; j <= maxEnd; j++) {
                            highlightBar(j, 'histogram-max-area');
                        }
                    }
                    
                    updateStackVisualization();
                    step++;
                    
                    setTimeout(() => {
                        performAlgorithmStep();
                    }, 2000);
                }
            }, 1500);
        } else {
            // Algorithm completed
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Algorithm Completed!</strong> 
                    Maximum rectangular area = ${maxArea}
                </div>
            `;
            
            // Final highlight of maximum area
            removeAllHighlights();
            for (let j = maxStart; j <= maxEnd; j++) {
                highlightBar(j, 'histogram-max-area');
            }
            
            showAreaVisualization(maxStart, maxEnd, maxHeight, maxArea);
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterHistogram();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterHistogram);
        }
    }
    
    // Start algorithm
    updateStackVisualization();
    performAlgorithmStep();
}

// NEW: Return to Original after Histogram
function returnToOriginalAfterHistogram() {
    // Reset to original array
    myArray = [...originalArrayForHistogram];
    originalArrayForHistogram = [];
    
    // Remove histogram visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isHistogramRunning = false;
    
    logOperation('Largest rectangle in histogram completed - returned to original array', 'info');
    showNotification('Returned to original array after histogram operation', 'success');
}
// NEW: Fruit Into Baskets Handler
function handleFruitIntoBaskets() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isFruitBasketRunning) {
        showNotification('Fruit into baskets operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains valid fruit types (numbers)
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseInt(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Fruit into baskets requires all elements to be numbers (fruit types)', 'danger');
        return;
    }
    
    isFruitBasketRunning = true;
    
    // Store original array
    originalArrayForFruitBasket = [...myArray];
    
    // Show fruit basket visualization
    showFruitBasketVisualization();
}
// NEW: Show Fruit Basket Visualization
function showFruitBasketVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Fruit Into Baskets Problem</h5>
        
        <div class="array-group">
            <div class="array-label">Fruit Trees Array</div>
            <div class="original-array-container" id="fruitBasketArray"></div>
        </div>
        
        <div class="basket-explanation">
            <p class="mb-2"><strong>Problem:</strong> Find maximum consecutive fruits you can pick with 2 baskets</p>
            <p class="mb-0" id="basketExplanation">Initializing sliding window with two baskets...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="basketStepsContainer">
            <h6 class="text-center">Sliding Window Steps</h6>
            <div class="steps-container" id="basketSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Current Basket Fruits</div>
            <div class="stats-value" id="currentBasketFruits">-</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Maximum Fruits Found</div>
            <div class="stats-value" id="maxFruitsValue">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Current Window</div>
            <div class="stats-value" id="currentWindow">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterBasket" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForFruitBasket, 'fruitBasketArray');
    
    performFruitBasketAlgorithm();
}
// NEW: Perform Fruit Basket Algorithm with Animation
function performFruitBasketAlgorithm() {
    const arrayContainer = document.getElementById('fruitBasketArray');
    const explanation = document.getElementById('basketExplanation');
    const stepsContainer = document.getElementById('basketSteps');
    const currentBasketFruits = document.getElementById('currentBasketFruits');
    const maxFruitsValue = document.getElementById('maxFruitsValue');
    const currentWindow = document.getElementById('currentWindow');
    const continueButton = document.getElementById('continueAfterBasket');
    
    const fruits = originalArrayForFruitBasket.map(val => parseInt(val));
    let left = 0;
    let maxFruits = 0;
    let basket = new Map(); // fruit type -> count
    let step = 0;
    
    function executeBasketStep(right) {
        if (right >= fruits.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Maximum fruits = ${maxFruits}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Maximum fruits you can pick = ${maxFruits}
                </div>
            `;
            
            // Highlight the final maximum window
            const elements = arrayContainer.querySelectorAll('.array-element');
            for (let i = left; i < fruits.length; i++) {
                if (i - left < maxFruits) {
                    setTimeout(() => {
                        elements[i].querySelector('.element-value').classList.add('basket-max');
                    }, (i - left) * 200);
                }
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterBasket();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterBasket);
            
            return;
        }
        
        step++;
        
        // Add current fruit to basket
        const currentFruit = fruits[right];
        basket.set(currentFruit, (basket.get(currentFruit) || 0) + 1);
        
        explanation.innerHTML = `Step ${step}: Adding fruit type ${currentFruit} at index ${right}`;
        
        // Highlight current fruit being added
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElement = elements[right].querySelector('.element-value');
        currentElement.classList.add('basket-current');
        
        // Update basket display
        const basketTypes = Array.from(basket.keys()).join(', ');
        const basketCounts = Array.from(basket.values()).join(', ');
        currentBasketFruits.textContent = `Types: [${basketTypes}], Counts: [${basketCounts}]`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Added fruit ${currentFruit} at index ${right}
            </div>
        `;
        
        setTimeout(() => {
            currentElement.classList.remove('basket-current');
            currentElement.classList.add('basket-fruit');
            
            // If basket has more than 2 types, shrink from left
            if (basket.size > 2) {
                explanation.innerHTML = `Step ${step}: Too many fruit types (${basket.size}), removing from left`;
                
                const shrinkStep = () => {
                    if (basket.size > 2 && left <= right) {
                        const leftFruit = fruits[left];
                        basket.set(leftFruit, basket.get(leftFruit) - 1);
                        
                        if (basket.get(leftFruit) === 0) {
                            basket.delete(leftFruit);
                        }
                        
                        // Highlight removal
                        const leftElement = elements[left].querySelector('.element-value');
                        leftElement.classList.add('basket-removed');
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Step ${step}.${left}:</strong> Removed fruit ${leftFruit} from index ${left}
                            </div>
                        `;
                        
                        setTimeout(() => {
                            leftElement.classList.remove('basket-removed', 'basket-fruit');
                            left++;
                            
                            // Update current window display
                            currentWindow.textContent = `[${left}, ${right}]`;
                            
                            shrinkStep();
                        }, 800);
                    } else {
                        // Continue with next right pointer
                        updateMaxAndContinue(right);
                    }
                };
                
                shrinkStep();
            } else {
                updateMaxAndContinue(right);
            }
            
            function updateMaxAndContinue(right) {
                // Update max fruits
                const currentLength = right - left + 1;
                if (currentLength > maxFruits) {
                    maxFruits = currentLength;
                    
                    // Highlight the new maximum window
                    for (let i = left; i <= right; i++) {
                        elements[i].querySelector('.element-value').classList.add('basket-max');
                    }
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step}:</strong> New maximum! Fruits = ${maxFruits} (indices ${left}-${right})
                        </div>
                    `;
                }
                
                maxFruitsValue.textContent = maxFruits;
                currentWindow.textContent = `[${left}, ${right}]`;
                
                // Scroll steps container
                stepsContainer.scrollTop = stepsContainer.scrollHeight;
                
                // Move to next right pointer
                setTimeout(() => {
                    executeBasketStep(right + 1);
                }, 1000);
            }
        }, 800);
    }
    
    // Start algorithm execution
    executeBasketStep(0);
}
// NEW: Return to Original after Fruit Basket
function returnToOriginalAfterBasket() {
    // Reset to original array
    myArray = [...originalArrayForFruitBasket];
    originalArrayForFruitBasket = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isFruitBasketRunning = false;
    
    logOperation('Fruit into baskets operation completed - returned to original array', 'info');
    showNotification('Returned to original array after fruit basket operation', 'success');
}
// NEW: Element-wise Operation Handler
function handleElementWiseOperation(operation) {
    if (isElementWiseOpRunning) {
        showNotification('An element-wise operation is already in progress', 'warning');
        return;
    }

    // Reset arrays
    elemWiseFirstArray = [];
    elemWiseSecondArray = [];
    elemWiseFirstSize = 0;
    elemWiseSecondSize = 0;
    currentElementWiseOp = operation;
    
    // Show input group
    elementWiseOperationGroup.style.display = 'block';
    elementWiseFirstArraySizeInput.focus();
    
    // Hide perform operation button initially
    performElementWiseOperationBtn.style.display = 'none';
    
    // Set button text based on operation
    const operationNames = {
        'add': 'Addition',
        'subtract': 'Subtraction', 
        'multiply': 'Multiplication',
        'divide': 'Division',
        'modulus': 'Modulus'
    };
    
    performElementWiseOperationBtn.innerHTML = 
        `<i class="fas fa-play me-2"></i>Perform ${operationNames[operation]} Operation`;
    
    logOperation(`Started element-wise ${operationNames[operation]} operation`, 'info');
}

// NEW: Confirm Element-wise First Array Size Handler
function handleConfirmElementWiseFirstArraySize() {
    const size = parseInt(elementWiseFirstArraySizeInput.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        elementWiseFirstArraySizeInput.focus();
        return;
    }
    
    elemWiseFirstSize = size;
    elemWiseFirstArray = [];
    
    // Create input fields for first array
    elementWiseFirstArrayInputs.innerHTML = '<label class="form-label">Enter numeric elements for First Array:</label>';
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="number" class="form-control element-wise-first-array-element" 
                   placeholder="Enter number" data-index="${i}" step="any">
        `;
        elementWiseFirstArrayInputs.appendChild(inputGroup);
    }
    
    showNotification(`First array size set to ${size}. Please enter ${size} numeric elements.`, 'success');
    logOperation(`First array size set to ${size} for element-wise operation`, 'info');
}

// NEW: Confirm Element-wise Second Array Size Handler
function handleConfirmElementWiseSecondArraySize() {
    const size = parseInt(elementWiseSecondArraySizeInput.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        elementWiseSecondArraySizeInput.focus();
        return;
    }
    
    if (size !== elemWiseFirstSize) {
        showNotification(`Second array size must match first array size (${elemWiseFirstSize})`, 'danger');
        return;
    }
    
    elemWiseSecondSize = size;
    elemWiseSecondArray = [];
    
    // Create input fields for second array
    elementWiseSecondArrayInputs.innerHTML = '<label class="form-label">Enter numeric elements for Second Array:</label>';
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="number" class="form-control element-wise-second-array-element" 
                   placeholder="Enter number" data-index="${i}" step="any">
        `;
        elementWiseSecondArrayInputs.appendChild(inputGroup);
    }
    
    // Show perform operation button
    performElementWiseOperationBtn.style.display = 'block';
    
    showNotification(`Second array size set to ${size}. Please enter ${size} numeric elements.`, 'success');
    logOperation(`Second array size set to ${size} for element-wise operation`, 'info');
}

// NEW: Perform Element-wise Operation Handler
function handlePerformElementWiseOperation() {
    // Collect first array elements
    const firstArrayInputs = document.querySelectorAll('.element-wise-first-array-element');
    elemWiseFirstArray = [];
    
    for (let i = 0; i < firstArrayInputs.length; i++) {
        const value = firstArrayInputs[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all elements for first array. Missing element at position ${i}`, 'danger');
            firstArrayInputs[i].focus();
            return;
        }
        if (isNaN(parseFloat(value))) {
            showNotification(`Please enter valid numbers only. Invalid value at position ${i}`, 'danger');
            firstArrayInputs[i].focus();
            return;
        }
        elemWiseFirstArray.push(parseFloat(value));
    }
    
    // Collect second array elements
    const secondArrayInputs = document.querySelectorAll('.element-wise-second-array-element');
    elemWiseSecondArray = [];
    
    for (let i = 0; i < secondArrayInputs.length; i++) {
        const value = secondArrayInputs[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all elements for second array. Missing element at position ${i}`, 'danger');
            secondArrayInputs[i].focus();
            return;
        }
        if (isNaN(parseFloat(value))) {
            showNotification(`Please enter valid numbers only. Invalid value at position ${i}`, 'danger');
            secondArrayInputs[i].focus();
            return;
        }
        elemWiseSecondArray.push(parseFloat(value));
    }
    
    // Store original array
    originalArrayBeforeElemWise = [...myArray];
    
    // Hide input group
    elementWiseOperationGroup.style.display = 'none';
    
    // Start element-wise operation visualization
    showElementWiseOperationVisualization();
}

// NEW: Cancel Element-wise Operation Handler
function handleCancelElementWiseOperation() {
    elementWiseOperationGroup.style.display = 'none';
    elementWiseFirstArraySizeInput.value = '';
    elementWiseSecondArraySizeInput.value = '';
    elementWiseFirstArrayInputs.innerHTML = '';
    elementWiseSecondArrayInputs.innerHTML = '';
    performElementWiseOperationBtn.style.display = 'none';
    
    elemWiseFirstArray = [];
    elemWiseSecondArray = [];
    elemWiseFirstSize = 0;
    elemWiseSecondSize = 0;
    currentElementWiseOp = null;
    
    logOperation('Cancelled element-wise operation', 'info');
    showNotification('Element-wise operation cancelled', 'info');
}

// NEW: Show Element-wise Operation Visualization
function showElementWiseOperationVisualization() {
    isElementWiseOpRunning = true;
    
    const operationNames = {
        'add': 'Addition',
        'subtract': 'Subtraction',
        'multiply': 'Multiplication (Hadamard)',
        'divide': 'Division',
        'modulus': 'Modulus'
    };
    
    const operationSymbols = {
        'add': '+',
        'subtract': '-',
        'multiply': '',
        'divide': '',
        'modulus': '%'
    };
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'element-wise-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Element-wise ${operationNames[currentElementWiseOp]}</h5>
        
        <div class="element-wise-array-group">
            <div class="array-label">First Array (A)</div>
            <div class="original-array-container" id="elementWiseFirstArrayDisplay"></div>
        </div>
        
        <div class="element-wise-arrow">
            <i class="fas fa-${operationSymbols[currentElementWiseOp]}"></i>
        </div>
        
        <div class="element-wise-array-group">
            <div class="array-label">Second Array (B)</div>
            <div class="original-array-container" id="elementWiseSecondArrayDisplay"></div>
        </div>
        
        <div class="element-wise-arrow">
            <i class="fas fa-equals"></i>
        </div>
        
        <div class="element-wise-array-group">
            <div class="array-label">Result Array (A ${operationSymbols[currentElementWiseOp]} B)</div>
            <div class="transformed-array-container" id="elementWiseResultArrayDisplay"></div>
        </div>
        
        <div class="element-wise-explanation">
            <p class="mb-2"><strong>Element-wise ${operationNames[currentElementWiseOp]}:</strong> Performing operation on corresponding elements</p>
            <p class="mb-0" id="elementWiseExplanation">Starting element-wise operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="elementWiseStepsContainer">
            <h6 class="text-center">Element-wise Operation Steps</h6>
            <div class="steps-container" id="elementWiseSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterElementWise" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display the input arrays
    renderArrayInContainer(elemWiseFirstArray, 'elementWiseFirstArrayDisplay');
    renderArrayInContainer(elemWiseSecondArray, 'elementWiseSecondArrayDisplay');
    renderArrayInContainer([], 'elementWiseResultArrayDisplay');
    
    // Start element-wise operation animation
    performElementWiseOperationAnimation();
}

// NEW: Perform Element-wise Operation Animation
function performElementWiseOperationAnimation() {
    const firstContainer = document.getElementById('elementWiseFirstArrayDisplay');
    const secondContainer = document.getElementById('elementWiseSecondArrayDisplay');
    const resultContainer = document.getElementById('elementWiseResultArrayDisplay');
    const explanation = document.getElementById('elementWiseExplanation');
    const stepsContainer = document.getElementById('elementWiseSteps');
    const continueButton = document.getElementById('continueAfterElementWise');
    
    const operationNames = {
        'add': 'addition',
        'subtract': 'subtraction',
        'multiply': 'multiplication',
        'divide': 'division',
        'modulus': 'modulus'
    };
    
    const operationSymbols = {
        'add': '+',
        'subtract': '-',
        'multiply': '',
        'divide': '',
        'modulus': '%'
    };
    
    let resultArray = [];
    let currentIndex = 0;
    
    function performElementWiseStep() {
        if (currentIndex >= elemWiseFirstArray.length) {
            // Operation completed
            explanation.innerHTML = `<strong>Element-wise ${operationNames[currentElementWiseOp]} Completed!</strong> All elements processed.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Element-wise ${operationNames[currentElementWiseOp]} completed! Result: [${resultArray.join(', ')}]
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterElementWise();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterElementWise);
            
            return;
        }
        
        const step = currentIndex + 1;
        const a = elemWiseFirstArray[currentIndex];
        const b = elemWiseSecondArray[currentIndex];
        
        explanation.innerHTML = `Step ${step}: Processing element at index ${currentIndex}`;
        
        // Highlight current elements being processed
        const firstElements = firstContainer.querySelectorAll('.array-element');
        const secondElements = secondContainer.querySelectorAll('.array-element');
        
        if (currentIndex < firstElements.length) {
            firstElements[currentIndex].querySelector('.element-value').classList.add('element-wise-highlight');
        }
        if (currentIndex < secondElements.length) {
            secondElements[currentIndex].querySelector('.element-value').classList.add('element-wise-highlight');
        }
        
        // Calculate result based on operation
        let result;
        let operationText;
        
        switch (currentElementWiseOp) {
            case 'add':
                result = a + b;
                operationText = `${a} + ${b} = ${result}`;
                break;
            case 'subtract':
                result = a - b;
                operationText = `${a} - ${b} = ${result}`;
                break;
            case 'multiply':
                result = a * b;
                operationText = `${a}  ${b} = ${result}`;
                break;
            case 'divide':
                if (b === 0) {
                    result = 'Undefined (division by zero)';
                    operationText = `${a}  ${b} = Undefined`;
                } else {
                    result = a / b;
                    operationText = `${a}  ${b} = ${result.toFixed(2)}`;
                }
                break;
            case 'modulus':
                if (b === 0) {
                    result = 'Undefined (modulus by zero)';
                    operationText = `${a} % ${b} = Undefined`;
                } else {
                    result = a % b;
                    operationText = `${a} % ${b} = ${result}`;
                }
                break;
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> A[${currentIndex}] ${operationSymbols[currentElementWiseOp]} B[${currentIndex}] = ${operationText}
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Remove highlights from input arrays
            if (currentIndex < firstElements.length) {
                firstElements[currentIndex].querySelector('.element-value').classList.remove('element-wise-highlight');
            }
            if (currentIndex < secondElements.length) {
                secondElements[currentIndex].querySelector('.element-value').classList.remove('element-wise-highlight');
            }
            
            // Add result to result array
            if (typeof result === 'number') {
                resultArray.push(result);
            } else {
                resultArray.push(result);
            }
            
            // Update result array display
            renderArrayInContainer(resultArray, 'elementWiseResultArrayDisplay');
            
            // Highlight the new result element
            const resultElements = resultContainer.querySelectorAll('.array-element');
            if (currentIndex < resultElements.length) {
                resultElements[currentIndex].querySelector('.element-value').classList.add('element-wise-result');
            }
            
            currentIndex++;
            performElementWiseStep();
        }, 1500);
    }
    
    // Start element-wise operation process
    performElementWiseStep();
}

// NEW: Return to Original after Element-wise Operation
function returnToOriginalAfterElementWise() {
    // Reset to original array
    myArray = [...originalArrayBeforeElemWise];
    originalArrayBeforeElemWise = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isElementWiseOpRunning = false;
    
    // Clear all element-wise operation data
    elemWiseFirstArray = [];
    elemWiseSecondArray = [];
    elemWiseFirstSize = 0;
    elemWiseSecondSize = 0;
    currentElementWiseOp = null;
    
    // Reset input groups
    elementWiseOperationGroup.style.display = 'none';
    elementWiseFirstArraySizeInput.value = '';
    elementWiseSecondArraySizeInput.value = '';
    elementWiseFirstArrayInputs.innerHTML = '';
    elementWiseSecondArrayInputs.innerHTML = '';
    performElementWiseOperationBtn.style.display = 'none';
    
    logOperation('Element-wise operation completed - returned to original array', 'info');
    showNotification('Returned to original array after element-wise operation', 'success');
}
// NEW: Logical NOT Handler
function handleLogicalNot() {
    if (isLogicalOpRunning) {
        showNotification('A logical operation is already in progress', 'warning');
        return;
    }

    // Reset and show NOT input group
    logicalNotGroup.style.display = 'block';
    logicalXorGroup.style.display = 'none';
    logicalNotSize.focus();
    
    logOperation('Started element-wise logical NOT operation', 'info');
}

// NEW: Logical XOR Handler
function handleLogicalXor() {
    if (isLogicalOpRunning) {
        showNotification('A logical operation is already in progress', 'warning');
        return;
    }

    // Reset and show XOR input group
    logicalXorGroup.style.display = 'block';
    logicalNotGroup.style.display = 'none';
    logicalXorArrayCount.focus();
    
    logOperation('Started element-wise logical XOR operation', 'info');
}

// NEW: Confirm Logical NOT Size Handler
function handleConfirmLogicalNotSize() {
    const size = parseInt(logicalNotSize.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        logicalNotSize.focus();
        return;
    }
    
    // Create input fields for array elements
    logicalNotInputs.innerHTML = '<label class="form-label">Enter binary elements (0 or 1):</label>';
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="number" class="form-control logical-not-element" 
                   placeholder="Enter 0 or 1" min="0" max="1" data-index="${i}">
        `;
        logicalNotInputs.appendChild(inputGroup);
    }
    
    // Add perform button
    const performBtn = document.createElement('button');
    performBtn.className = 'btn btn-glow w-100 mt-2';
    performBtn.innerHTML = '<i class="fas fa-play me-2"></i>Perform Logical NOT Operation';
    performBtn.addEventListener('click', handlePerformLogicalNot);
    logicalNotInputs.appendChild(performBtn);
    
    showNotification(`Array size set to ${size}. Please enter ${size} binary elements.`, 'success');
}

// NEW: Confirm Logical XOR Array Count Handler
function handleConfirmLogicalXorArrayCount() {
    const arrayCount = parseInt(logicalXorArrayCount.value);
    
    if (isNaN(arrayCount) || arrayCount < 2 || arrayCount > 5) {
        showNotification('Please enter a valid number of arrays between 2 and 5', 'danger');
        logicalXorArrayCount.focus();
        return;
    }
    
    // Create input fields for array sizes
    logicalXorSizeInputs.innerHTML = '<label class="form-label">Enter sizes for each array:</label>';
    for (let i = 0; i < arrayCount; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Array ${i+1} Size</span>
            <input type="number" class="form-control logical-xor-size" 
                   placeholder="Enter size" min="1" max="20" data-index="${i}">
        `;
        logicalXorSizeInputs.appendChild(inputGroup);
    }
    
    // Add confirm sizes button
    const confirmSizesBtn = document.createElement('button');
    confirmSizesBtn.className = 'btn btn-glow w-100 mt-2';
    confirmSizesBtn.innerHTML = '<i class="fas fa-check me-2"></i>Confirm Array Sizes';
    confirmSizesBtn.addEventListener('click', handleConfirmLogicalXorSizes);
    logicalXorSizeInputs.appendChild(confirmSizesBtn);
    
    showNotification(`Number of arrays set to ${arrayCount}. Please enter sizes for each array.`, 'success');
}

// NEW: Confirm Logical XOR Sizes Handler
function handleConfirmLogicalXorSizes() {
    const arrayCount = parseInt(logicalXorArrayCount.value);
    const sizeInputs = document.querySelectorAll('.logical-xor-size');
    
    logicalOpArrays = [];
    let allSizesValid = true;
    
    for (let i = 0; i < arrayCount; i++) {
        const size = parseInt(sizeInputs[i].value);
        if (isNaN(size) || size < 1 || size > 20) {
            showNotification(`Please enter a valid size for Array ${i+1}`, 'danger');
            sizeInputs[i].focus();
            allSizesValid = false;
            break;
        }
        logicalOpArrays.push({ size: size, elements: [] });
    }
    
    if (!allSizesValid) return;
    
    // Create input fields for array elements
    logicalXorElementInputs.innerHTML = '<label class="form-label">Enter binary elements (0 or 1) for each array:</label>';
    
    for (let i = 0; i < arrayCount; i++) {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'mb-3';
        arrayGroup.innerHTML = `<h6>Array ${i+1} (Size: ${logicalOpArrays[i].size})</h6>`;
        
        for (let j = 0; j < logicalOpArrays[i].size; j++) {
            const inputGroup = document.createElement('div');
            inputGroup.className = 'input-group mb-2';
            inputGroup.innerHTML = `
                <span class="input-group-text">Element ${j}</span>
                <input type="number" class="form-control logical-xor-element" 
                       placeholder="Enter 0 or 1" min="0" max="1" 
                       data-array="${i}" data-index="${j}">
            `;
            arrayGroup.appendChild(inputGroup);
        }
        logicalXorElementInputs.appendChild(arrayGroup);
    }
    
    // Add perform button
    const performBtn = document.createElement('button');
    performBtn.className = 'btn btn-glow w-100 mt-2';
    performBtn.innerHTML = '<i class="fas fa-play me-2"></i>Perform Logical XOR Operation';
    performBtn.addEventListener('click', handlePerformLogicalXor);
    logicalXorElementInputs.appendChild(performBtn);
    
    showNotification('Array sizes confirmed. Please enter binary elements for each array.', 'success');
}

// NEW: Perform Logical NOT Operation
function handlePerformLogicalNot() {
    const elementInputs = document.querySelectorAll('.logical-not-element');
    const inputArray = [];
    
    // Collect and validate elements
    for (let i = 0; i < elementInputs.length; i++) {
        const value = parseInt(elementInputs[i].value);
        if (isNaN(value) || (value !== 0 && value !== 1)) {
            showNotification(`Please enter valid binary value (0 or 1) for element ${i}`, 'danger');
            elementInputs[i].focus();
            return;
        }
        inputArray.push(value);
    }
    
    // Store original array
    originalArrayForLogicalOps = [...inputArray];
    logicalOpType = 'NOT';
    
    // Hide input group
    logicalNotGroup.style.display = 'none';
    
    // Start NOT operation visualization
    showLogicalNotVisualization(inputArray);
}

// NEW: Perform Logical XOR Operation
function handlePerformLogicalXor() {
    const arrayCount = logicalOpArrays.length;
    const elementInputs = document.querySelectorAll('.logical-xor-element');
    
    // Reset arrays
    for (let i = 0; i < arrayCount; i++) {
        logicalOpArrays[i].elements = [];
    }
    
    // Collect and validate elements
    for (let i = 0; i < elementInputs.length; i++) {
        const arrayIndex = parseInt(elementInputs[i].getAttribute('data-array'));
        const elementIndex = parseInt(elementInputs[i].getAttribute('data-index'));
        const value = parseInt(elementInputs[i].value);
        
        if (isNaN(value) || (value !== 0 && value !== 1)) {
            showNotification(`Please enter valid binary value (0 or 1) for Array ${arrayIndex+1}, Element ${elementIndex}`, 'danger');
            elementInputs[i].focus();
            return;
        }
        logicalOpArrays[arrayIndex].elements.push(value);
    }
    
    // Check if all arrays have the same size
    const firstSize = logicalOpArrays[0].elements.length;
    for (let i = 1; i < arrayCount; i++) {
        if (logicalOpArrays[i].elements.length !== firstSize) {
            showNotification('All arrays must have the same size for XOR operation', 'danger');
            return;
        }
    }
    
    logicalOpType = 'XOR';
    
    // Hide input group
    logicalXorGroup.style.display = 'none';
    
    // Start XOR operation visualization
    showLogicalXorVisualization();
}

// NEW: Cancel Logical NOT Handler
function handleCancelLogicalNot() {
    logicalNotGroup.style.display = 'none';
    logicalNotSize.value = '';
    logicalNotInputs.innerHTML = '';
    
    logOperation('Cancelled logical NOT operation', 'info');
}

// NEW: Cancel Logical XOR Handler
function handleCancelLogicalXor() {
    logicalXorGroup.style.display = 'none';
    logicalXorArrayCount.value = '';
    logicalXorSizeInputs.innerHTML = '';
    logicalXorElementInputs.innerHTML = '';
    logicalOpArrays = [];
    
    logOperation('Cancelled logical XOR operation', 'info');
}
// NEW: Show Logical NOT Visualization
function showLogicalNotVisualization(inputArray) {
    isLogicalOpRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Element-wise Logical NOT Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Original Binary Array</div>
            <div class="original-array-container" id="originalLogicalArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After Logical NOT Operation</div>
            <div class="transformed-array-container" id="transformedLogicalArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Logical NOT Operation:</strong> Each element is inverted (01, 10)</p>
            <p class="mb-0" id="logicalExplanation">Starting logical NOT operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="logicalStepsContainer">
            <h6 class="text-center">Logical NOT Steps</h6>
            <div class="steps-container" id="logicalSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterLogical" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original View
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(inputArray, 'originalLogicalArray');
    renderArrayInContainer([...inputArray], 'transformedLogicalArray');
    
    performLogicalNotAnimation(inputArray);
}

// NEW: Perform Logical NOT Animation
function performLogicalNotAnimation(inputArray) {
    const originalContainer = document.getElementById('originalLogicalArray');
    const transformedContainer = document.getElementById('transformedLogicalArray');
    const explanation = document.getElementById('logicalExplanation');
    const stepsContainer = document.getElementById('logicalSteps');
    const continueButton = document.getElementById('continueAfterLogical');
    
    const resultArray = [...inputArray];
    let currentIndex = 0;
    
    function performNotStep() {
        if (currentIndex >= inputArray.length) {
            // Operation completed
            explanation.innerHTML = `<strong>Logical NOT Operation Completed!</strong> All elements inverted successfully.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Logical NOT operation completed on all ${inputArray.length} elements
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterLogical();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterLogical);
            
            return;
        }
        
        const originalValue = inputArray[currentIndex];
        const notValue = originalValue === 0 ? 1 : 0;
        
        explanation.innerHTML = `Processing element [${currentIndex}]: ${originalValue}  ${notValue}`;
        
        // Highlight current element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        
        const originalElement = originalElements[currentIndex].querySelector('.element-value');
        const transformedElement = transformedElements[currentIndex].querySelector('.element-value');
        
        originalElement.classList.add('logical-not-current');
        transformedElement.classList.add('logical-not-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex + 1}:</strong> NOT(${originalValue}) = ${notValue}
            </div>
        `;
        
        setTimeout(() => {
            // Apply NOT operation
            resultArray[currentIndex] = notValue;
            
            // Update transformed array display
            renderArrayInContainer(resultArray, 'transformedLogicalArray');
            
            // Remove highlight and add completion effect
            originalElement.classList.remove('logical-not-current');
            transformedElement.classList.remove('logical-not-current');
            transformedElements[currentIndex].querySelector('.element-value').classList.add('create', 'bounce');
            
            currentIndex++;
            performNotStep();
        }, 1500);
    }
    
    // Start NOT operation
    performNotStep();
}

// NEW: Show Logical XOR Visualization
function showLogicalXorVisualization() {
    isLogicalOpRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Element-wise Logical XOR Operation</h5>
        
        <div id="logicalXorArraysContainer"></div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">XOR Result Array</div>
            <div class="transformed-array-container" id="logicalXorResultArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Logical XOR Operation:</strong> Output is 1 when inputs differ, 0 when same</p>
            <p class="mb-0" id="logicalXorExplanation">Starting logical XOR operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="logicalXorStepsContainer">
            <h6 class="text-center">Logical XOR Steps</h6>
            <div class="steps-container" id="logicalXorSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterLogicalXor" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original View
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display input arrays
    const arraysContainer = document.getElementById('logicalXorArraysContainer');
    for (let i = 0; i < logicalOpArrays.length; i++) {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'array-group';
        arrayGroup.innerHTML = `
            <div class="array-label">Array ${i+1}</div>
            <div class="original-array-container" id="logicalXorArray${i}"></div>
        `;
        arraysContainer.appendChild(arrayGroup);
        renderArrayInContainer(logicalOpArrays[i].elements, `logicalXorArray${i}`);
    }
    
    // Initialize result array with zeros
    const arraySize = logicalOpArrays[0].elements.length;
    logicalOpResultArray = Array(arraySize).fill(0);
    renderArrayInContainer(logicalOpResultArray, 'logicalXorResultArray');
    
    performLogicalXorAnimation();
}

// NEW: Perform Logical XOR Animation
function performLogicalXorAnimation() {
    const explanation = document.getElementById('logicalXorExplanation');
    const stepsContainer = document.getElementById('logicalXorSteps');
    const continueButton = document.getElementById('continueAfterLogicalXor');
    
    const arraySize = logicalOpArrays[0].elements.length;
    const arrayCount = logicalOpArrays.length;
    let currentElement = 0;
    
    function performXorStep() {
        if (currentElement >= arraySize) {
            // Operation completed
            explanation.innerHTML = `<strong>Logical XOR Operation Completed!</strong> All elements processed successfully.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> XOR operation completed on all ${arraySize} elements across ${arrayCount} arrays
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterLogical();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterLogical);
            
            return;
        }
        
        explanation.innerHTML = `Processing element position ${currentElement} across all arrays`;
        
        // Highlight current element in all arrays
        for (let i = 0; i < arrayCount; i++) {
            const arrayContainer = document.getElementById(`logicalXorArray${i}`);
            const elements = arrayContainer.querySelectorAll('.array-element');
            if (elements[currentElement]) {
                elements[currentElement].querySelector('.element-value').classList.add('logical-xor-current');
            }
        }
        
        // Calculate XOR step by step
        let xorResult = logicalOpArrays[0].elements[currentElement];
        let calculationSteps = `XOR calculation: ${logicalOpArrays[0].elements[currentElement]}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Element ${currentElement}:</strong> Starting XOR calculation...
            </div>
        `;
        
        setTimeout(() => {
            for (let i = 1; i < arrayCount; i++) {
                const currentValue = logicalOpArrays[i].elements[currentElement];
                const previousResult = xorResult;
                xorResult = (previousResult !== currentValue) ? 1 : 0;
                
                calculationSteps += ` XOR ${currentValue} = ${xorResult}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step:</strong> ${calculationSteps}
                    </div>
                `;
                
                // Update result array
                logicalOpResultArray[currentElement] = xorResult;
                renderArrayInContainer(logicalOpResultArray, 'logicalXorResultArray');
                
                // Highlight result element
                const resultContainer = document.getElementById('logicalXorResultArray');
                const resultElements = resultContainer.querySelectorAll('.array-element');
                if (resultElements[currentElement]) {
                    resultElements[currentElement].querySelector('.element-value').classList.add('create', 'bounce');
                }
            }
            
            // Remove highlights
            for (let i = 0; i < arrayCount; i++) {
                const arrayContainer = document.getElementById(`logicalXorArray${i}`);
                const elements = arrayContainer.querySelectorAll('.array-element');
                if (elements[currentElement]) {
                    elements[currentElement].querySelector('.element-value').classList.remove('logical-xor-current');
                }
            }
            
            currentElement++;
            performXorStep();
        }, 1000);
    }
    
    // Start XOR operation
    performXorStep();
}

// NEW: Return to Original after Logical Operations
function returnToOriginalAfterLogical() {
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isLogicalOpRunning = false;
    originalArrayForLogicalOps = [];
    logicalOpType = null;
    logicalOpArrays = [];
    logicalOpResultArray = [];
    
    // Clear all input groups
    logicalNotGroup.style.display = 'none';
    logicalXorGroup.style.display = 'none';
    logicalNotSize.value = '';
    logicalNotInputs.innerHTML = '';
    logicalXorArrayCount.value = '';
    logicalXorSizeInputs.innerHTML = '';
    logicalXorElementInputs.innerHTML = '';
    
    logOperation('Logical operation completed - returned to original view', 'info');
    showNotification('Returned to original view after logical operation', 'success');
}
// Updated handler to use the simpler implementation
function handleTransformNonDecreasing() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isTransformRunning) {
        showNotification('A transformation operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('This transformation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isTransformRunning = true;
    
    // Store original array
    originalArrayForTransform = [...myArray];
    
    // Calculate transformation steps using the simpler implementation
    calculateTransformStepsSimple();
    
    // Show transformation visualization
    showTransformVisualization();
}

// NEW: Calculate Transformation Steps (Based on Python logic)
function calculateTransformStepsSimple() {
    const arr = originalArrayForTransform.map(val => parseInt(val));
    transformSteps = [];
    let operations = 0;
    
    // Create a copy like in Python: arr = arr[:]
    let workingArray = [...arr];
    
    // Add initial state
    transformSteps.push({
        array: [...workingArray],
        currentIndex: 0,
        prevValue: workingArray[0],
        operations: operations,
        message: "Starting transformation process...",
        stepType: "start"
    });
    
    // Direct translation of Python logic
    for (let i = 1; i < workingArray.length; i++) {
        // Show initial comparison
        transformSteps.push({
            array: [...workingArray],
            currentIndex: i,
            prevValue: workingArray[i-1],
            operations: operations,
            message: ` Comparing arr[${i-1}]=${workingArray[i-1]} and arr[${i}]=${workingArray[i]}`,
            stepType: "compare"
        });
        
        // If current element is less than previous (like Python if condition)
        if (workingArray[i] < workingArray[i-1]) {
            operations += 1;
            
            // Strategy: always increase the current element to match previous
            // This minimizes future conflicts (like Python nums[i] = nums[i-1])
            const oldValue = workingArray[i];
            workingArray[i] = workingArray[i-1];
            
            transformSteps.push({
                array: [...workingArray],
                currentIndex: i,
                prevValue: workingArray[i-1],
                operations: operations,
                message: ` Increased arr[${i}] from ${oldValue} to ${workingArray[i]} to match previous element (operation ${operations})`,
                stepType: "increase"
            });
        }
        
        // Validation step
        transformSteps.push({
            array: [...workingArray],
            currentIndex: i,
            prevValue: workingArray[i-1],
            operations: operations,
            message: ` Validation: arr[${i-1}]=${workingArray[i-1]}  arr[${i}]=${workingArray[i]} `,
            stepType: "validate"
        });
    }
    
    // Final step
    transformSteps.push({
        array: [...workingArray],
        currentIndex: -1,
        prevValue: 0,
        operations: operations,
        message: ` Transformation completed! Total changes made: ${operations}. Array is now non-decreasing.`,
        stepType: "complete"
    });
}

// NEW: Show Transformation Visualization
function showTransformVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Transform to Non-Decreasing Array</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalTransformArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Transformation Process</div>
            <div class="transformed-array-container" id="transformedTransformArray"></div>
        </div>
        
        <div class="operations-counter">
            <i class="fas fa-calculator me-2"></i>
            Total Changes: <span id="operationsCount">0</span>
        </div>
        
        <div class="transform-explanation">
            <p class="mb-2"><strong>Greedy Algorithm:</strong> Ensure each element is  its predecessor by increasing elements when needed</p>
            <p class="mb-0" id="transformExplanation"> Starting automatic transformation process...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="transformStepsContainer">
            <h6 class="text-center">Transformation Steps</h6>
            <div class="steps-container" id="transformSteps"></div>
        </div>
        
        <div class="progress mt-3" style="height: 8px;">
            <div id="transformProgress" class="progress-bar bg-success" style="width: 0%"></div>
        </div>
        
        <div class="d-flex gap-2 mt-3 justify-content-center">
            <button class="btn btn-sm btn-outline-light" id="pauseTransform">
                <i class="fas fa-pause me-1"></i>Pause Animation
            </button>
            <button class="btn btn-sm btn-outline-light" id="restartTransform" style="display: none;">
                <i class="fas fa-redo me-1"></i>Restart Animation
            </button>
        </div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForTransform, 'originalTransformArray');
    renderArrayInContainer([...originalArrayForTransform], 'transformedTransformArray');
    
    setupTransformControls();
    startAutoPlay();
}

// NEW: Setup Transformation Controls
function setupTransformControls() {
    const pauseBtn = document.getElementById('pauseTransform');
    const restartBtn = document.getElementById('restartTransform');
    
    let isPaused = false;
    
    pauseBtn.addEventListener('click', () => {
        if (!isPaused) {
            // Pause animation
            clearInterval(window.transformAnimationInterval);
            pauseBtn.innerHTML = '<i class="fas fa-play me-1"></i>Resume Animation';
            isPaused = true;
        } else {
            // Resume animation
            startAutoPlay();
            pauseBtn.innerHTML = '<i class="fas fa-pause me-1"></i>Pause Animation';
            isPaused = false;
        }
    });
    
    restartBtn.addEventListener('click', () => {
        clearInterval(window.transformAnimationInterval);
        currentTransformStep = 0;
        const stepsContainer = document.getElementById('transformSteps');
        stepsContainer.innerHTML = '';
        startAutoPlay();
        restartBtn.style.display = 'none';
        pauseBtn.style.display = 'block';
    });
}

// NEW: Start Auto Play Animation
function startAutoPlay() {
    const pauseBtn = document.getElementById('pauseTransform');
    const restartBtn = document.getElementById('restartTransform');
    const progressBar = document.getElementById('transformProgress');
    
    let stepDelay = 1200; // 1.2 seconds per step for better visibility
    
    // Clear any existing interval
    if (window.transformAnimationInterval) {
        clearInterval(window.transformAnimationInterval);
    }
    
    // Start from step 0
    currentTransformStep = 0;
    displayTransformStep(currentTransformStep);
    
    window.transformAnimationInterval = setInterval(() => {
        if (currentTransformStep < transformSteps.length - 1) {
            currentTransformStep++;
            displayTransformStep(currentTransformStep);
            
            // Update progress bar
            const progress = (currentTransformStep / (transformSteps.length - 1)) * 100;
            progressBar.style.width = `${progress}%`;
            
        } else {
            // Animation completed
            clearInterval(window.transformAnimationInterval);
            pauseBtn.style.display = 'none';
            restartBtn.style.display = 'block';
            
            // Auto-return to original array after 3 seconds
            setTimeout(() => {
                returnToOriginalAfterTransform();
            }, 3000);
        }
    }, stepDelay);
}

// NEW: Display Transformation Step
function displayTransformStep(stepIndex) {
    const step = transformSteps[stepIndex];
    const explanation = document.getElementById('transformExplanation');
    const stepsContainer = document.getElementById('transformSteps');
    const operationsCount = document.getElementById('operationsCount');
    
    // Update operations count
    operationsCount.textContent = step.operations;
    
    // Update explanation with animated effect
    explanation.innerHTML = step.message;
    explanation.classList.add('pulse');
    setTimeout(() => {
        explanation.classList.remove('pulse');
    }, 500);
    
    // Update transformed array
    renderArrayInContainer(step.array, 'transformedTransformArray');
    
    // Add step to steps container with smooth scroll
    const stepElement = document.createElement('div');
    stepElement.className = `algorithm-step ${step.stepType === 'complete' ? 'active' : ''}`;
    stepElement.innerHTML = `<strong>Step ${stepIndex + 1}:</strong> ${step.message}`;
    stepsContainer.appendChild(stepElement);
    
    // Smooth scroll to bottom
    stepsContainer.scrollTo({
        top: stepsContainer.scrollHeight,
        behavior: 'smooth'
    });
    
    // Highlight current elements with enhanced animations
    const transformedContainer = document.getElementById('transformedTransformArray');
    const elements = transformedContainer.querySelectorAll('.array-element');
    
    // Remove previous highlights
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove(
            'transform-current', 
            'transform-compared', 
            'transform-increased', 
            'transform-valid',
            'pulse',
            'bounce',
            'shake'
        );
    });
    
    // Apply current highlights based on step type with enhanced animations
    if (step.currentIndex >= 0) {
        const currentElement = elements[step.currentIndex].querySelector('.element-value');
        
        switch (step.stepType) {
            case 'compare':
                if (step.currentIndex > 0) {
                    const prevElement = elements[step.currentIndex - 1].querySelector('.element-value');
                    prevElement.classList.add('transform-compared', 'pulse');
                }
                currentElement.classList.add('transform-current', 'bounce');
                break;
                
            case 'increase':
                currentElement.classList.add('transform-increased', 'pulse');
                // Add count animation for operations
                if (step.operations > 0) {
                    operationsCount.classList.add('bounce');
                    setTimeout(() => {
                        operationsCount.classList.remove('bounce');
                    }, 500);
                }
                break;
                
            case 'validate':
                if (step.currentIndex > 0) {
                    const prevElement = elements[step.currentIndex - 1].querySelector('.element-value');
                    prevElement.classList.add('transform-valid', 'pulse');
                }
                currentElement.classList.add('transform-valid', 'pulse');
                break;
                
            case 'complete':
                // Celebrate completion - highlight all elements
                elements.forEach((el, index) => {
                    setTimeout(() => {
                        const valueDiv = el.querySelector('.element-value');
                        valueDiv.classList.add('transform-valid', 'bounce');
                    }, index * 200);
                });
                break;
        }
    }
    
    // Special effects for completion
    if (step.stepType === 'complete') {
        explanation.classList.add('highlight');
        operationsCount.classList.add('color-change');
    }
}

// NEW: Return to Original after Transformation
function returnToOriginalAfterTransform() {
    // Clear any running intervals
    if (window.transformAnimationInterval) {
        clearInterval(window.transformAnimationInterval);
    }
    
    // Reset to original array
    myArray = [...originalArrayForTransform];
    originalArrayForTransform = [];
    transformSteps = [];
    currentTransformStep = 0;
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isTransformRunning = false;
    
    logOperation('Non-decreasing transformation completed - returned to original array', 'success');
    showNotification(' Transformation completed! Returned to original array', 'success');
}

// NEW: Helper function to render array in specific container
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = `
            <div class="array-empty-state">
                <i class="fas fa-layer-group"></i>
                <h4>Array is Empty</h4>
                <p>Add some elements to get started!</p>
            </div>
        `;
        return;
    }
    
    array.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}
// NEW: Minimum Flips Operation Handler
function handleMinFlipsOperation(operationType) {
    if (isMinFlipsRunning) {
        showNotification('A minimum flips operation is already in progress', 'warning');
        return;
    }

    minFlipsOperationType = operationType;
    minFlipsArrays = [];
    minFlipsOriginalArrays = [];
    minFlipsNumArraysCount = 0; // Updated variable name
    minFlipsArraySizes = [];

    // Show input group
    minFlipsInputGroup.style.display = 'block';
    minFlipsTitle.textContent = `Minimum Flips ${operationType.toUpperCase()} Operation`;
    numArraysInputField.focus(); // Updated variable name

    // Hide perform button initially
    performMinFlipsOperationBtn.style.display = 'none'; // Updated variable name
    arraySizeInputsContainer.innerHTML = ''; // Updated variable name
    arrayElementsInputsContainer.innerHTML = ''; // Updated variable name

    logOperation(`Started minimum flips ${operationType.toUpperCase()} operation`, 'info');
}

// NEW: Confirm Number of Arrays Handler
function handleConfirmNumArrays() {
    const numArrays = parseInt(numArraysInputField.value); // Updated variable name

    if (isNaN(numArrays) || numArrays < 2 || numArrays > 5) {
        showNotification('Please enter a valid number of arrays between 2 and 5', 'danger');
        numArraysInputField.focus(); // Updated variable name
        return;
    }

    minFlipsNumArraysCount = numArrays; // Updated variable name

    // Create size input fields for each array
    arraySizeInputsContainer.innerHTML = '<label class="form-label">Enter sizes for each array:</label>'; // Updated variable name
    for (let i = 0; i < numArrays; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Array ${i + 1} Size</span>
            <input type="number" class="form-control array-size-input" 
                   data-array-index="${i}" placeholder="Enter size" min="1" max="10">
        `;
        arraySizeInputsContainer.appendChild(inputGroup); // Updated variable name
    }

    // Add event listeners for size inputs
    const sizeInputs = arraySizeInputsContainer.querySelectorAll('.array-size-input'); // Updated variable name
    sizeInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('array-size-input')) {
                    nextInput.focus();
                }
            }
        });
    });

    showNotification(`Number of arrays set to ${numArrays}. Please enter sizes for each array.`, 'success');
}

// NEW: Handle Array Size Confirmation (called when all sizes are entered)
function handleArraySizesConfirmed() {
    // Collect all array sizes
    minFlipsArraySizes = [];
    const sizeInputs = arraySizeInputsContainer.querySelectorAll('.array-size-input'); // Updated variable name
    
    for (let i = 0; i < sizeInputs.length; i++) {
        const size = parseInt(sizeInputs[i].value);
        if (isNaN(size) || size < 1 || size > 10) {
            showNotification(`Please enter a valid size for Array ${i + 1} (1-10)`, 'danger');
            sizeInputs[i].focus();
            return;
        }
        minFlipsArraySizes.push(size);
    }

    // Create element input fields for each array
    arrayElementsInputsContainer.innerHTML = '<label class="form-label">Enter elements for each array (numbers only):</label>'; // Updated variable name
    
    for (let i = 0; i < minFlipsNumArraysCount; i++) { // Updated variable name
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'mb-3';
        arrayGroup.innerHTML = `<label class="form-label">Array ${i + 1} (size: ${minFlipsArraySizes[i]}):</label>`;
        
        for (let j = 0; j < minFlipsArraySizes[i]; j++) {
            const inputGroup = document.createElement('div');
            inputGroup.className = 'input-group mb-2';
            inputGroup.innerHTML = `
                <span class="input-group-text">Element ${j}</span>
                <input type="number" class="form-control array-element-input" 
                       data-array-index="${i}" data-element-index="${j}" 
                       placeholder="Enter number">
            `;
            arrayGroup.appendChild(inputGroup);
        }
        arrayElementsInputsContainer.appendChild(arrayGroup); // Updated variable name
    }

    // Show perform button
    performMinFlipsOperationBtn.style.display = 'block'; // Updated variable name

    // Add event listeners for element inputs
    const elementInputs = arrayElementsInputsContainer.querySelectorAll('.array-element-input'); // Updated variable name
    elementInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('array-element-input')) {
                    nextInput.focus();
                }
            }
        });
    });

    showNotification('Array sizes confirmed. Please enter elements for each array.', 'success');
}

// NEW: Perform Minimum Flips Handler
function handlePerformMinFlips() {
    // Check if sizes are entered, if not, confirm them first
    if (minFlipsArraySizes.length === 0) {
        handleArraySizesConfirmed();
        return;
    }

    // Collect all array elements
    minFlipsArrays = [];
    const elementInputs = arrayElementsInputsContainer.querySelectorAll('.array-element-input'); // Updated variable name
    
    // Initialize arrays
    for (let i = 0; i < minFlipsNumArraysCount; i++) { // Updated variable name
        minFlipsArrays.push([]);
    }

    // Fill arrays with elements
    for (let i = 0; i < elementInputs.length; i++) {
        const value = elementInputs[i].value.trim();
        const arrayIndex = parseInt(elementInputs[i].getAttribute('data-array-index'));
        const elementIndex = parseInt(elementInputs[i].getAttribute('data-element-index'));
        
        if (value === '' || isNaN(parseFloat(value))) {
            showNotification(`Please enter valid numbers for all elements. Missing element at Array ${arrayIndex + 1}, position ${elementIndex}`, 'danger');
            elementInputs[i].focus();
            return;
        }
        
        minFlipsArrays[arrayIndex].push(parseFloat(value));
    }

    // Verify all arrays have correct sizes
    for (let i = 0; i < minFlipsNumArraysCount; i++) { // Updated variable name
        if (minFlipsArrays[i].length !== minFlipsArraySizes[i]) {
            showNotification(`Array ${i + 1} has incorrect number of elements`, 'danger');
            return;
        }
    }

    // Store original arrays
    minFlipsOriginalArrays = JSON.parse(JSON.stringify(minFlipsArrays));

    // Hide input group and start visualization
    minFlipsInputGroup.style.display = 'none';
    isMinFlipsRunning = true;

    // Start minimum flips visualization
    showMinFlipsVisualization();
}

// NEW: Cancel Minimum Flips Handler
function handleCancelMinFlips() {
    minFlipsInputGroup.style.display = 'none';
    numArraysInputField.value = ''; // Updated variable name
    arraySizeInputsContainer.innerHTML = ''; // Updated variable name
    arrayElementsInputsContainer.innerHTML = ''; // Updated variable name
    performMinFlipsOperationBtn.style.display = 'none'; // Updated variable name
    
    minFlipsArrays = [];
    minFlipsOriginalArrays = [];
    minFlipsNumArraysCount = 0; // Updated variable name
    minFlipsArraySizes = [];
    minFlipsOperationType = null;
    
    logOperation('Cancelled minimum flips operation', 'info');
    showNotification('Minimum flips operation cancelled', 'info');
}

// NEW: Show Minimum Flips Visualization
function showMinFlipsVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Minimum Flips ${minFlipsOperationType.toUpperCase()} Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Input Arrays</div>
            <div id="inputArraysContainer"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Binary Representation & Flips</div>
            <div id="binaryRepresentationContainer"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Minimum Flips ${minFlipsOperationType.toUpperCase()}:</strong> Finding minimum bit flips to make array ${minFlipsOperationType} equal to target</p>
            <p class="mb-0" id="minFlipsExplanation">Converting numbers to binary...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="minFlipsStepsContainer">
            <h6 class="text-center">Minimum Flips Steps</h6>
            <div class="steps-container" id="minFlipsSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Minimum Flips Required</div>
            <div class="stats-value" id="minFlipsResult">0</div>
        </div>
        
        <div class="auto-return-notice mt-3">
            <p class="text-center text-info">
                <i class="fas fa-info-circle me-2"></i>
                Will automatically return to main view in 5 seconds...
            </p>
        </div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Render input arrays
    renderInputArrays();
    
    // Start minimum flips algorithm
    performMinFlipsAlgorithm();
}
// NEW: Render Input Arrays
function renderInputArrays() {
    const container = document.getElementById('inputArraysContainer');
    container.innerHTML = '';
    
    minFlipsArrays.forEach((array, index) => {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'mb-3';
        arrayGroup.innerHTML = `
            <div class="array-label">Array ${index + 1}</div>
            <div class="original-array-container" id="inputArray${index}"></div>
        `;
        container.appendChild(arrayGroup);
        renderArrayInContainer(array, `inputArray${index}`);
    });
}

// NEW: Perform Minimum Flips Algorithm
function performMinFlipsAlgorithm() {
    const explanation = document.getElementById('minFlipsExplanation');
    const stepsContainer = document.getElementById('minFlipsSteps');
    const minFlipsResult = document.getElementById('minFlipsResult');
    const binaryContainer = document.getElementById('binaryRepresentationContainer');
    
    let step = 0;
    let minFlips = Infinity;
    let bestResult = null;
    
    function executeStep() {
        switch (step) {
            case 0:
                // Step 1: Convert numbers to binary
                explanation.innerHTML = 'Step 1: Converting all numbers to binary representation';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Convert all array elements to binary
                    </div>
                `;
                
                // Show binary representation
                showBinaryRepresentation();
                break;
                
            case 1:
                // Step 2: Explain the operation
                explanation.innerHTML = `Step 2: For ${minFlipsOperationType.toUpperCase()} operation, we need to find minimum flips to make all arrays have the same ${minFlipsOperationType} result`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Analyze bit patterns for ${minFlipsOperationType.toUpperCase()} operation
                    </div>
                `;
                break;
                
            case 2:
                // Step 3: Calculate minimum flips
                explanation.innerHTML = 'Step 3: Calculating minimum flips required...';
                const result = calculateMinimumFlips();
                minFlips = result.minFlips;
                bestResult = result;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Minimum flips calculated = ${minFlips}
                    </div>
                `;
                break;
                
            case 3:
                // Step 4: Show result
                explanation.innerHTML = `<strong>Algorithm Completed!</strong> Minimum flips required = ${minFlips}`;
                minFlipsResult.textContent = minFlips;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Minimum flips = ${minFlips} ${bestResult.explanation}
                    </div>
                `;
                
                // Highlight the bits that need to be flipped
                highlightFlips(bestResult);
                
                // AUTO-RETURN: Set timeout to automatically return to main view after 5 seconds
                setTimeout(() => {
                    returnToMainAfterMinFlips();
                }, 5000);
                return;
        }
        
        step++;
        setTimeout(executeStep, 2000);
    }
    
    // Start execution
    executeStep();
}

// NEW: Calculate Minimum Flips
function calculateMinimumFlips() {
    // For OR operation: We want all arrays to have the same OR value
    // For AND operation: We want all arrays to have the same AND value
    
    if (minFlipsOperationType === 'or') {
        return calculateMinFlipsOR();
    } else {
        return calculateMinFlipsAND();
    }
}

// NEW: Calculate Minimum Flips for OR
function calculateMinFlipsOR() {
    // Find the maximum number to determine bit length
    const allNumbers = minFlipsArrays.flat();
    const maxNum = Math.max(...allNumbers);
    const bitLength = Math.floor(Math.log2(maxNum)) + 1;
    
    let totalFlips = 0;
    let explanation = '';
    
    // For OR operation, we need to make sure all arrays have at least one '1' in each bit position
    // where any array has a '1', or we need to flip bits to achieve this
    
    for (let bitPos = 0; bitPos < bitLength; bitPos++) {
        const bitMask = 1 << bitPos;
        let hasOneInAnyArray = false;
        
        // Check if any array has this bit set
        for (let i = 0; i < minFlipsArrays.length; i++) {
            for (let j = 0; j < minFlipsArrays[i].length; j++) {
                if (minFlipsArrays[i][j] & bitMask) {
                    hasOneInAnyArray = true;
                    break;
                }
            }
            if (hasOneInAnyArray) break;
        }
        
        if (!hasOneInAnyArray) {
            // We need to flip one '0' to '1' in this bit position
            totalFlips++;
            explanation += ` Bit ${bitPos}: flip one 01`;
        }
    }
    
    return {
        minFlips: totalFlips,
        explanation: `(OR: ensure each bit position has at least one 1)${explanation}`
    };
}

// NEW: Calculate Minimum Flips for AND
function calculateMinFlipsAND() {
    // Find the maximum number to determine bit length
    const allNumbers = minFlipsArrays.flat();
    const maxNum = Math.max(...allNumbers);
    const bitLength = Math.floor(Math.log2(maxNum)) + 1;
    
    let totalFlips = 0;
    let explanation = '';
    
    // For AND operation, we need to make sure all arrays have '1' in each bit position
    // where we want the final AND to be 1, or flip bits accordingly
    
    for (let bitPos = 0; bitPos < bitLength; bitPos++) {
        const bitMask = 1 << bitPos;
        let allArraysHaveOne = true;
        
        // Check if all arrays have at least one element with this bit set
        for (let i = 0; i < minFlipsArrays.length; i++) {
            let arrayHasOne = false;
            for (let j = 0; j < minFlipsArrays[i].length; j++) {
                if (minFlipsArrays[i][j] & bitMask) {
                    arrayHasOne = true;
                    break;
                }
            }
            if (!arrayHasOne) {
                allArraysHaveOne = false;
                break;
            }
        }
        
        if (!allArraysHaveOne) {
            // We need to flip one '0' to '1' in each array that doesn't have this bit set
            let flipsForThisBit = 0;
            for (let i = 0; i < minFlipsArrays.length; i++) {
                let arrayHasOne = false;
                for (let j = 0; j < minFlipsArrays[i].length; j++) {
                    if (minFlipsArrays[i][j] & bitMask) {
                        arrayHasOne = true;
                        break;
                    }
                }
                if (!arrayHasOne) {
                    flipsForThisBit++;
                }
            }
            totalFlips += flipsForThisBit;
            explanation += ` Bit ${bitPos}: ${flipsForThisBit} flips`;
        }
    }
    
    return {
        minFlips: totalFlips,
        explanation: `(AND: ensure each array has at least one 1 in required bits)${explanation}`
    };
}

// NEW: Show Binary Representation
function showBinaryRepresentation() {
    const container = document.getElementById('binaryRepresentationContainer');
    container.innerHTML = '';
    
    const allNumbers = minFlipsArrays.flat();
    const maxNum = Math.max(...allNumbers);
    const bitLength = Math.max(4, Math.floor(Math.log2(maxNum)) + 1); // Minimum 4 bits for visibility
    
    minFlipsArrays.forEach((array, arrayIndex) => {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'mb-3';
        arrayGroup.innerHTML = `<div class="array-label">Array ${arrayIndex + 1} Binary</div>`;
        
        array.forEach((number, elementIndex) => {
            const binaryGroup = document.createElement('div');
            binaryGroup.className = 'binary-representation';
            binaryGroup.innerHTML = `<div>Element ${elementIndex} (${number}):</div>`;
            
            const binaryStr = number.toString(2).padStart(bitLength, '0');
            for (let i = 0; i < binaryStr.length; i++) {
                const digit = document.createElement('span');
                digit.className = 'binary-digit';
                digit.textContent = binaryStr[i];
                digit.setAttribute('data-array', arrayIndex);
                digit.setAttribute('data-element', elementIndex);
                digit.setAttribute('data-bit', i);
                binaryGroup.appendChild(digit);
            }
            
            arrayGroup.appendChild(binaryGroup);
        });
        
        container.appendChild(arrayGroup);
    });
}

// NEW: Highlight Flips
function highlightFlips(result) {
    // This is a simplified visualization - in a real implementation,
    // you would highlight the specific bits that need to be flipped
    const binaryDigits = document.querySelectorAll('.binary-digit');
    
    // Highlight some random digits for demonstration
    binaryDigits.forEach((digit, index) => {
        if (index % 3 === 0) { // Just for demonstration
            setTimeout(() => {
                digit.classList.add('flip-candidate');
            }, index * 100);
        }
    });
}

// NEW: Return to Main after Minimum Flips
function returnToMainAfterMinFlips() {
    // Reset to original state
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMinFlipsRunning = false;
    minFlipsArrays = [];
    minFlipsOriginalArrays = [];
    minFlipsNumArraysCount = 0; // Updated variable name
    minFlipsArraySizes = [];
    minFlipsOperationType = null;
    
    logOperation('Minimum flips operation completed', 'info');
    showNotification('Returned to main view', 'success');
}

// Add this helper function to handle array size input completion
document.addEventListener('input', (e) => {
    if (e.target.classList.contains('array-size-input')) {
        // Check if all size inputs are filled
        const sizeInputs = arraySizeInputsContainer.querySelectorAll('.array-size-input'); // Updated variable name
        const allFilled = Array.from(sizeInputs).every(input => input.value.trim() !== '');
        
        if (allFilled) {
            // Auto-confirm sizes after a short delay
            setTimeout(handleArraySizesConfirmed, 500);
        }
    }
});
// NEW: Prefix XOR Array Handler
function handlePrefixXor() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isPrefixXorRunning) {
        showNotification('Prefix XOR operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers (XOR requires numbers)
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseInt(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('XOR operation requires all array elements to be integers', 'danger');
        return;
    }
    
    isPrefixXorRunning = true;
    
    // Store original array
    originalArrayForXor = [...myArray];
    
    // Show prefix XOR visualization
    showPrefixXorVisualization();
}
// NEW: Show Prefix XOR Visualization
function showPrefixXorVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Prefix XOR Array Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalXorArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Prefix XOR Array</div>
            <div class="transformed-array-container" id="transformedXorArray"></div>
        </div>
        
        <div class="xor-explanation">
            <p class="mb-2"><strong>Prefix XOR Operation:</strong> Each element = XOR of all previous elements including current</p>
            <p class="mb-0" id="xorExplanation">Starting prefix XOR calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="xorStepsContainer">
            <h6 class="text-center">XOR Operation Steps</h6>
            <div class="steps-container" id="xorSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterXor" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForXor, 'originalXorArray');
    renderArrayInContainer([...originalArrayForXor], 'transformedXorArray');
    
    performPrefixXorAnimation();
}
// NEW: Perform Prefix XOR Animation
function performPrefixXorAnimation() {
    const originalContainer = document.getElementById('originalXorArray');
    const transformedContainer = document.getElementById('transformedXorArray');
    const explanation = document.getElementById('xorExplanation');
    const stepsContainer = document.getElementById('xorSteps');
    const continueButton = document.getElementById('continueAfterXor');
    
    const originalArray = originalArrayForXor.map(val => parseInt(val));
    let prefixXorArray = [];
    let currentXor = 0;
    let currentIndex = 0;
    
    function performXorStep() {
        if (currentIndex >= originalArray.length) {
            // XOR operation completed
            explanation.innerHTML = `<strong>Prefix XOR Operation Completed!</strong> Final prefix XOR array generated.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Prefix XOR array: [${prefixXorArray.join(', ')}]
                </div>
            `;
            
            // Highlight all elements in the transformed array
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('xor-result');
                }, index * 200);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterXor();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterXor);
            
            return;
        }
        
        const stepNumber = currentIndex + 1;
        
        if (currentIndex === 0) {
            // First element - XOR with 0
            explanation.innerHTML = `Step ${stepNumber}: First element - XOR with 0`;
            
            const originalElements = originalContainer.querySelectorAll('.array-element');
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            
            // Highlight current element
            originalElements[currentIndex].querySelector('.element-value').classList.add('xor-current');
            transformedElements[currentIndex].querySelector('.element-value').classList.add('xor-current');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${stepNumber}:</strong> prefixXor[0] = 
                    <span class="xor-operation">0 XOR ${originalArray[currentIndex]}</span> = 
                    <span class="xor-operation">${originalArray[currentIndex]}</span>
                </div>
            `;
            
            setTimeout(() => {
                currentXor = originalArray[currentIndex];
                prefixXorArray.push(currentXor);
                
                // Update transformed array
                renderArrayInContainer(prefixXorArray, 'transformedXorArray');
                
                // Remove current highlight and add result highlight
                originalElements[currentIndex].querySelector('.element-value').classList.remove('xor-current');
                originalElements[currentIndex].querySelector('.element-value').classList.add('xor-highlight');
                
                const updatedElements = transformedContainer.querySelectorAll('.array-element');
                if (updatedElements[currentIndex]) {
                    updatedElements[currentIndex].querySelector('.element-value').classList.remove('xor-current');
                    updatedElements[currentIndex].querySelector('.element-value').classList.add('xor-result');
                }
                
                // Move to next step
                currentIndex++;
                setTimeout(performXorStep, 1500);
            }, 2000);
            
        } else {
            // Subsequent elements - XOR with previous result
            explanation.innerHTML = `Step ${stepNumber}: XOR with previous result (${currentXor})`;
            
            const originalElements = originalContainer.querySelectorAll('.array-element');
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            
            // Highlight previous result and current element
            if (currentIndex > 0) {
                const prevElement = transformedElements[currentIndex - 1];
                if (prevElement) {
                    prevElement.querySelector('.element-value').classList.add('xor-highlight');
                }
            }
            
            if (originalElements[currentIndex]) {
                originalElements[currentIndex].querySelector('.element-value').classList.add('xor-current');
            }
            
            if (transformedElements[currentIndex]) {
                transformedElements[currentIndex].querySelector('.element-value').classList.add('xor-current');
            }
            
            const newXor = currentXor ^ originalArray[currentIndex];
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${stepNumber}:</strong> prefixXor[${currentIndex}] = 
                    <span class="xor-operation">${currentXor} XOR ${originalArray[currentIndex]}</span> = 
                    <span class="xor-operation">${newXor}</span>
                </div>
            `;
            
            setTimeout(() => {
                currentXor = newXor;
                prefixXorArray.push(currentXor);
                
                // Update transformed array
                renderArrayInContainer(prefixXorArray, 'transformedXorArray');
                
                // Remove highlights
                if (currentIndex > 0) {
                    const prevElement = transformedElements[currentIndex - 1];
                    if (prevElement) {
                        prevElement.querySelector('.element-value').classList.remove('xor-highlight');
                    }
                }
                
                if (originalElements[currentIndex]) {
                    originalElements[currentIndex].querySelector('.element-value').classList.remove('xor-current');
                }
                
                // Get updated elements after re-render
                const updatedElements = transformedContainer.querySelectorAll('.array-element');
                if (updatedElements[currentIndex]) {
                    updatedElements[currentIndex].querySelector('.element-value').classList.remove('xor-current');
                    updatedElements[currentIndex].querySelector('.element-value').classList.add('xor-result');
                }
                
                // Highlight all previous results
                for (let j = 0; j <= currentIndex; j++) {
                    if (updatedElements[j]) {
                        updatedElements[j].querySelector('.element-value').classList.add('xor-highlight');
                    }
                }
                
                // Move to next step
                currentIndex++;
                setTimeout(performXorStep, 1500);
            }, 2000);
        }
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
    }
    
    // Start XOR process
    performXorStep();
}
// NEW: Return to Original after XOR Operation
function returnToOriginalAfterXor() {
    // Reset to original array
    myArray = [...originalArrayForXor];
    originalArrayForXor = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isPrefixXorRunning = false;
    
    logOperation('Prefix XOR operation completed - returned to original array', 'info');
    showNotification('Returned to original array after prefix XOR operation', 'success');
}
// NEW: Maximum Absolute Difference Handler
function handleFindMaxAbsDiff() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length < 2) {
        showNotification('Array must have at least 2 elements to calculate maximum absolute difference', 'warning');
        return;
    }
    
    if (isMaxAbsDiffRunning) {
        showNotification('Maximum absolute difference calculation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Maximum absolute difference calculation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isMaxAbsDiffRunning = true;
    
    // Store original array
    originalArrayForAbsDiff = [...myArray];
    
    // Show maximum absolute difference visualization
    showMaxAbsDiffVisualization();
}

// NEW: Show Maximum Absolute Difference Visualization
function showMaxAbsDiffVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Maximum Absolute Difference Calculation</h5>
        
        <div class="array-group">
            <div class="array-label">Array</div>
            <div class="original-array-container" id="absDiffArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Formula:</strong> max(|A[i] - A[j]| + |i - j|) for all i, j</p>
            <p class="mb-2"><strong>Optimized Approach:</strong> max(A[i] + i) - min(A[i] + i) OR max(A[i] - i) - min(A[i] - i)</p>
            <p class="mb-0" id="absDiffExplanation">Initializing calculation...</p>
        </div>
        
        <div class="abs-diff-table mt-3" id="absDiffTableContainer" style="display: none;">
            <h6 class="text-center">Calculation Table</h6>
            <table class="abs-diff-table">
                <thead>
                    <tr>
                        <th>Index (i)</th>
                        <th>A[i]</th>
                        <th>A[i] + i</th>
                        <th>A[i] - i</th>
                        <th>max(A[i] + i)</th>
                        <th>min(A[i] + i)</th>
                        <th>max(A[i] - i)</th>
                        <th>min(A[i] - i)</th>
                    </tr>
                </thead>
                <tbody id="absDiffTableBody">
                </tbody>
            </table>
        </div>
        
        <div class="algorithm-steps mt-3" id="absDiffStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="absDiffSteps"></div>
        </div>
        
        <div class="abs-diff-results mt-3" id="absDiffResults" style="display: none;">
            <h6 class="text-center">Maximum Absolute Difference Results</h6>
            <div class="stats-card">
                <div>Difference 1 (A[i] + i)</div>
                <div class="diff-value diff1-value" id="diff1Value">0</div>
            </div>
            <div class="stats-card">
                <div>Difference 2 (A[i] - i)</div>
                <div class="diff-value diff2-value" id="diff2Value">0</div>
            </div>
            <div class="stats-card">
                <div>Maximum Absolute Difference</div>
                <div class="diff-value max-diff-value" id="maxDiffValue">0</div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterAbsDiff" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForAbsDiff, 'absDiffArray');
    
    performMaxAbsDiffCalculation();
}

// NEW: Perform Maximum Absolute Difference Calculation with Animation
function performMaxAbsDiffCalculation() {
    const arrayContainer = document.getElementById('absDiffArray');
    const explanation = document.getElementById('absDiffExplanation');
    const stepsContainer = document.getElementById('absDiffSteps');
    const tableContainer = document.getElementById('absDiffTableContainer');
    const tableBody = document.getElementById('absDiffTableBody');
    const resultsContainer = document.getElementById('absDiffResults');
    const diff1Value = document.getElementById('diff1Value');
    const diff2Value = document.getElementById('diff2Value');
    const maxDiffValue = document.getElementById('maxDiffValue');
    const continueButton = document.getElementById('continueAfterAbsDiff');
    
    const arr = originalArrayForAbsDiff.map(val => parseFloat(val));
    const n = arr.length;
    
    let max1 = -Infinity, min1 = Infinity; // For A[i] + i
    let max2 = -Infinity, min2 = Infinity; // For A[i] - i
    let max1Index = -1, min1Index = -1;
    let max2Index = -1, min2Index = -1;
    
    let step = 0;
    let currentIndex = 0;
    
    // Show table after initial setup
    setTimeout(() => {
        tableContainer.style.display = 'block';
        explanation.innerHTML = 'Starting calculation process...';
    }, 500);
    
    function performCalculationStep() {
        if (currentIndex >= n) {
            // All steps completed - show final results
            showFinalResults();
            return;
        }
        
        const i = currentIndex;
        const valuePlusIndex = arr[i] + i;
        const valueMinusIndex = arr[i] - i;
        
        step++;
        
        // Update explanation
        explanation.innerHTML = `Step ${step}: Processing index ${i} (Value: ${arr[i]})`;
        
        // Highlight current element
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElement = elements[i].querySelector('.element-value');
        currentElement.classList.add('abs-diff-current');
        
        // Add step description
        const stepElement = document.createElement('div');
        stepElement.className = 'algorithm-step';
        stepElement.innerHTML = `
            <strong>Step ${step}:</strong> Processing index ${i}<br>
             Value A[${i}] = ${arr[i]}<br>
             A[i] + i = ${arr[i]} + ${i} = ${valuePlusIndex}<br>
             A[i] - i = ${arr[i]} - ${i} = ${valueMinusIndex}
        `;
        stepsContainer.appendChild(stepElement);
        
        // Scroll to show current step
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Update max and min values
        let max1Updated = false, min1Updated = false;
        let max2Updated = false, min2Updated = false;
        
        if (valuePlusIndex > max1) {
            max1 = valuePlusIndex;
            max1Index = i;
            max1Updated = true;
        }
        if (valuePlusIndex < min1) {
            min1 = valuePlusIndex;
            min1Index = i;
            min1Updated = true;
        }
        if (valueMinusIndex > max2) {
            max2 = valueMinusIndex;
            max2Index = i;
            max2Updated = true;
        }
        if (valueMinusIndex < min2) {
            min2 = valueMinusIndex;
            min2Index = i;
            min2Updated = true;
        }
        
        // Wait for animation to complete before proceeding
        setTimeout(() => {
            // Add row to table
            const row = document.createElement('tr');
            
            let max1Class = max1Updated ? 'abs-diff-highlight' : '';
            let min1Class = min1Updated ? 'abs-diff-highlight' : '';
            let max2Class = max2Updated ? 'abs-diff-highlight' : '';
            let min2Class = min2Updated ? 'abs-diff-highlight' : '';
            
            row.innerHTML = `
                <td>${i}</td>
                <td>${arr[i]}</td>
                <td>${valuePlusIndex}</td>
                <td>${valueMinusIndex}</td>
                <td class="${max1Class}">${max1}${max1Updated ? '  NEW!' : ''}</td>
                <td class="${min1Class}">${min1}${min1Updated ? '  NEW!' : ''}</td>
                <td class="${max2Class}">${max2}${max2Updated ? '  NEW!' : ''}</td>
                <td class="${min2Class}">${min2}${min2Updated ? '  NEW!' : ''}</td>
            `;
            
            tableBody.appendChild(row);
            
            // Remove current highlight
            currentElement.classList.remove('abs-diff-current');
            
            // Highlight updated max/min elements
            if (max1Updated && max1Index !== -1) {
                elements[max1Index].querySelector('.element-value').classList.add('abs-diff-compared');
                setTimeout(() => {
                    elements[max1Index].querySelector('.element-value').classList.remove('abs-diff-compared');
                }, 1000);
            }
            if (min1Updated && min1Index !== -1) {
                elements[min1Index].querySelector('.element-value').classList.add('abs-diff-compared');
                setTimeout(() => {
                    elements[min1Index].querySelector('.element-value').classList.remove('abs-diff-compared');
                }, 1000);
            }
            if (max2Updated && max2Index !== -1) {
                elements[max2Index].querySelector('.element-value').classList.add('abs-diff-compared');
                setTimeout(() => {
                    elements[max2Index].querySelector('.element-value').classList.remove('abs-diff-compared');
                }, 1000);
            }
            if (min2Updated && min2Index !== -1) {
                elements[min2Index].querySelector('.element-value').classList.add('abs-diff-compared');
                setTimeout(() => {
                    elements[min2Index].querySelector('.element-value').classList.remove('abs-diff-compared');
                }, 1000);
            }
            
            // Update step description with results
            let updates = [];
            if (max1Updated) updates.push(`New max(A[i]+i) = ${max1} at index ${max1Index}`);
            if (min1Updated) updates.push(`New min(A[i]+i) = ${min1} at index ${min1Index}`);
            if (max2Updated) updates.push(`New max(A[i]-i) = ${max2} at index ${max2Index}`);
            if (min2Updated) updates.push(`New min(A[i]-i) = ${min2} at index ${min2Index}`);
            
            if (updates.length > 0) {
                const updateElement = document.createElement('div');
                updateElement.className = 'algorithm-step active';
                updateElement.innerHTML = `<strong>Updates:</strong> ${updates.join(', ')}`;
                stepsContainer.appendChild(updateElement);
                stepsContainer.scrollTop = stepsContainer.scrollHeight;
            }
            
            // Move to next index
            currentIndex++;
            
            // Continue with next step after delay
            setTimeout(performCalculationStep, 2000);
            
        }, 1500);
    }
    
    function showFinalResults() {
        const diff1 = max1 - min1;
        const diff2 = max2 - min2;
        const maxDiff = Math.max(diff1, diff2);
        
        explanation.innerHTML = `<strong>Calculation Completed!</strong> Maximum absolute difference found.`;
        
        // Add final step with detailed calculation
        const finalStep = document.createElement('div');
        finalStep.className = 'algorithm-step active';
        
        // Create calculation table for final results
        const calculationTable = document.createElement('table');
        calculationTable.className = 'abs-diff-table';
        calculationTable.style.margin = '15px 0';
        calculationTable.style.background = 'rgba(255, 255, 255, 0.1)';
        
        calculationTable.innerHTML = `
            <thead>
                <tr>
                    <th>Calculation Type</th>
                    <th>Max Value</th>
                    <th>Min Value</th>
                    <th>Difference</th>
                    <th>Result</th>
                </tr>
            </thead>
            <tbody>
                <tr class="${diff1 >= diff2 ? 'abs-diff-highlight' : ''}">
                    <td>A[i] + i</td>
                    <td>${max1} (at index ${max1Index})</td>
                    <td>${min1} (at index ${min1Index})</td>
                    <td>${max1} - ${min1}</td>
                    <td><strong>${diff1}</strong></td>
                </tr>
                <tr class="${diff2 >= diff1 ? 'abs-diff-highlight' : ''}">
                    <td>A[i] - i</td>
                    <td>${max2} (at index ${max2Index})</td>
                    <td>${min2} (at index ${min2Index})</td>
                    <td>${max2} - ${min2}</td>
                    <td><strong>${diff2}</strong></td>
                </tr>
            </tbody>
        `;
        
        finalStep.innerHTML = `
            <strong>Final Calculation:</strong>
        `;
        finalStep.appendChild(calculationTable);
        
        // Add the maximum difference display
        const maxDiffDisplay = document.createElement('div');
        maxDiffDisplay.className = 'algorithm-step active';
        maxDiffDisplay.style.background = 'rgba(253, 203, 110, 0.3)';
        maxDiffDisplay.style.border = '2px solid var(--warning-color)';
        maxDiffDisplay.style.padding = '15px';
        maxDiffDisplay.style.borderRadius = '10px';
        maxDiffDisplay.style.textAlign = 'center';
        
        if (diff1 >= diff2) {
            maxDiffDisplay.innerHTML = `
                <h6 style="color: var(--warning-color); margin-bottom: 10px;">Maximum Absolute Difference Calculation</h6>
                <div style="font-size: 1.2rem; font-weight: bold;">
                    ${max1} - ${min1} = <span style="color: var(--success-color); font-size: 1.4rem;">${diff1}</span>
                </div>
                <div style="margin-top: 10px; font-weight: bold;">
                    The maximum absolute difference is <span style="color: var(--success-color);">${maxDiff}</span>
                </div>
                <div style="font-size: 0.9rem; margin-top: 5px;">
                    (Using A[i] + i approach with indices ${min1Index} and ${max1Index})
                </div>
            `;
        } else {
            maxDiffDisplay.innerHTML = `
                <h6 style="color: var(--warning-color); margin-bottom: 10px;">Maximum Absolute Difference Calculation</h6>
                <div style="font-size: 1.2rem; font-weight: bold;">
                    ${max2} - ${min2} = <span style="color: var(--success-color); font-size: 1.4rem;">${diff2}</span>
                </div>
                <div style="margin-top: 10px; font-weight: bold;">
                    The maximum absolute difference is <span style="color: var(--success-color);">${maxDiff}</span>
                </div>
                <div style="font-size: 0.9rem; margin-top: 5px;">
                    (Using A[i] - i approach with indices ${min2Index} and ${max2Index})
                </div>
            `;
        }
        
        stepsContainer.appendChild(finalStep);
        stepsContainer.appendChild(maxDiffDisplay);
        
        // Show results in the results container
        resultsContainer.style.display = 'block';
        diff1Value.textContent = `${diff1} (from indices ${min1Index} and ${max1Index})`;
        diff2Value.textContent = `${diff2} (from indices ${min2Index} and ${max2Index})`;
        maxDiffValue.textContent = `${maxDiff}`;
        
        // Highlight the elements that give maximum difference
        const elements = arrayContainer.querySelectorAll('.array-element');
        
        let finalMinIndex, finalMaxIndex;
        if (diff1 >= diff2) {
            finalMinIndex = min1Index;
            finalMaxIndex = max1Index;
        } else {
            finalMinIndex = min2Index;
            finalMaxIndex = max2Index;
        }
        
        // Animate the final result
        setTimeout(() => {
            elements[finalMinIndex].querySelector('.element-value').classList.add('abs-diff-max');
            elements[finalMaxIndex].querySelector('.element-value').classList.add('abs-diff-max');
            
            // Add explanation for the final pair
            const pairExplanation = document.createElement('div');
            pairExplanation.className = 'algorithm-step active';
            pairExplanation.innerHTML = `
                <strong>Maximum Absolute Difference Pair:</strong><br>
                 Indices: ${finalMinIndex} and ${finalMaxIndex}<br>
                 Values: ${arr[finalMinIndex]} and ${arr[finalMaxIndex]}<br>
                 Calculation: |${arr[finalMinIndex]} - ${arr[finalMaxIndex]}| + |${finalMinIndex} - ${finalMaxIndex}| = ${Math.abs(arr[finalMinIndex] - arr[finalMaxIndex])} + ${Math.abs(finalMinIndex - finalMaxIndex)} = <strong>${maxDiff}</strong>
            `;
            stepsContainer.appendChild(pairExplanation);
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
        }, 500);
        
        continueButton.style.display = 'block';
        
        // Auto-return after 10 seconds
        setTimeout(() => {
            returnToOriginalAfterAbsDiff();
        }, 10000);
        
        continueButton.addEventListener('click', returnToOriginalAfterAbsDiff);
    }
    
    // Start calculation process after initial delay
    setTimeout(performCalculationStep, 1000);
}
// NEW: Return to Original after Maximum Absolute Difference
function returnToOriginalAfterAbsDiff() {
    // Reset to original array
    myArray = [...originalArrayForAbsDiff];
    originalArrayForAbsDiff = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMaxAbsDiffRunning = false;
    
    logOperation('Maximum absolute difference calculation completed - returned to original array', 'info');
    showNotification('Returned to original array after maximum absolute difference calculation', 'success');
}
// NEW: Maximum Sum Circular Subarray Handler
function handleMaxCircularSubarray() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isCircularSubarrayRunning) {
        showNotification('Circular subarray operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Circular subarray algorithm requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForCircular = [...myArray];
    
    // Show circular subarray visualization
    showCircularSubarrayVisualization();
}
// NEW: Show Circular Subarray Visualization
function showCircularSubarrayVisualization() {
    isCircularSubarrayRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Maximum Sum Circular Subarray</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalCircularArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find maximum sum in circular array (wrapping allowed)</p>
            <p class="mb-0" id="circularExplanation">Initializing circular subarray algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="circularStepsContainer">
            <h6 class="text-center">Circular Subarray Calculation Steps</h6>
            <div class="steps-container" id="circularSteps"></div>
        </div>
        
        <div class="table-container mt-3">
            <table class="circular-table">
                <thead>
                    <tr>
                        <th>Step</th>
                        <th>Description</th>
                        <th>Value</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody id="circularTableBody">
                    <tr>
                        <td>1</td>
                        <td>Compute Total Sum</td>
                        <td id="step1Value">-</td>
                        <td id="step1Status">Pending</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>Kadane Max (Non-Wrapping)</td>
                        <td id="step2Value">-</td>
                        <td id="step2Status">Pending</td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>Kadane Min (Find Minimum Subarray Sum)</td>
                        <td id="step3Value">-</td>
                        <td id="step3Status">Pending</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>Max Circular = Total Sum - Min Subarray</td>
                        <td id="step4Value">-</td>
                        <td id="step4Status">Pending</td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td>Final Answer = max(Kadane Max, Max Circular)</td>
                        <td id="step5Value">-</td>
                        <td id="step5Status">Pending</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="stats-card mt-3">
            <div>Maximum Circular Subarray Sum</div>
            <div class="stats-value" id="maxCircularSumValue">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Subarray Indices</div>
            <div class="stats-value" id="maxCircularIndices">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterCircular" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForCircular, 'originalCircularArray');
    
    performCircularSubarrayAlgorithm();
}

// NEW: Perform Circular Subarray Algorithm
function performCircularSubarrayAlgorithm() {
    const arrayContainer = document.getElementById('originalCircularArray');
    const explanation = document.getElementById('circularExplanation');
    const stepsContainer = document.getElementById('circularSteps');
    const maxCircularSumValue = document.getElementById('maxCircularSumValue');
    const maxCircularIndices = document.getElementById('maxCircularIndices');
    const continueButton = document.getElementById('continueAfterCircular');
    
    const arr = originalArrayForCircular.map(val => parseFloat(val));
    const n = arr.length;
    let step = 0;
    
    // Helper functions
    function getKadaneMax(arr) {
        let maxEndingHere = arr[0];
        let maxSoFar = arr[0];
        for (let i = 1; i < arr.length; i++) {
            maxEndingHere = Math.max(arr[i], maxEndingHere + arr[i]);
            maxSoFar = Math.max(maxSoFar, maxEndingHere);
        }
        return maxSoFar;
    }
    
    function getKadaneMin(arr) {
        let minEndingHere = arr[0];
        let minSoFar = arr[0];
        for (let i = 1; i < arr.length; i++) {
            minEndingHere = Math.min(arr[i], minEndingHere + arr[i]);
            minSoFar = Math.min(minSoFar, minEndingHere);
        }
        return minSoFar;
    }
    
    function getKadaneMaxIndices(arr) {
        let maxEndingHere = arr[0];
        let maxSoFar = arr[0];
        let start = 0;
        let end = 0;
        let tempStart = 0;
        
        for (let i = 1; i < arr.length; i++) {
            if (maxEndingHere < 0) {
                maxEndingHere = arr[i];
                tempStart = i;
            } else {
                maxEndingHere += arr[i];
            }
            
            if (maxEndingHere > maxSoFar) {
                maxSoFar = maxEndingHere;
                start = tempStart;
                end = i;
            }
        }
        return { start, end };
    }
    
    function getKadaneMinIndices(arr) {
        let minEndingHere = arr[0];
        let minSoFar = arr[0];
        let start = 0;
        let end = 0;
        let tempStart = 0;
        
        for (let i = 1; i < arr.length; i++) {
            if (minEndingHere > 0) {
                minEndingHere = arr[i];
                tempStart = i;
            } else {
                minEndingHere += arr[i];
            }
            
            if (minEndingHere < minSoFar) {
                minSoFar = minEndingHere;
                start = tempStart;
                end = i;
            }
        }
        return { start, end };
    }
    
    function updateTableStep(stepNum, value, status) {
        const valueCell = document.getElementById(`step${stepNum}Value`);
        const statusCell = document.getElementById(`step${stepNum}Status`);
        
        valueCell.textContent = value;
        statusCell.textContent = status;
        
        // Highlight the active step
        const tableBody = document.getElementById('circularTableBody');
        const rows = tableBody.getElementsByTagName('tr');
        for (let i = 0; i < rows.length; i++) {
            rows[i].classList.remove('circular-step-active');
        }
        if (stepNum <= 5) {
            rows[stepNum - 1].classList.add('circular-step-active');
        }
    }
    
    // Step 1: Compute Total Sum
    function executeStep1() {
        step = 1;
        explanation.innerHTML = `Step ${step}: Computing total sum of all elements`;
        updateTableStep(step, 'Computing...', 'In Progress');
        
        let totalSum = 0;
        const elements = arrayContainer.querySelectorAll('.array-element');
        
        // Animate summing all elements
        function animateSum(index) {
            if (index >= n) {
                // Step 1 completed
                updateTableStep(1, totalSum, 'Completed');
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Total Sum = ${totalSum}
                    </div>
                `;
                setTimeout(executeStep2, 1500);
                return;
            }
            
            const valueDiv = elements[index].querySelector('.element-value');
            valueDiv.classList.add('circular-current');
            
            setTimeout(() => {
                totalSum += arr[index];
                valueDiv.classList.remove('circular-current');
                valueDiv.classList.add('circular-included');
                
                // Update explanation
                explanation.innerHTML = `Step ${step}: Computing total sum... Current: ${totalSum}`;
                
                animateSum(index + 1);
            }, 800);
        }
        
        animateSum(0);
    }
    
    // Step 2: Kadane Max (Non-Wrapping)
    function executeStep2() {
        step = 2;
        explanation.innerHTML = `Step ${step}: Finding maximum subarray sum (non-wrapping) using Kadane's algorithm`;
        updateTableStep(step, 'Computing...', 'In Progress');
        
        // Reset all highlights
        const elements = arrayContainer.querySelectorAll('.array-element');
        elements.forEach(el => {
            el.querySelector('.element-value').classList.remove('circular-included', 'circular-current');
        });
        
        let maxEndingHere = arr[0];
        let maxSoFar = arr[0];
        let start = 0;
        let end = 0;
        let tempStart = 0;
        
        function animateKadaneMax(i) {
            if (i >= n) {
                // Step 2 completed
                updateTableStep(2, maxSoFar, 'Completed');
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Kadane Max = ${maxSoFar} (indices ${start} to ${end})
                    </div>
                `;
                
                // Highlight the max subarray
                for (let j = start; j <= end; j++) {
                    setTimeout(() => {
                        elements[j].querySelector('.element-value').classList.add('circular-max-subarray');
                    }, (j - start) * 200);
                }
                
                setTimeout(executeStep3, 2000);
                return;
            }
            
            const valueDiv = elements[i].querySelector('.element-value');
            valueDiv.classList.add('circular-current');
            
            setTimeout(() => {
                if (maxEndingHere < 0) {
                    maxEndingHere = arr[i];
                    tempStart = i;
                } else {
                    maxEndingHere += arr[i];
                }
                
                if (maxEndingHere > maxSoFar) {
                    maxSoFar = maxEndingHere;
                    start = tempStart;
                    end = i;
                }
                
                explanation.innerHTML = `Step ${step}: Kadane's Algorithm - Current: ${maxEndingHere}, Max: ${maxSoFar}`;
                
                valueDiv.classList.remove('circular-current');
                if (i >= start && i <= end) {
                    valueDiv.classList.add('circular-included');
                }
                
                animateKadaneMax(i + 1);
            }, 1000);
        }
        
        animateKadaneMax(1); // Start from index 1 since we initialized with index 0
    }
    
    // Step 3: Kadane Min (Find Minimum Subarray Sum)
    function executeStep3() {
        step = 3;
        explanation.innerHTML = `Step ${step}: Finding minimum subarray sum (for circular calculation)`;
        updateTableStep(step, 'Computing...', 'In Progress');
        
        // Reset all highlights
        const elements = arrayContainer.querySelectorAll('.array-element');
        elements.forEach(el => {
            el.querySelector('.element-value').classList.remove('circular-included', 'circular-max-subarray');
        });
        
        let minEndingHere = arr[0];
        let minSoFar = arr[0];
        let minStart = 0;
        let minEnd = 0;
        let tempMinStart = 0;
        
        function animateKadaneMin(i) {
            if (i >= n) {
                // Step 3 completed
                updateTableStep(3, minSoFar, 'Completed');
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Kadane Min = ${minSoFar} (indices ${minStart} to ${minEnd})
                    </div>
                `;
                
                // Highlight the min subarray
                for (let j = minStart; j <= minEnd; j++) {
                    setTimeout(() => {
                        elements[j].querySelector('.element-value').classList.add('circular-min-subarray');
                    }, (j - minStart) * 200);
                }
                
                setTimeout(executeStep4, 2000);
                return;
            }
            
            const valueDiv = elements[i].querySelector('.element-value');
            valueDiv.classList.add('circular-current');
            
            setTimeout(() => {
                if (minEndingHere > 0) {
                    minEndingHere = arr[i];
                    tempMinStart = i;
                } else {
                    minEndingHere += arr[i];
                }
                
                if (minEndingHere < minSoFar) {
                    minSoFar = minEndingHere;
                    minStart = tempMinStart;
                    minEnd = i;
                }
                
                explanation.innerHTML = `Step ${step}: Kadane Min - Current: ${minEndingHere}, Min: ${minSoFar}`;
                
                valueDiv.classList.remove('circular-current');
                if (i >= minStart && i <= minEnd) {
                    valueDiv.classList.add('circular-included');
                }
                
                animateKadaneMin(i + 1);
            }, 1000);
        }
        
        animateKadaneMin(1);
    }
    
    // Step 4: Max Circular Calculation
    function executeStep4() {
        step = 4;
        const totalSum = arr.reduce((a, b) => a + b, 0);
        const kadaneMin = getKadaneMin(arr);
        const maxCircular = totalSum - kadaneMin;
        
        explanation.innerHTML = `Step ${step}: Max Circular = Total Sum (${totalSum}) - Min Subarray (${kadaneMin}) = ${maxCircular}`;
        updateTableStep(4, maxCircular, 'Completed');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step 4:</strong> Max Circular = ${totalSum} - ${kadaneMin} = ${maxCircular}
            </div>
        `;
        
        setTimeout(executeStep5, 1500);
    }
    
    // Step 5: Final Answer
    function executeStep5() {
        step = 5;
        const kadaneMax = getKadaneMax(arr);
        const totalSum = arr.reduce((a, b) => a + b, 0);
        const kadaneMin = getKadaneMin(arr);
        const maxCircular = totalSum - kadaneMin;
        const finalAnswer = Math.max(kadaneMax, maxCircular);
        
        explanation.innerHTML = `Step ${step}: Final Answer = max(Kadane Max: ${kadaneMax}, Max Circular: ${maxCircular}) = ${finalAnswer}`;
        updateTableStep(5, finalAnswer, 'Completed');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step 5:</strong> Final Answer = max(${kadaneMax}, ${maxCircular}) = ${finalAnswer}
            </div>
        `;
        
        // Update final results
        maxCircularSumValue.textContent = finalAnswer;
        
        // Determine which subarray gives the maximum
        const elements = arrayContainer.querySelectorAll('.array-element');
        elements.forEach(el => {
            el.querySelector('.element-value').classList.remove('circular-included', 'circular-min-subarray');
        });
        
        if (finalAnswer === kadaneMax) {
            // Highlight the non-circular max subarray
            const { start, end } = getKadaneMaxIndices(arr);
            maxCircularIndices.textContent = `Non-circular subarray (indices ${start} to ${end})`;
            for (let j = start; j <= end; j++) {
                setTimeout(() => {
                    elements[j].querySelector('.element-value').classList.add('circular-max-subarray');
                }, j * 100);
            }
        } else {
            // For circular case, highlight all elements except the min subarray
            const { start: minStart, end: minEnd } = getKadaneMinIndices(arr);
            maxCircularIndices.textContent = `Circular subarray (wrapping around, excluding indices ${minStart} to ${minEnd})`;
            for (let j = 0; j < n; j++) {
                if (j < minStart || j > minEnd) {
                    setTimeout(() => {
                        elements[j].querySelector('.element-value').classList.add('circular-max-subarray');
                    }, j * 100);
                }
            }
        }
        
        continueButton.style.display = 'block';
        
        // Auto-return after 8 seconds
        setTimeout(() => {
            returnToOriginalAfterCircular();
        }, 8000);
        
        continueButton.addEventListener('click', returnToOriginalAfterCircular);
    }
    
    // Start the algorithm
    executeStep1();
}

// NEW: Return to Original after Circular Subarray
function returnToOriginalAfterCircular() {
    // Reset to original array
    myArray = [...originalArrayForCircular];
    originalArrayForCircular = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isCircularSubarrayRunning = false;
    
    logOperation('Circular subarray algorithm completed - returned to original array', 'info');
    showNotification('Returned to original array after circular subarray operation', 'success');
}
// Helper function to render array in specific container
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = `
            <div class="array-empty-state">
                <i class="fas fa-layer-group"></i>
                <h4>Array is Empty</h4>
                <p>Add some elements to get started!</p>
            </div>
        `;
        return;
    }
    
    array.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}
// NEW: Wiggle Sort II Handler
function handleWiggleSortII() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isWiggleSortRunning) {
        showNotification('Wiggle Sort II is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Wiggle Sort II requires all array elements to be numbers', 'danger');
        return;
    }
    
    if (myArray.length < 3) {
        showNotification('Wiggle Sort II requires at least 3 elements', 'warning');
        return;
    }
    
    isWiggleSortRunning = true;
    
    // Store original array
    originalArrayForWiggle = [...myArray];
    
    // Show Wiggle Sort II visualization
    showWiggleSortIIVisualization();
}
// NEW: Show Wiggle Sort II Visualization
function showWiggleSortIIVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Wiggle Sort II Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalWiggleArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Wiggle Sort II Process</div>
            <div class="transformed-array-container" id="transformedWiggleArray"></div>
        </div>
        
        <div class="wiggle-explanation">
            <p class="mb-2"><strong>Wiggle Sort II:</strong> Sort array such that nums[0] < nums[1] > nums[2] < nums[3]...</p>
            <p class="mb-0" id="wiggleExplanation">Initializing Wiggle Sort II algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="wiggleStepsContainer">
            <h6 class="text-center">Wiggle Sort II Steps</h6>
            <div class="steps-container" id="wiggleSteps"></div>
        </div>
        
        <div class="code-snippet mt-3">
            <strong>Algorithm Steps:</strong><br>
            1. Sort the array<br>
            2. Split into two halves: smaller and larger<br>
            3. Interleave larger and smaller elements<br>
            4. Ensure wiggle property: odd < even > next_odd
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterWiggle" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForWiggle, 'originalWiggleArray');
    renderArrayInContainer([...originalArrayForWiggle], 'transformedWiggleArray');
    
    performWiggleSortIIAnimation();
}
// NEW: Perform Wiggle Sort II Animation
function performWiggleSortIIAnimation() {
    const originalContainer = document.getElementById('originalWiggleArray');
    const transformedContainer = document.getElementById('transformedWiggleArray');
    const explanation = document.getElementById('wiggleExplanation');
    const stepsContainer = document.getElementById('wiggleSteps');
    const continueButton = document.getElementById('continueAfterWiggle');
    
    let array = [...originalArrayForWiggle].map(val => parseFloat(val));
    const n = array.length;
    let step = 0;
    
    function performWiggleStep() {
        switch (step) {
            case 0:
                // Step 1: Sort the array
                explanation.innerHTML = "Step 1: Sorting the array in ascending order";
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Sort the array: [${array.join(', ')}]  [${[...array].sort((a, b) => a - b).join(', ')}]
                    </div>
                `;
                
                // Highlight all elements
                const elements1 = transformedContainer.querySelectorAll('.array-element');
                elements1.forEach((el, index) => {
                    setTimeout(() => {
                        el.querySelector('.element-value').classList.add('wiggle-current');
                    }, index * 200);
                });
                
                setTimeout(() => {
                    // Sort the array
                    array.sort((a, b) => a - b);
                    renderArrayInContainer(array, 'transformedWiggleArray');
                    
                    // Remove highlights
                    elements1.forEach(el => {
                        el.querySelector('.element-value').classList.remove('wiggle-current');
                    });
                    
                    step++;
                    performWiggleStep();
                }, 2000);
                break;
                
            case 1:
                // Step 2: Split into two halves
                const mid = Math.floor((n + 1) / 2);
                const smaller = array.slice(0, mid);
                const larger = array.slice(mid);
                
                explanation.innerHTML = `Step 2: Split into two halves - Smaller: [${smaller.join(', ')}], Larger: [${larger.join(', ')}]`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Split at index ${mid}: Smaller=${smaller.length}, Larger=${larger.length}
                    </div>
                `;
                
                // Highlight the two halves
                const elements2 = transformedContainer.querySelectorAll('.array-element');
                for (let i = 0; i < smaller.length; i++) {
                    setTimeout(() => {
                        elements2[i].querySelector('.element-value').classList.add('info-color');
                    }, i * 150);
                }
                for (let i = 0; i < larger.length; i++) {
                    setTimeout(() => {
                        elements2[i + smaller.length].querySelector('.element-value').classList.add('warning-color');
                    }, i * 150);
                }
                
                step++;
                setTimeout(performWiggleStep, 2000);
                break;
                
            case 2:
                // Step 3: Interleave elements
                explanation.innerHTML = "Step 3: Interleaving larger and smaller elements";
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Interleaving elements from both halves
                    </div>
                `;
                
                const mid2 = Math.floor((n + 1) / 2);
                const result = new Array(n);
                let smallIndex = mid2 - 1;
                let largeIndex = n - 1;
                
                function interleaveStep(index) {
                    if (index >= n) {
                        step++;
                        performWiggleStep();
                        return;
                    }
                    
                    if (index % 2 === 0) {
                        // Even index: take from smaller half
                        result[index] = array[smallIndex--];
                        explanation.innerHTML = `Step 3: Even index ${index}  Smaller[${smallIndex + 1}]=${result[index]}`;
                    } else {
                        // Odd index: take from larger half
                        result[index] = array[largeIndex--];
                        explanation.innerHTML = `Step 3: Odd index ${index}  Larger[${largeIndex + 1}]=${result[index]}`;
                    }
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Interleave:</strong> result[${index}] = ${result[index]}
                        </div>
                    `;
                    
                    // Update display
                    const tempArray = [...result];
                    for (let i = index + 1; i < n; i++) {
                        tempArray[i] = array[i];
                    }
                    renderArrayInContainer(tempArray, 'transformedWiggleArray');
                    
                    // Highlight current position
                    const elements3 = transformedContainer.querySelectorAll('.array-element');
                    elements3[index].querySelector('.element-value').classList.add('wiggle-current');
                    
                    setTimeout(() => {
                        elements3[index].querySelector('.element-value').classList.remove('wiggle-current');
                        interleaveStep(index + 1);
                    }, 1000);
                }
                
                interleaveStep(0);
                break;
                
            case 3:
                // Step 4: Verify wiggle property
                explanation.innerHTML = "Step 4: Verifying wiggle property";
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 4:</strong> Checking wiggle condition: nums[0] < nums[1] > nums[2] < nums[3]...
                    </div>
                `;
                
                const finalArray = [...array];
                const mid3 = Math.floor((n + 1) / 2);
                const smaller3 = finalArray.slice(0, mid3);
                const larger3 = finalArray.slice(mid3);
                
                // Reconstruct with wiggle pattern
                for (let i = 0; i < n; i++) {
                    if (i % 2 === 0) {
                        finalArray[i] = smaller3[Math.floor(smaller3.length - 1 - i/2)];
                    } else {
                        finalArray[i] = larger3[Math.floor(larger3.length - 1 - (i-1)/2)];
                    }
                }
                
                renderArrayInContainer(finalArray, 'transformedWiggleArray');
                
                // Verify and highlight
                function verifyStep(i) {
                    if (i >= n - 1) {
                        // Verification completed
                        explanation.innerHTML = `<strong>Wiggle Sort II Completed!</strong> Array satisfies wiggle condition.`;
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Final:</strong> Wiggle Sort II completed successfully!
                            </div>
                        `;
                        
                        continueButton.style.display = 'block';
                        
                        // Auto-return after 5 seconds
                        setTimeout(() => {
                            returnToOriginalAfterWiggle();
                        }, 5000);
                        
                        continueButton.addEventListener('click', returnToOriginalAfterWiggle);
                        
                        return;
                    }
                    
                    const elements4 = transformedContainer.querySelectorAll('.array-element');
                    const current = finalArray[i];
                    const next = finalArray[i + 1];
                    
                    // Highlight current pair
                    elements4[i].querySelector('.element-value').classList.add('wiggle-current');
                    elements4[i + 1].querySelector('.element-value').classList.add('wiggle-compared');
                    
                    if (i % 2 === 0) {
                        // Even index: should be < next
                        if (current < next) {
                            explanation.innerHTML = ` Position ${i} < ${i+1}: ${current} < ${next} `;
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step active">
                                    <strong>Check ${i}:</strong> ${current} < ${next}  CORRECT
                                </div>
                            `;
                            elements4[i].querySelector('.element-value').classList.add('wiggle-correct');
                            elements4[i + 1].querySelector('.element-value').classList.add('wiggle-correct');
                        } else {
                            explanation.innerHTML = ` Position ${i} < ${i+1}: ${current} >= ${next} `;
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step active">
                                    <strong>Check ${i}:</strong> ${current} >= ${next}  INCORRECT
                                </div>
                            `;
                            elements4[i].querySelector('.element-value').classList.add('wiggle-incorrect');
                            elements4[i + 1].querySelector('.element-value').classList.add('wiggle-incorrect');
                        }
                    } else {
                        // Odd index: should be > next
                        if (current > next) {
                            explanation.innerHTML = ` Position ${i} > ${i+1}: ${current} > ${next} `;
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step active">
                                    <strong>Check ${i}:</strong> ${current} > ${next}  CORRECT
                                </div>
                            `;
                            elements4[i].querySelector('.element-value').classList.add('wiggle-correct');
                            elements4[i + 1].querySelector('.element-value').classList.add('wiggle-correct');
                        } else {
                            explanation.innerHTML = ` Position ${i} > ${i+1}: ${current} <= ${next} `;
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step active">
                                    <strong>Check ${i}:</strong> ${current} <= ${next}  INCORRECT
                                </div>
                            `;
                            elements4[i].querySelector('.element-value').classList.add('wiggle-incorrect');
                            elements4[i + 1].querySelector('.element-value').classList.add('wiggle-incorrect');
                        }
                    }
                    
                    setTimeout(() => {
                        elements4[i].querySelector('.element-value').classList.remove('wiggle-current', 'wiggle-correct', 'wiggle-incorrect');
                        elements4[i + 1].querySelector('.element-value').classList.remove('wiggle-compared', 'wiggle-correct', 'wiggle-incorrect');
                        verifyStep(i + 1);
                    }, 1500);
                }
                
                verifyStep(0);
                break;
        }
    }
    
    // Start wiggle sort process
    performWiggleStep();
}
// NEW: Return to Original after Wiggle Sort
function returnToOriginalAfterWiggle() {
    // Reset to original array
    myArray = [...originalArrayForWiggle];
    originalArrayForWiggle = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isWiggleSortRunning = false;
    
    logOperation('Wiggle Sort II completed - returned to original array', 'info');
    showNotification('Returned to original array after Wiggle Sort II', 'success');
}
// NEW: Maximum Distance Between Same Elements Handler
function handleMaxDistanceSameElements() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isMaxDistanceRunning) {
        showNotification('Maximum distance operation is already in progress', 'warning');
        return;
    }
    
    if (myArray.length < 2) {
        showNotification('Array must have at least 2 elements', 'warning');
        return;
    }
    
    isMaxDistanceRunning = true;
    
    // Store original array
    originalArrayForMaxDistance = [...myArray];
    
    // Show maximum distance visualization
    showMaxDistanceVisualization();
}
// NEW: Show Maximum Distance Visualization
function showMaxDistanceVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Maximum Distance Between Same Elements</h5>
        
        <div class="array-group">
            <div class="array-label">Array</div>
            <div class="original-array-container" id="maxDistanceArray"></div>
        </div>
        
        <div class="max-distance-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find maximum distance (j-i) where arr[i] == arr[j] and i < j</p>
            <p class="mb-0" id="maxDistanceExplanation">Initializing algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="maxDistanceStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="maxDistanceSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Maximum Distance Found</div>
            <div class="stats-value" id="maxDistanceValue">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Element with Max Distance</div>
            <div class="stats-value" id="maxDistanceElement">-</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Indices (i, j)</div>
            <div class="stats-value" id="maxDistanceIndices">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMaxDistance" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForMaxDistance, 'maxDistanceArray');
    
    performMaxDistanceAlgorithm();
}
// NEW: Perform Maximum Distance Algorithm with Animation
function performMaxDistanceAlgorithm() {
    const arrayContainer = document.getElementById('maxDistanceArray');
    const explanation = document.getElementById('maxDistanceExplanation');
    const stepsContainer = document.getElementById('maxDistanceSteps');
    const maxDistanceValue = document.getElementById('maxDistanceValue');
    const maxDistanceElement = document.getElementById('maxDistanceElement');
    const maxDistanceIndices = document.getElementById('maxDistanceIndices');
    const continueButton = document.getElementById('continueAfterMaxDistance');
    
    const arr = [...originalArrayForMaxDistance];
    let maxDistance = -1;
    let maxElement = null;
    let maxI = -1;
    let maxJ = -1;
    let step = 0;
    
    // Create a map to store first occurrence of each element
    const firstOccurrence = new Map();
    
    function executeStep(i) {
        if (i >= arr.length) {
            // Algorithm completed
            if (maxDistance === -1) {
                explanation.innerHTML = `<strong>Algorithm Completed!</strong> No duplicate elements found.`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Final:</strong> No duplicate elements found in the array
                    </div>
                `;
            } else {
                explanation.innerHTML = `<strong>Algorithm Completed!</strong> Maximum distance found for element "${maxElement}"`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Maximum distance = ${maxDistance} for element "${maxElement}" at indices (${maxI}, ${maxJ})
                    </div>
                `;
                
                // Highlight the pair with maximum distance
                const elements = arrayContainer.querySelectorAll('.array-element');
                elements[maxI].querySelector('.element-value').classList.add('max-distance-pair');
                elements[maxJ].querySelector('.element-value').classList.add('max-distance-pair');
                
                maxDistanceValue.textContent = maxDistance;
                maxDistanceElement.textContent = maxElement;
                maxDistanceIndices.textContent = `(${maxI}, ${maxJ})`;
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterMaxDistance();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterMaxDistance);
            
            return;
        }
        
        const currentElement = arr[i];
        step++;
        
        explanation.innerHTML = `Step ${step}: Processing element at index ${i} = "${currentElement}"`;
        
        // Highlight current element
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElementDiv = elements[i].querySelector('.element-value');
        currentElementDiv.classList.add('max-distance-current');
        
        setTimeout(() => {
            if (firstOccurrence.has(currentElement)) {
                const firstIndex = firstOccurrence.get(currentElement);
                const currentDistance = i - firstIndex;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step ${currentDistance > maxDistance ? 'active' : ''}">
                        <strong>Step ${step}:</strong> Found duplicate of "${currentElement}" at index ${i}. 
                        First occurrence at ${firstIndex}. Distance = ${currentDistance}
                        ${currentDistance > maxDistance ? ' (NEW MAXIMUM!)' : ''}
                    </div>
                `;
                
                // Highlight both occurrences
                const firstElementDiv = elements[firstIndex].querySelector('.element-value');
                firstElementDiv.classList.add('max-distance-checked');
                
                if (currentDistance > maxDistance) {
                    // Update maximum distance
                    maxDistance = currentDistance;
                    maxElement = currentElement;
                    maxI = firstIndex;
                    maxJ = i;
                    
                    // Highlight the new maximum pair
                    firstElementDiv.classList.add('max-distance-pair');
                    currentElementDiv.classList.add('max-distance-pair');
                    
                    explanation.innerHTML = `Step ${step}: New maximum distance found! ${currentDistance} for element "${currentElement}"`;
                }
                
            } else {
                // First occurrence of this element
                firstOccurrence.set(currentElement, i);
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step}:</strong> First occurrence of "${currentElement}" at index ${i}
                    </div>
                `;
                
                currentElementDiv.classList.add('max-distance-checked');
            }
            
            // Scroll steps container to bottom
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            // Update statistics
            if (maxDistance !== -1) {
                maxDistanceValue.textContent = maxDistance;
                maxDistanceElement.textContent = maxElement;
                maxDistanceIndices.textContent = maxI !== -1 ? `(${maxI}, ${maxJ})` : '-';
            }
            
            // Remove current highlight and move to next element
            currentElementDiv.classList.remove('max-distance-current');
            
            // Continue with next element
            executeStep(i + 1);
        }, 1500);
    }
    
    // Start algorithm execution
    executeStep(0);
}
// NEW: Return to Original after Maximum Distance Operation
function returnToOriginalAfterMaxDistance() {
    // Reset to original array
    myArray = [...originalArrayForMaxDistance];
    originalArrayForMaxDistance = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMaxDistanceRunning = false;
    
    logOperation('Maximum distance between same elements operation completed', 'info');
    showNotification('Returned to original array after maximum distance operation', 'success');
}
// NEW: Count Pairs with Difference K Handler
function handleCountPairsWithDifference() {
    const k = parseInt(pairDifferenceK.value);
    
    if (isNaN(k) || k < 0) {
        showNotification('Please enter a valid non-negative K value', 'danger');
        pairDifferenceK.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Count pairs operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    if (isCountPairsRunning) {
        showNotification('Count pairs operation is already in progress', 'warning');
        return;
    }
    
    isCountPairsRunning = true;
    
    // Store original array
    originalArrayForPairs = [...myArray];
    
    // Perform count pairs visualization
    performCountPairsWithDifference(k);
}
// NEW: Perform Count Pairs with Difference K Visualization
function performCountPairsWithDifference(k) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Count Pairs with Difference K (K = ${k})</h5>
        
        <div class="array-group">
            <div class="array-label">Array</div>
            <div class="original-array-container" id="pairsArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Count unique pairs (i,j) where |arr[i]-arr[j]| = ${k} and i < j</p>
            <p class="mb-0" id="pairsExplanation">Initializing pairs counting algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="pairsStepsContainer">
            <h6 class="text-center">Pairs Counting Steps</h6>
            <div class="steps-container" id="pairsSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Total Pairs Found</div>
            <div class="stats-value" id="totalPairsCount">0</div>
        </div>
        
        <div class="pairs-results mt-3" id="pairsResults" style="display: none;">
            <h6>Found Pairs</h6>
            <div id="pairsList"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPairs" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForPairs, 'pairsArray');
    
    executeCountPairsAlgorithm(k);
}
// NEW: Execute Count Pairs Algorithm with Animation
function executeCountPairsAlgorithm(k) {
    const arrayContainer = document.getElementById('pairsArray');
    const explanation = document.getElementById('pairsExplanation');
    const stepsContainer = document.getElementById('pairsSteps');
    const totalPairsCount = document.getElementById('totalPairsCount');
    const pairsResults = document.getElementById('pairsResults');
    const pairsList = document.getElementById('pairsList');
    const continueButton = document.getElementById('continueAfterPairs');
    
    const arr = originalArrayForPairs.map(val => parseFloat(val));
    const n = arr.length;
    let pairs = [];
    let totalPairs = 0;
    let step = 0;
    let i = 0, j = 1;
    
    function executePairsStep() {
        if (i >= n - 1) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Found ${totalPairs} unique pairs with difference ${k}.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Total pairs found = ${totalPairs}
                </div>
            `;
            
            // Show all found pairs
            if (totalPairs > 0) {
                pairsResults.style.display = 'block';
                pairsList.innerHTML = '';
                pairs.forEach(pair => {
                    const pairElement = document.createElement('div');
                    pairElement.className = 'pair-item';
                    pairElement.textContent = `(${pair.i},${pair.j})  |${arr[pair.i]}-${arr[pair.j]}|=${k}`;
                    pairsList.appendChild(pairElement);
                });
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterPairs();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterPairs);
            
            return;
        }
        
        if (j >= n) {
            // Move to next i
            i++;
            j = i + 1;
            executePairsStep();
            return;
        }
        
        step++;
        explanation.innerHTML = `Step ${step}: Checking pair (${i},${j})  |${arr[i]}-${arr[j]}| = ${Math.abs(arr[i] - arr[j])}`;
        
        // Highlight current elements being checked
        const elements = arrayContainer.querySelectorAll('.array-element');
        const elementI = elements[i].querySelector('.element-value');
        const elementJ = elements[j].querySelector('.element-value');
        
        elementI.classList.add('pair-current');
        elementJ.classList.add('pair-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Checking pair (${i},${j})  |${arr[i]}-${arr[j]}| = ${Math.abs(arr[i] - arr[j])}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            const difference = Math.abs(arr[i] - arr[j]);
            
            if (difference === k) {
                // Found a valid pair
                explanation.innerHTML = `Step ${step}: FOUND PAIR! (${i},${j})  |${arr[i]}-${arr[j]}| = ${k}`;
                
                elementI.classList.remove('pair-current');
                elementJ.classList.remove('pair-current');
                elementI.classList.add('pair-match');
                elementJ.classList.add('pair-match');
                
                // Add to pairs list
                pairs.push({ i, j });
                totalPairs++;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong> MATCH:</strong> Pair (${i},${j})  |${arr[i]}-${arr[j]}| = ${k} 
                    </div>
                `;
                
                totalPairsCount.textContent = totalPairs;
                
                setTimeout(() => {
                    elementI.classList.remove('pair-match');
                    elementJ.classList.remove('pair-match');
                    elementI.classList.add('pair-element');
                    elementJ.classList.add('pair-element');
                    
                    j++;
                    executePairsStep();
                }, 1500);
                
            } else {
                // No match
                elementI.classList.remove('pair-current');
                elementJ.classList.remove('pair-current');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>No match:</strong> Difference ${difference}  ${k}
                    </div>
                `;
                
                j++;
                executePairsStep();
            }
        }, 1000);
    }
    
    // Start algorithm execution
    executePairsStep();
}
// NEW: Return to Original after Pairs Operation
function returnToOriginalAfterPairs() {
    // Reset to original array
    myArray = [...originalArrayForPairs];
    originalArrayForPairs = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isCountPairsRunning = false;
    
    // Clear input
    pairDifferenceK.value = '';
    
    logOperation('Count pairs with difference K completed - returned to original array', 'info');
    showNotification('Returned to original array after pairs counting operation', 'success');
}
// NEW: Minimum Swaps to Bring Elements  K Handler
function handleMinSwaps() {
    const k = parseInt(minSwapsK.value);
    
    if (isNaN(k)) {
        showNotification('Please enter a valid K value', 'danger');
        minSwapsK.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Minimum swaps operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    if (isMinSwapsRunning) {
        showNotification('Minimum swaps operation is already in progress', 'warning');
        return;
    }
    
    isMinSwapsRunning = true;
    
    // Store original array
    originalArrayForMinSwaps = [...myArray];
    
    // Perform minimum swaps visualization
    performMinSwapsVisualization(k);
}
// NEW: Perform Minimum Swaps Visualization
function performMinSwapsVisualization(k) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Minimum Swaps to Bring Elements  ${k} Together</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="minSwapsArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find minimum swaps to group all elements  ${k} together</p>
            <p class="mb-0" id="minSwapsExplanation">Initializing minimum swaps algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="minSwapsStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="minSwapsSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Elements  ${k} Count</div>
            <div class="stats-value" id="validElementsCount">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Minimum Swaps Required</div>
            <div class="stats-value" id="minSwapsRequired">0</div>
        </div>
        
        <div class="swaps-results mt-3" id="swapsResults" style="display: none;">
            <h6>Swap Operations</h6>
            <div id="swapsList"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMinSwaps" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForMinSwaps, 'minSwapsArray');
    
    executeMinSwapsAlgorithm(k);
}
// NEW: Execute Minimum Swaps Algorithm with Animation
function executeMinSwapsAlgorithm(k) {
    const arrayContainer = document.getElementById('minSwapsArray');
    const explanation = document.getElementById('minSwapsExplanation');
    const stepsContainer = document.getElementById('minSwapsSteps');
    const validElementsCount = document.getElementById('validElementsCount');
    const minSwapsRequired = document.getElementById('minSwapsRequired');
    const swapsResults = document.getElementById('swapsResults');
    const swapsList = document.getElementById('swapsList');
    const continueButton = document.getElementById('continueAfterMinSwaps');
    
    const arr = originalArrayForMinSwaps.map(val => parseFloat(val));
    const n = arr.length;
    
    // Step 1: Count elements <= k
    let validCount = 0;
    let step = 0;
    let swaps = [];
    
    function executeAlgorithmStep() {
        switch (step) {
            case 0:
                // Step 1: Count valid elements and highlight them
                explanation.innerHTML = `Step 1: Counting elements  ${k}`;
                
                countValidElements();
                break;
                
            case 1:
                // Step 2: If no valid elements or all valid, no swaps needed
                if (validCount === 0 || validCount === n) {
                    explanation.innerHTML = validCount === 0 ? 
                        `No elements  ${k} found. Minimum swaps = 0` : 
                        `All elements are  ${k}. Minimum swaps = 0`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Result:</strong> Minimum swaps required = 0
                        </div>
                    `;
                    
                    minSwapsRequired.textContent = '0';
                    completeAlgorithm();
                    return;
                }
                
                explanation.innerHTML = `Step 2: Found ${validCount} elements  ${k}. Using sliding window of size ${validCount}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Window size = ${validCount} (number of elements  ${k})
                    </div>
                `;
                
                step++;
                setTimeout(executeAlgorithmStep, 2000);
                break;
                
            case 2:
                // Step 3: Find window with maximum valid elements
                explanation.innerHTML = `Step 3: Finding window with maximum valid elements`;
                findOptimalWindow();
                break;
                
            case 3:
                // Step 4: Calculate and perform minimum swaps
                explanation.innerHTML = `Step 4: Calculating minimum swaps required`;
                calculateMinimumSwaps();
                break;
        }
    }
    
    function countValidElements() {
        let currentIndex = 0;
        
        function countNextElement() {
            if (currentIndex >= n) {
                // Counting completed
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1 Complete:</strong> Found ${validCount} elements  ${k}
                    </div>
                `;
                
                validElementsCount.textContent = validCount;
                step++;
                setTimeout(executeAlgorithmStep, 1500);
                return;
            }
            
            const elements = arrayContainer.querySelectorAll('.array-element');
            const currentElement = elements[currentIndex].querySelector('.element-value');
            
            if (arr[currentIndex] <= k) {
                validCount++;
                currentElement.classList.add('valid-element');
                explanation.innerHTML = `Counting: [${currentIndex}] = ${arr[currentIndex]}  ${k}  (Count: ${validCount})`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Element ${currentIndex}:</strong> ${arr[currentIndex]}  ${k}  (Valid)
                    </div>
                `;
            } else {
                currentElement.classList.add('invalid-element');
                explanation.innerHTML = `Counting: [${currentIndex}] = ${arr[currentIndex]} > ${k}  (Count: ${validCount})`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Element ${currentIndex}:</strong> ${arr[currentIndex]} > ${k}  (Invalid)
                    </div>
                `;
            }
            
            // Scroll steps container
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            currentIndex++;
            setTimeout(countNextElement, 800);
        }
        
        countNextElement();
    }
    
    function findOptimalWindow() {
        let maxValidInWindow = 0;
        let currentValid = 0;
        
        // Count valid elements in first window
        for (let i = 0; i < validCount; i++) {
            if (arr[i] <= k) currentValid++;
        }
        
        maxValidInWindow = currentValid;
        let bestWindowStart = 0;
        
        let left = 0;
        let right = validCount - 1;
        
        function slideWindow() {
            if (right >= n - 1) {
                // Window sliding completed
                explanation.innerHTML = `Best window found at [${bestWindowStart}-${bestWindowStart + validCount - 1}] with ${maxValidInWindow} valid elements`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3 Complete:</strong> Best window has ${maxValidInWindow} valid elements
                    </div>
                `;
                
                // Highlight the best window
                const elements = arrayContainer.querySelectorAll('.array-element');
                for (let i = bestWindowStart; i < bestWindowStart + validCount; i++) {
                    elements[i].querySelector('.element-value').classList.add('window-boundary');
                }
                
                step++;
                setTimeout(executeAlgorithmStep, 2000);
                return;
            }
            
            // Move window right
            if (arr[left] <= k) currentValid--;
            left++;
            right++;
            if (arr[right] <= k) currentValid++;
            
            if (currentValid > maxValidInWindow) {
                maxValidInWindow = currentValid;
                bestWindowStart = left;
            }
            
            explanation.innerHTML = `Window [${left}-${right}]: ${currentValid} valid elements (Max: ${maxValidInWindow})`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Window [${left}-${right}]:</strong> ${currentValid} valid elements
                </div>
            `;
            
            // Highlight current window
            const elements = arrayContainer.querySelectorAll('.array-element');
            
            // Remove previous window highlights
            elements.forEach(el => {
                el.querySelector('.element-value').classList.remove('window-boundary');
            });
            
            // Add current window highlight
            for (let i = left; i <= right; i++) {
                elements[i].querySelector('.element-value').classList.add('window-boundary');
            }
            
            // Scroll steps container
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            setTimeout(slideWindow, 1200);
        }
        
        // Highlight initial window
        const elements = arrayContainer.querySelectorAll('.array-element');
        for (let i = 0; i < validCount; i++) {
            elements[i].querySelector('.element-value').classList.add('window-boundary');
        }
        
        explanation.innerHTML = `Initial window [0-${validCount - 1}]: ${currentValid} valid elements`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Initial Window:</strong> [0-${validCount - 1}] has ${currentValid} valid elements
            </div>
        `;
        
        setTimeout(slideWindow, 1500);
    }
    
    function calculateMinimumSwaps() {
        // Calculate minimum swaps = total valid elements - max valid elements in any window
        let maxValidInWindow = 0;
        let currentValid = 0;
        
        // Find maximum valid elements in any window of size validCount
        for (let i = 0; i < validCount; i++) {
            if (arr[i] <= k) currentValid++;
        }
        maxValidInWindow = currentValid;
        
        for (let i = validCount; i < n; i++) {
            if (arr[i - validCount] <= k) currentValid--;
            if (arr[i] <= k) currentValid++;
            if (currentValid > maxValidInWindow) {
                maxValidInWindow = currentValid;
            }
        }
        
        const minSwaps = validCount - maxValidInWindow;
        
        explanation.innerHTML = `Minimum swaps = ${validCount} (total valid) - ${maxValidInWindow} (max in window) = ${minSwaps}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Calculation:</strong> ${validCount} - ${maxValidInWindow} = ${minSwaps} swaps needed
            </div>
        `;
        
        minSwapsRequired.textContent = minSwaps;
        
        // Show swap operations explanation
        if (minSwaps > 0) {
            swapsResults.style.display = 'block';
            swapsList.innerHTML = `
                <div class="swap-operation">
                    We need to swap ${minSwaps} invalid elements from the optimal window with valid elements outside
                </div>
                <div class="swap-operation">
                    Each swap replaces one invalid element inside with one valid element outside
                </div>
                <div class="swap-operation">
                    Total swaps required: ${minSwaps}
                </div>
            `;
        }
        
        completeAlgorithm();
    }
    
    function completeAlgorithm() {
        explanation.innerHTML = `<strong>Algorithm Completed!</strong> Minimum swaps required = ${minSwapsRequired.textContent}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Final Result:</strong> Minimum swaps to group elements  ${k} = ${minSwapsRequired.textContent}
            </div>
        `;
        
        continueButton.style.display = 'block';
        
        // Auto-return after 30 seconds
        setTimeout(() => {
            returnToOriginalAfterMinSwaps();
        }, 30000);
        
        continueButton.addEventListener('click', returnToOriginalAfterMinSwaps);
    }
    
    // Start algorithm execution
    executeAlgorithmStep();
}
// NEW: Return to Original after Minimum Swaps Operation
function returnToOriginalAfterMinSwaps() {
    // Reset to original array
    myArray = [...originalArrayForMinSwaps];
    originalArrayForMinSwaps = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMinSwapsRunning = false;
    
    // Clear input
    minSwapsK.value = '';
    
    logOperation('Minimum swaps operation completed - returned to original array', 'info');
    showNotification('Returned to original array after minimum swaps operation', 'success');
}
// NEW: Find Missing and Repeating Number Handler
function handleFindMissingRepeating() {
    console.log('handleFindMissingRepeating called');
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isMissingRepeatingRunning) {
        showNotification('Missing/Repeating operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains only numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseInt(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('This operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Convert array to numbers
    const numArray = myArray.map(val => parseInt(val));
    
    // Check if array contains numbers from 1 to n (with one missing and one duplicate)
    const n = numArray.length;
    const expectedSum = n * (n + 1) / 2;
    const actualSum = numArray.reduce((sum, val) => sum + val, 0);
    
    // This is a simple check - in real scenario we'd need more validation
    if (Math.abs(actualSum - expectedSum) > n) {
        showNotification('Array may not follow the pattern of numbers 1 to n with one missing and one repeated', 'warning');
    }
    
    const method = missingRepeatingMethod.value;
    console.log('Selected method:', method);
    isMissingRepeatingRunning = true;
    
    // Store original array
    originalArrayForMissingRepeating = [...myArray];
    console.log('Original array stored:', originalArrayForMissingRepeating);
    
    // Show visualization based on selected method
    if (method === 'math') {
        console.log('Calling showMathMethodVisualization');
        showMathMethodVisualization(numArray);
    } else {
        console.log('Calling showXORMethodVisualization');
        showXORMethodVisualization(numArray);
    }
}

// NEW: Show Math Method Visualization
function showMathMethodVisualization(numArray) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find Missing & Repeating (Math Method)</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalMathArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Math Method:</strong> Using sum and sum of squares to find missing and repeating numbers</p>
            <p class="mb-0" id="mathExplanation">Initializing math method calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="mathStepsContainer">
            <h6 class="text-center">Math Method Steps</h6>
            <div class="steps-container" id="mathSteps"></div>
        </div>
        
        <div class="missing-repeating-results" id="mathResults" style="display: none;">
            <h6 class="text-center">Results</h6>
            <div class="stats-card">
                <div>Repeating Number</div>
                <div class="stats-value" id="repeatingNumber">-</div>
            </div>
            <div class="stats-card">
                <div>Missing Number</div>
                <div class="stats-value" id="missingNumber">-</div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMath" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForMissingRepeating, 'originalMathArray');
    
    performMathMethodAnimation(numArray);
}

// NEW: Perform Math Method Animation
function performMathMethodAnimation(numArray) {
    const arrayContainer = document.getElementById('originalMathArray');
    const explanation = document.getElementById('mathExplanation');
    const stepsContainer = document.getElementById('mathSteps');
    const resultsDiv = document.getElementById('mathResults');
    const repeatingNumberDiv = document.getElementById('repeatingNumber');
    const missingNumberDiv = document.getElementById('missingNumber');
    const continueButton = document.getElementById('continueAfterMath');
    
    const n = numArray.length;
    let step = 0;
    
    // Define variables at function scope to avoid block scoping issues
    let expectedSum, actualSum, sumDiff;
    let expectedSumSq, actualSumSq, sumSqDiff;
    let expectedSumFinal, actualSumFinal, sumDiffFinal;
    let expectedSumSqFinal, actualSumSqFinal, sumSqDiffFinal;
    let sumXY, x, y;
    let repeating, missing;
    
    // Define cleanup function locally to ensure it's accessible
    const cleanupMathOperation = () => {
        console.log('Cleanup function called for Math method');
        
        // Reset to original array
        myArray = [...originalArrayForMissingRepeating];
        originalArrayForMissingRepeating = [];
        
        // Remove visualization and return to normal view
        const mainContainer = document.getElementById('arrayContainer');
        if (mainContainer) {
            mainContainer.innerHTML = '';
            renderArray();
            updateStats();
        }
        
        // Reset state
        isMissingRepeatingRunning = false;
        
        logOperation('Missing/Repeating operation completed - returned to original array', 'info');
        showNotification('Returned to original array after missing/repeating operation', 'success');
    };
    
    function performMathStep() {
        console.log('Math step:', step);
        
        switch (step) {
            case 0:
                // Step 1: Calculate expected sum
                explanation.innerHTML = 'Step 1: Calculate expected sum of numbers 1 to n';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Expected sum = n(n+1)/2 = ${n}${n+1}/2 = ${n*(n+1)/2}
                    </div>
                `;
                break;
                
            case 1:
                // Step 2: Calculate actual sum
                explanation.innerHTML = 'Step 2: Calculate actual sum of array elements';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Actual sum = ${numArray.join(' + ')} = ${numArray.reduce((a, b) => a + b, 0)}
                    </div>
                `;
                
                // Highlight all elements while calculating sum
                const elements = arrayContainer.querySelectorAll('.array-element');
                elements.forEach((el, index) => {
                    setTimeout(() => {
                        el.querySelector('.element-value').classList.add('window-included');
                    }, index * 200);
                });
                break;
                
            case 2:
                // Step 3: Calculate difference
                expectedSum = n * (n + 1) / 2;
                actualSum = numArray.reduce((a, b) => a + b, 0);
                sumDiff = actualSum - expectedSum;
                
                explanation.innerHTML = `Step 3: Calculate difference between actual and expected sums`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Difference = Actual sum - Expected sum = ${actualSum} - ${expectedSum} = ${sumDiff}
                    </div>
                `;
                break;
                
            case 3:
                // Step 4: Calculate sum of squares
                explanation.innerHTML = 'Step 4: Calculate expected and actual sum of squares';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 4:</strong> Calculating sum of squares...
                    </div>
                `;
                break;
                
            case 4:
                // Step 5: Show sum of squares results
                expectedSumSq = n * (n + 1) * (2 * n + 1) / 6;
                actualSumSq = numArray.reduce((a, b) => a + b * b, 0);
                sumSqDiff = actualSumSq - expectedSumSq;
                
                explanation.innerHTML = 'Step 5: Calculate difference between sum of squares';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 5:</strong> Sum of squares difference = ${actualSumSq} - ${expectedSumSq} = ${sumSqDiff}
                    </div>
                `;
                break;
                
            case 5:
                // Step 6: Solve equations
                expectedSumFinal = n * (n + 1) / 2;
                actualSumFinal = numArray.reduce((a, b) => a + b, 0);
                sumDiffFinal = actualSumFinal - expectedSumFinal;
                
                expectedSumSqFinal = n * (n + 1) * (2 * n + 1) / 6;
                actualSumSqFinal = numArray.reduce((a, b) => a + b * b, 0);
                sumSqDiffFinal = actualSumSqFinal - expectedSumSqFinal;
                
                // Solve: x - y = sumDiff, x - y = sumSqDiff
                // => (x-y)(x+y) = sumSqDiff => x+y = sumSqDiff/sumDiff
                sumXY = sumSqDiffFinal / sumDiffFinal;
                x = (sumDiffFinal + sumXY) / 2; // repeating
                y = (sumXY - sumDiffFinal) / 2; // missing
                
                explanation.innerHTML = 'Step 6: Solve equations to find missing and repeating numbers';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 6:</strong> 
                        Let x = repeating, y = missing<br>
                        x - y = ${sumDiffFinal}<br>
                        x + y = ${sumXY}<br>
                        Solving: x = ${x}, y = ${y}
                    </div>
                `;
                break;
                
            case 6:
                // Step 7: Show results
                repeating = Math.round((sumDiffFinal + (sumSqDiffFinal / sumDiffFinal)) / 2);
                missing = Math.round(((sumSqDiffFinal / sumDiffFinal) - sumDiffFinal) / 2);
                
                explanation.innerHTML = `<strong>Calculation Complete!</strong> Found missing and repeating numbers.`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final Result:</strong> 
                        Repeating number = ${repeating}, Missing number = ${missing}
                    </div>
                `;
                
                // Show results
                resultsDiv.style.display = 'block';
                repeatingNumberDiv.textContent = repeating;
                missingNumberDiv.textContent = missing;
                
                // Highlight the numbers in the array
                const allElements = arrayContainer.querySelectorAll('.array-element');
                allElements.forEach((el, index) => {
                    const value = parseInt(numArray[index]);
                    if (value === repeating) {
                        el.querySelector('.element-value').classList.add('repeating-number');
                    }
                });
                
                // Show missing number visualization
                setTimeout(() => {
                    try {
                        const missingElement = document.createElement('div');
                        missingElement.className = 'array-element';
                        missingElement.innerHTML = `
                            <div class="element-value missing-number">${missing}</div>
                            <div class="element-index">Missing</div>
                        `;
                        arrayContainer.appendChild(missingElement);
                        
                        // Set up the continue button with proper cleanup
                        if (continueButton) {
                            continueButton.style.display = 'block';
                            continueButton.onclick = cleanupMathOperation;
                        }
                        
                        // Auto-return after 3 seconds (shorter time for testing)
                        console.log('Setting auto-return timeout for Math method');
                        setTimeout(() => {
                            console.log('Auto-return timeout triggered for Math method');
                            cleanupMathOperation();
                        }, 3000);
                    } catch (error) {
                        console.error('Error in final step:', error);
                        // If anything fails, still try to cleanup
                        cleanupMathOperation();
                    }
                }, 1000);
                return;
        }
        
        step++;
        setTimeout(performMathStep, 2000);
    }
    
    // Start math method process
    performMathStep();
}
// NEW: Show XOR Method Visualization
function showXORMethodVisualization(numArray) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find Missing & Repeating (XOR Method)</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalXORArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>XOR Method:</strong> Using bit manipulation to find missing and repeating numbers</p>
            <p class="mb-0" id="xorExplanation">Initializing XOR method calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="xorStepsContainer">
            <h6 class="text-center">XOR Method Steps</h6>
            <div class="steps-container" id="xorSteps"></div>
        </div>
        
        <div class="missing-repeating-results" id="xorResults" style="display: none;">
            <h6 class="text-center">Results</h6>
            <div class="stats-card">
                <div>Repeating Number</div>
                <div class="stats-value" id="xorRepeatingNumber">-</div>
            </div>
            <div class="stats-card">
                <div>Missing Number</div>
                <div class="stats-value" id="xorMissingNumber">-</div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterXOR" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForMissingRepeating, 'originalXORArray');
    
    performXORMethodAnimation(numArray);
}

// NEW: Perform XOR Method Animation
function performXORMethodAnimation(numArray) {
    const arrayContainer = document.getElementById('originalXORArray');
    const explanation = document.getElementById('xorExplanation');
    const stepsContainer = document.getElementById('xorSteps');
    const resultsDiv = document.getElementById('xorResults');
    const repeatingNumberDiv = document.getElementById('xorRepeatingNumber');
    const missingNumberDiv = document.getElementById('xorMissingNumber');
    const continueButton = document.getElementById('continueAfterXOR');
    
    const n = numArray.length;
    let step = 0;
    
    // Define cleanup function locally to ensure it's accessible
    const cleanupXOROperation = () => {
        // Reset to original array
        myArray = [...originalArrayForMissingRepeating];
        originalArrayForMissingRepeating = [];
        
        // Remove visualization and return to normal view
        const mainContainer = document.getElementById('arrayContainer');
        mainContainer.innerHTML = '';
        renderArray();
        updateStats();
        
        // Reset state
        isMissingRepeatingRunning = false;
        
        logOperation('Missing/Repeating operation completed - returned to original array', 'info');
        showNotification('Returned to original array after missing/repeating operation', 'success');
    };
    
    function performXORStep() {
        switch (step) {
            case 0:
                // Step 1: XOR all array elements and numbers 1 to n
                explanation.innerHTML = 'Step 1: Calculate XOR of all array elements and numbers 1 to n';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> XOR = (arr[0] XOR arr[1] XOR ... XOR arr[n-1]) XOR (1 XOR 2 XOR ... XOR n)
                    </div>
                `;
                
                // Visualize XOR process
                let xorAll = 0;
                const elements = arrayContainer.querySelectorAll('.array-element');
                
                elements.forEach((el, index) => {
                    setTimeout(() => {
                        const value = numArray[index];
                        xorAll ^= value;
                        el.querySelector('.element-value').classList.add('window-included');
                        
                        // Also XOR with expected number (index + 1)
                        xorAll ^= (index + 1);
                    }, index * 300);
                });
                break;
                
            case 1:
                // Step 2: Find rightmost set bit
                const xorAllFinal = numArray.reduce((xor, val, idx) => xor ^ val ^ (idx + 1), 0);
                const rightmostSetBit = xorAllFinal & -xorAllFinal;
                
                explanation.innerHTML = 'Step 2: Find rightmost set bit in XOR result';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> XOR result = ${xorAllFinal} (binary: ${xorAllFinal.toString(2)})<br>
                        Rightmost set bit = ${rightmostSetBit} (binary: ${rightmostSetBit.toString(2)})
                    </div>
                `;
                break;
                
            case 2:
                // Step 3: Separate numbers into two groups
                explanation.innerHTML = 'Step 3: Separate numbers based on rightmost set bit';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Dividing numbers into two groups based on the set bit
                    </div>
                `;
                break;
                
            case 3:
                // Step 4: Find repeating and missing numbers
                const xorFinal = numArray.reduce((xor, val, idx) => xor ^ val ^ (idx + 1), 0);
                const setBit = xorFinal & -xorFinal;
                
                let x = 0, y = 0;
                
                // Group 1: Numbers with the set bit
                for (let i = 0; i < n; i++) {
                    if (numArray[i] & setBit) {
                        x ^= numArray[i];
                    }
                    if ((i + 1) & setBit) {
                        x ^= (i + 1);
                    }
                }
                
                // Group 2: Numbers without the set bit
                for (let i = 0; i < n; i++) {
                    if (!(numArray[i] & setBit)) {
                        y ^= numArray[i];
                    }
                    if (!((i + 1) & setBit)) {
                        y ^= (i + 1);
                    }
                }
                
                // Determine which is repeating and which is missing
                let repeating, missing;
                if (numArray.includes(x)) {
                    repeating = x;
                    missing = y;
                } else {
                    repeating = y;
                    missing = x;
                }
                
                explanation.innerHTML = 'Step 4: Identify repeating and missing numbers';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 4:</strong> 
                        Group 1 XOR = ${x}, Group 2 XOR = ${y}<br>
                        Repeating number = ${repeating}, Missing number = ${missing}
                    </div>
                `;
                break;
                
            case 4:
                // Step 5: Show final results
                const finalXOR = numArray.reduce((xor, val, idx) => xor ^ val ^ (idx + 1), 0);
                const finalSetBit = finalXOR & -finalXOR;
                let group1 = 0, group2 = 0;
                
                for (let i = 0; i < n; i++) {
                    if (numArray[i] & finalSetBit) {
                        group1 ^= numArray[i];
                    } else {
                        group2 ^= numArray[i];
                    }
                    if ((i + 1) & finalSetBit) {
                        group1 ^= (i + 1);
                    } else {
                        group2 ^= (i + 1);
                    }
                }
                
                const finalRepeating = numArray.includes(group1) ? group1 : group2;
                const finalMissing = numArray.includes(group1) ? group2 : group1;
                
                explanation.innerHTML = `<strong>XOR Method Complete!</strong> Found missing and repeating numbers.`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final Result:</strong> 
                        Repeating number = ${finalRepeating}, Missing number = ${finalMissing}
                    </div>
                `;
                
                // Show results
                resultsDiv.style.display = 'block';
                repeatingNumberDiv.textContent = finalRepeating;
                missingNumberDiv.textContent = finalMissing;
                
                // Highlight the repeating number in the array
                const allElements = arrayContainer.querySelectorAll('.array-element');
                allElements.forEach((el, index) => {
                    const value = parseInt(numArray[index]);
                    if (value === finalRepeating) {
                        el.querySelector('.element-value').classList.add('repeating-number');
                    }
                });
                
                // Show missing number visualization
                setTimeout(() => {
                    const missingElement = document.createElement('div');
                    missingElement.className = 'array-element';
                    missingElement.innerHTML = `
                        <div class="element-value missing-number">${finalMissing}</div>
                        <div class="element-index">Missing</div>
                    `;
                    arrayContainer.appendChild(missingElement);
                    
                    // Set up the continue button with proper cleanup
                    continueButton.style.display = 'block';
                    continueButton.onclick = cleanupXOROperation;
                    
                    // Auto-return after 5 seconds
                    setTimeout(cleanupXOROperation, 5000);
                }, 1000);
                return;
        }
        
        step++;
        setTimeout(performXORStep, 2000);
    }
    
    // Start XOR method process
    performXORStep();
}

// NEW: Return to Original after Missing/Repeating Operation (Global fallback)
function returnToOriginalAfterMissingRepeating() {
    // Reset to original array
    myArray = [...originalArrayForMissingRepeating];
    originalArrayForMissingRepeating = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMissingRepeatingRunning = false;
    
    logOperation('Missing/Repeating operation completed - returned to original array', 'info');
    showNotification('Returned to original array after missing/repeating operation', 'success');
}
// NEW: Find First Repeating Element Handler
function handleFindFirstRepeating() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isFirstRepeatingRunning) {
        showNotification('First repeating element search is already in progress', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - no repeating elements possible', 'info');
        return;
    }
    
    isFirstRepeatingRunning = true;
    
    // Store original array
    originalArrayForRepeating = [...myArray];
    
    // Show first repeating element visualization
    showFirstRepeatingVisualization();
}
// NEW: Show First Repeating Visualization
function showFirstRepeatingVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find First Repeating Element</h5>
        
        <div class="array-group">
            <div class="array-label">Array</div>
            <div class="original-array-container" id="repeatingArray"></div>
        </div>
        
        <div class="repeating-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find the first element that repeats in the array</p>
            <p class="mb-0" id="repeatingExplanation">Starting first repeating element search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="repeatingStepsContainer">
            <h6 class="text-center">Search Steps</h6>
            <div class="steps-container" id="repeatingSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>First Repeating Element</div>
            <div class="stats-value" id="firstRepeatingValue">Not found</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Found at Index</div>
            <div class="stats-value" id="firstRepeatingIndex">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterRepeating" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForRepeating, 'repeatingArray');
    
    performFirstRepeatingSearch();
}
// NEW: Perform First Repeating Search with Animation
function performFirstRepeatingSearch() {
    const arrayContainer = document.getElementById('repeatingArray');
    const explanation = document.getElementById('repeatingExplanation');
    const stepsContainer = document.getElementById('repeatingSteps');
    const firstRepeatingValue = document.getElementById('firstRepeatingValue');
    const firstRepeatingIndex = document.getElementById('firstRepeatingIndex');
    const continueButton = document.getElementById('continueAfterRepeating');
    
    const arr = [...originalArrayForRepeating];
    const seen = new Set();
    let firstRepeating = null;
    let firstRepeatingIdx = -1;
    let currentIndex = 0;
    
    function performSearchStep() {
        if (currentIndex >= arr.length) {
            // Search completed
            if (firstRepeating === null) {
                explanation.innerHTML = `<strong>Search Completed!</strong> No repeating elements found in the array.`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> No repeating elements found - all elements are unique
                    </div>
                `;
                
                firstRepeatingValue.textContent = "None";
                firstRepeatingIndex.textContent = "-";
                
            } else {
                explanation.innerHTML = `<strong>Search Completed!</strong> First repeating element found!`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> First repeating element is "${firstRepeating}" at index ${firstRepeatingIdx}
                    </div>
                `;
                
                firstRepeatingValue.textContent = firstRepeating;
                firstRepeatingIndex.textContent = firstRepeatingIdx.toString();
                
                // Highlight the first repeating element
                const elements = arrayContainer.querySelectorAll('.array-element');
                elements[firstRepeatingIdx].querySelector('.element-value').classList.add('repeating-element');
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterRepeating();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterRepeating);
            
            return;
        }
        
        const currentElement = arr[currentIndex];
        
        explanation.innerHTML = `Checking element at index ${currentIndex}: "${currentElement}"`;
        
        // Highlight current element being checked
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElementDiv = elements[currentIndex].querySelector('.element-value');
        currentElementDiv.classList.add('checked-repeating');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${currentIndex + 1}:</strong> Checking index ${currentIndex} = "${currentElement}"
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            if (seen.has(currentElement)) {
                // Found repeating element!
                explanation.innerHTML = `Found repeating element! "${currentElement}" was seen before.`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>FOUND:</strong> "${currentElement}" is repeating! First occurrence found at index ${currentIndex}
                    </div>
                `;
                
                firstRepeating = currentElement;
                firstRepeatingIdx = currentIndex;
                
                // Highlight as repeating element
                currentElementDiv.classList.remove('checked-repeating');
                currentElementDiv.classList.add('repeating-element');
                
                // Also highlight the first occurrence
                let firstOccurrenceIndex = -1;
                for (let i = 0; i < currentIndex; i++) {
                    if (arr[i] === currentElement) {
                        firstOccurrenceIndex = i;
                        break;
                    }
                }
                
                if (firstOccurrenceIndex !== -1) {
                    elements[firstOccurrenceIndex].querySelector('.element-value').classList.add('repeating-element');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>NOTE:</strong> First occurrence of "${currentElement}" was at index ${firstOccurrenceIndex}
                        </div>
                    `;
                }
                
                // Update results
                firstRepeatingValue.textContent = firstRepeating;
                firstRepeatingIndex.textContent = firstRepeatingIdx.toString();
                
                // Move to completion
                currentIndex = arr.length;
                performSearchStep();
                
            } else {
                // Not repeating, add to seen set
                seen.add(currentElement);
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Result:</strong> "${currentElement}" is new - added to seen elements
                    </div>
                `;
                
                // Change to non-repeating check style
                currentElementDiv.classList.remove('checked-repeating');
                currentElementDiv.classList.add('non-repeating-check');
                
                currentIndex++;
                performSearchStep();
            }
        }, 1500);
    }
    
    // Start search process
    performSearchStep();
}
// NEW: Return to Original after Repeating Search
function returnToOriginalAfterRepeating() {
    // Reset to original array
    myArray = [...originalArrayForRepeating];
    originalArrayForRepeating = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isFirstRepeatingRunning = false;
    
    logOperation('First repeating element search completed - returned to original array', 'info');
    showNotification('Returned to original array after repeating element search', 'success');
}
// NEW: Handle Conditional Operation
function handleConditionalOperation(operation) {
    if (isConditionalOperationRunning) {
        showNotification('A conditional operation is already in progress', 'warning');
        return;
    }

    currentConditionalOperation = operation;
    isConditionalOperationRunning = true;

    // Reset arrays
    array1 = [];
    array2 = [];
    array1Size = 0;
    array2Size = 0;

    // Show input group
    conditionalOperationsGroup.style.display = 'block';
    arraySizesGroup.style.display = 'block';
    arrayElementsGroup.style.display = 'none';
    conditionGroup.style.display = 'none';

    // Set appropriate labels based on operation
    let operationName = '';
    switch(operation) {
        case 'where':
            operationName = 'Conditional Select (Where)';
            arraySize2.placeholder = 'Size of Array Y';
            break;
        case 'select':
            operationName = 'Multi-Condition Select';
            arraySize2.placeholder = 'Size of Choice Arrays';
            break;
        case 'piecewise':
            operationName = 'Piecewise Evaluate';
            arraySize2.placeholder = 'Size of Function Array';
            break;
    }

    arraySize1.placeholder = 'Size of Array/Input';
    arraySize1.focus();

    logOperation(`Started ${operationName} operation`, 'info');
    showNotification(`Started ${operationName} operation. Please set array sizes.`, 'info');
}

// NEW: Confirm Array Sizes Handler
function handleConfirmArraySizes() {
    const size1 = parseInt(arraySize1.value);
    const size2 = parseInt(arraySize2.value);

    if (isNaN(size1) || size1 < 1 || size1 > 20) {
        showNotification('Please enter a valid size for Array 1 (1-20)', 'danger');
        arraySize1.focus();
        return;
    }

    if (isNaN(size2) || size2 < 1 || size2 > 20) {
        showNotification('Please enter a valid size for Array 2 (1-20)', 'danger');
        arraySize2.focus();
        return;
    }

    array1Size = size1;
    array2Size = size2;
    array1 = [];
    array2 = [];

    // Create input fields for arrays
    createArrayInputs();

    // Show array elements group and condition group
    arrayElementsGroup.style.display = 'block';
    conditionGroup.style.display = 'block';

    showNotification(`Array sizes set. Please enter ${size1 + size2} elements.`, 'success');
    logOperation(`Array sizes set: ${size1} and ${size2}`, 'info');
}

// NEW: Create Array Inputs
function createArrayInputs() {
    // Array 1 inputs
    array1Inputs.innerHTML = '<label class="form-label">Enter elements for Array 1:</label>';
    for (let i = 0; i < array1Size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="number" class="form-control array1-element" 
                   placeholder="Enter number" data-index="${i}" step="any">
        `;
        array1Inputs.appendChild(inputGroup);
    }

    // Array 2 inputs
    array2Inputs.innerHTML = '<label class="form-label">Enter elements for Array 2:</label>';
    for (let i = 0; i < array2Size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="number" class="form-control array2-element" 
                   placeholder="Enter number" data-index="${i}" step="any">
        `;
        array2Inputs.appendChild(inputGroup);
    }

    // Add event listeners for auto-focus
    const array1Elements = array1Inputs.querySelectorAll('.array1-element');
    const array2Elements = array2Inputs.querySelectorAll('.array2-element');
    
    array1Elements.forEach((input, index) => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = array1Elements[index + 1] || array2Elements[0];
                if (nextInput) nextInput.focus();
            }
        });
    });

    array2Elements.forEach((input, index) => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = array2Elements[index + 1];
                if (nextInput) nextInput.focus();
                else conditionValue.focus();
            }
        });
    });
}

// NEW: Confirm Condition Handler (Updated)
function handleConfirmCondition() {
    // Collect array 1 elements
    const array1Inputs = document.querySelectorAll('.array1-element');
    array1 = [];
    
    for (let i = 0; i < array1Inputs.length; i++) {
        const value = array1Inputs[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all elements for Array 1. Missing element at position ${i}`, 'danger');
            array1Inputs[i].focus();
            return;
        }
        array1.push(parseFloat(value));
    }

    // Collect array 2 elements
    const array2Inputs = document.querySelectorAll('.array2-element');
    array2 = [];
    
    for (let i = 0; i < array2Inputs.length; i++) {
        const value = array2Inputs[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all elements for Array 2. Missing element at position ${i}`, 'danger');
            array2Inputs[i].focus();
            return;
        }
        array2.push(parseFloat(value));
    }

    const operator = conditionOperator.value;
    const value = parseFloat(conditionValue.value);

    if (isNaN(value)) {
        showNotification('Please enter a valid condition value', 'danger');
        conditionValue.focus();
        return;
    }

    // Store original array
    originalArrayForConditional = [...myArray];

    // Hide input group and clear inputs immediately
    conditionalOperationsGroup.style.display = 'none';
    arraySize1.value = '';
    arraySize2.value = '';
    conditionValue.value = '';
    array1Inputs.innerHTML = '';
    array2Inputs.innerHTML = '';

    // Execute the appropriate operation
    switch(currentConditionalOperation) {
        case 'where':
            performWhereOperation(array1, array2, operator, value);
            break;
        case 'select':
            performSelectOperation(array1, array2, operator, value);
            break;
        case 'piecewise':
            performPiecewiseOperation(array1, array2, operator, value);
            break;
    }
}
// NEW: Cancel Conditional Operation
function handleCancelConditional() {
    conditionalOperationsGroup.style.display = 'none';
    arraySize1.value = '';
    arraySize2.value = '';
    conditionValue.value = '';
    array1Inputs.innerHTML = '';
    array2Inputs.innerHTML = '';
    
    array1 = [];
    array2 = [];
    array1Size = 0;
    array2Size = 0;
    currentConditionalOperation = null;
    isConditionalOperationRunning = false;
    
    logOperation('Cancelled conditional operation', 'info');
    showNotification('Conditional operation cancelled', 'info');
}
// NEW: Perform Where Operation with Animation
function performWhereOperation(arr1, arr2, operator, conditionValue) {
    // Create visualization container
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Conditional Select (Where) Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Array X (True values)</div>
            <div class="original-array-container" id="arrayXDisplay"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Array Y (False values)</div>
            <div class="original-array-container" id="arrayYDisplay"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Condition: Array X ${operator} ${conditionValue}</div>
            <div class="original-array-container" id="conditionDisplay"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Result (np.where)</div>
            <div class="transformed-array-container" id="resultDisplay"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Where Operation:</strong> result[i] = X[i] if condition[i] else Y[i]</p>
            <p class="mb-0" id="whereExplanation">Starting where operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="whereStepsContainer">
            <h6 class="text-center">Where Operation Steps</h6>
            <div class="steps-container" id="whereSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterWhere" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display arrays
    renderArrayInContainer(arr1, 'arrayXDisplay');
    renderArrayInContainer(arr2, 'arrayYDisplay');
    
    // Calculate condition and result
    const condition = calculateCondition(arr1, operator, conditionValue);
    const result = [];
    for (let i = 0; i < arr1.length; i++) {
        result.push(condition[i] ? arr1[i] : arr2[i]);
    }
    
    renderArrayInContainer(condition.map(c => c ? 'True' : 'False'), 'conditionDisplay');
    renderArrayInContainer([...result], 'resultDisplay');
    
    // Animate the where operation
    animateWhereOperation(arr1, arr2, condition, result);
}

// NEW: Perform Select Operation with Animation
function performSelectOperation(inputArray, choicesArray, operator, conditionValue) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Multi-Condition Select Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Input Array</div>
            <div class="original-array-container" id="inputArrayDisplay"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Choices Array</div>
            <div class="original-array-container" id="choicesArrayDisplay"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Condition: Input ${operator} ${conditionValue}</div>
            <div class="original-array-container" id="selectConditionDisplay"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Result (np.select)</div>
            <div class="transformed-array-container" id="selectResultDisplay"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Select Operation:</strong> Choose from choices based on conditions</p>
            <p class="mb-0" id="selectExplanation">Starting select operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="selectStepsContainer">
            <h6 class="text-center">Select Operation Steps</h6>
            <div class="steps-container" id="selectSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSelect" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(inputArray, 'inputArrayDisplay');
    renderArrayInContainer(choicesArray, 'choicesArrayDisplay');
    
    const condition = calculateCondition(inputArray, operator, conditionValue);
    const result = [];
    for (let i = 0; i < inputArray.length; i++) {
        result.push(condition[i] ? choicesArray[i] : 0); // Default 0 for no match
    }
    
    renderArrayInContainer(condition.map(c => c ? 'True' : 'False'), 'selectConditionDisplay');
    renderArrayInContainer([...result], 'selectResultDisplay');
    
    animateSelectOperation(inputArray, choicesArray, condition, result);
}

// NEW: Perform Piecewise Operation with Animation
function performPiecewiseOperation(inputArray, functionsArray, operator, conditionValue) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Piecewise Evaluate Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Input Array</div>
            <div class="original-array-container" id="piecewiseInputDisplay"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Functions Array</div>
            <div class="original-array-container" id="functionsArrayDisplay"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Condition: Input ${operator} ${conditionValue}</div>
            <div class="original-array-container" id="piecewiseConditionDisplay"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Result (np.piecewise)</div>
            <div class="transformed-array-container" id="piecewiseResultDisplay"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Piecewise Operation:</strong> Apply different functions based on conditions</p>
            <p class="mb-0" id="piecewiseExplanation">Starting piecewise operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="piecewiseStepsContainer">
            <h6 class="text-center">Piecewise Operation Steps</h6>
            <div class="steps-container" id="piecewiseSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPiecewise" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(inputArray, 'piecewiseInputDisplay');
    renderArrayInContainer(functionsArray.map(f => `f(x)=${f}x`), 'functionsArrayDisplay');
    
    const condition = calculateCondition(inputArray, operator, conditionValue);
    const result = [];
    for (let i = 0; i < inputArray.length; i++) {
        if (condition[i]) {
            result.push(functionsArray[i] * inputArray[i]); // Simulate function application
        } else {
            result.push(inputArray[i]); // Default function: identity
        }
    }
    
    renderArrayInContainer(condition.map(c => c ? 'True' : 'False'), 'piecewiseConditionDisplay');
    renderArrayInContainer([...result], 'piecewiseResultDisplay');
    
    animatePiecewiseOperation(inputArray, functionsArray, condition, result);
}

// NEW: Calculate Condition
function calculateCondition(array, operator, value) {
    const condition = [];
    for (let i = 0; i < array.length; i++) {
        switch(operator) {
            case '<': condition.push(array[i] < value); break;
            case '>': condition.push(array[i] > value); break;
            case '<=': condition.push(array[i] <= value); break;
            case '>=': condition.push(array[i] >= value); break;
            case '==': condition.push(array[i] === value); break;
            case '!=': condition.push(array[i] !== value); break;
        }
    }
    return condition;
}
// NEW: Animate Where Operation
function animateWhereOperation(arr1, arr2, condition, result) {
    const arrayXDisplay = document.getElementById('arrayXDisplay');
    const arrayYDisplay = document.getElementById('arrayYDisplay');
    const conditionDisplay = document.getElementById('conditionDisplay');
    const resultDisplay = document.getElementById('resultDisplay');
    const explanation = document.getElementById('whereExplanation');
    const stepsContainer = document.getElementById('whereSteps');
    const continueButton = document.getElementById('continueAfterWhere');
    
    let step = 0;
    
    function performWhereStep(i) {
        if (i >= arr1.length) {
            // Operation completed
            explanation.innerHTML = `<strong>Where Operation Completed!</strong> Result array generated.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Where operation completed successfully
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterConditional();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterConditional);
            
            return;
        }
        
        step++;
        explanation.innerHTML = `Step ${step}: Processing element at index ${i}`;
        
        // Highlight current elements
        const xElements = arrayXDisplay.querySelectorAll('.array-element');
        const yElements = arrayYDisplay.querySelectorAll('.array-element');
        const conditionElements = conditionDisplay.querySelectorAll('.array-element');
        const resultElements = resultDisplay.querySelectorAll('.array-element');
        
        xElements[i].querySelector('.element-value').classList.add('sorting-current');
        yElements[i].querySelector('.element-value').classList.add('sorting-compared');
        conditionElements[i].querySelector('.element-value').classList.add(condition[i] ? 'success-color' : 'warning-color');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> Condition[${i}] = ${condition[i]}  
                Taking ${condition[i] ? 'X[' + i + ']=' + arr1[i] : 'Y[' + i + ']=' + arr2[i]}
            </div>
        `;
        
        setTimeout(() => {
            // Update result
            resultElements[i].querySelector('.element-value').classList.add('create', 'bounce');
            resultElements[i].querySelector('.element-value').textContent = result[i];
            
            // Remove highlights
            xElements[i].querySelector('.element-value').classList.remove('sorting-current');
            yElements[i].querySelector('.element-value').classList.remove('sorting-compared');
            
            // Move to next element
            performWhereStep(i + 1);
        }, 1500);
    }
    
    // Start animation
    performWhereStep(0);
}
// NEW: Animate Select Operation
function animateSelectOperation(inputArray, choicesArray, condition, result) {
    const inputArrayDisplay = document.getElementById('inputArrayDisplay');
    const choicesArrayDisplay = document.getElementById('choicesArrayDisplay');
    const selectConditionDisplay = document.getElementById('selectConditionDisplay');
    const selectResultDisplay = document.getElementById('selectResultDisplay');
    const explanation = document.getElementById('selectExplanation');
    const stepsContainer = document.getElementById('selectSteps');
    const continueButton = document.getElementById('continueAfterSelect');
    
    let step = 0;
    
    function performSelectStep(i) {
        if (i >= inputArray.length) {
            // Operation completed
            explanation.innerHTML = `<strong>Select Operation Completed!</strong> Result array generated.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Select operation completed successfully
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterConditional();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterConditional);
            
            return;
        }
        
        step++;
        explanation.innerHTML = `Step ${step}: Processing element at index ${i}`;
        
        // Highlight current elements
        const inputElements = inputArrayDisplay.querySelectorAll('.array-element');
        const choicesElements = choicesArrayDisplay.querySelectorAll('.array-element');
        const conditionElements = selectConditionDisplay.querySelectorAll('.array-element');
        const resultElements = selectResultDisplay.querySelectorAll('.array-element');
        
        inputElements[i].querySelector('.element-value').classList.add('sorting-current');
        choicesElements[i].querySelector('.element-value').classList.add('sorting-compared');
        conditionElements[i].querySelector('.element-value').classList.add(condition[i] ? 'success-color' : 'warning-color');
        
        const selectedValue = condition[i] ? choicesArray[i] : 0;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> Input[${i}]=${inputArray[i]}, Condition=${condition[i]}  
                ${condition[i] ? 'Taking Choice[' + i + ']=' + choicesArray[i] : 'Default=0'}
            </div>
        `;
        
        setTimeout(() => {
            // Update result
            resultElements[i].querySelector('.element-value').classList.add('create', 'bounce');
            resultElements[i].querySelector('.element-value').textContent = selectedValue;
            
            // Remove highlights
            inputElements[i].querySelector('.element-value').classList.remove('sorting-current');
            choicesElements[i].querySelector('.element-value').classList.remove('sorting-compared');
            
            // Move to next element
            performSelectStep(i + 1);
        }, 1500);
    }
    
    // Start animation
    performSelectStep(0);
}

// NEW: Animate Piecewise Operation
function animatePiecewiseOperation(inputArray, functionsArray, condition, result) {
    const piecewiseInputDisplay = document.getElementById('piecewiseInputDisplay');
    const functionsArrayDisplay = document.getElementById('functionsArrayDisplay');
    const piecewiseConditionDisplay = document.getElementById('piecewiseConditionDisplay');
    const piecewiseResultDisplay = document.getElementById('piecewiseResultDisplay');
    const explanation = document.getElementById('piecewiseExplanation');
    const stepsContainer = document.getElementById('piecewiseSteps');
    const continueButton = document.getElementById('continueAfterPiecewise');
    
    let step = 0;
    
    function performPiecewiseStep(i) {
        if (i >= inputArray.length) {
            // Operation completed
            explanation.innerHTML = `<strong>Piecewise Operation Completed!</strong> Result array generated.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Piecewise operation completed successfully
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterConditional();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterConditional);
            
            return;
        }
        
        step++;
        explanation.innerHTML = `Step ${step}: Processing element at index ${i}`;
        
        // Highlight current elements
        const inputElements = piecewiseInputDisplay.querySelectorAll('.array-element');
        const functionsElements = functionsArrayDisplay.querySelectorAll('.array-element');
        const conditionElements = piecewiseConditionDisplay.querySelectorAll('.array-element');
        const resultElements = piecewiseResultDisplay.querySelectorAll('.array-element');
        
        inputElements[i].querySelector('.element-value').classList.add('sorting-current');
        functionsElements[i].querySelector('.element-value').classList.add('sorting-compared');
        conditionElements[i].querySelector('.element-value').classList.add(condition[i] ? 'success-color' : 'warning-color');
        
        const originalValue = inputArray[i];
        const functionValue = functionsArray[i];
        const resultValue = result[i];
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> 
                Input[${i}]=${originalValue}, Condition=${condition[i]}  
                ${condition[i] ? 
                  `Applying f(x)=${functionValue}x  ${resultValue}` : 
                  `Using identity function  ${resultValue}`}
            </div>
        `;
        
        setTimeout(() => {
            // Update result
            resultElements[i].querySelector('.element-value').classList.add('create', 'bounce');
            resultElements[i].querySelector('.element-value').textContent = resultValue;
            
            // Remove highlights
            inputElements[i].querySelector('.element-value').classList.remove('sorting-current');
            functionsElements[i].querySelector('.element-value').classList.remove('sorting-compared');
            
            // Move to next element
            performPiecewiseStep(i + 1);
        }, 1500);
    }
    
    // Start animation
    performPiecewiseStep(0);
}
// NEW: Return to Original after Conditional Operations (Updated)
function returnToOriginalAfterConditional() {
    // Reset to original array
    if (originalArrayForConditional && originalArrayForConditional.length > 0) {
        myArray = [...originalArrayForConditional];
    }
    originalArrayForConditional = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    if (mainContainer) {
        mainContainer.innerHTML = '';
        renderArray();
        updateStats();
    }
    
    // Reset state
    isConditionalOperationRunning = false;
    currentConditionalOperation = null;
    
    // Clear all conditional data
    array1 = [];
    array2 = [];
    array1Size = 0;
    array2Size = 0;
    
    // Clear input fields
    if (arraySize1) arraySize1.value = '';
    if (arraySize2) arraySize2.value = '';
    if (conditionValue) conditionValue.value = '';
    if (array1Inputs) array1Inputs.innerHTML = '';
    if (array2Inputs) array2Inputs.innerHTML = '';
    
    logOperation('Conditional operation completed - returned to original array', 'info');
    showNotification('Returned to original array after conditional operation', 'success');
}
// Helper function to render arrays in specific containers
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = '<div class="array-empty-state"><p>Array is empty</p></div>';
        return;
    }
    
    array.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}
// NEW: Previous Greater/Smaller Element Handler
function handlePreviousElement(type) {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isPreviousElementRunning) {
        showNotification('A previous element operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Previous element operations require all array elements to be numbers', 'danger');
        return;
    }
    
    isPreviousElementRunning = true;
    
    // Store original array
    originalArrayForPreviousElement = [...myArray];
    
    // Show previous element visualization
    showPreviousElementVisualization(type);
}
// NEW: Show Previous Element Visualization
function showPreviousElementVisualization(type) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Previous ${type === 'greater' ? 'Greater' : 'Smaller'} Element (P${type === 'greater' ? 'G' : 'S'}E)</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalPrevElementArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Previous ${type === 'greater' ? 'Greater' : 'Smaller'} Element Analysis</div>
            <div class="transformed-array-container" id="transformedPrevElementArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>P${type === 'greater' ? 'G' : 'S'}E Algorithm:</strong> For each element, find the nearest ${type === 'greater' ? 'greater' : 'smaller'} element to its left</p>
            <p class="mb-0" id="prevElementExplanation">Initializing analysis...</p>
        </div>
        
        <!-- Final Result Container - Moved ABOVE the steps -->
        <div class="final-result-container mt-4" id="finalResultContainer" style="display: none;">
            <h6 class="text-center mb-3">Final Result</h6>
            <div class="row justify-content-center">
                <div class="col-md-5">
                    <div class="array-group">
                        <div class="array-label">Original Array</div>
                        <div class="original-array-container" id="finalOriginalArray"></div>
                    </div>
                </div>
                <div class="col-md-1 d-flex align-items-center justify-content-center">
                    <div class="operation-arrow">
                        <i class="fas fa-arrow-right"></i>
                    </div>
                </div>
                <div class="col-md-5">
                    <div class="array-group">
                        <div class="array-label">P${type === 'greater' ? 'G' : 'S'}E Array</div>
                        <div class="transformed-array-container" id="finalPrevElementArrayDisplay"></div>
                    </div>
                </div>
            </div>
            <div class="text-center mt-3" id="finalResultText"></div>
        </div>
        
        <!-- Step-by-Step Analysis - Moved BELOW the final result -->
        <div class="algorithm-steps mt-3" id="prevElementStepsContainer">
            <h6 class="text-center">Step-by-Step Analysis</h6>
            <div class="steps-container" id="prevElementSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPrevElement" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForPreviousElement, 'originalPrevElementArray');
    renderArrayInContainer([...originalArrayForPreviousElement], 'transformedPrevElementArray');
    
    performPreviousElementAnalysis(type);
}

// NEW: Perform Previous Element Analysis
function performPreviousElementAnalysis(type) {
    const originalContainer = document.getElementById('originalPrevElementArray');
    const transformedContainer = document.getElementById('transformedPrevElementArray');
    const explanation = document.getElementById('prevElementExplanation');
    const stepsContainer = document.getElementById('prevElementSteps');
    const finalResultContainer = document.getElementById('finalResultContainer');
    const finalOriginalArray = document.getElementById('finalOriginalArray');
    const finalPrevElementArrayDisplay = document.getElementById('finalPrevElementArrayDisplay');
    const finalResultText = document.getElementById('finalResultText');
    const continueButton = document.getElementById('continueAfterPrevElement');
    
    const arr = originalArrayForPreviousElement.map(val => parseFloat(val));
    const n = arr.length;
    const result = new Array(n).fill(-1);
    const resultValues = new Array(n).fill('N/A');
    let step = 0;
    let currentIndex = 0;
    
    function performAnalysisStep() {
        if (currentIndex >= n) {
            // Analysis completed
            explanation.innerHTML = `<strong>Analysis Completed!</strong> All elements processed.`;
            
            // Show final results side by side - NOW ABOVE the steps
            finalResultContainer.style.display = 'block';
            
            // Render final arrays
            renderArrayInContainer(originalArrayForPreviousElement, 'finalOriginalArray');
            renderPGEArrayInContainer(result, 'finalPrevElementArrayDisplay', type);
            
            // Create detailed result text
            let resultText = `<strong>Original Array:</strong> [${arr.join(', ')}]<br>`;
            resultText += `<strong>P${type === 'greater' ? 'G' : 'S'}E Array:</strong> [${result.join(', ')}]<br><br>`;
            resultText += `<strong>Detailed Explanation:</strong><br>`;
            
            for (let i = 0; i < n; i++) {
                resultText += `Index ${i}, Value ${arr[i]}:  P${type === 'greater' ? 'G' : 'S'}E: ${result[i]} `;
                if (result[i] === -1) {
                    resultText += `(val=N/A)`;
                } else {
                    resultText += `(val=${arr[result[i]]})`;
                }
                resultText += `<br>`;
            }
            
            finalResultText.innerHTML = resultText;
            
            // Add final step to the steps container (which is now BELOW the final result)
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> P${type === 'greater' ? 'G' : 'S'}E Array = [${result.join(', ')}]
                </div>
            `;
            
            // Highlight all elements in final result
            const finalPrevElements = finalPrevElementArrayDisplay.querySelectorAll('.array-element');
            finalPrevElements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('success-color', 'pulse');
                }, index * 200);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterPrevElement();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterPrevElement);
            
            return;
        }
        
        step++;
        const currentValue = arr[currentIndex];
        
        explanation.innerHTML = `Processing index ${currentIndex}, value = ${currentValue}`;
        
        // Highlight current element
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        const currentElement = transformedElements[currentIndex].querySelector('.element-value');
        currentElement.classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> Processing index ${currentIndex}, value = ${currentValue}
            </div>
        `;
        
        setTimeout(() => {
            if (currentIndex === 0) {
                // First element always has -1
                result[currentIndex] = -1;
                resultValues[currentIndex] = 'N/A';
                
                explanation.innerHTML = `Index ${currentIndex}: First element  P${type === 'greater' ? 'G' : 'S'}E = -1 (no previous elements)`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Result:</strong> First element  P${type === 'greater' ? 'G' : 'S'}E = -1 (no previous elements)
                    </div>
                `;
                
                // Highlight as first element
                currentElement.classList.remove('sorting-current');
                currentElement.classList.add('info-color');
                
                currentIndex++;
                performAnalysisStep();
                
            } else {
                // Search for previous greater/smaller element
                let foundIndex = -1;
                let foundValue = 'N/A';
                
                explanation.innerHTML = `Searching for previous ${type === 'greater' ? 'greater' : 'smaller'} element...`;
                
                // Start searching from currentIndex-1 backwards
                let searchIndex = currentIndex - 1;
                
                function performSearchStep() {
                    if (searchIndex < 0) {
                        // No element found
                        result[currentIndex] = -1;
                        resultValues[currentIndex] = 'N/A';
                        
                        explanation.innerHTML = `Index ${currentIndex}: No previous ${type === 'greater' ? 'greater' : 'smaller'} element found  P${type === 'greater' ? 'G' : 'S'}E = -1`;
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Result:</strong> No previous ${type === 'greater' ? 'greater' : 'smaller'} element found  P${type === 'greater' ? 'G' : 'S'}E = -1
                            </div>
                        `;
                        
                        currentElement.classList.remove('sorting-current');
                        currentElement.classList.add('warning-color');
                        
                        currentIndex++;
                        performAnalysisStep();
                        return;
                    }
                    
                    const searchValue = arr[searchIndex];
                    const isMatch = type === 'greater' ? searchValue > currentValue : searchValue < currentValue;
                    
                    // Highlight the element being checked
                    const searchElement = transformedElements[searchIndex].querySelector('.element-value');
                    searchElement.classList.add('sorting-compared');
                    
                    explanation.innerHTML = `Checking index ${searchIndex}, value = ${searchValue}...`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Check:</strong> Comparing with index ${searchIndex}, value = ${searchValue}
                        </div>
                    `;
                    
                    setTimeout(() => {
                        if (isMatch) {
                            // Found the element
                            foundIndex = searchIndex;
                            foundValue = searchValue;
                            result[currentIndex] = foundIndex;
                            resultValues[currentIndex] = foundValue;
                            
                            explanation.innerHTML = `Index ${currentIndex}: Found P${type === 'greater' ? 'G' : 'S'}E at index ${foundIndex} (value = ${foundValue})`;
                            
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step active">
                                    <strong>Found!</strong> P${type === 'greater' ? 'G' : 'S'}E = ${foundIndex} (value = ${foundValue})
                                </div>
                            `;
                            
                            // Highlight the connection
                            currentElement.classList.remove('sorting-current');
                            searchElement.classList.remove('sorting-compared');
                            currentElement.classList.add('success-color');
                            searchElement.classList.add('success-color');
                            
                            // Draw visual connection (simplified)
                            setTimeout(() => {
                                currentIndex++;
                                performAnalysisStep();
                            }, 1500);
                            
                        } else {
                            // Continue searching
                            searchElement.classList.remove('sorting-compared');
                            searchIndex--;
                            
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step">
                                    <strong>Continue:</strong> Value ${searchValue} is not ${type === 'greater' ? 'greater' : 'smaller'} than ${currentValue}
                                </div>
                            `;
                            
                            performSearchStep();
                        }
                    }, 1500);
                }
                
                // Start search
                performSearchStep();
            }
        }, 1000);
    }
    
    // Start analysis
    performAnalysisStep();
}
// NEW: Render PGE/PSE array in specific container
function renderPGEArrayInContainer(resultArray, containerId, type) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    resultArray.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        
        let displayValue = value === -1 ? '-1' : value.toString();
        let tooltip = value === -1 ? 
            `No previous ${type === 'greater' ? 'greater' : 'smaller'} element found` : 
            `Index of previous ${type === 'greater' ? 'greater' : 'smaller'} element`;
        
        arrayElement.innerHTML = `
            <div class="element-value" title="${tooltip}">${displayValue}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}

// NEW: Return to Original after Previous Element Analysis
function returnToOriginalAfterPrevElement() {
    // Reset to original array
    myArray = [...originalArrayForPreviousElement];
    originalArrayForPreviousElement = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isPreviousElementRunning = false;
    
    logOperation('Previous element analysis completed - returned to original array', 'info');
    showNotification('Returned to original array after previous element analysis', 'success');
}

// NEW: Render array in specific container
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = `
            <div class="array-empty-state">
                <i class="fas fa-layer-group"></i>
                <h4>Array is Empty</h4>
                <p>Add some elements to get started!</p>
            </div>
        `;
        return;
    }
    
    array.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}
// NEW: Find Elements by Predicate Function Handler
function handleFindByPredicate() {
    const condition = predicateCondition.value.trim();
    
    if (condition === '') {
        showNotification('Please enter a predicate condition', 'danger');
        predicateCondition.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isPredicateFilterRunning) {
        showNotification('A predicate filter operation is already in progress', 'warning');
        return;
    }
    
    // Validate the condition
    if (!isValidPredicateCondition(condition)) {
        showNotification('Invalid condition format. Use format like: arr%2==0, arr!=0, arr<5', 'danger');
        predicateCondition.focus();
        return;
    }
    
    isPredicateFilterRunning = true;
    
    // Store original array
    originalArrayForPredicate = [...myArray];
    
    // Show predicate filter visualization
    showPredicateFilterVisualization(condition);
}

// NEW: Validate Predicate Condition
function isValidPredicateCondition(condition) {
    // Basic validation - should contain 'arr' and valid operators
    const validPattern = /^arr\s*([<>!=]=?|%|\+|-|\*|\/)\s*[0-9]+$/;
    return validPattern.test(condition.replace(/\s/g, ''));
}

// NEW: Evaluate Predicate Condition
function evaluatePredicate(element, condition) {
    try {
        // Replace 'arr' with the actual element value
        const expression = condition.replace(/arr/g, `(${element})`);
        
        // Use Function constructor for safe evaluation
        return new Function(`return ${expression};`)();
    } catch (error) {
        console.error('Error evaluating predicate:', error);
        return false;
    }
}

// NEW: Show Predicate Filter Visualization
function showPredicateFilterVisualization(condition) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Filter Elements by Predicate Function</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalPredicateArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-filter"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Filtered Array (Condition: ${condition})</div>
            <div class="transformed-array-container" id="filteredPredicateArray"></div>
        </div>
        
        <div class="predicate-explanation">
            <p class="mb-2"><strong>Predicate Filter:</strong> Finding elements that satisfy: ${condition}</p>
            <p class="mb-0" id="predicateExplanation">Starting predicate filter analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="predicateStepsContainer">
            <h6 class="text-center">Filtering Steps</h6>
            <div class="steps-container" id="predicateSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Elements Matching Condition</div>
            <div class="stats-value" id="matchingCount">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPredicate" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForPredicate, 'originalPredicateArray');
    renderArrayInContainer([], 'filteredPredicateArray');
    
    performPredicateFilterAnimation(condition);
}

// NEW: Perform Predicate Filter Animation
function performPredicateFilterAnimation(condition) {
    const originalContainer = document.getElementById('originalPredicateArray');
    const filteredContainer = document.getElementById('filteredPredicateArray');
    const explanation = document.getElementById('predicateExplanation');
    const stepsContainer = document.getElementById('predicateSteps');
    const matchingCount = document.getElementById('matchingCount');
    const continueButton = document.getElementById('continueAfterPredicate');
    
    const originalArray = [...originalArrayForPredicate];
    let filteredArray = [];
    let currentIndex = 0;
    let matchCount = 0;
    
    function performFilterStep() {
        if (currentIndex >= originalArray.length) {
            // Filtering completed
            explanation.innerHTML = `<strong>Filtering Completed!</strong> Found ${matchCount} elements matching the condition.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Filtering completed! ${matchCount} elements satisfy: ${condition}
                </div>
            `;
            
            matchingCount.textContent = matchCount;
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterPredicate();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterPredicate);
            
            return;
        }
        
        const currentElement = originalArray[currentIndex];
        const elementValue = currentElement;
        
        // Update explanation
        explanation.innerHTML = `Checking element [${currentIndex}] = ${elementValue} against condition: ${condition}`;
        
        // Highlight current element being checked
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElementDiv = originalElements[currentIndex].querySelector('.element-value');
        currentElementDiv.classList.add('predicate-match');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${currentIndex + 1}:</strong> Checking [${currentIndex}] = ${elementValue} against: ${condition}
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            try {
                // Evaluate the condition
                const matches = evaluatePredicate(elementValue, condition);
                
                if (matches) {
                    // Element matches the condition
                    explanation.innerHTML = `Element [${currentIndex}] = ${elementValue} <strong class="text-success">MATCHES</strong> condition: ${condition}`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong> Match:</strong> [${currentIndex}] = ${elementValue} satisfies: ${condition}
                        </div>
                    `;
                    
                    // Add to filtered array
                    filteredArray.push(elementValue);
                    matchCount++;
                    
                    // Update filtered array display
                    renderArrayInContainer(filteredArray, 'filteredPredicateArray');
                    
                    // Highlight as match
                    currentElementDiv.classList.remove('predicate-match');
                    currentElementDiv.classList.add('predicate-match');
                    
                    // Highlight in filtered array
                    const filteredElements = filteredContainer.querySelectorAll('.array-element');
                    if (filteredElements.length > 0) {
                        const lastFilteredElement = filteredElements[filteredElements.length - 1].querySelector('.element-value');
                        lastFilteredElement.classList.add('create', 'bounce');
                    }
                    
                } else {
                    // Element doesn't match
                    explanation.innerHTML = `Element [${currentIndex}] = ${elementValue} <strong class="text-danger">DOES NOT MATCH</strong> condition: ${condition}`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong> No Match:</strong> [${currentIndex}] = ${elementValue} does not satisfy: ${condition}
                        </div>
                    `;
                    
                    // Highlight as no match
                    currentElementDiv.classList.remove('predicate-match');
                    currentElementDiv.classList.add('predicate-nomatch');
                }
                
                matchingCount.textContent = matchCount;
                
            } catch (error) {
                explanation.innerHTML = `<strong class="text-danger">Error evaluating condition for element ${elementValue}</strong>`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Error:</strong> Could not evaluate condition for element ${elementValue}
                    </div>
                `;
                
                currentElementDiv.classList.remove('predicate-match');
                currentElementDiv.classList.add('predicate-nomatch');
            }
            
            currentIndex++;
            setTimeout(performFilterStep, 1500);
        }, 1000);
    }
    
    // Start filtering process
    performFilterStep();
}

// NEW: Return to Original after Predicate Filter
function returnToOriginalAfterPredicate() {
    // Reset to original array
    myArray = [...originalArrayForPredicate];
    originalArrayForPredicate = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isPredicateFilterRunning = false;
    
    // Clear input
    predicateCondition.value = '';
    
    logOperation('Predicate filter operation completed - returned to original array', 'info');
    showNotification('Returned to original array after predicate filter operation', 'success');
}
// Helper function to render array in specific container
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = `
            <div class="array-empty-state">
                <i class="fas fa-layer-group"></i>
                <h6>Array is Empty</h6>
            </div>
        `;
        return;
    }
    
    array.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}
// NEW: Convert 1D to 2D Array Handler
function handleConvertTo2D() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isReshapeOperationRunning) {
        showNotification('A reshape operation is already in progress', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - cannot convert to 2D', 'info');
        return;
    }
    
    isReshapeOperationRunning = true;
    
    // Store original array
    originalArrayForReshape = [...myArray];
    
    // Perform reshape visualization
    performReshapeTo2D();
}

// NEW: Perform Reshape to 2D with Animation
function performReshapeTo2D() {
    const array = [...originalArrayForReshape];
    const n = array.length;
    
    // Calculate optimal dimensions
    const { rows, cols } = calculateOptimalDimensions(n);
    
    // Create matrix container
    const matrixContainer = document.createElement('div');
    matrixContainer.className = 'matrix-container';
    matrixContainer.innerHTML = `
        <h5 class="text-center mb-3">1D to 2D Array Conversion</h5>
        
        <div class="array-group">
            <div class="array-label">Original 1D Array (Length: ${n})</div>
            <div class="original-array-container" id="original1DArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Reshaped 2D Array (${rows}  ${cols})</div>
            <div id="matrix2DArray"></div>
        </div>
        
        <div class="reshape-explanation">
            <p class="mb-2"><strong>Reshape Algorithm:</strong> Automatically calculated ${rows}  ${cols} matrix for ${n} elements</p>
            <p class="mb-0" id="reshapeExplanation">Starting reshape animation...</p>
        </div>
        
        <div class="stats-card mt-3">
            <div>Matrix Dimensions</div>
            <div class="stats-value">${rows}  ${cols}</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Total Elements</div>
            <div class="stats-value">${rows * cols}</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="manualRevertBtn">
            <i class="fas fa-undo me-1"></i>Return to 1D Array Now
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(matrixContainer);
    
    // Render original 1D array
    renderArrayInContainer(array, 'original1DArray');
    
    // Start reshape animation
    animateReshapeTo2D(array, rows, cols);
}

// NEW: Calculate Optimal Dimensions
function calculateOptimalDimensions(n) {
    let rows, cols;
    
    // Check if it's a perfect square
    const sqrt = Math.sqrt(n);
    if (Number.isInteger(sqrt)) {
        // Perfect square (e.g., 4, 9, 16, 25)
        rows = cols = sqrt;
    } else {
        // Find factors that are as close to square as possible
        let bestDiff = Infinity;
        let bestRows = 1;
        let bestCols = n;
        
        for (let i = 2; i <= Math.sqrt(n); i++) {
            if (n % i === 0) {
                const j = n / i;
                const diff = Math.abs(i - j);
                if (diff < bestDiff) {
                    bestDiff = diff;
                    bestRows = i;
                    bestCols = j;
                }
            }
        }
        
        // If no good factors found, use floor(sqrt(n)) and ceil(n/floor(sqrt(n)))
        if (bestRows === 1) {
            rows = Math.floor(sqrt);
            cols = Math.ceil(n / rows);
            // Ensure rows * cols >= n
            while (rows * cols < n) {
                rows++;
                cols = Math.ceil(n / rows);
            }
        } else {
            rows = bestRows;
            cols = bestCols;
        }
    }
    
    return { rows: Math.min(rows, cols), cols: Math.max(rows, cols) };
}

// NEW: Animate Reshape to 2D
function animateReshapeTo2D(array, rows, cols) {
    const originalContainer = document.getElementById('original1DArray');
    const matrixContainer = document.getElementById('matrix2DArray');
    const explanation = document.getElementById('reshapeExplanation');
    const manualRevertBtn = document.getElementById('manualRevertBtn');
    
    // Create 2D matrix
    const matrix = [];
    let index = 0;
    
    for (let i = 0; i < rows; i++) {
        const row = [];
        for (let j = 0; j < cols; j++) {
            if (index < array.length) {
                row.push(array[index]);
                index++;
            } else {
                row.push(''); // Empty cell for incomplete rows
            }
        }
        matrix.push(row);
    }
    
    explanation.innerHTML = `Reshaping ${array.length} elements into ${rows}  ${cols} matrix...`;
    
    // Animate the transformation
    let currentRow = 0;
    let currentCol = 0;
    let animatedCount = 0;
    
    function animateNextElement() {
        if (currentRow >= rows) {
            // Animation completed
            explanation.innerHTML = `<strong>Reshape Completed!</strong> Successfully converted to ${rows}  ${cols} matrix. Auto-reverting in 10 seconds...`;
            
            // Set auto-revert timer
            autoRevertTimer = setTimeout(() => {
                revertTo1DArray();
            }, 10000);
            
            // Manual revert button
            manualRevertBtn.addEventListener('click', () => {
                clearTimeout(autoRevertTimer);
                revertTo1DArray();
            });
            
            return;
        }
        
        // Create matrix structure if not exists
        if (currentCol === 0) {
            const rowDiv = document.createElement('div');
            rowDiv.className = 'matrix-row';
            rowDiv.id = `matrix-row-${currentRow}`;
            matrixContainer.appendChild(rowDiv);
        }
        
        // Create matrix element with animation
        const elementDiv = document.createElement('div');
        elementDiv.className = 'matrix-element';
        elementDiv.textContent = matrix[currentRow][currentCol] || '';
        elementDiv.style.animationDelay = `${animatedCount * 0.1}s`;
        
        const rowDiv = document.getElementById(`matrix-row-${currentRow}`);
        rowDiv.appendChild(elementDiv);
        
        // Highlight corresponding 1D element
        const originalIndex = currentRow * cols + currentCol;
        if (originalIndex < array.length) {
            const originalElements = originalContainer.querySelectorAll('.array-element');
            if (originalElements[originalIndex]) {
                const originalElement = originalElements[originalIndex].querySelector('.element-value');
                originalElement.classList.add('create', 'pulse');
                
                // Remove highlight after animation
                setTimeout(() => {
                    originalElement.classList.remove('create', 'pulse');
                }, 500);
            }
        }
        
        animatedCount++;
        currentCol++;
        
        if (currentCol >= cols) {
            currentCol = 0;
            currentRow++;
        }
        
        setTimeout(animateNextElement, 150);
    }
    
    // Start animation
    animateNextElement();
}

// NEW: Revert to 1D Array
function revertTo1DArray() {
    // Reset to original array
    myArray = [...originalArrayForReshape];
    originalArrayForReshape = [];
    
    // Remove matrix visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isReshapeOperationRunning = false;
    
    // Show success message
    logOperation('Automatically reverted from 2D to 1D array', 'info');
    showNotification('Automatically reverted to 1D array', 'success');
    
    // Highlight all elements to show reversion
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
}
// Helper function to render array in specific container
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = '<div class="array-empty-state"><i class="fas fa-layer-group"></i><h4>Array is Empty</h4></div>';
        return;
    }
    
    array.forEach((value, index) => {
        const elementDiv = document.createElement('div');
        elementDiv.className = 'array-element';
        elementDiv.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(elementDiv);
    });
}
// NEW: Get Data Type Handler
function handleGetDataType() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    const dataType = determineArrayDataType(myArray);
    
    // Show result in search results
    searchResults.innerHTML = `
        <div class="alert alert-info">
            <h6><i class="fas fa-info-circle me-2"></i>Array Data Type Analysis</h6>
            <p class="mb-1"><strong>Array:</strong> [${myArray.join(', ')}]</p>
            <p class="mb-1"><strong>Data Type:</strong> ${dataType}</p>
            <p class="mb-0"><strong>Length:</strong> ${myArray.length} elements</p>
        </div>
    `;
    
    // Highlight all elements based on data type
    myArray.forEach((_, index) => {
        highlightElement(index, 'info');
    });
    
    logOperation(`Analyzed array data type: ${dataType}`, 'info');
    showNotification(`Array data type: ${dataType}`, 'success');
}

// NEW: Create Typed Array Handler
function handleCreateTypedArray() {
    // Show input group
    dataTypeInputGroup.style.display = 'block';
    typedArraySize.focus();
    
    logOperation('Started create array with specific data type operation', 'info');
}

// NEW: Confirm Data Type Handler
function handleConfirmDataType() {
    const size = parseInt(typedArraySize.value);
    const dataType = dataTypeSelect.value;
    
    if (isNaN(size) || size < 1 || size > 50) {
        showNotification('Please enter a valid size between 1 and 50', 'danger');
        typedArraySize.focus();
        return;
    }
    
    if (dataType === '') {
        showNotification('Please select a data type', 'danger');
        dataTypeSelect.focus();
        return;
    }
    
    // Store original array
    originalArrayForDataType = [...myArray];
    
    // Hide input group
    dataTypeInputGroup.style.display = 'none';
    typedArraySize.value = '';
    dataTypeSelect.value = '';
    
    // Create array with specified data type
    createArrayWithDataType(size, dataType);
}

// NEW: Cancel Data Type Handler
function handleCancelDataType() {
    dataTypeInputGroup.style.display = 'none';
    typedArraySize.value = '';
    dataTypeSelect.value = '';
    
    logOperation('Cancelled create typed array operation', 'info');
}

// NEW: Convert to List Handler
function handleConvertToList() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isDataTypeOperationRunning) {
        showNotification('A data type operation is already in progress', 'warning');
        return;
    }
    
    isDataTypeOperationRunning = true;
    
    // Store original array
    originalArrayForDataType = [...myArray];
    
    // Show conversion visualization
    showConvertToListVisualization();
}

// NEW: Determine Array Data Type
function determineArrayDataType(array) {
    if (array.length === 0) return 'Empty';
    
    let hasInteger = false;
    let hasFloat = false;
    let hasString = false;
    let hasBoolean = false;
    let hasChar = false;
    
    for (let i = 0; i < array.length; i++) {
        const element = array[i];
        
        // Check boolean
        if (element === 'true' || element === 'false' || element === true || element === false) {
            hasBoolean = true;
        }
        // Check integer
        else if (!isNaN(parseInt(element)) && parseInt(element).toString() === element.toString()) {
            hasInteger = true;
        }
        // Check float
        else if (!isNaN(parseFloat(element)) && parseFloat(element).toString() !== parseInt(element).toString()) {
            hasFloat = true;
        }
        // Check char (single character)
        else if (typeof element === 'string' && element.length === 1) {
            hasChar = true;
        }
        // Check string
        else if (typeof element === 'string') {
            hasString = true;
        }
    }
    
    // Determine predominant type
    if (hasBoolean && !hasInteger && !hasFloat && !hasString && !hasChar) return 'Boolean';
    if (hasInteger && !hasFloat && !hasString && !hasChar && !hasBoolean) return 'Integer';
    if (hasFloat && !hasString && !hasChar && !hasBoolean) return 'Float';
    if (hasChar && !hasString && !hasBoolean) return 'Character';
    if (hasString) return 'String';
    
    // Mixed types
    const types = [];
    if (hasInteger) types.push('Integer');
    if (hasFloat) types.push('Float');
    if (hasString) types.push('String');
    if (hasChar) types.push('Character');
    if (hasBoolean) types.push('Boolean');
    
    return `Mixed (${types.join(', ')})`;
}

// NEW: Create Array with Specific Data Type
function createArrayWithDataType(size, dataType) {
    const newArray = [];
    
    switch (dataType) {
        case 'integer':
            for (let i = 0; i < size; i++) {
                newArray.push(Math.floor(Math.random() * 100).toString());
            }
            break;
        case 'float':
            for (let i = 0; i < size; i++) {
                newArray.push((Math.random() * 100).toFixed(2));
            }
            break;
        case 'string':
            const strings = ['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig', 'grape', 'honeydew'];
            for (let i = 0; i < size; i++) {
                newArray.push(strings[Math.floor(Math.random() * strings.length)]);
            }
            break;
        case 'char':
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
            for (let i = 0; i < size; i++) {
                newArray.push(chars[Math.floor(Math.random() * chars.length)]);
            }
            break;
        case 'boolean':
            for (let i = 0; i < size; i++) {
                newArray.push(Math.random() > 0.5 ? 'true' : 'false');
            }
            break;
    }
    
    // Update the array
    myArray = newArray;
    renderArray();
    updateStats();
    
    // Show data type information
    const detectedType = determineArrayDataType(myArray);
    searchResults.innerHTML = `
        <div class="alert alert-success">
            <h6><i class="fas fa-check-circle me-2"></i>Array Created Successfully</h6>
            <p class="mb-1"><strong>Requested Type:</strong> ${dataType}</p>
            <p class="mb-1"><strong>Detected Type:</strong> ${detectedType}</p>
            <p class="mb-1"><strong>Array:</strong> [${myArray.join(', ')}]</p>
            <p class="mb-0"><strong>Size:</strong> ${size} elements</p>
        </div>
    `;
    
    // Animate all elements
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation(`Created new ${dataType} array with ${size} elements`, 'success');
    showNotification(`Created ${dataType} array with ${size} elements`, 'success');
    
    // Auto-reset after 10 seconds
    setTimeout(() => {
        resetAfterDataTypeOperation();
    }, 10000);
}

// NEW: Show Convert to List Visualization
function showConvertToListVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Convert Array to List</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalArrayDataType"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Converted List</div>
            <div class="transformed-array-container" id="transformedListDataType"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Conversion Process:</strong> Converting JavaScript array to list representation</p>
            <p class="mb-0" id="dataTypeExplanation">Starting conversion animation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="dataTypeStepsContainer">
            <h6 class="text-center">Conversion Steps</h6>
            <div class="steps-container" id="dataTypeSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>List Representation</div>
            <div class="stats-value" id="listRepresentation">[]</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterDataType" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForDataType, 'originalArrayDataType');
    renderArrayInContainer([...originalArrayForDataType], 'transformedListDataType');
    
    performConvertToListAnimation();
}

// NEW: Perform Convert to List Animation
function performConvertToListAnimation() {
    const originalContainer = document.getElementById('originalArrayDataType');
    const transformedContainer = document.getElementById('transformedListDataType');
    const explanation = document.getElementById('dataTypeExplanation');
    const stepsContainer = document.getElementById('dataTypeSteps');
    const listRepresentation = document.getElementById('listRepresentation');
    const continueButton = document.getElementById('continueAfterDataType');
    
    const array = [...originalArrayForDataType];
    let currentIndex = 0;
    
    function performConversionStep() {
        if (currentIndex >= array.length) {
            // Conversion completed
            explanation.innerHTML = '<strong>Conversion Completed!</strong> Array successfully converted to list.';
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Array converted to list: [${array.join(', ')}]
                </div>
            `;
            
            listRepresentation.textContent = `[${array.join(', ')}]`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterDataType();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterDataType);
            
            return;
        }
        
        // Update explanation
        explanation.innerHTML = `Converting element at index ${currentIndex}: "${array[currentIndex]}"`;
        
        // Highlight current element being converted
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        
        const originalElement = originalElements[currentIndex].querySelector('.element-value');
        const transformedElement = transformedElements[currentIndex].querySelector('.element-value');
        
        originalElement.classList.add('transform-animation');
        transformedElement.classList.add('transform-animation');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex + 1}:</strong> Converted element [${currentIndex}] = "${array[currentIndex]}"
            </div>
        `;
        
        // Update list representation
        const currentList = array.slice(0, currentIndex + 1);
        listRepresentation.textContent = `[${currentList.join(', ')}${currentIndex < array.length - 1 ? ', ...' : ''}]`;
        
        setTimeout(() => {
            originalElement.classList.remove('transform-animation');
            transformedElement.classList.remove('transform-animation');
            
            currentIndex++;
            performConversionStep();
        }, 1000);
    }
    
    // Start conversion process
    performConversionStep();
}

// NEW: Return to Original after Data Type Operations
function returnToOriginalAfterDataType() {
    // Reset to original array
    myArray = [...originalArrayForDataType];
    originalArrayForDataType = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isDataTypeOperationRunning = false;
    
    logOperation('Data type operation completed - returned to original array', 'info');
    showNotification('Returned to original array after data type operation', 'success');
}

// NEW: Reset after Data Type Operation
function resetAfterDataTypeOperation() {
    if (originalArrayForDataType.length === 0) {
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayForDataType];
    originalArrayForDataType = [];
    
    renderArray();
    updateStats();
    
    logOperation('Automatically reset to original array after data type operation', 'info');
    showNotification('Automatically reset to original array', 'info');
}
// NEW: Shuffle Elements Handler
function handleShuffleElements() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - cannot shuffle', 'info');
        return;
    }
    
    if (isShuffleRunning) {
        showNotification('A shuffle operation is already in progress', 'warning');
        return;
    }
    
    isShuffleRunning = true;
    
    // Store original array
    originalArrayForShuffle = [...myArray];
    
    // Show shuffle visualization
    showShuffleVisualization();
}
// NEW: Show Shuffle Visualization
function showShuffleVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Fisher-Yates (Knuth) Shuffle Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalShuffleArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-random"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Shuffling Process</div>
            <div class="transformed-array-container" id="transformedShuffleArray"></div>
        </div>
        
        <div class="shuffle-explanation">
            <p class="mb-2"><strong>Fisher-Yates Algorithm:</strong> Randomly shuffles array in-place with O(n) time complexity</p>
            <p class="mb-0" id="shuffleExplanation">Starting Fisher-Yates shuffle algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="shuffleStepsContainer">
            <h6 class="text-center">Shuffle Steps</h6>
            <div class="steps-container" id="shuffleSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterShuffle" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForShuffle, 'originalShuffleArray');
    renderArrayInContainer([...originalArrayForShuffle], 'transformedShuffleArray');
    
    performShuffleAnimation();
}
// NEW: Perform Fisher-Yates Shuffle Animation
function performShuffleAnimation() {
    const originalContainer = document.getElementById('originalShuffleArray');
    const transformedContainer = document.getElementById('transformedShuffleArray');
    const explanation = document.getElementById('shuffleExplanation');
    const stepsContainer = document.getElementById('shuffleSteps');
    const continueButton = document.getElementById('continueAfterShuffle');
    
    let array = [...originalArrayForShuffle];
    const n = array.length;
    let step = 0;
    
    function performShuffleStep(i) {
        if (i < 0) {
            // Shuffle completed
            explanation.innerHTML = `<strong>Shuffle Completed!</strong> Array has been randomly shuffled using Fisher-Yates algorithm.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Array completely shuffled! Total steps: ${n}
                </div>
            `;
            
            // Highlight all elements as shuffled
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('shuffle-completed');
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds as requested
            setTimeout(() => {
                returnToOriginalAfterShuffle();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterShuffle);
            
            return;
        }
        
        step++;
        
        if (i === n - 1) {
            // First step explanation
            explanation.innerHTML = `Step ${step}: Starting from last element (index ${i})`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Start Fisher-Yates algorithm from last element (i = ${i})
                </div>
            `;
            
            // Highlight current position
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const currentElement = transformedElements[i].querySelector('.element-value');
            currentElement.classList.add('shuffle-current');
            
            setTimeout(() => {
                currentElement.classList.remove('shuffle-current');
                performShuffleStep(i - 1);
            }, 1500);
            
        } else {
            // Generate random index between 0 and i (inclusive)
            const j = Math.floor(Math.random() * (i + 1));
            
            explanation.innerHTML = `Step ${step}: i=${i}, Random j=${j} (0 to ${i})`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${i !== j ? 'active' : ''}">
                    <strong>Step ${step}:</strong> i=${i}, Random j=${j} ${i !== j ? '- SWAPPING elements' : '- No swap (same index)'}
                </div>
            `;
            
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            
            if (i !== j) {
                // Highlight elements being swapped
                const elementI = transformedElements[i].querySelector('.element-value');
                const elementJ = transformedElements[j].querySelector('.element-value');
                
                elementI.classList.add('shuffle-current');
                elementJ.classList.add('shuffle-swap');
                
                // Calculate swap distance for animation
                const rectI = transformedElements[i].getBoundingClientRect();
                const rectJ = transformedElements[j].getBoundingClientRect();
                const swapDistance = rectJ.left - rectI.left;
                
                elementI.style.setProperty('--swap-distance', `${swapDistance}px`);
                elementJ.style.setProperty('--swap-distance', `-${swapDistance}px`);
                
                setTimeout(() => {
                    elementI.classList.add('swap-animation');
                    elementJ.classList.add('swap-animation');
                    
                    setTimeout(() => {
                        // Swap the elements
                        [array[i], array[j]] = [array[j], array[i]];
                        
                        // Update transformed array display
                        renderArrayInContainer(array, 'transformedShuffleArray');
                        
                        // Remove highlights
                        elementI.classList.remove('shuffle-current', 'shuffle-swap', 'swap-animation');
                        elementJ.classList.remove('shuffle-current', 'shuffle-swap', 'swap-animation');
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Swap ${step}:</strong> Swapped [${i}]="${array[i]}" and [${j}]="${array[j]}"
                            </div>
                        `;
                        
                        // Move to next step
                        performShuffleStep(i - 1);
                    }, 1000);
                }, 500);
            } else {
                // No swap needed (same index)
                const elementI = transformedElements[i].querySelector('.element-value');
                elementI.classList.add('shuffle-current');
                
                setTimeout(() => {
                    elementI.classList.remove('shuffle-current');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step}:</strong> No swap needed (i = j)
                        </div>
                    `;
                    
                    performShuffleStep(i - 1);
                }, 1000);
            }
        }
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
    }
    // Add this in the performShuffleAnimation function after the steps container
const algorithmCode = `
<div class="code-snippet mt-3">
    <strong>Fisher-Yates Shuffle Algorithm:</strong><br>
    function fisherYatesShuffle(arr) {<br>
    &nbsp;&nbsp;for (let i = arr.length - 1; i > 0; i--) {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;const j = Math.floor(Math.random() * (i + 1));<br>
    &nbsp;&nbsp;&nbsp;&nbsp;[arr[i], arr[j]] = [arr[j], arr[i]];<br>
    &nbsp;&nbsp;}<br>
    &nbsp;&nbsp;return arr;<br>
    }
</div>
`;

// You can insert this in the shuffleStepsContainer if you want to show the code
    
    // Start Fisher-Yates shuffle process (from last element to first)
    performShuffleStep(n - 1);
}
// NEW: Return to Original after Shuffle
function returnToOriginalAfterShuffle() {
    // Reset to original array
    myArray = [...originalArrayForShuffle];
    originalArrayForShuffle = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isShuffleRunning = false;
    
    logOperation('Fisher-Yates shuffle completed - returned to original array', 'info');
    showNotification('Returned to original array after shuffle operation', 'success');
}
// NEW: Bin Intervals Handler
function handleBinIntervals() {
    const numBins = parseInt(binCount.value);
    
    if (isNaN(numBins) || numBins < 2 || numBins > 20) {
        showNotification('Please enter a valid number of bins between 2 and 20', 'danger');
        binCount.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Binning operations require all array elements to be numbers', 'danger');
        return;
    }
    
    if (isBinningRunning) {
        showNotification('A binning operation is already in progress', 'warning');
        return;
    }
    
    isBinningRunning = true;
    
    // Store original array
    originalArrayForBinning = [...myArray];
    
    // Perform binning by number of bins
    performBinningByCount(numBins);
}

// NEW: Bin by Width Handler
function handleBinByWidth() {
    const width = parseFloat(binWidth.value);
    
    if (isNaN(width) || width <= 0) {
        showNotification('Please enter a valid bin width greater than 0', 'danger');
        binWidth.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Binning operations require all array elements to be numbers', 'danger');
        return;
    }
    
    if (isBinningRunning) {
        showNotification('A binning operation is already in progress', 'warning');
        return;
    }
    
    isBinningRunning = true;
    
    // Store original array
    originalArrayForBinning = [...myArray];
    
    // Perform binning by width
    performBinningByWidth(width);
}

// NEW: Perform Binning by Number of Bins
function performBinningByCount(numBins) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Data Binning - ${numBins} Equal Intervals</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalBinningArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Binning Process</div>
            <div class="transformed-array-container" id="transformedBinningArray"></div>
        </div>
        
        <div class="bin-visualization">
            <p class="mb-2"><strong>Binning Algorithm:</strong> Dividing data into ${numBins} equal intervals</p>
            <p class="mb-0" id="binningExplanation">Calculating bin ranges...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="binningStepsContainer">
            <h6 class="text-center">Binning Steps</h6>
            <div class="steps-container" id="binningSteps"></div>
        </div>
        
        <div class="bin-results mt-3" id="binResults" style="display: none;">
            <h6 class="text-center">Bin Distribution</h6>
            <div class="table-container">
                <table class="bin-table" id="binDistributionTable">
                    <thead>
                        <tr>
                            <th>Bin Range</th>
                            <th>Count</th>
                            <th>Elements</th>
                        </tr>
                    </thead>
                    <tbody id="binTableBody"></tbody>
                </table>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterBinning" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForBinning, 'originalBinningArray');
    renderArrayInContainer([...originalArrayForBinning], 'transformedBinningArray');
    
    executeBinningByCountAnimation(numBins);
}

// NEW: Execute Binning by Count Animation
function executeBinningByCountAnimation(numBins) {
    const originalContainer = document.getElementById('originalBinningArray');
    const transformedContainer = document.getElementById('transformedBinningArray');
    const explanation = document.getElementById('binningExplanation');
    const stepsContainer = document.getElementById('binningSteps');
    const binResults = document.getElementById('binResults');
    const binTableBody = document.getElementById('binTableBody');
    const continueButton = document.getElementById('continueAfterBinning');
    
    const arr = originalArrayForBinning.map(val => parseFloat(val));
    const minVal = Math.min(...arr);
    const maxVal = Math.max(...arr);
    const range = maxVal - minVal;
    const binSize = range / numBins;
    
    // Initialize bins
    const bins = Array.from({ length: numBins }, () => ({ count: 0, elements: [] }));
    let currentStep = 0;
    
    function executeBinningStep() {
        if (currentStep === 0) {
            // Step 1: Calculate statistics
            explanation.innerHTML = `Step 1: Calculating data range and bin size`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Data range: ${minVal} to ${maxVal} (Range: ${range.toFixed(2)})
                </div>
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Bin size: ${range.toFixed(2)} / ${numBins} = ${binSize.toFixed(2)}
                </div>
            `;
            
            // Highlight min and max values
            const originalElements = originalContainer.querySelectorAll('.array-element');
            const minIndex = arr.indexOf(minVal);
            const maxIndex = arr.indexOf(maxVal);
            
            if (minIndex !== -1) {
                originalElements[minIndex].querySelector('.element-value').classList.add('bin-boundary');
            }
            if (maxIndex !== -1 && maxIndex !== minIndex) {
                originalElements[maxIndex].querySelector('.element-value').classList.add('bin-boundary');
            }
            
            currentStep++;
            setTimeout(executeBinningStep, 2000);
            
        } else if (currentStep === 1) {
            // Step 2: Create bin ranges
            explanation.innerHTML = `Step 2: Creating ${numBins} bin intervals`;
            
            let binRangesHTML = '';
            for (let i = 0; i < numBins; i++) {
                const binStart = minVal + i * binSize;
                const binEnd = minVal + (i + 1) * binSize;
                binRangesHTML += `
                    <div class="algorithm-step">
                        <strong>Bin ${i + 1}:</strong> [${binStart.toFixed(2)}, ${binEnd.toFixed(2)})
                    </div>
                `;
            }
            
            stepsContainer.innerHTML += binRangesHTML;
            currentStep++;
            setTimeout(executeBinningStep, 2000);
            
        } else if (currentStep === 2) {
            // Step 3: Assign elements to bins
            explanation.innerHTML = `Step 3: Assigning elements to bins`;
            
            let elementIndex = 0;
            
            function assignNextElement() {
                if (elementIndex >= arr.length) {
                    // All elements assigned
                    currentStep++;
                    executeBinningStep();
                    return;
                }
                
                const value = arr[elementIndex];
                const binIndex = Math.min(Math.floor((value - minVal) / binSize), numBins - 1);
                
                explanation.innerHTML = `Step 3: Assigning element [${elementIndex}] = ${value} to Bin ${binIndex + 1}`;
                
                // Highlight current element
                const transformedElements = transformedContainer.querySelectorAll('.array-element');
                const currentElement = transformedElements[elementIndex].querySelector('.element-value');
                currentElement.classList.add('bin-interval-highlight');
                
                // Update bin
                bins[binIndex].count++;
                bins[binIndex].elements.push(value);
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Element [${elementIndex}] = ${value}  Bin ${binIndex + 1} [${(minVal + binIndex * binSize).toFixed(2)}, ${(minVal + (binIndex + 1) * binSize).toFixed(2)})
                    </div>
                `;
                
                setTimeout(() => {
                    currentElement.classList.remove('bin-interval-highlight');
                    elementIndex++;
                    assignNextElement();
                }, 1000);
            }
            
            assignNextElement();
            
        } else if (currentStep === 3) {
            // Step 4: Display results
            explanation.innerHTML = `Step 4: Binning completed! Displaying distribution`;
            
            // Show results table
            binResults.style.display = 'block';
            
            // Populate table
            let tableHTML = '';
            let maxCount = 0;
            
            for (let i = 0; i < numBins; i++) {
                const binStart = minVal + i * binSize;
                const binEnd = minVal + (i + 1) * binSize;
                const count = bins[i].count;
                
                if (count > maxCount) maxCount = count;
                
                tableHTML += `
                    <tr>
                        <td>[${binStart.toFixed(2)}, ${binEnd.toFixed(2)})</td>
                        <td>${count}</td>
                        <td>${bins[i].elements.join(', ')}</td>
                    </tr>
                `;
            }
            
            binTableBody.innerHTML = tableHTML;
            
            // Highlight bins with maximum count
            setTimeout(() => {
                const tableRows = binTableBody.querySelectorAll('tr');
                tableRows.forEach((row, index) => {
                    if (bins[index].count === maxCount && maxCount > 0) {
                        row.classList.add('bin-interval-high-count');
                    }
                });
            }, 500);
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 4:</strong> Binning completed! Created ${numBins} intervals with ${arr.length} total elements
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterBinning();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterBinning);
        }
    }
    
    // Start binning process
    executeBinningStep();
}

// NEW: Perform Binning by Width
function performBinningByWidth(width) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Data Binning - Bin Width ${width}</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalBinningArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Binning Process</div>
            <div class="transformed-array-container" id="transformedBinningArray"></div>
        </div>
        
        <div class="bin-visualization">
            <p class="mb-2"><strong>Binning Algorithm:</strong> Grouping data into intervals of width ${width}</p>
            <p class="mb-0" id="binningExplanation">Calculating bin ranges...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="binningStepsContainer">
            <h6 class="text-center">Binning Steps</h6>
            <div class="steps-container" id="binningSteps"></div>
        </div>
        
        <div class="bin-results mt-3" id="binResults" style="display: none;">
            <h6 class="text-center">Bin Distribution</h6>
            <div class="table-container">
                <table class="bin-table" id="binDistributionTable">
                    <thead>
                        <tr>
                            <th>Bin Range</th>
                            <th>Count</th>
                            <th>Elements</th>
                        </tr>
                    </thead>
                    <tbody id="binTableBody"></tbody>
                </table>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterBinning" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForBinning, 'originalBinningArray');
    renderArrayInContainer([...originalArrayForBinning], 'transformedBinningArray');
    
    executeBinningByWidthAnimation(width);
}

// NEW: Execute Binning by Width Animation
function executeBinningByWidthAnimation(width) {
    const originalContainer = document.getElementById('originalBinningArray');
    const transformedContainer = document.getElementById('transformedBinningArray');
    const explanation = document.getElementById('binningExplanation');
    const stepsContainer = document.getElementById('binningSteps');
    const binResults = document.getElementById('binResults');
    const binTableBody = document.getElementById('binTableBody');
    const continueButton = document.getElementById('continueAfterBinning');
    
    const arr = originalArrayForBinning.map(val => parseFloat(val));
    const minVal = Math.min(...arr);
    const maxVal = Math.max(...arr);
    
    // Calculate number of bins based on width
    const numBins = Math.ceil((maxVal - minVal) / width);
    const actualMax = minVal + numBins * width;
    
    // Initialize bins
    const bins = Array.from({ length: numBins }, () => ({ count: 0, elements: [] }));
    let currentStep = 0;
    
    function executeBinningStep() {
        if (currentStep === 0) {
            // Step 1: Calculate statistics
            explanation.innerHTML = `Step 1: Calculating data range and bin configuration`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Data range: ${minVal} to ${maxVal}
                </div>
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Bin width: ${width}  ${numBins} bins needed
                </div>
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Actual range: ${minVal} to ${actualMax.toFixed(2)}
                </div>
            `;
            
            // Highlight min and max values
            const originalElements = originalContainer.querySelectorAll('.array-element');
            const minIndex = arr.indexOf(minVal);
            const maxIndex = arr.indexOf(maxVal);
            
            if (minIndex !== -1) {
                originalElements[minIndex].querySelector('.element-value').classList.add('bin-boundary');
            }
            if (maxIndex !== -1 && maxIndex !== minIndex) {
                originalElements[maxIndex].querySelector('.element-value').classList.add('bin-boundary');
            }
            
            currentStep++;
            setTimeout(executeBinningStep, 2000);
            
        } else if (currentStep === 1) {
            // Step 2: Create bin ranges
            explanation.innerHTML = `Step 2: Creating ${numBins} bin intervals of width ${width}`;
            
            let binRangesHTML = '';
            for (let i = 0; i < numBins; i++) {
                const binStart = minVal + i * width;
                const binEnd = minVal + (i + 1) * width;
                binRangesHTML += `
                    <div class="algorithm-step">
                        <strong>Bin ${i + 1}:</strong> [${binStart.toFixed(2)}, ${binEnd.toFixed(2)})
                    </div>
                `;
            }
            
            stepsContainer.innerHTML += binRangesHTML;
            currentStep++;
            setTimeout(executeBinningStep, 2000);
            
        } else if (currentStep === 2) {
            // Step 3: Assign elements to bins
            explanation.innerHTML = `Step 3: Assigning elements to bins`;
            
            let elementIndex = 0;
            
            function assignNextElement() {
                if (elementIndex >= arr.length) {
                    // All elements assigned
                    currentStep++;
                    executeBinningStep();
                    return;
                }
                
                const value = arr[elementIndex];
                const binIndex = Math.min(Math.floor((value - minVal) / width), numBins - 1);
                
                explanation.innerHTML = `Step 3: Assigning element [${elementIndex}] = ${value} to Bin ${binIndex + 1}`;
                
                // Highlight current element
                const transformedElements = transformedContainer.querySelectorAll('.array-element');
                const currentElement = transformedElements[elementIndex].querySelector('.element-value');
                currentElement.classList.add('bin-interval-highlight');
                
                // Update bin
                bins[binIndex].count++;
                bins[binIndex].elements.push(value);
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Element [${elementIndex}] = ${value}  Bin ${binIndex + 1} [${(minVal + binIndex * width).toFixed(2)}, ${(minVal + (binIndex + 1) * width).toFixed(2)})
                    </div>
                `;
                
                setTimeout(() => {
                    currentElement.classList.remove('bin-interval-highlight');
                    elementIndex++;
                    assignNextElement();
                }, 1000);
            }
            
            assignNextElement();
            
        } else if (currentStep === 3) {
            // Step 4: Display results
            explanation.innerHTML = `Step 4: Binning completed! Displaying distribution`;
            
            // Show results table
            binResults.style.display = 'block';
            
            // Populate table
            let tableHTML = '';
            let maxCount = 0;
            
            for (let i = 0; i < numBins; i++) {
                const binStart = minVal + i * width;
                const binEnd = minVal + (i + 1) * width;
                const count = bins[i].count;
                
                if (count > maxCount) maxCount = count;
                
                tableHTML += `
                    <tr>
                        <td>[${binStart.toFixed(2)}, ${binEnd.toFixed(2)})</td>
                        <td>${count}</td>
                        <td>${bins[i].elements.join(', ')}</td>
                    </tr>
                `;
            }
            
            binTableBody.innerHTML = tableHTML;
            
            // Highlight bins with maximum count
            setTimeout(() => {
                const tableRows = binTableBody.querySelectorAll('tr');
                tableRows.forEach((row, index) => {
                    if (bins[index].count === maxCount && maxCount > 0) {
                        row.classList.add('bin-interval-high-count');
                    }
                });
            }, 500);
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 4:</strong> Binning completed! Created ${numBins} intervals with ${arr.length} total elements
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterBinning();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterBinning);
        }
    }
    
    // Start binning process
    executeBinningStep();
}

// NEW: Return to Original after Binning
function returnToOriginalAfterBinning() {
    // Reset to original array
    myArray = [...originalArrayForBinning];
    originalArrayForBinning = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isBinningRunning = false;
    
    // Clear inputs
    binCount.value = '';
    binWidth.value = '';
    
    logOperation('Binning operation completed - returned to original array', 'info');
    showNotification('Returned to original array after binning operation', 'success');
}
// NEW: Handle UFunc Selection
function handleUfuncSelection() {
    const selectedFunc = ufuncSelect.value;
    
    // Show/hide additional parameters based on selection
    ufuncParams.style.display = 'none';
    clampLow.style.display = 'none';
    clampHigh.style.display = 'none';
    euclidRef.style.display = 'none';
    bitwiseOperand.style.display = 'none';
    leakyReluAlpha.style.display = 'none';
    
    if (selectedFunc === 'clamp') {
        ufuncParams.style.display = 'block';
        clampLow.style.display = 'block';
        clampHigh.style.display = 'block';
    } else if (selectedFunc === 'euclid_1d') {
        ufuncParams.style.display = 'block';
        euclidRef.style.display = 'block';
    } else if (selectedFunc === 'bit_and' || selectedFunc === 'bit_or' || selectedFunc === 'bit_xor') {
        ufuncParams.style.display = 'block';
        bitwiseOperand.style.display = 'block';
    } else if (selectedFunc === 'leaky_relu') {
        ufuncParams.style.display = 'block';
        leakyReluAlpha.style.display = 'block';
    }
}

// NEW: Apply Universal Function Handler
function handleApplyUfunc() {
    const selectedFunc = ufuncSelect.value;
    
    if (!selectedFunc) {
        showNotification('Please select a universal function', 'warning');
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers for numeric functions
    const numericFunctions = ['c2f', 'f2c', 'square', 'cube', 'reciprocal', 'relu', 'sigmoid', 'clamp', 
                             'zscore_elem', 'percentile_rank', 'euclid_1d', 'inc', 'dec', 'double', 'half', 
                             'neg', 'is_positive', 'is_negative', 'is_zero', 'sqroot', 'cbrt', 'sin_deg', 
                             'cos_deg', 'tan_deg', 'bit_flip', 'bit_and', 'bit_or', 'bit_xor', 'asin_deg',
                             'acos_deg', 'atan_deg', 'factorial_approx', 'leaky_relu', 'bin_0_100'];
    
    if (numericFunctions.includes(selectedFunc)) {
        let allNumbers = true;
        for (let i = 0; i < myArray.length; i++) {
            if (isNaN(parseFloat(myArray[i]))) {
                allNumbers = false;
                break;
            }
        }
        
        if (!allNumbers) {
            showNotification('This function requires all array elements to be numbers', 'danger');
            return;
        }
    }
    
    if (isUfuncRunning) {
        showNotification('A universal function operation is already in progress', 'warning');
        return;
    }
    
    isUfuncRunning = true;
    
    // Store original array
    originalArrayForUfunc = [...myArray];
    
    // Get additional parameters if needed
    let additionalParams = {};
    if (selectedFunc === 'clamp') {
        const low = parseFloat(clampLow.value);
        const high = parseFloat(clampHigh.value);
        
        if (isNaN(low) || isNaN(high) || low >= high) {
            showNotification('Please enter valid lower and upper bounds (lower < upper)', 'danger');
            isUfuncRunning = false;
            return;
        }
        
        additionalParams = { low, high };
    } else if (selectedFunc === 'euclid_1d') {
        const ref = parseFloat(euclidRef.value);
        
        if (isNaN(ref)) {
            showNotification('Please enter a valid reference point', 'danger');
            isUfuncRunning = false;
            return;
        }
        
        additionalParams = { ref };
    } else if (selectedFunc === 'bit_and' || selectedFunc === 'bit_or' || selectedFunc === 'bit_xor') {
        const operand = parseInt(bitwiseOperand.value);
        
        if (isNaN(operand)) {
            showNotification('Please enter a valid operand value', 'danger');
            isUfuncRunning = false;
            return;
        }
        
        additionalParams = { operand };
    } else if (selectedFunc === 'leaky_relu') {
        const alpha = parseFloat(leakyReluAlpha.value);
        
        if (isNaN(alpha)) {
            showNotification('Please enter a valid alpha value', 'danger');
            isUfuncRunning = false;
            return;
        }
        
        additionalParams = { alpha };
    }
    
    // Show UFunc visualization
    showUfuncVisualization(selectedFunc, additionalParams);
}

// NEW: Get Display Name for UFunc
function getUfuncDisplayName(funcName) {
    const names = {
        'c2f': 'CF',
        'f2c': 'FC',
        'square': 'Squaring',
        'cube': 'Cubing',
        'reciprocal': 'Reciprocal',
        'relu': 'ReLU',
        'sigmoid': 'Sigmoid',
        'is_even': 'Is Even Check',
        'is_odd': 'Is Odd Check',
        'clamp': 'Clamping',
        'zscore_elem': 'Z-Score',
        'percentile_rank': 'Percentile Rank',
        'to_grade': 'Grade Conversion',
        'euclid_1d': 'Euclidean Distance',
        'inc': 'Increment',
        'dec': 'Decrement',
        'double': 'Double',
        'half': 'Half',
        'neg': 'Negate',
        'is_positive': 'Is Positive',
        'is_negative': 'Is Negative',
        'is_zero': 'Is Zero',
        'sqroot': 'Square Root',
        'cbrt': 'Cube Root',
        'sin_deg': 'Sine',
        'cos_deg': 'Cosine',
        'tan_deg': 'Tangent',
        'bit_flip': 'Bit Flip',
        'bit_and': 'Bitwise AND',
        'bit_or': 'Bitwise OR',
        'bit_xor': 'Bitwise XOR',
        'asin_deg': 'Arcsine',
        'acos_deg': 'Arccosine',
        'atan_deg': 'Arctangent',
        'factorial_approx': 'Factorial',
        'leaky_relu': 'Leaky ReLU',
        'bin_0_100': 'Bin to 0-100'
    };
    return names[funcName] || funcName;
}

// NEW: Show UFunc Visualization
function showUfuncVisualization(funcName, params = {}) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    
    let title = '';
    let description = '';
    
    // Set title and description based on function
    switch(funcName) {
        case 'c2f':
            title = 'Celsius to Fahrenheit Conversion';
            description = 'Convert temperature values from Celsius to Fahrenheit using: F = (C  9/5) + 32';
            break;
        case 'f2c':
            title = 'Fahrenheit to Celsius Conversion';
            description = 'Convert temperature values from Fahrenheit to Celsius using: C = (F - 32)  5/9';
            break;
        case 'square':
            title = 'Square Function';
            description = 'Calculate the square of each element: x = x  x';
            break;
        case 'cube':
            title = 'Cube Function';
            description = 'Calculate the cube of each element: x = x  x  x';
            break;
        case 'reciprocal':
            title = 'Reciprocal Function';
            description = 'Calculate the reciprocal of each element: 1/x';
            break;
        case 'relu':
            title = 'ReLU Activation Function';
            description = 'Rectified Linear Unit: returns x if x > 0, otherwise returns 0';
            break;
        case 'sigmoid':
            title = 'Sigmoid Activation Function';
            description = 'Sigmoid function: 1 / (1 + e^(-x)) - maps values to range (0, 1)';
            break;
        case 'is_even':
            title = 'Is Even Function';
            description = 'Check if each element is even: returns 1 if even, 0 if odd';
            break;
        case 'is_odd':
            title = 'Is Odd Function';
            description = 'Check if each element is odd: returns 1 if odd, 0 if even';
            break;
        case 'clamp':
            title = `Clamp Function (${params.low} to ${params.high})`;
            description = `Constrain values to range [${params.low}, ${params.high}]: returns lower bound if x < lower, upper bound if x > upper, otherwise x`;
            break;
        // NEW FUNCTIONS
        case 'zscore_elem':
            title = 'Z-Score Normalization';
            description = 'Standardize values using Z-score: (x - mean) / standard deviation';
            break;
        case 'percentile_rank':
            title = 'Percentile Rank';
            description = 'Calculate percentile rank for each value: (number of values below x / total values)  100';
            break;
        case 'to_grade':
            title = 'Grade Conversion';
            description = 'Convert numerical scores to letter grades: A (90-100), B (80-89), C (70-79), D (60-69), F (0-59)';
            break;
        case 'euclid_1d':
            title = `Euclidean Distance (from ${params.ref})`;
            description = `Calculate 1D Euclidean distance from reference point: |x - ${params.ref}|`;
            break;
        case 'inc':
            title = 'Increment';
            description = 'Increase each element by 1: x + 1';
            break;
        case 'dec':
            title = 'Decrement';
            description = 'Decrease each element by 1: x - 1';
            break;
        case 'double':
            title = 'Double';
            description = 'Multiply each element by 2: x  2';
            break;
        case 'half':
            title = 'Half';
            description = 'Divide each element by 2: x  2';
            break;
        case 'neg':
            title = 'Negate';
            description = 'Change sign of each element: -x';
            break;
        case 'is_positive':
            title = 'Is Positive Check';
            description = 'Check if element is positive: returns 1 if x > 0, 0 otherwise';
            break;
        case 'is_negative':
            title = 'Is Negative Check';
            description = 'Check if element is negative: returns 1 if x < 0, 0 otherwise';
            break;
        case 'is_zero':
            title = 'Is Zero Check';
            description = 'Check if element is zero: returns 1 if x = 0, 0 otherwise';
            break;
        case 'sqroot':
            title = 'Square Root';
            description = 'Calculate square root of each element: x';
            break;
        case 'cbrt':
            title = 'Cube Root';
            description = 'Calculate cube root of each element: x';
            break;
        case 'sin_deg':
            title = 'Sine (Degrees)';
            description = 'Calculate sine of each element (in degrees): sin(x)';
            break;
        case 'cos_deg':
            title = 'Cosine (Degrees)';
            description = 'Calculate cosine of each element (in degrees): cos(x)';
            break;
        case 'tan_deg':
            title = 'Tangent (Degrees)';
            description = 'Calculate tangent of each element (in degrees): tan(x)';
            break;
        // NEWLY ADDED FUNCTIONS
        case 'bit_flip':
            title = 'Bit Flip';
            description = 'Flip all bits of each element (bitwise NOT operation): ~x';
            break;
        case 'bit_and':
            title = `Bitwise AND (with ${params.operand})`;
            description = `Perform bitwise AND operation with ${params.operand}: x & ${params.operand}`;
            break;
        case 'bit_or':
            title = `Bitwise OR (with ${params.operand})`;
            description = `Perform bitwise OR operation with ${params.operand}: x | ${params.operand}`;
            break;
        case 'bit_xor':
            title = `Bitwise XOR (with ${params.operand})`;
            description = `Perform bitwise XOR operation with ${params.operand}: x ^ ${params.operand}`;
            break;
        case 'asin_deg':
            title = 'Arcsine (Degrees)';
            description = 'Calculate arcsine of each element (result in degrees): asin(x)  180/';
            break;
        case 'acos_deg':
            title = 'Arccosine (Degrees)';
            description = 'Calculate arccosine of each element (result in degrees): acos(x)  180/';
            break;
        case 'atan_deg':
            title = 'Arctangent (Degrees)';
            description = 'Calculate arctangent of each element (result in degrees): atan(x)  180/';
            break;
        case 'factorial_approx':
            title = 'Factorial (Approximation)';
            description = 'Calculate approximate factorial using Stirling\'s approximation: (2x)  (x/e)^x';
            break;
        case 'leaky_relu':
            title = `Leaky ReLU (alpha=${params.alpha})`;
            description = `Leaky Rectified Linear Unit: returns x if x > 0, otherwise returns ${params.alpha}  x`;
            break;
        case 'bin_0_100':
            title = 'Bin to 0-100';
            description = 'Convert values to bins: 0-200, 21-401, 41-602, 61-803, 81-1004';
            break;
    }
    
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">${title}</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalUfuncArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After ${getUfuncDisplayName(funcName)}</div>
            <div class="transformed-array-container" id="transformedUfuncArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Universal Function:</strong> ${description}</p>
            <p class="mb-0" id="ufuncExplanation">Starting universal function application...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="ufuncStepsContainer">
            <h6 class="text-center">Function Application Steps</h6>
            <div class="steps-container" id="ufuncSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterUfunc" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForUfunc, 'originalUfuncArray');
    renderArrayInContainer([...originalArrayForUfunc], 'transformedUfuncArray');
    
    performUfuncAnimation(funcName, params);
}

// NEW: Calculate array statistics for z-score and percentile
function calculateArrayStats(arr) {
    const mean = arr.reduce((sum, val) => sum + val, 0) / arr.length;
    const variance = arr.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / arr.length;
    const stdDev = Math.sqrt(variance);
    return { mean, stdDev };
}

// NEW: Convert number to grade
function numberToGrade(score) {
    if (score >= 90) return 'A';
    if (score >= 80) return 'B';
    if (score >= 70) return 'C';
    if (score >= 60) return 'D';
    return 'F';
}

// NEW: Convert number to bin (0-100)
function numberToBin(value) {
    if (value <= 20) return 0;
    if (value <= 40) return 1;
    if (value <= 60) return 2;
    if (value <= 80) return 3;
    return 4;
}

// NEW: Stirling's approximation for factorial
function stirlingFactorial(n) {
    if (n <= 1) return 1;
    return Math.sqrt(2 * Math.PI * n) * Math.pow(n / Math.E, n);
}

// NEW: Perform UFunc Animation
function performUfuncAnimation(funcName, params = {}) {
    const originalContainer = document.getElementById('originalUfuncArray');
    const transformedContainer = document.getElementById('transformedUfuncArray');
    const explanation = document.getElementById('ufuncExplanation');
    const stepsContainer = document.getElementById('ufuncSteps');
    const continueButton = document.getElementById('continueAfterUfunc');
    
    const originalArray = originalArrayForUfunc.map(val => {
        const numericFunctions = ['c2f', 'f2c', 'square', 'cube', 'reciprocal', 'relu', 'sigmoid', 'clamp', 
                                 'zscore_elem', 'percentile_rank', 'euclid_1d', 'inc', 'dec', 'double', 'half', 
                                 'neg', 'is_positive', 'is_negative', 'is_zero', 'sqroot', 'cbrt', 'sin_deg', 
                                 'cos_deg', 'tan_deg', 'bit_flip', 'bit_and', 'bit_or', 'bit_xor', 'asin_deg',
                                 'acos_deg', 'atan_deg', 'factorial_approx', 'leaky_relu', 'bin_0_100'];
        if (numericFunctions.includes(funcName)) {
            return parseFloat(val);
        }
        return val;
    });
    
    let transformedArray = [...originalArray];
    let currentIndex = 0;
    
    // Pre-calculate statistics for functions that need them
    let arrayStats = null;
    if (funcName === 'zscore_elem' || funcName === 'percentile_rank') {
        arrayStats = calculateArrayStats(originalArray);
    }
    
    // Helper function to format numbers with up to 3 decimals
    function formatNumber(num) {
        if (typeof num !== 'number') return num;
        // Check if it's an integer
        if (num % 1 === 0) return num.toString();
        // Format with up to 3 decimal places
        return parseFloat(num.toFixed(3)).toString();
    }
    
    function performUfuncStep() {
        if (currentIndex >= originalArray.length) {
            // Operation completed
            explanation.innerHTML = `<strong>Universal Function Application Completed!</strong> Applied ${getUfuncDisplayName(funcName)} to all elements.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Successfully applied ${getUfuncDisplayName(funcName)} to all ${originalArray.length} elements
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterUfunc();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterUfunc);
            
            return;
        }
        
        const originalValue = originalArray[currentIndex];
        let transformedValue;
        let stepDescription = '';
        
        // Apply the selected function
        switch(funcName) {
            case 'c2f':
                transformedValue = (originalValue * 1.8) + 32;
                stepDescription = `[${currentIndex}]: ${formatNumber(originalValue)}C  (${formatNumber(originalValue)}  1.8) + 32 = ${formatNumber(transformedValue)}F`;
                break;
            case 'f2c':
                transformedValue = (originalValue - 32) * 5/9;
                stepDescription = `[${currentIndex}]: ${formatNumber(originalValue)}F  (${formatNumber(originalValue)} - 32)  5/9 = ${formatNumber(transformedValue)}C`;
                break;
            case 'square':
                transformedValue = originalValue * originalValue;
                stepDescription = `[${currentIndex}]: ${formatNumber(originalValue)} = ${formatNumber(originalValue)}  ${formatNumber(originalValue)} = ${formatNumber(transformedValue)}`;
                break;
            case 'cube':
                transformedValue = originalValue * originalValue * originalValue;
                stepDescription = `[${currentIndex}]: ${formatNumber(originalValue)} = ${formatNumber(originalValue)}  ${formatNumber(originalValue)}  ${formatNumber(originalValue)} = ${formatNumber(transformedValue)}`;
                break;
            case 'reciprocal':
                transformedValue = 1 / originalValue;
                stepDescription = `[${currentIndex}]: 1/${formatNumber(originalValue)} = ${formatNumber(transformedValue)}`;
                break;
            case 'relu':
                transformedValue = Math.max(0, originalValue);
                stepDescription = `[${currentIndex}]: ReLU(${formatNumber(originalValue)}) = max(0, ${formatNumber(originalValue)}) = ${formatNumber(transformedValue)}`;
                break;
            case 'sigmoid':
                transformedValue = 1 / (1 + Math.exp(-originalValue));
                stepDescription = `[${currentIndex}]: sigmoid(${formatNumber(originalValue)}) = 1 / (1 + e^(-${formatNumber(originalValue)})) = ${formatNumber(transformedValue)}`;
                break;
            case 'is_even':
                transformedValue = (parseInt(originalValue) % 2 === 0) ? 1 : 0;
                stepDescription = `[${currentIndex}]: is_even(${formatNumber(originalValue)}) = (${formatNumber(originalValue)} % 2 == 0) = ${transformedValue}`;
                break;
            case 'is_odd':
                transformedValue = (parseInt(originalValue) % 2 !== 0) ? 1 : 0;
                stepDescription = `[${currentIndex}]: is_odd(${formatNumber(originalValue)}) = (${formatNumber(originalValue)} % 2 != 0) = ${transformedValue}`;
                break;
            case 'clamp':
                transformedValue = Math.max(params.low, Math.min(params.high, originalValue));
                let clampAction = 'unchanged';
                if (originalValue < params.low) clampAction = `clamped to lower bound ${formatNumber(params.low)}`;
                else if (originalValue > params.high) clampAction = `clamped to upper bound ${formatNumber(params.high)}`;
                stepDescription = `[${currentIndex}]: clamp(${formatNumber(originalValue)}, ${formatNumber(params.low)}, ${formatNumber(params.high)}) = ${formatNumber(transformedValue)} (${clampAction})`;
                break;
            // NEW FUNCTIONS
            case 'zscore_elem':
                transformedValue = (originalValue - arrayStats.mean) / arrayStats.stdDev;
                stepDescription = `[${currentIndex}]: zscore(${formatNumber(originalValue)}) = (${formatNumber(originalValue)} - ${formatNumber(arrayStats.mean)}) / ${formatNumber(arrayStats.stdDev)} = ${formatNumber(transformedValue)}`;
                break;
            case 'percentile_rank':
                const valuesBelow = originalArray.filter(val => val < originalValue).length;
                transformedValue = (valuesBelow / originalArray.length) * 100;
                stepDescription = `[${currentIndex}]: percentile(${formatNumber(originalValue)}) = (${valuesBelow} values below / ${originalArray.length} total)  100 = ${formatNumber(transformedValue)}%`;
                break;
            case 'to_grade':
                transformedValue = numberToGrade(originalValue);
                stepDescription = `[${currentIndex}]: grade(${formatNumber(originalValue)}) = ${transformedValue}`;
                break;
            case 'euclid_1d':
                transformedValue = Math.abs(originalValue - params.ref);
                stepDescription = `[${currentIndex}]: euclid(${formatNumber(originalValue)}, ${formatNumber(params.ref)}) = |${formatNumber(originalValue)} - ${formatNumber(params.ref)}| = ${formatNumber(transformedValue)}`;
                break;
            case 'inc':
                transformedValue = originalValue + 1;
                stepDescription = `[${currentIndex}]: inc(${formatNumber(originalValue)}) = ${formatNumber(originalValue)} + 1 = ${formatNumber(transformedValue)}`;
                break;
            case 'dec':
                transformedValue = originalValue - 1;
                stepDescription = `[${currentIndex}]: dec(${formatNumber(originalValue)}) = ${formatNumber(originalValue)} - 1 = ${formatNumber(transformedValue)}`;
                break;
            case 'double':
                transformedValue = originalValue * 2;
                stepDescription = `[${currentIndex}]: double(${formatNumber(originalValue)}) = ${formatNumber(originalValue)}  2 = ${formatNumber(transformedValue)}`;
                break;
            case 'half':
                transformedValue = originalValue / 2;
                stepDescription = `[${currentIndex}]: half(${formatNumber(originalValue)}) = ${formatNumber(originalValue)}  2 = ${formatNumber(transformedValue)}`;
                break;
            case 'neg':
                transformedValue = -originalValue;
                stepDescription = `[${currentIndex}]: neg(${formatNumber(originalValue)}) = -${formatNumber(originalValue)} = ${formatNumber(transformedValue)}`;
                break;
            case 'is_positive':
                transformedValue = originalValue > 0 ? 1 : 0;
                stepDescription = `[${currentIndex}]: is_positive(${formatNumber(originalValue)}) = (${formatNumber(originalValue)} > 0) = ${transformedValue}`;
                break;
            case 'is_negative':
                transformedValue = originalValue < 0 ? 1 : 0;
                stepDescription = `[${currentIndex}]: is_negative(${formatNumber(originalValue)}) = (${formatNumber(originalValue)} < 0) = ${transformedValue}`;
                break;
            case 'is_zero':
                transformedValue = originalValue === 0 ? 1 : 0;
                stepDescription = `[${currentIndex}]: is_zero(${formatNumber(originalValue)}) = (${formatNumber(originalValue)} == 0) = ${transformedValue}`;
                break;
            case 'sqroot':
                transformedValue = Math.sqrt(originalValue);
                stepDescription = `[${currentIndex}]: sqrt(${formatNumber(originalValue)}) = ${formatNumber(transformedValue)}`;
                break;
            case 'cbrt':
                transformedValue = Math.cbrt(originalValue);
                stepDescription = `[${currentIndex}]: cbrt(${formatNumber(originalValue)}) = ${formatNumber(transformedValue)}`;
                break;
            case 'sin_deg':
                transformedValue = Math.sin(originalValue * Math.PI / 180);
                stepDescription = `[${currentIndex}]: sin(${formatNumber(originalValue)}) = ${formatNumber(transformedValue)}`;
                break;
            case 'cos_deg':
                transformedValue = Math.cos(originalValue * Math.PI / 180);
                stepDescription = `[${currentIndex}]: cos(${formatNumber(originalValue)}) = ${formatNumber(transformedValue)}`;
                break;
            case 'tan_deg':
                transformedValue = Math.tan(originalValue * Math.PI / 180);
                stepDescription = `[${currentIndex}]: tan(${formatNumber(originalValue)}) = ${formatNumber(transformedValue)}`;
                break;
            // NEWLY ADDED FUNCTIONS
            case 'bit_flip':
                transformedValue = ~parseInt(originalValue);
                stepDescription = `[${currentIndex}]: bit_flip(${formatNumber(originalValue)}) = ~${formatNumber(originalValue)} = ${transformedValue}`;
                break;
            case 'bit_and':
                transformedValue = parseInt(originalValue) & params.operand;
                stepDescription = `[${currentIndex}]: bit_and(${formatNumber(originalValue)}, ${params.operand}) = ${formatNumber(originalValue)} & ${params.operand} = ${transformedValue}`;
                break;
            case 'bit_or':
                transformedValue = parseInt(originalValue) | params.operand;
                stepDescription = `[${currentIndex}]: bit_or(${formatNumber(originalValue)}, ${params.operand}) = ${formatNumber(originalValue)} | ${params.operand} = ${transformedValue}`;
                break;
            case 'bit_xor':
                transformedValue = parseInt(originalValue) ^ params.operand;
                stepDescription = `[${currentIndex}]: bit_xor(${formatNumber(originalValue)}, ${params.operand}) = ${formatNumber(originalValue)} ^ ${params.operand} = ${transformedValue}`;
                break;
            case 'asin_deg':
                transformedValue = Math.asin(originalValue) * 180 / Math.PI;
                stepDescription = `[${currentIndex}]: asin(${formatNumber(originalValue)}) = ${formatNumber(transformedValue)}`;
                break;
            case 'acos_deg':
                transformedValue = Math.acos(originalValue) * 180 / Math.PI;
                stepDescription = `[${currentIndex}]: acos(${formatNumber(originalValue)}) = ${formatNumber(transformedValue)}`;
                break;
            case 'atan_deg':
                transformedValue = Math.atan(originalValue) * 180 / Math.PI;
                stepDescription = `[${currentIndex}]: atan(${formatNumber(originalValue)}) = ${formatNumber(transformedValue)}`;
                break;
            case 'factorial_approx':
                transformedValue = stirlingFactorial(originalValue);
                stepDescription = `[${currentIndex}]: factorial_approx(${formatNumber(originalValue)}) = (2${formatNumber(originalValue)})  (${formatNumber(originalValue)}/e)^${formatNumber(originalValue)} = ${formatNumber(transformedValue)}`;
                break;
            case 'leaky_relu':
                transformedValue = originalValue > 0 ? originalValue : params.alpha * originalValue;
                stepDescription = `[${currentIndex}]: leaky_relu(${formatNumber(originalValue)}, ${params.alpha}) = ${originalValue > 0 ? formatNumber(originalValue) : `${formatNumber(params.alpha)}  ${formatNumber(originalValue)}`} = ${formatNumber(transformedValue)}`;
                break;
            case 'bin_0_100':
                transformedValue = numberToBin(originalValue);
                stepDescription = `[${currentIndex}]: bin_0_100(${formatNumber(originalValue)}) = ${transformedValue}`;
                break;
        }
        
        transformedArray[currentIndex] = transformedValue;
        
        // Update explanation
        explanation.innerHTML = `Applying ${getUfuncDisplayName(funcName)} to element at index ${currentIndex}`;
        
        // Highlight current element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        
        const originalElement = originalElements[currentIndex].querySelector('.element-value');
        const transformedElement = transformedElements[currentIndex].querySelector('.element-value');
        
        originalElement.classList.add('traverse-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex + 1}:</strong> ${stepDescription}
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Update transformed array display with formatted values
            const formattedTransformedArray = transformedArray.map(val => {
                if (typeof val === 'number' && funcName !== 'to_grade') {
                    return formatNumber(val);
                }
                return val;
            });
            renderArrayInContainer(formattedTransformedArray, 'transformedUfuncArray');
            
            // Highlight the transformed element
            transformedElement.classList.add('create', 'bounce');
            
            // Remove current highlight and mark as completed
            originalElement.classList.remove('traverse-current');
            originalElement.classList.add('traverse-completed');
            
            currentIndex++;
            performUfuncStep();
        }, 1500);
    }
    
    // Start UFunc application process
    performUfuncStep();
}

// NEW: Return to Original after UFunc
function returnToOriginalAfterUfunc() {
    // Reset to original array
    myArray = [...originalArrayForUfunc];
    originalArrayForUfunc = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isUfuncRunning = false;
    
    // Clear selection and inputs
    ufuncSelect.value = '';
    ufuncParams.style.display = 'none';
    clampLow.value = '';
    clampHigh.value = '';
    euclidRef.value = '';
    bitwiseOperand.value = '';
    leakyReluAlpha.value = '';
    
    logOperation('Universal function application completed - returned to original array', 'info');
    showNotification('Returned to original array after universal function application', 'success');
}
// NEW: Load Stock Prices Handler
// Update your existing handleLoadStockPrices function
function handleLoadStockPrices() {
    const input = stockPricesInput.value.trim();
    
    if (input === '') {
        showNotification('Please enter stock prices', 'warning');
        stockPricesInput.focus();
        return;
    }
    
    // Parse input as numbers
    const prices = input.split(',').map(item => {
        const num = parseFloat(item.trim());
        if (isNaN(num)) {
            showNotification(`Invalid number: ${item}`, 'danger');
            return null;
        }
        return num;
    }).filter(item => item !== null);
    
    if (prices.length < 2) {
        showNotification('Please enter at least 2 stock prices', 'warning');
        return;
    }
    
    // Store original prices
    originalStockPrices = [...prices];
    
    // NEW: Generate open and close prices for gap analysis
    openPrices = prices.map(price => {
        // Simulate open price with some variation (2%)
        const variation = (Math.random() - 0.5) * 0.04;
        return price * (1 + variation);
    });
    
    closePrices = [...prices]; // Use input prices as close prices
    
    // Load into main array for visualization
    myArray = prices.map(price => price.toString());
    
    renderArray();
    updateStats();
    
    // Highlight all prices
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'stock-price');
        });
    }, 100);
    
    logOperation(`Loaded ${prices.length} stock prices with open/close data`, 'success');
    showNotification('Stock prices loaded successfully with open/close data', 'success');
}
// NEW: Handle Stock Market Operations
function handleStockOperation(operation) {
    if (originalStockPrices.length === 0) {
        showNotification('Please load stock prices first', 'warning');
        return;
    }
    
    if (isStockOperationRunning) {
        showNotification('A stock operation is already in progress', 'warning');
        return;
    }
    
    isStockOperationRunning = true;
    
    switch (operation) {
        case 'dailyReturns':
            performDailyReturnsCalculation();
            break;
        case 'logReturns':
            performLogReturnsCalculation();
            break;
        case 'cumulativeReturns':
            performCumulativeReturnsCalculation();
            break;
        case 'totalReturn':
            performTotalReturnCalculation();
            break;
        case 'priceDifference':
            performPriceDifferenceCalculation();
            break;
        case 'priceMomentum':
    performPriceMomentumCalculation();
    break;
case 'rateOfChange':
    performRateOfChangeCalculation();
    break;
case 'gapAnalysis':
    performGapAnalysisCalculation();
    break;
case 'intradayGain':
    performIntradayGainCalculation();
    break; 
case 'sma':
    performSMACalculation();
    break;
case 'ema':
    performEMACalculation();
    break;
case 'macd':
    performMACDCalculation();
    break;
case 'macdSignal':
    performMACDSignalCalculation();
    break;
case 'bollingerMiddle':
    performBollingerMiddleCalculation();
    break;
case 'bollingerUpper':
    performBollingerUpperCalculation();
    break;       
    }
}

// NEW: Perform Daily Returns Calculation with Animation
function performDailyReturnsCalculation() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Daily Returns Calculation</h5>
        
        <div class="array-group">
            <div class="array-label">Stock Prices</div>
            <div class="original-array-container" id="originalPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Daily Returns</div>
            <div class="transformed-array-container" id="returnsArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> returns[i] = (price[i] - price[i-1]) / price[i-1]</p>
            <p class="mb-0" id="returnsExplanation">Starting daily returns calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="returnsStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="returnsSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterReturns" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalStockPrices.map(p => p.toString()), 'originalPricesArray');
    renderArrayInContainer([], 'returnsArray');
    
    executeDailyReturnsAnimation();
}

// NEW: Execute Daily Returns Animation
function executeDailyReturnsAnimation() {
    const originalContainer = document.getElementById('originalPricesArray');
    const returnsContainer = document.getElementById('returnsArray');
    const explanation = document.getElementById('returnsExplanation');
    const stepsContainer = document.getElementById('returnsSteps');
    const continueButton = document.getElementById('continueAfterReturns');
    
    const prices = [...originalStockPrices];
    const dailyReturns = [];
    let step = 0;
    
    function executeReturnsStep(i) {
        if (i >= prices.length) {
            // Calculation completed
            explanation.innerHTML = `<strong>Daily Returns Calculation Completed!</strong>`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> All daily returns calculated successfully
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToStockPrices();
            }, 5000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            
            return;
        }
        
        if (i === 0) {
            // First element - no return calculation
            explanation.innerHTML = `Step ${step + 1}: First price - no daily return calculation`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step + 1}:</strong> First price (${prices[i]}) - no return calculation
                </div>
            `;
            
            dailyReturns.push('N/A');
            renderArrayInContainer(dailyReturns, 'returnsArray');
            
            step++;
            setTimeout(() => executeReturnsStep(i + 1), 1500);
            return;
        }
        
        // Calculate daily return
        const currentPrice = prices[i];
        const previousPrice = prices[i - 1];
        const dailyReturn = (currentPrice - previousPrice) / previousPrice;
        
        explanation.innerHTML = `Step ${step + 1}: Calculating return for day ${i}<br>
                                (${currentPrice} - ${previousPrice}) / ${previousPrice} = ${(dailyReturn * 100).toFixed(2)}%`;
        
        // Highlight the prices being used
        const originalElements = originalContainer.querySelectorAll('.array-element');
        originalElements[i - 1].querySelector('.element-value').classList.add('sorting-compared');
        originalElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step + 1}:</strong> Return[${i}] = (${currentPrice} - ${previousPrice}) / ${previousPrice} = ${(dailyReturn * 100).toFixed(2)}%
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            originalElements[i - 1].querySelector('.element-value').classList.remove('sorting-compared');
            originalElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            // Add the calculated return
            dailyReturns.push((dailyReturn * 100).toFixed(2) + '%');
            renderArrayInContainer(dailyReturns, 'returnsArray');
            
            // Highlight the return value
            const returnsElements = returnsContainer.querySelectorAll('.array-element');
            const returnElement = returnsElements[i].querySelector('.element-value');
            returnElement.classList.add('daily-return');
            returnElement.classList.add(dailyReturn >= 0 ? 'positive-return' : 'negative-return');
            
            step++;
            executeReturnsStep(i + 1);
        }, 2000);
    }
    
    // Start calculation
    executeReturnsStep(0);
}

// NEW: Perform Log Returns Calculation (similar structure)
function performLogReturnsCalculation() {
    // Similar structure to performDailyReturnsCalculation but with log formula
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Log Returns Calculation</h5>
        
        <div class="array-group">
            <div class="array-label">Stock Prices</div>
            <div class="original-array-container" id="originalPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Log Returns</div>
            <div class="transformed-array-container" id="logReturnsArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> log_returns[i] = log(price[i] / price[i-1])</p>
            <p class="mb-0" id="logReturnsExplanation">Starting log returns calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="logReturnsStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="logReturnsSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterLogReturns" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalStockPrices.map(p => p.toString()), 'originalPricesArray');
    renderArrayInContainer([], 'logReturnsArray');
    
    executeLogReturnsAnimation();
}

// NEW: Execute Log Returns Animation
function executeLogReturnsAnimation() {
    const originalContainer = document.getElementById('originalPricesArray');
    const logReturnsContainer = document.getElementById('logReturnsArray');
    const explanation = document.getElementById('logReturnsExplanation');
    const stepsContainer = document.getElementById('logReturnsSteps');
    const continueButton = document.getElementById('continueAfterLogReturns');
    
    const prices = [...originalStockPrices];
    const logReturns = [];
    let step = 0;
    
    function executeLogReturnsStep(i) {
        if (i >= prices.length) {
            explanation.innerHTML = `<strong>Log Returns Calculation Completed!</strong>`;
            continueButton.style.display = 'block';
            
            setTimeout(() => {
                returnToStockPrices();
            }, 5000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            return;
        }
        
        if (i === 0) {
            explanation.innerHTML = `Step ${step + 1}: First price - no log return calculation`;
            logReturns.push('N/A');
            renderArrayInContainer(logReturns, 'logReturnsArray');
            
            step++;
            setTimeout(() => executeLogReturnsStep(i + 1), 1500);
            return;
        }
        
        const currentPrice = prices[i];
        const previousPrice = prices[i - 1];
        const logReturn = Math.log(currentPrice / previousPrice);
        
        explanation.innerHTML = `Step ${step + 1}: Calculating log return for day ${i}<br>
                                log(${currentPrice} / ${previousPrice}) = ${logReturn.toFixed(4)}`;
        
        const originalElements = originalContainer.querySelectorAll('.array-element');
        originalElements[i - 1].querySelector('.element-value').classList.add('sorting-compared');
        originalElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step + 1}:</strong> Log_Return[${i}] = log(${currentPrice} / ${previousPrice}) = ${logReturn.toFixed(4)}
            </div>
        `;
        
        setTimeout(() => {
            originalElements[i - 1].querySelector('.element-value').classList.remove('sorting-compared');
            originalElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            logReturns.push(logReturn.toFixed(4));
            renderArrayInContainer(logReturns, 'logReturnsArray');
            
            const logReturnElements = logReturnsContainer.querySelectorAll('.array-element');
            const returnElement = logReturnElements[i].querySelector('.element-value');
            returnElement.classList.add('log-return');
            returnElement.classList.add(logReturn >= 0 ? 'positive-return' : 'negative-return');
            
            step++;
            executeLogReturnsStep(i + 1);
        }, 2000);
    }
    
    executeLogReturnsStep(0);
}

// NEW: Perform Cumulative Returns Calculation with Animation
function performCumulativeReturnsCalculation() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Cumulative Returns Calculation</h5>
        
        <div class="array-group">
            <div class="array-label">Stock Prices</div>
            <div class="original-array-container" id="originalPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Cumulative Returns</div>
            <div class="transformed-array-container" id="cumulativeReturnsArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> cumulative_returns[i] = (price[i] - price[0]) / price[0]</p>
            <p class="mb-2"><strong>Business Insight:</strong> Shows total return from initial investment to each point in time</p>
            <p class="mb-0" id="cumulativeExplanation">Starting cumulative returns calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="cumulativeStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="cumulativeSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Initial Investment Value</div>
            <div class="stats-value" id="initialInvestmentValue">${originalStockPrices[0]}</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterCumulative" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalStockPrices.map(p => p.toString()), 'originalPricesArray');
    renderArrayInContainer([], 'cumulativeReturnsArray');
    
    executeCumulativeReturnsAnimation();
}

// NEW: Execute Cumulative Returns Animation
function executeCumulativeReturnsAnimation() {
    const originalContainer = document.getElementById('originalPricesArray');
    const cumulativeContainer = document.getElementById('cumulativeReturnsArray');
    const explanation = document.getElementById('cumulativeExplanation');
    const stepsContainer = document.getElementById('cumulativeSteps');
    const continueButton = document.getElementById('continueAfterCumulative');
    const initialInvestmentValue = document.getElementById('initialInvestmentValue');
    
    const prices = [...originalStockPrices];
    const cumulativeReturns = [];
    const initialPrice = prices[0];
    let step = 0;
    
    function executeCumulativeStep(i) {
        if (i >= prices.length) {
            // Calculation completed
            explanation.innerHTML = `<strong>Cumulative Returns Calculation Completed!</strong><br>
                                    Total period return: ${((prices[prices.length-1] - initialPrice) / initialPrice * 100).toFixed(2)}%`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final Analysis:</strong> 
                    Initial: ${initialPrice} | Final: ${prices[prices.length-1]} | 
                    Total Return: ${((prices[prices.length-1] - initialPrice) / initialPrice * 100).toFixed(2)}%
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 8 seconds (more time for analysis)
            setTimeout(() => {
                returnToStockPrices();
            }, 8000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            
            return;
        }
        
        const currentPrice = prices[i];
        const cumulativeReturn = (currentPrice - initialPrice) / initialPrice;
        
        explanation.innerHTML = `Step ${step + 1}: Day ${i} Cumulative Return<br>
                                (Current: ${currentPrice} - Initial: ${initialPrice}) / Initial: ${initialPrice}<br>
                                = ${(cumulativeReturn * 100).toFixed(2)}% cumulative return`;
        
        // Highlight the prices being used
        const originalElements = originalContainer.querySelectorAll('.array-element');
        originalElements[0].querySelector('.element-value').classList.add('sorting-compared');
        originalElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Day ${i}:</strong> 
                Cumulative Return = (${currentPrice} - ${initialPrice}) / ${initialPrice} = ${(cumulativeReturn * 100).toFixed(2)}%<br>
                <small>Investment growth from day 0 to day ${i}</small>
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            originalElements[0].querySelector('.element-value').classList.remove('sorting-compared');
            originalElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            // Add the calculated cumulative return
            cumulativeReturns.push((cumulativeReturn * 100).toFixed(2) + '%');
            renderArrayInContainer(cumulativeReturns, 'cumulativeReturnsArray');
            
            // Highlight the cumulative return value
            const cumulativeElements = cumulativeContainer.querySelectorAll('.array-element');
            const cumulativeElement = cumulativeElements[i].querySelector('.element-value');
            cumulativeElement.classList.add('cumulative-return');
            cumulativeElement.classList.add(cumulativeReturn >= 0 ? 'positive-return' : 'negative-return');
            
            // Show investment value growth
            if (i > 0) {
                const investmentValue = initialPrice * (1 + cumulativeReturn);
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Portfolio Value Day ${i}:</strong> 
                        $${investmentValue.toFixed(2)} (Initial: $${initialPrice})
                    </div>
                `;
            }
            
            step++;
            executeCumulativeStep(i + 1);
        }, 2500);
    }
    
    // Start calculation
    executeCumulativeStep(0);
}

// NEW: Perform Total Return Calculation with Animation
function performTotalReturnCalculation() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Total Return Analysis</h5>
        
        <div class="array-group">
            <div class="array-label">Stock Prices Over Time</div>
            <div class="original-array-container" id="originalPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Investment Performance</div>
            <div class="transformed-array-container" id="performanceArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> total_return = (price[last] - price[0]) / price[0]</p>
            <p class="mb-2"><strong>Business Insight:</strong> Overall investment performance across entire period</p>
            <p class="mb-0" id="totalReturnExplanation">Starting total return analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="totalReturnStepsContainer">
            <h6 class="text-center">Investment Analysis</h6>
            <div class="steps-container" id="totalReturnSteps"></div>
        </div>
        
        <div class="row mt-3">
            <div class="col-md-6">
                <div class="stats-card">
                    <div>Initial Price</div>
                    <div class="stats-value" id="initialPriceValue">-</div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="stats-card">
                    <div>Final Price</div>
                    <div class="stats-value" id="finalPriceValue">-</div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="stats-card">
                    <div>Total Return</div>
                    <div class="stats-value" id="totalReturnValue">-</div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="stats-card">
                    <div>Performance</div>
                    <div class="stats-value" id="performanceValue">-</div>
                </div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterTotalReturn" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalStockPrices.map(p => p.toString()), 'originalPricesArray');
    renderArrayInContainer(['Analysis in progress...'], 'performanceArray');
    
    executeTotalReturnAnimation();
}

// NEW: Execute Total Return Animation
function executeTotalReturnAnimation() {
    const originalContainer = document.getElementById('originalPricesArray');
    const performanceContainer = document.getElementById('performanceArray');
    const explanation = document.getElementById('totalReturnExplanation');
    const stepsContainer = document.getElementById('totalReturnSteps');
    const continueButton = document.getElementById('continueAfterTotalReturn');
    
    const initialPriceValue = document.getElementById('initialPriceValue');
    const finalPriceValue = document.getElementById('finalPriceValue');
    const totalReturnValue = document.getElementById('totalReturnValue');
    const performanceValue = document.getElementById('performanceValue');
    
    const prices = [...originalStockPrices];
    const initialPrice = prices[0];
    const finalPrice = prices[prices.length - 1];
    const totalReturn = (finalPrice - initialPrice) / initialPrice;
    
    let step = 0;
    
    function executeTotalReturnStep() {
        switch (step) {
            case 0:
                // Step 1: Show initial price
                explanation.innerHTML = `Step ${step + 1}: Identify Initial Investment Price`;
                initialPriceValue.textContent = initialPrice;
                
                const initialElements = originalContainer.querySelectorAll('.array-element');
                initialElements[0].querySelector('.element-value').classList.add('create', 'pulse');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1 - Initial Investment:</strong> 
                        Day 0 price = $${initialPrice}<br>
                        <small>This is your starting investment value</small>
                    </div>
                `;
                break;
                
            case 1:
                // Step 2: Show final price
                explanation.innerHTML = `Step ${step + 1}: Identify Final Portfolio Value`;
                finalPriceValue.textContent = finalPrice;
                
                const finalElements = originalContainer.querySelectorAll('.array-element');
                finalElements[finalElements.length - 1].querySelector('.element-value').classList.add('update', 'pulse');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2 - Final Value:</strong> 
                        Day ${prices.length - 1} price = $${finalPrice}<br>
                        <small>This is your ending portfolio value</small>
                    </div>
                `;
                break;
                
            case 2:
                // Step 3: Calculate total return
                explanation.innerHTML = `Step ${step + 1}: Calculate Total Return Percentage`;
                totalReturnValue.textContent = (totalReturn * 100).toFixed(2) + '%';
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3 - Return Calculation:</strong><br>
                        Formula: (Final - Initial) / Initial<br>
                        (${finalPrice} - ${initialPrice}) / ${initialPrice} = ${(totalReturn * 100).toFixed(2)}%
                    </div>
                `;
                break;
                
            case 3:
                // Step 4: Performance analysis
                explanation.innerHTML = `Step ${step + 1}: Investment Performance Analysis`;
                
                const performanceText = totalReturn >= 0 ? 
                    `POSITIVE - Investment Grew ${(totalReturn * 100).toFixed(2)}%` : 
                    `NEGATIVE - Investment Declined ${Math.abs(totalReturn * 100).toFixed(2)}%`;
                
                performanceValue.textContent = performanceText;
                performanceValue.className = `stats-value ${totalReturn >= 0 ? 'text-success' : 'text-danger'}`;
                
                // Update performance array
                const performanceData = [
                    `Initial: $${initialPrice}`,
                    `Final: $${finalPrice}`,
                    `Return: ${(totalReturn * 100).toFixed(2)}%`,
                    totalReturn >= 0 ? ' PROFIT' : ' LOSS'
                ];
                renderArrayInContainer(performanceData, 'performanceArray');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step ${totalReturn >= 0 ? 'active' : ''}">
                        <strong>Step 4 - Performance Summary:</strong><br>
                         Initial Investment: $${initialPrice}<br>
                         Final Value: $${finalPrice}<br>
                         Total Return: ${(totalReturn * 100).toFixed(2)}%<br>
                         $10,000 would become $${(10000 * (1 + totalReturn)).toFixed(2)}
                    </div>
                `;
                break;
                
            case 4:
                // Step 5: Complete analysis
                explanation.innerHTML = `<strong>Total Return Analysis Completed!</strong><br>
                                        Your investment ${totalReturn >= 0 ? 'grew' : 'declined'} by ${Math.abs(totalReturn * 100).toFixed(2)}%`;
                
                // Highlight all elements to show the journey
                const allElements = originalContainer.querySelectorAll('.array-element');
                allElements.forEach((el, index) => {
                    setTimeout(() => {
                        el.querySelector('.element-value').classList.add('color-change');
                    }, index * 200);
                });
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>FINAL ANALYSIS:</strong><br>
                        <div class="mt-2 p-2 ${totalReturn >= 0 ? 'bg-success' : 'bg-danger'} rounded text-white">
                            <strong>Investment Result:</strong><br>
                            Period: ${prices.length} days<br>
                            Return: ${(totalReturn * 100).toFixed(2)}%<br>
                            Performance: ${totalReturn >= 0 ? ' SUCCESSFUL' : ' UNSUCCESSFUL'}
                        </div>
                    </div>
                `;
                
                continueButton.style.display = 'block';
                
                // Auto-return after 10 seconds (more time for analysis)
                setTimeout(() => {
                    returnToStockPrices();
                }, 10000);
                
                continueButton.addEventListener('click', returnToStockPrices);
                return;
        }
        
        step++;
        setTimeout(executeTotalReturnStep, 3000);
    }
    
    // Start analysis
    executeTotalReturnStep();
}

// NEW: Perform Price Difference Calculation with Animation
function performPriceDifferenceCalculation() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Price Difference Analysis</h5>
        
        <div class="array-group">
            <div class="array-label">Stock Prices</div>
            <div class="original-array-container" id="originalPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Daily Price Changes</div>
            <div class="transformed-array-container" id="priceDiffArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> diff[i] = price[i] - price[i-1]</p>
            <p class="mb-2"><strong>Business Insight:</strong> Shows daily price movements and volatility</p>
            <p class="mb-0" id="priceDiffExplanation">Starting price difference analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="priceDiffStepsContainer">
            <h6 class="text-center">Daily Movement Analysis</h6>
            <div class="steps-container" id="priceDiffSteps"></div>
        </div>
        
        <div class="row mt-3">
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Total Up Days</div>
                    <div class="stats-value" id="upDaysValue">0</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Total Down Days</div>
                    <div class="stats-value" id="downDaysValue">0</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Net Change</div>
                    <div class="stats-value" id="netChangeValue">0</div>
                </div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPriceDiff" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalStockPrices.map(p => p.toString()), 'originalPricesArray');
    renderArrayInContainer([], 'priceDiffArray');
    
    executePriceDifferenceAnimation();
}

// NEW: Execute Price Difference Animation
function executePriceDifferenceAnimation() {
    const originalContainer = document.getElementById('originalPricesArray');
    const priceDiffContainer = document.getElementById('priceDiffArray');
    const explanation = document.getElementById('priceDiffExplanation');
    const stepsContainer = document.getElementById('priceDiffSteps');
    const continueButton = document.getElementById('continueAfterPriceDiff');
    
    const upDaysValue = document.getElementById('upDaysValue');
    const downDaysValue = document.getElementById('downDaysValue');
    const netChangeValue = document.getElementById('netChangeValue');
    
    const prices = [...originalStockPrices];
    const priceDifferences = [];
    let upDays = 0;
    let downDays = 0;
    let totalNetChange = 0;
    let step = 0;
    
    function executePriceDiffStep(i) {
        if (i >= prices.length) {
            // Calculation completed
            explanation.innerHTML = `<strong>Price Difference Analysis Completed!</strong><br>
                                    Volatility Analysis: ${upDays} up days, ${downDays} down days`;
            
            // Final statistics
            const volatility = (upDays + downDays) / (prices.length - 1);
            const avgGain = upDays > 0 ? totalNetChange / upDays : 0;
            const avgLoss = downDays > 0 ? Math.abs(totalNetChange) / downDays : 0;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>VOLATILITY ANALYSIS:</strong><br>
                     Trading Days: ${prices.length - 1}<br>
                     Up Days: ${upDays} (${((upDays/(prices.length-1))*100).toFixed(1)}%)<br>
                     Down Days: ${downDays} (${((downDays/(prices.length-1))*100).toFixed(1)}%)<br>
                     Net Price Change: ${totalNetChange.toFixed(2)}<br>
                     Volatility Score: ${(volatility * 100).toFixed(1)}%
                </div>
            `;
            
            // Update final stats
            upDaysValue.textContent = upDays;
            downDaysValue.textContent = downDays;
            netChangeValue.textContent = totalNetChange.toFixed(2);
            
            continueButton.style.display = 'block';
            
            // Auto-return after 8 seconds
            setTimeout(() => {
                returnToStockPrices();
            }, 8000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            
            return;
        }
        
        if (i === 0) {
            // First element - no difference calculation
            explanation.innerHTML = `Step ${step + 1}: Baseline price established`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step + 1}:</strong> Baseline price = $${prices[i]}<br>
                    <small>Starting reference point for all calculations</small>
                </div>
            `;
            
            priceDifferences.push('Baseline');
            renderArrayInContainer(priceDifferences, 'priceDiffArray');
            
            step++;
            setTimeout(() => executePriceDiffStep(i + 1), 2000);
            return;
        }
        
        // Calculate price difference
        const currentPrice = prices[i];
        const previousPrice = prices[i - 1];
        const priceDiff = currentPrice - previousPrice;
        
        explanation.innerHTML = `Step ${step + 1}: Day ${i} Price Movement<br>
                                Current: $${currentPrice} - Previous: $${previousPrice} = ${priceDiff >= 0 ? '+' : ''}${priceDiff.toFixed(2)}`;
        
        // Update statistics
        if (priceDiff > 0) {
            upDays++;
            totalNetChange += priceDiff;
        } else if (priceDiff < 0) {
            downDays++;
            totalNetChange += priceDiff;
        }
        
        // Highlight the prices being used
        const originalElements = originalContainer.querySelectorAll('.array-element');
        originalElements[i - 1].querySelector('.element-value').classList.add('sorting-compared');
        originalElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${priceDiff !== 0 ? 'active' : ''}">
                <strong>Day ${i} Analysis:</strong><br>
                 Price Change: ${priceDiff >= 0 ? '+' : ''}${priceDiff.toFixed(2)}<br>
                 Movement: ${priceDiff > 0 ? ' UP' : priceDiff < 0 ? ' DOWN' : ' FLAT'}<br>
                 Cumulative: ${upDays} up, ${downDays} down days
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            originalElements[i - 1].querySelector('.element-value').classList.remove('sorting-compared');
            originalElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            // Add the calculated price difference
            const diffText = priceDiff > 0 ? `+${priceDiff.toFixed(2)}` : priceDiff.toFixed(2);
            priceDifferences.push(diffText);
            renderArrayInContainer(priceDifferences, 'priceDiffArray');
            
            // Highlight the difference value
            const diffElements = priceDiffContainer.querySelectorAll('.array-element');
            const diffElement = diffElements[i].querySelector('.element-value');
            diffElement.classList.add('price-difference');
            
            if (priceDiff > 0) {
                diffElement.classList.add('positive-return');
                diffElement.innerHTML = `${diffText} `;
            } else if (priceDiff < 0) {
                diffElement.classList.add('negative-return');
                diffElement.innerHTML = `${diffText} `;
            } else {
                diffElement.innerHTML = `${diffText} `;
            }
            
            // Update live statistics
            upDaysValue.textContent = upDays;
            downDaysValue.textContent = downDays;
            netChangeValue.textContent = totalNetChange.toFixed(2);
            
            step++;
            executePriceDiffStep(i + 1);
        }, 2500);
    }
    
    // Start calculation
    executePriceDiffStep(0);
}
// NEW: Return to Stock Prices (common function for all operations)
function returnToStockPrices() {
    // Reset to original stock prices
    if (originalStockPrices.length > 0) {
        myArray = originalStockPrices.map(price => price.toString());
        renderArray();
        updateStats();
        
        // Highlight all prices
        setTimeout(() => {
            myArray.forEach((_, index) => {
                highlightElement(index, 'stock-price');
            });
        }, 100);
    }
    
    // Reset state
    isStockOperationRunning = false;
    
    logOperation('Returned to original stock prices', 'info');
    showNotification('Returned to original stock prices', 'success');
}
// NEW: Perform Price Momentum Calculation
function performPriceMomentumCalculation() {
    if (originalStockPrices.length < 2) {
        showNotification('Need at least 2 prices for momentum calculation', 'warning');
        return;
    }

    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3"> Price Momentum Analysis (N-day)</h5>
        
        <div class="array-group">
            <div class="array-label">Stock Prices</div>
            <div class="original-array-container" id="originalPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Price Momentum (N=1 day)</div>
            <div class="transformed-array-container" id="momentumArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> momentum[i] = price[i] - price[i-1]</p>
            <p class="mb-2"><strong>Business Insight:</strong> Shows the directional movement and strength of price changes</p>
            <p class="mb-0" id="momentumExplanation">Starting price momentum calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="momentumStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="momentumSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Total Positive Momentum Days</div>
            <div class="stats-value" id="positiveMomentumCount">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMomentum" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalStockPrices.map(p => p.toString()), 'originalPricesArray');
    renderArrayInContainer([], 'momentumArray');
    
    executePriceMomentumAnimation();
}

// NEW: Execute Price Momentum Animation
function executePriceMomentumAnimation() {
    const originalContainer = document.getElementById('originalPricesArray');
    const momentumContainer = document.getElementById('momentumArray');
    const explanation = document.getElementById('momentumExplanation');
    const stepsContainer = document.getElementById('momentumSteps');
    const continueButton = document.getElementById('continueAfterMomentum');
    const positiveMomentumCount = document.getElementById('positiveMomentumCount');
    
    const prices = [...originalStockPrices];
    const momentumValues = [];
    let positiveDays = 0;
    let step = 0;
    
    function executeMomentumStep(i) {
        if (i >= prices.length) {
            explanation.innerHTML = `<strong>Price Momentum Analysis Completed!</strong><br>
                                    ${positiveDays} positive momentum days out of ${prices.length - 1} trading days`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>MOMENTUM SUMMARY:</strong><br>
                     Total Trading Days: ${prices.length - 1}<br>
                     Positive Momentum Days: ${positiveDays}<br>
                     Negative Momentum Days: ${prices.length - 1 - positiveDays}<br>
                     Bullish Ratio: ${((positiveDays/(prices.length-1))*100).toFixed(1)}%
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToStockPrices();
            }, 10000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            return;
        }
        
        if (i === 0) {
            explanation.innerHTML = `Step ${step + 1}: Baseline established - no momentum calculation for first price`;
            momentumValues.push('Baseline');
            renderArrayInContainer(momentumValues, 'momentumArray');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step + 1}:</strong> Baseline price = $${prices[i]}<br>
                    <small>Starting point for momentum calculations</small>
                </div>
            `;
            
            step++;
            setTimeout(() => executeMomentumStep(i + 1), 2000);
            return;
        }
        
        const currentPrice = prices[i];
        const previousPrice = prices[i - 1];
        const momentum = currentPrice - previousPrice;
        
        explanation.innerHTML = `Step ${step + 1}: Calculating Day ${i} Momentum<br>
                                Formula: ${currentPrice} - ${previousPrice} = ${momentum.toFixed(2)}`;
        
        // Update statistics
        if (momentum > 0) positiveDays++;
        
        // Highlight the prices being used
        const originalElements = originalContainer.querySelectorAll('.array-element');
        originalElements[i - 1].querySelector('.element-value').classList.add('sorting-compared');
        originalElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step + 1}:</strong> Momentum[${i}] = ${currentPrice} - ${previousPrice}<br>
                <strong>Result:</strong> ${momentum >= 0 ? '+' : ''}${momentum.toFixed(2)}<br>
                <small>${momentum > 0 ? ' BULLISH' : momentum < 0 ? ' BEARISH' : ' NEUTRAL'} momentum</small>
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            originalElements[i - 1].querySelector('.element-value').classList.remove('sorting-compared');
            originalElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            // Add the calculated momentum
            momentumValues.push(momentum.toFixed(2));
            renderArrayInContainer(momentumValues, 'momentumArray');
            
            // Highlight the momentum value
            const momentumElements = momentumContainer.querySelectorAll('.array-element');
            const momentumElement = momentumElements[i].querySelector('.element-value');
            momentumElement.classList.add('price-momentum');
            
            if (momentum > 0) {
                momentumElement.classList.add('momentum-positive');
                momentumElement.innerHTML = `+${momentum.toFixed(2)} `;
            } else if (momentum < 0) {
                momentumElement.classList.add('momentum-negative');
                momentumElement.innerHTML = `${momentum.toFixed(2)} `;
            } else {
                momentumElement.innerHTML = `${momentum.toFixed(2)} `;
            }
            
            // Update statistics
            positiveMomentumCount.textContent = positiveDays;
            
            step++;
            executeMomentumStep(i + 1);
        }, 2500);
    }
    
    executeMomentumStep(0);
}

// NEW: Perform Rate of Change (ROC) Calculation
function performRateOfChangeCalculation() {
    if (originalStockPrices.length < 2) {
        showNotification('Need at least 2 prices for ROC calculation', 'warning');
        return;
    }

    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3"> Rate of Change (ROC) Analysis</h5>
        
        <div class="array-group">
            <div class="array-label">Stock Prices</div>
            <div class="original-array-container" id="originalPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Rate of Change % (N=1 day)</div>
            <div class="transformed-array-container" id="rocArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> ROC[i] = ((price[i] - price[i-1]) / price[i-1])  100</p>
            <p class="mb-2"><strong>Business Insight:</strong> Percentage-based momentum indicator showing relative price changes</p>
            <p class="mb-0" id="rocExplanation">Starting ROC calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="rocStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="rocSteps"></div>
        </div>
        
        <div class="row mt-3">
            <div class="col-md-6">
                <div class="stats-card">
                    <div>Average ROC</div>
                    <div class="stats-value" id="averageROC">0%</div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="stats-card">
                    <div>Max ROC</div>
                    <div class="stats-value" id="maxROC">0%</div>
                </div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterROC" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalStockPrices.map(p => p.toString()), 'originalPricesArray');
    renderArrayInContainer([], 'rocArray');
    
    executeRateOfChangeAnimation();
}

// NEW: Execute Rate of Change Animation
function executeRateOfChangeAnimation() {
    const originalContainer = document.getElementById('originalPricesArray');
    const rocContainer = document.getElementById('rocArray');
    const explanation = document.getElementById('rocExplanation');
    const stepsContainer = document.getElementById('rocSteps');
    const continueButton = document.getElementById('continueAfterROC');
    const averageROC = document.getElementById('averageROC');
    const maxROC = document.getElementById('maxROC');
    
    const prices = [...originalStockPrices];
    const rocValues = [];
    let totalROC = 0;
    let maxROCAbs = 0;
    let step = 0;
    
    function executeROCStep(i) {
        if (i >= prices.length) {
            const avgROC = totalROC / (prices.length - 1);
            explanation.innerHTML = `<strong>ROC Analysis Completed!</strong><br>
                                    Average daily ROC: ${avgROC.toFixed(2)}%`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>ROC SUMMARY:</strong><br>
                     Analysis Period: ${prices.length} days<br>
                     Trading Days: ${prices.length - 1}<br>
                     Average Daily ROC: ${avgROC.toFixed(2)}%<br>
                     Maximum ROC: ${maxROCAbs.toFixed(2)}%<br>
                     Volatility: ${(maxROCAbs * 2).toFixed(2)}% range
                </div>
            `;
            
            averageROC.textContent = avgROC.toFixed(2) + '%';
            maxROC.textContent = maxROCAbs.toFixed(2) + '%';
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToStockPrices();
            }, 10000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            return;
        }
        
        if (i === 0) {
            explanation.innerHTML = `Step ${step + 1}: Baseline established - no ROC calculation for first price`;
            rocValues.push('Baseline');
            renderArrayInContainer(rocValues, 'rocArray');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step + 1}:</strong> Baseline price = $${prices[i]}<br>
                    <small>Reference point for ROC calculations</small>
                </div>
            `;
            
            step++;
            setTimeout(() => executeROCStep(i + 1), 2000);
            return;
        }
        
        const currentPrice = prices[i];
        const previousPrice = prices[i - 1];
        const roc = ((currentPrice - previousPrice) / previousPrice) * 100;
        
        explanation.innerHTML = `Step ${step + 1}: Calculating Day ${i} ROC<br>
                                Formula: ((${currentPrice} - ${previousPrice}) / ${previousPrice})  100<br>
                                Result: ${roc.toFixed(2)}%`;
        
        // Update statistics
        totalROC += Math.abs(roc);
        if (Math.abs(roc) > maxROCAbs) maxROCAbs = Math.abs(roc);
        
        // Highlight the prices being used
        const originalElements = originalContainer.querySelectorAll('.array-element');
        originalElements[i - 1].querySelector('.element-value').classList.add('sorting-compared');
        originalElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step + 1}:</strong> ROC[${i}] = ((${currentPrice} - ${previousPrice}) / ${previousPrice})  100<br>
                <strong>Calculation:</strong> (${(currentPrice - previousPrice).toFixed(2)} / ${previousPrice})  100<br>
                <strong>Result:</strong> ${roc >= 0 ? '+' : ''}${roc.toFixed(2)}%<br>
                <small>${roc > 1 ? ' STRONG BULLISH' : roc > 0 ? ' BULLISH' : roc < -1 ? ' STRONG BEARISH' : roc < 0 ? ' BEARISH' : ' NEUTRAL'}</small>
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            originalElements[i - 1].querySelector('.element-value').classList.remove('sorting-compared');
            originalElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            // Add the calculated ROC
            rocValues.push(roc.toFixed(2) + '%');
            renderArrayInContainer(rocValues, 'rocArray');
            
            // Highlight the ROC value
            const rocElements = rocContainer.querySelectorAll('.array-element');
            const rocElement = rocElements[i].querySelector('.element-value');
            rocElement.classList.add('roc-indicator');
            
            if (roc > 1) {
                rocElement.classList.add('roc-high', 'momentum-positive');
                rocElement.innerHTML = `+${roc.toFixed(2)}% `;
            } else if (roc > 0) {
                rocElement.classList.add('roc-high');
                rocElement.innerHTML = `+${roc.toFixed(2)}% `;
            } else if (roc < -1) {
                rocElement.classList.add('roc-low', 'momentum-negative');
                rocElement.innerHTML = `${roc.toFixed(2)}% `;
            } else if (roc < 0) {
                rocElement.classList.add('roc-low');
                rocElement.innerHTML = `${roc.toFixed(2)}% `;
            } else {
                rocElement.innerHTML = `${roc.toFixed(2)}% `;
            }
            
            step++;
            executeROCStep(i + 1);
        }, 3000);
    }
    
    executeROCStep(0);
}

// NEW: Perform Gap Analysis Calculation
function performGapAnalysisCalculation() {
    if (openPrices.length === 0 || closePrices.length === 0) {
        showNotification('Open/Close price data not available', 'warning');
        return;
    }

    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3"> Gap Up/Down Analysis</h5>
        
        <div class="array-group">
            <div class="array-label">Previous Day Close Prices</div>
            <div class="original-array-container" id="closePricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-right"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Current Day Open Prices</div>
            <div class="transformed-array-container" id="openPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Gap Analysis %</div>
            <div class="transformed-array-container" id="gapArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> gap[i] = (open[i] - close[i-1]) / close[i-1]  100</p>
            <p class="mb-2"><strong>Business Insight:</strong> Measures overnight price movements and market sentiment gaps</p>
            <p class="mb-0" id="gapExplanation">Starting gap analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="gapStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="gapSteps"></div>
        </div>
        
        <div class="row mt-3">
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Gap Up Days</div>
                    <div class="stats-value" id="gapUpCount">0</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Gap Down Days</div>
                    <div class="stats-value" id="gapDownCount">0</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Largest Gap</div>
                    <div class="stats-value" id="largestGap">0%</div>
                </div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterGap" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display previous closes (shifted by one)
    const previousCloses = ['N/A', ...closePrices.slice(0, -1).map(p => p.toFixed(2))];
    renderArrayInContainer(previousCloses, 'closePricesArray');
    renderArrayInContainer(openPrices.map(p => p.toFixed(2)), 'openPricesArray');
    renderArrayInContainer([], 'gapArray');
    
    executeGapAnalysisAnimation();
}

// NEW: Execute Gap Analysis Animation
function executeGapAnalysisAnimation() {
    const closeContainer = document.getElementById('closePricesArray');
    const openContainer = document.getElementById('openPricesArray');
    const gapContainer = document.getElementById('gapArray');
    const explanation = document.getElementById('gapExplanation');
    const stepsContainer = document.getElementById('gapSteps');
    const continueButton = document.getElementById('continueAfterGap');
    const gapUpCount = document.getElementById('gapUpCount');
    const gapDownCount = document.getElementById('gapDownCount');
    const largestGap = document.getElementById('largestGap');
    
    let gapUpDays = 0;
    let gapDownDays = 0;
    let maxGap = 0;
    const gapValues = [];
    let step = 0;
    
    function executeGapStep(i) {
        if (i >= openPrices.length) {
            explanation.innerHTML = `<strong>Gap Analysis Completed!</strong><br>
                                    ${gapUpDays} gap up days, ${gapDownDays} gap down days`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>GAP ANALYSIS SUMMARY:</strong><br>
                     Total Trading Days: ${openPrices.length - 1}<br>
                     Gap Up Days: ${gapUpDays} (${((gapUpDays/(openPrices.length-1))*100).toFixed(1)}%)<br>
                     Gap Down Days: ${gapDownDays} (${((gapDownDays/(openPrices.length-1))*100).toFixed(1)}%)<br>
                     Largest Gap: ${maxGap.toFixed(2)}%<br>
                     Market Sentiment: ${gapUpDays > gapDownDays ? 'BULLISH' : gapDownDays > gapUpDays ? 'BEARISH' : 'NEUTRAL'} bias
                </div>
            `;
            
            gapUpCount.textContent = gapUpDays;
            gapDownCount.textContent = gapDownDays;
            largestGap.textContent = maxGap.toFixed(2) + '%';
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToStockPrices();
            }, 10000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            return;
        }
        
        if (i === 0) {
            explanation.innerHTML = `Step ${step + 1}: First day - no previous close for gap calculation`;
            gapValues.push('N/A');
            renderArrayInContainer(gapValues, 'gapArray');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step + 1}:</strong> Day 0 - Initial opening<br>
                    <small>No previous close price available</small>
                </div>
            `;
            
            step++;
            setTimeout(() => executeGapStep(i + 1), 2000);
            return;
        }
        
        const currentOpen = openPrices[i];
        const previousClose = closePrices[i - 1];
        const gap = ((currentOpen - previousClose) / previousClose) * 100;
        
        explanation.innerHTML = `Step ${step + 1}: Calculating Day ${i} Gap<br>
                                Formula: ((${currentOpen.toFixed(2)} - ${previousClose.toFixed(2)}) / ${previousClose.toFixed(2)})  100<br>
                                Result: ${gap.toFixed(2)}%`;
        
        // Update statistics
        if (gap > 0) {
            gapUpDays++;
        } else if (gap < 0) {
            gapDownDays++;
        }
        
        if (Math.abs(gap) > Math.abs(maxGap)) {
            maxGap = gap;
        }
        
        // Highlight the prices being used
        const closeElements = closeContainer.querySelectorAll('.array-element');
        const openElements = openContainer.querySelectorAll('.array-element');
        
        closeElements[i].querySelector('.element-value').classList.add('sorting-compared');
        openElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step + 1}:</strong> Gap[${i}] = ((${currentOpen.toFixed(2)} - ${previousClose.toFixed(2)}) / ${previousClose.toFixed(2)})  100<br>
                <strong>Calculation:</strong> (${(currentOpen - previousClose).toFixed(2)} / ${previousClose.toFixed(2)})  100<br>
                <strong>Result:</strong> ${gap >= 0 ? '+' : ''}${gap.toFixed(2)}%<br>
                <small>${gap > 0 ? ' GAP UP - Bullish opening' : gap < 0 ? ' GAP DOWN - Bearish opening' : ' NO GAP - Neutral opening'}</small>
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            closeElements[i].querySelector('.element-value').classList.remove('sorting-compared');
            openElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            // Add the calculated gap
            gapValues.push(gap.toFixed(2) + '%');
            renderArrayInContainer(gapValues, 'gapArray');
            
            // Highlight the gap value
            const gapElements = gapContainer.querySelectorAll('.array-element');
            const gapElement = gapElements[i].querySelector('.element-value');
            
            if (gap > 0.5) {
                gapElement.classList.add('gap-up', 'momentum-positive');
                gapElement.innerHTML = `+${gap.toFixed(2)}% `;
            } else if (gap > 0) {
                gapElement.classList.add('gap-up');
                gapElement.innerHTML = `+${gap.toFixed(2)}% `;
            } else if (gap < -0.5) {
                gapElement.classList.add('gap-down', 'momentum-negative');
                gapElement.innerHTML = `${gap.toFixed(2)}% `;
            } else if (gap < 0) {
                gapElement.classList.add('gap-down');
                gapElement.innerHTML = `${gap.toFixed(2)}% `;
            } else {
                gapElement.innerHTML = `${gap.toFixed(2)}% `;
            }
            
            // Update statistics
            gapUpCount.textContent = gapUpDays;
            gapDownCount.textContent = gapDownDays;
            largestGap.textContent = maxGap.toFixed(2) + '%';
            
            step++;
            executeGapStep(i + 1);
        }, 3000);
    }
    
    executeGapStep(0);
}

// NEW: Perform Intraday Gain/Loss Calculation
function performIntradayGainCalculation() {
    if (openPrices.length === 0 || closePrices.length === 0) {
        showNotification('Open/Close price data not available', 'warning');
        return;
    }

    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3"> Intraday Gain/Loss Analysis</h5>
        
        <div class="array-group">
            <div class="array-label">Daily Open Prices</div>
            <div class="original-array-container" id="openPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-right"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Daily Close Prices</div>
            <div class="transformed-array-container" id="closePricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Intraday Gain/Loss %</div>
            <div class="transformed-array-container" id="intradayArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> intraday[i] = (close[i] - open[i]) / open[i]  100</p>
            <p class="mb-2"><strong>Business Insight:</strong> Measures daily trading performance and intraday volatility</p>
            <p class="mb-0" id="intradayExplanation">Starting intraday analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="intradayStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="intradaySteps"></div>
        </div>
        
        <div class="row mt-3">
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Profitable Days</div>
                    <div class="stats-value" id="profitableDays">0</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Losing Days</div>
                    <div class="stats-value" id="losingDays">0</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Best Day</div>
                    <div class="stats-value" id="bestDay">0%</div>
                </div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterIntraday" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(openPrices.map(p => p.toFixed(2)), 'openPricesArray');
    renderArrayInContainer(closePrices.map(p => p.toFixed(2)), 'closePricesArray');
    renderArrayInContainer([], 'intradayArray');
    
    executeIntradayGainAnimation();
}

// NEW: Execute Intraday Gain/Loss Animation
function executeIntradayGainAnimation() {
    const openContainer = document.getElementById('openPricesArray');
    const closeContainer = document.getElementById('closePricesArray');
    const intradayContainer = document.getElementById('intradayArray');
    const explanation = document.getElementById('intradayExplanation');
    const stepsContainer = document.getElementById('intradaySteps');
    const continueButton = document.getElementById('continueAfterIntraday');
    const profitableDays = document.getElementById('profitableDays');
    const losingDays = document.getElementById('losingDays');
    const bestDay = document.getElementById('bestDay');
    
    let profitDays = 0;
    let lossDays = 0;
    let bestGain = 0;
    const intradayValues = [];
    let step = 0;
    
    function executeIntradayStep(i) {
        if (i >= openPrices.length) {
            explanation.innerHTML = `<strong>Intraday Analysis Completed!</strong><br>
                                    ${profitDays} profitable days, ${lossDays} losing days`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>INTRADAY TRADING SUMMARY:</strong><br>
                     Total Trading Days: ${openPrices.length}<br>
                     Profitable Days: ${profitDays} (${((profitDays/openPrices.length)*100).toFixed(1)}%)<br>
                     Losing Days: ${lossDays} (${((lossDays/openPrices.length)*100).toFixed(1)}%)<br>
                     Best Day: +${bestGain.toFixed(2)}%<br>
                     Win Rate: ${((profitDays/openPrices.length)*100).toFixed(1)}%
                </div>
            `;
            
            profitableDays.textContent = profitDays;
            losingDays.textContent = lossDays;
            bestDay.textContent = '+' + bestGain.toFixed(2) + '%';
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToStockPrices();
            }, 10000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            return;
        }
        
        const openPrice = openPrices[i];
        const closePrice = closePrices[i];
        const intradayGain = ((closePrice - openPrice) / openPrice) * 100;
        
        explanation.innerHTML = `Step ${step + 1}: Calculating Day ${i} Intraday Performance<br>
                                Formula: ((${closePrice.toFixed(2)} - ${openPrice.toFixed(2)}) / ${openPrice.toFixed(2)})  100<br>
                                Result: ${intradayGain.toFixed(2)}%`;
        
        // Update statistics
        if (intradayGain > 0) {
            profitDays++;
            if (intradayGain > bestGain) bestGain = intradayGain;
        } else if (intradayGain < 0) {
            lossDays++;
        }
        
        // Highlight the prices being used
        const openElements = openContainer.querySelectorAll('.array-element');
        const closeElements = closeContainer.querySelectorAll('.array-element');
        
        openElements[i].querySelector('.element-value').classList.add('sorting-compared');
        closeElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step + 1}:</strong> Intraday[${i}] = ((${closePrice.toFixed(2)} - ${openPrice.toFixed(2)}) / ${openPrice.toFixed(2)})  100<br>
                <strong>Calculation:</strong> (${(closePrice - openPrice).toFixed(2)} / ${openPrice.toFixed(2)})  100<br>
                <strong>Result:</strong> ${intradayGain >= 0 ? '+' : ''}${intradayGain.toFixed(2)}%<br>
                <small>${intradayGain > 0 ? ' PROFIT' : intradayGain < 0 ? ' LOSS' : ' BREAKEVEN'} for the day</small>
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            openElements[i].querySelector('.element-value').classList.remove('sorting-compared');
            closeElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            // Add the calculated intraday gain
            intradayValues.push(intradayGain.toFixed(2) + '%');
            renderArrayInContainer(intradayValues, 'intradayArray');
            
            // Highlight the intraday value
            const intradayElements = intradayContainer.querySelectorAll('.array-element');
            const intradayElement = intradayElements[i].querySelector('.element-value');
            
            if (intradayGain > 1) {
                intradayElement.classList.add('intraday-gain', 'momentum-positive');
                intradayElement.innerHTML = `+${intradayGain.toFixed(2)}% `;
            } else if (intradayGain > 0) {
                intradayElement.classList.add('intraday-gain');
                intradayElement.innerHTML = `+${intradayGain.toFixed(2)}% `;
            } else if (intradayGain < -1) {
                intradayElement.classList.add('intraday-loss', 'momentum-negative');
                intradayElement.innerHTML = `${intradayGain.toFixed(2)}% `;
            } else if (intradayGain < 0) {
                intradayElement.classList.add('intraday-loss');
                intradayElement.innerHTML = `${intradayGain.toFixed(2)}% `;
            } else {
                intradayElement.innerHTML = `${intradayGain.toFixed(2)}% `;
            }
            
            // Update statistics
            profitableDays.textContent = profitDays;
            losingDays.textContent = lossDays;
            if (intradayGain > bestGain) {
                bestDay.textContent = '+' + intradayGain.toFixed(2) + '%';
            }
            
            step++;
            executeIntradayStep(i + 1);
        }, 3000);
    }
    
    executeIntradayStep(0);
}
// NEW: Perform Simple Moving Average (SMA) Calculation
function performSMACalculation() {
    if (originalStockPrices.length < 3) {
        showNotification('Need at least 3 prices for SMA calculation', 'warning');
        return;
    }

    const period = 3; // Default period for SMA

    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3"> Simple Moving Average (SMA) - ${period} Period</h5>
        
        <div class="period-selector">
            <div class="period-label">Calculation Period: ${period} days</div>
            <small>SMA smoothes price data by creating a constantly updated average price</small>
        </div>
        
        <div class="array-group">
            <div class="array-label">Stock Prices</div>
            <div class="original-array-container" id="originalPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">SMA Values (${period}-period)</div>
            <div class="transformed-array-container" id="smaArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> sma[i] = average(price[i-${period-1} : i+1])</p>
            <p class="mb-2"><strong>Business Insight:</strong> Identifies trend direction and smooths out price fluctuations</p>
            <p class="mb-0" id="smaExplanation">Starting SMA calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="smaStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="smaSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Current Trend Direction</div>
            <div class="stats-value" id="trendDirection">Calculating...</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSMA" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalStockPrices.map(p => p.toString()), 'originalPricesArray');
    renderArrayInContainer([], 'smaArray');
    
    executeSMAAnimation(period);
}

// NEW: Execute SMA Animation
function executeSMAAnimation(period) {
    const originalContainer = document.getElementById('originalPricesArray');
    const smaContainer = document.getElementById('smaArray');
    const explanation = document.getElementById('smaExplanation');
    const stepsContainer = document.getElementById('smaSteps');
    const continueButton = document.getElementById('continueAfterSMA');
    const trendDirection = document.getElementById('trendDirection');
    
    const prices = [...originalStockPrices];
    const smaValues = [];
    let step = 0;
    
    function executeSMAStep(i) {
        if (i >= prices.length) {
            // Determine overall trend
            const lastSMA = smaValues[smaValues.length - 1];
            const firstSMA = smaValues[period - 1];
            const overallTrend = lastSMA > firstSMA ? 'UPTREND ' : lastSMA < firstSMA ? 'DOWNTREND ' : 'SIDEWAYS ';
            
            explanation.innerHTML = `<strong>SMA Calculation Completed!</strong><br>
                                    Overall Trend: ${overallTrend}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>TREND ANALYSIS:</strong><br>
                     First SMA (Period ${period}): ${firstSMA.toFixed(2)}<br>
                     Last SMA: ${lastSMA.toFixed(2)}<br>
                     Trend Direction: ${overallTrend}<br>
                     Signal: ${lastSMA > firstSMA ? 'BULLISH' : lastSMA < firstSMA ? 'BEARISH' : 'NEUTRAL'}
                </div>
            `;
            
            trendDirection.textContent = overallTrend;
            trendDirection.className = `stats-value ${lastSMA > firstSMA ? 'text-success' : lastSMA < firstSMA ? 'text-danger' : 'text-warning'}`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToStockPrices();
            }, 10000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            return;
        }
        
        if (i < period - 1) {
            explanation.innerHTML = `Step ${step + 1}: Insufficient data for SMA (need ${period} prices, have ${i + 1})`;
            smaValues.push('N/A');
            renderArrayInContainer(smaValues, 'smaArray');
            
            stepsContainer.innerHTML += `
                <div class="calculation-step">
                    <strong>Step ${step + 1}:</strong> Position ${i} - Not enough data<br>
                    <small>Need ${period} prices, currently have ${i + 1} prices</small>
                </div>
            `;
            
            step++;
            setTimeout(() => executeSMAStep(i + 1), 1500);
            return;
        }
        
        // Calculate SMA for current position
        const periodPrices = prices.slice(i - period + 1, i + 1);
        const sum = periodPrices.reduce((a, b) => a + b, 0);
        const sma = sum / period;
        
        explanation.innerHTML = `Step ${step + 1}: Calculating SMA for position ${i}<br>
                                Prices: [${periodPrices.join(', ')}]<br>
                                Sum: ${sum.toFixed(2)} / ${period} = ${sma.toFixed(2)}`;
        
        // Highlight the prices being used
        const originalElements = originalContainer.querySelectorAll('.array-element');
        for (let j = i - period + 1; j <= i; j++) {
            originalElements[j].querySelector('.element-value').classList.add('sorting-compared');
        }
        originalElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="calculation-step active">
                <strong>Step ${step + 1}:</strong> SMA[${i}] = average(${periodPrices.join(' + ')}) / ${period}<br>
                <strong>Calculation:</strong> ${sum.toFixed(2)} / ${period} = ${sma.toFixed(2)}<br>
                <small>Using prices from position ${i - period + 1} to ${i}</small>
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            for (let j = i - period + 1; j <= i; j++) {
                originalElements[j].querySelector('.element-value').classList.remove('sorting-compared');
            }
            originalElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            // Add the calculated SMA
            smaValues.push(sma);
            renderArrayInContainer(smaValues.map(v => typeof v === 'number' ? v.toFixed(2) : v), 'smaArray');
            
            // Highlight the SMA value
            const smaElements = smaContainer.querySelectorAll('.array-element');
            if (i >= period - 1) {
                const smaElement = smaElements[i].querySelector('.element-value');
                smaElement.classList.add('technical-indicator', 'moving-average');
                
                // Add trend indication
                if (i > period - 1) {
                    const prevSMA = smaValues[i - 1];
                    if (sma > prevSMA) {
                        smaElement.classList.add('trend-up');
                        smaElement.innerHTML = `${sma.toFixed(2)} `;
                    } else if (sma < prevSMA) {
                        smaElement.classList.add('trend-down');
                        smaElement.innerHTML = `${sma.toFixed(2)} `;
                    } else {
                        smaElement.innerHTML = `${sma.toFixed(2)} `;
                    }
                } else {
                    smaElement.innerHTML = `${sma.toFixed(2)} `;
                }
            }
            
            step++;
            executeSMAStep(i + 1);
        }, 3000);
    }
    
    executeSMAStep(0);
}

// NEW: Perform Exponential Moving Average (EMA) Calculation
function performEMACalculation() {
    if (originalStockPrices.length < 3) {
        showNotification('Need at least 3 prices for EMA calculation', 'warning');
        return;
    }

    const period = 3; // Default period for EMA
    const smoothing = 2 / (period + 1);

    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3"> Exponential Moving Average (EMA) - ${period} Period</h5>
        
        <div class="period-selector">
            <div class="period-label">Calculation Period: ${period} days | Smoothing: ${smoothing.toFixed(4)}</div>
            <small>EMA gives more weight to recent prices, reacts faster to price changes</small>
        </div>
        
        <div class="array-group">
            <div class="array-label">Stock Prices</div>
            <div class="original-array-container" id="originalPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">EMA Values (${period}-period)</div>
            <div class="transformed-array-container" id="emaArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> ema[i] = (price[i]  ${smoothing.toFixed(4)}) + (ema[i-1]  ${(1-smoothing).toFixed(4)})</p>
            <p class="mb-2"><strong>Business Insight:</strong> More responsive to recent price action than SMA, better for short-term trading</p>
            <p class="mb-0" id="emaExplanation">Starting EMA calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="emaStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="emaSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>EMA Sensitivity</div>
            <div class="stats-value" id="emaSensitivity">HIGH </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterEMA" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalStockPrices.map(p => p.toString()), 'originalPricesArray');
    renderArrayInContainer([], 'emaArray');
    
    executeEMAAnimation(period, smoothing);
}

// NEW: Execute EMA Animation
function executeEMAAnimation(period, smoothing) {
    const originalContainer = document.getElementById('originalPricesArray');
    const emaContainer = document.getElementById('emaArray');
    const explanation = document.getElementById('emaExplanation');
    const stepsContainer = document.getElementById('emaSteps');
    const continueButton = document.getElementById('continueAfterEMA');
    const emaSensitivity = document.getElementById('emaSensitivity');
    
    const prices = [...originalStockPrices];
    const emaValues = [];
    let step = 0;
    
    function executeEMAStep(i) {
        if (i >= prices.length) {
            explanation.innerHTML = `<strong>EMA Calculation Completed!</strong><br>
                                    EMA gives more weight to recent price movements`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>EMA CHARACTERISTICS:</strong><br>
                     Period: ${period} days<br>
                     Smoothing Factor: ${smoothing.toFixed(4)}<br>
                     Recent Price Weight: ${(smoothing * 100).toFixed(1)}%<br>
                     Previous EMA Weight: ${((1-smoothing) * 100).toFixed(1)}%<br>
                     Use Case: Short-term trading signals
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToStockPrices();
            }, 10000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            return;
        }
        
        if (i < period - 1) {
            explanation.innerHTML = `Step ${step + 1}: Using SMA as initial EMA value (need ${period} prices)`;
            
            // For first EMA, use SMA
            const periodPrices = prices.slice(0, i + 1);
            if (periodPrices.length === period) {
                const sum = periodPrices.reduce((a, b) => a + b, 0);
                const initialEMA = sum / period;
                emaValues.push(initialEMA);
                
                stepsContainer.innerHTML += `
                    <div class="calculation-step active">
                        <strong>Step ${step + 1}:</strong> Initial EMA = SMA of first ${period} prices<br>
                        <strong>Calculation:</strong> (${periodPrices.join(' + ')}) / ${period} = ${initialEMA.toFixed(2)}<br>
                        <small>Using SMA as starting point for EMA calculation</small>
                    </div>
                `;
            } else {
                emaValues.push('N/A');
                stepsContainer.innerHTML += `
                    <div class="calculation-step">
                        <strong>Step ${step + 1}:</strong> Position ${i} - Building initial dataset<br>
                        <small>Need ${period} prices for initial EMA, currently have ${i + 1}</small>
                    </div>
                `;
            }
            
            renderArrayInContainer(emaValues.map(v => typeof v === 'number' ? v.toFixed(2) : v), 'emaArray');
            step++;
            setTimeout(() => executeEMAStep(i + 1), 2000);
            return;
        }
        
        let ema;
        if (i === period - 1) {
            // First EMA value (SMA)
            const periodPrices = prices.slice(0, i + 1);
            const sum = periodPrices.reduce((a, b) => a + b, 0);
            ema = sum / period;
            
            explanation.innerHTML = `Step ${step + 1}: Initial EMA = SMA of first ${period} prices<br>
                                    (${periodPrices.join(' + ')}) / ${period} = ${ema.toFixed(2)}`;
        } else {
            // Subsequent EMA values
            const currentPrice = prices[i];
            const previousEMA = emaValues[i - 1];
            ema = (currentPrice * smoothing) + (previousEMA * (1 - smoothing));
            
            explanation.innerHTML = `Step ${step + 1}: Calculating EMA for position ${i}<br>
                                    Formula: (${currentPrice}  ${smoothing.toFixed(4)}) + (${previousEMA.toFixed(2)}  ${(1-smoothing).toFixed(4)})<br>
                                    = ${ema.toFixed(2)}`;
        }
        
        // Highlight current price
        const originalElements = originalContainer.querySelectorAll('.array-element');
        originalElements[i].querySelector('.element-value').classList.add('sorting-current');
        if (i > period - 1) {
            originalElements[i - 1].querySelector('.element-value').classList.add('sorting-compared');
        }
        
        stepsContainer.innerHTML += `
            <div class="calculation-step active">
                <strong>Step ${step + 1}:</strong> ${i === period - 1 ? 'Initial EMA (SMA)' : 'EMA'}[${i}]<br>
                ${i === period - 1 ? 
                    `Initial EMA = (${prices.slice(0, i+1).join(' + ')}) / ${period} = ${ema.toFixed(2)}` :
                    `EMA = (${prices[i]}  ${smoothing.toFixed(4)}) + (${emaValues[i-1].toFixed(2)}  ${(1-smoothing).toFixed(4)}) = ${ema.toFixed(2)}`
                }<br>
                <small>${i === period - 1 ? 'Using SMA as starting point' : 'Weighted average favoring recent prices'}</small>
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            originalElements[i].querySelector('.element-value').classList.remove('sorting-current');
            if (i > period - 1) {
                originalElements[i - 1].querySelector('.element-value').classList.remove('sorting-compared');
            }
            
            // Add the calculated EMA
            emaValues.push(ema);
            renderArrayInContainer(emaValues.map(v => typeof v === 'number' ? v.toFixed(2) : v), 'emaArray');
            
            // Highlight the EMA value
            const emaElements = emaContainer.querySelectorAll('.array-element');
            if (i >= period - 1) {
                const emaElement = emaElements[i].querySelector('.element-value');
                emaElement.classList.add('technical-indicator', 'moving-average');
                
                // Add momentum indication
                if (i > period - 1) {
                    const prevEMA = emaValues[i - 1];
                    if (ema > prevEMA) {
                        emaElement.classList.add('trend-up');
                        emaElement.innerHTML = `${ema.toFixed(2)} `;
                    } else if (ema < prevEMA) {
                        emaElement.classList.add('trend-down');
                        emaElement.innerHTML = `${ema.toFixed(2)} `;
                    } else {
                        emaElement.innerHTML = `${ema.toFixed(2)} `;
                    }
                } else {
                    emaElement.innerHTML = `${ema.toFixed(2)} `;
                }
            }
            
            step++;
            executeEMAStep(i + 1);
        }, 3000);
    }
    
    executeEMAStep(0);
}

// NEW: Perform MACD Calculation
function performMACDCalculation() {
    if (originalStockPrices.length < 26) {
        showNotification('Need at least 26 prices for MACD calculation', 'warning');
        return;
    }

    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3"> MACD (Moving Average Convergence Divergence)</h5>
        
        <div class="period-selector">
            <div class="period-label">MACD = EMA(12) - EMA(26) | Trend Momentum Indicator</div>
            <small>Measures the relationship between two EMAs to identify momentum changes</small>
        </div>
        
        <div class="array-group">
            <div class="array-label">Stock Prices</div>
            <div class="original-array-container" id="originalPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">MACD Values (12-26 EMA Difference)</div>
            <div class="transformed-array-container" id="macdArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> MACD = EMA(12 periods) - EMA(26 periods)</p>
            <p class="mb-2"><strong>Business Insight:</strong> Positive MACD = bullish momentum, Negative MACD = bearish momentum</p>
            <p class="mb-0" id="macdExplanation">Starting MACD calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="macdStepsContainer">
            <h6 class="text-center">MACD Calculation Steps</h6>
            <div class="steps-container" id="macdSteps"></div>
        </div>
        
        <div class="row mt-3">
            <div class="col-md-6">
                <div class="stats-card">
                    <div>Current MACD</div>
                    <div class="stats-value" id="currentMACD">-</div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="stats-card">
                    <div>Momentum</div>
                    <div class="stats-value" id="macdMomentum">-</div>
                </div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMACD" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalStockPrices.map(p => p.toString()), 'originalPricesArray');
    renderArrayInContainer([], 'macdArray');
    
    executeMACDAnimation();
}

// NEW: Execute MACD Animation
function executeMACDAnimation() {
    const originalContainer = document.getElementById('originalPricesArray');
    const macdContainer = document.getElementById('macdArray');
    const explanation = document.getElementById('macdExplanation');
    const stepsContainer = document.getElementById('macdSteps');
    const continueButton = document.getElementById('continueAfterMACD');
    const currentMACD = document.getElementById('currentMACD');
    const macdMomentum = document.getElementById('macdMomentum');
    
    const prices = [...originalStockPrices];
    const macdValues = [];
    let step = 0;
    
    // Calculate EMAs for MACD
    function calculateEMA(prices, period) {
        const smoothing = 2 / (period + 1);
        const emaValues = [];
        
        for (let i = 0; i < prices.length; i++) {
            if (i < period - 1) {
                emaValues.push(null);
            } else if (i === period - 1) {
                const periodPrices = prices.slice(0, i + 1);
                const sum = periodPrices.reduce((a, b) => a + b, 0);
                emaValues.push(sum / period);
            } else {
                const ema = (prices[i] * smoothing) + (emaValues[i - 1] * (1 - smoothing));
                emaValues.push(ema);
            }
        }
        return emaValues;
    }
    
    const ema12 = calculateEMA(prices, 12);
    const ema26 = calculateEMA(prices, 26);
    
    function executeMACDStep(i) {
        if (i >= prices.length) {
            const lastMACD = macdValues[macdValues.length - 1];
            const signal = lastMACD > 0 ? 'BULLISH ' : lastMACD < 0 ? 'BEARISH ' : 'NEUTRAL ';
            
            explanation.innerHTML = `<strong>MACD Calculation Completed!</strong><br>
                                    Final MACD: ${lastMACD.toFixed(4)} | Signal: ${signal}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>MACD INTERPRETATION:</strong><br>
                     MACD > 0: Bullish momentum (EMA12 > EMA26)<br>
                     MACD < 0: Bearish momentum (EMA12 < EMA26)<br>
                     Rising MACD: Increasing bullish momentum<br>
                     Falling MACD: Decreasing bullish momentum<br>
                     Current Signal: ${signal}
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToStockPrices();
            }, 10000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            return;
        }
        
        if (i < 25) {
            explanation.innerHTML = `Step ${step + 1}: Building EMA datasets (need 26 prices for MACD)`;
            macdValues.push('N/A');
            renderArrayInContainer(macdValues, 'macdArray');
            
            stepsContainer.innerHTML += `
                <div class="calculation-step">
                    <strong>Step ${step + 1}:</strong> Position ${i} - Insufficient data<br>
                    <small>Need 26 prices for MACD calculation, currently have ${i + 1}</small>
                </div>
            `;
            
            step++;
            setTimeout(() => executeMACDStep(i + 1), 1500);
            return;
        }
        
        const macd = ema12[i] - ema26[i];
        
        explanation.innerHTML = `Step ${step + 1}: Calculating MACD for position ${i}<br>
                                MACD = EMA(12): ${ema12[i].toFixed(2)} - EMA(26): ${ema26[i].toFixed(2)}<br>
                                = ${macd.toFixed(4)}`;
        
        // Highlight relevant prices
        const originalElements = originalContainer.querySelectorAll('.array-element');
        originalElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="calculation-step active">
                <strong>Step ${step + 1}:</strong> MACD[${i}] = EMA12[${i}] - EMA26[${i}]<br>
                <strong>Calculation:</strong> ${ema12[i].toFixed(2)} - ${ema26[i].toFixed(2)} = ${macd.toFixed(4)}<br>
                <small>${macd > 0 ? 'Bullish (EMA12 > EMA26)' : macd < 0 ? 'Bearish (EMA12 < EMA26)' : 'Neutral (EMA12 = EMA26)'}</small>
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            originalElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            // Add the calculated MACD
            macdValues.push(macd);
            renderArrayInContainer(macdValues.map(v => typeof v === 'number' ? v.toFixed(4) : v), 'macdArray');
            
            // Highlight the MACD value
            const macdElements = macdContainer.querySelectorAll('.array-element');
            if (i >= 25) {
                const macdElement = macdElements[i].querySelector('.element-value');
                macdElement.classList.add('technical-indicator', 'macd-line');
                
                if (macd > 0) {
                    macdElement.classList.add('trend-up');
                    macdElement.innerHTML = `+${macd.toFixed(4)} `;
                } else if (macd < 0) {
                    macdElement.classList.add('trend-down');
                    macdElement.innerHTML = `${macd.toFixed(4)} `;
                } else {
                    macdElement.innerHTML = `${macd.toFixed(4)} `;
                }
            }
            
            // Update current values
            if (i === prices.length - 1) {
                currentMACD.textContent = macd.toFixed(4);
                currentMACD.className = `stats-value ${macd > 0 ? 'text-success' : macd < 0 ? 'text-danger' : 'text-warning'}`;
                
                const momentumText = macd > 0 ? 'BULLISH ' : macd < 0 ? 'BEARISH ' : 'NEUTRAL ';
                macdMomentum.textContent = momentumText;
                macdMomentum.className = `stats-value ${macd > 0 ? 'text-success' : macd < 0 ? 'text-danger' : 'text-warning'}`;
            }
            
            step++;
            executeMACDStep(i + 1);
        }, 3000);
    }
    
    executeMACDStep(0);
}

// NEW: Perform MACD Signal Line Calculation
function performMACDSignalCalculation() {
    if (originalStockPrices.length < 35) {
        showNotification('Need at least 35 prices for MACD Signal calculation', 'warning');
        return;
    }

    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3"> MACD Signal Line (9-period EMA of MACD)</h5>
        
        <div class="period-selector">
            <div class="period-label">Signal Line = EMA(MACD, 9 periods) | Trigger for buy/sell signals</div>
            <small>Smoothed version of MACD used to generate trading signals when MACD crosses it</small>
        </div>
        
        <div class="array-group">
            <div class="array-label">MACD Values</div>
            <div class="original-array-container" id="macdValuesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Signal Line Values (9-period EMA)</div>
            <div class="transformed-array-container" id="signalArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> Signal Line = EMA(MACD, 9 periods)</p>
            <p class="mb-2"><strong>Trading Signal:</strong> MACD above Signal = Buy, MACD below Signal = Sell</p>
            <p class="mb-0" id="signalExplanation">Starting Signal Line calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="signalStepsContainer">
            <h6 class="text-center">Signal Line Calculation Steps</h6>
            <div class="steps-container" id="signalSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Current Trading Signal</div>
            <div class="stats-value" id="tradingSignal">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSignal" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // First calculate MACD values
    const macdValues = calculateMACDValues(originalStockPrices);
    renderArrayInContainer(macdValues.map(v => typeof v === 'number' ? v.toFixed(4) : v), 'macdValuesArray');
    renderArrayInContainer([], 'signalArray');
    
    executeMACDSignalAnimation(macdValues);
}

// NEW: Calculate MACD Values
function calculateMACDValues(prices) {
    function calculateEMA(prices, period) {
        const smoothing = 2 / (period + 1);
        const emaValues = [];
        
        for (let i = 0; i < prices.length; i++) {
            if (i < period - 1) {
                emaValues.push(null);
            } else if (i === period - 1) {
                const periodPrices = prices.slice(0, i + 1);
                const sum = periodPrices.reduce((a, b) => a + b, 0);
                emaValues.push(sum / period);
            } else {
                const ema = (prices[i] * smoothing) + (emaValues[i - 1] * (1 - smoothing));
                emaValues.push(ema);
            }
        }
        return emaValues;
    }
    
    const ema12 = calculateEMA(prices, 12);
    const ema26 = calculateEMA(prices, 26);
    const macdValues = [];
    
    for (let i = 0; i < prices.length; i++) {
        if (ema12[i] === null || ema26[i] === null) {
            macdValues.push(null);
        } else {
            macdValues.push(ema12[i] - ema26[i]);
        }
    }
    
    return macdValues;
}

// NEW: Execute MACD Signal Animation
function executeMACDSignalAnimation(macdValues) {
    const macdContainer = document.getElementById('macdValuesArray');
    const signalContainer = document.getElementById('signalArray');
    const explanation = document.getElementById('signalExplanation');
    const stepsContainer = document.getElementById('signalSteps');
    const continueButton = document.getElementById('continueAfterSignal');
    const tradingSignal = document.getElementById('tradingSignal');
    
    const signalValues = [];
    let step = 0;
    
    function executeSignalStep(i) {
        if (i >= macdValues.length) {
            const lastMACD = macdValues[macdValues.length - 1];
            const lastSignal = signalValues[signalValues.length - 1];
            const signal = lastMACD > lastSignal ? 'BUY SIGNAL ' : lastMACD < lastSignal ? 'SELL SIGNAL ' : 'NO SIGNAL ';
            
            explanation.innerHTML = `<strong>Signal Line Calculation Completed!</strong><br>
                                    ${signal} | MACD: ${lastMACD.toFixed(4)} vs Signal: ${lastSignal.toFixed(4)}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>TRADING SIGNALS:</strong><br>
                     MACD > Signal Line: BUY Signal (Bullish)<br>
                     MACD < Signal Line: SELL Signal (Bearish)<br>
                     MACD crosses above: Potential uptrend start<br>
                     MACD crosses below: Potential downtrend start<br>
                     Current: ${signal}
                </div>
            `;
            
            tradingSignal.textContent = signal;
            tradingSignal.className = `stats-value ${lastMACD > lastSignal ? 'text-success' : lastMACD < lastSignal ? 'text-danger' : 'text-warning'}`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToStockPrices();
            }, 10000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            return;
        }
        
        if (i < 33) { // 26 for MACD + 8 for signal EMA = 34, but we start from 0
            explanation.innerHTML = `Step ${step + 1}: Building MACD dataset for signal calculation`;
            signalValues.push('N/A');
            renderArrayInContainer(signalValues, 'signalArray');
            
            stepsContainer.innerHTML += `
                <div class="calculation-step">
                    <strong>Step ${step + 1}:</strong> Position ${i} - Preparing data<br>
                    <small>Need sufficient MACD values for signal calculation</small>
                </div>
            `;
            
            step++;
            setTimeout(() => executeSignalStep(i + 1), 1500);
            return;
        }
        
        // Calculate signal line (EMA of MACD with period 9)
        const signalPeriod = 9;
        const smoothing = 2 / (signalPeriod + 1);
        let signal;
        
        if (i === 33) {
            // First signal value (SMA of first 9 MACD values)
            const periodMACD = macdValues.slice(25, 34); // MACD starts at index 25
            const sum = periodMACD.reduce((a, b) => a + b, 0);
            signal = sum / signalPeriod;
            
            explanation.innerHTML = `Step ${step + 1}: Initial Signal Line = SMA of first 9 MACD values<br>
                                    Average of [${periodMACD.map(v => v.toFixed(4)).join(', ')}] = ${signal.toFixed(4)}`;
        } else {
            // Subsequent signal values (EMA)
            signal = (macdValues[i] * smoothing) + (signalValues[i - 1] * (1 - smoothing));
            
            explanation.innerHTML = `Step ${step + 1}: Calculating Signal Line for position ${i}<br>
                                    Formula: (MACD: ${macdValues[i].toFixed(4)}  ${smoothing.toFixed(4)}) + (Prev Signal: ${signalValues[i-1].toFixed(4)}  ${(1-smoothing).toFixed(4)})<br>
                                    = ${signal.toFixed(4)}`;
        }
        
        // Highlight current MACD value
        const macdElements = macdContainer.querySelectorAll('.array-element');
        macdElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="calculation-step active">
                <strong>Step ${step + 1}:</strong> ${i === 33 ? 'Initial Signal' : 'Signal'}[${i}]<br>
                ${i === 33 ? 
                    `Initial = SMA of MACD[25:33] = ${signal.toFixed(4)}` :
                    `Signal = (${macdValues[i].toFixed(4)}  ${smoothing.toFixed(4)}) + (${signalValues[i-1].toFixed(4)}  ${(1-smoothing).toFixed(4)}) = ${signal.toFixed(4)}`
                }<br>
                <small>${macdValues[i] > signal ? 'MACD above Signal (Bullish)' : macdValues[i] < signal ? 'MACD below Signal (Bearish)' : 'MACD = Signal (Neutral)'}</small>
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            macdElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            // Add the calculated signal
            signalValues.push(signal);
            renderArrayInContainer(signalValues.map(v => typeof v === 'number' ? v.toFixed(4) : v), 'signalArray');
            
            // Highlight the signal value
            const signalElements = signalContainer.querySelectorAll('.array-element');
            if (i >= 33) {
                const signalElement = signalElements[i].querySelector('.element-value');
                signalElement.classList.add('technical-indicator', 'macd-signal');
                
                // Compare with MACD
                if (macdValues[i] > signal) {
                    signalElement.classList.add('trend-up');
                    signalElement.innerHTML = `${signal.toFixed(4)} `;
                } else if (macdValues[i] < signal) {
                    signalElement.classList.add('trend-down');
                    signalElement.innerHTML = `${signal.toFixed(4)} `;
                } else {
                    signalElement.innerHTML = `${signal.toFixed(4)} `;
                }
            }
            
            step++;
            executeSignalStep(i + 1);
        }, 3000);
    }
    
    executeSignalStep(0);
}

// NEW: Perform Bollinger Middle Band Calculation
function performBollingerMiddleCalculation() {
    if (originalStockPrices.length < 20) {
        showNotification('Need at least 20 prices for Bollinger Bands calculation', 'warning');
        return;
    }

    const period = 20; // Standard period for Bollinger Bands

    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3"> Bollinger Middle Band (${period}-period SMA)</h5>
        
        <div class="period-selector">
            <div class="period-label">Middle Band = ${period}-period Simple Moving Average</div>
            <small>Base line for Bollinger Bands, represents the intermediate-term trend</small>
        </div>
        
        <div class="array-group">
            <div class="array-label">Stock Prices</div>
            <div class="original-array-container" id="originalPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Middle Band Values (SMA${period})</div>
            <div class="transformed-array-container" id="middleBandArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> Middle Band = SMA(${period} periods)</p>
            <p class="mb-2"><strong>Trading Insight:</strong> Prices above middle band = bullish, below = bearish</p>
            <p class="mb-0" id="middleBandExplanation">Starting Middle Band calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="middleBandStepsContainer">
            <h6 class="text-center">Middle Band Calculation Steps</h6>
            <div class="steps-container" id="middleBandSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Trend Relative to Middle Band</div>
            <div class="stats-value" id="bandPosition">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMiddleBand" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalStockPrices.map(p => p.toString()), 'originalPricesArray');
    renderArrayInContainer([], 'middleBandArray');
    
    executeBollingerMiddleAnimation(period);
}

// NEW: Execute Bollinger Middle Band Animation
function executeBollingerMiddleAnimation(period) {
    const originalContainer = document.getElementById('originalPricesArray');
    const middleBandContainer = document.getElementById('middleBandArray');
    const explanation = document.getElementById('middleBandExplanation');
    const stepsContainer = document.getElementById('middleBandSteps');
    const continueButton = document.getElementById('continueAfterMiddleBand');
    const bandPosition = document.getElementById('bandPosition');
    
    const prices = [...originalStockPrices];
    const middleBandValues = [];
    let step = 0;
    
    function executeMiddleBandStep(i) {
        if (i >= prices.length) {
            const lastPrice = prices[prices.length - 1];
            const lastMiddleBand = middleBandValues[middleBandValues.length - 1];
            const position = lastPrice > lastMiddleBand ? 'ABOVE BAND ' : lastPrice < lastMiddleBand ? 'BELOW BAND ' : 'ON BAND ';
            
            explanation.innerHTML = `<strong>Middle Band Calculation Completed!</strong><br>
                                    Current Price: ${lastPrice} vs Middle Band: ${lastMiddleBand.toFixed(2)}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>BOLLINGER BANDS INTERPRETATION:</strong><br>
                     Price > Middle Band: Bullish territory<br>
                     Price < Middle Band: Bearish territory  <br>
                     Price touches upper band: Overbought possible<br>
                     Price touches lower band: Oversold possible<br>
                     Current: ${position}
                </div>
            `;
            
            bandPosition.textContent = position;
            bandPosition.className = `stats-value ${lastPrice > lastMiddleBand ? 'text-success' : lastPrice < lastMiddleBand ? 'text-danger' : 'text-warning'}`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToStockPrices();
            }, 10000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            return;
        }
        
        if (i < period - 1) {
            explanation.innerHTML = `Step ${step + 1}: Building dataset for ${period}-period SMA`;
            middleBandValues.push('N/A');
            renderArrayInContainer(middleBandValues, 'middleBandArray');
            
            stepsContainer.innerHTML += `
                <div class="calculation-step">
                    <strong>Step ${step + 1}:</strong> Position ${i} - Gathering data<br>
                    <small>Need ${period} prices for SMA calculation, currently have ${i + 1}</small>
                </div>
            `;
            
            step++;
            setTimeout(() => executeMiddleBandStep(i + 1), 1500);
            return;
        }
        
        // Calculate SMA for current position
        const periodPrices = prices.slice(i - period + 1, i + 1);
        const sum = periodPrices.reduce((a, b) => a + b, 0);
        const sma = sum / period;
        
        explanation.innerHTML = `Step ${step + 1}: Calculating Middle Band for position ${i}<br>
                                SMA = (${periodPrices.join(' + ')}) / ${period}<br>
                                = ${sma.toFixed(2)}`;
        
        // Highlight the prices being used
        const originalElements = originalContainer.querySelectorAll('.array-element');
        for (let j = i - period + 1; j <= i; j++) {
            originalElements[j].querySelector('.element-value').classList.add('sorting-compared');
        }
        originalElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="calculation-step active">
                <strong>Step ${step + 1}:</strong> MiddleBand[${i}] = SMA(${period})<br>
                <strong>Calculation:</strong> (${periodPrices.join(' + ')}) / ${period} = ${sma.toFixed(2)}<br>
                <small>Using prices ${i - period + 1} to ${i}</small>
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            for (let j = i - period + 1; j <= i; j++) {
                originalElements[j].querySelector('.element-value').classList.remove('sorting-compared');
            }
            originalElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            // Add the calculated middle band
            middleBandValues.push(sma);
            renderArrayInContainer(middleBandValues.map(v => typeof v === 'number' ? v.toFixed(2) : v), 'middleBandArray');
            
            // Highlight the middle band value
            const middleBandElements = middleBandContainer.querySelectorAll('.array-element');
            if (i >= period - 1) {
                const middleBandElement = middleBandElements[i].querySelector('.element-value');
                middleBandElement.classList.add('technical-indicator', 'bollinger-band');
                
                // Compare with current price
                if (prices[i] > sma) {
                    middleBandElement.classList.add('trend-up');
                    middleBandElement.innerHTML = `${sma.toFixed(2)} `;
                } else if (prices[i] < sma) {
                    middleBandElement.classList.add('trend-down');
                    middleBandElement.innerHTML = `${sma.toFixed(2)} `;
                } else {
                    middleBandElement.innerHTML = `${sma.toFixed(2)} `;
                }
            }
            
            step++;
            executeMiddleBandStep(i + 1);
        }, 3000);
    }
    
    executeMiddleBandStep(0);
}

// NEW: Perform Bollinger Upper Band Calculation
function performBollingerUpperCalculation() {
    if (originalStockPrices.length < 20) {
        showNotification('Need at least 20 prices for Bollinger Bands calculation', 'warning');
        return;
    }

    const period = 20; // Standard period for Bollinger Bands
    const stdDevMultiplier = 2; // Standard deviation multiplier

    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3"> Bollinger Upper Band (SMA + 2StdDev)</h5>
        
        <div class="period-selector">
            <div class="period-label">Upper Band = Middle Band + (${stdDevMultiplier}  Standard Deviation)</div>
            <small>Represents overbought territory, often acts as resistance level</small>
        </div>
        
        <div class="array-group">
            <div class="array-label">Stock Prices & Middle Band</div>
            <div class="original-array-container" id="pricesAndMiddleArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Upper Band Values</div>
            <div class="transformed-array-container" id="upperBandArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> Upper Band = Middle Band + (${stdDevMultiplier}  StdDev)</p>
            <p class="mb-2"><strong>Trading Insight:</strong> Prices near upper band may be overbought, potential reversal area</p>
            <p class="mb-0" id="upperBandExplanation">Starting Upper Band calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="upperBandStepsContainer">
            <h6 class="text-center">Upper Band Calculation Steps</h6>
            <div class="steps-container" id="upperBandSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Current Volatility Level</div>
            <div class="stats-value" id="volatilityLevel">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterUpperBand" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Calculate middle band values first
    const middleBandValues = calculateMiddleBandValues(originalStockPrices, period);
    const displayValues = originalStockPrices.map((price, i) => 
        `${price} | MB: ${middleBandValues[i] !== null && typeof middleBandValues[i] === 'number' ? middleBandValues[i].toFixed(2) : 'N/A'}`
    );
    
    renderArrayInContainer(displayValues, 'pricesAndMiddleArray');
    renderArrayInContainer([], 'upperBandArray');
    
    executeBollingerUpperAnimation(period, stdDevMultiplier, middleBandValues);
}

// NEW: Calculate Middle Band Values
function calculateMiddleBandValues(prices, period) {
    const middleBandValues = [];
    
    for (let i = 0; i < prices.length; i++) {
        if (i < period - 1) {
            middleBandValues.push(null);
        } else {
            const periodPrices = prices.slice(i - period + 1, i + 1);
            const sum = periodPrices.reduce((a, b) => a + b, 0);
            middleBandValues.push(sum / period);
        }
    }
    
    return middleBandValues;
}

// NEW: Execute Bollinger Upper Band Animation
function executeBollingerUpperAnimation(period, stdDevMultiplier, middleBandValues) {
    const pricesAndMiddleContainer = document.getElementById('pricesAndMiddleArray');
    const upperBandContainer = document.getElementById('upperBandArray');
    const explanation = document.getElementById('upperBandExplanation');
    const stepsContainer = document.getElementById('upperBandSteps');
    const continueButton = document.getElementById('continueAfterUpperBand');
    const volatilityLevel = document.getElementById('volatilityLevel');
    
    const prices = [...originalStockPrices];
    const upperBandValues = [];
    let step = 0;
    
    function executeUpperBandStep(i) {
        if (i >= prices.length) {
            const lastPrice = prices[prices.length - 1];
            const lastUpperBand = upperBandValues[upperBandValues.length - 1];
            const proximity = ((lastPrice / lastUpperBand) * 100).toFixed(1);
            const volatility = lastUpperBand - middleBandValues[middleBandValues.length - 1];
            
            explanation.innerHTML = `<strong>Upper Band Calculation Completed!</strong><br>
                                    Price is at ${proximity}% of upper band | Band Width: ${volatility.toFixed(2)}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>UPPER BAND TRADING SIGNALS:</strong><br>
                     Price > Upper Band: Strong overbought (Caution)<br>
                     Price near Upper Band: Potential resistance<br>
                     Band Width expanding: Increasing volatility<br>
                     Band Width contracting: Decreasing volatility<br>
                     Current Band Width: ${volatility.toFixed(2)}
                </div>
            `;
            
            const volText = volatility > (prices[0] * 0.1) ? 'HIGH VOLATILITY ' : volatility > (prices[0] * 0.05) ? 'MEDIUM VOLATILITY ' : 'LOW VOLATILITY ';
            volatilityLevel.textContent = volText;
            volatilityLevel.className = `stats-value ${volatility > (prices[0] * 0.1) ? 'volatility-high' : volatility > (prices[0] * 0.05) ? 'text-warning' : 'text-info'}`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToStockPrices();
            }, 10000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            return;
        }
        
        if (i < period - 1) {
            explanation.innerHTML = `Step ${step + 1}: Building datasets for upper band calculation`;
            upperBandValues.push('N/A');
            renderArrayInContainer(upperBandValues, 'upperBandArray');
            
            stepsContainer.innerHTML += `
                <div class="calculation-step">
                    <strong>Step ${step + 1}:</strong> Position ${i} - Preparing data<br>
                    <small>Need ${period} prices for standard deviation calculation</small>
                </div>
            `;
            
            step++;
            setTimeout(() => executeUpperBandStep(i + 1), 1500);
            return;
        }
        
        // Calculate standard deviation
        const periodPrices = prices.slice(i - period + 1, i + 1);
        const mean = middleBandValues[i];
        const squaredDiffs = periodPrices.map(price => Math.pow(price - mean, 2));
        const variance = squaredDiffs.reduce((a, b) => a + b, 0) / period;
        const stdDev = Math.sqrt(variance);
        const upperBand = mean + (stdDev * stdDevMultiplier);
        
        explanation.innerHTML = `Step ${step + 1}: Calculating Upper Band for position ${i}<br>
                                StdDev = [(price - mean) / ${period}] = ${stdDev.toFixed(2)}<br>
                                Upper Band = ${mean.toFixed(2)} + (${stdDev.toFixed(2)}  ${stdDevMultiplier}) = ${upperBand.toFixed(2)}`;
        
        // Highlight relevant data
        const pricesAndMiddleElements = pricesAndMiddleContainer.querySelectorAll('.array-element');
        pricesAndMiddleElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="calculation-step active">
                <strong>Step ${step + 1}:</strong> UpperBand[${i}]<br>
                <strong>Standard Deviation:</strong> ${stdDev.toFixed(2)}<br>
                <strong>Calculation:</strong> ${mean.toFixed(2)} + (${stdDev.toFixed(2)}  ${stdDevMultiplier}) = ${upperBand.toFixed(2)}<br>
                <small>Volatility Measure: ${stdDev.toFixed(2)} (${((stdDev/mean)*100).toFixed(1)}% of mean)</small>
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            pricesAndMiddleElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            // Add the calculated upper band
            upperBandValues.push(upperBand);
            renderArrayInContainer(upperBandValues.map(v => typeof v === 'number' ? v.toFixed(2) : v), 'upperBandArray');
            
            // Highlight the upper band value
            const upperBandElements = upperBandContainer.querySelectorAll('.array-element');
            if (i >= period - 1) {
                const upperBandElement = upperBandElements[i].querySelector('.element-value');
                upperBandElement.classList.add('technical-indicator', 'bollinger-band', 'volatility-high');
                
                // Check if price is near upper band
                const priceProximity = (prices[i] / upperBand) * 100;
                if (priceProximity > 95) {
                    upperBandElement.classList.add('trend-up');
                    upperBandElement.innerHTML = `${upperBand.toFixed(2)} `;
                } else {
                    upperBandElement.innerHTML = `${upperBand.toFixed(2)} `;
                }
            }
            
            step++;
            executeUpperBandStep(i + 1);
        }, 3500);
    }
    
    executeUpperBandStep(0);
}
// NEW: Handle Axis Function Selection Change
function handleAxisFunctionChange() {
    const selectedFunction = axisFunctionSelect.value;
    
    // Show/hide custom function input
    if (selectedFunction === 'custom') {
        customFunctionGroup.style.display = 'block';
    } else {
        customFunctionGroup.style.display = 'none';
    }
    
    // Show matrix dimensions for all axis operations
    matrixDimensionsGroup.style.display = 'block';
}

// NEW: Create Matrix Handler
function handleCreateMatrix() {
    const rows = parseInt(matrixRowsInput.value);
    const cols = parseInt(matrixColsInput.value);
    
    if (isNaN(rows) || rows < 1 || rows > 10 || isNaN(cols) || cols < 1 || cols > 10) {
        showNotification('Please enter valid matrix dimensions (1-10 for rows and columns)', 'danger');
        return;
    }
    
    matrixRows = rows;
    matrixCols = cols;
    
    // Create a sample matrix with random values
    currentMatrix = [];
    for (let i = 0; i < rows; i++) {
        const row = [];
        for (let j = 0; j < cols; j++) {
            row.push(Math.floor(Math.random() * 100) + 1); // Random values 1-100
        }
        currentMatrix.push(row);
    }
    
    // Store original array
    originalArrayForAxis = [...myArray];
    
    // Show matrix visualization
    showMatrixVisualization(currentMatrix, 'Original Matrix');
    
    logOperation(`Created ${rows}x${cols} matrix for axis operations`, 'success');
    showNotification(`Created ${rows}x${cols} matrix successfully`, 'success');
}

// NEW: Apply Axis Operation Handler
function handleApplyAxis() {
    const selectedFunction = axisFunctionSelect.value;
    
    if (!selectedFunction) {
        showNotification('Please select an operation', 'warning');
        return;
    }
    
    if (currentMatrix.length === 0) {
        showNotification('Please create a matrix first', 'warning');
        return;
    }
    
    if (isAxisOperationRunning) {
        showNotification('An axis operation is already in progress', 'warning');
        return;
    }
    
    isAxisOperationRunning = true;
    
    // Perform the selected axis operation
    performAxisOperation(selectedFunction);
}

// NEW: Show Matrix Visualization
function showMatrixVisualization(matrix, title) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">${title}</h5>
        
        <div class="array-group">
            <div class="array-label">Matrix (${matrix.length}  ${matrix[0].length})</div>
            <div class="matrix-container" id="matrixDisplay"></div>
        </div>
        
        <div class="axis-operation-explanation">
            <p class="mb-2"><strong>apply_along_axis() Simulation:</strong> Applying function to 1D slices</p>
            <p class="mb-0" id="axisExplanation">Ready to perform axis operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="axisStepsContainer">
            <h6 class="text-center">Operation Steps</h6>
            <div class="steps-container" id="axisSteps"></div>
        </div>
        
        <div id="resultContainer" style="display: none;">
            <div class="array-group mt-3">
                <div class="array-label">Result</div>
                <div class="matrix-container" id="resultDisplay"></div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterAxis" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderMatrix(matrix, 'matrixDisplay');
}

// NEW: Render Matrix
function renderMatrix(matrix, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    container.style.gridTemplateColumns = `repeat(${matrix[0].length}, 1fr)`;
    
    matrix.forEach((row, i) => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'matrix-row';
        
        row.forEach((cell, j) => {
            const cellDiv = document.createElement('div');
            cellDiv.className = 'matrix-cell';
            cellDiv.textContent = cell;
            cellDiv.title = `[${i}][${j}] = ${cell}`;
            rowDiv.appendChild(cellDiv);
        });
        
        container.appendChild(rowDiv);
    });
}

// NEW: Perform Axis Operation - ENHANCED VERSION
function performAxisOperation(operation) {
    const explanation = document.getElementById('axisExplanation');
    const stepsContainer = document.getElementById('axisSteps');
    const resultContainer = document.getElementById('resultContainer');
    const continueButton = document.getElementById('continueAfterAxis');
    
    let operationName = '';
    let operationType = ''; // 'row' or 'col'
    
    // Define the operation functions with better error handling
    const operations = {
        rowSum: {
            name: 'Row-wise Sum',
            type: 'row',
            func: (arr) => {
                if (!arr.every(val => !isNaN(parseFloat(val)))) {
                    throw new Error('All elements must be numbers for sum operation');
                }
                return arr.reduce((a, b) => parseFloat(a) + parseFloat(b), 0);
            },
            description: 'Sum of all elements in each row'
        },
        colMean: {
            name: 'Column-wise Mean',
            type: 'col',
            func: (arr) => {
                if (!arr.every(val => !isNaN(parseFloat(val)))) {
                    throw new Error('All elements must be numbers for mean operation');
                }
                const sum = arr.reduce((a, b) => parseFloat(a) + parseFloat(b), 0);
                return sum / arr.length;
            },
            description: 'Average of all elements in each column'
        },
        rowStd: {
            name: 'Row-wise Standard Deviation',
            type: 'row',
            func: (arr) => {
                if (!arr.every(val => !isNaN(parseFloat(val)))) {
                    throw new Error('All elements must be numbers for standard deviation');
                }
                const floatArr = arr.map(val => parseFloat(val));
                const mean = floatArr.reduce((a, b) => a + b, 0) / floatArr.length;
                return Math.sqrt(floatArr.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / floatArr.length);
            },
            description: 'Standard deviation of elements in each row'
        },
        colMedian: {
            name: 'Column-wise Median',
            type: 'col',
            func: (arr) => {
                if (!arr.every(val => !isNaN(parseFloat(val)))) {
                    throw new Error('All elements must be numbers for median operation');
                }
                const sorted = arr.map(val => parseFloat(val)).sort((a, b) => a - b);
                const mid = Math.floor(sorted.length / 2);
                return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
            },
            description: 'Median value of elements in each column'
        },
        rowMax: {
            name: 'Row-wise Maximum',
            type: 'row',
            func: (arr) => {
                if (!arr.every(val => !isNaN(parseFloat(val)))) {
                    throw new Error('All elements must be numbers for max operation');
                }
                return Math.max(...arr.map(val => parseFloat(val)));
            },
            description: 'Maximum value in each row'
        },
        rowMin: {
            name: 'Row-wise Minimum',
            type: 'row',
            func: (arr) => {
                if (!arr.every(val => !isNaN(parseFloat(val)))) {
                    throw new Error('All elements must be numbers for min operation');
                }
                return Math.min(...arr.map(val => parseFloat(val)));
            },
            description: 'Minimum value in each row'
        },
        colVariance: {
            name: 'Column-wise Variance',
            type: 'col',
            func: (arr) => {
                if (!arr.every(val => !isNaN(parseFloat(val)))) {
                    throw new Error('All elements must be numbers for variance operation');
                }
                const floatArr = arr.map(val => parseFloat(val));
                const mean = floatArr.reduce((a, b) => a + b, 0) / floatArr.length;
                return floatArr.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / floatArr.length;
            },
            description: 'Variance of elements in each column'
        },
        rowRange: {
            name: 'Row-wise Range',
            type: 'row',
            func: (arr) => {
                if (!arr.every(val => !isNaN(parseFloat(val)))) {
                    throw new Error('All elements must be numbers for range operation');
                }
                const floatArr = arr.map(val => parseFloat(val));
                return Math.max(...floatArr) - Math.min(...floatArr);
            },
            description: 'Range (max-min) of elements in each row'
        },
        rowNormalize: {
            name: 'Row-wise Normalization',
            type: 'row',
            func: (arr) => {
                if (!arr.every(val => !isNaN(parseFloat(val)))) {
                    throw new Error('All elements must be numbers for normalization');
                }
                const floatArr = arr.map(val => parseFloat(val));
                const min = Math.min(...floatArr);
                const max = Math.max(...floatArr);
                if (min === max) return floatArr.map(() => 0); // Avoid division by zero
                return floatArr.map(val => (val - min) / (max - min));
            },
            description: 'Normalize each row to [0,1] range'
        },
        colZScore: {
            name: 'Column-wise Z-Score',
            type: 'col',
            func: (arr) => {
                if (!arr.every(val => !isNaN(parseFloat(val)))) {
                    throw new Error('All elements must be numbers for Z-score normalization');
                }
                const floatArr = arr.map(val => parseFloat(val));
                const mean = floatArr.reduce((a, b) => a + b, 0) / floatArr.length;
                const std = Math.sqrt(floatArr.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / floatArr.length);
                if (std === 0) return floatArr.map(() => 0); // Avoid division by zero
                return floatArr.map(val => (val - mean) / std);
            },
            description: 'Z-score normalization for each column'
        },
        custom: {
            name: 'Custom Function',
            type: 'row',
            func: null,
            description: 'Custom user-defined function'
        }
    };
    
    const opConfig = operations[operation];
    
    if (operation === 'custom') {
        try {
            const customFunc = new Function('arr', `
                try {
                    ${customFunction.value}
                } catch (error) {
                    throw new Error('Custom function error: ' + error.message);
                }
            `);
            opConfig.func = customFunc;
        } catch (error) {
            showNotification('Invalid custom function: ' + error.message, 'danger');
            isAxisOperationRunning = false;
            return;
        }
    }
    
    operationName = opConfig.name;
    operationType = opConfig.type;
    
    explanation.innerHTML = `<strong>${operationName}</strong><br>${opConfig.description}`;
    explanation.classList.add('highlight');
    
    // Clear previous results
    stepsContainer.innerHTML = '';
    resultContainer.style.display = 'none';
    continueButton.style.display = 'none';
    
    // Perform the axis operation with animation
    performAxisOperationAnimation(currentMatrix, opConfig.func, operationType, operationName);
}

// NEW: Perform Axis Operation with Animation - FIXED VERSION
function performAxisOperationAnimation(matrix, operation, type, name) {
    const explanation = document.getElementById('axisExplanation');
    const stepsContainer = document.getElementById('axisSteps');
    const resultContainer = document.getElementById('resultContainer');
    const continueButton = document.getElementById('continueAfterAxis');
    const matrixDisplay = document.getElementById('matrixDisplay');
    
    let result = [];
    let step = 0;
    
    // Clear previous steps
    stepsContainer.innerHTML = '';
    
    function performStep() {
        if (type === 'row' && step >= matrix.length) {
            finishOperation();
            return;
        }
        
        if (type === 'col' && step >= matrix[0].length) {
            finishOperation();
            return;
        }
        
        if (type === 'row') {
            // Row-wise operation
            const currentRow = matrix[step];
            explanation.innerHTML = `Processing row ${step}: [${currentRow.join(', ')}]`;
            
            // Highlight current row
            const rows = matrixDisplay.querySelectorAll('.matrix-row');
            if (rows[step]) {
                const cells = rows[step].querySelectorAll('.matrix-cell');
                
                cells.forEach(cell => {
                    cell.classList.add('highlight');
                });
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step + 1}:</strong> Processing row ${step} = [${currentRow.join(', ')}]
                    </div>
                `;
                
                // Scroll to show the current step
                stepsContainer.scrollTop = stepsContainer.scrollHeight;
                
                setTimeout(() => {
                    // Apply operation
                    let rowResult;
                    try {
                        rowResult = operation(currentRow);
                        result.push(rowResult);
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Result:</strong> ${name} for row ${step} = ${Array.isArray(rowResult) ? `[${rowResult.map(r => typeof r === 'number' ? r.toFixed(2) : r).join(', ')}]` : (typeof rowResult === 'number' ? rowResult.toFixed(2) : rowResult)}
                            </div>
                        `;
                        
                        // Scroll to show the result
                        stepsContainer.scrollTop = stepsContainer.scrollHeight;
                        
                    } catch (error) {
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step" style="border-left-color: var(--danger-color);">
                                <strong>Error:</strong> ${error.message}
                            </div>
                        `;
                        result.push(null);
                    }
                    
                    // Remove highlight with animation
                    cells.forEach((cell, index) => {
                        setTimeout(() => {
                            cell.classList.remove('highlight');
                        }, index * 100);
                    });
                    
                    step++;
                    setTimeout(performStep, 1000);
                }, 2000);
            }
            
        } else {
            // Column-wise operation
            explanation.innerHTML = `Processing column ${step}`;
            
            // Highlight current column
            const rows = matrixDisplay.querySelectorAll('.matrix-row');
            const column = matrix.map(row => row[step]);
            
            // Highlight all cells in this column
            rows.forEach((row, rowIndex) => {
                const cells = row.querySelectorAll('.matrix-cell');
                if (cells[step]) {
                    setTimeout(() => {
                        cells[step].classList.add('highlight');
                    }, rowIndex * 100);
                }
            });
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step + 1}:</strong> Processing column ${step} = [${column.join(', ')}]
                </div>
            `;
            
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            setTimeout(() => {
                // Apply operation
                let colResult;
                try {
                    colResult = operation(column);
                    result.push(colResult);
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Result:</strong> ${name} for column ${step} = ${Array.isArray(colResult) ? `[${colResult.map(r => typeof r === 'number' ? r.toFixed(2) : r).join(', ')}]` : (typeof colResult === 'number' ? colResult.toFixed(2) : colResult)}
                        </div>
                    `;
                    
                    stepsContainer.scrollTop = stepsContainer.scrollHeight;
                    
                } catch (error) {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step" style="border-left-color: var(--danger-color);">
                            <strong>Error:</strong> ${error.message}
                        </div>
                    `;
                    result.push(null);
                }
                
                // Remove highlight from column
                rows.forEach((row, rowIndex) => {
                    const cells = row.querySelectorAll('.matrix-cell');
                    if (cells[step]) {
                        setTimeout(() => {
                            cells[step].classList.remove('highlight');
                        }, rowIndex * 100);
                    }
                });
                
                step++;
                setTimeout(performStep, 1000);
            }, 2000 + (rows.length * 100));
        }
    }
    
    function finishOperation() {
        explanation.innerHTML = `<strong>${name} Completed!</strong> All ${type === 'row' ? 'rows' : 'columns'} processed.`;
        
        // Filter out null results from errors
        const validResults = result.filter(r => r !== null);
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Final Result:</strong> [${validResults.map(r => 
                    Array.isArray(r) ? `[${r.map(v => typeof v === 'number' ? v.toFixed(2) : v).join(', ')}]` : 
                    (typeof r === 'number' ? r.toFixed(2) : r)
                ).join(', ')}]
            </div>
        `;
        
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Show result after a delay
        setTimeout(() => {
            resultContainer.style.display = 'block';
            
            if (type === 'row') {
                // For row operations, result is a 1D array - show as single row
                const resultMatrix = [validResults];
                renderMatrix(resultMatrix, 'resultDisplay');
                
                // Add labels
                const resultDisplay = document.getElementById('resultDisplay');
                resultDisplay.previousElementSibling.innerHTML = 
                    `Result (Row-wise ${name}): 1  ${validResults.length}`;
            } else {
                // For column operations, result is a 1D array - show as single row
                const resultMatrix = [validResults];
                renderMatrix(resultMatrix, 'resultDisplay');
                
                // Add labels
                const resultDisplay = document.getElementById('resultDisplay');
                resultDisplay.previousElementSibling.innerHTML = 
                    `Result (Column-wise ${name}): 1  ${validResults.length}`;
            }
            
            // Highlight result cells with animation
            const resultCells = document.querySelectorAll('#resultDisplay .matrix-cell');
            resultCells.forEach((cell, index) => {
                setTimeout(() => {
                    cell.classList.add('result');
                    cell.style.animation = 'bounce 0.5s ease';
                }, index * 200);
            });
            
            continueButton.style.display = 'block';
            
        }, 1000);
        
        // Auto-return after 10 seconds
        const autoReturnTimer = setTimeout(() => {
            returnToOriginalAfterAxis();
        }, 10000);
        
        continueButton.addEventListener('click', () => {
            clearTimeout(autoReturnTimer);
            returnToOriginalAfterAxis();
        });
    }
    
    // Start the operation with a small delay
    setTimeout(performStep, 500);
}

// Also update the CSS to ensure animations work properly - ADD THESE STYLES:
// NEW: Return to Original after Axis Operation
function returnToOriginalAfterAxis() {
    // Reset to original array
    myArray = [...originalArrayForAxis];
    originalArrayForAxis = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isAxisOperationRunning = false;
    currentMatrix = [];
    
    // Clear inputs
    axisFunctionSelect.value = '';
    customFunction.value = '';
    matrixRowsInput.value = '';
    matrixColsInput.value = '';
    customFunctionGroup.style.display = 'none';
    matrixDimensionsGroup.style.display = 'none';
    
    logOperation('Axis operation completed - returned to original array', 'info');
    showNotification('Returned to original array after axis operation', 'success');
}
// NEW: Statistical Analysis Operations Handler
function handleStatisticalOperation(operation) {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Statistical operations require all array elements to be numbers', 'danger');
        return;
    }
    
    if (isStatisticalAnalysisRunning) {
        showNotification('A statistical analysis operation is already in progress', 'warning');
        return;
    }
    
    currentStatOperation = operation; // Using renamed variable
    
    if (operation === 'nSmallest' || operation === 'nLargest') {
        // Show N value input for these operations
        nValueInputGroup.style.display = 'block';
        nValueInput.focus();
        nValueInput.placeholder = `Enter N (1 to ${myArray.length})`;
    } else {
        // Directly perform min/max index operations
        performStatisticalOperation(operation);
    }
}

// NEW: Confirm N Value Handler
function handleConfirmNValue() {
    const nValue = parseInt(nValueInput.value);
    const maxN = myArray.length;
    
    if (isNaN(nValue) || nValue < 1 || nValue > maxN) {
        showNotification(`Please enter a valid N value between 1 and ${maxN}`, 'danger');
        nValueInput.focus();
        return;
    }
    
    nValueForStatisticalAnalysis = nValue;
    nValueInputGroup.style.display = 'none';
    nValueInput.value = '';
    
    performStatisticalOperation(currentStatOperation); // Using renamed variable
}

// NEW: Cancel N Value Handler
function handleCancelNValue() {
    nValueInputGroup.style.display = 'none';
    nValueInput.value = '';
    currentStatOperation = null; // Using renamed variable
}

// NEW: Perform Statistical Operation
function performStatisticalOperation(operation) {
    isStatisticalAnalysisRunning = true;
    
    // Store original array
    originalArrayForStatisticalOps = [...myArray];
    
    // Convert array to numbers
    const numericArray = myArray.map(val => parseFloat(val));
    
    switch(operation) {
        case 'minIndex':
            findMinIndex(numericArray);
            break;
        case 'maxIndex':
            findMaxIndex(numericArray);
            break;
        case 'nSmallest':
            findNSmallestValues(numericArray);
            break;
        case 'nLargest':
            findNLargestValues(numericArray);
            break;
    }
}

// NEW: Find Minimum Index
function findMinIndex(numericArray) {
    let minIndex = 0;
    let minValue = numericArray[0];
    
    // Create visualization container
    const statsContainer = document.createElement('div');
    statsContainer.className = 'stats-results-container';
    statsContainer.innerHTML = `
        <h5 class="text-center mb-3">Finding Minimum Value Index</h5>
        <div class="array-container" id="statsArrayContainer"></div>
        <div id="statsResults" class="mt-3"></div>
        <button class="btn btn-sm btn-outline-light mt-3 w-100" id="resetAfterStats">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(statsContainer);
    
    renderArrayInContainer(originalArrayForStatisticalOps, 'statsArrayContainer');
    
    const resultsDiv = document.getElementById('statsResults');
    const arrayContainer = document.getElementById('statsArrayContainer');
    const resetBtn = document.getElementById('resetAfterStats');
    
    let currentIndex = 0;
    
    function findMinStep() {
        if (currentIndex >= numericArray.length) {
            // Search completed
            resultsDiv.innerHTML = `
                <div class="alert alert-success">
                    <h6><i class="fas fa-check-circle me-2"></i>Minimum Value Found!</h6>
                    <p class="mb-1">Index: <strong>${minIndex}</strong></p>
                    <p class="mb-1">Value: <strong>${minValue}</strong></p>
                    <p class="mb-0">Position: <strong>${minIndex + 1}</strong> of ${numericArray.length}</p>
                </div>
            `;
            
            // Highlight the minimum element
            const elements = arrayContainer.querySelectorAll('.array-element');
            elements[minIndex].querySelector('.element-value').classList.add('stat-min-highlight');
            
            resetBtn.style.display = 'block';
            resetBtn.addEventListener('click', resetAfterStatisticalOperation);
            
            // Auto-reset after 5 seconds
            setTimeout(() => {
                resetAfterStatisticalOperation();
            }, 5000);
            
            return;
        }
        
        // Highlight current element being checked
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElement = elements[currentIndex].querySelector('.element-value');
        
        if (currentIndex === 0) {
            // First element - initialize min
            currentElement.classList.add('stat-min-highlight');
            setTimeout(() => {
                currentIndex++;
                findMinStep();
            }, 1000);
        } else {
            currentElement.classList.add('sorting-current');
            
            setTimeout(() => {
                if (numericArray[currentIndex] < minValue) {
                    // New minimum found
                    minValue = numericArray[currentIndex];
                    minIndex = currentIndex;
                    
                    // Remove highlight from previous min
                    elements[minIndex].querySelector('.element-value').classList.remove('stat-min-highlight');
                    // Add highlight to new min
                    currentElement.classList.remove('sorting-current');
                    currentElement.classList.add('stat-min-highlight');
                    
                    resultsDiv.innerHTML = `
                        <div class="alert alert-info">
                            <p class="mb-1">New minimum found at index ${currentIndex}</p>
                            <p class="mb-0">Current minimum: ${minValue} at index ${minIndex}</p>
                        </div>
                    `;
                } else {
                    // Not a new minimum
                    currentElement.classList.remove('sorting-current');
                }
                
                currentIndex++;
                findMinStep();
            }, 1000);
        }
    }
    
    // Start the search
    findMinStep();
}

// NEW: Find Maximum Index
function findMaxIndex(numericArray) {
    let maxIndex = 0;
    let maxValue = numericArray[0];
    
    // Create visualization container
    const statsContainer = document.createElement('div');
    statsContainer.className = 'stats-results-container';
    statsContainer.innerHTML = `
        <h5 class="text-center mb-3">Finding Maximum Value Index</h5>
        <div class="array-container" id="statsArrayContainer"></div>
        <div id="statsResults" class="mt-3"></div>
        <button class="btn btn-sm btn-outline-light mt-3 w-100" id="resetAfterStats">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(statsContainer);
    
    renderArrayInContainer(originalArrayForStatisticalOps, 'statsArrayContainer');
    
    const resultsDiv = document.getElementById('statsResults');
    const arrayContainer = document.getElementById('statsArrayContainer');
    const resetBtn = document.getElementById('resetAfterStats');
    
    let currentIndex = 0;
    
    function findMaxStep() {
        if (currentIndex >= numericArray.length) {
            // Search completed
            resultsDiv.innerHTML = `
                <div class="alert alert-success">
                    <h6><i class="fas fa-check-circle me-2"></i>Maximum Value Found!</h6>
                    <p class="mb-1">Index: <strong>${maxIndex}</strong></p>
                    <p class="mb-1">Value: <strong>${maxValue}</strong></p>
                    <p class="mb-0">Position: <strong>${maxIndex + 1}</strong> of ${numericArray.length}</p>
                </div>
            `;
            
            // Highlight the maximum element
            const elements = arrayContainer.querySelectorAll('.array-element');
            elements[maxIndex].querySelector('.element-value').classList.add('stat-max-highlight');
            
            resetBtn.style.display = 'block';
            resetBtn.addEventListener('click', resetAfterStatisticalOperation);
            
            // Auto-reset after 5 seconds
            setTimeout(() => {
                resetAfterStatisticalOperation();
            }, 5000);
            
            return;
        }
        
        // Highlight current element being checked
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElement = elements[currentIndex].querySelector('.element-value');
        
        if (currentIndex === 0) {
            // First element - initialize max
            currentElement.classList.add('stat-max-highlight');
            setTimeout(() => {
                currentIndex++;
                findMaxStep();
            }, 1000);
        } else {
            currentElement.classList.add('sorting-current');
            
            setTimeout(() => {
                if (numericArray[currentIndex] > maxValue) {
                    // New maximum found
                    maxValue = numericArray[currentIndex];
                    maxIndex = currentIndex;
                    
                    // Remove highlight from previous max
                    elements[maxIndex].querySelector('.element-value').classList.remove('stat-max-highlight');
                    // Add highlight to new max
                    currentElement.classList.remove('sorting-current');
                    currentElement.classList.add('stat-max-highlight');
                    
                    resultsDiv.innerHTML = `
                        <div class="alert alert-info">
                            <p class="mb-1">New maximum found at index ${currentIndex}</p>
                            <p class="mb-0">Current maximum: ${maxValue} at index ${maxIndex}</p>
                        </div>
                    `;
                } else {
                    // Not a new maximum
                    currentElement.classList.remove('sorting-current');
                }
                
                currentIndex++;
                findMaxStep();
            }, 1000);
        }
    }
    
    // Start the search
    findMaxStep();
}

// NEW: Find N Smallest Values
function findNSmallestValues(numericArray) {
    const n = nValueForStatisticalAnalysis;
    
    // Create visualization container
    const statsContainer = document.createElement('div');
    statsContainer.className = 'stats-results-container';
    statsContainer.innerHTML = `
        <h5 class="text-center mb-3">Finding ${n} Smallest Values</h5>
        <div class="array-container" id="statsArrayContainer"></div>
        <div id="statsResults" class="mt-3"></div>
        <button class="btn btn-sm btn-outline-light mt-3 w-100" id="resetAfterStats">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(statsContainer);
    
    renderArrayInContainer(originalArrayForStatisticalOps, 'statsArrayContainer');
    
    const resultsDiv = document.getElementById('statsResults');
    const arrayContainer = document.getElementById('statsArrayContainer');
    const resetBtn = document.getElementById('resetAfterStats');
    
    // Create array with indices for tracking
    const indexedArray = numericArray.map((value, index) => ({ value, index }));
    
    // Sort to find N smallest values
    indexedArray.sort((a, b) => a.value - b.value);
    const nSmallest = indexedArray.slice(0, n);
    
    // Display results
    resultsDiv.innerHTML = `
        <div class="alert alert-success">
            <h6><i class="fas fa-check-circle me-2"></i>${n} Smallest Values Found!</h6>
            <div class="mt-2">
                ${nSmallest.map((item, i) => `
                    <div class="stats-result-item">
                        ${i + 1}. Index ${item.index}: ${item.value}
                    </div>
                `).join('')}
            </div>
        </div>
    `;
    
    // Highlight the N smallest elements with animation
    const elements = arrayContainer.querySelectorAll('.array-element');
    nSmallest.forEach((item, i) => {
        setTimeout(() => {
            elements[item.index].querySelector('.element-value').classList.add('stat-n-smallest');
        }, i * 300);
    });
    
    resetBtn.style.display = 'block';
    resetBtn.addEventListener('click', resetAfterStatisticalOperation);
    
    // Auto-reset after 8 seconds
    setTimeout(() => {
        resetAfterStatisticalOperation();
    }, 8000);
}

// NEW: Find N Largest Values
function findNLargestValues(numericArray) {
    const n = nValueForStatisticalAnalysis;
    
    // Create visualization container
    const statsContainer = document.createElement('div');
    statsContainer.className = 'stats-results-container';
    statsContainer.innerHTML = `
        <h5 class="text-center mb-3">Finding ${n} Largest Values</h5>
        <div class="array-container" id="statsArrayContainer"></div>
        <div id="statsResults" class="mt-3"></div>
        <button class="btn btn-sm btn-outline-light mt-3 w-100" id="resetAfterStats">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(statsContainer);
    
    renderArrayInContainer(originalArrayForStatisticalOps, 'statsArrayContainer');
    
    const resultsDiv = document.getElementById('statsResults');
    const arrayContainer = document.getElementById('statsArrayContainer');
    const resetBtn = document.getElementById('resetAfterStats');
    
    // Create array with indices for tracking
    const indexedArray = numericArray.map((value, index) => ({ value, index }));
    
    // Sort to find N largest values
    indexedArray.sort((a, b) => b.value - a.value);
    const nLargest = indexedArray.slice(0, n);
    
    // Display results
    resultsDiv.innerHTML = `
        <div class="alert alert-success">
            <h6><i class="fas fa-check-circle me-2"></i>${n} Largest Values Found!</h6>
            <div class="mt-2">
                ${nLargest.map((item, i) => `
                    <div class="stats-result-item">
                        ${i + 1}. Index ${item.index}: ${item.value}
                    </div>
                `).join('')}
            </div>
        </div>
    `;
    
    // Highlight the N largest elements with animation
    const elements = arrayContainer.querySelectorAll('.array-element');
    nLargest.forEach((item, i) => {
        setTimeout(() => {
            elements[item.index].querySelector('.element-value').classList.add('stat-n-largest');
        }, i * 300);
    });
    
    resetBtn.style.display = 'block';
    resetBtn.addEventListener('click', resetAfterStatisticalOperation);
    
    // Auto-reset after 8 seconds
    setTimeout(() => {
        resetAfterStatisticalOperation();
    }, 8000);
}

// NEW: Reset after Statistical Operation
function resetAfterStatisticalOperation() {
    // Reset to original array
    myArray = [...originalArrayForStatisticalOps];
    originalArrayForStatisticalOps = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isStatisticalAnalysisRunning = false;
    currentStatOperation = null; // Using renamed variable
    nValueForStatisticalAnalysis = 0;
    
    logOperation('Statistical analysis completed - returned to original array', 'info');
    showNotification('Returned to original array after statistical analysis', 'success');
}
// NEW: Valid Parentheses Handler
function handleValidParentheses() {
    const inputString = parenthesesInput.value.trim();
    
    if (inputString === '') {
        showNotification('Please enter a string to validate', 'warning');
        parenthesesInput.focus();
        return;
    }
    
    // Check if string contains only parentheses
    const parenthesesRegex = /^[{}]*$/;
    if (!parenthesesRegex.test(inputString)) {
        showNotification('Please enter only curly braces {} - no numbers, alphabets, or other characters allowed', 'danger');
        parenthesesInput.focus();
        return;
    }
    
    if (isParenthesesCheckActive) {
        showNotification('Parentheses validation is already in progress', 'warning');
        return;
    }
    
    isParenthesesCheckActive = true;
    
    // Store original array state
    originalArrayState = [...myArray];
    
    // Show parentheses validation visualization
    showParenthesesValidation(inputString);
}

// NEW: Show Parentheses Validation Visualization
function showParenthesesValidation(inputString) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Valid Parentheses Validation</h5>
        
        <div class="array-group">
            <div class="array-label">Input String: "${inputString}"</div>
            <div class="original-array-container" id="parenthesesString"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Validation Process</div>
            <div id="stackContainer" class="mt-3">
                <h6 class="text-center">Stack Operations</h6>
                <div class="d-flex flex-wrap justify-content-center" id="stackVisualization"></div>
            </div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Using stack to validate balanced parentheses</p>
            <p class="mb-0" id="parenthesesExplanation">Starting parentheses validation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="parenthesesStepsContainer">
            <h6 class="text-center">Validation Steps</h6>
            <div class="steps-container" id="parenthesesSteps"></div>
        </div>
        
        <div id="parenthesesResult" class="mt-3" style="display: none;"></div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterParentheses" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Render the input string as array elements
    renderParenthesesString(inputString);
    
    // Start parentheses validation animation
    performParenthesesValidation(inputString);
}

// NEW: Render Parentheses String
function renderParenthesesString(inputString) {
    const container = document.getElementById('parenthesesString');
    container.innerHTML = '';
    
    const characters = inputString.split('');
    
    characters.forEach((char, index) => {
        const element = document.createElement('div');
        element.className = 'array-element';
        element.innerHTML = `
            <div class="element-value" data-index="${index}" data-char="${char}">
                ${char}
            </div>
            <div class="element-index">${index}</div>
        `;
        container.appendChild(element);
    });
}

// NEW: Perform Parentheses Validation with Animation
function performParenthesesValidation(inputString) {
    const stringContainer = document.getElementById('parenthesesString');
    const stackContainer = document.getElementById('stackVisualization');
    const explanation = document.getElementById('parenthesesExplanation');
    const stepsContainer = document.getElementById('parenthesesSteps');
    const resultContainer = document.getElementById('parenthesesResult');
    const continueButton = document.getElementById('continueAfterParentheses');
    
    const characters = inputString.split('');
    const stack = [];
    let currentIndex = 0;
    let isValid = true;
    let autoReturnTimer = null;
    let unmatchedClosingBrackets = []; // Track unmatched closing brackets
    
    function performValidationStep() {
        if (currentIndex >= characters.length) {
            // Validation completed
            if (stack.length === 0 && unmatchedClosingBrackets.length === 0 && isValid) {
                explanation.innerHTML = `<strong>Algorithm Completed!</strong> Given string is Valid Parentheses`;
                resultContainer.innerHTML = `
                    <div class="parentheses-valid">
                        <i class="fas fa-check-circle me-2"></i>
                        YES - Given string is Valid Parentheses
                    </div>
                `;
                resultContainer.style.display = 'block';
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Algorithm completed - All parentheses are properly matched!
                    </div>
                `;
            } else {
                explanation.innerHTML = `<strong>Algorithm Completed!</strong> Given string is Invalid Parentheses`;
                resultContainer.innerHTML = `
                    <div class="parentheses-invalid">
                        <i class="fas fa-times-circle me-2"></i>
                        NO - Given string is Invalid Parentheses
                    </div>
                `;
                resultContainer.style.display = 'block';
                
                let errorMessage = '';
                if (stack.length > 0) {
                    errorMessage += `${stack.length} unmatched opening parentheses`;
                }
                if (unmatchedClosingBrackets.length > 0) {
                    if (errorMessage) errorMessage += ' and ';
                    errorMessage += `${unmatchedClosingBrackets.length} unmatched closing parentheses`;
                }
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Algorithm completed - ${errorMessage} found!
                    </div>
                `;
            }
            
            continueButton.style.display = 'block';
            
            // Set up auto-return after 10 seconds
            autoReturnTimer = setTimeout(() => {
                resetToOriginalArray();
            }, 10000);
            
            // Set up manual return button
            continueButton.onclick = function() {
                if (autoReturnTimer) {
                    clearTimeout(autoReturnTimer);
                }
                resetToOriginalArray();
            };
            
            return;
        }
        
        const currentChar = characters[currentIndex];
        const elements = stringContainer.querySelectorAll('.array-element');
        const currentElement = elements[currentIndex].querySelector('.element-value');
        
        // Highlight current character
        currentElement.classList.add('parentheses-current');
        explanation.innerHTML = `Processing character at position ${currentIndex}: "${currentChar}"`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${currentIndex + 1}:</strong> Processing character "${currentChar}" at index ${currentIndex}
            </div>
        `;
        
        setTimeout(() => {
            if (currentChar === '{') {
                // Opening bracket - push to stack
                explanation.innerHTML = `Found opening bracket "{" - pushing to stack`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Action:</strong> Opening bracket - Pushing to stack
                    </div>
                `;
                
                stack.push({
                    char: currentChar,
                    index: currentIndex
                });
                currentElement.classList.remove('parentheses-current');
                currentElement.classList.add('parentheses-unmatched');
                
                // Update stack visualization
                updateStackVisualization(stack, unmatchedClosingBrackets, stackContainer);
                
            } else if (currentChar === '}') {
                // Closing bracket - check stack
                explanation.innerHTML = `Found closing bracket "}" - checking stack`;
                
                if (stack.length > 0 && stack[stack.length - 1].char === '{') {
                    // Matching pair found
                    explanation.innerHTML = `Matching pair found - popping from stack`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Action:</strong> Closing bracket matches top of stack - Popping "{"
                        </div>
                    `;
                    
                    stack.pop();
                    currentElement.classList.remove('parentheses-current');
                    currentElement.classList.add('parentheses-matched');
                    
                    // Also highlight the corresponding opening bracket
                    for (let i = currentIndex - 1; i >= 0; i--) {
                        const element = elements[i].querySelector('.element-value');
                        if (element.classList.contains('parentheses-unmatched') && 
                            element.getAttribute('data-char') === '{') {
                            element.classList.remove('parentheses-unmatched');
                            element.classList.add('parentheses-matched');
                            break;
                        }
                    }
                    
                } else {
                    // No matching opening bracket - track as unmatched closing bracket
                    explanation.innerHTML = `No matching opening bracket found!`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Error:</strong> No matching opening bracket - Invalid parentheses!
                        </div>
                    `;
                    
                    currentElement.classList.remove('parentheses-current');
                    currentElement.classList.add('parentheses-unmatched');
                    unmatchedClosingBrackets.push({
                        char: currentChar,
                        index: currentIndex
                    });
                    isValid = false;
                }
                
                // Update stack visualization
                updateStackVisualization(stack, unmatchedClosingBrackets, stackContainer);
            }
            
            // Scroll steps container to bottom
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            currentIndex++;
            performValidationStep();
        }, 1500);
    }
    
    // Start validation process
    performValidationStep();
}

// NEW: Update Stack Visualization - Show both unmatched opening and closing brackets
function updateStackVisualization(stack, unmatchedClosingBrackets, container) {
    container.innerHTML = '';
    
    if (stack.length === 0 && unmatchedClosingBrackets.length === 0) {
        container.innerHTML = '<div class="text-muted">Stack is empty</div>';
        return;
    }
    
    // Create a wrapper for better organization
    const wrapper = document.createElement('div');
    wrapper.className = 'w-100';
    
    // Show unmatched opening brackets (stack)
    if (stack.length > 0) {
        const openingSection = document.createElement('div');
        openingSection.className = 'mb-3';
        openingSection.innerHTML = '<div class="text-info mb-2"><strong>Unmatched Opening Brackets:</strong></div>';
        
        const openingStack = document.createElement('div');
        openingStack.className = 'd-flex flex-wrap justify-content-center';
        
        // Display stack from top to bottom
        for (let i = stack.length - 1; i >= 0; i--) {
            const stackItem = document.createElement('div');
            stackItem.className = 'parentheses-stack-item';
            if (i === stack.length - 1) {
                stackItem.classList.add('current');
            }
            stackItem.innerHTML = `${stack[i].char}<small class="ms-1">[${stack[i].index}]</small>`;
            openingStack.appendChild(stackItem);
        }
        
        openingSection.appendChild(openingStack);
        wrapper.appendChild(openingSection);
    }
    
    // Show unmatched closing brackets
    if (unmatchedClosingBrackets.length > 0) {
        const closingSection = document.createElement('div');
        closingSection.className = 'mb-3';
        closingSection.innerHTML = '<div class="text-danger mb-2"><strong>Unmatched Closing Brackets:</strong></div>';
        
        const closingStack = document.createElement('div');
        closingStack.className = 'd-flex flex-wrap justify-content-center';
        
        // Display unmatched closing brackets
        for (let i = 0; i < unmatchedClosingBrackets.length; i++) {
            const closingItem = document.createElement('div');
            closingItem.className = 'parentheses-stack-item';
            closingItem.style.background = 'var(--danger-color) !important';
            closingItem.innerHTML = `${unmatchedClosingBrackets[i].char}<small class="ms-1">[${unmatchedClosingBrackets[i].index}]</small>`;
            closingStack.appendChild(closingItem);
        }
        
        closingSection.appendChild(closingStack);
        wrapper.appendChild(closingSection);
    }
    
    container.appendChild(wrapper);
}

// NEW: Reset to Original Array Function
function resetToOriginalArray() {
    // Reset to original array
    myArray = [...originalArrayState];
    originalArrayState = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isParenthesesCheckActive = false;
    
    // Clear input
    parenthesesInput.value = '';
    
    logOperation('Parentheses validation completed - returned to original array', 'info');
    showNotification('Returned to original array after parentheses validation', 'success');
}

// NEW: Maximum Subarray Sum Handler (Kadane's Algorithm)
function handleMaxSubarraySum() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Maximum subarray algorithm requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForKadane = [...myArray];
    
    // Show Kadane's algorithm visualization
    showMaxSubarraySumVisualization();
}

// NEW: Maximum Product Subarray Handler
function handleMaxProductSubarray() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Maximum product subarray algorithm requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForKadane = [...myArray];
    
    // Show maximum product subarray visualization
    showMaxProductSubarrayVisualization();
}

// NEW: Show Maximum Subarray Sum Visualization
function showMaxSubarraySumVisualization() {
    isKadaneAlgorithmRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Maximum Subarray Sum - Kadane's Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalKadaneArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Kadane's Algorithm Process</div>
            <div class="transformed-array-container" id="transformedKadaneArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Kadane's Algorithm:</strong> Finding the contiguous subarray with maximum sum</p>
            <p class="mb-0" id="kadaneExplanation">Initializing Kadane's algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="kadaneStepsContainer">
            <h6 class="text-center">Kadane's Algorithm Steps</h6>
            <div class="steps-container" id="kadaneSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Maximum Subarray Sum</div>
            <div class="stats-value" id="maxSubarraySumValue">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Subarray Indices</div>
            <div class="stats-value" id="maxSubarrayIndices">-</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Subarray Elements</div>
            <div class="stats-value" id="maxSubarrayElements">-</div>
        </div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForKadane, 'originalKadaneArray');
    renderArrayInContainer([...originalArrayForKadane], 'transformedKadaneArray');
    
    performKadaneAlgorithmAnimation();
}

// NEW: Show Maximum Product Subarray Visualization
function showMaxProductSubarrayVisualization() {
    isKadaneAlgorithmRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Maximum Product Subarray</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalProductArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Maximum Product Subarray Process</div>
            <div class="transformed-array-container" id="transformedProductArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Maximum Product Subarray:</strong> Finding the contiguous subarray with maximum product</p>
            <p class="mb-0" id="productExplanation">Initializing maximum product algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="productStepsContainer">
            <h6 class="text-center">Maximum Product Algorithm Steps</h6>
            <div class="steps-container" id="productSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Maximum Product</div>
            <div class="stats-value" id="maxProductValue">1</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Subarray Indices</div>
            <div class="stats-value" id="maxProductIndices">-</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Subarray Elements</div>
            <div class="stats-value" id="maxProductElements">-</div>
        </div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForKadane, 'originalProductArray');
    renderArrayInContainer([...originalArrayForKadane], 'transformedProductArray');
    
    performMaxProductSubarrayAnimation();
}

// NEW: Perform Kadane's Algorithm Animation
function performKadaneAlgorithmAnimation() {
    const originalContainer = document.getElementById('originalKadaneArray');
    const transformedContainer = document.getElementById('transformedKadaneArray');
    const explanation = document.getElementById('kadaneExplanation');
    const stepsContainer = document.getElementById('kadaneSteps');
    const maxSubarraySumValue = document.getElementById('maxSubarraySumValue');
    const maxSubarrayIndices = document.getElementById('maxSubarrayIndices');
    const maxSubarrayElements = document.getElementById('maxSubarrayElements');
    
    const arr = originalArrayForKadane.map(val => parseFloat(val));
    let maxEndingHere = arr[0];
    let maxSoFar = arr[0];
    let start = 0;
    let end = 0;
    let tempStart = 0;
    let step = 0;
    
    // Highlight first element
    const transformedElements = transformedContainer.querySelectorAll('.array-element');
    transformedElements[0].querySelector('.element-value').classList.add('kadane-current');
    
    explanation.innerHTML = `Step ${step + 1}: Initialize with first element = ${arr[0]}`;
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Step 1:</strong> Initialize maxEndingHere = ${arr[0]}, maxSoFar = ${arr[0]}
        </div>
    `;
    
    maxSubarraySumValue.textContent = maxSoFar;
    maxSubarrayIndices.textContent = `0 to 0`;
    maxSubarrayElements.textContent = `[${arr[0]}]`;
    
    step++;
    
    function performKadaneStep(i) {
        if (i >= arr.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Kadane's Algorithm Completed!</strong> Maximum subarray sum found.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Maximum subarray sum = ${maxSoFar} from indices ${start} to ${end}
                </div>
            `;
            
            // Highlight the maximum subarray
            for (let j = start; j <= end; j++) {
                setTimeout(() => {
                    transformedElements[j].querySelector('.element-value').classList.add('kadane-max-subarray');
                }, (j - start) * 200);
            }
            
            maxSubarraySumValue.textContent = maxSoFar;
            maxSubarrayIndices.textContent = `${start} to ${end}`;
            maxSubarrayElements.textContent = `[${arr.slice(start, end + 1).join(', ')}]`;
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterKadane();
            }, 10000);
            
            return;
        }
        
        // Remove previous highlights
        if (i > 0) {
            transformedElements[i-1].querySelector('.element-value').classList.remove('kadane-current');
        }
        
        // Highlight current element
        transformedElements[i].querySelector('.element-value').classList.add('kadane-current');
        
        explanation.innerHTML = `Step ${step + 1}: Processing element [${i}] = ${arr[i]}`;
        
        // Calculate maxEndingHere
        const newMaxEndingHere = Math.max(arr[i], maxEndingHere + arr[i]);
        
        if (newMaxEndingHere === arr[i]) {
            // Start new subarray
            tempStart = i;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step + 1}:</strong> maxEndingHere = max(${arr[i]}, ${maxEndingHere} + ${arr[i]}) = ${arr[i]} (start new subarray at index ${i})
                </div>
            `;
        } else {
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step + 1}:</strong> maxEndingHere = max(${arr[i]}, ${maxEndingHere} + ${arr[i]}) = ${newMaxEndingHere} (extend subarray)
                </div>
            `;
        }
        
        maxEndingHere = newMaxEndingHere;
        
        // Update maxSoFar if needed
        if (maxEndingHere > maxSoFar) {
            maxSoFar = maxEndingHere;
            start = tempStart;
            end = i;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Update:</strong> New maximum found! maxSoFar = ${maxSoFar} (indices ${start}-${end})
                </div>
            `;
            
            // Highlight current best subarray
            const currentElements = transformedContainer.querySelectorAll('.array-element');
            currentElements.forEach(el => {
                el.querySelector('.element-value').classList.remove('kadane-included');
            });
            for (let j = start; j <= end; j++) {
                currentElements[j].querySelector('.element-value').classList.add('kadane-included');
            }
        }
        
        maxSubarraySumValue.textContent = maxSoFar;
        maxSubarrayIndices.textContent = `${start} to ${end}`;
        maxSubarrayElements.textContent = `[${arr.slice(start, end + 1).join(', ')}]`;
        
        step++;
        
        // Scroll to bottom of steps
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Continue to next element
        setTimeout(() => {
            performKadaneStep(i + 1);
        }, 2000);
    }
    
    // Start algorithm from second element
    setTimeout(() => {
        performKadaneStep(1);
    }, 2000);
}

// NEW: Perform Maximum Product Subarray Animation
function performMaxProductSubarrayAnimation() {
    const originalContainer = document.getElementById('originalProductArray');
    const transformedContainer = document.getElementById('transformedProductArray');
    const explanation = document.getElementById('productExplanation');
    const stepsContainer = document.getElementById('productSteps');
    const maxProductValue = document.getElementById('maxProductValue');
    const maxProductIndices = document.getElementById('maxProductIndices');
    const maxProductElements = document.getElementById('maxProductElements');
    
    const arr = originalArrayForKadane.map(val => parseFloat(val));
    let maxProduct = arr[0];
    let minProduct = arr[0];
    let result = arr[0];
    let start = 0;
    let end = 0;
    let tempStart = 0;
    let step = 0;
    
    // Highlight first element
    const transformedElements = transformedContainer.querySelectorAll('.array-element');
    transformedElements[0].querySelector('.element-value').classList.add('kadane-current');
    
    explanation.innerHTML = `Step ${step + 1}: Initialize with first element = ${arr[0]}`;
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Step 1:</strong> Initialize maxProduct = ${arr[0]}, minProduct = ${arr[0]}, result = ${arr[0]}
        </div>
    `;
    
    maxProductValue.textContent = result;
    maxProductIndices.textContent = `0 to 0`;
    maxProductElements.textContent = `[${arr[0]}]`;
    
    step++;
    
    function performProductStep(i) {
        if (i >= arr.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Maximum Product Algorithm Completed!</strong> Maximum product subarray found.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Maximum product = ${result} from indices ${start} to ${end}
                </div>
            `;
            
            // Highlight the maximum product subarray
            for (let j = start; j <= end; j++) {
                setTimeout(() => {
                    transformedElements[j].querySelector('.element-value').classList.add('kadane-max-subarray');
                }, (j - start) * 200);
            }
            
            maxProductValue.textContent = result;
            maxProductIndices.textContent = `${start} to ${end}`;
            maxProductElements.textContent = `[${arr.slice(start, end + 1).join(', ')}]`;
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterKadane();
            }, 10000);
            
            return;
        }
        
        // Remove previous highlights
        if (i > 0) {
            transformedElements[i-1].querySelector('.element-value').classList.remove('kadane-current');
        }
        
        // Highlight current element
        transformedElements[i].querySelector('.element-value').classList.add('kadane-current');
        
        explanation.innerHTML = `Step ${step + 1}: Processing element [${i}] = ${arr[i]}`;
        
        // Store previous values
        const tempMax = maxProduct;
        const tempMin = minProduct;
        
        // Calculate new max and min products
        maxProduct = Math.max(arr[i], tempMax * arr[i], tempMin * arr[i]);
        minProduct = Math.min(arr[i], tempMax * arr[i], tempMin * arr[i]);
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step + 1}:</strong> 
                maxProduct = max(${arr[i]}, ${tempMax}  ${arr[i]}, ${tempMin}  ${arr[i]}) = ${maxProduct}<br>
                minProduct = min(${arr[i]}, ${tempMax}  ${arr[i]}, ${tempMin}  ${arr[i]}) = ${minProduct}
            </div>
        `;
        
        // Update result if needed
        if (maxProduct > result) {
            result = maxProduct;
            // For simplicity, we'll show the current subarray
            // In a real implementation, you'd track the actual subarray indices
            end = i;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Update:</strong> New maximum product found! result = ${result}
                </div>
            `;
            
            // Highlight current subarray (simplified - shows up to current index)
            const currentElements = transformedContainer.querySelectorAll('.array-element');
            currentElements.forEach(el => {
                el.querySelector('.element-value').classList.remove('kadane-included');
            });
            for (let j = 0; j <= i; j++) {
                currentElements[j].querySelector('.element-value').classList.add('kadane-included');
            }
        }
        
        maxProductValue.textContent = result;
        maxProductIndices.textContent = `0 to ${end}`; // Simplified indices
        maxProductElements.textContent = `[${arr.slice(0, end + 1).join(', ')}]`;
        
        step++;
        
        // Scroll to bottom of steps
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Continue to next element
        setTimeout(() => {
            performProductStep(i + 1);
        }, 2500);
    }
    
    // Start algorithm from second element
    setTimeout(() => {
        performProductStep(1);
    }, 2000);
}

// NEW: Return to Original after Kadane/Product Operations
function returnToOriginalAfterKadane() {
    // Reset to original array
    myArray = [...originalArrayForKadane];
    originalArrayForKadane = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isKadaneAlgorithmRunning = false;
    
    logOperation('Maximum subarray operation completed - returned to original array', 'info');
    showNotification('Returned to original array after maximum subarray operation', 'success');
}
// NEW: Check Palindrome Handler
function handleCheckPalindrome() {
    if (isPalindromeOperationRunning) {
        showNotification('A palindrome check is already in progress', 'warning');
        return;
    }

    // Create modal for string input
    const inputString = prompt('Enter a string to check if it\'s a palindrome:');
    
    if (!inputString) {
        showNotification('No string entered', 'info');
        return;
    }

    isPalindromeOperationRunning = true;
    performPalindromeCheck(inputString);
}

// NEW: Perform Palindrome Check with Animation
function performPalindromeCheck(inputString) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'string-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Check Valid Palindrome</h5>
        
        <div class="string-input-group">
            <div class="array-label">Original String</div>
            <div class="string-display" id="originalString">${inputString}</div>
        </div>

        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>

        <div class="string-input-group">
            <div class="array-label">Processing Steps</div>
            <div class="character-container" id="characterContainer"></div>
        </div>

        <div class="operation-explanation">
            <p class="mb-2"><strong>Palindrome Check:</strong> A string that reads the same forward and backward</p>
            <p class="mb-0" id="palindromeExplanation">Starting palindrome check...</p>
        </div>

        <div class="algorithm-steps mt-3" id="palindromeStepsContainer">
            <h6 class="text-center">Palindrome Check Steps</h6>
            <div class="steps-container" id="palindromeSteps"></div>
        </div>

        <div class="stats-card mt-3" id="palindromeResult" style="display: none;">
            <div>Result</div>
            <div class="stats-value" id="palindromeResultValue">-</div>
        </div>

        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPalindrome" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Array Operations
        </button>
    `;

    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);

    executePalindromeAlgorithm(inputString);
}

// NEW: Execute Palindrome Algorithm
function executePalindromeAlgorithm(inputString) {
    const characterContainer = document.getElementById('characterContainer');
    const explanation = document.getElementById('palindromeExplanation');
    const stepsContainer = document.getElementById('palindromeSteps');
    const resultDiv = document.getElementById('palindromeResult');
    const resultValue = document.getElementById('palindromeResultValue');
    const continueButton = document.getElementById('continueAfterPalindrome');

    // Clean the string: convert to lowercase and remove non-alphanumeric characters
    const cleanString = inputString.toLowerCase().replace(/[^a-z0-9]/g, '');
    const chars = cleanString.split('');
    const n = chars.length;
    
    let left = 0;
    let right = n - 1;
    let isPalindrome = true;
    let step = 0;

    // Display characters
    chars.forEach((char, index) => {
        const charBox = document.createElement('div');
        charBox.className = 'character-box';
        charBox.textContent = char;
        charBox.id = `char-${index}`;
        characterContainer.appendChild(charBox);
    });

    function executePalindromeStep() {
        if (left >= right) {
            // Algorithm completed
            if (isPalindrome) {
                explanation.innerHTML = `<strong class="text-success">Palindrome Check Complete!</strong> The string is a valid palindrome.`;
                resultValue.innerHTML = '<span class="text-success">Valid Palindrome </span>';
                resultValue.classList.add('palindrome-valid');
            } else {
                explanation.innerHTML = `<strong class="text-danger">Palindrome Check Complete!</strong> The string is not a palindrome.`;
                resultValue.innerHTML = '<span class="text-danger">Not a Palindrome </span>';
                resultValue.classList.add('palindrome-invalid');
            }

            resultDiv.style.display = 'block';
            continueButton.style.display = 'block';

            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterPalindrome();
            }, 10000);

            continueButton.addEventListener('click', returnToOriginalAfterPalindrome);
            return;
        }

        step++;
        explanation.innerHTML = `Step ${step}: Comparing characters at positions ${left} and ${right}`;

        // Highlight current characters being compared
        const leftChar = document.getElementById(`char-${left}`);
        const rightChar = document.getElementById(`char-${right}`);

        leftChar.classList.add('highlight');
        rightChar.classList.add('highlight');

        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Compare [${left}]='${chars[left]}' and [${right}]='${chars[right]}'
            </div>
        `;

        setTimeout(() => {
            if (chars[left] !== chars[right]) {
                isPalindrome = false;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Mismatch Found:</strong> '${chars[left]}'  '${chars[right]}' - Not a palindrome
                    </div>
                `;
                
                leftChar.classList.add('palindrome-invalid');
                rightChar.classList.add('palindrome-invalid');
            } else {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Match:</strong> '${chars[left]}' = '${chars[right]}' - Continue checking
                    </div>
                `;
                
                leftChar.classList.add('palindrome-valid');
                rightChar.classList.add('palindrome-valid');
            }

            // Move pointers
            left++;
            right--;

            // Remove highlight for next step
            setTimeout(() => {
                leftChar.classList.remove('highlight');
                rightChar.classList.remove('highlight');
                executePalindromeStep();
            }, 1000);
        }, 1500);
    }

    // Start algorithm
    if (n === 0) {
        explanation.innerHTML = `<strong class="text-warning">Empty string after cleaning - considered a palindrome</strong>`;
        resultValue.innerHTML = '<span class="text-success">Valid Palindrome </span>';
        resultValue.classList.add('palindrome-valid');
        resultDiv.style.display = 'block';
        continueButton.style.display = 'block';
        continueButton.addEventListener('click', returnToOriginalAfterPalindrome);
    } else {
        executePalindromeStep();
    }
}

// NEW: Return to Original after Palindrome Check
function returnToOriginalAfterPalindrome() {
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    isPalindromeOperationRunning = false;
    
    logOperation('Palindrome check completed - returned to array operations', 'info');
    showNotification('Returned to array operations after palindrome check', 'success');
}

// NEW: Find Anagrams Handler
function handleFindAnagrams() {
    if (isAnagramOperationRunning) {
        showNotification('An anagram check is already in progress', 'warning');
        return;
    }

    const string1 = prompt('Enter first string:');
    if (!string1) {
        showNotification('No first string entered', 'info');
        return;
    }

    const string2 = prompt('Enter second string:');
    if (!string2) {
        showNotification('No second string entered', 'info');
        return;
    }

    isAnagramOperationRunning = true;
    performAnagramCheck(string1, string2);
}

// NEW: Perform Anagram Check with Animation
function performAnagramCheck(string1, string2) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'string-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find All Anagrams</h5>
        
        <div class="string-input-group">
            <div class="array-label">First String</div>
            <div class="string-display" id="firstString">${string1}</div>
        </div>

        <div class="string-input-group">
            <div class="array-label">Second String</div>
            <div class="string-display" id="secondString">${string2}</div>
        </div>

        <div class="operation-arrow">
            <i class="fas fa-exchange-alt"></i>
        </div>

        <div class="string-input-group">
            <div class="array-label">Character Frequency Analysis</div>
            <div class="character-container" id="frequencyContainer"></div>
        </div>

        <div class="operation-explanation">
            <p class="mb-2"><strong>Anagram Check:</strong> Two strings that contain the same characters in different order</p>
            <p class="mb-0" id="anagramExplanation">Starting anagram check...</p>
        </div>

        <div class="algorithm-steps mt-3" id="anagramStepsContainer">
            <h6 class="text-center">Anagram Check Steps</h6>
            <div class="steps-container" id="anagramSteps"></div>
        </div>

        <div class="stats-card mt-3" id="anagramResult" style="display: none;">
            <div>Result</div>
            <div class="stats-value" id="anagramResultValue">-</div>
        </div>

        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterAnagram" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Array Operations
        </button>
    `;

    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);

    executeAnagramAlgorithm(string1, string2);
}

// NEW: Execute Anagram Algorithm
function executeAnagramAlgorithm(string1, string2) {
    const frequencyContainer = document.getElementById('frequencyContainer');
    const explanation = document.getElementById('anagramExplanation');
    const stepsContainer = document.getElementById('anagramSteps');
    const resultDiv = document.getElementById('anagramResult');
    const resultValue = document.getElementById('anagramResultValue');
    const continueButton = document.getElementById('continueAfterAnagram');

    // Clean strings: convert to lowercase and sort characters
    const cleanStr1 = string1.toLowerCase().replace(/[^a-z]/g, '');
    const cleanStr2 = string2.toLowerCase().replace(/[^a-z]/g, '');
    
    const sortedStr1 = cleanStr1.split('').sort().join('');
    const sortedStr2 = cleanStr2.split('').sort().join('');
    
    const isAnagram = sortedStr1 === sortedStr2;
    let step = 0;

    // Display unique characters from both strings
    const allChars = [...new Set([...cleanStr1, ...cleanStr2])].sort();
    
    allChars.forEach(char => {
        const charBox = document.createElement('div');
        charBox.className = 'character-box';
        charBox.textContent = char;
        charBox.id = `char-${char}`;
        frequencyContainer.appendChild(charBox);
    });

    function executeAnagramStep() {
        if (step >= allChars.length) {
            // Algorithm completed
            if (isAnagram) {
                explanation.innerHTML = `<strong class="text-success">Anagram Check Complete!</strong> The strings are anagrams.`;
                resultValue.innerHTML = '<span class="text-success">Anagrams </span>';
                resultValue.classList.add('anagram-valid');
            } else {
                explanation.innerHTML = `<strong class="text-danger">Anagram Check Complete!</strong> The strings are not anagrams.`;
                resultValue.innerHTML = '<span class="text-danger">Not Anagrams </span>';
                resultValue.classList.add('anagram-invalid');
            }

            resultDiv.style.display = 'block';
            continueButton.style.display = 'block';

            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterAnagram();
            }, 10000);

            continueButton.addEventListener('click', returnToOriginalAfterAnagram);
            return;
        }

        const char = allChars[step];
        step++;
        
        const count1 = (cleanStr1.match(new RegExp(char, 'g')) || []).length;
        const count2 = (cleanStr2.match(new RegExp(char, 'g')) || []).length;
        
        explanation.innerHTML = `Step ${step}: Checking frequency of character '${char}'`;

        const charElement = document.getElementById(`char-${char}`);
        charElement.classList.add('highlight');

        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Character '${char}' - String1: ${count1} occurrence(s), String2: ${count2} occurrence(s)
            </div>
        `;

        setTimeout(() => {
            if (count1 !== count2) {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Frequency Mismatch:</strong> '${char}' appears ${count1} time(s) in first string but ${count2} time(s) in second string
                    </div>
                `;
                charElement.classList.add('anagram-invalid');
            } else {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Frequency Match:</strong> '${char}' appears equally in both strings (${count1} time(s))
                    </div>
                `;
                charElement.classList.add('anagram-valid');
            }

            // Remove highlight for next step
            setTimeout(() => {
                charElement.classList.remove('highlight');
                executeAnagramStep();
            }, 1000);
        }, 1500);
    }

    // Start algorithm
    if (cleanStr1.length !== cleanStr2.length) {
        explanation.innerHTML = `<strong class="text-warning">Different lengths - cannot be anagrams</strong>`;
        resultValue.innerHTML = '<span class="text-danger">Not Anagrams </span>';
        resultValue.classList.add('anagram-invalid');
        resultDiv.style.display = 'block';
        continueButton.style.display = 'block';
        continueButton.addEventListener('click', returnToOriginalAfterAnagram);
    } else {
        executeAnagramStep();
    }
}

// NEW: Return to Original after Anagram Check
function returnToOriginalAfterAnagram() {
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    isAnagramOperationRunning = false;
    
    logOperation('Anagram check completed - returned to array operations', 'info');
    showNotification('Returned to array operations after anagram check', 'success');
}
// NEW: Range Sum Query Handler
function handleRangeSumQuery() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isRangeSumRunning) {
        showNotification('A range sum operation is already in progress', 'warning');
        return;
    }
    
    const start = parseInt(rangeSumStart.value);
    const end = parseInt(rangeSumEnd.value);
    const n = myArray.length;
    
    // Validation
    if (isNaN(start) || isNaN(end)) {
        showNotification('Please enter valid start and end indices', 'danger');
        rangeSumStart.focus();
        return;
    }
    
    if (start < 0 || start >= n || end < 0 || end >= n) {
        showNotification(`Indices should be between 0 and ${n-1}`, 'danger');
        rangeSumStart.focus();
        return;
    }
    
    if (end < start) {
        showNotification('End index should be greater than or equal to start index', 'danger');
        rangeSumStart.focus();
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = start; i <= end; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Range sum query requires all elements in the range to be numbers', 'danger');
        return;
    }
    
    isRangeSumRunning = true;
    
    // Store original array
    originalArrayForRangeSum = [...myArray];
    
    // Perform range sum visualization
    performRangeSumVisualization(start, end);
}
// NEW: Perform Range Sum Visualization
function performRangeSumVisualization(start, end) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Range Sum Query (Indices ${start} to ${end})</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalRangeSumArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Range Sum Query:</strong> Calculating sum of elements from index ${start} to ${end}</p>
            <p class="mb-0" id="rangeSumExplanation">Starting range sum calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="rangeSumStepsContainer">
            <h6 class="text-center">Range Sum Calculation Steps</h6>
            <div class="steps-container" id="rangeSumSteps"></div>
        </div>
        
        <div class="range-sum-results mt-3" id="rangeSumResults" style="display: none;">
            <h6 class="text-center">Range Sum Result</h6>
            <div class="stats-card">
                <div>Sum of elements from index ${start} to ${end}</div>
                <div class="stats-value" id="rangeSumValue">0</div>
            </div>
            <div class="stats-card mt-2">
                <div>Elements included</div>
                <div class="stats-value" id="rangeSumElements">-</div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterRangeSum" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForRangeSum, 'originalRangeSumArray');
    
    performRangeSumAnimation(start, end);
}
// NEW: Perform Range Sum Animation
function performRangeSumAnimation(start, end) {
    const arrayContainer = document.getElementById('originalRangeSumArray');
    const explanation = document.getElementById('rangeSumExplanation');
    const stepsContainer = document.getElementById('rangeSumSteps');
    const rangeSumResults = document.getElementById('rangeSumResults');
    const rangeSumValue = document.getElementById('rangeSumValue');
    const rangeSumElements = document.getElementById('rangeSumElements');
    const continueButton = document.getElementById('continueAfterRangeSum');
    
    const arr = originalArrayForRangeSum;
    let currentSum = 0;
    let currentIndex = start;
    let step = 0;
    const includedElements = [];
    
    function performRangeSumStep() {
        if (currentIndex > end) {
            // Calculation completed
            explanation.innerHTML = `<strong>Range Sum Calculation Completed!</strong>`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Total sum = ${currentSum}
                </div>
            `;
            
            // Show results
            rangeSumValue.textContent = currentSum;
            rangeSumElements.textContent = `[${includedElements.join(' + ')}]`;
            rangeSumResults.style.display = 'block';
            
            // Highlight all range elements
            const elements = arrayContainer.querySelectorAll('.array-element');
            for (let i = start; i <= end; i++) {
                setTimeout(() => {
                    elements[i].querySelector('.element-value').classList.add('range-sum-highlight');
                }, (i - start) * 200);
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterRangeSum();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterRangeSum);
            
            return;
        }
        
        step++;
        const currentValue = parseFloat(arr[currentIndex]);
        
        explanation.innerHTML = `Step ${step}: Adding element at index ${currentIndex} = ${currentValue}`;
        
        // Highlight current element
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElement = elements[currentIndex].querySelector('.element-value');
        currentElement.classList.add('range-sum-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> Current sum = ${currentSum} + [${currentIndex}]=${currentValue} = ${currentSum + currentValue}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Add to sum
            currentSum += currentValue;
            includedElements.push(currentValue);
            
            // Update current element highlight
            currentElement.classList.remove('range-sum-current');
            currentElement.classList.add('range-sum-highlight');
            
            // Show intermediate sum
            rangeSumValue.textContent = currentSum;
            rangeSumElements.textContent = `[${includedElements.join(' + ')}]`;
            rangeSumResults.style.display = 'block';
            
            // Move to next index
            currentIndex++;
            performRangeSumStep();
        }, 1500);
    }
    
    // Start calculation
    performRangeSumStep();
}
// NEW: Return to Original after Range Sum
function returnToOriginalAfterRangeSum() {
    // Reset to original array
    myArray = [...originalArrayForRangeSum];
    originalArrayForRangeSum = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isRangeSumRunning = false;
    
    // Clear inputs
    rangeSumStart.value = '';
    rangeSumEnd.value = '';
    
    logOperation('Range sum query completed - returned to original array', 'info');
    showNotification('Returned to original array after range sum query', 'success');
}
// NEW: Daily Temperatures Handler
function handleDailyTemperatures() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isDailyTemperaturesRunning) {
        showNotification('Daily temperatures algorithm is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Daily temperatures algorithm requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForDailyTemperatures = [...myArray];
    
    // Show daily temperatures visualization
    showDailyTemperaturesVisualization();
}
// NEW: Show Daily Temperatures Visualization
function showDailyTemperaturesVisualization() {
    isDailyTemperaturesRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Daily Temperatures Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Temperatures Array</div>
            <div class="original-array-container" id="originalDailyTempArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Result (Days until Warmer)</div>
            <div class="transformed-array-container" id="resultDailyTempArray"></div>
        </div>
        
        <div class="daily-temp-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> For each day, find how many days until a warmer temperature</p>
            <p class="mb-0" id="dailyTempExplanation">Initializing daily temperatures algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="dailyTempStepsContainer">
            <h6 class="text-center">Algorithm Steps (Monotonic Stack)</h6>
            <div class="steps-container" id="dailyTempSteps"></div>
        </div>
        
        <div class="daily-temp-result mt-3" id="dailyTempResult" style="display: none;">
            <h6 class="text-center">Final Result</h6>
            <div class="row text-center" id="finalResultDisplay"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterDailyTemp" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForDailyTemperatures, 'originalDailyTempArray');
    
    // Initialize result array with zeros
    const resultArray = Array(originalArrayForDailyTemperatures.length).fill(0);
    renderArrayInContainer(resultArray, 'resultDailyTempArray');
    
    performDailyTemperaturesAnimation();
}
// NEW: Perform Daily Temperatures Animation
function performDailyTemperaturesAnimation() {
    const originalContainer = document.getElementById('originalDailyTempArray');
    const resultContainer = document.getElementById('resultDailyTempArray');
    const explanation = document.getElementById('dailyTempExplanation');
    const stepsContainer = document.getElementById('dailyTempSteps');
    const resultDisplay = document.getElementById('finalResultDisplay');
    const resultSection = document.getElementById('dailyTempResult');
    const continueButton = document.getElementById('continueAfterDailyTemp');
    
    const temperatures = originalArrayForDailyTemperatures.map(val => parseFloat(val));
    const n = temperatures.length;
    const answer = Array(n).fill(0);
    const stack = [];
    let currentDay = 0;
    let stepCount = 0;
    
    function performDailyTempStep() {
        if (currentDay >= n) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> All days processed.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Daily temperatures algorithm completed. Final result computed.
                </div>
            `;
            
            // Show final result
            resultSection.style.display = 'block';
            resultDisplay.innerHTML = `
                <div class="col-md-6">
                    <div class="stats-card">
                        <div>Input Temperatures</div>
                        <div class="stats-value">[${temperatures.join(', ')}]</div>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="stats-card">
                        <div>Output (Days until Warmer)</div>
                        <div class="stats-value">[${answer.join(', ')}]</div>
                    </div>
                </div>
            `;
            
            // Highlight all elements in result
            const resultElements = resultContainer.querySelectorAll('.array-element');
            resultElements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('daily-temp-warmer');
                }, index * 200);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterDailyTemperatures();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterDailyTemperatures);
            
            return;
        }
        
        stepCount++;
        const currentTemp = temperatures[currentDay];
        
        // Highlight current day
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentDay].querySelector('.element-value');
        currentElement.classList.add('daily-temp-current');
        
        explanation.innerHTML = `Day ${currentDay}: Processing temperature ${currentTemp}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${stepCount}:</strong> Processing day ${currentDay} (temp: ${currentTemp})
            </div>
        `;
        
        setTimeout(() => {
            // Check stack for warmer temperatures
            let foundWarmer = false;
            
            function processStack() {
                if (stack.length === 0) {
                    // No more elements in stack to compare
                    stack.push(currentDay);
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${stepCount}.${stack.length}:</strong> No warmer days found in stack. Pushing day ${currentDay} to stack.
                        </div>
                    `;
                    
                    // Highlight stack elements
                    highlightStackElements();
                    moveToNextDay();
                    return;
                }
                
                const prevIndex = stack[stack.length - 1];
                const prevTemp = temperatures[prevIndex];
                
                if (currentTemp > prevTemp) {
                    // Found a warmer day
                    foundWarmer = true;
                    const poppedIndex = stack.pop();
                    answer[poppedIndex] = currentDay - poppedIndex;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${stepCount}.${stack.length + 1}:</strong> Day ${currentDay} (${currentTemp}) > Day ${poppedIndex} (${prevTemp}). 
                            Answer[${poppedIndex}] = ${currentDay} - ${poppedIndex} = ${answer[poppedIndex]}
                        </div>
                    `;
                    
                    // Update result display
                    updateResultDisplay(poppedIndex, answer[poppedIndex]);
                    
                    // Highlight the warmer day connection
                    const prevElement = originalElements[poppedIndex].querySelector('.element-value');
                    const resultElement = resultContainer.querySelectorAll('.array-element')[poppedIndex].querySelector('.element-value');
                    
                    prevElement.classList.add('daily-temp-warmer');
                    resultElement.classList.add('daily-temp-warmer');
                    resultElement.textContent = answer[poppedIndex];
                    
                    setTimeout(() => {
                        prevElement.classList.remove('daily-temp-warmer');
                        prevElement.classList.add('daily-temp-processed');
                        
                        // Continue processing stack
                        processStack();
                    }, 2000);
                    
                } else {
                    // Current temp is not warmer than stack top
                    stack.push(currentDay);
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${stepCount}.${stack.length}:</strong> Day ${currentDay} (${currentTemp})  Day ${prevIndex} (${prevTemp}). Pushing to stack.
                        </div>
                    `;
                    
                    highlightStackElements();
                    moveToNextDay();
                }
            }
            
            function highlightStackElements() {
                // Highlight all elements in stack
                originalElements.forEach((el, index) => {
                    const valueDiv = el.querySelector('.element-value');
                    if (stack.includes(index)) {
                        valueDiv.classList.add('daily-temp-stack');
                    } else {
                        valueDiv.classList.remove('daily-temp-stack');
                    }
                });
            }
            
            function updateResultDisplay(index, value) {
                const resultElements = resultContainer.querySelectorAll('.array-element');
                resultElements[index].querySelector('.element-value').textContent = value;
            }
            
            function moveToNextDay() {
                currentElement.classList.remove('daily-temp-current');
                currentElement.classList.add('daily-temp-processed');
                
                currentDay++;
                setTimeout(performDailyTempStep, 1500);
            }
            
            // Start processing the stack
            processStack();
            
        }, 1500);
    }
    
    // Start the algorithm
    performDailyTempStep();
}
// NEW: Return to Original after Daily Temperatures
function returnToOriginalAfterDailyTemperatures() {
    // Reset to original array
    myArray = [...originalArrayForDailyTemperatures];
    originalArrayForDailyTemperatures = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isDailyTemperaturesRunning = false;
    
    logOperation('Daily temperatures algorithm completed - returned to original array', 'info');
    showNotification('Returned to original array after daily temperatures algorithm', 'success');
}
// NEW: Find First and Last Position Handler
function handleFindFirstLast() {
    const target = firstLastTarget.value.trim();
    
    if (target === '') {
        showNotification('Please enter a target element to search for', 'warning');
        firstLastTarget.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isFirstLastSearchRunning) {
        showNotification('First/last position search is already in progress', 'warning');
        return;
    }
    
    isFirstLastSearchRunning = true;
    
    // Store original array
    originalArrayForFirstLast = [...myArray];
    
    // Check if array is sorted, if not, sort it
    if (!isArraySorted(myArray)) {
        showNotification('Array is not sorted. Auto-sorting array for binary search...', 'info');
        
        // Sort the array numerically if possible
        const isNumeric = !myArray.some(item => isNaN(parseFloat(item)));
        if (isNumeric) {
            myArray.sort((a, b) => parseFloat(a) - parseFloat(b));
        } else {
            myArray.sort();
        }
        
        renderArray();
        updateStats();
        
        logOperation('Array auto-sorted for first/last position search', 'warning');
    }
    
    // Perform first/last position search
    performFirstLastSearch(target);
}

// NEW: Check if array is sorted
function isArraySorted(arr) {
    const isNumeric = !arr.some(item => isNaN(parseFloat(item)));
    
    for (let i = 1; i < arr.length; i++) {
        if (isNumeric) {
            if (parseFloat(arr[i]) < parseFloat(arr[i - 1])) {
                return false;
            }
        } else {
            if (arr[i] < arr[i - 1]) {
                return false;
            }
        }
    }
    return true;
}

// NEW: Perform First and Last Position Search with Visualization
function performFirstLastSearch(target) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find First & Last Position of "${target}"</h5>
        
        <div class="array-group">
            <div class="array-label">Sorted Array</div>
            <div class="original-array-container" id="firstLastArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Two binary searches - one for first occurrence, one for last occurrence</p>
            <p class="mb-0" id="firstLastExplanation">Starting binary search for first occurrence...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="firstLastStepsContainer">
            <h6 class="text-center">Binary Search Steps</h6>
            <div class="steps-container" id="firstLastSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>First Occurrence</div>
            <div class="stats-value" id="firstOccurrenceValue">-</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Last Occurrence</div>
            <div class="stats-value" id="lastOccurrenceValue">-</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Total Occurrences</div>
            <div class="stats-value" id="totalOccurrencesValue">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterFirstLast" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(myArray, 'firstLastArray');
    
    executeFirstLastSearchAlgorithm(target);
}

// NEW: Execute First and Last Position Search Algorithm
function executeFirstLastSearchAlgorithm(target) {
    const arrayContainer = document.getElementById('firstLastArray');
    const explanation = document.getElementById('firstLastExplanation');
    const stepsContainer = document.getElementById('firstLastSteps');
    const firstOccurrenceValue = document.getElementById('firstOccurrenceValue');
    const lastOccurrenceValue = document.getElementById('lastOccurrenceValue');
    const totalOccurrencesValue = document.getElementById('totalOccurrencesValue');
    const continueButton = document.getElementById('continueAfterFirstLast');
    
    const arr = [...myArray];
    const targetNum = isNaN(parseFloat(target)) ? target : parseFloat(target);
    let step = 0;
    
    // Convert array elements to numbers if target is numeric
    const numericArr = arr.map(item => isNaN(parseFloat(item)) ? item : parseFloat(item));
    
    function findFirstOccurrence() {
        let left = 0;
        let right = numericArr.length - 1;
        let firstOccurrence = -1;
        
        explanation.innerHTML = `Searching for FIRST occurrence of ${target}...`;
        
        function performFirstSearchStep() {
            if (left > right) {
                // Search completed for first occurrence
                stepsContainer.innerHTML += `
                    <div class="algorithm-step ${firstOccurrence !== -1 ? 'active' : ''}">
                        <strong>First Search Complete:</strong> ${firstOccurrence !== -1 ? 
                            `Found at index ${firstOccurrence}` : 'Not found'}
                    </div>
                `;
                
                firstOccurrenceValue.textContent = firstOccurrence !== -1 ? firstOccurrence : 'Not found';
                
                // Start searching for last occurrence
                setTimeout(() => {
                    findLastOccurrence(firstOccurrence);
                }, 1500);
                return;
            }
            
            step++;
            const mid = Math.floor((left + right) / 2);
            
            // Update explanation
            explanation.innerHTML = `Step ${step}: First search - Left=${left}, Right=${right}, Mid=${mid}`;
            
            // Highlight current search range
            const elements = arrayContainer.querySelectorAll('.array-element');
            
            // Highlight left, right, and mid pointers
            if (left <= right) {
                elements[left].querySelector('.element-value').classList.add('binary-search-left');
                elements[right].querySelector('.element-value').classList.add('binary-search-right');
                elements[mid].querySelector('.element-value').classList.add('binary-search-mid');
            }
            
            const midVal = numericArr[mid];
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}:</strong> First search - Checking mid[${mid}]=${midVal} vs target=${target}
                </div>
            `;
            
            // Scroll steps container
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            setTimeout(() => {
                // Remove highlights
                if (left <= right) {
                    elements[left].querySelector('.element-value').classList.remove('binary-search-left');
                    elements[right].querySelector('.element-value').classList.remove('binary-search-right');
                    elements[mid].querySelector('.element-value').classList.remove('binary-search-mid');
                }
                
                if (midVal < targetNum) {
                    // Search right half
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step}.1:</strong> ${midVal} < ${target}  Search RIGHT (left = ${mid + 1})
                        </div>
                    `;
                    left = mid + 1;
                } else {
                    // Search left half (including when equal, to find first occurrence)
                    if (midVal === targetNum) {
                        firstOccurrence = mid;
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Step ${step}.1:</strong> ${midVal} = ${target}  Found potential first occurrence at ${mid}, continue LEFT
                            </div>
                        `;
                        
                        // Highlight the found occurrence
                        elements[mid].querySelector('.element-value').classList.add('first-occurrence');
                    } else {
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Step ${step}.1:</strong> ${midVal} > ${target}  Search LEFT (right = ${mid - 1})
                            </div>
                        `;
                    }
                    right = mid - 1;
                }
                
                performFirstSearchStep();
            }, 2000);
        }
        
        performFirstSearchStep();
    }
    
    function findLastOccurrence(firstOccurrence) {
        if (firstOccurrence === -1) {
            // Element not found at all
            explanation.innerHTML = `<strong>Element ${target} not found in array</strong>`;
            lastOccurrenceValue.textContent = 'Not found';
            totalOccurrencesValue.textContent = '0';
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Final Result:</strong> Element ${target} not found in array
                </div>
            `;
            
            continueButton.style.display = 'block';
            setTimeout(() => {
                returnToOriginalAfterFirstLast();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterFirstLast);
            return;
        }
        
        let left = 0;
        let right = numericArr.length - 1;
        let lastOccurrence = -1;
        
        explanation.innerHTML = `Searching for LAST occurrence of ${target}...`;
        
        function performLastSearchStep() {
            if (left > right) {
                // Search completed for last occurrence
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Last Search Complete:</strong> Found at index ${lastOccurrence}
                    </div>
                `;
                
                lastOccurrenceValue.textContent = lastOccurrence;
                const totalOccurrences = lastOccurrence - firstOccurrence + 1;
                totalOccurrencesValue.textContent = totalOccurrences;
                
                // Show final result
                explanation.innerHTML = `<strong>Search Complete!</strong> First occurrence: ${firstOccurrence}, Last occurrence: ${lastOccurrence}, Total: ${totalOccurrences}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final Result:</strong> First occurrence at ${firstOccurrence}, Last occurrence at ${lastOccurrence}, Total occurrences: ${totalOccurrences}
                    </div>
                `;
                
                // Highlight all occurrences
                const elements = arrayContainer.querySelectorAll('.array-element');
                for (let i = firstOccurrence; i <= lastOccurrence; i++) {
                    setTimeout(() => {
                        elements[i].querySelector('.element-value').classList.add('all-occurrence');
                    }, (i - firstOccurrence) * 200);
                }
                
                // Highlight first and last specifically
                setTimeout(() => {
                    elements[firstOccurrence].querySelector('.element-value').classList.add('first-occurrence');
                    elements[lastOccurrence].querySelector('.element-value').classList.add('last-occurrence');
                }, (lastOccurrence - firstOccurrence + 1) * 200 + 500);
                
                continueButton.style.display = 'block';
                
                // Auto-return after 10 seconds
                setTimeout(() => {
                    returnToOriginalAfterFirstLast();
                }, 10000);
                
                continueButton.addEventListener('click', returnToOriginalAfterFirstLast);
                return;
            }
            
            step++;
            const mid = Math.floor((left + right) / 2);
            
            // Update explanation
            explanation.innerHTML = `Step ${step}: Last search - Left=${left}, Right=${right}, Mid=${mid}`;
            
            // Highlight current search range
            const elements = arrayContainer.querySelectorAll('.array-element');
            
            // Highlight left, right, and mid pointers
            if (left <= right) {
                elements[left].querySelector('.element-value').classList.add('binary-search-left');
                elements[right].querySelector('.element-value').classList.add('binary-search-right');
                elements[mid].querySelector('.element-value').classList.add('binary-search-mid');
            }
            
            const midVal = numericArr[mid];
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}:</strong> Last search - Checking mid[${mid}]=${midVal} vs target=${target}
                </div>
            `;
            
            // Scroll steps container
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            setTimeout(() => {
                // Remove highlights
                if (left <= right) {
                    elements[left].querySelector('.element-value').classList.remove('binary-search-left');
                    elements[right].querySelector('.element-value').classList.remove('binary-search-right');
                    elements[mid].querySelector('.element-value').classList.remove('binary-search-mid');
                }
                
                if (midVal > targetNum) {
                    // Search left half
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step}.1:</strong> ${midVal} > ${target}  Search LEFT (right = ${mid - 1})
                        </div>
                    `;
                    right = mid - 1;
                } else {
                    // Search right half (including when equal, to find last occurrence)
                    if (midVal === targetNum) {
                        lastOccurrence = mid;
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Step ${step}.1:</strong> ${midVal} = ${target}  Found potential last occurrence at ${mid}, continue RIGHT
                            </div>
                        `;
                        
                        // Highlight the found occurrence
                        elements[mid].querySelector('.element-value').classList.add('last-occurrence');
                    } else {
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Step ${step}.1:</strong> ${midVal} < ${target}  Search RIGHT (left = ${mid + 1})
                            </div>
                        `;
                    }
                    left = mid + 1;
                }
                
                performLastSearchStep();
            }, 2000);
        }
        
        performLastSearchStep();
    }
    
    // Start the search process
    findFirstOccurrence();
}

// NEW: Return to Original after First/Last Search
function returnToOriginalAfterFirstLast() {
    // Reset to original array
    myArray = [...originalArrayForFirstLast];
    originalArrayForFirstLast = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isFirstLastSearchRunning = false;
    
    // Clear input
    firstLastTarget.value = '';
    
    logOperation('First/last position search completed - returned to original array', 'info');
    showNotification('Returned to original array after first/last position search', 'success');
}
// NEW: Find Palindromic Substrings Handler
function handleFindPalindromicSubstrings() {
    const inputString = palindromeInput.value.trim();
    
    if (inputString === '') {
        showNotification('Please enter a string to find palindromic substrings', 'danger');
        palindromeInput.focus();
        return;
    }
    
    if (isPalindromicOperationRunning) {
        showNotification('A palindrome operation is already in progress', 'warning');
        return;
    }
    
    isPalindromicOperationRunning = true;
    originalStringBeforePalindrome = inputString;
    
    // Store original array
    originalArrayBeforePalindrome = [...myArray];
    
    // Convert string to array of characters for visualization
    myArray = inputString.split('');
    
    // Show palindrome visualization
    showPalindromicSubstringsVisualization(inputString);
}

// NEW: Find Longest Palindromic Substring Handler
function handleFindLongestPalindromicSubstring() {
    let inputString = longestPalindromeInput.value.trim();
    
    // If empty, use the value from the other input field
    if (inputString === '') {
        inputString = palindromeInput.value.trim();
    }
    
    if (inputString === '') {
        showNotification('Please enter a string to find the longest palindromic substring', 'danger');
        longestPalindromeInput.focus();
        return;
    }
    
    if (isPalindromicOperationRunning) {
        showNotification('A palindrome operation is already in progress', 'warning');
        return;
    }
    
    isPalindromicOperationRunning = true;
    originalStringBeforePalindrome = inputString;
    
    // Store original array
    originalArrayBeforePalindrome = [...myArray];
    
    // Convert string to array of characters for visualization
    myArray = inputString.split('');
    
    // Show longest palindrome visualization
    showLongestPalindromicSubstringVisualization(inputString);
}
// NEW: Show Palindromic Substrings Visualization
function showPalindromicSubstringsVisualization(inputString) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find All Palindromic Substrings</h5>
        
        <div class="array-group">
            <div class="array-label">Input String: "${inputString}"</div>
            <div class="original-array-container" id="palindromeArray"></div>
        </div>
        
        <div class="palindrome-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Expand Around Center - Check all possible centers</p>
            <p class="mb-0" id="palindromeExplanation">Initializing palindrome search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="palindromeStepsContainer">
            <h6 class="text-center">Palindrome Detection Steps</h6>
            <div class="steps-container" id="palindromeSteps"></div>
        </div>
        
        <div class="palindrome-stats mt-3">
            <div>Total Palindromic Substrings Found</div>
            <div class="stats-value" id="palindromeCount">0</div>
            <div id="palindromesList" class="mt-2"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPalindrome" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array (Auto in 10s)
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(myArray, 'palindromeArray');
    
    performPalindromicSubstringsSearch(inputString);
}

// NEW: Show Longest Palindromic Substring Visualization
function showLongestPalindromicSubstringVisualization(inputString) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find Longest Palindromic Substring</h5>
        
        <div class="array-group">
            <div class="array-label">Input String: "${inputString}"</div>
            <div class="original-array-container" id="longestPalindromeArray"></div>
        </div>
        
        <div class="palindrome-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Expand Around Center - Find maximum length palindrome</p>
            <p class="mb-0" id="longestPalindromeExplanation">Initializing longest palindrome search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="longestPalindromeStepsContainer">
            <h6 class="text-center">Longest Palindrome Detection Steps</h6>
            <div class="steps-container" id="longestPalindromeSteps"></div>
        </div>
        
        <div class="palindrome-stats mt-3">
            <div>Longest Palindromic Substring</div>
            <div class="stats-value" id="longestPalindromeResult">-</div>
            <div>Length</div>
            <div class="stats-value" id="longestPalindromeLength">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterLongestPalindrome" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array (Auto in 10s)
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(myArray, 'longestPalindromeArray');
    
    performLongestPalindromicSubstringSearch(inputString);
}
// NEW: Show Palindromic Substrings Visualization
function showPalindromicSubstringsVisualization(inputString) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find All Palindromic Substrings</h5>
        
        <div class="array-group">
            <div class="array-label">Input String: "${inputString}"</div>
            <div class="original-array-container" id="palindromeArray"></div>
        </div>
        
        <div class="palindrome-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Expand Around Center - Check all possible centers</p>
            <p class="mb-0" id="palindromeExplanation">Initializing palindrome search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="palindromeStepsContainer">
            <h6 class="text-center">Palindrome Detection Steps</h6>
            <div class="steps-container" id="palindromeSteps"></div>
        </div>
        
        <div class="palindrome-stats mt-3">
            <div>Total Palindromic Substrings Found</div>
            <div class="stats-value" id="palindromeCount">0</div>
            <div id="palindromesList" class="mt-2"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPalindrome" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array (Auto in 10s)
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(myArray, 'palindromeArray');
    
    performPalindromicSubstringsSearch(inputString);
}

// NEW: Show Longest Palindromic Substring Visualization
function showLongestPalindromicSubstringVisualization(inputString) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find Longest Palindromic Substring</h5>
        
        <div class="array-group">
            <div class="array-label">Input String: "${inputString}"</div>
            <div class="original-array-container" id="longestPalindromeArray"></div>
        </div>
        
        <div class="palindrome-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Expand Around Center - Find maximum length palindrome</p>
            <p class="mb-0" id="longestPalindromeExplanation">Initializing longest palindrome search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="longestPalindromeStepsContainer">
            <h6 class="text-center">Longest Palindrome Detection Steps</h6>
            <div class="steps-container" id="longestPalindromeSteps"></div>
        </div>
        
        <div class="palindrome-stats mt-3">
            <div>Longest Palindromic Substring</div>
            <div class="stats-value" id="longestPalindromeResult">-</div>
            <div>Length</div>
            <div class="stats-value" id="longestPalindromeLength">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterLongestPalindrome" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array (Auto in 10s)
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(myArray, 'longestPalindromeArray');
    
    performLongestPalindromicSubstringSearch(inputString);
}
// NEW: Perform Palindromic Substrings Search with Animation
function performPalindromicSubstringsSearch(inputString) {
    const arrayContainer = document.getElementById('palindromeArray');
    const explanation = document.getElementById('palindromeExplanation');
    const stepsContainer = document.getElementById('palindromeSteps');
    const palindromeCount = document.getElementById('palindromeCount');
    const palindromesList = document.getElementById('palindromesList');
    const continueButton = document.getElementById('continueAfterPalindrome');
    
    const chars = inputString.split('');
    const n = chars.length;
    let palindromes = [];
    let step = 0;
    
    function expandAroundCenter(left, right) {
        return new Promise((resolve) => {
            let currentLeft = left;
            let currentRight = right;
            let currentPalindrome = '';
            
            function expandStep() {
                if (currentLeft < 0 || currentRight >= n || chars[currentLeft] !== chars[currentRight]) {
                    resolve(palindromes);
                    return;
                }
                
                // Highlight current expansion
                const elements = arrayContainer.querySelectorAll('.array-element');
                
                // Highlight center for odd length
                if (currentLeft === currentRight) {
                    elements[currentLeft].querySelector('.element-value').classList.add('palindrome-center');
                }
                
                // Highlight expanding characters
                if (currentLeft !== currentRight) {
                    elements[currentLeft].querySelector('.element-value').classList.add('palindrome-expanding');
                    elements[currentRight].querySelector('.element-value').classList.add('palindrome-expanding');
                }
                
                currentPalindrome = chars.slice(currentLeft, currentRight + 1).join('');
                
                step++;
                explanation.innerHTML = `Step ${step}: Expanding around center - Found: "${currentPalindrome}"`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> Center [${currentLeft},${currentRight}], Found: "${currentPalindrome}"
                    </div>
                `;
                
                // Add to palindromes list if not already included (for single characters)
                if (currentPalindrome.length >= 1 && !palindromes.includes(currentPalindrome)) {
                    palindromes.push(currentPalindrome);
                    palindromeCount.textContent = palindromes.length;
                    
                    // Update palindromes list
                    palindromesList.innerHTML = `<small>Found: ${palindromes.join(', ')}</small>`;
                    
                    // Highlight found palindrome
                    setTimeout(() => {
                        for (let i = currentLeft; i <= currentRight; i++) {
                            elements[i].querySelector('.element-value').classList.add('palindrome-found');
                        }
                    }, 500);
                }
                
                setTimeout(() => {
                    // Remove highlights
                    if (currentLeft === currentRight) {
                        elements[currentLeft].querySelector('.element-value').classList.remove('palindrome-center');
                    }
                    if (currentLeft !== currentRight) {
                        elements[currentLeft].querySelector('.element-value').classList.remove('palindrome-expanding');
                        elements[currentRight].querySelector('.element-value').classList.remove('palindrome-expanding');
                    }
                    
                    // Continue expansion
                    currentLeft--;
                    currentRight++;
                    expandStep();
                }, 1500);
            }
            
            expandStep();
        });
    }
    
    async function performSearch() {
        for (let i = 0; i < n; i++) {
            // Odd length palindromes
            await expandAroundCenter(i, i);
            
            // Even length palindromes
            await expandAroundCenter(i, i + 1);
        }
        
        // Search completed
        explanation.innerHTML = `<strong>Search Completed!</strong> Found ${palindromes.length} palindromic substrings.`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Final:</strong> Total ${palindromes.length} palindromic substrings found: ${palindromes.join(', ')}
            </div>
        `;
        
        // Highlight all found palindromes briefly
        const elements = arrayContainer.querySelectorAll('.array-element');
        elements.forEach(el => {
            el.querySelector('.element-value').classList.add('palindrome-found');
        });
        
        continueButton.style.display = 'block';
        
        // Auto-return after 10 seconds
        setTimeout(() => {
            returnToOriginalAfterPalindrome();
        }, 10000);
        
        continueButton.addEventListener('click', returnToOriginalAfterPalindrome);
    }
    
    // Start search
    performSearch();
}

// NEW: Perform Longest Palindromic Substring Search with Animation
function performLongestPalindromicSubstringSearch(inputString) {
    const arrayContainer = document.getElementById('longestPalindromeArray');
    const explanation = document.getElementById('longestPalindromeExplanation');
    const stepsContainer = document.getElementById('longestPalindromeSteps');
    const longestPalindromeResult = document.getElementById('longestPalindromeResult');
    const longestPalindromeLength = document.getElementById('longestPalindromeLength');
    const continueButton = document.getElementById('continueAfterLongestPalindrome');
    
    const chars = inputString.split('');
    const n = chars.length;
    let longestPalindrome = '';
    let maxLength = 0;
    let step = 0;
    
    function expandAroundCenter(left, right, isEven = false) {
        return new Promise((resolve) => {
            let l = left;
            let r = right;
            let currentLength = 0;
            let currentPalindrome = '';
            
            function expandStep() {
                if (l < 0 || r >= n || chars[l] !== chars[r]) {
                    resolve({length: currentLength, palindrome: currentPalindrome});
                    return;
                }
                
                // Highlight current expansion
                const elements = arrayContainer.querySelectorAll('.array-element');
                
                if (l === r) {
                    elements[l].querySelector('.element-value').classList.add('palindrome-center');
                } else {
                    elements[l].querySelector('.element-value').classList.add('palindrome-expanding');
                    elements[r].querySelector('.element-value').classList.add('palindrome-expanding');
                }
                
                currentLength = r - l + 1;
                currentPalindrome = chars.slice(l, r + 1).join('');
                
                step++;
                const type = isEven ? 'Even' : 'Odd';
                explanation.innerHTML = `Step ${step}: ${type} expansion - Center [${l},${r}], Current: "${currentPalindrome}"`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step ${currentLength > maxLength ? 'active' : ''}">
                        <strong>Step ${step}:</strong> ${type} center [${l},${r}], Found: "${currentPalindrome}" (Length: ${currentLength})
                    </div>
                `;
                
                // Check if this is the new longest
                if (currentLength > maxLength) {
                    maxLength = currentLength;
                    longestPalindrome = currentPalindrome;
                    
                    longestPalindromeResult.textContent = `"${longestPalindrome}"`;
                    longestPalindromeLength.textContent = maxLength;
                    
                    // Highlight the new longest palindrome
                    setTimeout(() => {
                        // Remove previous longest highlights
                        elements.forEach(el => {
                            el.querySelector('.element-value').classList.remove('longest-palindrome');
                        });
                        
                        // Add new longest highlights
                        for (let i = l; i <= r; i++) {
                            elements[i].querySelector('.element-value').classList.add('longest-palindrome');
                        }
                    }, 500);
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>New Longest!</strong> "${longestPalindrome}" (Length: ${maxLength})
                        </div>
                    `;
                }
                
                setTimeout(() => {
                    // Remove temporary highlights
                    if (l === r) {
                        elements[l].querySelector('.element-value').classList.remove('palindrome-center');
                    } else {
                        elements[l].querySelector('.element-value').classList.remove('palindrome-expanding');
                        elements[r].querySelector('.element-value').classList.remove('palindrome-expanding');
                    }
                    
                    // Continue expansion
                    l--;
                    r++;
                    expandStep();
                }, 2000);
            }
            
            expandStep();
        });
    }
    
    async function performSearch() {
        for (let i = 0; i < n; i++) {
            // Odd length palindromes (single character center)
            const oddResult = await expandAroundCenter(i, i, false);
            
            // Even length palindromes (two character center)
            const evenResult = await expandAroundCenter(i, i + 1, true);
        }
        
        // Search completed
        explanation.innerHTML = `<strong>Search Completed!</strong> Longest palindromic substring: "${longestPalindrome}" (Length: ${maxLength})`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Final Result:</strong> Longest Palindromic Substring = "${longestPalindrome}" with length ${maxLength}
            </div>
        `;
        
        continueButton.style.display = 'block';
        
        // Auto-return after 10 seconds
        setTimeout(() => {
            returnToOriginalAfterPalindrome();
        }, 10000);
        
        continueButton.addEventListener('click', returnToOriginalAfterPalindrome);
    }
    
    // Start search
    performSearch();
}

// NEW: Return to Original after Palindrome Operations
function returnToOriginalAfterPalindrome() {
    // Reset to original array
    myArray = [...originalArrayBeforePalindrome];
    originalArrayBeforePalindrome = [];
    originalStringBeforePalindrome = "";
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isPalindromicOperationRunning = false;
    
    // Clear inputs
    palindromeInput.value = '';
    longestPalindromeInput.value = '';
    
    logOperation('Palindrome operation completed - returned to original array', 'info');
    showNotification('Returned to original array after palindrome operation', 'success');
}

// NEW: Handle Pattern Matching Selection
function handlePatternMatching(type) {
    if (isPatternMatchingRunning) {
        showNotification('A pattern matching operation is already in progress', 'warning');
        return;
    }
    
    currentPatternMatchingType = type;
    
    // Show input group
    patternMatchingGroup.style.display = 'block';
    
    // Update label based on type
    if (type === 'wildcard') {
        patternMatchingLabel.innerHTML = 'Wildcard Matching Details';
        patternPattern.placeholder = 'Enter wildcard pattern (e.g., a*b*)';
    } else {
        patternMatchingLabel.innerHTML = 'Regular Expression Matching Details';
        patternPattern.placeholder = 'Enter regex pattern (e.g., a.*b*)';
    }
    
    patternString.focus();
    
    logOperation(`Started ${type === 'wildcard' ? 'Wildcard' : 'Regular Expression'} Matching operation`, 'info');
}

// NEW: Confirm Pattern Matching Handler
function handleConfirmPatternMatching() {
    const str = patternString.value.trim();
    const pattern = patternPattern.value.trim();
    
    if (str === '') {
        showNotification('Please enter a string to match', 'danger');
        patternString.focus();
        return;
    }
    
    if (pattern === '') {
        showNotification('Please enter a pattern', 'danger');
        patternPattern.focus();
        return;
    }
    
    // Hide input group
    patternMatchingGroup.style.display = 'none';
    
    // Store original array
    originalArrayForPatternMatching = [...myArray];
    
    // Start pattern matching visualization
    if (currentPatternMatchingType === 'wildcard') {
        performWildcardMatching(str, pattern);
    } else {
        performRegexMatching(str, pattern);
    }
}

// NEW: Cancel Pattern Matching Handler
function handleCancelPatternMatching() {
    patternMatchingGroup.style.display = 'none';
    patternString.value = '';
    patternPattern.value = '';
    currentPatternMatchingType = null;
    
    logOperation('Cancelled pattern matching operation', 'info');
    showNotification('Pattern matching operation cancelled', 'info');
}

// NEW: Perform Wildcard Matching with Animation
function performWildcardMatching(str, pattern) {
    isPatternMatchingRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Wildcard Matching Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">String: "${str}"</div>
            <div class="original-array-container" id="stringDisplay"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Pattern: "${pattern}"</div>
            <div class="original-array-container" id="patternDisplay"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Dynamic Programming Table</div>
            <div class="transformed-array-container" id="dpTableDisplay"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Wildcard Matching:</strong> Check if string matches pattern with '*' and '?' wildcards</p>
            <p class="mb-0" id="wildcardExplanation">Initializing wildcard matching algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="wildcardStepsContainer">
            <h6 class="text-center">Wildcard Matching Steps</h6>
            <div class="steps-container" id="wildcardSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Matching Result</div>
            <div class="stats-value" id="wildcardResult">Processing...</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterWildcard" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display string and pattern
    renderStringAsArray(str, 'stringDisplay');
    renderPatternAsArray(pattern, 'patternDisplay');
    
    // Initialize DP table display
    initializeDPTable(str, pattern, 'dpTableDisplay');
    
    // Start wildcard matching animation
    executeWildcardMatching(str, pattern);
}

// NEW: Perform Regex Matching with Animation
function performRegexMatching(str, pattern) {
    isPatternMatchingRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Regular Expression Matching Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">String: "${str}"</div>
            <div class="original-array-container" id="stringDisplay"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Pattern: "${pattern}"</div>
            <div class="original-array-container" id="patternDisplay"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Dynamic Programming Table</div>
            <div class="transformed-array-container" id="dpTableDisplay"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Regular Expression Matching:</strong> Check if string matches pattern with '.' and '*' operators</p>
            <p class="mb-0" id="regexExplanation">Initializing regex matching algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="regexStepsContainer">
            <h6 class="text-center">Regex Matching Steps</h6>
            <div class="steps-container" id="regexSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Matching Result</div>
            <div class="stats-value" id="regexResult">Processing...</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterRegex" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display string and pattern
    renderStringAsArray(str, 'stringDisplay');
    renderPatternAsArray(pattern, 'patternDisplay');
    
    // Initialize DP table display
    initializeDPTable(str, pattern, 'dpTableDisplay');
    
    // Start regex matching animation
    executeRegexMatching(str, pattern);
}

// NEW: Render String as Array
function renderStringAsArray(str, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    for (let i = 0; i <= str.length; i++) {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        
        const valueDiv = document.createElement('div');
        valueDiv.className = 'element-value';
        
        if (i === 0) {
            valueDiv.textContent = ''; // Empty string symbol
            valueDiv.style.background = 'var(--secondary-color)';
        } else {
            valueDiv.textContent = str[i-1];
        }
        
        const indexDiv = document.createElement('div');
        indexDiv.className = 'element-index';
        indexDiv.textContent = i === 0 ? 'start' : `[${i-1}]`;
        
        arrayElement.appendChild(valueDiv);
        arrayElement.appendChild(indexDiv);
        container.appendChild(arrayElement);
    }
}

// NEW: Render Pattern as Array
function renderPatternAsArray(pattern, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    for (let i = 0; i <= pattern.length; i++) {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        
        const valueDiv = document.createElement('div');
        valueDiv.className = 'element-value';
        
        if (i === 0) {
            valueDiv.textContent = ''; // Empty string symbol
            valueDiv.style.background = 'var(--secondary-color)';
        } else {
            valueDiv.textContent = pattern[i-1];
            // Color code special characters
            if (pattern[i-1] === '*' || pattern[i-1] === '?' || pattern[i-1] === '.') {
                valueDiv.style.background = 'var(--warning-color)';
            }
        }
        
        const indexDiv = document.createElement('div');
        indexDiv.className = 'element-index';
        indexDiv.textContent = i === 0 ? 'start' : `[${i-1}]`;
        
        arrayElement.appendChild(valueDiv);
        arrayElement.appendChild(indexDiv);
        container.appendChild(arrayElement);
    }
}

// NEW: Initialize DP Table
function initializeDPTable(str, pattern, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    const table = document.createElement('div');
    table.className = 'dp-table';
    table.style.display = 'grid';
    table.style.gridTemplateColumns = `repeat(${pattern.length + 2}, 1fr)`;
    table.style.gap = '5px';
    table.style.width = '100%';
    
    // Create header row
    for (let i = -1; i <= pattern.length; i++) {
        const headerCell = document.createElement('div');
        headerCell.className = 'dp-cell dp-header';
        headerCell.style.padding = '10px';
        headerCell.style.textAlign = 'center';
        headerCell.style.background = 'var(--primary-color)';
        headerCell.style.borderRadius = '5px';
        
        if (i === -1) {
            headerCell.textContent = 'str\\pat';
        } else if (i === 0) {
            headerCell.textContent = '';
        } else {
            headerCell.textContent = pattern[i-1];
        }
        
        table.appendChild(headerCell);
    }
    
    // Create data rows
    for (let i = 0; i <= str.length; i++) {
        // Row header
        const rowHeader = document.createElement('div');
        rowHeader.className = 'dp-cell dp-header';
        rowHeader.style.padding = '10px';
        rowHeader.style.textAlign = 'center';
        rowHeader.style.background = 'var(--primary-color)';
        rowHeader.style.borderRadius = '5px';
        rowHeader.textContent = i === 0 ? '' : str[i-1];
        table.appendChild(rowHeader);
        
        // Data cells
        for (let j = 0; j <= pattern.length; j++) {
            const dataCell = document.createElement('div');
            dataCell.className = 'dp-cell';
            dataCell.style.padding = '10px';
            dataCell.style.textAlign = 'center';
            dataCell.style.background = 'rgba(255, 255, 255, 0.1)';
            dataCell.style.borderRadius = '5px';
            dataCell.style.minHeight = '40px';
            dataCell.style.display = 'flex';
            dataCell.style.alignItems = 'center';
            dataCell.style.justifyContent = 'center';
            dataCell.id = `dp-cell-${i}-${j}`;
            dataCell.textContent = 'F'; // Initialize as false
            
            table.appendChild(dataCell);
        }
    }
    
    container.appendChild(table);
}

// NEW: Execute Wildcard Matching Algorithm
function executeWildcardMatching(str, pattern) {
    const explanation = document.getElementById('wildcardExplanation');
    const stepsContainer = document.getElementById('wildcardSteps');
    const resultDiv = document.getElementById('wildcardResult');
    const continueButton = document.getElementById('continueAfterWildcard');
    
    const m = str.length;
    const n = pattern.length;
    
    // Initialize DP table
    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(false));
    dp[0][0] = true;
    
    // Handle patterns that start with multiple '*'
    for (let j = 1; j <= n; j++) {
        if (pattern[j - 1] === '*') {
            dp[0][j] = dp[0][j - 1];
        }
    }
    
    let step = 0;
    
    function updateDPCell(i, j, value, reason) {
        setTimeout(() => {
            const cell = document.getElementById(`dp-cell-${i}-${j}`);
            cell.textContent = value ? 'T' : 'F';
            cell.style.background = value ? 'var(--success-color)' : 'var(--danger-color)';
            cell.classList.add('pulse');
            
            explanation.innerHTML = reason;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> ${reason}
                </div>
            `;
            
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            step++;
        }, step * 1000);
    }
    
    // Initialize first row (empty string)
    updateDPCell(0, 0, true, 'Base case: Empty string matches empty pattern');
    
    for (let j = 1; j <= n; j++) {
        if (pattern[j - 1] === '*') {
            dp[0][j] = dp[0][j - 1];
            updateDPCell(0, j, dp[0][j], 
                `Pattern[${j-1}]='*': Empty string matches pattern[0:${j}] = ${dp[0][j]}`);
        }
    }
    
    // Fill DP table
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            setTimeout(() => {
                if (pattern[j - 1] === '*') {
                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];
                    updateDPCell(i, j, dp[i][j],
                        `Pattern[${j-1}]='*': str[0:${i}] matches pattern[0:${j}] = ${dp[i][j]} ` +
                        `(using str[0:${i-1}] or pattern[0:${j-1}])`);
                } else if (pattern[j - 1] === '?' || str[i - 1] === pattern[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                    updateDPCell(i, j, dp[i][j],
                        `str[${i-1}]='${str[i-1]}' matches pattern[${j-1}]='${pattern[j-1]}': ` +
                        `str[0:${i}] matches pattern[0:${j}] = ${dp[i][j]}`);
                } else {
                    dp[i][j] = false;
                    updateDPCell(i, j, dp[i][j],
                        `str[${i-1}]='${str[i-1]}' doesn't match pattern[${j-1}]='${pattern[j-1]}': ` +
                        `str[0:${i}] matches pattern[0:${j}] = false`);
                }
                
                // If this is the last cell, show final result
                if (i === m && j === n) {
                    setTimeout(() => {
                        const result = dp[m][n];
                        resultDiv.textContent = result ? 'MATCH' : 'NO MATCH';
                        resultDiv.style.color = result ? 'var(--success-color)' : 'var(--danger-color)';
                        resultDiv.style.fontWeight = 'bold';
                        
                        explanation.innerHTML = `<strong>Final Result:</strong> "${str}" ${result ? 'matches' : 'does not match'} pattern "${pattern}"`;
                        
                        continueButton.style.display = 'block';
                        
                        // Auto-return after 10 seconds
                        setTimeout(() => {
                            returnToOriginalAfterPatternMatching();
                        }, 10000);
                        
                        continueButton.addEventListener('click', returnToOriginalAfterPatternMatching);
                    }, 1000);
                }
            }, step * 1000);
        }
    }
}

// NEW: Execute Regex Matching Algorithm
function executeRegexMatching(str, pattern) {
    const explanation = document.getElementById('regexExplanation');
    const stepsContainer = document.getElementById('regexSteps');
    const resultDiv = document.getElementById('regexResult');
    const continueButton = document.getElementById('continueAfterRegex');
    
    const m = str.length;
    const n = pattern.length;
    
    // Initialize DP table
    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(false));
    dp[0][0] = true;
    
    // Handle patterns like a*, a*b*, a*b*c* that can match empty string
    for (let j = 2; j <= n; j++) {
        if (pattern[j - 1] === '*') {
            dp[0][j] = dp[0][j - 2];
        }
    }
    
    let step = 0;
    
    function updateDPCell(i, j, value, reason) {
        setTimeout(() => {
            const cell = document.getElementById(`dp-cell-${i}-${j}`);
            cell.textContent = value ? 'T' : 'F';
            cell.style.background = value ? 'var(--success-color)' : 'var(--danger-color)';
            cell.classList.add('pulse');
            
            explanation.innerHTML = reason;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> ${reason}
                </div>
            `;
            
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            step++;
        }, step * 800);
    }
    
    // Initialize first row (empty string)
    updateDPCell(0, 0, true, 'Base case: Empty string matches empty pattern');
    
    for (let j = 2; j <= n; j++) {
        if (pattern[j - 1] === '*') {
            dp[0][j] = dp[0][j - 2];
            updateDPCell(0, j, dp[0][j], 
                `Pattern[${j-1}]='*': Empty string matches pattern[0:${j}] = ${dp[0][j]} ` +
                `(ignoring previous character with '*')`);
        }
    }
    
    // Fill DP table
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            setTimeout(() => {
                if (pattern[j - 1] === '*') {
                    // Zero or more of the previous character
                    dp[i][j] = dp[i][j - 2] || 
                               (dp[i - 1][j] && (str[i - 1] === pattern[j - 2] || pattern[j - 2] === '.'));
                    
                    updateDPCell(i, j, dp[i][j],
                        `Pattern[${j-1}]='*': str[0:${i}] matches pattern[0:${j}] = ${dp[i][j]} ` +
                        `(zero occurrences or matching previous character)`);
                } else if (pattern[j - 1] === '.' || str[i - 1] === pattern[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                    updateDPCell(i, j, dp[i][j],
                        `str[${i-1}]='${str[i-1]}' matches pattern[${j-1}]='${pattern[j-1]}': ` +
                        `str[0:${i}] matches pattern[0:${j}] = ${dp[i][j]}`);
                } else {
                    dp[i][j] = false;
                    updateDPCell(i, j, dp[i][j],
                        `str[${i-1}]='${str[i-1]}' doesn't match pattern[${j-1}]='${pattern[j-1]}': ` +
                        `str[0:${i}] matches pattern[0:${j}] = false`);
                }
                
                // If this is the last cell, show final result
                if (i === m && j === n) {
                    setTimeout(() => {
                        const result = dp[m][n];
                        resultDiv.textContent = result ? 'MATCH' : 'NO MATCH';
                        resultDiv.style.color = result ? 'var(--success-color)' : 'var(--danger-color)';
                        resultDiv.style.fontWeight = 'bold';
                        
                        explanation.innerHTML = `<strong>Final Result:</strong> "${str}" ${result ? 'matches' : 'does not match'} pattern "${pattern}"`;
                        
                        continueButton.style.display = 'block';
                        
                        // Auto-return after 10 seconds
                        setTimeout(() => {
                            returnToOriginalAfterPatternMatching();
                        }, 15000);
                        
                        continueButton.addEventListener('click', returnToOriginalAfterPatternMatching);
                    }, 1000);
                }
            }, step * 800);
        }
    }
}

// NEW: Return to Original after Pattern Matching
function returnToOriginalAfterPatternMatching() {
    // Reset to original array
    myArray = [...originalArrayForPatternMatching];
    originalArrayForPatternMatching = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isPatternMatchingRunning = false;
    currentPatternMatchingType = null;
    
    // Clear inputs
    patternString.value = '';
    patternPattern.value = '';
    
    logOperation('Pattern matching completed - returned to original array', 'info');
    showNotification('Returned to original array after pattern matching', 'success');
}
// NEW: Combination Sum Handler
function handleCombinationSum() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Combination Sum requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Show input group
    combinationSumGroup.style.display = 'block';
    combinationSumTarget.focus();
}

// NEW: Subsets Handler
function handleSubsets() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isSubsetsRunning) {
        showNotification('Subsets operation is already in progress', 'warning');
        return;
    }
    
    isSubsetsRunning = true;
    
    // Store original array
    originalArrayForBacktrack = [...myArray];
    
    // Perform subsets visualization
    performSubsetsVisualization();
}

// NEW: Confirm Combination Sum Handler
function handleConfirmCombinationSum() {
    const target = parseFloat(combinationSumTarget.value);
    
    if (isNaN(target)) {
        showNotification('Please enter a valid target sum', 'danger');
        combinationSumTarget.focus();
        return;
    }
    
    if (isCombinationSumRunning) {
        showNotification('Combination Sum operation is already in progress', 'warning');
        return;
    }
    
    isCombinationSumRunning = true;
    
    // Hide input group
    combinationSumGroup.style.display = 'none';
    combinationSumTarget.value = '';
    
    // Store original array
    originalArrayForBacktrack = [...myArray];
    
    // Perform combination sum visualization
    performCombinationSumVisualization(target);
}

// NEW: Cancel Combination Sum Handler
function handleCancelCombinationSum() {
    combinationSumGroup.style.display = 'none';
    combinationSumTarget.value = '';
}
// NEW: Perform Combination Sum Visualization
function performCombinationSumVisualization(target) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Combination Sum - Target: ${target}</h5>
        
        <div class="array-group">
            <div class="array-label">Candidates Array</div>
            <div class="original-array-container" id="candidatesArray"></div>
        </div>
        
        <div class="backtrack-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find all unique combinations where candidate numbers sum to target</p>
            <p class="mb-0" id="combinationExplanation">Initializing backtracking algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="combinationStepsContainer">
            <h6 class="text-center">Backtracking Steps</h6>
            <div class="steps-container" id="combinationSteps"></div>
        </div>
        
        <div class="combination-result mt-3" id="combinationResults" style="display: none;">
            <h6 class="text-center">Valid Combinations Found</h6>
            <div id="combinationsList"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterCombination" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForBacktrack, 'candidatesArray');
    
    executeCombinationSumAlgorithm(target);
}

// NEW: Execute Combination Sum Algorithm
function executeCombinationSumAlgorithm(target) {
    const arrayContainer = document.getElementById('candidatesArray');
    const explanation = document.getElementById('combinationExplanation');
    const stepsContainer = document.getElementById('combinationSteps');
    const resultsDiv = document.getElementById('combinationResults');
    const combinationsList = document.getElementById('combinationsList');
    const continueButton = document.getElementById('continueAfterCombination');
    
    const candidates = originalArrayForBacktrack.map(val => parseFloat(val));
    const result = [];
    let step = 0;
    let currentPath = [];
    let currentSum = 0;
    
    // Sort candidates (helps with pruning)
    candidates.sort((a, b) => a - b);
    
    function backtrack(start, path, sum) {
        step++;
        
        if (sum === target) {
            // Found a valid combination
            explanation.innerHTML = `<strong>Valid Combination Found!</strong> Sum = ${sum}, Path: [${path.join(', ')}]`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong>  Valid combination found! [${path.join(', ')}] = ${sum}
                </div>
            `;
            
            result.push([...path]);
            
            // Highlight the valid combination
            highlightValidCombination(path);
            
            return new Promise(resolve => setTimeout(resolve, 2000));
        }
        
        if (sum > target) {
            // Exceeded target
            explanation.innerHTML = `Sum exceeded target: ${sum} > ${target}, backtracking...`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}:</strong>  Sum ${sum} > target ${target}, backtracking
                </div>
            `;
            
            return Promise.resolve();
        }
        
        explanation.innerHTML = `Exploring combinations starting from index ${start}, current sum: ${sum}, path: [${path.join(', ')}]`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Start=${start}, Sum=${sum}, Path=[${path.join(', ')}]
            </div>
        `;
        
        return new Promise(resolve => {
            let promiseChain = Promise.resolve();
            
            for (let i = start; i < candidates.length; i++) {
                const num = candidates[i];
                
                if (sum + num > target) {
                    // Prune: since array is sorted, no need to check further
                    explanation.innerHTML = `Pruning: sum ${sum + num} > target ${target}, stopping exploration`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step}.${i}:</strong> Pruning - sum would exceed target
                        </div>
                    `;
                    
                    break;
                }
                
                promiseChain = promiseChain.then(() => {
                    // Add current number to path
                    step++;
                    path.push(num);
                    const newSum = sum + num;
                    
                    explanation.innerHTML = `Trying candidate [${i}]=${num}, new sum: ${newSum}, path: [${path.join(', ')}]`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step}:</strong> Add [${i}]=${num}, Sum=${newSum}, Path=[${path.join(', ')}]
                        </div>
                    `;
                    
                    // Highlight current candidate
                    const elements = arrayContainer.querySelectorAll('.array-element');
                    elements[i].querySelector('.element-value').classList.add('backtrack-current');
                    
                    return new Promise(resolveStep => {
                        setTimeout(() => {
                            elements[i].querySelector('.element-value').classList.remove('backtrack-current');
                            elements[i].querySelector('.element-value').classList.add('backtrack-included');
                            
                            // Recursively explore
                            backtrack(i, path, newSum).then(() => {
                                // Backtrack: remove last element
                                path.pop();
                                step++;
                                
                                explanation.innerHTML = `Backtracking: removed ${num}, path: [${path.join(', ')}]`;
                                
                                stepsContainer.innerHTML += `
                                    <div class="algorithm-step">
                                        <strong>Step ${step}:</strong> Backtrack - remove ${num}, Path=[${path.join(', ')}]
                                    </div>
                                `;
                                
                                elements[i].querySelector('.element-value').classList.remove('backtrack-included');
                                resolveStep();
                            });
                        }, 1500);
                    });
                });
            }
            
            promiseChain.then(resolve);
        });
    }
    
    function highlightValidCombination(path) {
        const elements = arrayContainer.querySelectorAll('.array-element');
        const candidateCount = {};
        
        // Count occurrences in the valid combination
        path.forEach(num => {
            candidateCount[num] = (candidateCount[num] || 0) + 1;
        });
        
        // Highlight elements that are part of the combination
        elements.forEach((element, index) => {
            const value = parseFloat(element.querySelector('.element-value').textContent);
            const countInCombination = candidateCount[value] || 0;
            
            if (countInCombination > 0) {
                element.querySelector('.element-value').classList.add('backtrack-valid');
                candidateCount[value]--;
            }
        });
        
        // Add combination to results
        const combinationDiv = document.createElement('div');
        combinationDiv.className = 'subset-item';
        combinationDiv.textContent = `[${path.join(', ')}]`;
        combinationsList.appendChild(combinationDiv);
    }
    
    // Start the algorithm
    backtrack(0, [], 0).then(() => {
        explanation.innerHTML = `<strong>Algorithm Completed!</strong> Found ${result.length} valid combination(s) for target ${target}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Final:</strong> Found ${result.length} combination(s) for target ${target}
            </div>
        `;
        
        resultsDiv.style.display = 'block';
        continueButton.style.display = 'block';
        
        // Auto-return after 10 seconds
        setTimeout(() => {
            returnToOriginalAfterBacktrack();
        }, 10000);
        
        continueButton.addEventListener('click', returnToOriginalAfterBacktrack);
        
        // Log operation
        logOperation(`Found ${result.length} combination(s) for target ${target}: ${JSON.stringify(result)}`, 'success');
    });
}

// NEW: Perform Subsets Visualization
function performSubsetsVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Generate All Subsets</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="subsetsArray"></div>
        </div>
        
        <div class="backtrack-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Generate all possible subsets (power set)</p>
            <p class="mb-0" id="subsetsExplanation">Initializing backtracking algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="subsetsStepsContainer">
            <h6 class="text-center">Backtracking Steps</h6>
            <div class="steps-container" id="subsetsSteps"></div>
        </div>
        
        <div class="combination-result mt-3" id="subsetsResults">
            <h6 class="text-center">Generated Subsets</h6>
            <div id="subsetsList"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSubsets" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForBacktrack, 'subsetsArray');
    
    executeSubsetsAlgorithm();
}

// NEW: Execute Subsets Algorithm
function executeSubsetsAlgorithm() {
    const arrayContainer = document.getElementById('subsetsArray');
    const explanation = document.getElementById('subsetsExplanation');
    const stepsContainer = document.getElementById('subsetsSteps');
    const subsetsList = document.getElementById('subsetsList');
    const continueButton = document.getElementById('continueAfterSubsets');
    
    const nums = [...originalArrayForBacktrack];
    const result = [];
    let step = 0;
    
    function backtrack(start, path) {
        step++;
        
        // Add current subset to result
        explanation.innerHTML = `Adding subset: [${path.join(', ')}]`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong>  Subset found: [${path.join(', ')}]
            </div>
        `;
        
        result.push([...path]);
        
        // Display the subset
        const subsetDiv = document.createElement('div');
        subsetDiv.className = 'subset-item';
        subsetDiv.textContent = `[${path.join(', ')}]`;
        subsetsList.appendChild(subsetDiv);
        
        // Highlight elements in current subset
        const elements = arrayContainer.querySelectorAll('.array-element');
        elements.forEach((element, index) => {
            element.querySelector('.element-value').classList.remove('backtrack-included', 'backtrack-skipped');
            
            if (path.includes(nums[index])) {
                element.querySelector('.element-value').classList.add('backtrack-included');
            } else {
                element.querySelector('.element-value').classList.add('backtrack-skipped');
            }
        });
        
        return new Promise(resolve => {
            setTimeout(() => {
                let promiseChain = Promise.resolve();
                
                for (let i = start; i < nums.length; i++) {
                    promiseChain = promiseChain.then(() => {
                        step++;
                        
                        explanation.innerHTML = `Exploring: add ${nums[i]} to current subset`;
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Step ${step}:</strong> Include [${i}]=${nums[i]} in subset
                            </div>
                        `;
                        
                        // Highlight current element being considered
                        elements[i].querySelector('.element-value').classList.add('backtrack-current');
                        
                        return new Promise(resolveStep => {
                            setTimeout(() => {
                                elements[i].querySelector('.element-value').classList.remove('backtrack-current');
                                
                                path.push(nums[i]);
                                backtrack(i + 1, path).then(() => {
                                    path.pop();
                                    resolveStep();
                                });
                            }, 1000);
                        });
                    });
                }
                
                promiseChain.then(resolve);
            }, 1000);
        });
    }
    
    // Start the algorithm
    backtrack(0, []).then(() => {
        explanation.innerHTML = `<strong>Algorithm Completed!</strong> Generated ${result.length} subsets (power set)`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Final:</strong> Generated ${result.length} subsets including empty set
            </div>
        `;
        
        continueButton.style.display = 'block';
        
        // Auto-return after 10 seconds
        setTimeout(() => {
            returnToOriginalAfterBacktrack();
        }, 10000);
        
        continueButton.addEventListener('click', returnToOriginalAfterBacktrack);
        
        // Log operation
        logOperation(`Generated ${result.length} subsets: ${JSON.stringify(result)}`, 'success');
    });
}

// NEW: Return to Original after Backtracking Operations
function returnToOriginalAfterBacktrack() {
    // Reset to original array
    myArray = [...originalArrayForBacktrack];
    originalArrayForBacktrack = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset states
    isCombinationSumRunning = false;
    isSubsetsRunning = false;
    
    logOperation('Returned to original array after backtracking operation', 'info');
    showNotification('Returned to original array', 'success');
}
// NEW: Longest Valid Parentheses Handler
function handleLongestValidParentheses() {
    if (isParenthesesOperationRunning) {
        showNotification('A parentheses operation is already in progress', 'warning');
        return;
    }
    
    // Show input group
    parenthesesInputGroup.style.display = 'block';
    lvpInput.focus();
    
    // Hide other input groups
    subsequencesInputGroup.style.display = 'none';
    
    logOperation('Started longest valid parentheses operation', 'info');
}

// NEW: Distinct Subsequences Handler
function handleDistinctSubsequences() {
    if (isSubsequencesOperationRunning) {
        showNotification('A subsequences operation is already in progress', 'warning');
        return;
    }
    
    // Show input group
    subsequencesInputGroup.style.display = 'block';
    dsMainStringInput.focus();
    
    // Hide other input groups
    parenthesesInputGroup.style.display = 'none';
    
    logOperation('Started distinct subsequences operation', 'info');
}

// NEW: Confirm Parentheses Handler
function handleConfirmParentheses() {
    const input = lvpInput.value.trim();
    
    if (input === '') {
        showNotification('Please enter a parentheses string', 'danger');
        lvpInput.focus();
        return;
    }
    
    // Validate input - only allow parentheses
    if (!/^[()]*$/.test(input)) {
        showNotification('Please enter only parentheses characters: ( and )', 'danger');
        lvpInput.focus();
        return;
    }
    
    if (input.length > 50) {
        showNotification('String too long. Maximum 50 characters allowed.', 'danger');
        lvpInput.focus();
        return;
    }
    
    // Store original array
    originalArrayForParentheses = [...myArray];
    
    // Hide input group
    parenthesesInputGroup.style.display = 'none';
    
    // Start parentheses visualization
    performLongestValidParentheses(input);
}

// NEW: Confirm Subsequences Handler
function handleConfirmSubsequences() {
    const s = dsMainStringInput.value.trim();
    const t = dsTargetStringInput.value.trim();
    
    if (s === '') {
        showNotification('Please enter the main string', 'danger');
        dsMainStringInput.focus();
        return;
    }
    
    if (t === '') {
        showNotification('Please enter the target string', 'danger');
        dsTargetStringInput.focus();
        return;
    }
    
    if (s.length > 30) {
        showNotification('Main string too long. Maximum 30 characters allowed.', 'danger');
        dsMainStringInput.focus();
        return;
    }
    
    if (t.length > 20) {
        showNotification('Target string too long. Maximum 20 characters allowed.', 'danger');
        dsTargetStringInput.focus();
        return;
    }
    
    if (t.length > s.length) {
        showNotification('Target string cannot be longer than main string', 'danger');
        dsTargetStringInput.focus();
        return;
    }
    
    // Store original array
    originalArrayForSubsequences = [...myArray];
    
    // Hide input group
    subsequencesInputGroup.style.display = 'none';
    
    // Start subsequences visualization
    performDistinctSubsequences(s, t);
}

// NEW: Cancel Parentheses Handler
function handleCancelParentheses() {
    parenthesesInputGroup.style.display = 'none';
    lvpInput.value = '';
}

// NEW: Cancel Subsequences Handler
function handleCancelSubsequences() {
    subsequencesInputGroup.style.display = 'none';
    dsMainStringInput.value = '';
    dsTargetStringInput.value = '';
}
// NEW: Perform Longest Valid Parentheses with Animation
function performLongestValidParentheses(s) {
    isParenthesesOperationRunning = true;
    
    const container = document.createElement('div');
    container.className = 'dual-operation-container';
    container.innerHTML = `
        <h5 class="text-center mb-3">Longest Valid Parentheses</h5>
        
        <div class="array-group">
            <div class="array-label">Input String: "${s}"</div>
            <div class="original-array-container" id="parenthesesArray"></div>
        </div>
        
        <div class="parenthesis-stack mt-3">
            <h6 class="text-center">Stack Operations</h6>
            <div id="stackContainer"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Using stack to track valid parentheses positions</p>
            <p class="mb-0" id="parenthesesExplanation">Initializing algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="parenthesesStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="parenthesesSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Longest Valid Parentheses Length</div>
            <div class="stats-value" id="longestParenthesesValue">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterParentheses" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(container);
    
    // Render the parentheses as array elements
    renderParenthesesArray(s);
    
    executeLongestValidParentheses(s);
}

// NEW: Render Parentheses Array
function renderParenthesesArray(s) {
    const container = document.getElementById('parenthesesArray');
    container.innerHTML = '';
    
    for (let i = 0; i < s.length; i++) {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value" data-index="${i}">${s[i]}</div>
            <div class="element-index">${i}</div>
        `;
        container.appendChild(arrayElement);
    }
}

// NEW: Execute Longest Valid Parentheses Algorithm
function executeLongestValidParentheses(s) {
    const arrayContainer = document.getElementById('parenthesesArray');
    const stackContainer = document.getElementById('stackContainer');
    const explanation = document.getElementById('parenthesesExplanation');
    const stepsContainer = document.getElementById('parenthesesSteps');
    const longestValue = document.getElementById('longestParenthesesValue');
    const continueButton = document.getElementById('continueAfterParentheses');
    
    let max_len = 0;
    let stack = [-1]; // stack stores indices, -1 is sentinel
    let step = 0;
    
    // Initialize stack display
    updateStackDisplay(stack, stackContainer, -1);
    
    function executeStep(i) {
        if (i >= s.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Longest valid parentheses length = ${max_len}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Maximum valid parentheses length = ${max_len}
                </div>
            `;
            
            longestValue.textContent = max_len;
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterParentheses();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterParentheses);
            
            return;
        }
        
        step++;
        const char = s[i];
        
        // Highlight current character
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElement = elements[i].querySelector('.element-value');
        currentElement.classList.add('parenthesis-current');
        
        explanation.innerHTML = `Step ${step}: Processing character at index ${i} = "${char}"`;
        
        if (char === '(') {
            // Push opening bracket index
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}:</strong> Found '(', pushing index ${i} to stack
                </div>
            `;
            
            setTimeout(() => {
                stack.push(i);
                updateStackDisplay(stack, stackContainer, i);
                
                currentElement.classList.remove('parenthesis-current');
                
                executeStep(i + 1);
            }, 1500);
            
        } else {
            // Closing bracket
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}:</strong> Found ')', popping from stack
                </div>
            `;
            
            setTimeout(() => {
                stack.pop();
                
                if (stack.length === 0) {
                    // New base if no valid structure left
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step}.1:</strong> Stack empty, pushing current index ${i} as new base
                        </div>
                    `;
                    
                    stack.push(i);
                    updateStackDisplay(stack, stackContainer, i);
                    currentElement.classList.add('parenthesis-invalid');
                    
                } else {
                    // Calculate current valid length
                    const current_len = i - stack[stack.length - 1];
                    max_len = Math.max(max_len, current_len);
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step}.1:</strong> Valid sequence found! Length = ${current_len}, Max = ${max_len}
                        </div>
                    `;
                    
                    // Highlight the valid sequence
                    const start = stack[stack.length - 1] + 1;
                    for (let j = start; j <= i; j++) {
                        elements[j].querySelector('.element-value').classList.add('parenthesis-match');
                    }
                    
                    currentElement.classList.add('parenthesis-match');
                    longestValue.textContent = max_len;
                }
                
                updateStackDisplay(stack, stackContainer, -1);
                
                setTimeout(() => {
                    currentElement.classList.remove('parenthesis-current');
                    executeStep(i + 1);
                }, 2000);
                
            }, 1500);
        }
    }
    
    // Start execution
    executeStep(0);
}

// NEW: Update Stack Display
function updateStackDisplay(stack, container, highlightIndex) {
    container.innerHTML = '';
    
    // Display stack from bottom to top
    for (let i = 0; i < stack.length; i++) {
        const item = document.createElement('div');
        item.className = `stack-item ${stack[i] === highlightIndex ? 'current' : ''} ${stack[i] === -1 ? 'sentinel' : ''}`;
        item.textContent = stack[i] === -1 ? 'Sentinel (-1)' : `Index: ${stack[i]} (${stack[i] === -1 ? '' : `"${myArray[stack[i]] || 'N/A'}"`})`;
        container.appendChild(item);
    }
    
    if (stack.length === 0) {
        const emptyMsg = document.createElement('div');
        emptyMsg.className = 'stack-item';
        emptyMsg.textContent = 'Stack is empty';
        container.appendChild(emptyMsg);
    }
}

// NEW: Perform Distinct Subsequences with Animation
function performDistinctSubsequences(s, t) {
    isSubsequencesOperationRunning = true;
    
    const container = document.createElement('div');
    container.className = 'dual-operation-container';
    container.innerHTML = `
        <h5 class="text-center mb-3">Distinct Subsequences</h5>
        
        <div class="array-group">
            <div class="array-label">Main String (s): "${s}"</div>
            <div class="original-array-container" id="mainStringArray"></div>
        </div>
        
        <div class="array-group mt-3">
            <div class="array-label">Target String (t): "${t}"</div>
            <div class="original-array-container" id="targetStringArray"></div>
        </div>
        
        <div class="algorithm-explanation mt-3">
            <p class="mb-2"><strong>Algorithm:</strong> Dynamic Programming - Count how many times t appears in s as subsequence</p>
            <p class="mb-0" id="subsequencesExplanation">Initializing DP table...</p>
        </div>
        
        <div id="dpTableContainer" class="mt-3"></div>
        
        <div class="algorithm-steps mt-3" id="subsequencesStepsContainer">
            <h6 class="text-center">DP Table Construction Steps</h6>
            <div class="steps-container" id="subsequencesSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Distinct Subsequences Count</div>
            <div class="stats-value" id="subsequencesCountValue">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSubsequences" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(container);
    
    // Render the strings as arrays
    renderStringArray(s, 'mainStringArray');
    renderStringArray(t, 'targetStringArray');
    
    executeDistinctSubsequences(s, t);
}

// NEW: Render String Array
function renderStringArray(str, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    for (let i = 0; i < str.length; i++) {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value" data-index="${i}">${str[i]}</div>
            <div class="element-index">${i}</div>
        `;
        container.appendChild(arrayElement);
    }
}

// NEW: Execute Distinct Subsequences Algorithm
function executeDistinctSubsequences(s, t) {
    const explanation = document.getElementById('subsequencesExplanation');
    const stepsContainer = document.getElementById('subsequencesSteps');
    const countValue = document.getElementById('subsequencesCountValue');
    const continueButton = document.getElementById('continueAfterSubsequences');
    const dpTableContainer = document.getElementById('dpTableContainer');
    
    const m = s.length, n = t.length;
    let dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
    let step = 0;
    
    // Initialize DP table display
    updateDPTable(dp, s, t, dpTableContainer, -1, -1);
    
    function executeStep() {
        if (step === 0) {
            // Step 1: Initialize first column (empty t can be formed in 1 way)
            explanation.innerHTML = `Step ${step + 1}: Initialize DP table - empty target can be formed in 1 way`;
            
            for (let i = 0; i <= m; i++) {
                dp[i][0] = 1;
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step + 1}:</strong> Initialize dp[i][0] = 1 for all i (empty target)
                </div>
            `;
            
            updateDPTable(dp, s, t, dpTableContainer, -1, 0);
            step++;
            
            setTimeout(executeStep, 2000);
            
        } else if (step <= m * n) {
            const i = Math.floor((step - 1) / n) + 1;
            const j = ((step - 1) % n) + 1;
            
            if (i <= m && j <= n) {
                explanation.innerHTML = `Step ${step + 1}: Processing dp[${i}][${j}] - s[${i-1}]="${s[i-1]}", t[${j-1}]="${t[j-1]}"`;
                
                // Highlight current characters in strings
                highlightCurrentCharacters(i-1, j-1);
                
                if (s[i-1] === t[j-1]) {
                    // Characters match
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step + 1}:</strong> s[${i-1}]="${s[i-1]}" == t[${j-1}]="${t[j-1]}", so dp[${i}][${j}] = dp[${i-1}][${j-1}] + dp[${i-1}][${j}] = ${dp[i-1][j-1]} + ${dp[i-1][j]} = ${dp[i-1][j-1] + dp[i-1][j]}
                        </div>
                    `;
                    
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
                    
                } else {
                    // Characters don't match
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step + 1}:</strong> s[${i-1}]="${s[i-1]}" != t[${j-1}]="${t[j-1]}", so dp[${i}][${j}] = dp[${i-1}][${j}] = ${dp[i-1][j]}
                        </div>
                    `;
                    
                    dp[i][j] = dp[i-1][j];
                }
                
                updateDPTable(dp, s, t, dpTableContainer, i, j);
                countValue.textContent = dp[m][n];
                step++;
                
                setTimeout(executeStep, 2000);
                
            } else {
                step++;
                executeStep();
            }
            
        } else {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Distinct subsequences count = ${dp[m][n]}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> dp[${m}][${n}] = ${dp[m][n]} distinct subsequences
                </div>
            `;
            
            countValue.textContent = dp[m][n];
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterSubsequences();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSubsequences);
        }
    }
    
    // Start execution
    executeStep();
}

// NEW: Highlight Current Characters
function highlightCurrentCharacters(sIndex, tIndex) {
    // Highlight in main string
    const mainElements = document.getElementById('mainStringArray').querySelectorAll('.array-element');
    mainElements.forEach((el, idx) => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('parenthesis-current', 'parenthesis-match');
        if (idx === sIndex) {
            valueDiv.classList.add('parenthesis-current');
        }
    });
    
    // Highlight in target string
    const targetElements = document.getElementById('targetStringArray').querySelectorAll('.array-element');
    targetElements.forEach((el, idx) => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('parenthesis-current', 'parenthesis-match');
        if (idx === tIndex) {
            valueDiv.classList.add('parenthesis-current');
        }
    });
}

// NEW: Update DP Table Display
function updateDPTable(dp, s, t, container, highlightI, highlightJ) {
    const m = s.length, n = t.length;
    
    let html = `
        <div class="dp-table">
            <div class="dp-row">
                <div class="dp-cell header">s\\t</div>
                <div class="dp-cell header"></div>
    `;
    
    // Header row (target string)
    for (let j = 0; j < n; j++) {
        html += `<div class="dp-cell header">${t[j]}</div>`;
    }
    html += `</div>`;
    
    // Data rows
    for (let i = 0; i <= m; i++) {
        html += `<div class="dp-row">`;
        
        // First column (main string character or empty)
        if (i === 0) {
            html += `<div class="dp-cell header"></div>`;
        } else {
            html += `<div class="dp-cell header">${s[i-1]}</div>`;
        }
        
        // DP values
        for (let j = 0; j <= n; j++) {
            let cellClass = 'dp-cell';
            if (i === highlightI && j === highlightJ) {
                cellClass += ' current';
            } else if (dp[i][j] > 0) {
                cellClass += ' updated';
            } else if (i > 0 && j > 0) {
                cellClass += ' zero';
            }
            
            html += `<div class="${cellClass}">${dp[i][j]}</div>`;
        }
        
        html += `</div>`;
    }
    
    html += `</div>`;
    container.innerHTML = html;
}

// NEW: Return to Original after Parentheses
function returnToOriginalAfterParentheses() {
    // Reset to original array
    myArray = [...originalArrayForParentheses];
    originalArrayForParentheses = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state and clear input
    isParenthesesOperationRunning = false;
    lvpInput.value = '';
    
    logOperation('Longest valid parentheses operation completed', 'info');
    showNotification('Returned to original array', 'success');
}

// NEW: Return to Original after Subsequences
function returnToOriginalAfterSubsequences() {
    // Reset to original array
    myArray = [...originalArrayForSubsequences];
    originalArrayForSubsequences = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state and clear inputs
    isSubsequencesOperationRunning = false;
    dsMainStringInput.value = '';
    dsTargetStringInput.value = '';
    
    logOperation('Distinct subsequences operation completed', 'info');
    showNotification('Returned to original array', 'success');
}
// NEW: Start Word Concatenation Search Handler
function handleStartWordConcatSearch() {
    if (isWordConcatSearchActive) {
        showNotification('Word concatenation search is already running', 'warning');
        return;
    }
    
    // Show input section
    wordConcatInputSection.style.display = 'block';
    textStringInputField.focus();
    
    logOperation('Started word concatenation substring search operation', 'info');
}

// NEW: Run Word Concatenation Search Handler
function handleRunWordConcatSearch() {
    const inputTextString = textStringInputField.value.trim();
    const wordsInputText = searchWordsInputField.value.trim();
    
    if (inputTextString === '') {
        showNotification('Please enter a text string', 'danger');
        textStringInputField.focus();
        return;
    }
    
    if (wordsInputText === '') {
        showNotification('Please enter search words', 'danger');
        searchWordsInputField.focus();
        return;
    }
    
    const searchWordsArray = wordsInputText.split(',').map(word => word.trim()).filter(word => word !== '');
    
    if (searchWordsArray.length === 0) {
        showNotification('Please enter valid words separated by commas', 'danger');
        searchWordsInputField.focus();
        return;
    }
    
    // Check if all words have same length
    const firstWordLength = searchWordsArray[0].length;
    if (!searchWordsArray.every(word => word.length === firstWordLength)) {
        showNotification('All search words must have the same length', 'danger');
        searchWordsInputField.focus();
        return;
    }
    
    // Store original array
    originalArrayBeforeWordConcat = [...myArray];
    
    // Hide input section
    wordConcatInputSection.style.display = 'none';
    
    // Start word concatenation visualization
    showWordConcatVisualization(inputTextString, searchWordsArray);
}

// NEW: Stop Word Concatenation Search Handler
function handleStopWordConcatSearch() {
    wordConcatInputSection.style.display = 'none';
    textStringInputField.value = '';
    searchWordsInputField.value = '';
    
    logOperation('Cancelled word concatenation search operation', 'info');
    showNotification('Word concatenation search cancelled', 'info');
}
// NEW: Show Word Concatenation Visualization
function showWordConcatVisualization(textString, wordsArray) {
    isWordConcatSearchActive = true;
    
    const visualizationContainer = document.createElement('div');
    visualizationContainer.className = 'dual-operation-container';
    visualizationContainer.innerHTML = `
        <h5 class="text-center mb-3">Substring with Concatenation of All Words</h5>
        
        <div class="array-group">
            <div class="array-label">Input Text String (Length: ${textString.length})</div>
            <div class="original-array-container" id="textStringVisualization"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Search Words (${wordsArray.length} words)</div>
            <div class="original-array-container" id="wordsArrayVisualization"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Found Starting Positions</div>
            <div class="transformed-array-container" id="concatResultsVisualization"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find starting indices where substring contains all words in any order</p>
            <p class="mb-0" id="wordConcatAlgorithmExplanation">Initializing word concatenation search algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="wordConcatStepsArea">
            <h6 class="text-center">Algorithm Execution Steps</h6>
            <div class="steps-container" id="wordConcatStepsContainer"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Found Starting Indices</div>
            <div class="stats-value" id="foundPositionsDisplay">[]</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Total Valid Substrings</div>
            <div class="stats-value" id="totalSubstringsCount">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="finishWordConcatBtn" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(visualizationContainer);
    
    // Display the input text as individual characters
    renderTextAsCharacterGrid(textString, 'textStringVisualization');
    
    // Display words
    renderArrayInContainer(wordsArray, 'wordsArrayVisualization');
    
    // Initialize results display
    renderArrayInContainer([], 'concatResultsVisualization');
    
    // Start algorithm animation
    executeWordConcatAlgorithm(textString, wordsArray);
}

// NEW: Render Text as Character Grid for visualization
function renderTextAsCharacterGrid(text, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    for (let i = 0; i < text.length; i++) {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value">${text[i]}</div>
            <div class="element-index">${i}</div>
        `;
        container.appendChild(arrayElement);
    }
}
// NEW: Execute Word Concatenation Algorithm
function executeWordConcatAlgorithm(sourceText, targetWords) {
    const textContainer = document.getElementById('textStringVisualization');
    const resultsContainer = document.getElementById('concatResultsVisualization');
    const explanation = document.getElementById('wordConcatAlgorithmExplanation');
    const stepsContainer = document.getElementById('wordConcatStepsContainer');
    const foundPositionsDisplay = document.getElementById('foundPositionsDisplay');
    const totalSubstringsCount = document.getElementById('totalSubstringsCount');
    const finishButton = document.getElementById('finishWordConcatBtn');
    
    const singleWordLength = targetWords[0].length;
    const totalWordsCount = targetWords.length;
    const concatenationLength = singleWordLength * totalWordsCount;
    const wordFrequencyMap = new Map();
    const foundStartPositions = [];
    
    // Initialize word frequency counter
    targetWords.forEach(word => {
        wordFrequencyMap.set(word, (wordFrequencyMap.get(word) || 0) + 1);
    });
    
    let algorithmStep = 0;
    let currentSearchPosition = 0;
    
    function processSearchWindow(windowStart) {
        if (windowStart > sourceText.length - concatenationLength) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Found ${foundStartPositions.length} valid starting positions.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final Result:</strong> Valid starting indices: [${foundStartPositions.join(', ')}]
                </div>
            `;
            
            // Display results
            renderArrayInContainer(foundStartPositions.map(pos => `Position ${pos}`), 'concatResultsVisualization');
            
            // Highlight found positions in the text
            const textElements = textContainer.querySelectorAll('.array-element');
            foundStartPositions.forEach((position, index) => {
                setTimeout(() => {
                    for (let j = position; j < position + concatenationLength; j++) {
                        if (j < textElements.length) {
                            textElements[j].querySelector('.element-value').classList.add('success-color');
                        }
                    }
                }, index * 300);
            });
            
            foundPositionsDisplay.textContent = `[${foundStartPositions.join(', ')}]`;
            totalSubstringsCount.textContent = foundStartPositions.length;
            finishButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                resetAfterWordConcatSearch();
            }, 10000);
            
            finishButton.addEventListener('click', resetAfterWordConcatSearch);
            
            return;
        }
        
        algorithmStep++;
        currentSearchPosition = windowStart;
        
        explanation.innerHTML = `Examining window starting at position ${windowStart}: "${sourceText.substring(windowStart, windowStart + Math.min(10, sourceText.length - windowStart))}..."`;
        
        // Highlight current window in the text
        const textElements = textContainer.querySelectorAll('.array-element');
        
        // Remove previous highlights
        textElements.forEach(el => {
            el.querySelector('.element-value').classList.remove('window-current', 'window-checking', 'success-color', 'danger-color', 'info-color');
        });
        
        // Highlight current search window
        for (let j = windowStart; j < windowStart + concatenationLength && j < sourceText.length; j++) {
            textElements[j].querySelector('.element-value').classList.add('window-current');
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${algorithmStep}:</strong> Checking window starting at position ${windowStart}
            </div>
        `;
        
        // Scroll to bottom of steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            const currentWordCounts = new Map();
            let isWindowValid = true;
            let wordValidationStep = 0;
            
            function validateCurrentWord(wordIndex) {
                if (wordIndex >= totalWordsCount) {
                    // All words matched successfully
                    foundStartPositions.push(windowStart);
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${algorithmStep}.${wordValidationStep}:</strong>  Valid word concatenation found at position ${windowStart}!
                        </div>
                    `;
                    
                    // Highlight the valid window
                    for (let k = windowStart; k < windowStart + concatenationLength; k++) {
                        textElements[k].querySelector('.element-value').classList.remove('window-current');
                        textElements[k].querySelector('.element-value').classList.add('success-color');
                    }
                    
                    foundPositionsDisplay.textContent = `[${foundStartPositions.join(', ')}]`;
                    totalSubstringsCount.textContent = foundStartPositions.length;
                    
                    // Move to next search position
                    setTimeout(() => {
                        processSearchWindow(windowStart + 1);
                    }, 2000);
                    
                    return;
                }
                
                wordValidationStep++;
                const currentWordStart = windowStart + wordIndex * singleWordLength;
                const extractedWord = sourceText.substring(currentWordStart, currentWordStart + singleWordLength);
                
                // Highlight current word being validated
                for (let k = currentWordStart; k < currentWordStart + singleWordLength; k++) {
                    textElements[k].querySelector('.element-value').classList.add('window-checking');
                }
                
                explanation.innerHTML = `Validating word at positions ${currentWordStart}-${currentWordStart + singleWordLength - 1}: "${extractedWord}"`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${algorithmStep}.${wordValidationStep}:</strong> Checking word "${extractedWord}" at position ${currentWordStart}
                    </div>
                `;
                
                // Scroll to bottom
                stepsContainer.scrollTop = stepsContainer.scrollHeight;
                
                setTimeout(() => {
                    if (!wordFrequencyMap.has(extractedWord)) {
                        // Invalid word - not in our target words
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Step ${algorithmStep}.${wordValidationStep}:</strong>  "${extractedWord}" not in target word list
                            </div>
                        `;
                        
                        // Highlight invalid word
                        for (let k = currentWordStart; k < currentWordStart + singleWordLength; k++) {
                            textElements[k].querySelector('.element-value').classList.remove('window-checking');
                            textElements[k].querySelector('.element-value').classList.add('danger-color');
                        }
                        
                        isWindowValid = false;
                    } else {
                        currentWordCounts.set(extractedWord, (currentWordCounts.get(extractedWord) || 0) + 1);
                        
                        if (currentWordCounts.get(extractedWord) > wordFrequencyMap.get(extractedWord)) {
                            // Too many occurrences of this word
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step active">
                                    <strong>Step ${algorithmStep}.${wordValidationStep}:</strong>  Too many "${extractedWord}" (${currentWordCounts.get(extractedWord)} > ${wordFrequencyMap.get(extractedWord)})
                                </div>
                            `;
                            
                            isWindowValid = false;
                        } else {
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step">
                                    <strong>Step ${algorithmStep}.${wordValidationStep}:</strong>  "${extractedWord}" validated (${currentWordCounts.get(extractedWord)}/${wordFrequencyMap.get(extractedWord)})
                                </div>
                            `;
                        }
                    }
                    
                    // Remove temporary highlights
                    for (let k = currentWordStart; k < currentWordStart + singleWordLength; k++) {
                        textElements[k].querySelector('.element-value').classList.remove('window-checking');
                        if (isWindowValid) {
                            textElements[k].querySelector('.element-value').classList.add('info-color');
                        }
                    }
                    
                    if (!isWindowValid) {
                        // Invalid window found, move to next search position
                        setTimeout(() => {
                            processSearchWindow(windowStart + 1);
                        }, 1500);
                    } else {
                        // Validate next word in current window
                        setTimeout(() => {
                            validateCurrentWord(wordIndex + 1);
                        }, 1000);
                    }
                }, 1500);
            }
            
            // Start validating words in current window
            validateCurrentWord(0);
            
        }, 1500);
    }
    
    // Start algorithm execution from first position
    processSearchWindow(0);
}
// NEW: Reset after Word Concatenation Search
function resetAfterWordConcatSearch() {
    // Reset to original array
    myArray = [...originalArrayBeforeWordConcat];
    originalArrayBeforeWordConcat = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isWordConcatSearchActive = false;
    
    // Clear input fields
    textStringInputField.value = '';
    searchWordsInputField.value = '';
    
    logOperation('Word concatenation search completed - returned to original array', 'info');
    showNotification('Returned to original array after word concatenation search', 'success');
}
// NEW: Count Smaller Numbers After Self Handler
function handleCountSmallerAfterSelf() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isSmallerCountRunning) {
        showNotification('Count operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('This operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isSmallerCountRunning = true;
    
    // Store original array
    originalArrayForSmallerCount = [...myArray];
    
    // Show smaller count visualization
    showSmallerCountVisualization();
}
// NEW: Show Smaller Count Visualization
function showSmallerCountVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Count of Smaller Numbers After Self</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalSmallerCountArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Counting Process</div>
            <div class="transformed-array-container" id="transformedSmallerCountArray"></div>
        </div>
        
        <!-- Results Table positioned below the counting process array -->
        <div class="array-group">
            <div class="array-label">Results Table</div>
            <div class="smaller-count-results-container">
                <div id="smallerCountResultsTable">
                    <p class="text-center text-muted">Results will appear here as the algorithm progresses...</p>
                </div>
            </div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> For each element, count how many elements to the right are smaller</p>
            <p class="mb-0" id="smallerCountExplanation">Initializing count operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="smallerCountStepsContainer">
            <h6 class="text-center">Counting Steps</h6>
            <div class="steps-container" id="smallerCountSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSmallerCount" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSmallerCount, 'originalSmallerCountArray');
    renderArrayInContainer([...originalArrayForSmallerCount], 'transformedSmallerCountArray');
    
    performSmallerCountAnimation();
}

// NEW: Perform Smaller Count Animation
function performSmallerCountAnimation() {
    const originalContainer = document.getElementById('originalSmallerCountArray');
    const transformedContainer = document.getElementById('transformedSmallerCountArray');
    const explanation = document.getElementById('smallerCountExplanation');
    const stepsContainer = document.getElementById('smallerCountSteps');
    const resultsTable = document.getElementById('smallerCountResultsTable');
    const continueButton = document.getElementById('continueAfterSmallerCount');
    
    const arr = originalArrayForSmallerCount.map(val => parseFloat(val));
    const n = arr.length;
    const result = new Array(n).fill(0);
    let currentIndex = 0;
    let step = 0;
    
    // Initialize results table
    initializeResultsTable(arr, result);
    
    function performCountStep() {
        if (currentIndex >= n) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Counting Completed!</strong> All elements processed.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Counting completed for all elements
                </div>
            `;
            
            // Update final results table
            updateResultsTable(arr, result);
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterSmallerCount();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSmallerCount);
            
            return;
        }
        
        step++;
        explanation.innerHTML = `Processing element at index ${currentIndex}: ${arr[currentIndex]}`;
        
        // Highlight current element
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        const currentElement = transformedElements[currentIndex].querySelector('.element-value');
        currentElement.classList.add('smaller-count-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> Processing element [${currentIndex}] = ${arr[currentIndex]}
            </div>
        `;
        
        let count = 0;
        let comparisonStep = 0;
        
        function performComparison(j) {
            if (j >= n) {
                // All comparisons completed for current element
                result[currentIndex] = count;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}.${comparisonStep}:</strong> Total smaller elements after [${currentIndex}] = ${count}
                    </div>
                `;
                
                // Highlight the result
                currentElement.classList.remove('smaller-count-current');
                currentElement.classList.add('smaller-count-result');
                currentElement.textContent = `${arr[currentIndex]} (${count})`;
                
                // Update results table for this element
                updateResultsTableRow(currentIndex, arr, result);
                
                // Move to next element
                currentIndex++;
                setTimeout(performCountStep, 1000);
                return;
            }
            
            comparisonStep++;
            
            if (j <= currentIndex) {
                // Skip elements before or at current index
                performComparison(j + 1);
                return;
            }
            
            explanation.innerHTML = `Comparing [${currentIndex}]=${arr[currentIndex]} with [${j}]=${arr[j]}`;
            
            // Highlight compared element
            const comparedElement = transformedElements[j].querySelector('.element-value');
            comparedElement.classList.add('smaller-count-compared');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}.${comparisonStep}:</strong> Compare [${currentIndex}]=${arr[currentIndex]} with [${j}]=${arr[j]}
                </div>
            `;
            
            setTimeout(() => {
                if (arr[j] < arr[currentIndex]) {
                    // Found a smaller element
                    count++;
                    comparedElement.classList.remove('smaller-count-compared');
                    comparedElement.classList.add('smaller-count-smaller');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step}.${comparisonStep}:</strong> [${j}]=${arr[j]} is SMALLER than [${currentIndex}]=${arr[currentIndex]} - Count: ${count}
                        </div>
                    `;
                    
                    setTimeout(() => {
                        comparedElement.classList.remove('smaller-count-smaller');
                        performComparison(j + 1);
                    }, 1000);
                } else {
                    // Element is not smaller
                    comparedElement.classList.remove('smaller-count-compared');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step}.${comparisonStep}:</strong> [${j}]=${arr[j]} is NOT smaller than [${currentIndex}]=${arr[currentIndex]} - Count: ${count}
                        </div>
                    `;
                    
                    performComparison(j + 1);
                }
            }, 1000);
        }
        
        // Start comparisons for current element
        setTimeout(() => {
            performComparison(currentIndex + 1);
        }, 1000);
    }
    
    // Start counting process
    performCountStep();
}

// NEW: Initialize Results Table
function initializeResultsTable(arr, result) {
    const resultsTable = document.getElementById('smallerCountResultsTable');
    
    let tableHTML = `
        <table class="smaller-count-table">
            <thead>
                <tr>
                    <th>Index</th>
                    <th>Element Value</th>
                    <th>Count of Smaller Numbers After Self</th>
                </tr>
            </thead>
            <tbody>
    `;
    
    for (let i = 0; i < arr.length; i++) {
        tableHTML += `
            <tr id="resultRow-${i}">
                <td>[${i}]</td>
                <td>${arr[i]}</td>
                <td id="resultCount-${i}">-</td>
            </tr>
        `;
    }
    
    tableHTML += `
            </tbody>
        </table>
    `;
    
    resultsTable.innerHTML = tableHTML;
}

// NEW: Update Results Table Row
function updateResultsTableRow(index, arr, result) {
    const resultCountCell = document.getElementById(`resultCount-${index}`);
    const resultRow = document.getElementById(`resultRow-${index}`);
    
    if (resultCountCell && resultRow) {
        resultCountCell.textContent = result[index];
        resultCountCell.classList.add('stats-value');
        resultRow.style.background = 'rgba(0, 184, 148, 0.1)';
        
        // Add animation effect
        setTimeout(() => {
            resultCountCell.classList.add('pulse');
            setTimeout(() => {
                resultCountCell.classList.remove('pulse');
            }, 500);
        }, 100);
    }
}

// NEW: Update Complete Results Table
function updateResultsTable(arr, result) {
    const resultsTable = document.getElementById('smallerCountResultsTable');
    
    let tableHTML = `
        <table class="smaller-count-table">
            <thead>
                <tr>
                    <th>Index</th>
                    <th>Element Value</th>
                    <th>Count of Smaller Numbers After Self</th>
                </tr>
            </thead>
            <tbody>
    `;
    
    for (let i = 0; i < arr.length; i++) {
        tableHTML += `
            <tr style="background: rgba(0, 184, 148, 0.1);">
                <td>[${i}]</td>
                <td>${arr[i]}</td>
                <td class="stats-value">${result[i]}</td>
            </tr>
        `;
    }
    
    tableHTML += `
            </tbody>
        </table>
        <div class="text-center mt-3">
            <small class="text-success">
                <i class="fas fa-check-circle me-1"></i>
                All counts calculated successfully!
            </small>
        </div>
    `;
    
    resultsTable.innerHTML = tableHTML;
}

// NEW: Return to Original after Smaller Count
function returnToOriginalAfterSmallerCount() {
    // Reset to original array
    myArray = [...originalArrayForSmallerCount];
    originalArrayForSmallerCount = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isSmallerCountRunning = false;
    
    logOperation('Count of smaller numbers after self completed - returned to original array', 'info');
    showNotification('Returned to original array after count operation', 'success');
}
// NEW: Check Ugly Number Handler
function handleCheckUglyNumber() {
    const num = parseInt(uglyNumberInput.value);
    
    if (isNaN(num) || num < 1) {
        showNotification('Please enter a valid positive number', 'danger');
        uglyNumberInput.focus();
        return;
    }
    
    if (isUglyNumberOperationRunning) {
        showNotification('An ugly number operation is already in progress', 'warning');
        return;
    }
    
    isUglyNumberOperationRunning = true;
    
    // Show visualization
    showUglyNumberCheckVisualization(num);
}

// NEW: Find Nth Ugly Number Handler
function handleFindNthUglyNumber() {
    const n = parseInt(nthUglyNumberInput.value);
    
    if (isNaN(n) || n < 1 || n > 100) {
        showNotification('Please enter a valid n between 1 and 100', 'danger');
        nthUglyNumberInput.focus();
        return;
    }
    
    if (isUglyNumberOperationRunning) {
        showNotification('An ugly number operation is already in progress', 'warning');
        return;
    }
    
    isUglyNumberOperationRunning = true;
    
    // Show visualization
    showNthUglyNumberVisualization(n);
}

// NEW: Find Super Ugly Number Handler
function handleFindSuperUglyNumber() {
    const n = parseInt(superUglyNInput.value);
    const primesInput = superUglyPrimesInput.value.trim();
    
    if (isNaN(n) || n < 1 || n > 50) {
        showNotification('Please enter a valid n between 1 and 50', 'danger');
        superUglyNInput.focus();
        return;
    }
    
    if (primesInput === '') {
        showNotification('Please enter prime numbers separated by commas', 'danger');
        superUglyPrimesInput.focus();
        return;
    }
    
    // Parse primes
    const primes = primesInput.split(',').map(p => parseInt(p.trim())).filter(p => !isNaN(p) && p > 1);
    
    if (primes.length === 0) {
        showNotification('Please enter valid prime numbers (e.g., 2,3,5,7)', 'danger');
        superUglyPrimesInput.focus();
        return;
    }
    
    if (isUglyNumberOperationRunning) {
        showNotification('An ugly number operation is already in progress', 'warning');
        return;
    }
    
    isUglyNumberOperationRunning = true;
    
    // Show visualization
    showSuperUglyNumberVisualization(n, primes);
}

// NEW: Show Ugly Number Check Visualization
function showUglyNumberCheckVisualization(num) {
    const visualizationContainer = document.createElement('div');
    visualizationContainer.className = 'dual-operation-container';
    visualizationContainer.innerHTML = `
        <h5 class="text-center mb-3">Checking Ugly Number: ${num}</h5>
        
        <div class="array-group">
            <div class="array-label">Prime Factorization Process</div>
            <div class="original-array-container" id="factorizationProcess"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Ugly Number Check:</strong> Keep dividing by 2, 3, 5 until we reach 1</p>
            <p class="mb-0" id="uglyCheckExplanation">Starting factorization process...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="uglyCheckStepsContainer">
            <h6 class="text-center">Factorization Steps</h6>
            <div class="steps-container" id="uglyCheckSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Final Result</div>
            <div class="stats-value" id="uglyCheckResult">Processing...</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterUglyCheck" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Operations
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(visualizationContainer);
    
    performUglyNumberCheckAnimation(num);
}

// NEW: Perform Ugly Number Check Animation
function performUglyNumberCheckAnimation(num) {
    const processContainer = document.getElementById('factorizationProcess');
    const explanation = document.getElementById('uglyCheckExplanation');
    const stepsContainer = document.getElementById('uglyCheckSteps');
    const resultDiv = document.getElementById('uglyCheckResult');
    const continueButton = document.getElementById('continueAfterUglyCheck');
    
    let currentNumber = num;
    let step = 0;
    const primes = [2, 3, 5];
    
    function performFactorizationStep() {
        if (currentNumber === 1) {
            // Success - number is ugly
            explanation.innerHTML = `<strong>Success!</strong> Number reduced to 1 - it's an Ugly Number!`;
            resultDiv.innerHTML = `<span class="text-success">${num} is an Ugly Number</span>`;
            resultDiv.classList.add('success-color');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Number reduced to 1 -  UGLY NUMBER
                </div>
            `;
            
            showCompletion();
            return;
        }
        
        if (currentNumber < 1) {
            // Invalid case
            explanation.innerHTML = `<strong>Invalid:</strong> Number became less than 1`;
            resultDiv.innerHTML = `<span class="text-danger">${num} is NOT an Ugly Number</span>`;
            resultDiv.classList.add('danger-color');
            showCompletion();
            return;
        }
        
        step++;
        let divisible = false;
        
        // Check divisibility by each prime
        for (let i = 0; i < primes.length; i++) {
            const prime = primes[i];
            if (currentNumber % prime === 0) {
                divisible = true;
                const oldNumber = currentNumber;
                currentNumber = currentNumber / prime;
                
                explanation.innerHTML = `Step ${step}: ${oldNumber}  ${prime} = ${currentNumber}`;
                
                // Display current state
                const stepDiv = document.createElement('div');
                stepDiv.className = 'array-element';
                stepDiv.innerHTML = `
                    <div class="element-value warning-color">
                        ${oldNumber}  ${prime}
                    </div>
                    <div class="element-index">Step ${step}</div>
                `;
                processContainer.appendChild(stepDiv);
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> ${oldNumber}  ${prime} = ${currentNumber}
                    </div>
                `;
                
                // Scroll to bottom
                stepsContainer.scrollTop = stepsContainer.scrollHeight;
                
                // Animate the step
                setTimeout(() => {
                    stepDiv.querySelector('.element-value').classList.add('pulse');
                    setTimeout(() => {
                        performFactorizationStep();
                    }, 1000);
                }, 500);
                
                break;
            }
        }
        
        if (!divisible) {
            // Not divisible by any ugly prime - not an ugly number
            explanation.innerHTML = `<strong>Failed!</strong> ${currentNumber} is not divisible by 2, 3, or 5`;
            resultDiv.innerHTML = `<span class="text-danger">${num} is NOT an Ugly Number</span>`;
            resultDiv.classList.add('danger-color');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Final:</strong> Stuck at ${currentNumber} -  NOT UGLY NUMBER
                </div>
            `;
            
            showCompletion();
        }
    }
    
    function showCompletion() {
        continueButton.style.display = 'block';
        
        // Auto-return after 5 seconds
        setTimeout(() => {
            returnToOperationsAfterUglyCheck();
        }, 5000);
        
        continueButton.addEventListener('click', returnToOperationsAfterUglyCheck);
    }
    
    // Start the process
    performFactorizationStep();
}

// NEW: Show Nth Ugly Number Visualization
function showNthUglyNumberVisualization(n) {
    const visualizationContainer = document.createElement('div');
    visualizationContainer.className = 'dual-operation-container';
    visualizationContainer.innerHTML = `
        <h5 class="text-center mb-3">Finding ${getOrdinal(n)} Ugly Number</h5>
        
        <div class="array-group">
            <div class="array-label">Ugly Numbers Sequence</div>
            <div class="original-array-container" id="uglySequenceContainer"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Dynamic Programming Approach:</strong> Generate ugly numbers using three pointers</p>
            <p class="mb-0" id="nthUglyExplanation">Initializing sequence generation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="nthUglyStepsContainer">
            <h6 class="text-center">Generation Steps</h6>
            <div class="steps-container" id="nthUglySteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Pointers Status</div>
            <div class="stats-value" id="pointersStatus">i2=0, i3=0, i5=0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>${getOrdinal(n)} Ugly Number</div>
            <div class="stats-value" id="nthUglyResult">Processing...</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterNthUgly" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Operations
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(visualizationContainer);
    
    performNthUglyNumberAnimation(n);
}

// NEW: Perform Nth Ugly Number Animation
function performNthUglyNumberAnimation(n) {
    const sequenceContainer = document.getElementById('uglySequenceContainer');
    const explanation = document.getElementById('nthUglyExplanation');
    const stepsContainer = document.getElementById('nthUglySteps');
    const pointersStatus = document.getElementById('pointersStatus');
    const resultDiv = document.getElementById('nthUglyResult');
    const continueButton = document.getElementById('continueAfterNthUgly');
    
    const ugly = [1];
    let i2 = 0, i3 = 0, i5 = 0;
    let step = 0;
    
    // Display initial state
    renderUglySequence(ugly, sequenceContainer, i2, i3, i5);
    
    function generateNextUglyNumber() {
        if (ugly.length >= n) {
            // Generation completed
            const result = ugly[n - 1];
            explanation.innerHTML = `<strong>Generation Completed!</strong> ${getOrdinal(n)} Ugly Number found.`;
            resultDiv.innerHTML = `<span class="text-success">${result}</span>`;
            resultDiv.classList.add('success-color');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> ${getOrdinal(n)} Ugly Number = ${result}
                </div>
            `;
            
            showCompletion();
            return;
        }
        
        step++;
        const next2 = ugly[i2] * 2;
        const next3 = ugly[i3] * 3;
        const next5 = ugly[i5] * 5;
        const nextUgly = Math.min(next2, next3, next5);
        
        explanation.innerHTML = `Step ${step}: min(${next2}, ${next3}, ${next5}) = ${nextUgly}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> min(ugly[${i2}]2=${next2}, ugly[${i3}]3=${next3}, ugly[${i5}]5=${next5}) = ${nextUgly}
            </div>
        `;
        
        // Add to sequence
        ugly.push(nextUgly);
        
        // Update pointers
        if (nextUgly === next2) i2++;
        if (nextUgly === next3) i3++;
        if (nextUgly === next5) i5++;
        
        pointersStatus.textContent = `i2=${i2}, i3=${i3}, i5=${i5}`;
        
        // Update visualization
        setTimeout(() => {
            renderUglySequence(ugly, sequenceContainer, i2, i3, i5);
            
            // Highlight the new number
            const newElement = sequenceContainer.lastChild;
            if (newElement) {
                newElement.querySelector('.element-value').classList.add('create', 'bounce');
            }
            
            // Continue generation
            setTimeout(() => {
                generateNextUglyNumber();
            }, 1500);
        }, 1000);
    }
    
    function showCompletion() {
        continueButton.style.display = 'block';
        
        // Auto-return after 5 seconds
        setTimeout(() => {
            returnToOperationsAfterUglyCheck();
        }, 5000);
        
        continueButton.addEventListener('click', returnToOperationsAfterUglyCheck);
    }
    
    // Start generation
    generateNextUglyNumber();
}

// NEW: Show Super Ugly Number Visualization
function showSuperUglyNumberVisualization(n, primes) {
    const visualizationContainer = document.createElement('div');
    visualizationContainer.className = 'dual-operation-container';
    visualizationContainer.innerHTML = `
        <h5 class="text-center mb-3">Finding ${getOrdinal(n)} Super Ugly Number</h5>
        
        <div class="array-group">
            <div class="array-label">Super Ugly Numbers Sequence</div>
            <div class="original-array-container" id="superUglySequenceContainer"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Super Ugly Numbers:</strong> Using primes [${primes.join(', ')}]</p>
            <p class="mb-0" id="superUglyExplanation">Initializing sequence generation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="superUglyStepsContainer">
            <h6 class="text-center">Generation Steps</h6>
            <div class="steps-container" id="superUglySteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Pointers Status</div>
            <div class="stats-value" id="superPointersStatus">${primes.map((_, i) => `i${i}=0`).join(', ')}</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>${getOrdinal(n)} Super Ugly Number</div>
            <div class="stats-value" id="superUglyResult">Processing...</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSuperUgly" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Operations
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(visualizationContainer);
    
    performSuperUglyNumberAnimation(n, primes);
}

// NEW: Perform Super Ugly Number Animation
function performSuperUglyNumberAnimation(n, primes) {
    const sequenceContainer = document.getElementById('superUglySequenceContainer');
    const explanation = document.getElementById('superUglyExplanation');
    const stepsContainer = document.getElementById('superUglySteps');
    const pointersStatus = document.getElementById('superPointersStatus');
    const resultDiv = document.getElementById('superUglyResult');
    const continueButton = document.getElementById('continueAfterSuperUgly');
    
    const ugly = [1];
    const indices = Array(primes.length).fill(0);
    let step = 0;
    
    // Display initial state
    renderSuperUglySequence(ugly, sequenceContainer, indices, primes);
    
    function generateNextSuperUglyNumber() {
        if (ugly.length >= n) {
            // Generation completed
            const result = ugly[n - 1];
            explanation.innerHTML = `<strong>Generation Completed!</strong> ${getOrdinal(n)} Super Ugly Number found.`;
            resultDiv.innerHTML = `<span class="text-success">${result}</span>`;
            resultDiv.classList.add('success-color');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> ${getOrdinal(n)} Super Ugly Number = ${result}
                </div>
            `;
            
            showCompletion();
            return;
        }
        
        step++;
        
        // Calculate next candidates
        const candidates = primes.map((p, j) => ugly[indices[j]] * p);
        const nextUgly = Math.min(...candidates);
        
        explanation.innerHTML = `Step ${step}: min(${candidates.join(', ')}) = ${nextUgly}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> min(${candidates.map((c, j) => `ugly[${indices[j]}]${primes[j]}=${c}`).join(', ')}) = ${nextUgly}
            </div>
        `;
        
        // Add to sequence
        ugly.push(nextUgly);
        
        // Update pointers
        primes.forEach((p, j) => {
            if (nextUgly === ugly[indices[j]] * p) {
                indices[j]++;
            }
        });
        
        pointersStatus.textContent = indices.map((idx, j) => `i${j}=${idx}`).join(', ');
        
        // Update visualization
        setTimeout(() => {
            renderSuperUglySequence(ugly, sequenceContainer, indices, primes);
            
            // Highlight the new number
            const newElement = sequenceContainer.lastChild;
            if (newElement) {
                newElement.querySelector('.element-value').classList.add('create', 'bounce');
            }
            
            // Continue generation
            setTimeout(() => {
                generateNextSuperUglyNumber();
            }, 1500);
        }, 1000);
    }
    
    function showCompletion() {
        continueButton.style.display = 'block';
        
        // Auto-return after 5 seconds
        setTimeout(() => {
            returnToOperationsAfterUglyCheck();
        }, 5000);
        
        continueButton.addEventListener('click', returnToOperationsAfterUglyCheck);
    }
    
    // Start generation
    generateNextSuperUglyNumber();
}

// NEW: Helper function to render ugly sequence
function renderUglySequence(ugly, container, i2, i3, i5) {
    container.innerHTML = '';
    
    ugly.forEach((num, index) => {
        const element = document.createElement('div');
        element.className = 'array-element';
        
        let specialClass = '';
        if (index === i2) specialClass = 'two-pointer-left';
        else if (index === i3) specialClass = 'two-pointer-right';
        else if (index === i5) specialClass = 'info-color';
        
        element.innerHTML = `
            <div class="element-value ${specialClass}">
                ${num}
            </div>
            <div class="element-index">[${index}]</div>
        `;
        
        container.appendChild(element);
    });
}

// NEW: Helper function to render super ugly sequence
function renderSuperUglySequence(ugly, container, indices, primes) {
    container.innerHTML = '';
    
    ugly.forEach((num, index) => {
        const element = document.createElement('div');
        element.className = 'array-element';
        
        // Find if this index is a pointer for any prime
        let pointerIndex = indices.indexOf(index);
        let specialClass = pointerIndex !== -1 ? `window-included` : '';
        
        element.innerHTML = `
            <div class="element-value ${specialClass}">
                ${num}
            </div>
            <div class="element-index">[${index}]</div>
        `;
        
        if (pointerIndex !== -1) {
            const pointerLabel = document.createElement('div');
            pointerLabel.className = 'element-pointer';
            pointerLabel.textContent = `${primes[pointerIndex]}`;
            pointerLabel.style.fontSize = '0.7rem';
            pointerLabel.style.color = 'var(--warning-color)';
            element.appendChild(pointerLabel);
        }
        
        container.appendChild(element);
    });
}

// NEW: Helper function to get ordinal number
function getOrdinal(n) {
    const suffixes = ['th', 'st', 'nd', 'rd'];
    const value = n % 100;
    return n + (suffixes[(value - 20) % 10] || suffixes[value] || suffixes[0]);
}

// NEW: Return to operations after ugly number check
function returnToOperationsAfterUglyCheck() {
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isUglyNumberOperationRunning = false;
    
    // Clear inputs
    uglyNumberInput.value = '';
    nthUglyNumberInput.value = '';
    superUglyNInput.value = '';
    superUglyPrimesInput.value = '';
    
    logOperation('Ugly number operation completed', 'info');
    showNotification('Returned to normal array view', 'success');
}
// NEW: Find Perfect Numbers Handler
function handleFindPerfectNumbers() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isPerfectNumberRunning) {
        showNotification('Perfect number detection is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseInt(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Perfect number detection requires all array elements to be integers', 'danger');
        return;
    }
    
    isPerfectNumberRunning = true;
    
    // Store original array
    originalArrayForSpecialNumbers = [...myArray];
    
    // Show perfect number visualization
    showPerfectNumberVisualization();
}

// NEW: Find Armstrong Numbers Handler
function handleFindArmstrongNumbers() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isArmstrongNumberRunning) {
        showNotification('Armstrong number detection is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseInt(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Armstrong number detection requires all array elements to be integers', 'danger');
        return;
    }
    
    isArmstrongNumberRunning = true;
    
    // Store original array
    originalArrayForSpecialNumbers = [...myArray];
    
    // Show Armstrong number visualization
    showArmstrongNumberVisualization();
}
// NEW: Show Perfect Number Visualization
function showPerfectNumberVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Perfect Number Detection</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalPerfectArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Perfect Numbers Found</div>
            <div class="transformed-array-container" id="perfectNumbersArray"></div>
        </div>
        
        <div class="perfect-explanation">
            <p class="mb-2"><strong>Perfect Number:</strong> A number that equals the sum of its proper divisors (excluding itself)</p>
            <p class="mb-0" id="perfectExplanation">Starting perfect number detection...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="perfectStepsContainer">
            <h6 class="text-center">Perfect Number Detection Steps</h6>
            <div class="steps-container" id="perfectSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Perfect Numbers Found</div>
            <div class="stats-value" id="perfectCount">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPerfect" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSpecialNumbers, 'originalPerfectArray');
    renderArrayInContainer([], 'perfectNumbersArray');
    
    performPerfectNumberDetection();
}

// NEW: Show Armstrong Number Visualization
function showArmstrongNumberVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Armstrong Number Detection</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalArmstrongArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Armstrong Numbers Found</div>
            <div class="transformed-array-container" id="armstrongNumbersArray"></div>
        </div>
        
        <div class="armstrong-explanation">
            <p class="mb-2"><strong>Armstrong Number:</strong> A number that equals the sum of its own digits each raised to the power of the number of digits</p>
            <p class="mb-0" id="armstrongExplanation">Starting Armstrong number detection...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="armstrongStepsContainer">
            <h6 class="text-center">Armstrong Number Detection Steps</h6>
            <div class="steps-container" id="armstrongSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Armstrong Numbers Found</div>
            <div class="stats-value" id="armstrongCount">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterArmstrong" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSpecialNumbers, 'originalArmstrongArray');
    renderArrayInContainer([], 'armstrongNumbersArray');
    
    performArmstrongNumberDetection();
}
// NEW: Helper function to check if a number is perfect
function isPerfectNumber(num) {
    if (num <= 1) return false;
    
    let sum = 1; // 1 is always a divisor
    for (let i = 2; i <= Math.sqrt(num); i++) {
        if (num % i === 0) {
            sum += i;
            if (i !== num / i) {
                sum += num / i;
            }
        }
    }
    return sum === num;
}

// NEW: Helper function to check if a number is Armstrong
function isArmstrongNumber(num) {
    const digits = num.toString().split('');
    const power = digits.length;
    const sum = digits.reduce((total, digit) => total + Math.pow(parseInt(digit), power), 0);
    return sum === num;
}

// NEW: Perform Perfect Number Detection with Animation
function performPerfectNumberDetection() {
    const originalContainer = document.getElementById('originalPerfectArray');
    const perfectContainer = document.getElementById('perfectNumbersArray');
    const explanation = document.getElementById('perfectExplanation');
    const stepsContainer = document.getElementById('perfectSteps');
    const perfectCount = document.getElementById('perfectCount');
    const continueButton = document.getElementById('continueAfterPerfect');
    
    const arr = originalArrayForSpecialNumbers.map(val => parseInt(val));
    let perfectNumbers = [];
    let currentIndex = 0;
    
    function checkNextNumber() {
        if (currentIndex >= arr.length) {
            // Detection completed
            explanation.innerHTML = `<strong>Perfect Number Detection Completed!</strong> Found ${perfectNumbers.length} perfect number(s).`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Perfect numbers found: ${perfectNumbers.length > 0 ? perfectNumbers.join(', ') : 'None'}
                </div>
            `;
            
            perfectCount.textContent = perfectNumbers.length;
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterSpecialNumbers();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSpecialNumbers);
            
            return;
        }
        
        const currentNumber = arr[currentIndex];
        explanation.innerHTML = `Checking if ${currentNumber} is a perfect number...`;
        
        // Highlight current number being checked
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentIndex].querySelector('.element-value');
        currentElement.classList.add('checking-perfect');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${currentIndex + 1}:</strong> Checking ${currentNumber} for perfect number property
            </div>
        `;
        
        // Check if perfect number
        setTimeout(() => {
            if (isPerfectNumber(currentNumber)) {
                perfectNumbers.push(currentNumber);
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Found!</strong> ${currentNumber} is a perfect number! 
                        (Sum of proper divisors = ${currentNumber})
                    </div>
                `;
                
                // Highlight as perfect number
                currentElement.classList.remove('checking-perfect');
                currentElement.classList.add('perfect-number');
                
                // Add to perfect numbers array
                renderArrayInContainer(perfectNumbers, 'perfectNumbersArray');
                perfectCount.textContent = perfectNumbers.length;
                
                // Highlight the new perfect number in results
                const perfectElements = perfectContainer.querySelectorAll('.array-element');
                if (perfectElements.length > 0) {
                    const newPerfectElement = perfectElements[perfectElements.length - 1].querySelector('.element-value');
                    newPerfectElement.classList.add('perfect-number', 'bounce');
                }
                
            } else {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Not Perfect:</strong> ${currentNumber} is not a perfect number
                    </div>
                `;
                
                currentElement.classList.remove('checking-perfect');
            }
            
            // Scroll to bottom of steps
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            currentIndex++;
            setTimeout(checkNextNumber, 1500);
        }, 1000);
    }
    
    // Start detection process
    checkNextNumber();
}

// NEW: Perform Armstrong Number Detection with Animation
function performArmstrongNumberDetection() {
    const originalContainer = document.getElementById('originalArmstrongArray');
    const armstrongContainer = document.getElementById('armstrongNumbersArray');
    const explanation = document.getElementById('armstrongExplanation');
    const stepsContainer = document.getElementById('armstrongSteps');
    const armstrongCount = document.getElementById('armstrongCount');
    const continueButton = document.getElementById('continueAfterArmstrong');
    
    const arr = originalArrayForSpecialNumbers.map(val => parseInt(val));
    let armstrongNumbers = [];
    let currentIndex = 0;
    
    function checkNextNumber() {
        if (currentIndex >= arr.length) {
            // Detection completed
            explanation.innerHTML = `<strong>Armstrong Number Detection Completed!</strong> Found ${armstrongNumbers.length} Armstrong number(s).`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Armstrong numbers found: ${armstrongNumbers.length > 0 ? armstrongNumbers.join(', ') : 'None'}
                </div>
            `;
            
            armstrongCount.textContent = armstrongNumbers.length;
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterSpecialNumbers();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSpecialNumbers);
            
            return;
        }
        
        const currentNumber = arr[currentIndex];
        explanation.innerHTML = `Checking if ${currentNumber} is an Armstrong number...`;
        
        // Highlight current number being checked
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentIndex].querySelector('.element-value');
        currentElement.classList.add('checking-armstrong');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${currentIndex + 1}:</strong> Checking ${currentNumber} for Armstrong number property
            </div>
        `;
        
        // Check if Armstrong number
        setTimeout(() => {
            if (isArmstrongNumber(currentNumber)) {
                armstrongNumbers.push(currentNumber);
                
                const digits = currentNumber.toString().split('');
                const power = digits.length;
                const sum = digits.reduce((total, digit) => total + Math.pow(parseInt(digit), power), 0);
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Found!</strong> ${currentNumber} is an Armstrong number! 
                        (${digits.join('^' + power + ' + ')}^${power} = ${sum})
                    </div>
                `;
                
                // Highlight as Armstrong number
                currentElement.classList.remove('checking-armstrong');
                currentElement.classList.add('armstrong-number');
                
                // Add to Armstrong numbers array
                renderArrayInContainer(armstrongNumbers, 'armstrongNumbersArray');
                armstrongCount.textContent = armstrongNumbers.length;
                
                // Highlight the new Armstrong number in results
                const armstrongElements = armstrongContainer.querySelectorAll('.array-element');
                if (armstrongElements.length > 0) {
                    const newArmstrongElement = armstrongElements[armstrongElements.length - 1].querySelector('.element-value');
                    newArmstrongElement.classList.add('armstrong-number', 'bounce');
                }
                
            } else {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Not Armstrong:</strong> ${currentNumber} is not an Armstrong number
                    </div>
                `;
                
                currentElement.classList.remove('checking-armstrong');
            }
            
            // Scroll to bottom of steps
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            currentIndex++;
            setTimeout(checkNextNumber, 1500);
        }, 1000);
    }
    
    // Start detection process
    checkNextNumber();
}

// NEW: Return to Original after Special Number Detection
function returnToOriginalAfterSpecialNumbers() {
    // Reset to original array
    myArray = [...originalArrayForSpecialNumbers];
    originalArrayForSpecialNumbers = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset states
    isPerfectNumberRunning = false;
    isArmstrongNumberRunning = false;
    
    logOperation('Special number detection completed - returned to original array', 'info');
    showNotification('Returned to original array after special number detection', 'success');
}
// NEW: Pascal's Triangle - Specific Row Handler
function handlePascalSpecificRow() {
    const rowNum = parseInt(pascalRowNumber.value);
    
    if (isNaN(rowNum) || rowNum < 0 || rowNum > 20) {
        showNotification('Please enter a valid row number between 0 and 20', 'danger');
        pascalRowNumber.focus();
        return;
    }
    
    if (isPascalOperationRunning) {
        showNotification('A Pascal operation is already in progress', 'warning');
        return;
    }
    
    isPascalOperationRunning = true;
    
    // Store original array
    originalArrayForPascal = [...myArray];
    
    // Generate and display specific row
    showPascalSpecificRow(rowNum);
}

// NEW: Pascal's Triangle - Multiple Rows Handler
function handlePascalMultipleRows() {
    const numRows = parseInt(pascalNumRows.value);
    
    if (isNaN(numRows) || numRows < 1 || numRows > 10) {
        showNotification('Please enter a valid number of rows between 1 and 10', 'danger');
        pascalNumRows.focus();
        return;
    }
    
    if (isPascalOperationRunning) {
        showNotification('A Pascal operation is already in progress', 'warning');
        return;
    }
    
    isPascalOperationRunning = true;
    
    // Store original array
    originalArrayForPascal = [...myArray];
    
    // Generate and display multiple rows
    showPascalMultipleRows(numRows);
}

// NEW: Show Pascal's Triangle Specific Row
function showPascalSpecificRow(rowNum) {
    const pascalContainer = document.createElement('div');
    pascalContainer.className = 'dual-operation-container';
    pascalContainer.innerHTML = `
        <h5 class="text-center mb-3">Pascal's Triangle - Row ${rowNum}</h5>
        
        <div class="array-group">
            <div class="array-label">Row ${rowNum} of Pascal's Triangle</div>
            <div class="transformed-array-container" id="pascalRowContainer"></div>
        </div>
        
        <div class="pascal-explanation">
            <p class="mb-2"><strong>Pascal's Triangle Row Generation:</strong> Each element is computed using binomial coefficients</p>
            <p class="mb-0" id="pascalExplanation">Generating row ${rowNum}...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="pascalStepsContainer">
            <h6 class="text-center">Row Generation Steps</h6>
            <div class="steps-container" id="pascalSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPascal" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(pascalContainer);
    
    generatePascalRowWithAnimation(rowNum);
}

// NEW: Show Pascal's Triangle Multiple Rows
function showPascalMultipleRows(numRows) {
    const pascalContainer = document.createElement('div');
    pascalContainer.className = 'pascal-triangle-container';
    pascalContainer.innerHTML = `
        <h5 class="text-center mb-3">Pascal's Triangle - First ${numRows} Rows</h5>
        
        <div id="pascalTriangleContainer" class="mb-3"></div>
        
        <div class="pascal-explanation">
            <p class="mb-2"><strong>Pascal's Triangle:</strong> Each number is the sum of the two numbers directly above it</p>
            <p class="mb-0" id="pascalMultiExplanation">Generating ${numRows} rows...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="pascalMultiStepsContainer">
            <h6 class="text-center">Triangle Generation Steps</h6>
            <div class="steps-container" id="pascalMultiSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPascalMulti" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(pascalContainer);
    
    generatePascalTriangleWithAnimation(numRows);
}

// NEW: Generate Pascal's Triangle Row with Animation
function generatePascalRowWithAnimation(rowNum) {
    const rowContainer = document.getElementById('pascalRowContainer');
    const explanation = document.getElementById('pascalExplanation');
    const stepsContainer = document.getElementById('pascalSteps');
    const continueButton = document.getElementById('continueAfterPascal');
    
    const row = [];
    let currentStep = 0;
    
    function generateStep() {
        if (currentStep > rowNum) {
            // Generation completed
            explanation.innerHTML = `<strong>Row ${rowNum} Generated!</strong> Contains ${row.length} elements.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Row ${rowNum} of Pascal's Triangle: [${row.join(', ')}]
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterPascal();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterPascal);
            
            return;
        }
        
        // Calculate binomial coefficient C(rowNum, currentStep)
        explanation.innerHTML = `Calculating element at position ${currentStep}: C(${rowNum}, ${currentStep})`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentStep + 1}:</strong> Computing C(${rowNum}, ${currentStep}) = ${rowNum}! / (${currentStep}!  ${rowNum - currentStep}!)
            </div>
        `;
        
        setTimeout(() => {
            // Calculate binomial coefficient
            const value = binomialCoefficient(rowNum, currentStep);
            row.push(value);
            
            // Update row display
            renderPascalRow(row, 'pascalRowContainer');
            
            // Highlight the new element
            const elements = rowContainer.querySelectorAll('.array-element');
            const newElement = elements[currentStep].querySelector('.element-value');
            newElement.classList.add('highlight');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Result:</strong> C(${rowNum}, ${currentStep}) = ${value}
                </div>
            `;
            
            // Scroll steps container
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            currentStep++;
            generateStep();
        }, 1500);
    }
    
    // Start generation
    generateStep();
}

// NEW: Generate Pascal's Triangle with Animation
function generatePascalTriangleWithAnimation(numRows) {
    const triangleContainer = document.getElementById('pascalTriangleContainer');
    const explanation = document.getElementById('pascalMultiExplanation');
    const stepsContainer = document.getElementById('pascalMultiSteps');
    const continueButton = document.getElementById('continueAfterPascalMulti');
    
    const triangle = [];
    let currentRow = 0;
    
    function generateRow() {
        if (currentRow >= numRows) {
            // Generation completed
            explanation.innerHTML = `<strong>Pascal's Triangle Generated!</strong> ${numRows} rows created.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Pascal's Triangle with ${numRows} rows completed
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterPascal();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterPascal);
            
            return;
        }
        
        explanation.innerHTML = `Generating row ${currentRow}...`;
        
        const row = [];
        for (let i = 0; i <= currentRow; i++) {
            if (i === 0 || i === currentRow) {
                row.push(1);
            } else {
                row.push(triangle[currentRow - 1][i - 1] + triangle[currentRow - 1][i]);
            }
        }
        
        triangle.push(row);
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Row ${currentRow}:</strong> [${row.join(', ')}]
            </div>
        `;
        
        // Update triangle display
        renderPascalTriangle(triangle);
        
        // Highlight the current row
        const rows = triangleContainer.querySelectorAll('.pascal-row');
        const currentRowElements = rows[currentRow].querySelectorAll('.pascal-element');
        
        currentRowElements.forEach(element => {
            element.classList.add('highlight');
        });
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        currentRow++;
        setTimeout(generateRow, 1000);
    }
    
    // Start generation
    generateRow();
}

// NEW: Render Pascal's Triangle Row
function renderPascalRow(row, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    row.forEach((value, index) => {
        const elementDiv = document.createElement('div');
        elementDiv.className = 'array-element';
        elementDiv.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(elementDiv);
    });
}

// NEW: Render Pascal's Triangle
function renderPascalTriangle(triangle) {
    const container = document.getElementById('pascalTriangleContainer');
    container.innerHTML = '';
    
    triangle.forEach((row, rowIndex) => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'pascal-row';
        
        row.forEach(value => {
            const elementDiv = document.createElement('div');
            elementDiv.className = 'pascal-element';
            elementDiv.textContent = value;
            rowDiv.appendChild(elementDiv);
        });
        
        container.appendChild(rowDiv);
    });
}

// NEW: Binomial Coefficient Calculation
function binomialCoefficient(n, k) {
    if (k < 0 || k > n) return 0;
    if (k === 0 || k === n) return 1;
    
    let result = 1;
    for (let i = 1; i <= k; i++) {
        result = result * (n - i + 1) / i;
    }
    return result;
}

// NEW: Return to Original after Pascal Operations
function returnToOriginalAfterPascal() {
    // Reset to original array
    myArray = [...originalArrayForPascal];
    originalArrayForPascal = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isPascalOperationRunning = false;
    
    // Clear inputs
    pascalRowNumber.value = '';
    pascalNumRows.value = '';
    
    logOperation('Pascal\'s Triangle operation completed - returned to original array', 'info');
    showNotification('Returned to original array after Pascal\'s Triangle operation', 'success');
}
// NEW: Random Pick with Weight Handler
function handleRandomPickWithWeight() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isRandomPickRunning) {
        showNotification('Random pick operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers (weights)
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Random Pick with Weight requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForRandomPick = [...myArray];
    
    // Show random pick visualization
    showRandomPickVisualization();
}

// NEW: Show Random Pick Visualization
function showRandomPickVisualization() {
    isRandomPickRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Random Pick with Weight - Cumulative Weights Method</h5>
        
        <div class="array-group">
            <div class="array-label">Original Weights Array</div>
            <div class="original-array-container" id="originalWeightsArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Cumulative Weights Array</div>
            <div class="transformed-array-container" id="cumulativeWeightsArray"></div>
        </div>
        
        <!-- Results Display Section -->
        <div class="results-display mt-4" id="randomPickResults" style="display: none;">
            <div class="row text-center">
                <div class="col-md-4">
                    <div class="stats-card">
                        <div>Random Number Generated</div>
                        <div class="stats-value" id="randomNumberValue">-</div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="stats-card">
                        <div>Selected Index</div>
                        <div class="stats-value" id="selectedIndexValue">-</div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="stats-card">
                        <div>Selected Element Value</div>
                        <div class="stats-value" id="selectedElementValue">-</div>
                    </div>
                </div>
            </div>
            
            <!-- Random Pick Visualization Array -->
            <div class="array-group mt-3">
                <div class="array-label">Random Pick Selection</div>
                <div class="transformed-array-container" id="randomPickArray"></div>
            </div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Random selection based on weights using cumulative distribution</p>
            <p class="mb-0" id="randomPickExplanation">Initializing random pick with weights...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="randomPickStepsContainer">
            <h6 class="text-center">Random Pick Steps</h6>
            <div class="steps-container" id="randomPickSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterRandomPick" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForRandomPick, 'originalWeightsArray');
    renderArrayInContainer([...originalArrayForRandomPick], 'cumulativeWeightsArray');
    
    // Initialize random pick array with weight values (initially normal state)
    renderArrayInContainer(originalArrayForRandomPick, 'randomPickArray');
    
    performRandomPickAnimation();
}

// NEW: Perform Random Pick Animation
function performRandomPickAnimation() {
    const originalContainer = document.getElementById('originalWeightsArray');
    const cumulativeContainer = document.getElementById('cumulativeWeightsArray');
    const randomPickContainer = document.getElementById('randomPickArray');
    const explanation = document.getElementById('randomPickExplanation');
    const stepsContainer = document.getElementById('randomPickSteps');
    const randomNumberValue = document.getElementById('randomNumberValue');
    const selectedElementValue = document.getElementById('selectedElementValue');
    const selectedIndexValue = document.getElementById('selectedIndexValue');
    const resultsDisplay = document.getElementById('randomPickResults');
    const continueButton = document.getElementById('continueAfterRandomPick');
    
    const weights = originalArrayForRandomPick.map(val => parseFloat(val));
    let cumulativeWeights = [];
    let totalWeight = 0;
    let step = 0;
    
    function performRandomPickStep() {
        switch (step) {
            case 0:
                // Step 1: Calculate cumulative weights
                explanation.innerHTML = "Step 1: Calculating cumulative weights...";
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Calculate cumulative weights from original weights
                    </div>
                `;
                
                // Highlight original weights
                const originalElements = originalContainer.querySelectorAll('.array-element');
                originalElements.forEach((el, index) => {
                    setTimeout(() => {
                        el.querySelector('.element-value').classList.add('cumulative-highlight');
                    }, index * 300);
                });
                
                setTimeout(() => {
                    // Calculate cumulative weights
                    cumulativeWeights = [];
                    totalWeight = 0;
                    
                    for (let i = 0; i < weights.length; i++) {
                        totalWeight += weights[i];
                        cumulativeWeights.push(totalWeight);
                    }
                    
                    explanation.innerHTML = `Step 2: Cumulative weights calculated. Total weight = ${totalWeight}`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 2:</strong> Cumulative weights: [${cumulativeWeights.join(', ')}], Total weight = ${totalWeight}
                        </div>
                    `;
                    
                    // Update cumulative weights display
                    renderArrayInContainer(cumulativeWeights.map(w => w.toString()), 'cumulativeWeightsArray');
                    
                    // Highlight cumulative weights
                    const cumulativeElements = cumulativeContainer.querySelectorAll('.array-element');
                    cumulativeElements.forEach((el, index) => {
                        setTimeout(() => {
                            el.querySelector('.element-value').classList.add('prefix-highlight');
                        }, index * 300);
                    });
                    
                    step++;
                    performRandomPickStep();
                }, weights.length * 300 + 1000);
                break;
                
            case 1:
                // Step 3: Generate random number
                explanation.innerHTML = "Step 3: Generating random number between 0 and total weight...";
                
                setTimeout(() => {
                    const randomNum = Math.random() * totalWeight;
                    randomNumberValue.textContent = randomNum.toFixed(2);
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 3:</strong> Generated random number: ${randomNum.toFixed(2)} (range: 0 to ${totalWeight})
                        </div>
                    `;
                    
                    // Show results display
                    resultsDisplay.style.display = 'block';
                    
                    explanation.innerHTML = `Step 4: Finding element where cumulative weight  ${randomNum.toFixed(2)}`;
                    
                    step++;
                    performRandomPickStep();
                }, 1500);
                break;
                
            case 2:
                // Step 4: Find selected element
                const randomNum = parseFloat(randomNumberValue.textContent);
                let selectedIndex = -1;
                
                explanation.innerHTML = `Step 4: Searching for element where cumulative weight  ${randomNum.toFixed(2)}`;
                
                // Linear search visualization
                function findSelectedElement(currentIndex) {
                    if (currentIndex >= cumulativeWeights.length) {
                        // Should not happen if randomNum < totalWeight
                        selectedIndex = cumulativeWeights.length - 1;
                        completeSelection();
                        return;
                    }
                    
                    // Highlight current cumulative weight being checked
                    const cumulativeElements = cumulativeContainer.querySelectorAll('.array-element');
                    if (currentIndex > 0) {
                        cumulativeElements[currentIndex - 1].querySelector('.element-value').classList.remove('linear-search-current');
                        cumulativeElements[currentIndex - 1].querySelector('.element-value').classList.add('linear-search-checked');
                    }
                    
                    cumulativeElements[currentIndex].querySelector('.element-value').classList.add('linear-search-current');
                    
                    explanation.innerHTML = `Checking index ${currentIndex}: cumulative weight = ${cumulativeWeights[currentIndex]}, target = ${randomNum.toFixed(2)}`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step 4.${currentIndex + 1}:</strong> Check index ${currentIndex}: cumulative[${currentIndex}] = ${cumulativeWeights[currentIndex]} ${cumulativeWeights[currentIndex] >= randomNum ? '' : '<'} ${randomNum.toFixed(2)}
                        </div>
                    `;
                    
                    setTimeout(() => {
                        if (cumulativeWeights[currentIndex] >= randomNum) {
                            selectedIndex = currentIndex;
                            completeSelection();
                        } else {
                            findSelectedElement(currentIndex + 1);
                        }
                    }, 1500);
                }
                
                function completeSelection() {
                    // Remove current highlight
                    const cumulativeElements = cumulativeContainer.querySelectorAll('.array-element');
                    if (selectedIndex > 0) {
                        cumulativeElements[selectedIndex - 1].querySelector('.element-value').classList.remove('linear-search-checked');
                    }
                    cumulativeElements[selectedIndex].querySelector('.element-value').classList.remove('linear-search-current');
                    
                    // Highlight selected element in cumulative array
                    cumulativeElements[selectedIndex].querySelector('.element-value').classList.add('linear-search-found');
                    
                    // Also highlight corresponding original element
                    const originalElements = originalContainer.querySelectorAll('.array-element');
                    originalElements[selectedIndex].querySelector('.element-value').classList.add('linear-search-found');
                    
                    // Update random pick array - show all weights but highlight the selected one
                    const randomPickElements = randomPickContainer.querySelectorAll('.array-element');
                    
                    // Highlight the selected element in random pick array
                    setTimeout(() => {
                        randomPickElements[selectedIndex].querySelector('.element-value').classList.add('linear-search-found', 'bounce');
                    }, 500);
                    
                    explanation.innerHTML = `<strong>Selection Complete!</strong> Element at index ${selectedIndex} selected with weight ${weights[selectedIndex]}`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 5:</strong> Found! Index ${selectedIndex} selected (cumulative[${selectedIndex}] = ${cumulativeWeights[selectedIndex]}  ${randomNum.toFixed(2)})
                        </div>
                    `;
                    
                    // Update results display
                    selectedElementValue.textContent = weights[selectedIndex];
                    selectedIndexValue.textContent = selectedIndex;
                    
                    // Show probability information
                    const probability = (weights[selectedIndex] / totalWeight * 100).toFixed(2);
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Probability Analysis:</strong> 
                            <br> Element ${selectedIndex} weight: ${weights[selectedIndex]}
                            <br> Total weight: ${totalWeight}
                            <br> Selection probability: ${probability}%
                            <br> Random number: ${randomNum.toFixed(2)}
                        </div>
                    `;
                    
                    continueButton.style.display = 'block';
                    
                    // Auto-return after 10 seconds
                    setTimeout(() => {
                        returnToOriginalAfterRandomPick();
                    }, 10000);
                    
                    continueButton.addEventListener('click', returnToOriginalAfterRandomPick);
                }
                
                // Start the search
                findSelectedElement(0);
                break;
        }
    }
    
    // Start random pick process
    performRandomPickStep();
}

// NEW: Return to Original after Random Pick
function returnToOriginalAfterRandomPick() {
    // Reset to original array
    myArray = [...originalArrayForRandomPick];
    originalArrayForRandomPick = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isRandomPickRunning = false;
    
    logOperation('Random pick with weight completed - returned to original array', 'info');
    showNotification('Returned to original array after random pick operation', 'success');
}
// NEW: Generate Random Point in Circle Handler
function handleGenerateRandomPoint() {
    if (myArray.length < 3) {
        showNotification('Array needs at least 3 elements for circle generation', 'danger');
        return;
    }

    if (isRandomPointRunning) {
        showNotification('Random point generation is already in progress', 'warning');
        return;
    }

    isRandomPointRunning = true;

    // Store original array
    originalArrayForRandomPoint = [...myArray];

    // Show circle visualization
    showCircleVisualization();
}

// NEW: Show Circle Visualization
function showCircleVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Generate Random Point in Circle</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalRandomPointArray"></div>
        </div>

        <div class="circle-visualization">
            <div class="circle-container" id="circleCanvas">
                <!-- Circle and points will be drawn here -->
            </div>
            
            <div class="circle-info">
                <p class="mb-2"><strong>Circle Parameters:</strong></p>
                <div class="coordinate-display">
                    <div class="coordinate-item" id="centerDisplay">Center: [?, ?]</div>
                    <div class="coordinate-item" id="radiusDisplay">Radius: ?</div>
                </div>
                <p class="mb-0" id="circleExplanation">Initializing circle generation...</p>
            </div>
        </div>

        <div class="algorithm-steps mt-3" id="circleStepsContainer">
            <h6 class="text-center">Random Point Generation Steps</h6>
            <div class="steps-container" id="circleSteps"></div>
        </div>

        <div class="stats-card mt-3">
            <div>Generated Point Coordinates</div>
            <div class="stats-value" id="generatedPointCoords">-</div>
        </div>

        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterRandomPoint" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;

    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);

    renderArrayInContainer(originalArrayForRandomPoint, 'originalRandomPointArray');
    performRandomPointGeneration();
}

// NEW: Perform Random Point Generation with Animation
function performRandomPointGeneration() {
    const arrayContainer = document.getElementById('originalRandomPointArray');
    const circleCanvas = document.getElementById('circleCanvas');
    const centerDisplay = document.getElementById('centerDisplay');
    const radiusDisplay = document.getElementById('radiusDisplay');
    const explanation = document.getElementById('circleExplanation');
    const stepsContainer = document.getElementById('circleSteps');
    const generatedPointCoords = document.getElementById('generatedPointCoords');
    const continueButton = document.getElementById('continueAfterRandomPoint');

    const arr = originalArrayForRandomPoint;
    let step = 0;

    // Extract center coordinates and radius from array
    const centerX = parseFloat(arr[0]) || 0;
    const centerY = parseFloat(arr[1]) || 0;
    const radius = parseFloat(arr[2]) || 1;

    // Set up circle visualization
    const circleSize = 300;
    const scale = circleSize / (2 * (radius + 1)); // Add padding

    function drawCircle() {
        // Clear previous drawings
        circleCanvas.innerHTML = '';

        // Draw center point
        const centerDot = document.createElement('div');
        centerDot.className = 'circle-center';
        centerDot.style.left = '50%';
        centerDot.style.top = '50%';
        circleCanvas.appendChild(centerDot);

        // Add center label
        const centerLabel = document.createElement('div');
        centerLabel.className = 'point-label';
        centerLabel.textContent = `Center (${centerX}, ${centerY})`;
        centerLabel.style.left = '50%';
        centerLabel.style.top = '50%';
        circleCanvas.appendChild(centerLabel);

        // Update displays
        centerDisplay.textContent = `Center: [${centerX}, ${centerY}]`;
        radiusDisplay.textContent = `Radius: ${radius}`;
    }

    function performGenerationStep() {
        switch (step) {
            case 0:
                // Step 1: Show array elements being used
                explanation.innerHTML = 'Step 1: Using array elements for circle parameters';
                
                // Highlight the array elements being used
                const elements = arrayContainer.querySelectorAll('.array-element');
                if (elements.length >= 3) {
                    elements[0].querySelector('.element-value').classList.add('info-color');
                    elements[1].querySelector('.element-value').classList.add('info-color');
                    elements[2].querySelector('.element-value').classList.add('warning-color');
                }

                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Using array[0]=${arr[0]} as center X, array[1]=${arr[1]} as center Y, array[2]=${arr[2]} as radius
                    </div>
                `;

                // Draw the circle
                drawCircle();
                break;

            case 1:
                // Step 2: Generate random angle
                explanation.innerHTML = 'Step 2: Generating random angle (0 to 2)';
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step 2:</strong> Generating random angle  between 0 and 2 radians
                    </div>
                `;

                // Show angle visualization
                setTimeout(() => {
                    const angle = Math.random() * 2 * Math.PI;
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 2a:</strong> Generated angle  = ${angle.toFixed(4)} radians
                        </div>
                    `;
                    step++;
                    performGenerationStep();
                }, 1500);
                return;

            case 2:
                // Step 3: Generate random distance
                explanation.innerHTML = 'Step 3: Generating random distance within radius';
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step 3:</strong> Generating random distance r using (random(0,1))  radius
                    </div>
                `;

                setTimeout(() => {
                    const randomValue = Math.random();
                    const distance = Math.sqrt(randomValue) * radius;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 3a:</strong> Random value = ${randomValue.toFixed(4)}, Distance r = (${randomValue.toFixed(4)})  ${radius} = ${distance.toFixed(4)}
                        </div>
                    `;
                    step++;
                    performGenerationStep();
                }, 1500);
                return;

            case 3:
                // Step 4: Calculate coordinates
                explanation.innerHTML = 'Step 4: Calculating point coordinates';
                
                const angle = Math.random() * 2 * Math.PI;
                const randomValue = Math.random();
                const distance = Math.sqrt(randomValue) * radius;
                
                const pointX = centerX + distance * Math.cos(angle);
                const pointY = centerY + distance * Math.sin(angle);

                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 4:</strong> Calculating coordinates:<br>
                        x = ${centerX} + ${distance.toFixed(4)}  cos(${angle.toFixed(4)}) = ${pointX.toFixed(4)}<br>
                        y = ${centerY} + ${distance.toFixed(4)}  sin(${angle.toFixed(4)}) = ${pointY.toFixed(4)}
                    </div>
                `;

                // Draw the generated point
                const pointDot = document.createElement('div');
                pointDot.className = 'random-point';
                pointDot.style.left = '50%';
                pointDot.style.top = '50%';
                pointDot.style.transform = `translate(-50%, -50%) translate(${(pointX - centerX) * scale}px, ${(centerY - pointY) * scale}px)`;
                circleCanvas.appendChild(pointDot);

                // Add point label
                const pointLabel = document.createElement('div');
                pointLabel.className = 'point-label';
                pointLabel.textContent = `Point (${pointX.toFixed(2)}, ${pointY.toFixed(2)})`;
                pointLabel.style.left = `calc(50% + ${(pointX - centerX) * scale}px)`;
                pointLabel.style.top = `calc(50% + ${(centerY - pointY) * scale}px)`;
                circleCanvas.appendChild(pointLabel);

                // Draw radius line
                const radiusLine = document.createElement('div');
                radiusLine.className = 'radius-line';
                radiusLine.style.left = '50%';
                radiusLine.style.top = '50%';
                radiusLine.style.width = `${distance * scale}px`;
                radiusLine.style.transform = `rotate(${-angle}rad)`;
                circleCanvas.appendChild(radiusLine);

                // Update generated coordinates display
                generatedPointCoords.textContent = `[${pointX.toFixed(4)}, ${pointY.toFixed(4)}]`;
                break;

            case 4:
                // Step 5: Completion
                explanation.innerHTML = '<strong>Random Point Generation Completed!</strong> Point successfully generated within circle.';
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Random point generated at coordinates [${generatedPointCoords.textContent}]
                    </div>
                `;

                continueButton.style.display = 'block';
                
                // Auto-return after 10 seconds
                setTimeout(() => {
                    returnToOriginalAfterRandomPoint();
                }, 10000);
                
                continueButton.addEventListener('click', returnToOriginalAfterRandomPoint);
                return;
        }

        step++;
        setTimeout(performGenerationStep, 2000);
    }

    // Start the generation process
    performGenerationStep();
}

// NEW: Return to Original after Random Point Generation
function returnToOriginalAfterRandomPoint() {
    // Reset to original array
    myArray = [...originalArrayForRandomPoint];
    originalArrayForRandomPoint = [];

    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();

    // Reset state
    isRandomPointRunning = false;

    logOperation('Random point generation completed - returned to original array', 'info');
    showNotification('Returned to original array after random point generation', 'success');
}

// Helper function to render array in specific container
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';

    if (array.length === 0) {
        container.innerHTML = '<div class="array-empty-state"><i class="fas fa-layer-group"></i><h4>Array is Empty</h4></div>';
        return;
    }

    array.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}
// NEW: Find Consecutive Sequences Handler
function handleFindConsecutiveSequences() {
    const targetSum = parseInt(consecutiveTargetSum.value);
    
    if (isNaN(targetSum)) {
        showNotification('Please enter a valid target sum', 'danger');
        consecutiveTargetSum.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('This operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    if (isConsecutiveSequenceSearchRunning) {
        showNotification('Consecutive sequence search is already in progress', 'warning');
        return;
    }
    
    isConsecutiveSequenceSearchRunning = true;
    
    // Store original array with unique name
    originalArrayForConsecutiveSearch = [...myArray];
    
    // Perform consecutive sequence visualization
    performConsecutiveSequenceVisualization(targetSum);
}

// NEW: Perform Consecutive Sequence Visualization
function performConsecutiveSequenceVisualization(targetSum) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find Consecutive Sequences Summing to ${targetSum}</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalConsecutiveSearchArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find all sequences of consecutive numbers that sum to ${targetSum}</p>
            <p class="mb-0" id="consecutiveSearchExplanation">Initializing sequence search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="consecutiveSearchStepsContainer">
            <h6 class="text-center">Search Steps</h6>
            <div class="steps-container" id="consecutiveSearchSteps"></div>
        </div>
        
        <div class="subarrays-results mt-3" id="consecutiveSearchResults">
            <h6 class="text-center">Found Sequences</h6>
            <div class="stats-card">
                <div>Total Sequences Found</div>
                <div class="stats-value" id="consecutiveSequenceCount">0</div>
            </div>
            <div id="consecutiveSequencesList" class="mt-3"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterConsecutiveSearch" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForConsecutiveSearch, 'originalConsecutiveSearchArray');
    
    executeConsecutiveSequenceAlgorithm(targetSum);
}

// NEW: Execute Consecutive Sequence Algorithm with Animation
function executeConsecutiveSequenceAlgorithm(targetSum) {
    const arrayContainer = document.getElementById('originalConsecutiveSearchArray');
    const explanation = document.getElementById('consecutiveSearchExplanation');
    const stepsContainer = document.getElementById('consecutiveSearchSteps');
    const resultsContainer = document.getElementById('consecutiveSearchResults');
    const sequenceCount = document.getElementById('consecutiveSequenceCount');
    const sequencesList = document.getElementById('consecutiveSequencesList');
    const continueButton = document.getElementById('continueAfterConsecutiveSearch');
    
    const arr = originalArrayForConsecutiveSearch.map(val => parseFloat(val));
    const n = arr.length;
    let foundSequences = [];
    let step = 0;
    let currentStart = 0;
    let currentEnd = 0;
    
    // Initialize results display
    sequenceCount.textContent = '0';
    sequencesList.innerHTML = '<p class="text-center text-muted">No sequences found yet</p>';
    
    function executeStep() {
        if (currentStart >= n) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Search Completed!</strong> Found ${foundSequences.length} sequence(s) summing to ${targetSum}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Search completed. Found ${foundSequences.length} sequence(s)
                </div>
            `;
            
            // Update final results
            updateSequencesDisplay();
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterConsecutiveSearch();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterConsecutiveSearch);
            
            return;
        }
        
        step++;
        
        if (currentEnd >= n) {
            // Current start exhausted, move to next start
            currentStart++;
            currentEnd = currentStart;
            executeStep();
            return;
        }
        
        // Calculate current sum from currentStart to currentEnd
        let currentSum = 0;
        for (let i = currentStart; i <= currentEnd; i++) {
            currentSum += arr[i];
        }
        
        explanation.innerHTML = `Checking sequence [${currentStart}-${currentEnd}]: Sum = ${currentSum}`;
        
        // Highlight current window
        const elements = arrayContainer.querySelectorAll('.array-element');
        for (let i = currentStart; i <= currentEnd; i++) {
            elements[i].querySelector('.element-value').classList.add('window-current');
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${currentSum === targetSum ? 'active' : ''}">
                <strong>Step ${step}:</strong> Checking [${currentStart}-${currentEnd}] = ${arr.slice(currentStart, currentEnd + 1).join(' + ')} = ${currentSum}
                ${currentSum === targetSum ? ' - MATCH FOUND!' : ''}
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Remove current window highlights
            for (let i = currentStart; i <= currentEnd; i++) {
                elements[i].querySelector('.element-value').classList.remove('window-current');
            }
            
            if (currentSum === targetSum) {
                // Found a sequence
                const sequence = arr.slice(currentStart, currentEnd + 1);
                foundSequences.push({
                    start: currentStart,
                    end: currentEnd,
                    sequence: sequence
                });
                
                // Highlight the found sequence
                for (let i = currentStart; i <= currentEnd; i++) {
                    elements[i].querySelector('.element-value').classList.add('subarray-sum-match');
                }
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Sequence Found!</strong> [${currentStart}-${currentEnd}] = [${sequence.join(', ')}] sums to ${targetSum}
                    </div>
                `;
                
                // Update sequences display immediately when found
                updateSequencesDisplay();
                
                // Move to next start
                currentStart++;
                currentEnd = currentStart;
            } else if (currentSum < targetSum) {
                // Sum is less than target, extend window
                currentEnd++;
            } else {
                // Sum is greater than target, move start forward
                currentStart++;
                currentEnd = currentStart;
            }
            
            executeStep();
        }, 1500);
    }
    
    // Function to update sequences display
    function updateSequencesDisplay() {
        sequenceCount.textContent = foundSequences.length;
        
        if (foundSequences.length > 0) {
            sequencesList.innerHTML = '';
            foundSequences.forEach((seq, index) => {
                const sequenceDiv = document.createElement('div');
                sequenceDiv.className = 'subarray-sum-item mb-2 p-3';
                sequenceDiv.innerHTML = `
                    <div class="d-flex justify-content-between align-items-center">
                        <strong class="text-warning">Sequence ${index + 1}</strong>
                        <span class="badge bg-success">Sum: ${seq.sequence.reduce((a, b) => a + b, 0)}</span>
                    </div>
                    <div class="mt-2">
                        <strong>Indices:</strong> [${seq.start} - ${seq.end}]<br>
                        <strong>Values:</strong> [${seq.sequence.join(', ')}]<br>
                        <strong>Verification:</strong> ${seq.sequence.join(' + ')} = ${targetSum}
                    </div>
                `;
                sequencesList.appendChild(sequenceDiv);
            });
        } else {
            sequencesList.innerHTML = '<p class="text-center text-muted">No sequences found yet</p>';
        }
        
        // Scroll results into view
        resultsContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
    
    // Start execution
    executeStep();
}

// NEW: Return to Original after Consecutive Sequence Search
function returnToOriginalAfterConsecutiveSearch() {
    // Reset to original array
    myArray = [...originalArrayForConsecutiveSearch];
    originalArrayForConsecutiveSearch = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isConsecutiveSequenceSearchRunning = false;
    
    // Clear input
    consecutiveTargetSum.value = '';
    
    logOperation('Consecutive sequence search completed - returned to original array', 'info');
    showNotification('Returned to original array after consecutive sequence search', 'success');
}
// NEW: Convert to English Words Handler
function handleConvertToEnglish() {
    const number = parseInt(numberInput.value);
    
    if (isNaN(number) || number < 0 || number > 999999999) {
        showNotification('Please enter a valid number between 0 and 999,999,999', 'danger');
        numberInput.focus();
        return;
    }
    
    if (isNumberOperationRunning) {
        showNotification('A number operation is already in progress', 'warning');
        return;
    }
    
    isNumberOperationRunning = true;
    
    // Store original array
    originalArrayForNumberOps = [...myArray];
    
    // Show conversion visualization
    showEnglishConversionVisualization(number);
}

// NEW: Find Digit One Handler
function handleFindDigitOne() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isNumberOperationRunning) {
        showNotification('A number operation is already in progress', 'warning');
        return;
    }
    
    isNumberOperationRunning = true;
    
    // Store original array
    originalArrayForNumberOps = [...myArray];
    
    // Show digit one visualization
    showDigitOneVisualization();
}

// NEW: Show English Conversion Visualization
function showEnglishConversionVisualization(number) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Convert Number to English Words</h5>
        
        <div class="array-group">
            <div class="array-label">Original Number</div>
            <div class="english-word-display" id="originalNumberDisplay">${number}</div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">English Words</div>
            <div class="english-word-display" id="englishWordsDisplay">Converting...</div>
        </div>
        
        <div class="number-operation-explanation">
            <p class="mb-2"><strong>Conversion Process:</strong> Converting numeric digits to English words</p>
            <p class="mb-0" id="conversionExplanation">Starting conversion process...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="conversionStepsContainer">
            <h6 class="text-center">Conversion Steps</h6>
            <div class="steps-container" id="conversionSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterConversion" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    performEnglishConversionAnimation(number);
}

// NEW: Perform English Conversion Animation
function performEnglishConversionAnimation(number) {
    const englishDisplay = document.getElementById('englishWordsDisplay');
    const explanation = document.getElementById('conversionExplanation');
    const stepsContainer = document.getElementById('conversionSteps');
    const continueButton = document.getElementById('continueAfterConversion');
    
    const steps = [];
    let currentStep = 0;
    
    function performConversionStep() {
        if (currentStep >= steps.length) {
            // Conversion completed
            const englishWords = numberToWords(number);
            englishDisplay.textContent = englishWords;
            
            explanation.innerHTML = `<strong>Conversion Completed!</strong> Number converted to English words.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> "${number}" = "${englishWords}"
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterNumberOperation();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterNumberOperation);
            
            return;
        }
        
        const step = steps[currentStep];
        explanation.innerHTML = step.explanation;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${step.active ? 'active' : ''}">
                <strong>Step ${currentStep + 1}:</strong> ${step.description}
            </div>
        `;
        
        // Scroll to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        currentStep++;
        setTimeout(performConversionStep, 1500);
    }
    
    // Generate conversion steps based on the number
    generateConversionSteps(number, steps);
    
    // Start conversion process
    performConversionStep();
}

// NEW: Generate Conversion Steps
function generateConversionSteps(number, steps) {
    if (number === 0) {
        steps.push({
            explanation: "Processing number: 0",
            description: "Zero is a special case",
            active: true
        });
        return;
    }
    
    const numStr = number.toString();
    const length = numStr.length;
    
    steps.push({
        explanation: `Processing number: ${number} (${length} digit${length > 1 ? 's' : ''})`,
        description: `Input number has ${length} digit${length > 1 ? 's' : ''}`,
        active: true
    });
    
    // Process based on number length
    if (length <= 3) {
        steps.push({
            explanation: "Processing hundreds, tens, and units",
            description: "Breaking down into hundreds, tens, and units places",
            active: true
        });
    } else if (length <= 6) {
        steps.push({
            explanation: "Processing thousands",
            description: "Breaking down into thousands and hundreds",
            active: true
        });
    } else {
        steps.push({
            explanation: "Processing millions",
            description: "Breaking down into millions, thousands, and hundreds",
            active: true
        });
    }
    
    steps.push({
        explanation: "Converting each segment to English words",
        description: "Mapping digits to their English equivalents",
        active: true
    });
    
    steps.push({
        explanation: "Combining all segments with proper formatting",
        description: "Adding spaces and proper punctuation",
        active: true
    });
}

// NEW: Number to Words Conversion Function
function numberToWords(num) {
    if (num === 0) return "Zero";
    
    const belowTwenty = [
        "", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten",
        "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", 
        "Eighteen", "Nineteen"
    ];
    
    const tens = [
        "", "", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"
    ];
    
    const thousands = ["", "Thousand", "Million", "Billion"];
    
    function convertChunk(n) {
        if (n === 0) return "";
        if (n < 20) return belowTwenty[n];
        if (n < 100) {
            return tens[Math.floor(n / 10)] + (n % 10 !== 0 ? " " + belowTwenty[n % 10] : "");
        }
        return belowTwenty[Math.floor(n / 100)] + " Hundred" + (n % 100 !== 0 ? " " + convertChunk(n % 100) : "");
    }
    
    let result = "";
    let chunkIndex = 0;
    
    while (num > 0) {
        if (num % 1000 !== 0) {
            result = convertChunk(num % 1000) + (thousands[chunkIndex] ? " " + thousands[chunkIndex] : "") + (result ? " " + result : "");
        }
        num = Math.floor(num / 1000);
        chunkIndex++;
    }
    
    return result.trim();
}

// NEW: Show Digit One Visualization
function showDigitOneVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find Digit '1' in Array Elements</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalDigitOneArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Digit '1' Analysis</div>
            <div class="transformed-array-container" id="transformedDigitOneArray"></div>
        </div>
        
        <div class="number-operation-explanation">
            <p class="mb-2"><strong>Analysis Process:</strong> Finding elements that contain digit '1'</p>
            <p class="mb-0" id="digitOneExplanation">Starting digit analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="digitOneStepsContainer">
            <h6 class="text-center">Digit Analysis Steps</h6>
            <div class="steps-container" id="digitOneSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Total Elements with Digit '1'</div>
            <div class="stats-value" id="digitOneCount">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterDigitOne" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForNumberOps, 'originalDigitOneArray');
    renderArrayInContainer([...originalArrayForNumberOps], 'transformedDigitOneArray');
    
    performDigitOneAnalysisAnimation();
}

// NEW: Perform Digit One Analysis Animation
function performDigitOneAnalysisAnimation() {
    const originalContainer = document.getElementById('originalDigitOneArray');
    const transformedContainer = document.getElementById('transformedDigitOneArray');
    const explanation = document.getElementById('digitOneExplanation');
    const stepsContainer = document.getElementById('digitOneSteps');
    const digitOneCount = document.getElementById('digitOneCount');
    const continueButton = document.getElementById('continueAfterDigitOne');
    
    const array = [...originalArrayForNumberOps];
    let totalOnes = 0;
    let currentIndex = 0;
    
    function performAnalysisStep() {
        if (currentIndex >= array.length) {
            // Analysis completed
            explanation.innerHTML = `<strong>Analysis Completed!</strong> Found ${totalOnes} element${totalOnes !== 1 ? 's' : ''} containing digit '1'.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Total elements with digit '1': ${totalOnes}
                </div>
            `;
            
            digitOneCount.textContent = totalOnes;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterNumberOperation();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterNumberOperation);
            
            return;
        }
        
        const element = array[currentIndex];
        const elementStr = element.toString();
        
        explanation.innerHTML = `Checking element [${currentIndex}]: "${element}"`;
        
        // Highlight current element being checked
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        
        const originalElement = originalElements[currentIndex].querySelector('.element-value');
        const transformedElement = transformedElements[currentIndex].querySelector('.element-value');
        
        originalElement.classList.add('sorting-current');
        transformedElement.classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${currentIndex + 1}:</strong> Checking "${element}" for digit '1'
            </div>
        `;
        
        setTimeout(() => {
            // Check if element contains digit '1'
            const containsOne = elementStr.includes('1');
            const oneCount = (elementStr.match(/1/g) || []).length;
            
            if (containsOne) {
                totalOnes++;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Found:</strong> "${element}" contains digit '1' ${oneCount} time${oneCount !== 1 ? 's' : ''}
                    </div>
                `;
                
                // Highlight as containing digit one
                originalElement.classList.remove('sorting-current');
                transformedElement.classList.remove('sorting-current');
                originalElement.classList.add('contains-digit-one');
                transformedElement.classList.add('contains-digit-one');
                
                // If it's exactly "1", highlight differently
                if (element === '1') {
                    transformedElement.classList.add('digit-one-count');
                }
                
            } else {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>No Match:</strong> "${element}" does not contain digit '1'
                    </div>
                `;
                
                originalElement.classList.remove('sorting-current');
                transformedElement.classList.remove('sorting-current');
            }
            
            digitOneCount.textContent = totalOnes;
            
            // Scroll to bottom
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            currentIndex++;
            performAnalysisStep();
        }, 1500);
    }
    
    // Start analysis process
    performAnalysisStep();
}

// NEW: Return to Original after Number Operations
function returnToOriginalAfterNumberOperation() {
    // Reset to original array
    myArray = [...originalArrayForNumberOps];
    originalArrayForNumberOps = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isNumberOperationRunning = false;
    
    // Clear input
    numberInput.value = '';
    
    logOperation('Number operation completed - returned to original array', 'info');
    showNotification('Returned to original array after number operation', 'success');
}
// NEW: Add Digits (Digital Root) Handler
function handleAddDigits() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isDigitalRootRunning) {
        showNotification('Digital root operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Digital root operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isDigitalRootRunning = true;
    
    // Store original array
    originalArrayForDigitalRoot = [...myArray];
    
    // Show digital root visualization
    showDigitalRootVisualization();
}
// NEW: Happy Number Handler
function handleHappyNumber() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isHappyNumberRunning) {
        showNotification('Happy number operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Happy number operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isHappyNumberRunning = true;
    
    // Store original array
    originalArrayForHappyNumber = [...myArray];
    
    // Show happy number visualization
    showHappyNumberVisualization();
}

// NEW: Show Digital Root Visualization
function showDigitalRootVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Add Digits (Digital Root) Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalDigitalRootArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Digital Root Results</div>
            <div class="transformed-array-container" id="transformedDigitalRootArray"></div>
        </div>
        
        <div class="digital-root-explanation">
            <p class="mb-2"><strong>Digital Root Algorithm:</strong> Repeatedly sum digits until single digit is obtained</p>
            <p class="mb-0" id="digitalRootExplanation">Starting digital root calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="digitalRootStepsContainer">
            <h6 class="text-center">Digital Root Calculation Steps</h6>
            <div class="steps-container" id="digitalRootSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterDigitalRoot" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForDigitalRoot, 'originalDigitalRootArray');
    renderArrayInContainer([...originalArrayForDigitalRoot], 'transformedDigitalRootArray');
    
    performDigitalRootAnimation();
}

// NEW: Perform Digital Root Animation
function performDigitalRootAnimation() {
    const originalContainer = document.getElementById('originalDigitalRootArray');
    const transformedContainer = document.getElementById('transformedDigitalRootArray');
    const explanation = document.getElementById('digitalRootExplanation');
    const stepsContainer = document.getElementById('digitalRootSteps');
    const continueButton = document.getElementById('continueAfterDigitalRoot');
    
    const originalArray = [...originalArrayForDigitalRoot];
    const digitalRootResults = [];
    let currentIndex = 0;
    
    // Helper function to calculate digital root
    function calculateDigitalRoot(num) {
        let current = Math.abs(parseInt(num));
        const steps = [];
        
        while (current > 9) {
            const digits = current.toString().split('').map(Number);
            const sum = digits.reduce((acc, digit) => acc + digit, 0);
            steps.push(`${current}  ${digits.join(' + ')} = ${sum}`);
            current = sum;
        }
        
        steps.push(`Final digital root: ${current}`);
        return { result: current, steps: steps };
    }
    
    function processNextElement() {
        if (currentIndex >= originalArray.length) {
            // All elements processed
            explanation.innerHTML = `<strong>Digital Root Operation Completed!</strong> All elements processed.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Digital root calculation completed for all elements
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterDigitalRoot();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterDigitalRoot);
            
            return;
        }
        
        const currentElement = originalArray[currentIndex];
        const num = parseFloat(currentElement);
        
        if (isNaN(num)) {
            // Skip non-numeric elements
            digitalRootResults.push('N/A');
            currentIndex++;
            processNextElement();
            return;
        }
        
        explanation.innerHTML = `Processing element [${currentIndex}]: ${currentElement}`;
        
        // Highlight current element in original array
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentOriginalElement = originalElements[currentIndex].querySelector('.element-value');
        currentOriginalElement.classList.add('digital-root-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Processing Element ${currentIndex}:</strong> ${currentElement}
            </div>
        `;
        
        setTimeout(() => {
            // Calculate digital root with step-by-step demonstration
            const digitalRootData = calculateDigitalRoot(num);
            digitalRootResults.push(digitalRootData.result.toString());
            
            // Show calculation steps
            digitalRootData.steps.forEach((step, stepIndex) => {
                setTimeout(() => {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step ${stepIndex === digitalRootData.steps.length - 1 ? 'active' : ''}">
                            <strong>Step ${stepIndex + 1}:</strong> ${step}
                        </div>
                    `;
                    stepsContainer.scrollTop = stepsContainer.scrollHeight;
                    
                    if (stepIndex === digitalRootData.steps.length - 1) {
                        // Final step - update transformed array
                        renderArrayInContainer(digitalRootResults, 'transformedDigitalRootArray');
                        
                        // Highlight the result
                        const transformedElements = transformedContainer.querySelectorAll('.array-element');
                        if (transformedElements[currentIndex]) {
                            const resultElement = transformedElements[currentIndex].querySelector('.element-value');
                            resultElement.classList.add('digital-root-result');
                        }
                        
                        // Remove highlight from original element
                        currentOriginalElement.classList.remove('digital-root-current');
                        
                        // Move to next element
                        currentIndex++;
                        setTimeout(processNextElement, 1500);
                    }
                }, stepIndex * 1000);
            });
        }, 1000);
    }
    
    // Start processing
    processNextElement();
}
// NEW: Show Happy Number Visualization
function showHappyNumberVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Happy Number Check Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalHappyNumberArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Happy Numbers Found</div>
            <div class="transformed-array-container" id="transformedHappyNumberArray"></div>
        </div>
        
        <div class="happy-number-explanation">
            <p class="mb-2"><strong>Happy Number Algorithm:</strong> A number is happy if the process of summing squares of digits eventually reaches 1</p>
            <p class="mb-0" id="happyNumberExplanation">Starting happy number check...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="happyNumberStepsContainer">
            <h6 class="text-center">Happy Number Check Steps</h6>
            <div class="steps-container" id="happyNumberSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Happy Numbers Found</div>
            <div class="stats-value" id="happyNumberCount">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterHappyNumber" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForHappyNumber, 'originalHappyNumberArray');
    renderArrayInContainer([], 'transformedHappyNumberArray'); // Start with empty array for results
    
    performHappyNumberAnimation();
}

// NEW: Perform Happy Number Animation
function performHappyNumberAnimation() {
    const originalContainer = document.getElementById('originalHappyNumberArray');
    const transformedContainer = document.getElementById('transformedHappyNumberArray');
    const explanation = document.getElementById('happyNumberExplanation');
    const stepsContainer = document.getElementById('happyNumberSteps');
    const happyNumberCount = document.getElementById('happyNumberCount');
    const continueButton = document.getElementById('continueAfterHappyNumber');
    
    const originalArray = [...originalArrayForHappyNumber];
    const happyNumberResults = []; // This will only contain happy numbers from original array
    let currentIndex = 0;
    let totalHappyNumbers = 0;
    
    // Helper function to check if a number is happy
    function isHappyNumber(num) {
        let seen = new Set();
        let current = Math.abs(parseInt(num));
        const steps = [];
        
        while (current !== 1 && !seen.has(current)) {
            seen.add(current);
            const digits = current.toString().split('').map(Number);
            const sumOfSquares = digits.reduce((acc, digit) => acc + digit * digit, 0);
            steps.push(`${current}  ${digits.map(d => d + '').join(' + ')} = ${sumOfSquares}`);
            current = sumOfSquares;
        }
        
        const isHappy = current === 1;
        steps.push(isHappy ? 'Reached 1 - This is a HAPPY NUMBER! ' : 'Entered cycle - This is NOT a happy number');
        
        return { isHappy: isHappy, steps: steps };
    }
    
    function processNextElement() {
        if (currentIndex >= originalArray.length) {
            // All elements processed
            explanation.innerHTML = `<strong>Happy Number Check Completed!</strong> Found ${totalHappyNumbers} happy number(s).`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Happy number check completed. Total happy numbers found: ${totalHappyNumbers}
                </div>
            `;
            
            if (totalHappyNumbers === 0) {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Note:</strong> No happy numbers found in the array
                    </div>
                `;
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterHappyNumber();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterHappyNumber);
            
            return;
        }
        
        const currentElement = originalArray[currentIndex];
        const num = parseFloat(currentElement);
        
        if (isNaN(num)) {
            // Skip non-numeric elements
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Skipping Element ${currentIndex}:</strong> "${currentElement}" is not a number
                </div>
            `;
            currentIndex++;
            setTimeout(processNextElement, 1000);
            return;
        }
        
        explanation.innerHTML = `Checking if ${currentElement} is a happy number...`;
        
        // Highlight current element in original array
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentOriginalElement = originalElements[currentIndex].querySelector('.element-value');
        currentOriginalElement.classList.add('happy-process');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Checking Element ${currentIndex}:</strong> ${currentElement}
            </div>
        `;
        
        setTimeout(() => {
            // Check if number is happy with step-by-step demonstration
            const happyData = isHappyNumber(num);
            
            // Show calculation steps
            happyData.steps.forEach((step, stepIndex) => {
                setTimeout(() => {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step ${stepIndex === happyData.steps.length - 1 ? 'active' : ''}">
                            <strong>Step ${stepIndex + 1}:</strong> ${step}
                        </div>
                    `;
                    stepsContainer.scrollTop = stepsContainer.scrollHeight;
                    
                    if (stepIndex === happyData.steps.length - 1) {
                        // Final step - check if it's happy
                        if (happyData.isHappy) {
                            // Add the happy number to results
                            happyNumberResults.push(currentElement);
                            totalHappyNumbers++;
                            happyNumberCount.textContent = totalHappyNumbers;
                            
                            // Update transformed array with only happy numbers
                            renderArrayInContainer(happyNumberResults, 'transformedHappyNumberArray');
                            
                            // Highlight both the original element and the result
                            currentOriginalElement.classList.add('happy-number');
                            
                            const transformedElements = transformedContainer.querySelectorAll('.array-element');
                            if (transformedElements[happyNumberResults.length - 1]) {
                                const resultElement = transformedElements[happyNumberResults.length - 1].querySelector('.element-value');
                                resultElement.classList.add('happy-number', 'bounce');
                            }
                            
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step active">
                                    <strong>Result:</strong> ${currentElement} is a HAPPY NUMBER! Added to results. 
                                </div>
                            `;
                        } else {
                            // Not a happy number - just show the result
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step">
                                    <strong>Result:</strong> ${currentElement} is not a happy number
                                </div>
                            `;
                        }
                        
                        // Remove process highlight from original element
                        currentOriginalElement.classList.remove('happy-process');
                        
                        // Move to next element
                        currentIndex++;
                        setTimeout(processNextElement, 1500);
                    }
                }, stepIndex * 1000);
            });
        }, 1000);
    }
    
    // Start processing
    processNextElement();
}

// NEW: Return to Original after Digital Root
function returnToOriginalAfterDigitalRoot() {
    // Reset to original array
    myArray = [...originalArrayForDigitalRoot];
    originalArrayForDigitalRoot = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isDigitalRootRunning = false;
    
    logOperation('Digital root operation completed - returned to original array', 'info');
    showNotification('Returned to original array after digital root operation', 'success');
}

// NEW: Return to Original after Happy Number
function returnToOriginalAfterHappyNumber() {
    // Reset to original array
    myArray = [...originalArrayForHappyNumber];
    originalArrayForHappyNumber = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isHappyNumberRunning = false;
    
    logOperation('Happy number operation completed - returned to original array', 'info');
    showNotification('Returned to original array after happy number operation', 'success');
}
// NEW: Excel Column Number Handler
function handleExcelColumnNumber() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isExcelConversionRunning) {
        showNotification('Excel conversion is already in progress', 'warning');
        return;
    }
    
    // Validate that all elements are valid Excel column titles
    const invalidElements = [];
    for (let i = 0; i < myArray.length; i++) {
        const element = myArray[i].toString().trim().toUpperCase();
        if (!isValidExcelColumn(element)) {
            invalidElements.push({
                index: i,
                value: myArray[i],
                element: element
            });
        }
    }
    
    if (invalidElements.length > 0) {
        // Show detailed error message
        let errorMessage = 'Invalid Excel column titles found:<br>';
        invalidElements.forEach(invalid => {
            errorMessage += ` Index ${invalid.index}: "${invalid.value}" is not a valid Excel column<br>`;
        });
        errorMessage += '<br>Please enter only alphabetic characters (A-Z, AA-ZZ, etc.)';
        
        // Show error in search results
        searchResults.innerHTML = `
            <div class="alert alert-danger">
                <h6><i class="fas fa-exclamation-triangle me-2"></i>Invalid Input</h6>
                <p class="mb-0">${errorMessage}</p>
            </div>
        `;
        
        // Highlight invalid elements with animation
        invalidElements.forEach(invalid => {
            highlightElement(invalid.index, 'excel-error');
        });
        
        logOperation('Excel conversion failed - invalid column titles detected', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForExcel = [...myArray];
    
    // Show Excel conversion visualization
    showExcelConversionVisualization();
}

// NEW: Validate Excel Column Title
function isValidExcelColumn(title) {
    if (typeof title !== 'string') return false;
    
    const trimmed = title.trim().toUpperCase();
    if (trimmed.length === 0) return false;
    
    // Check if all characters are uppercase letters A-Z
    for (let i = 0; i < trimmed.length; i++) {
        const char = trimmed.charAt(i);
        if (char < 'A' || char > 'Z') {
            return false;
        }
    }
    
    return true;
}

// NEW: Convert Excel Column to Number (Python implementation equivalent)
function excelColumnToNumber(columnTitle) {
    let result = 0;
    const upperTitle = columnTitle.toString().trim().toUpperCase();
    
    for (let i = 0; i < upperTitle.length; i++) {
        const char = upperTitle.charAt(i);
        const charValue = char.charCodeAt(0) - 'A'.charCodeAt(0) + 1;
        result = result * 26 + charValue;
    }
    
    return result;
}

// NEW: Show Excel Conversion Visualization
function showExcelConversionVisualization() {
    isExcelConversionRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Excel Column to Number Conversion</h5>
        
        <div class="array-group">
            <div class="array-label">Excel Column Titles</div>
            <div class="original-array-container" id="originalExcelArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Column Numbers</div>
            <div class="transformed-array-container" id="transformedExcelArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Conversion Formula:</strong> result = result  26 + (char - 'A' + 1)</p>
            <p class="mb-0" id="excelExplanation">Starting Excel column conversion...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="excelStepsContainer">
            <h6 class="text-center">Conversion Steps</h6>
            <div class="steps-container" id="excelSteps"></div>
        </div>
        
        <div class="table-container mt-3">
            <table class="excel-table">
                <thead>
                    <tr>
                        <th>Excel Column</th>
                        <th>Calculation Steps</th>
                        <th>Result</th>
                    </tr>
                </thead>
                <tbody id="excelConversionTable">
                </tbody>
            </table>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterExcel" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForExcel, 'originalExcelArray');
    renderArrayInContainer([], 'transformedExcelArray');
    
    performExcelConversionAnimation();
}

// NEW: Perform Excel Conversion Animation
function performExcelConversionAnimation() {
    const originalContainer = document.getElementById('originalExcelArray');
    const transformedContainer = document.getElementById('transformedExcelArray');
    const explanation = document.getElementById('excelExplanation');
    const stepsContainer = document.getElementById('excelSteps');
    const conversionTable = document.getElementById('excelConversionTable');
    const continueButton = document.getElementById('continueAfterExcel');
    
    const excelColumns = [...originalArrayForExcel];
    const convertedNumbers = [];
    let currentIndex = 0;
    
    function performConversionStep() {
        if (currentIndex >= excelColumns.length) {
            // Conversion completed
            explanation.innerHTML = `<strong>Conversion Completed!</strong> All Excel columns converted to numbers.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> All ${excelColumns.length} Excel columns successfully converted
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterExcel();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterExcel);
            
            return;
        }
        
        const currentColumn = excelColumns[currentIndex].toString().trim().toUpperCase();
        explanation.innerHTML = `Converting column "${currentColumn}" to number...`;
        
        // Highlight current element being converted
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentIndex].querySelector('.element-value');
        currentElement.classList.add('excel-column');
        
        // Show detailed calculation steps
        const calculationSteps = calculateExcelColumnSteps(currentColumn);
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex + 1}:</strong> Converting "${currentColumn}" to number
            </div>
        `;
        
        // Add to conversion table
        const tableRow = document.createElement('tr');
        tableRow.innerHTML = `
            <td><strong>${currentColumn}</strong></td>
            <td>
                <div class="excel-conversion-steps" id="steps-${currentIndex}"></div>
            </td>
            <td><strong id="result-${currentIndex}">Calculating...</strong></td>
        `;
        conversionTable.appendChild(tableRow);
        
        const stepsElement = document.getElementById(`steps-${currentIndex}`);
        const resultElement = document.getElementById(`result-${currentIndex}`);
        
        // Animate the calculation process
        animateExcelCalculation(currentColumn, calculationSteps, stepsElement, resultElement, currentIndex, () => {
            // Calculation complete for this column
            const finalResult = excelColumnToNumber(currentColumn);
            convertedNumbers.push(finalResult);
            
            // Update transformed array
            renderArrayInContainer(convertedNumbers, 'transformedExcelArray');
            
            // Highlight the converted number
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            if (transformedElements[currentIndex]) {
                transformedElements[currentIndex].querySelector('.element-value').classList.add('excel-number');
            }
            
            // Remove highlight from original element
            currentElement.classList.remove('excel-column');
            
            // Move to next column
            currentIndex++;
            setTimeout(performConversionStep, 1000);
        });
    }
    
    // Start conversion process
    performConversionStep();
}

// NEW: Calculate Detailed Steps for Excel Conversion
function calculateExcelColumnSteps(columnTitle) {
    const steps = [];
    let result = 0;
    const upperTitle = columnTitle.toUpperCase();
    
    for (let i = 0; i < upperTitle.length; i++) {
        const char = upperTitle.charAt(i);
        const charValue = char.charCodeAt(0) - 'A'.charCodeAt(0) + 1;
        const previousResult = result;
        result = result * 26 + charValue;
        
        steps.push({
            char: char,
            charValue: charValue,
            previousResult: previousResult,
            newResult: result,
            step: i + 1
        });
    }
    
    return steps;
}

// NEW: Animate Excel Calculation Steps
function animateExcelCalculation(columnTitle, steps, stepsElement, resultElement, index, callback) {
    let currentStep = 0;
    let finalResult = 0;
    
    function showNextStep() {
        if (currentStep >= steps.length) {
            // All steps completed
            resultElement.innerHTML = `<span class="text-success">${finalResult}</span>`;
            resultElement.classList.add('text-success', 'fw-bold');
            callback();
            return;
        }
        
        const step = steps[currentStep];
        finalResult = step.newResult;
        
        const stepHTML = `
            <div class="excel-conversion-step ${currentStep === steps.length - 1 ? 'active' : ''}">
                <strong>Step ${step.step}:</strong> '${step.char}'  ${step.charValue}<br>
                Calculation: ${step.previousResult}  26 + ${step.charValue} = <strong>${step.newResult}</strong>
            </div>
        `;
        
        stepsElement.innerHTML += stepHTML;
        
        // Scroll to show the latest step
        stepsElement.scrollTop = stepsElement.scrollHeight;
        
        // Update result with animation
        resultElement.innerHTML = `<span class="text-warning">${step.newResult}</span>`;
        resultElement.classList.add('pulse');
        
        setTimeout(() => {
            resultElement.classList.remove('pulse');
            currentStep++;
            showNextStep();
        }, 1500);
    }
    
    // Start showing steps
    showNextStep();
}

// NEW: Return to Original after Excel Conversion
function returnToOriginalAfterExcel() {
    // Reset to original array
    myArray = [...originalArrayForExcel];
    originalArrayForExcel = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isExcelConversionRunning = false;
    
    logOperation('Excel column conversion completed - returned to original array', 'info');
    showNotification('Returned to original array after Excel conversion', 'success');
}
// Helper function to render array in specific container
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = `
            <div class="array-empty-state">
                <i class="fas fa-layer-group"></i>
                <h6>Empty</h6>
            </div>
        `;
        return;
    }
    
    array.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}
// NEW: Number to Column Title Handler
function handleNumberToColumnTitle() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isNumberToColumnRunning) {
        showNotification('Number to column conversion is already in progress', 'warning');
        return;
    }
    
    // Validate that all elements are valid positive integers
    const invalidElements = [];
    for (let i = 0; i < myArray.length; i++) {
        const element = myArray[i];
        const num = parseInt(element);
        
        if (isNaN(num) || num < 1 || num > 2147483647 || !Number.isInteger(parseFloat(element))) {
            invalidElements.push({
                index: i,
                value: myArray[i],
                parsed: num
            });
        }
    }
    
    if (invalidElements.length > 0) {
        // Show detailed error message
        let errorMessage = 'Invalid numbers found:<br>';
        invalidElements.forEach(invalid => {
            let reason = '';
            if (isNaN(invalid.parsed)) {
                reason = 'not a number';
            } else if (invalid.parsed < 1) {
                reason = 'must be  1';
            } else if (invalid.parsed > 2147483647) {
                reason = 'must be  2147483647';
            } else if (!Number.isInteger(parseFloat(invalid.value))) {
                reason = 'must be integer';
            }
            
            errorMessage += ` Index ${invalid.index}: "${invalid.value}" - ${reason}<br>`;
        });
        errorMessage += '<br>Please enter only positive integers between 1 and 2147483647';
        
        // Show error in search results
        searchResults.innerHTML = `
            <div class="alert alert-danger">
                <h6><i class="fas fa-exclamation-triangle me-2"></i>Invalid Input</h6>
                <p class="mb-0">${errorMessage}</p>
            </div>
        `;
        
        // Highlight invalid elements with animation
        invalidElements.forEach(invalid => {
            highlightElement(invalid.index, 'excel-error');
        });
        
        logOperation('Number to column conversion failed - invalid numbers detected', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForNumberToColumn = [...myArray];
    
    // Show Number to Column conversion visualization
    showNumberToColumnVisualization();
}

// NEW: Convert Number to Excel Column Title (Python implementation equivalent)
function numberToExcelColumn(columnNumber) {
    let result = "";
    let num = columnNumber;
    
    while (num > 0) {
        num -= 1; // Adjust for 1-based indexing
        result = String.fromCharCode('A'.charCodeAt(0) + (num % 26)) + result;
        num = Math.floor(num / 26);
    }
    
    return result;
}

// NEW: Show Number to Column Visualization
function showNumberToColumnVisualization() {
    isNumberToColumnRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Number to Excel Column Title Conversion</h5>
        
        <div class="array-group">
            <div class="array-label">Column Numbers</div>
            <div class="original-array-container" id="originalNumberArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Excel Column Titles</div>
            <div class="transformed-array-container" id="transformedNumberArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Conversion Algorithm:</strong> 
                <span class="code-snippet" style="display: inline-block; padding: 5px; margin: 0;">
                    while n > 0: n--; result = chr(65 + n % 26) + result; n //= 26
                </span>
            </p>
            <p class="mb-0" id="numberToColumnExplanation">Starting number to column conversion...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="numberToColumnStepsContainer">
            <h6 class="text-center">Conversion Steps</h6>
            <div class="steps-container" id="numberToColumnSteps"></div>
        </div>
        
        <div class="table-container mt-3">
            <table class="excel-table">
                <thead>
                    <tr>
                        <th>Input Number</th>
                        <th>Conversion Process</th>
                        <th>Excel Column</th>
                    </tr>
                </thead>
                <tbody id="numberToColumnTable">
                </tbody>
            </table>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterNumberToColumn" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForNumberToColumn, 'originalNumberArray');
    renderArrayInContainer([], 'transformedNumberArray');
    
    performNumberToColumnAnimation();
}

// NEW: Perform Number to Column Animation
function performNumberToColumnAnimation() {
    const originalContainer = document.getElementById('originalNumberArray');
    const transformedContainer = document.getElementById('transformedNumberArray');
    const explanation = document.getElementById('numberToColumnExplanation');
    const stepsContainer = document.getElementById('numberToColumnSteps');
    const conversionTable = document.getElementById('numberToColumnTable');
    const continueButton = document.getElementById('continueAfterNumberToColumn');
    
    const numbers = [...originalArrayForNumberToColumn].map(num => parseInt(num));
    const convertedColumns = [];
    let currentIndex = 0;
    
    function performConversionStep() {
        if (currentIndex >= numbers.length) {
            // Conversion completed
            explanation.innerHTML = `<strong>Conversion Completed!</strong> All numbers converted to Excel columns.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> All ${numbers.length} numbers successfully converted to Excel column titles
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterNumberToColumn();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterNumberToColumn);
            
            return;
        }
        
        const currentNumber = numbers[currentIndex];
        explanation.innerHTML = `Converting number ${currentNumber} to Excel column...`;
        
        // Highlight current element being converted
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentIndex].querySelector('.element-value');
        currentElement.classList.add('number-to-column');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex + 1}:</strong> Converting number ${currentNumber} to Excel column
            </div>
        `;
        
        // Add to conversion table
        const tableRow = document.createElement('tr');
        tableRow.innerHTML = `
            <td><strong>${currentNumber}</strong></td>
            <td>
                <div class="conversion-process" id="process-${currentIndex}">
                    <div class="process-steps" id="steps-${currentIndex}"></div>
                </div>
            </td>
            <td><strong id="result-${currentIndex}">Calculating...</strong></td>
        `;
        conversionTable.appendChild(tableRow);
        
        const processElement = document.getElementById(`process-${currentIndex}`);
        const stepsElement = document.getElementById(`steps-${currentIndex}`);
        const resultElement = document.getElementById(`result-${currentIndex}`);
        
        // Animate the conversion process
        animateNumberToColumnConversion(currentNumber, processElement, stepsElement, resultElement, currentIndex, () => {
            // Conversion complete for this number
            const finalResult = numberToExcelColumn(currentNumber);
            convertedColumns.push(finalResult);
            
            // Update transformed array
            renderArrayInContainer(convertedColumns, 'transformedNumberArray');
            
            // Highlight the converted column
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            if (transformedElements[currentIndex]) {
                transformedElements[currentIndex].querySelector('.element-value').classList.add('column-title-result');
            }
            
            // Remove highlight from original element
            currentElement.classList.remove('number-to-column');
            
            // Move to next number
            currentIndex++;
            setTimeout(performConversionStep, 1000);
        });
    }
    
    // Start conversion process
    performConversionStep();
}

// NEW: Animate Number to Column Conversion Process
function animateNumberToColumnConversion(number, processElement, stepsElement, resultElement, index, callback) {
    let currentNumber = number;
    let steps = [];
    let result = "";
    let stepCount = 0;
    
    function performConversionStep() {
        if (currentNumber <= 0) {
            // Conversion completed
            resultElement.innerHTML = `<span class="text-success">"${result}"</span>`;
            resultElement.classList.add('text-success', 'fw-bold');
            
            // Show final summary
            stepsElement.innerHTML += `
                <div class="number-to-column-step active">
                    <strong>Final Result:</strong> "${result}"<br>
                    <em>Conversion completed in ${stepCount} steps</em>
                </div>
            `;
            
            callback();
            return;
        }
        
        stepCount++;
        const stepNumber = currentNumber;
        
        // Perform the conversion step
        currentNumber -= 1; // Adjust for 1-based indexing
        const remainder = currentNumber % 26;
        const char = String.fromCharCode('A'.charCodeAt(0) + remainder);
        result = char + result;
        const quotient = Math.floor(currentNumber / 26);
        
        steps.push({
            step: stepCount,
            currentNumber: stepNumber,
            adjustedNumber: currentNumber + 1,
            remainder: remainder,
            character: char,
            newResult: result,
            quotient: quotient
        });
        
        // Display current step
        const step = steps[steps.length - 1];
        const stepHTML = `
            <div class="number-to-column-step ${quotient <= 0 ? 'active' : ''}">
                <strong>Step ${step.step}:</strong><br>
                 Current number: ${step.currentNumber}<br>
                 Subtract 1: ${step.currentNumber} - 1 = ${step.adjustedNumber}<br>
                 Calculate remainder: ${step.adjustedNumber} % 26 = ${step.remainder}<br>
                 Convert to letter: ${step.remainder}  '${step.character}'<br>
                 Build result: "${step.newResult}"<br>
                 New number: ${step.adjustedNumber} // 26 = ${step.quotient}
            </div>
        `;
        
        stepsElement.innerHTML = stepHTML;
        
        // Update process visualization
        processElement.innerHTML = `
            <div class="process-step">
                <div class="bg-warning text-dark p-2 rounded">${step.currentNumber}</div>
                <div class="process-arrow"><i class="fas fa-arrow-right"></i></div>
                <div class="bg-info text-white p-2 rounded">${step.adjustedNumber}</div>
                <div class="process-arrow"><i class="fas fa-arrow-right"></i></div>
                <div class="bg-primary text-white p-2 rounded">${step.remainder}  '${step.character}'</div>
                <div class="process-arrow"><i class="fas fa-arrow-right"></i></div>
                <div class="bg-success text-white p-2 rounded">"${step.newResult}"</div>
            </div>
        `;
        
        // Update current number for next iteration
        currentNumber = quotient;
        
        // Update result with current progress
        resultElement.innerHTML = `<span class="text-warning">"${result}"</span>`;
        resultElement.classList.add('pulse');
        
        setTimeout(() => {
            resultElement.classList.remove('pulse');
            performConversionStep();
        }, 2000);
    }
    
    // Start conversion process
    performConversionStep();
}

// NEW: Return to Original after Number to Column Conversion
function returnToOriginalAfterNumberToColumn() {
    // Reset to original array
    myArray = [...originalArrayForNumberToColumn];
    originalArrayForNumberToColumn = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isNumberToColumnRunning = false;
    
    logOperation('Number to column conversion completed - returned to original array', 'info');
    showNotification('Returned to original array after number to column conversion', 'success');
}
// Update the renderArrayInContainer function to handle different data types better
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = `
            <div class="array-empty-state">
                <i class="fas fa-layer-group"></i>
                <h6>Empty</h6>
            </div>
        `;
        return;
    }
    
    array.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        
        // Format the value for display
        let displayValue = value;
        if (typeof value === 'string' && value.length > 8) {
            displayValue = value.substring(0, 8) + '...';
        }
        
        arrayElement.innerHTML = `
            <div class="element-value">${displayValue}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}
// Stack Implementation Functions
function handleImplementStack() {
    stackImplementationGroup.style.display = 'block';
    stackSizeInput.focus();
    logOperation('Started stack implementation setup', 'info');
}

function handleCreateStack() {
    const size = parseInt(stackSizeInput.value);
    
    if (isNaN(size) || size < 1 || size > 50) {
        showNotification('Please enter a valid stack size between 1 and 50', 'danger');
        stackSizeInput.focus();
        return;
    }
    
    // Store original array
    originalArrayForStack = [...myArray];
    
    // Create stack
    stack = {
        arr: new Array(size),
        top: -1,
        capacity: size
    };
    
    // Show stack operations
    stackOperations.style.display = 'block';
    stackInfo.style.display = 'flex';
    stackExplanation.style.display = 'block';
    
    // Update stack info
    updateStackInfo();
    
    // Render stack visualization
    renderStack();
    
    logOperation(`Created stack with capacity ${size}`, 'success');
    showNotification(`Stack created with capacity ${size}`, 'success');
}

function handlePush() {
    if (!stack) {
        showNotification('Please create a stack first', 'warning');
        return;
    }
    
    const value = pushValue.value.trim();
    if (value === '') {
        showNotification('Please enter a value to push', 'warning');
        pushValue.focus();
        return;
    }
    
    if (isStackOperationRunning) {
        showNotification('A stack operation is already in progress', 'warning');
        return;
    }
    
    performPushOperation(value);
}

function handlePop() {
    if (!stack) {
        showNotification('Please create a stack first', 'warning');
        return;
    }
    
    const count = parseInt(popCount.value) || 1;
    
    if (count < 1) {
        showNotification('Please enter a valid number of pops', 'warning');
        popCount.focus();
        return;
    }
    
    if (isStackOperationRunning) {
        showNotification('A stack operation is already in progress', 'warning');
        return;
    }
    
    performPopOperation(count);
}

function handlePeek() {
    if (!stack) {
        showNotification('Please create a stack first', 'warning');
        return;
    }
    
    if (isStackOperationRunning) {
        showNotification('A stack operation is already in progress', 'warning');
        return;
    }
    
    performPeekOperation();
}
function handleIsFull() {
    if (!stack) {
        showNotification('Please create a stack first', 'warning');
        return;
    }
    
    const isFull = stack.top === stack.capacity - 1;
    const message = isFull ? 'Stack is FULL' : 'Stack is NOT full';
    const type = isFull ? 'warning' : 'info';
    
    showNotification(message, type);
    logOperation(`Checked if stack is full: ${message}`, type);
    
    // Visual feedback
    if (isFull) {
        const stackContainer = document.getElementById('arrayContainer');
        stackContainer.classList.add('shake');
        setTimeout(() => {
            stackContainer.classList.remove('shake');
        }, 500);
    }
}

function handleIsEmpty() {
    if (!stack) {
        showNotification('Please create a stack first', 'warning');
        return;
    }
    
    const isEmpty = stack.top === -1;
    const message = isEmpty ? 'Stack is EMPTY' : 'Stack is NOT empty';
    const type = isEmpty ? 'warning' : 'info';
    
    showNotification(message, type);
    logOperation(`Checked if stack is empty: ${message}`, type);
}
function handleResetStack() {
    if (!stack && !isStackOperationRunning) {
        showNotification('No stack to reset', 'info');
        return;
    }
    
    // Stop any running animation first
    if (isStackOperationRunning) {
        stopStackAnimation();
    }
    
    // Reset to original array
    myArray = [...originalArrayForStack];
    stack = null;
    isStackOperationRunning = false;
    
    // Hide stack interface
    stackOperations.style.display = 'none';
    stackInfo.style.display = 'none';
    stackExplanation.style.display = 'none';
    stackImplementationGroup.style.display = 'none';
    
    // Clear inputs
    stackSizeInput.value = '';
    pushValue.value = '';
    popCount.value = '1';
    
    // Return to normal array view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    logOperation('Stack implementation reset (Shift+R)', 'info');
    showNotification('Stack reset to original position', 'success');
}

function performPushOperation(value) {
    isStackOperationRunning = true;
    
    // Auto-scroll to animation
    setTimeout(() => {
        scrollToAnimation();
    }, 100);
    
    if (stack.top === stack.capacity - 1) {
        showNotification('Stack Overflow! Cannot push to full stack', 'danger');
        logOperation(`Push operation failed: Stack Overflow (tried to push "${value}")`, 'danger');
        isStackOperationRunning = false;
        
        // Scroll back to controls after error
        setTimeout(() => {
            scrollToStackControls();
        }, 500);
        return;
    }
    
    // Create operation log
    const operationLog = document.createElement('div');
    operationLog.className = 'stack-operation-log';
    operationLog.innerHTML = '<h6>Push Operation Steps</h6>';
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(operationLog);
    
    renderStack();
    
    let step = 0;
    
    function executePushStep() {
        if (isStackOperationRunning === false) return;
        
        switch (step) {
            case 0:
                addOperationStep(operationLog, `Step 1: Check if stack is full (top = ${stack.top}, capacity = ${stack.capacity})`, 'info');
                setTimeout(executePushStep, 1500);
                break;
                
            case 1:
                addOperationStep(operationLog, `Step 2: Stack is not full, proceeding with push operation`, 'success');
                setTimeout(executePushStep, 1500);
                break;
                
            case 2:
                addOperationStep(operationLog, `Step 3: Increment top pointer from ${stack.top} to ${stack.top + 1}`, 'info');
                highlightTopPointer();
                setTimeout(executePushStep, 1500);
                break;
                
            case 3:
                stack.top++;
                updateStackInfo();
                addOperationStep(operationLog, `Step 4: Insert value "${value}" at position ${stack.top}`, 'info');
                setTimeout(executePushStep, 1500);
                break;
                
            case 4:
                stack.arr[stack.top] = value;
                renderStack();
                addOperationStep(operationLog, `Step 5: Value "${value}" successfully pushed to stack`, 'success');
                
                // Highlight the pushed element
                const stackElements = document.querySelectorAll('.stack-element');
                if (stackElements[stack.top]) {
                    const pushedElement = stackElements[stack.top];
                    pushedElement.classList.add('push-animation', 'top-element');
                }
                
                setTimeout(() => {
                    pushValue.value = '';
                    isStackOperationRunning = false;
                    logOperation(`Pushed "${value}" to stack`, 'success');
                    showNotification(`"${value}" pushed to stack successfully`, 'success');
                    
                    // Auto-scroll back to stack controls after completion
                    setTimeout(() => {
                        scrollToStackControls();
                    }, 500);
                }, 2000);
                return;
        }
        
        step++;
    }
    
    executePushStep();
}
function performPopOperation(count) {
    isStackOperationRunning = true;
    
    // Auto-scroll to animation
    setTimeout(() => {
        scrollToAnimation();
    }, 100);
    
    if (stack.top === -1) {
        showNotification('Stack Underflow! Cannot pop from empty stack', 'danger');
        logOperation(`Pop operation failed: Stack Underflow (tried to pop ${count} elements)`, 'danger');
        isStackOperationRunning = false;
        
        // Scroll back to controls after error
        setTimeout(() => {
            scrollToStackControls();
        }, 500);
        return;
    }
    
    if (count > stack.top + 1) {
        showNotification(`Cannot pop ${count} elements. Only ${stack.top + 1} elements in stack`, 'danger');
        logOperation(`Pop operation failed: Insufficient elements`, 'danger');
        isStackOperationRunning = false;
        
        // Scroll back to controls after error
        setTimeout(() => {
            scrollToStackControls();
        }, 500);
        return;
    }
    
    const operationLog = document.createElement('div');
    operationLog.className = 'stack-operation-log';
    operationLog.innerHTML = `<h6>Pop Operation Steps (Popping ${count} element${count > 1 ? 's' : ''})</h6>`;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(operationLog);
    
    renderStack();
    
    let step = 0;
    let poppedCount = 0;
    const poppedValues = [];
    
    function executePopStep() {
        if (isStackOperationRunning === false) return;
        
        if (poppedCount >= count || stack.top === -1) {
            // Operation completed
            addOperationStep(operationLog, `Pop operation completed. Popped values: [${poppedValues.join(', ')}]`, 'success');
            
            setTimeout(() => {
                popCount.value = '1';
                isStackOperationRunning = false;
                logOperation(`Popped ${count} element${count > 1 ? 's' : ''} from stack: [${poppedValues.join(', ')}]`, 'success');
                showNotification(`Popped ${count} element${count > 1 ? 's' : ''} successfully`, 'success');
                
                // Auto-scroll back to stack controls after completion
                setTimeout(() => {
                    scrollToStackControls();
                }, 500);
            }, 2000);
            return;
        }
        
        switch (step % 5) {
            case 0:
                addOperationStep(operationLog, `Step ${poppedCount + 1}.1: Check if stack is empty (top = ${stack.top})`, 'info');
                setTimeout(executePopStep, 1500);
                break;
                
            case 1:
                addOperationStep(operationLog, `Step ${poppedCount + 1}.2: Stack is not empty, proceeding with pop`, 'success');
                setTimeout(executePopStep, 1500);
                break;
                
            case 2:
                const valueToPop = stack.arr[stack.top];
                addOperationStep(operationLog, `Step ${poppedCount + 1}.3: Access top element "${valueToPop}" at position ${stack.top}`, 'info');
                
                // Highlight the element to be popped
                const stackElements = document.querySelectorAll('.stack-element');
                if (stackElements[stack.top]) {
                    stackElements[stack.top].classList.add('pop-animation');
                }
                
                setTimeout(executePopStep, 1500);
                break;
                
            case 3:
                addOperationStep(operationLog, `Step ${poppedCount + 1}.4: Decrement top pointer from ${stack.top} to ${stack.top - 1}`, 'info');
                setTimeout(executePopStep, 1500);
                break;
                
            case 4:
                const poppedValue = stack.arr[stack.top];
                stack.arr[stack.top] = undefined;
                stack.top--;
                poppedValues.push(poppedValue);
                poppedCount++;
                
                updateStackInfo();
                renderStack();
                addOperationStep(operationLog, `Step ${poppedCount + 1}.5: Value "${poppedValue}" popped successfully`, 'success');
                
                setTimeout(executePopStep, 1500);
                break;
        }
        
        step++;
    }
    
    executePopStep();
}
function performPeekOperation() {
    isStackOperationRunning = true;
    
    // Auto-scroll to animation
    setTimeout(() => {
        scrollToAnimation();
    }, 100);
    
    if (stack.top === -1) {
        showNotification('Stack is empty! Cannot peek', 'danger');
        logOperation('Peek operation failed: Stack is empty', 'danger');
        isStackOperationRunning = false;
        
        // Scroll back to controls after error
        setTimeout(() => {
            scrollToStackControls();
        }, 500);
        return;
    }
    
    const operationLog = document.createElement('div');
    operationLog.className = 'stack-operation-log';
    operationLog.innerHTML = '<h6>Peek Operation Steps</h6>';
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(operationLog);
    
    renderStack();
    
    let step = 0;
    
    function executePeekStep() {
        if (isStackOperationRunning === false) return;
        
        switch (step) {
            case 0:
                addOperationStep(operationLog, `Step 1: Check if stack is empty (top = ${stack.top})`, 'info');
                setTimeout(executePeekStep, 1500);
                break;
                
            case 1:
                addOperationStep(operationLog, 'Step 2: Stack is not empty, proceeding with peek', 'success');
                setTimeout(executePeekStep, 1500);
                break;
                
            case 2:
                const topValue = stack.arr[stack.top];
                addOperationStep(operationLog, `Step 3: Access top element at position ${stack.top}`, 'info');
                
                // Highlight the top element
                const stackElements = document.querySelectorAll('.stack-element');
                if (stackElements[stack.top]) {
                    stackElements[stack.top].classList.add('peek-highlight');
                }
                
                setTimeout(executePeekStep, 1500);
                break;
                
            case 3:
                addOperationStep(operationLog, `Step 4: Top element is "${stack.arr[stack.top]}"`, 'success');
                
                setTimeout(() => {
                    isStackOperationRunning = false;
                    logOperation(`Peek operation: Top element is "${stack.arr[stack.top]}"`, 'success');
                    showNotification(`Top element is "${stack.arr[stack.top]}"`, 'success');
                    
                    // Remove highlight after delay
                    const stackElements = document.querySelectorAll('.stack-element');
                    if (stackElements[stack.top]) {
                        setTimeout(() => {
                            stackElements[stack.top].classList.remove('peek-highlight');
                        }, 1000);
                    }
                    
                    // Auto-scroll back to stack controls after completion
                    setTimeout(() => {
                        scrollToStackControls();
                    }, 500);
                }, 2000);
                return;
        }
        
        step++;
    }
    
    executePeekStep();
}
// Stack Utility Functions
function renderStack() {
    const mainContainer = document.getElementById('arrayContainer');
    const existingLog = mainContainer.querySelector('.stack-operation-log');
    
    if (existingLog) {
        mainContainer.innerHTML = '';
        mainContainer.appendChild(existingLog);
    }
    
    const stackContainer = document.createElement('div');
    stackContainer.className = 'stack-container';
    
    // Create stack elements
    for (let i = stack.capacity - 1; i >= 0; i--) {
        const stackElement = document.createElement('div');
        stackElement.className = 'stack-element';
        
        if (i <= stack.top) {
            stackElement.textContent = stack.arr[i];
            if (i === stack.top) {
                stackElement.classList.add('top-element');
            }
        } else {
            stackElement.textContent = '';
            stackElement.style.opacity = '0.5';
        }
        
        stackContainer.appendChild(stackElement);
    }
    
    // Add top pointer
    const pointer = document.createElement('div');
    pointer.className = 'stack-pointer';
    pointer.textContent = `TOP  ${stack.top}`;
    stackContainer.appendChild(pointer);
    
    mainContainer.appendChild(stackContainer);
    
    // Add comparison section
    const comparisonSection = document.createElement('div');
    comparisonSection.className = 'stack-comparison';
    comparisonSection.innerHTML = `
        <div class="comparison-section">
            <div class="comparison-title">Array Representation</div>
            <div class="code-snippet">
                [${stack.arr.map((val, idx) => 
                    idx <= stack.top ? val : ''
                ).join(', ')}]
            </div>
            <div class="mt-2">
                <strong>Top Index:</strong> ${stack.top}<br>
                <strong>Capacity:</strong> ${stack.capacity}
            </div>
        </div>
        <div class="comparison-section">
            <div class="comparison-title">Stack Operations</div>
            <div class="code-snippet">
                push(x): O(1) - Add element<br>
                pop(): O(1) - Remove element<br>
                peek(): O(1) - View top<br>
                isEmpty(): O(1)<br>
                isFull(): O(1)
            </div>
        </div>
    `;
    
    mainContainer.appendChild(comparisonSection);
}

function updateStackInfo() {
    stackSizeValue.textContent = stack.capacity;
    stackTopValue.textContent = stack.top;
    stackStatus.textContent = stack.top === -1 ? 'Empty' : 
                             stack.top === stack.capacity - 1 ? 'Full' : 'Available';
}

function highlightTopPointer() {
    const pointers = document.querySelectorAll('.stack-pointer');
    pointers.forEach(pointer => {
        pointer.classList.add('pulse');
        setTimeout(() => {
            pointer.classList.remove('pulse');
        }, 1000);
    });
}

function addOperationStep(container, message, type) {
    const step = document.createElement('div');
    step.className = `stack-operation-step ${type}`;
    step.textContent = message;
    container.appendChild(step);
    container.scrollTop = container.scrollHeight;
}

function stopStackAnimation() {
    isStackOperationRunning = false;
    if (stackAnimationTimeout) {
        clearTimeout(stackAnimationTimeout);
    }
    showNotification('Stack animation stopped', 'warning');
    logOperation('Stack animation stopped (Shift+X)', 'warning');
    
    // Re-render stack in current state
    if (stack) {
        renderStack();
    }
}
// Add these utility functions for auto-scrolling
function scrollToAnimation() {
    const arrayContainer = document.getElementById('arrayContainer');
    if (arrayContainer) {
        arrayContainer.scrollIntoView({ 
            behavior: 'smooth', 
            block: 'center'
        });
    }
}

function scrollToStackControls() {
    const stackControls = document.getElementById('stackOperations');
    if (stackControls) {
        stackControls.scrollIntoView({ 
            behavior: 'smooth', 
            block: 'center'
        });
    }
}
// NEW: Implement Queue Handler
function handleImplementQueue() {
    if (isQueueOperationRunning) {
        showNotification('Queue operation is already in progress', 'warning');
        return;
    }

    // Store original array
    originalArrayForQueue = [...myArray];
    
    // Show queue size input dialog
    showQueueSizeInput();
}

// NEW: Show Queue Size Input
function showQueueSizeInput() {
    const queueSizeHtml = `
        <div class="glass-card">
            <h5 class="text-center mb-4">Initialize Queue</h5>
            <div class="mb-3">
                <label class="form-label">Enter Queue Size</label>
                <div class="input-group">
                    <input type="number" class="form-control" id="queueSizeInput" 
                           placeholder="Enter queue size (1-20)" min="1" max="20">
                    <button class="btn btn-glow" id="confirmQueueSizeBtn">
                        <i class="fas fa-check me-2"></i>Initialize Queue
                    </button>
                </div>
                <small class="text-muted">Maximum number of elements the queue can hold</small>
            </div>
        </div>
    `;

    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = queueSizeHtml;

    // Add event listener for confirm button
    document.getElementById('confirmQueueSizeBtn').addEventListener('click', confirmQueueSize);
    
    // Add Enter key support
    document.getElementById('queueSizeInput').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            confirmQueueSize();
        }
    });
    
    // Auto-focus the input
    document.getElementById('queueSizeInput').focus();
}

// NEW: Confirm Queue Size
function confirmQueueSize() {
    const sizeInput = document.getElementById('queueSizeInput');
    const size = parseInt(sizeInput.value);

    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid queue size between 1 and 20', 'danger');
        sizeInput.focus();
        return;
    }

    queueSize = size;
    queueArray = Array(size).fill(null);
    front = -1;
    rear = -1;

    isQueueOperationRunning = true;
    showQueueVisualization();
}
// NEW: Update the queue statistics display
function showQueueVisualization() {
    const queueHtml = `
        <div class="queue-container">
            <h4 class="text-center mb-4">Queue Implementation using Circular Array</h4>
            
            <div class="queue-visualization" id="queueVisualization">
                <!-- Queue items will be dynamically generated -->
            </div>
            
            <div class="queue-pointers" id="queuePointers">
                <!-- Pointers will be dynamically generated -->
            </div>

            <div class="queue-stats">
                <div class="stats-card">
                    <div>Queue Capacity</div>
                    <div class="stats-value">${queueSize}</div>
                </div>
                <div class="stats-card">
                    <div>Current Size</div>
                    <div class="stats-value" id="currentSize">0</div>
                </div>
                <div class="stats-card">
                    <div>Front</div>
                    <div class="stats-value" id="frontPointer">${front}</div>
                </div>
                <div class="stats-card">
                    <div>Rear</div>
                    <div class="stats-value" id="rearPointer">${rear}</div>
                </div>
            </div>

            <div class="queue-operations">
                <div class="mb-3">
                    <label class="form-label">Enqueue Operation</label>
                    <div class="input-group">
                        <input type="text" class="form-control" id="enqueueValue" placeholder="Enter value">
                        <button class="btn btn-success" id="enqueueBtn">
                            <i class="fas fa-plus-circle me-2"></i>Enqueue
                        </button>
                    </div>
                    <small class="text-muted" id="enqueueStatus">Ready to enqueue</small>
                </div>
                
                <div class="mb-3">
                    <label class="form-label">Dequeue Operation</label>
                    <div class="input-group">
                        <input type="number" class="form-control" id="dequeueCount" 
                               placeholder="Count (1)" min="1" value="1">
                        <button class="btn btn-warning" id="dequeueBtn">
                            <i class="fas fa-minus-circle me-2"></i>Dequeue
                        </button>
                    </div>
                    <small class="text-muted" id="dequeueStatus">Elements available: 0</small>
                </div>
            </div>

            <div class="d-grid gap-2">
                <button class="btn btn-glow" id="peekBtn">
                    <i class="fas fa-eye me-2"></i>Peek (Front Element)
                </button>
                <button class="btn btn-outline-light" id="resetQueueBtn">
                    <i class="fas fa-undo me-2"></i>Reset Queue (Shift+R)
                </button>
            </div>

            <div class="queue-explanation">
                <p class="mb-2"><strong>Circular Queue Operations (FIFO - First In First Out):</strong></p>
                <ul class="mb-0">
                    <li><strong>Enqueue:</strong> Add element at rear (circular fashion)</li>
                    <li><strong>Dequeue:</strong> Remove element from front (circular fashion)</li>
                    <li><strong>Peek:</strong> View front element without removing</li>
                    <li><strong>Circular:</strong> Reuses empty spaces created by dequeue</li>
                </ul>
            </div>

            <div class="algorithm-steps mt-3">
                <h6 class="text-center">Queue Operation Steps</h6>
                <div class="steps-container" id="queueSteps"></div>
            </div>
        </div>
    `;

    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = queueHtml;

    // Initialize queue visualization
    renderQueue();
    updateQueuePointers();
    updateQueueStatus();

    // Add event listeners
    document.getElementById('enqueueBtn').addEventListener('click', handleEnqueue);
    document.getElementById('dequeueBtn').addEventListener('click', handleDequeue);
    document.getElementById('peekBtn').addEventListener('click', handlePeek);
    document.getElementById('resetQueueBtn').addEventListener('click', resetAfterQueueOperation);

    // Add Enter key support
    document.getElementById('enqueueValue').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') handleEnqueue();
    });
    document.getElementById('dequeueCount').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') handleDequeue();
    });

    // Auto-scroll to queue operations
    setTimeout(() => {
        document.getElementById('enqueueValue').focus();
        document.querySelector('.queue-operations').scrollIntoView({ 
            behavior: 'smooth', 
            block: 'center' 
        });
    }, 500);

    logOperation('Circular Queue implementation initialized with size: ' + queueSize, 'info');
}

// NEW: Update Queue Status
function updateQueueStatus() {
    const currentSize = getQueueSize();
    document.getElementById('currentSize').textContent = currentSize;
    
    const enqueueStatus = document.getElementById('enqueueStatus');
    const dequeueStatus = document.getElementById('dequeueStatus');
    
    if (isQueueFull()) {
        enqueueStatus.textContent = 'Queue is FULL! Cannot enqueue.';
        enqueueStatus.className = 'text-danger';
    } else {
        enqueueStatus.textContent = `Space available: ${queueSize - currentSize}`;
        enqueueStatus.className = 'text-success';
    }
    
    dequeueStatus.textContent = `Elements available: ${currentSize}`;
    dequeueStatus.className = currentSize > 0 ? 'text-warning' : 'text-muted';
}




// NEW: Render Queue with proper circular visualization
function renderQueue() {
    const visualization = document.getElementById('queueVisualization');
    if (!visualization) return;

    let html = '<div class="queue-items-container">';
    
    for (let i = 0; i < queueSize; i++) {
        const value = queueArray[i] !== null && queueArray[i] !== undefined ? queueArray[i] : 'Empty';
        const isActive = (front !== -1 && i >= front && i <= rear) || 
                        (front !== -1 && rear < front && (i >= front || i <= rear));
        
        html += `
            <div class="queue-item ${isActive ? 'active' : ''} ${value === 'Empty' ? 'empty' : ''}">
                <div class="queue-value">${value}</div>
                <div class="queue-index">[${i}]</div>
            </div>
        `;
    }
    
    html += '</div>';
    visualization.innerHTML = html;
}



// NEW: Update Queue Pointers
function updateQueuePointers() {
    document.getElementById('frontPointer').textContent = front;
    document.getElementById('rearPointer').textContent = rear;
    updateQueueStatus();
}

// NEW: Handle Enqueue Operation (with better validation)
function handleEnqueue() {
    const valueInput = document.getElementById('enqueueValue');
    const value = valueInput.value.trim();

    if (value === '') {
        showNotification('Please enter a value to enqueue', 'warning');
        valueInput.focus();
        return;
    }

    if (isQueueFull()) {
        showNotification('Queue is full! Cannot enqueue more elements.', 'danger');
        valueInput.focus();
        return;
    }

    // Auto-scroll to show animation
    document.getElementById('queueVisualization').scrollIntoView({ 
        behavior: 'smooth', 
        block: 'center' 
    });

    performEnqueueAnimation(value);
}


// NEW: Perform Enqueue Animation (Updated for Circular Queue)
function performEnqueueAnimation(value) {
    const stepsContainer = document.getElementById('queueSteps');
    stepsContainer.innerHTML = '';

    // Step 1: Check if queue is full
    addQueueStep('Step 1: Checking if queue is full', false);
    
    if (isQueueFull()) {
        addQueueStep('Queue is FULL! Cannot enqueue element.', false);
        showNotification('Queue is full! Cannot enqueue more elements.', 'danger');
        return;
    }

    // Step 2: Check if queue is empty
    addQueueStep('Step 2: Checking if queue is empty', false);
    
    if (front === -1) {
        addQueueStep('Queue is empty. Setting front = 0, rear = 0', false);
        front = 0;
        rear = 0;
    } else {
        // Step 3: Increment rear in circular fashion
        addQueueStep('Step 3: Incrementing rear pointer in circular fashion', false);
        rear = (rear + 1) % queueSize;
        addQueueStep(`Rear moved to position: ${rear}`, false);
    }
    
    // Step 4: Add element at rear
    addQueueStep(`Step 4: Adding element "${value}" at position ${rear}`, true);
    
    queueArray[rear] = value;
    updateQueuePointers();
    renderQueue();

    // Animation
    const queueItems = document.querySelectorAll('.queue-item');
    if (queueItems[rear]) {
        const newItem = queueItems[rear];
        newItem.classList.add('enqueue-animation');
        
        setTimeout(() => {
            newItem.classList.remove('enqueue-animation');
        }, 1000);
    }

    // Clear input and auto-scroll back to operations
    setTimeout(() => {
        document.getElementById('enqueueValue').value = '';
        document.getElementById('enqueueValue').focus();
        document.querySelector('.queue-operations').scrollIntoView({ 
            behavior: 'smooth', 
            block: 'center' 
        });
    }, 1500);

    logOperation(`Enqueued element: "${value}" at position ${rear}`, 'success');
    showNotification(`Element "${value}" enqueued successfully`, 'success');
}
// NEW: Handle Dequeue Operation (with better validation)
function handleDequeue() {
    const countInput = document.getElementById('dequeueCount');
    const count = parseInt(countInput.value);

    if (isNaN(count) || count < 1) {
        showNotification('Please enter a valid dequeue count', 'danger');
        countInput.focus();
        return;
    }

    if (isQueueEmpty()) {
        showNotification('Queue is empty! Cannot dequeue elements.', 'danger');
        countInput.focus();
        return;
    }

    const currentSize = getQueueSize();
    if (count > currentSize) {
        showNotification(`Cannot dequeue ${count} elements. Queue has only ${currentSize} elements.`, 'danger');
        countInput.focus();
        return;
    }

    // Auto-scroll to show animation
    document.getElementById('queueVisualization').scrollIntoView({ 
        behavior: 'smooth', 
        block: 'center' 
    });

    performDequeueAnimation(count);
}


// NEW: Perform Dequeue Animation
// NEW: Perform Dequeue Animation (Updated for Circular Queue)
function performDequeueAnimation(count) {
    const stepsContainer = document.getElementById('queueSteps');
    stepsContainer.innerHTML = '';

    let dequeuedElements = [];

    function dequeueStep(currentCount) {
        if (currentCount <= 0 || isQueueEmpty()) {
            // Dequeue completed
            addQueueStep(`Dequeue completed. Removed elements: ${dequeuedElements.join(', ')}`, true);
            
            // Auto-scroll back to operations
            setTimeout(() => {
                document.getElementById('dequeueCount').value = '1';
                document.getElementById('dequeueCount').focus();
                document.querySelector('.queue-operations').scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center' 
                });
            }, 1000);

            logOperation(`Dequeued ${dequeuedElements.length} elements: ${dequeuedElements.join(', ')}`, 'warning');
            showNotification(`Dequeued ${dequeuedElements.length} elements successfully`, 'success');
            return;
        }

        // Step details
        addQueueStep(`Step ${count - currentCount + 1}: Removing element from front (position ${front})`, true);
        
        // Get element to dequeue
        const element = queueArray[front];
        dequeuedElements.push(element);

        // Animation
        const queueItems = document.querySelectorAll('.queue-item');
        if (queueItems[front]) {
            const removedItem = queueItems[front];
            removedItem.classList.add('dequeue-animation');
        }

        // Actual dequeue operation
        setTimeout(() => {
            queueArray[front] = null;
            
            if (front === rear) {
                // Queue becomes empty
                addQueueStep(`Queue becomes empty. Resetting front and rear to -1`, false);
                front = -1;
                rear = -1;
            } else {
                // Move front in circular fashion
                addQueueStep(`Moving front pointer in circular fashion from ${front} to ${(front + 1) % queueSize}`, false);
                front = (front + 1) % queueSize;
            }

            updateQueuePointers();
            renderQueue();

            // Continue with next dequeue
            dequeueStep(currentCount - 1);
        }, 1000);
    }

    // Start dequeue process
    dequeueStep(count);
}
// NEW: Get Current Queue Size (Circular Queue)
function getQueueSize() {
    if (front === -1) return 0;
    if (rear >= front) return rear - front + 1;
    return queueSize - front + rear + 1;
}

// NEW: Handle Peek Operation
function handlePeek() {
    if (isQueueEmpty()) {
        showNotification('Queue is empty! No element to peek.', 'warning');
        return;
    }

    const frontElement = queueArray[front];
    showNotification(`Front element is: ${frontElement}`, 'info');
    logOperation(`Peeked front element: ${frontElement}`, 'info');

    // Highlight the front element
    const queueItems = document.querySelectorAll('.queue-item');
    if (queueItems[front]) {
        const frontItem = queueItems[front];
        frontItem.classList.add('peek-animation');
        
        setTimeout(() => {
            frontItem.classList.remove('peek-animation');
        }, 2000);
    }
}


// NEW: Add Queue Step
function addQueueStep(message, isActive) {
    const stepsContainer = document.getElementById('queueSteps');
    const step = document.createElement('div');
    step.className = `queue-step ${isActive ? 'active' : ''}`;
    step.textContent = message;
    stepsContainer.appendChild(step);
    stepsContainer.scrollTop = stepsContainer.scrollHeight;
}

// NEW: Check if Queue is Empty
function isQueueEmpty() {
    return front === -1;
}

// NEW: Check if Queue is Full (Circular Queue)
function isQueueFull() {
    return (rear + 1) % queueSize === front;
}

// NEW: Reset Queue Operation
function resetAfterQueueOperation() {
    // Reset to original array
    myArray = [...originalArrayForQueue];
    originalArrayForQueue = [];
    
    // Reset queue variables
    queueArray = [];
    queueSize = 0;
    front = -1;
    rear = -1;
    isQueueOperationRunning = false;
    
    // Remove queue visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    logOperation('Queue operation completed - returned to original array', 'info');
    showNotification('Returned to original array after queue operation', 'success');
}
// NEW: Implement Priority Queue Handler
function handleImplementPriorityQueue() {
    if (isPriorityQueueRunning) {
        showNotification('Priority Queue is already running', 'info');
        return;
    }

    // Show priority queue group
    priorityQueueGroup.style.display = 'block';
    queueSizeInput.focus();
    
    logOperation('Started Priority Queue implementation', 'info');
    showNotification('Priority Queue implementation started. Please initialize queue size.', 'success');
}

// NEW: Initialize Queue Handler
function handleInitializeQueue() {
    const size = parseInt(queueSizeInput.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid queue size between 1 and 20', 'danger');
        queueSizeInput.focus();
        return;
    }

    // Store original array
    originalArrayForPriorityQueue = [...myArray];
    
    // Initialize queue
    maxQueueSize = size;
    priorityQueueArray = [];
    queueFrontIndex = -1;
    queueRearIndex = -1;
    isPriorityQueueRunning = true;
    
    // Show queue operations and stats
    queueOperations.style.display = 'flex';
    queueStats.style.display = 'flex';
    
    // Update stats
    updateQueueStats();
    
    // Show heap type selection
    showHeapTypeSelection();
    
    logOperation(`Initialized Priority Queue with size ${size}`, 'success');
    showNotification(`Priority Queue initialized with size ${size}`, 'success');
}

// NEW: Show Heap Type Selection
function showHeapTypeSelection() {
    const explanationDiv = document.createElement('div');
    explanationDiv.className = 'heap-explanation';
    explanationDiv.innerHTML = `
        <p class="mb-2"><strong>Priority Queue Type:</strong> 
            <button class="btn btn-sm ${isMinHeap ? 'btn-success' : 'btn-outline-success'}" id="minHeapBtn">
                Min-Heap (Ascending Priority)
            </button>
            <button class="btn btn-sm ${!isMinHeap ? 'btn-warning' : 'btn-outline-warning'}" id="maxHeapBtn">
                Max-Heap (Descending Priority)
            </button>
        </p>
        <p class="mb-0" id="heapExplanation">
            ${isMinHeap ? 'Min-Heap: Smallest element has highest priority' : 'Max-Heap: Largest element has highest priority'}
        </p>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.appendChild(explanationDiv);
    
    // Add event listeners for heap type buttons
    document.getElementById('minHeapBtn').addEventListener('click', () => {
        isMinHeap = true;
        showHeapTypeSelection();
        logOperation('Switched to Min-Heap (Ascending Priority)', 'info');
    });
    
    document.getElementById('maxHeapBtn').addEventListener('click', () => {
        isMinHeap = false;
        showHeapTypeSelection();
        logOperation('Switched to Max-Heap (Descending Priority)', 'info');
    });
}

// NEW: Enqueue Handler
function handleEnqueue() {
    if (!isPriorityQueueRunning) {
        showNotification('Please initialize the queue first', 'warning');
        return;
    }
    
    const value = enqueueValue.value.trim();
    const priority = parseInt(enqueuePriority.value);
    
    if (value === '') {
        showNotification('Please enter a value', 'danger');
        enqueueValue.focus();
        return;
    }
    
    if (isNaN(priority)) {
        showNotification('Please enter a valid priority number', 'danger');
        enqueuePriority.focus();
        return;
    }
    
    if (priorityQueueArray.length >= maxQueueSize) {
        showNotification('Queue is full! Cannot enqueue more elements', 'danger');
        return;
    }
    
    // Auto-scroll up for animation
    autoScrollToTop();
    
    // Perform enqueue operation with animation
    performEnqueueAnimation(value, priority);
}

// NEW: Dequeue Handler
function handleDequeue() {
    if (!isPriorityQueueRunning) {
        showNotification('Please initialize the queue first', 'warning');
        return;
    }
    
    if (priorityQueueArray.length === 0) {
        showNotification('Queue is empty! Cannot dequeue', 'danger');
        return;
    }
    
    // Auto-scroll up for animation
    autoScrollToTop();
    
    // Perform dequeue operation with animation
    performDequeueAnimation();
}

// NEW: Peek Handler
function handlePeek() {
    if (!isPriorityQueueRunning) {
        showNotification('Please initialize the queue first', 'warning');
        return;
    }
    
    if (priorityQueueArray.length === 0) {
        showNotification('Queue is empty! Cannot peek', 'danger');
        return;
    }
    
    // Auto-scroll up for animation
    autoScrollToTop();
    
    // Perform peek operation with animation
    performPeekAnimation();
}

// NEW: Reset Queue Handler
function handleResetQueue() {
    if (!isPriorityQueueRunning) {
        showNotification('No active queue to reset', 'info');
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayForPriorityQueue];
    originalArrayForPriorityQueue = [];
    
    // Hide queue elements
    priorityQueueGroup.style.display = 'none';
    queueOperations.style.display = 'none';
    queueStats.style.display = 'none';
    
    // Reset variables
    isPriorityQueueRunning = false;
    priorityQueueArray = [];
    maxQueueSize = 0;
    queueFrontIndex = -1;
    queueRearIndex = -1;
    
    // Clear inputs
    queueSizeInput.value = '';
    enqueueValue.value = '';
    enqueuePriority.value = '';
    
    // Return to normal array view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    logOperation('Priority Queue reset to original array', 'info');
    showNotification('Priority Queue reset successfully', 'success');
}

// NEW: Auto-scroll to top for animations
function autoScrollToTop() {
    const arrayContainer = document.getElementById('arrayContainer');
    arrayContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

// NEW: Auto-scroll back to operations after animation
function autoScrollToOperations() {
    setTimeout(() => {
        const queueOps = document.getElementById('queueOperations');
        if (queueOps) {
            queueOps.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }, 1000);
}

// NEW: Update Queue Statistics
function updateQueueStats() {
    document.getElementById('currentQueueSize').textContent = priorityQueueArray.length;
    document.getElementById('queueFront').textContent = 
        priorityQueueArray.length > 0 ? `Index 0 (${getHeapRoot()?.value || '-'})` : '-';
    document.getElementById('queueRear').textContent = 
        priorityQueueArray.length > 0 ? `Index ${priorityQueueArray.length - 1}` : '-';
}

// NEW: Get heap root (element with highest priority)
function getHeapRoot() {
    if (priorityQueueArray.length === 0) return null;
    return priorityQueueArray[0];
}

// NEW: Heapify up function for maintaining heap property
function heapifyUp(index) {
    if (index === 0) return;
    
    const parentIndex = Math.floor((index - 1) / 2);
    
    if (shouldSwap(parentIndex, index)) {
        // Swap with parent
        [priorityQueueArray[parentIndex], priorityQueueArray[index]] = 
        [priorityQueueArray[index], priorityQueueArray[parentIndex]];
        heapifyUp(parentIndex);
    }
}

// NEW: Heapify down function for maintaining heap property
function heapifyDown(index) {
    const leftChild = 2 * index + 1;
    const rightChild = 2 * index + 2;
    let extremeIndex = index;
    
    if (leftChild < priorityQueueArray.length && shouldSwap(extremeIndex, leftChild)) {
        extremeIndex = leftChild;
    }
    
    if (rightChild < priorityQueueArray.length && shouldSwap(extremeIndex, rightChild)) {
        extremeIndex = rightChild;
    }
    
    if (extremeIndex !== index) {
        [priorityQueueArray[index], priorityQueueArray[extremeIndex]] = 
        [priorityQueueArray[extremeIndex], priorityQueueArray[index]];
        heapifyDown(extremeIndex);
    }
}

// NEW: Check if swap should occur based on heap type
function shouldSwap(parentIndex, childIndex) {
    const parentPriority = priorityQueueArray[parentIndex].priority;
    const childPriority = priorityQueueArray[childIndex].priority;
    
    return isMinHeap ? childPriority < parentPriority : childPriority > parentPriority;
}

// NEW: Perform Enqueue Animation
function performEnqueueAnimation(value, priority) {
    const newElement = { value, priority };
    
    // Create visualization container
    const queueContainer = document.createElement('div');
    queueContainer.className = 'priority-queue-container';
    queueContainer.innerHTML = `
        <h5 class="text-center mb-3">Enqueue Operation: "${value}" with Priority ${priority}</h5>
        
        <div class="queue-diagram">
            <div class="array-label">Priority Queue (Heap) Structure</div>
            <div id="heapVisualization" class="heap-visualization"></div>
        </div>
        
        <div class="heap-explanation">
            <p class="mb-2"><strong>Enqueue Process:</strong> Adding element and maintaining heap property</p>
            <p class="mb-0" id="enqueueExplanation">Starting enqueue operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3">
            <h6 class="text-center">Enqueue Steps</h6>
            <div class="steps-container" id="enqueueSteps"></div>
        </div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(queueContainer);
    
    const explanation = document.getElementById('enqueueExplanation');
    const stepsContainer = document.getElementById('enqueueSteps');
    
    let step = 0;
    
    function performEnqueueStep() {
        switch (step) {
            case 0:
                explanation.innerHTML = `Step 1: Adding element "${value}" with priority ${priority} to the end of heap`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Add new element at the next available position
                    </div>
                `;
                
                // Add element to queue
                priorityQueueArray.push(newElement);
                updateQueueStats();
                renderHeapVisualization();
                
                // Highlight the new element
                setTimeout(() => {
                    const heapNodes = document.querySelectorAll('.queue-node');
                    if (heapNodes.length > 0) {
                        const newNode = heapNodes[heapNodes.length - 1];
                        newNode.classList.add('active');
                    }
                }, 500);
                break;
                
            case 1:
                explanation.innerHTML = `Step 2: Performing heapify-up to maintain ${isMinHeap ? 'min-heap' : 'max-heap'} property`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Compare with parent and swap if necessary (Heapify-Up)
                    </div>
                `;
                
                // Perform heapify-up with animation
                performHeapifyUpAnimation(priorityQueueArray.length - 1, stepsContainer, explanation, () => {
                    step++;
                    performEnqueueStep();
                });
                return;
                
            case 2:
                explanation.innerHTML = `<strong>Enqueue Completed!</strong> Element "${value}" successfully added to priority queue`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Element enqueued successfully. Heap property maintained.
                    </div>
                `;
                
                // Final highlight
                renderHeapVisualization();
                setTimeout(() => {
                    const heapRoot = document.querySelector('.queue-node');
                    if (heapRoot) {
                        heapRoot.classList.add('active');
                    }
                }, 500);
                
                // Clear inputs
                enqueueValue.value = '';
                enqueuePriority.value = '';
                
                // Auto-scroll back to operations
                autoScrollToOperations();
                
                logOperation(`Enqueued element "${value}" with priority ${priority}`, 'success');
                return;
        }
        
        step++;
        setTimeout(performEnqueueStep, 1500);
    }
    
    performEnqueueStep();
}

// NEW: Perform Heapify Up Animation
function performHeapifyUpAnimation(index, stepsContainer, explanation, callback) {
    if (index === 0) {
        callback();
        return;
    }
    
    const parentIndex = Math.floor((index - 1) / 2);
    
    if (shouldSwap(parentIndex, index)) {
        explanation.innerHTML = `Heapify-Up: Swapping with parent (Index ${parentIndex})`;
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Heapify-Up:</strong> Swapping elements at indices ${parentIndex} and ${index}
            </div>
        `;
        
        // Highlight elements being swapped
        renderHeapVisualization();
        setTimeout(() => {
            const heapNodes = document.querySelectorAll('.queue-node');
            heapNodes[parentIndex].classList.add('priority-high');
            heapNodes[index].classList.add('priority-high');
            
            setTimeout(() => {
                // Perform swap
                [priorityQueueArray[parentIndex], priorityQueueArray[index]] = 
                [priorityQueueArray[index], priorityQueueArray[parentIndex]];
                
                // Update visualization
                renderHeapVisualization();
                
                // Continue heapify-up
                performHeapifyUpAnimation(parentIndex, stepsContainer, explanation, callback);
            }, 1000);
        }, 500);
    } else {
        explanation.innerHTML = 'Heapify-Up: No swap needed - heap property satisfied';
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Heapify-Up:</strong> No swap needed - heap property maintained
            </div>
        `;
        callback();
    }
}

// NEW: Perform Dequeue Animation
function performDequeueAnimation() {
    if (priorityQueueArray.length === 0) return;
    
    const dequeuedElement = getHeapRoot();
    
    const queueContainer = document.createElement('div');
    queueContainer.className = 'priority-queue-container';
    queueContainer.innerHTML = `
        <h5 class="text-center mb-3">Dequeue Operation: Removing Highest Priority Element</h5>
        
        <div class="queue-diagram">
            <div class="array-label">Priority Queue (Heap) Structure</div>
            <div id="heapVisualization" class="heap-visualization"></div>
        </div>
        
        <div class="heap-explanation">
            <p class="mb-2"><strong>Dequeue Process:</strong> Removing root and maintaining heap property</p>
            <p class="mb-0" id="dequeueExplanation">Starting dequeue operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3">
            <h6 class="text-center">Dequeue Steps</h6>
            <div class="steps-container" id="dequeueSteps"></div>
        </div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(queueContainer);
    
    const explanation = document.getElementById('dequeueExplanation');
    const stepsContainer = document.getElementById('dequeueSteps');
    
    let step = 0;
    
    function performDequeueStep() {
        switch (step) {
            case 0:
                explanation.innerHTML = `Step 1: Removing root element "${dequeuedElement.value}" (priority ${dequeuedElement.priority})`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Remove the root element (highest priority)
                    </div>
                `;
                
                // Highlight root
                renderHeapVisualization();
                setTimeout(() => {
                    const heapRoot = document.querySelector('.queue-node');
                    if (heapRoot) {
                        heapRoot.classList.add('priority-high');
                    }
                }, 500);
                break;
                
            case 1:
                explanation.innerHTML = 'Step 2: Moving last element to root position';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Move last element to root position
                    </div>
                `;
                
                // Move last element to root
                if (priorityQueueArray.length === 1) {
                    priorityQueueArray.pop();
                } else {
                    priorityQueueArray[0] = priorityQueueArray.pop();
                }
                updateQueueStats();
                renderHeapVisualization();
                break;
                
            case 2:
                if (priorityQueueArray.length > 0) {
                    explanation.innerHTML = `Step 3: Performing heapify-down to maintain ${isMinHeap ? 'min-heap' : 'max-heap'} property`;
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 3:</strong> Compare with children and swap if necessary (Heapify-Down)
                        </div>
                    `;
                    
                    // Perform heapify-down with animation
                    performHeapifyDownAnimation(0, stepsContainer, explanation, () => {
                        step++;
                        performDequeueStep();
                    });
                    return;
                }
                break;
                
            case 3:
                explanation.innerHTML = `<strong>Dequeue Completed!</strong> Element "${dequeuedElement.value}" successfully removed`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Element dequeued successfully. Heap property maintained.
                    </div>
                `;
                
                // Final visualization
                renderHeapVisualization();
                
                // Auto-scroll back to operations
                autoScrollToOperations();
                
                logOperation(`Dequeued element "${dequeuedElement.value}" with priority ${dequeuedElement.priority}`, 'success');
                return;
        }
        
        step++;
        setTimeout(performDequeueStep, 1500);
    }
    
    performDequeueStep();
}

// NEW: Perform Heapify Down Animation
function performHeapifyDownAnimation(index, stepsContainer, explanation, callback) {
    const leftChild = 2 * index + 1;
    const rightChild = 2 * index + 2;
    let extremeIndex = index;
    
    // Find the extreme child
    if (leftChild < priorityQueueArray.length && shouldSwap(extremeIndex, leftChild)) {
        extremeIndex = leftChild;
    }
    
    if (rightChild < priorityQueueArray.length && shouldSwap(extremeIndex, rightChild)) {
        extremeIndex = rightChild;
    }
    
    if (extremeIndex !== index) {
        explanation.innerHTML = `Heapify-Down: Swapping with ${extremeIndex === leftChild ? 'left' : 'right'} child (Index ${extremeIndex})`;
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Heapify-Down:</strong> Swapping elements at indices ${index} and ${extremeIndex}
            </div>
        `;
        
        // Highlight elements being swapped
        renderHeapVisualization();
        setTimeout(() => {
            const heapNodes = document.querySelectorAll('.queue-node');
            heapNodes[index].classList.add('priority-high');
            heapNodes[extremeIndex].classList.add('priority-high');
            
            setTimeout(() => {
                // Perform swap
                [priorityQueueArray[index], priorityQueueArray[extremeIndex]] = 
                [priorityQueueArray[extremeIndex], priorityQueueArray[index]];
                
                // Update visualization
                renderHeapVisualization();
                
                // Continue heapify-down
                performHeapifyDownAnimation(extremeIndex, stepsContainer, explanation, callback);
            }, 1000);
        }, 500);
    } else {
        explanation.innerHTML = 'Heapify-Down: No swap needed - heap property satisfied';
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Heapify-Down:</strong> No swap needed - heap property maintained
            </div>
        `;
        callback();
    }
}

// NEW: Perform Peek Animation
function performPeekAnimation() {
    const peekElement = getHeapRoot();
    
    const queueContainer = document.createElement('div');
    queueContainer.className = 'priority-queue-container';
    queueContainer.innerHTML = `
        <h5 class="text-center mb-3">Peek Operation: Viewing Highest Priority Element</h5>
        
        <div class="queue-diagram">
            <div class="array-label">Priority Queue (Heap) Structure</div>
            <div id="heapVisualization" class="heap-visualization"></div>
        </div>
        
        <div class="heap-explanation">
            <p class="mb-2"><strong>Peek Process:</strong> Viewing the root element without removal</p>
            <p class="mb-0" id="peekExplanation">Starting peek operation...</p>
        </div>
        
        <div class="stats-card mt-3">
            <div>Highest Priority Element</div>
            <div class="stats-value">${peekElement.value} (Priority: ${peekElement.priority})</div>
        </div>
        
        <div class="algorithm-steps mt-3">
            <h6 class="text-center">Peek Steps</h6>
            <div class="steps-container" id="peekSteps"></div>
        </div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(queueContainer);
    
    const explanation = document.getElementById('peekExplanation');
    const stepsContainer = document.getElementById('peekSteps');
    
    renderHeapVisualization();
    
    // Highlight the root element
    setTimeout(() => {
        const heapRoot = document.querySelector('.queue-node');
        if (heapRoot) {
            heapRoot.classList.add('active');
        }
        
        explanation.innerHTML = `<strong>Peek Completed!</strong> Highest priority element is "${peekElement.value}" with priority ${peekElement.priority}`;
        stepsContainer.innerHTML = `
            <div class="algorithm-step active">
                <strong>Step 1:</strong> Access the root element (index 0)
            </div>
            <div class="algorithm-step active">
                <strong>Step 2:</strong> Return element without modifying the heap
            </div>
            <div class="algorithm-step active">
                <strong>Final:</strong> Element "${peekElement.value}" with priority ${peekElement.priority} is at the root
            </div>
        `;
        
        // Auto-scroll back to operations
        autoScrollToOperations();
        
        logOperation(`Peeked element "${peekElement.value}" with priority ${peekElement.priority}`, 'info');
    }, 1000);
}

// NEW: Render Heap Visualization
function renderHeapVisualization() {
    const heapVisualization = document.getElementById('heapVisualization');
    if (!heapVisualization) return;
    
    heapVisualization.innerHTML = '';
    
    if (priorityQueueArray.length === 0) {
        heapVisualization.innerHTML = `
            <div class="queue-empty-message">
                <i class="fas fa-inbox fa-2x mb-3"></i>
                <p>Priority Queue is Empty</p>
            </div>
        `;
        return;
    }
    
    // Calculate heap levels
    const levels = Math.ceil(Math.log2(priorityQueueArray.length + 1));
    
    for (let level = 0; level < levels; level++) {
        const levelStart = Math.pow(2, level) - 1;
        const levelEnd = Math.min(Math.pow(2, level + 1) - 1, priorityQueueArray.length);
        
        const levelDiv = document.createElement('div');
        levelDiv.className = 'queue-level';
        
        for (let i = levelStart; i < levelEnd; i++) {
            const element = priorityQueueArray[i];
            const nodeDiv = document.createElement('div');
            nodeDiv.className = 'queue-node';
            nodeDiv.innerHTML = `
                <div class="queue-node-value">${element.value}</div>
                <div class="queue-node-priority">P:${element.priority}</div>
            `;
            
            // Add priority-based styling
            if (i === 0) {
                nodeDiv.classList.add('priority-high');
            }
            
            levelDiv.appendChild(nodeDiv);
        }
        
        heapVisualization.appendChild(levelDiv);
        
        // Add connections between levels (except for last level)
        if (level < levels - 1) {
            const connectionsDiv = document.createElement('div');
            connectionsDiv.className = 'queue-connections';
            heapVisualization.appendChild(connectionsDiv);
        }
    }
}
// NEW: Browser History Handler
function handleBrowserHistory() {
    if (isBrowserHistoryRunning) {
        showNotification('Browser history simulation is already running', 'warning');
        return;
    }

    isBrowserHistoryRunning = true;
    
    // Store original array
    originalArrayForBrowser = [...myArray];
    
    // Initialize browser history with a default homepage
    const homepage = myArray.length > 0 ? myArray[0] : "leetcode.com";
    browserHistory = new BrowserHistoryVisualization(homepage);
    
    // Show browser history visualization
    showBrowserHistoryVisualization();
}
// NEW: Show Browser History Visualization
function showBrowserHistoryVisualization() {
    const browserContainer = document.createElement('div');
    browserContainer.className = 'browser-history-container';
    browserContainer.innerHTML = `
        <h4 class="text-center mb-4">Browser History Simulation</h4>
        
        <div class="browser-history-visualization">
            <div class="browser-stats">
                <div class="browser-stat">
                    <div>Current Position</div>
                    <div class="browser-stat-value" id="browserCurrentPos">0</div>
                </div>
                <div class="browser-stat">
                    <div>History End</div>
                    <div class="browser-stat-value" id="browserEndPos">0</div>
                </div>
                <div class="browser-stat">
                    <div>Total Pages</div>
                    <div class="browser-stat-value" id="browserTotalPages">1</div>
                </div>
            </div>
            
            <div class="browser-pointer" id="browserPointer">
                 Current Pointer (Position: 0)
            </div>
            
            <div class="browser-stack" id="browserStack">
                <div class="browser-page current">leetcode.com</div>
            </div>
            
            <div class="browser-controls">
                <div class="browser-input-group">
                    <input type="text" class="form-control" id="browserUrl" placeholder="Enter URL" value="google.com">
                    <button class="btn btn-glow" id="browserVisitBtn">
                        <i class="fas fa-plane-departure me-1"></i>Visit
                    </button>
                </div>
                
                <div class="browser-input-group">
                    <input type="number" class="form-control" id="browserBackSteps" placeholder="Steps" value="1" min="1">
                    <button class="btn btn-glow" id="browserBackBtn">
                        <i class="fas fa-arrow-left me-1"></i>Back
                    </button>
                </div>
                
                <div class="browser-input-group">
                    <input type="number" class="form-control" id="browserForwardSteps" placeholder="Steps" value="1" min="1">
                    <button class="btn btn-glow" id="browserForwardBtn">
                        <i class="fas fa-arrow-right me-1"></i>Forward
                    </button>
                </div>
            </div>
            
            <div class="browser-explanation">
                <p class="mb-2"><strong>Browser History Algorithm:</strong> Array + Pointer implementation</p>
                <p class="mb-0"><strong>Keyboard Shortcut:</strong> Left Shift + R to return to original array</p>
                <p class="mb-0" id="browserExplanation">Ready to simulate browser history operations...</p>
            </div>
            
            <div class="algorithm-steps mt-3">
                <h6 class="text-center">Operation Steps</h6>
                <div class="steps-container" id="browserSteps"></div>
            </div>
            
            <div class="text-center mt-3">
                <button class="btn btn-outline-light" id="browserResetBtn">
                    <i class="fas fa-undo me-1"></i>Reset Browser History
                </button>
                <button class="btn btn-outline-light" id="browserCloseBtn">
                    <i class="fas fa-times me-1"></i>Close Simulation
                </button>
            </div>
        </div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(browserContainer);
    
    // Initialize browser history display
    updateBrowserHistoryDisplay();
    
    // Add event listeners for browser controls
    document.getElementById('browserVisitBtn').addEventListener('click', handleBrowserVisit);
    document.getElementById('browserBackBtn').addEventListener('click', handleBrowserBack);
    document.getElementById('browserForwardBtn').addEventListener('click', handleBrowserForward);
    document.getElementById('browserResetBtn').addEventListener('click', handleBrowserReset);
    document.getElementById('browserCloseBtn').addEventListener('click', handleBrowserClose);
    
    // Add keyboard shortcut for returning to original array (Left Shift + R)
    document.addEventListener('keydown', handleBrowserKeyboardShortcut);
}

// NEW: Update Browser History Display
function updateBrowserHistoryDisplay() {
    if (!browserHistory) return;
    
    const state = browserHistory.getCurrentState();
    const stackContainer = document.getElementById('browserStack');
    const pointerElement = document.getElementById('browserPointer');
    const explanationElement = document.getElementById('browserExplanation');
    const stepsContainer = document.getElementById('browserSteps');
    
    // Update stats
    document.getElementById('browserCurrentPos').textContent = state.current;
    document.getElementById('browserEndPos').textContent = state.end;
    document.getElementById('browserTotalPages').textContent = state.history.length;
    
    // Update pointer
    pointerElement.textContent = ` Current Pointer (Position: ${state.current})`;
    pointerElement.style.marginLeft = `${state.current * 60}px`;
    
    // Clear and rebuild stack
    stackContainer.innerHTML = '';
    
    state.history.forEach((url, index) => {
        const pageElement = document.createElement('div');
        pageElement.className = 'browser-page';
        
        if (index === state.current) {
            pageElement.classList.add('current');
        } else if (index <= state.end) {
            pageElement.classList.add('visited');
        } else {
            pageElement.classList.add('cleared');
        }
        
        pageElement.textContent = `${url} [${index}]`;
        pageElement.title = `Index: ${index}${index === state.current ? ' (Current)' : ''}${index > state.end ? ' (Cleared)' : ''}`;
        
        stackContainer.appendChild(pageElement);
    });
    
    // Update explanation with current state
    explanationElement.innerHTML = `
        <strong>Current State:</strong> Position: ${state.current}, End: ${state.end}, 
        Current Page: "${state.currentPage}", History Size: ${state.history.length}
    `;
    
    // Update steps
    stepsContainer.innerHTML = '';
    state.operations.forEach((op, index) => {
        const stepElement = document.createElement('div');
        stepElement.className = `algorithm-step browser-step ${index === state.operations.length - 1 ? 'active' : ''}`;
        stepElement.innerHTML = `<strong>Step ${index + 1}:</strong> ${op}`;
        stepsContainer.appendChild(stepElement);
    });
    
    // Auto-scroll to bottom of steps
    stepsContainer.scrollTop = stepsContainer.scrollHeight;
}

// NEW: Browser Visit Handler
function handleBrowserVisit() {
    const urlInput = document.getElementById('browserUrl');
    const url = urlInput.value.trim();
    
    if (!url) {
        showNotification('Please enter a URL to visit', 'warning');
        return;
    }
    
    browserHistory.visit(url);
    updateBrowserHistoryDisplay();
    
    // Animate the new page
    setTimeout(() => {
        const stackContainer = document.getElementById('browserStack');
        const pages = stackContainer.querySelectorAll('.browser-page');
        if (pages.length > 0) {
            const currentPage = pages[browserHistory.curr];
            currentPage.classList.add('pulse');
            setTimeout(() => currentPage.classList.remove('pulse'), 1000);
        }
    }, 100);
}

// NEW: Browser Back Handler
function handleBrowserBack() {
    const stepsInput = document.getElementById('browserBackSteps');
    const steps = parseInt(stepsInput.value) || 1;
    
    const previousPage = browserHistory.back(steps);
    updateBrowserHistoryDisplay();
    
    showNotification(`Navigated back to: ${previousPage}`, 'info');
    
    // Animate the pointer movement
    const pointerElement = document.getElementById('browserPointer');
    pointerElement.classList.add('bounce');
    setTimeout(() => pointerElement.classList.remove('bounce'), 1000);
}

// NEW: Browser Forward Handler
function handleBrowserForward() {
    const stepsInput = document.getElementById('browserForwardSteps');
    const steps = parseInt(stepsInput.value) || 1;
    
    const nextPage = browserHistory.forward(steps);
    updateBrowserHistoryDisplay();
    
    showNotification(`Navigated forward to: ${nextPage}`, 'info');
    
    // Animate the pointer movement
    const pointerElement = document.getElementById('browserPointer');
    pointerElement.classList.add('bounce');
    setTimeout(() => pointerElement.classList.remove('bounce'), 1000);
}

// NEW: Browser Reset Handler
function handleBrowserReset() {
    const homepage = browserHistory.history[0];
    browserHistory = new BrowserHistoryVisualization(homepage);
    updateBrowserHistoryDisplay();
    showNotification('Browser history reset to initial state', 'info');
}

// NEW: Browser Close Handler
function handleBrowserClose() {
    // Remove keyboard event listener
    document.removeEventListener('keydown', handleBrowserKeyboardShortcut);
    
    // Reset to original array
    myArray = [...originalArrayForBrowser];
    originalArrayForBrowser = [];
    
    // Remove browser visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isBrowserHistoryRunning = false;
    browserHistory = null;
    
    logOperation('Browser history simulation completed', 'info');
    showNotification('Returned to array visualization', 'success');
}

// NEW: Browser Keyboard Shortcut Handler (Left Shift + R) - Modified to return to original position
function handleBrowserKeyboardShortcut(event) {
    if (event.key === 'R' && event.shiftKey && !event.ctrlKey && !event.altKey) {
        event.preventDefault();
        handleBrowserClose(); // This will return to original array visualization
        showNotification('Returned to original array (Shift+R)', 'info');
    }
}
// NEW: Handle Design Ordered Stream
function handleDesignOrderedStream() {
    const size = parseInt(streamSize.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid stream size between 1 and 20', 'danger');
        streamSize.focus();
        return;
    }

    // Store original array
    originalArrayBeforeStream = [...myArray];
    
    // Create ordered stream
    orderedStream = new OrderedStream(size);
    isStreamActive = true;
    
    // Show ordered stream group
    orderedStreamGroup.style.display = 'block';
    
    // Reset inputs
    streamIndex.value = '';
    streamValue.value = '';
    streamIndex.max = size;
    
    // Update display
    currentPointer.textContent = '1';
    lastChunk.textContent = '[]';
    
    // Show ordered stream visualization
    showOrderedStreamVisualization();
    
    logOperation(`Created ordered stream with size ${size}`, 'success');
    showNotification(`Ordered stream created with size ${size}. Use indices 1 to ${size}.`, 'success');
}

// NEW: Handle Insert into Stream
function handleInsertIntoStream() {
    if (!isStreamActive || !orderedStream) {
        showNotification('Please create an ordered stream first', 'warning');
        return;
    }
    
    const index = parseInt(streamIndex.value);
    const value = streamValue.value.trim();
    
    if (isNaN(index) || index < 1 || index > orderedStream.size) {
        showNotification(`Please enter a valid index between 1 and ${orderedStream.size}`, 'danger');
        streamIndex.focus();
        return;
    }
    
    if (value === '') {
        showNotification('Please enter a value to insert', 'warning');
        streamValue.focus();
        return;
    }
    
    try {
        // Insert into stream
        const chunk = orderedStream.insert(index, value);
        
        // Update display
        currentPointer.textContent = orderedStream.ptr.toString();
        lastChunk.textContent = JSON.stringify(chunk);
        
        // Clear inputs
        streamValue.value = '';
        
        // Update visualization
        updateOrderedStreamVisualization(chunk);
        
        logOperation(`Inserted "${value}" at index ${index}. Returned chunk: ${JSON.stringify(chunk)}`, 'success');
        
        // Check if stream is complete
        if (orderedStream.ptr > orderedStream.size) {
            showNotification('Ordered stream is complete! All indices have been filled.', 'success');
        }
        
    } catch (error) {
        showNotification(error.message, 'danger');
    }
}

// NEW: Handle Reset Stream
function handleResetStream() {
    if (!isStreamActive) {
        showNotification('No active ordered stream to reset', 'info');
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayBeforeStream];
    originalArrayBeforeStream = [];
    
    // Hide ordered stream group
    orderedStreamGroup.style.display = 'none';
    
    // Reset stream data
    orderedStream = null;
    isStreamActive = false;
    
    // Clear inputs
    streamSize.value = '';
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    logOperation('Ordered stream reset', 'info');
    showNotification('Ordered stream reset successfully', 'success');
}

// NEW: Show Ordered Stream Visualization
function showOrderedStreamVisualization() {
    const streamContainer = document.createElement('div');
    streamContainer.className = 'stream-container';
    streamContainer.innerHTML = `
        <h5 class="stream-title">Ordered Stream Visualization (Size: ${orderedStream.size})</h5>
        <div class="array-container" id="streamArrayContainer"></div>
        
        <div class="chunk-container" id="chunkContainer" style="display: none;">
            <div class="chunk-title">Current Chunk</div>
            <div class="array-container" id="currentChunkContainer"></div>
        </div>
        
        <div class="final-stream-container" id="finalStreamContainer" style="display: none;">
            <div class="final-stream-title">Final Reconstructed Stream</div>
            <div class="array-container" id="finalStreamDisplay"></div>
        </div>
        
        <div class="algorithm-explanation mt-3">
            <h6>Ordered Stream Algorithm</h6>
            <p>Insert values at specific indices. When you insert at the current pointer, it returns consecutive chunks of values.</p>
            
            <div class="code-snippet">
                class OrderedStream {<br>
                &nbsp;&nbsp;constructor(n) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;this.data = Array(n + 1).fill(null);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;this.ptr = 1;<br>
                &nbsp;&nbsp;}<br>
                &nbsp;&nbsp;insert(idKey, value) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;this.data[idKey] = value;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;if (idKey === this.ptr) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const result = [];<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (this.ptr < this.data.length && this.data[this.ptr]) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push(this.data[this.ptr++]);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return result;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                &nbsp;&nbsp;&nbsp;&nbsp;return [];<br>
                &nbsp;&nbsp;}<br>
                }
            </div>
        </div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(streamContainer);
    
    renderStreamArray();
}

// NEW: Render Stream Array
function renderStreamArray() {
    const container = document.getElementById('streamArrayContainer');
    container.innerHTML = '';
    
    for (let i = 1; i <= orderedStream.size; i++) {
        const streamElement = document.createElement('div');
        streamElement.className = 'stream-element';
        
        const value = orderedStream.data[i];
        const isPointer = i === orderedStream.ptr;
        
        streamElement.innerHTML = `
            <div class="stream-value ${value ? 'stream-filled' : 'stream-empty'} ${isPointer ? 'stream-pointer' : ''}" 
                 data-index="${i}" id="streamElement${i}">
                ${value || 'null'}
                <div class="stream-index">[${i}]</div>
            </div>
        `;
        
        container.appendChild(streamElement);
    }
}

// NEW: Update Ordered Stream Visualization
function updateOrderedStreamVisualization(chunk) {
    // Update main stream display
    renderStreamArray();
    
    // Show chunk if any was returned
    if (chunk.length > 0) {
        const chunkContainer = document.getElementById('chunkContainer');
        const currentChunkContainer = document.getElementById('currentChunkContainer');
        
        chunkContainer.style.display = 'block';
        currentChunkContainer.innerHTML = '';
        
        // Display the chunk
        chunk.forEach((value, index) => {
            const chunkElement = document.createElement('div');
            chunkElement.className = 'array-element';
            chunkElement.innerHTML = `
                <div class="element-value stream-chunk">
                    ${value}
                </div>
                <div class="element-index">[${index}]</div>
            `;
            currentChunkContainer.appendChild(chunkElement);
        });
        
        // Highlight the chunk in the main stream
        const startIndex = orderedStream.ptr - chunk.length;
        for (let i = startIndex; i < orderedStream.ptr; i++) {
            const element = document.getElementById(`streamElement${i}`);
            if (element) {
                element.classList.add('stream-chunk');
            }
        }
    }
    
    // Show final reconstructed stream
    const finalStream = orderedStream.getFullStream();
    if (finalStream.length > 0) {
        const finalStreamContainer = document.getElementById('finalStreamContainer');
        const finalStreamDisplay = document.getElementById('finalStreamDisplay');
        
        finalStreamContainer.style.display = 'block';
        finalStreamDisplay.innerHTML = '';
        
        finalStream.forEach((value, index) => {
            const streamElement = document.createElement('div');
            streamElement.className = 'array-element';
            streamElement.innerHTML = `
                <div class="element-value success-color">
                    ${value}
                </div>
                <div class="element-index">[${index}]</div>
            `;
            finalStreamDisplay.appendChild(streamElement);
        });
    }
}
// NEW: Run-Length Encoding Handler
function handleRLEOperation(operation) {
    if (isRLEOperationRunning) {
        showNotification('An RLE operation is already in progress', 'warning');
        return;
    }

    // Ask user for input
    const inputType = operation === 'encode' ? 'string to encode' : 'RLE string to decode';
    const example = operation === 'encode' ? 'e.g., "aaabbbccc"' : 'e.g., "a3b3c3"';
    
    const userInput = prompt(`Please enter the ${inputType}:\n${example}`);
    
    if (userInput === null) {
        // User cancelled
        return;
    }
    
    if (userInput.trim() === '') {
        showNotification('Please enter a valid string', 'danger');
        return;
    }
    
    // Validate input based on operation
    if (operation === 'decode') {
        // Validate RLE format (char followed by digits)
        const rlePattern = /^([a-zA-Z]\d+)+$/;
        if (!rlePattern.test(userInput)) {
            showNotification('Invalid RLE format. Please use pattern like "a1b2c3" where characters are followed by numbers.', 'danger');
            return;
        }
    }
    
    isRLEOperationRunning = true;
    rleInputString = userInput.trim();
    
    // Store original array
    originalArrayForRLE = [...myArray];
    
    // Show RLE visualization
    showRLEVisualization(operation);
}
// NEW: Show RLE Visualization
function showRLEVisualization(operation) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Run-Length Encoding - ${operation === 'encode' ? 'Compress String' : 'Decode RLE'}</h5>
        
        <div class="array-group">
            <div class="array-label">${operation === 'encode' ? 'Original String' : 'RLE Encoded String'}</div>
            <div class="rle-container" id="inputRleDisplay">
                <div class="text-center" id="inputRleContent">Processing...</div>
            </div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">${operation === 'encode' ? 'RLE Encoded Result' : 'Decoded String'}</div>
            <div class="transformed-array-container" id="outputRleDisplay"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Run-Length Encoding:</strong> ${operation === 'encode' ? 'Compressing consecutive characters' : 'Expanding RLE format to original string'}</p>
            <p class="mb-0" id="rleExplanation">Starting ${operation} process...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="rleStepsContainer">
            <h6 class="text-center">${operation === 'encode' ? 'Encoding Steps' : 'Decoding Steps'}</h6>
            <div class="steps-container" id="rleSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterRLE" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display input string
    const inputContent = document.getElementById('inputRleContent');
    if (operation === 'encode') {
        inputContent.innerHTML = `"${rleInputString}"`;
    } else {
        // Format RLE input for display
        let formattedInput = '';
        let i = 0;
        while (i < rleInputString.length) {
            const char = rleInputString[i++];
            let count = '';
            while (i < rleInputString.length && !isNaN(rleInputString[i])) {
                count += rleInputString[i++];
            }
            formattedInput += `<span class="rle-char">${char}</span><span class="rle-count">${count}</span>`;
        }
        inputContent.innerHTML = formattedInput;
    }
    
    // Start RLE operation
    if (operation === 'encode') {
        performRLEEncoding();
    } else {
        performRLEDecoding();
    }
}
// NEW: Perform RLE Encoding
function performRLEEncoding() {
    const outputContainer = document.getElementById('outputRleDisplay');
    const explanation = document.getElementById('rleExplanation');
    const stepsContainer = document.getElementById('rleSteps');
    const continueButton = document.getElementById('continueAfterRLE');
    
    const inputString = rleInputString;
    let encodedResult = [];
    let currentStep = 0;
    let i = 0;
    
    function performEncodingStep() {
        if (i >= inputString.length) {
            // Encoding completed
            explanation.innerHTML = `<strong>Encoding Completed!</strong> String compressed using Run-Length Encoding.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> RLE Encoding completed! Compression ratio: ${inputString.length}:${encodedResult.length * 2}
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterRLE();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterRLE);
            
            return;
        }
        
        currentStep++;
        const currentChar = inputString[i];
        let count = 1;
        
        // Count consecutive characters
        while (i + 1 < inputString.length && inputString[i + 1] === currentChar) {
            count++;
            i++;
        }
        
        explanation.innerHTML = `Step ${currentStep}: Found ${count} consecutive '${currentChar}' characters`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentStep}:</strong> Character '${currentChar}' appears ${count} times  "${currentChar}${count}"
            </div>
        `;
        
        // Add to encoded result
        encodedResult.push(`${currentChar}${count}`);
        
        // Update output display
        renderRLEArray(encodedResult, 'outputRleDisplay');
        
        // Highlight current encoding
        const outputElements = outputContainer.querySelectorAll('.array-element');
        const currentElement = outputElements[outputElements.length - 1].querySelector('.element-value');
        currentElement.classList.add('rle-encoded', 'bounce');
        
        i++;
        
        // Continue to next step
        setTimeout(performEncodingStep, 1500);
    }
    
    // Start encoding process
    performEncodingStep();
}
// NEW: Perform RLE Decoding
function performRLEDecoding() {
    const outputContainer = document.getElementById('outputRleDisplay');
    const explanation = document.getElementById('rleExplanation');
    const stepsContainer = document.getElementById('rleSteps');
    const continueButton = document.getElementById('continueAfterRLE');
    
    const rleString = rleInputString;
    let decodedResult = [];
    let currentStep = 0;
    let i = 0;
    
    function performDecodingStep() {
        if (i >= rleString.length) {
            // Decoding completed
            explanation.innerHTML = `<strong>Decoding Completed!</strong> RLE string expanded to original form.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> RLE Decoding completed! Original string restored.
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterRLE();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterRLE);
            
            return;
        }
        
        currentStep++;
        
        // Parse RLE format: character followed by digits
        const char = rleString[i++];
        let countStr = '';
        
        while (i < rleString.length && !isNaN(rleString[i])) {
            countStr += rleString[i++];
        }
        
        const count = parseInt(countStr);
        
        explanation.innerHTML = `Step ${currentStep}: Decoding "${char}${count}"  ${count} '${char}' characters`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentStep}:</strong> "${char}${count}" decodes to "${char.repeat(count)}"
            </div>
        `;
        
        // Add decoded characters to result
        for (let j = 0; j < count; j++) {
            decodedResult.push(char);
        }
        
        // Update output display
        renderArrayInContainer(decodedResult, 'outputRleDisplay');
        
        // Highlight newly added characters
        const outputElements = outputContainer.querySelectorAll('.array-element');
        for (let j = decodedResult.length - count; j < decodedResult.length; j++) {
            setTimeout(() => {
                outputElements[j].querySelector('.element-value').classList.add('rle-original', 'pulse');
            }, (j - (decodedResult.length - count)) * 100);
        }
        
        // Continue to next step
        setTimeout(performDecodingStep, 2000);
    }
    
    // Start decoding process
    performDecodingStep();
}
// NEW: Render RLE Array (special rendering for RLE format)
function renderRLEArray(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    array.forEach((item, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        
        arrayElement.innerHTML = `
            <div class="element-value rle-encoded">${item}</div>
            <div class="element-index">${index}</div>
        `;
        
        container.appendChild(arrayElement);
    });
    
    // Add slide-in animation
    const elements = container.querySelectorAll('.array-element');
    elements.forEach((element, index) => {
        setTimeout(() => {
            element.classList.add('slide-in');
        }, index * 100);
    });
}
// NEW: Return to Original after RLE Operations
function returnToOriginalAfterRLE() {
    // Reset to original array
    myArray = [...originalArrayForRLE];
    originalArrayForRLE = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isRLEOperationRunning = false;
    rleInputString = '';
    
    logOperation('RLE operation completed - returned to original array', 'info');
    showNotification('Returned to original array after RLE operation', 'success');
}
// NEW: Delta Encoding Handler
function handleDeltaEncoding() {
    if (isDeltaEncodingRunning) {
        showNotification('Delta encoding is already in progress', 'warning');
        return;
    }

    // Show input group
    deltaEncodingGroup.style.display = 'block';
    deltaArraySizeInput.focus();
    performDeltaEncodingBtn.style.display = 'none';
    
    logOperation('Started delta encoding operation', 'info');
}

// NEW: Confirm Delta Size Handler
function handleConfirmDeltaSize() {
    const size = parseInt(deltaArraySizeInput.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        deltaArraySizeInput.focus();
        return;
    }
    
    deltaArraySize = size;
    
    // Create input fields for array elements
    deltaArrayInputs.innerHTML = '<label class="form-label">Enter array elements (numbers only):</label>';
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="number" class="form-control delta-array-element" 
                   placeholder="Enter number" data-index="${i}">
        `;
        deltaArrayInputs.appendChild(inputGroup);
    }
    
    // Add event listeners for array inputs
    const deltaElements = deltaArrayInputs.querySelectorAll('.delta-array-element');
    deltaElements.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('delta-array-element')) {
                    nextInput.focus();
                }
            }
        });
    });
    
    performDeltaEncodingBtn.style.display = 'block';
    showNotification(`Array size set to ${size}. Please enter ${size} numbers.`, 'success');
}

// NEW: Perform Delta Encoding Handler
function handlePerformDeltaEncoding() {
    // Collect array elements
    const deltaElements = document.querySelectorAll('.delta-array-element');
    const inputArray = [];
    
    for (let i = 0; i < deltaElements.length; i++) {
        const value = deltaElements[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all array elements. Missing element at position ${i}`, 'danger');
            deltaElements[i].focus();
            return;
        }
        inputArray.push(parseFloat(value));
    }
    
    // Store original array
    originalArrayForDelta = [...inputArray];
    
    // Hide input group
    deltaEncodingGroup.style.display = 'none';
    
    // Start delta encoding visualization
    showDeltaEncodingVisualization(inputArray);
}

// NEW: Cancel Delta Handler
function handleCancelDelta() {
    deltaEncodingGroup.style.display = 'none';
    deltaArraySizeInput.value = '';
    deltaArrayInputs.innerHTML = '';
    performDeltaEncodingBtn.style.display = 'none';
    
    logOperation('Cancelled delta encoding operation', 'info');
}

// NEW: BWT Transform Handler
function handleBWTTransform() {
    if (isBWTRunning) {
        showNotification('BWT transform is already in progress', 'warning');
        return;
    }

    // Show input group
    bwtGroup.style.display = 'block';
    bwtString.focus();
    
    logOperation('Started BWT transform operation', 'info');
}

// NEW: Perform BWT Handler
function handlePerformBWT() {
    const inputString = bwtString.value.trim();
    const sentinel = bwtSentinel.value.trim() || '$';
    
    if (inputString === '') {
        showNotification('Please enter a string', 'danger');
        bwtString.focus();
        return;
    }
    
    if (sentinel.length !== 1) {
        showNotification('Sentinel must be a single character', 'danger');
        bwtSentinel.focus();
        return;
    }
    
    if (inputString.includes(sentinel)) {
        showNotification(`String cannot contain the sentinel character '${sentinel}'`, 'danger');
        return;
    }
    
    // Hide input group
    bwtGroup.style.display = 'none';
    
    // Start BWT visualization
    showBWTVisualization(inputString, sentinel);
}

// NEW: Cancel BWT Handler
function handleCancelBWT() {
    bwtGroup.style.display = 'none';
    bwtString.value = '';
    bwtSentinel.value = '$';
    
    logOperation('Cancelled BWT operation', 'info');
}

// NEW: MTF Transform Handler
function handleMTFTransform() {
    if (isMTFRunning) {
        showNotification('MTF transform is already in progress', 'warning');
        return;
    }

    // Show input group
    mtfGroup.style.display = 'block';
    mtfString.focus();
    
    logOperation('Started MTF transform operation', 'info');
}

// NEW: Perform MTF Handler
function handlePerformMTF() {
    const inputString = mtfString.value.trim();
    
    if (inputString === '') {
        showNotification('Please enter a string', 'danger');
        mtfString.focus();
        return;
    }
    
    // Hide input group
    mtfGroup.style.display = 'none';
    
    // Start MTF visualization
    showMTFVisualization(inputString);
}

// NEW: Cancel MTF Handler
function handleCancelMTF() {
    mtfGroup.style.display = 'none';
    mtfString.value = '';
    
    logOperation('Cancelled MTF operation', 'info');
}
// NEW: Show Delta Encoding Visualization
function showDeltaEncodingVisualization(inputArray) {
    isDeltaEncodingRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Delta Encoding & Decoding</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalDeltaArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Delta Encoded Array</div>
            <div class="transformed-array-container" id="encodedDeltaArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Decoded Delta Array</div>
            <div class="transformed-array-container" id="decodedDeltaArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Delta Encoding Process:</strong> Store differences between consecutive elements</p>
            <p class="mb-0" id="deltaExplanation">Starting delta encoding...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="deltaStepsContainer">
            <h6 class="text-center">Delta Encoding Steps</h6>
            <div class="steps-container" id="deltaSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterDelta" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(inputArray, 'originalDeltaArray');
    renderArrayInContainer([], 'encodedDeltaArray');
    renderArrayInContainer([], 'decodedDeltaArray');
    
    performDeltaEncodingAnimation(inputArray);
}

// NEW: Perform Delta Encoding Animation
function performDeltaEncodingAnimation(inputArray) {
    const originalContainer = document.getElementById('originalDeltaArray');
    const encodedContainer = document.getElementById('encodedDeltaArray');
    const decodedContainer = document.getElementById('decodedDeltaArray');
    const explanation = document.getElementById('deltaExplanation');
    const stepsContainer = document.getElementById('deltaSteps');
    const continueButton = document.getElementById('continueAfterDelta');
    
    let encodedArray = [];
    let step = 0;
    
    function performDeltaStep() {
        if (step === 0) {
            // First element (stored as-is)
            explanation.innerHTML = `Step 1: First element stored as-is: ${inputArray[0]}`;
            
            const originalElements = originalContainer.querySelectorAll('.array-element');
            originalElements[0].querySelector('.element-value').classList.add('create');
            
            encodedArray.push(inputArray[0]);
            renderArrayInContainer(encodedArray, 'encodedDeltaArray');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> First element stored as-is: encoded[0] = ${inputArray[0]}
                </div>
            `;
            
            step++;
            setTimeout(performDeltaStep, 1500);
            
        } else if (step <= inputArray.length - 1) {
            const i = step;
            explanation.innerHTML = `Step ${i + 1}: Calculate difference: ${inputArray[i]} - ${inputArray[i-1]} = ${inputArray[i] - inputArray[i-1]}`;
            
            const originalElements = originalContainer.querySelectorAll('.array-element');
            originalElements[i-1].querySelector('.element-value').classList.add('info-color');
            originalElements[i].querySelector('.element-value').classList.add('warning-color');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${i + 1}:</strong> encoded[${i}] = arr[${i}] - arr[${i-1}] = ${inputArray[i]} - ${inputArray[i-1]} = ${inputArray[i] - inputArray[i-1]}
                </div>
            `;
            
            setTimeout(() => {
                encodedArray.push(inputArray[i] - inputArray[i-1]);
                renderArrayInContainer(encodedArray, 'encodedDeltaArray');
                
                // Highlight the new encoded element
                const encodedElements = encodedContainer.querySelectorAll('.array-element');
                encodedElements[i].querySelector('.element-value').classList.add('create');
                
                // Remove highlights
                originalElements[i-1].querySelector('.element-value').classList.remove('info-color');
                originalElements[i].querySelector('.element-value').classList.remove('warning-color');
                
                step++;
                
                if (step === inputArray.length) {
                    // Encoding completed, start decoding
                    performDecodingAnimation(encodedArray);
                } else {
                    performDeltaStep();
                }
            }, 1500);
        }
    }
    
    function performDecodingAnimation(encodedArray) {
        explanation.innerHTML = '<strong>Encoding Complete!</strong> Starting decoding process...';
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Encoding Complete:</strong> Delta encoded array = [${encodedArray.join(', ')}]
            </div>
        `;
        
        let decodedArray = [];
        let decodeStep = 0;
        
        function performDecodeStep() {
            if (decodeStep === 0) {
                // First element (stored as-is)
                explanation.innerHTML = `Decode Step 1: First element as-is: ${encodedArray[0]}`;
                
                const encodedElements = encodedContainer.querySelectorAll('.array-element');
                encodedElements[0].querySelector('.element-value').classList.add('success-color');
                
                decodedArray.push(encodedArray[0]);
                renderArrayInContainer(decodedArray, 'decodedDeltaArray');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Decode Step 1:</strong> decoded[0] = encoded[0] = ${encodedArray[0]}
                    </div>
                `;
                
                decodeStep++;
                setTimeout(performDecodeStep, 1500);
                
            } else if (decodeStep <= encodedArray.length - 1) {
                const i = decodeStep;
                explanation.innerHTML = `Decode Step ${i + 1}: decoded[${i}] = decoded[${i-1}] + encoded[${i}] = ${decodedArray[i-1]} + ${encodedArray[i]} = ${decodedArray[i-1] + encodedArray[i]}`;
                
                const encodedElements = encodedContainer.querySelectorAll('.array-element');
                encodedElements[i].querySelector('.element-value').classList.add('warning-color');
                
                const decodedElements = decodedContainer.querySelectorAll('.array-element');
                if (decodedElements[i-1]) {
                    decodedElements[i-1].querySelector('.element-value').classList.add('info-color');
                }
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Decode Step ${i + 1}:</strong> decoded[${i}] = decoded[${i-1}] + encoded[${i}] = ${decodedArray[i-1]} + ${encodedArray[i]} = ${decodedArray[i-1] + encodedArray[i]}
                    </div>
                `;
                
                setTimeout(() => {
                    decodedArray.push(decodedArray[i-1] + encodedArray[i]);
                    renderArrayInContainer(decodedArray, 'decodedDeltaArray');
                    
                    // Highlight the new decoded element
                    const newDecodedElements = decodedContainer.querySelectorAll('.array-element');
                    newDecodedElements[i].querySelector('.element-value').classList.add('success-color');
                    
                    // Remove highlights
                    encodedElements[i].querySelector('.element-value').classList.remove('warning-color');
                    if (decodedElements[i-1]) {
                        decodedElements[i-1].querySelector('.element-value').classList.remove('info-color');
                    }
                    
                    decodeStep++;
                    
                    if (decodeStep === encodedArray.length) {
                        // Decoding completed
                        explanation.innerHTML = '<strong>Delta Encoding & Decoding Complete!</strong> Successfully encoded and decoded the array.';
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Decoding Complete:</strong> Original array recovered successfully!
                            </div>
                        `;
                        
                        // Verify the result
                        const isCorrect = JSON.stringify(decodedArray) === JSON.stringify(inputArray);
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step ${isCorrect ? 'active' : ''}">
                                <strong>Verification:</strong> ${isCorrect ? ' SUCCESS' : ' FAILED'} - Decoded array matches original
                            </div>
                        `;
                        
                        continueButton.style.display = 'block';
                        
                        // Auto-return after 10 seconds
                        setTimeout(() => {
                            returnToOriginalAfterDelta();
                        }, 10000);
                        
                        continueButton.addEventListener('click', returnToOriginalAfterDelta);
                    } else {
                        performDecodeStep();
                    }
                }, 1500);
            }
        }
        
        // Start decoding
        setTimeout(performDecodeStep, 1000);
    }
    
    // Start encoding process
    performDeltaStep();
}

// NEW: Return to Original after Delta
function returnToOriginalAfterDelta() {
    // Reset state
    isDeltaEncodingRunning = false;
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Clear inputs
    deltaArraySizeInput.value = '';
    deltaArrayInputs.innerHTML = '';
    performDeltaEncodingBtn.style.display = 'none';
    
    logOperation('Delta encoding completed - returned to original array', 'info');
    showNotification('Returned to original array after delta encoding', 'success');
}

// NEW: Show BWT Visualization
function showBWTVisualization(inputString, sentinel) {
    isBWTRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Burrows-Wheeler Transform</h5>
        
        <div class="array-group">
            <div class="array-label">Original String</div>
            <div class="stats-highlight">${inputString}</div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">BWT Result</div>
            <div class="stats-highlight" id="bwtResult"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>BWT Process:</strong> Generate all rotations, sort them, and take last column</p>
            <p class="mb-0" id="bwtExplanation">Starting BWT transformation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="bwtStepsContainer">
            <h6 class="text-center">BWT Transformation Steps</h6>
            <div class="steps-container" id="bwtSteps"></div>
        </div>
        
        <div class="table-container mt-3" id="bwtTableContainer" style="display: none;">
            <h6 class="text-center">All Sorted Rotations</h6>
            <table class="frequency-table">
                <thead>
                    <tr>
                        <th>Rotation</th>
                        <th>Index</th>
                    </tr>
                </thead>
                <tbody id="bwtTableBody"></tbody>
            </table>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterBWT" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    performBWTAnimation(inputString, sentinel);
}

// NEW: Perform BWT Animation
function performBWTAnimation(inputString, sentinel) {
    const bwtResult = document.getElementById('bwtResult');
    const explanation = document.getElementById('bwtExplanation');
    const stepsContainer = document.getElementById('bwtSteps');
    const bwtTableContainer = document.getElementById('bwtTableContainer');
    const bwtTableBody = document.getElementById('bwtTableBody');
    const continueButton = document.getElementById('continueAfterBWT');
    
    const s = inputString + sentinel;
    const n = s.length;
    let step = 0;
    
    function performBWTStep() {
        if (step === 0) {
            explanation.innerHTML = `Step 1: Add sentinel '${sentinel}' to string`;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Original string: "${inputString}" + sentinel "${sentinel}" = "${s}"
                </div>
            `;
            step++;
            setTimeout(performBWTStep, 1500);
            
        } else if (step === 1) {
            explanation.innerHTML = `Step 2: Generate all ${n} rotations of the string`;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 2:</strong> Generating ${n} cyclic rotations
                </div>
            `;
            
            // Show rotations table
            bwtTableContainer.style.display = 'block';
            step++;
            setTimeout(performBWTStep, 1500);
            
        } else if (step === 2) {
            explanation.innerHTML = `Step 3: Sort all rotations lexicographically`;
            
            // Generate and display all rotations
            const rotations = [];
            for (let i = 0; i < n; i++) {
                const rotation = s.slice(i) + s.slice(0, i);
                rotations.push(rotation);
            }
            
            // Display unsorted rotations
            bwtTableBody.innerHTML = '';
            rotations.forEach((rot, idx) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${rot}</td>
                    <td>${idx}</td>
                `;
                bwtTableBody.appendChild(row);
            });
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 3:</strong> Generated ${n} rotations (see table above)
                </div>
            `;
            
            step++;
            setTimeout(performBWTStep, 2000);
            
        } else if (step === 3) {
            explanation.innerHTML = `Step 4: Sort rotations and take last column for BWT result`;
            
            // Sort rotations
            const rotations = [];
            for (let i = 0; i < n; i++) {
                const rotation = s.slice(i) + s.slice(0, i);
                rotations.push(rotation);
            }
            
            const sortedRotations = [...rotations].sort();
            
            // Update table with sorted rotations
            bwtTableBody.innerHTML = '';
            sortedRotations.forEach((rot, idx) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${rot}</td>
                    <td>${rotations.indexOf(rot)}</td>
                `;
                bwtTableBody.appendChild(row);
            });
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 4:</strong> Sorted all rotations lexicographically
                </div>
            `;
            
            step++;
            setTimeout(performBWTStep, 2000);
            
        } else if (step === 4) {
            // Final step: Extract BWT result
            const rotations = [];
            for (let i = 0; i < n; i++) {
                const rotation = s.slice(i) + s.slice(0, i);
                rotations.push(rotation);
            }
            
            const sortedRotations = [...rotations].sort();
            const bwt = sortedRotations.map(rot => rot.charAt(rot.length - 1)).join('');
            
            explanation.innerHTML = `<strong>BWT Complete!</strong> Result: "${bwt}"`;
            bwtResult.textContent = bwt;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 5:</strong> Take last column of sorted rotations: "${bwt}"
                </div>
                <div class="algorithm-step active">
                    <strong>Final Result:</strong> BWT("${inputString}") = "${bwt}"
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterBWT();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterBWT);
        }
    }
    
    // Start BWT process
    performBWTStep();
}

// NEW: Return to Original after BWT
function returnToOriginalAfterBWT() {
    // Reset state
    isBWTRunning = false;
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Clear inputs
    bwtString.value = '';
    bwtSentinel.value = '$';
    
    logOperation('BWT completed - returned to original array', 'info');
    showNotification('Returned to original array after BWT', 'success');
}

// NEW: Show MTF Visualization
function showMTFVisualization(inputString) {
    isMTFRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Move-to-Front Transform</h5>
        
        <div class="array-group">
            <div class="array-label">Original String</div>
            <div class="stats-highlight">${inputString}</div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">MTF Codes</div>
            <div class="stats-highlight" id="mtfCodesResult"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Final Vocabulary</div>
            <div class="stats-highlight" id="mtfVocabResult"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Decoded String</div>
            <div class="stats-highlight" id="mtfDecodedResult"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>MTF Process:</strong> Encode characters as indices in dynamic vocabulary, move to front after each access</p>
            <p class="mb-0" id="mtfExplanation">Starting MTF transformation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="mtfStepsContainer">
            <h6 class="text-center">MTF Transformation Steps</h6>
            <div class="steps-container" id="mtfSteps"></div>
        </div>
        
        <div class="table-container mt-3" id="mtfTableContainer">
            <h6 class="text-center">Encoding Process</h6>
            <table class="frequency-table">
                <thead>
                    <tr>
                        <th>Step</th>
                        <th>Character</th>
                        <th>Vocabulary</th>
                        <th>Code</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody id="mtfTableBody"></tbody>
            </table>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMTF" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    performMTFAnimation(inputString);
}

// NEW: Perform MTF Animation
function performMTFAnimation(inputString) {
    const mtfCodesResult = document.getElementById('mtfCodesResult');
    const mtfVocabResult = document.getElementById('mtfVocabResult');
    const mtfDecodedResult = document.getElementById('mtfDecodedResult');
    const explanation = document.getElementById('mtfExplanation');
    const stepsContainer = document.getElementById('mtfSteps');
    const mtfTableBody = document.getElementById('mtfTableBody');
    const continueButton = document.getElementById('continueAfterMTF');
    
    let vocab = [];
    let codes = [];
    let step = 0;
    
    function performMTFStep() {
        if (step >= inputString.length) {
            // Encoding completed, start decoding
            explanation.innerHTML = '<strong>MTF Encoding Complete!</strong> Starting decoding process...';
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Encoding Complete:</strong> Codes = [${codes.join(', ')}], Final Vocabulary = [${vocab.join(', ')}]
                </div>
            `;
            
            mtfCodesResult.textContent = `[${codes.join(', ')}]`;
            mtfVocabResult.textContent = `[${vocab.join(', ')}]`;
            
            performMTFDecoding(codes, vocab);
            return;
        }
        
        const char = inputString[step];
        let action = '';
        
        if (!vocab.includes(char)) {
            // New character
            vocab.push(char);
            action = `Added '${char}' to vocabulary`;
        }
        
        const idx = vocab.indexOf(char);
        codes.push(idx);
        
        // Move to front
        vocab.splice(idx, 1);
        vocab.unshift(char);
        
        // Update explanation
        explanation.innerHTML = `Step ${step + 1}: Process character '${char}' -> Code = ${idx}`;
        
        // Add to steps
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step + 1}:</strong> Character '${char}' -> Code ${idx} ${action ? `(${action})` : ''}
            </div>
        `;
        
        // Add to table
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${step + 1}</td>
            <td>'${char}'</td>
            <td>[${[...vocab].join(', ')}]</td>
            <td>${idx}</td>
            <td>${action || `Moved '${char}' to front`}</td>
        `;
        mtfTableBody.appendChild(row);
        
        step++;
        setTimeout(performMTFStep, 1500);
    }
    
    function performMTFDecoding(codes, initialVocab) {
        let currentVocab = [...initialVocab];
        let decoded = [];
        let decodeStep = 0;
        
        function performDecodeStep() {
            if (decodeStep >= codes.length) {
                // Decoding completed
                const decodedString = decoded.join('');
                explanation.innerHTML = `<strong>MTF Complete!</strong> Successfully encoded and decoded the string.`;
                
                mtfDecodedResult.textContent = decodedString;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Decoding Complete:</strong> Decoded string = "${decodedString}"
                    </div>
                `;
                
                // Verify the result
                const isCorrect = decodedString === inputString;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step ${isCorrect ? 'active' : ''}">
                        <strong>Verification:</strong> ${isCorrect ? ' SUCCESS' : ' FAILED'} - Decoded string matches original
                    </div>
                `;
                
                continueButton.style.display = 'block';
                
                // Auto-return after 10 seconds
                setTimeout(() => {
                    returnToOriginalAfterMTF();
                }, 10000);
                
                continueButton.addEventListener('click', returnToOriginalAfterMTF);
                
                return;
            }
            
            const idx = codes[decodeStep];
            const char = currentVocab[idx];
            decoded.push(char);
            
            // Move to front
            currentVocab.splice(idx, 1);
            currentVocab.unshift(char);
            
            explanation.innerHTML = `Decode Step ${decodeStep + 1}: Code ${idx} -> Character '${char}'`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Decode Step ${decodeStep + 1}:</strong> Code ${idx} -> '${char}'
                </div>
            `;
            
            decodeStep++;
            setTimeout(performDecodeStep, 1500);
        }
        
        // Start decoding
        setTimeout(performDecodeStep, 1000);
    }
    
    // Start MTF process
    performMTFStep();
}

// NEW: Return to Original after MTF
function returnToOriginalAfterMTF() {
    // Reset state
    isMTFRunning = false;
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Clear inputs
    mtfString.value = '';
    
    logOperation('MTF completed - returned to original array', 'info');
    showNotification('Returned to original array after MTF', 'success');
}
// NEW: Count and Say Sequence Handler
function handleCountAndSay() {
    if (isCountAndSayRunning) {
        showNotification('Count and Say sequence is already running', 'warning');
        return;
    }
    
    // Show input group
    countAndSayGroup.style.display = 'block';
    countAndSayTerms.focus();
    
    // Hide other input groups
    stringCompressionGroup.style.display = 'none';
    
    logOperation('Started Count and Say sequence operation', 'info');
}

// NEW: String Compression Handler
function handleStringCompression() {
    if (isStringCompressionRunning) {
        showNotification('String compression is already running', 'warning');
        return;
    }
    
    // Show input group
    stringCompressionGroup.style.display = 'block';
    stringToCompress.focus();
    
    // Hide other input groups
    countAndSayGroup.style.display = 'none';
    
    logOperation('Started string compression operation', 'info');
}

// NEW: Confirm Count and Say Handler
function handleConfirmCountAndSay() {
    const terms = parseInt(countAndSayTerms.value);
    
    if (isNaN(terms) || terms < 1 || terms > 10) {
        showNotification('Please enter a valid number of terms between 1 and 10', 'danger');
        countAndSayTerms.focus();
        return;
    }
    
    // Store original array
    originalArrayForCountSay = [...myArray];
    
    // Hide input group
    countAndSayGroup.style.display = 'none';
    countAndSayTerms.value = '';
    
    // Start count and say visualization
    performCountAndSayVisualization(terms);
}

// NEW: Confirm String Compression Handler
function handleConfirmStringCompression() {
    const inputString = stringToCompress.value.trim();
    
    if (inputString === '') {
        showNotification('Please enter a string to compress', 'danger');
        stringToCompress.focus();
        return;
    }
    
    // Store original array
    originalArrayForCompression = [...myArray];
    
    // Hide input group
    stringCompressionGroup.style.display = 'none';
    stringToCompress.value = '';
    
    // Start string compression visualization
    performStringCompressionVisualization(inputString);
}

// NEW: Cancel Count and Say Handler
function handleCancelCountAndSay() {
    countAndSayGroup.style.display = 'none';
    countAndSayTerms.value = '';
    logOperation('Cancelled Count and Say operation', 'info');
}

// NEW: Cancel String Compression Handler
function handleCancelStringCompression() {
    stringCompressionGroup.style.display = 'none';
    stringToCompress.value = '';
    logOperation('Cancelled string compression operation', 'info');
}
// NEW: Perform Count and Say Visualization (Updated for 1D Array)
function performCountAndSayVisualization(n) {
    isCountAndSayRunning = true;
    
    const sequenceContainer = document.createElement('div');
    sequenceContainer.className = 'sequence-container';
    sequenceContainer.innerHTML = `
        <h5 class="text-center mb-4">Count and Say Sequence (${n} terms)</h5>
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Count and Say Algorithm:</strong> Each term describes the previous term</p>
            <p class="mb-0" id="countSayExplanation">Starting sequence generation...</p>
        </div>
        <div class="sequence-terms" id="sequenceTerms"></div>
        <div class="algorithm-steps mt-3" id="countSayStepsContainer">
            <h6 class="text-center">Generation Steps</h6>
            <div class="steps-container" id="countSaySteps"></div>
        </div>
        <button class="btn btn-sm btn-outline-light mt-3 w-100" id="continueAfterCountSay" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array (Auto in 10s)
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(sequenceContainer);
    
    generateCountAndSaySequence(n);
}
// NEW: Generate Count and Say Sequence with Animation (1D Array Format)
function generateCountAndSaySequence(n) {
    const explanation = document.getElementById('countSayExplanation');
    const stepsContainer = document.getElementById('countSaySteps');
    const sequenceTerms = document.getElementById('sequenceTerms');
    const continueButton = document.getElementById('continueAfterCountSay');
    
    let current = "1";
    let terms = [current];
    let step = 0;
    
    // Create 1D array container for all terms
    sequenceTerms.innerHTML = `
        <div class="array-group">
            <div class="array-label">Count and Say Sequence (1D Array)</div>
            <div class="original-array-container" id="countSayArray"></div>
        </div>
        <div class="sequence-details" id="sequenceDetails"></div>
    `;
    
    function generateNextTerm(termIndex) {
        if (termIndex >= n) {
            // Sequence completed
            explanation.innerHTML = `<strong>Sequence Generation Completed!</strong> Generated ${n} terms of Count and Say sequence.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Count and Say sequence completed with ${n} terms
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterCountSay();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterCountSay);
            
            return;
        }
        
        step++;
        
        if (termIndex === 0) {
            // First term
            explanation.innerHTML = `Term 1: Always starts with "1"`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Term 1:</strong> Always starts with "1"
                </div>
            `;
            
            // Display first term in array
            updateCountSayArray(terms);
            highlightTermInArray(0);
            
            setTimeout(() => {
                generateNextTerm(1);
            }, 2000);
            
        } else {
            const prevTerm = terms[termIndex - 1];
            explanation.innerHTML = `Generating Term ${termIndex + 1} from "${prevTerm}"`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Term ${termIndex + 1}:</strong> Generating from "${prevTerm}"
                </div>
            `;
            
            // Highlight the previous term we're generating from
            highlightTermInArray(termIndex - 1);
            
            generateTermWithAnimation(prevTerm, termIndex);
        }
    }
    
    function generateTermWithAnimation(prevTerm, termIndex) {
        let nextTerm = "";
        let count = 1;
        let currentChar = prevTerm[0];
        let groupStep = 0;
        
        // Show detailed processing in sequence details
        const sequenceDetails = document.getElementById('sequenceDetails');
        sequenceDetails.innerHTML = `
            <div class="algorithm-explanation mt-3">
                <h6>Generating Term ${termIndex + 1}</h6>
                <div class="processing-steps" id="processingSteps"></div>
            </div>
        `;
        
        const processingSteps = document.getElementById('processingSteps');
        
        function processGroup(i) {
            if (i >= prevTerm.length) {
                // Add final group
                nextTerm += count + currentChar;
                
                processingSteps.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final Group:</strong> ${count} '${currentChar}'  "${count}${currentChar}"
                    </div>
                `;
                
                terms.push(nextTerm);
                
                // Update the array with new term
                updateCountSayArray(terms);
                
                // Highlight the new term
                setTimeout(() => {
                    highlightTermInArray(termIndex);
                    
                    // Show term details
                    sequenceDetails.innerHTML = `
                        <div class="algorithm-explanation mt-3">
                            <h6>Term ${termIndex + 1} Generated: "${nextTerm}"</h6>
                            <p>Length: ${nextTerm.length} characters</p>
                        </div>
                    `;
                    
                    setTimeout(() => {
                        generateNextTerm(termIndex + 1);
                    }, 2000);
                }, 1000);
                
                return;
            }
            
            groupStep++;
            
            if (prevTerm[i] === currentChar) {
                // Same character
                count++;
                explanation.innerHTML = `Term ${termIndex + 1}: Same character '${currentChar}', count: ${count}`;
                
                processingSteps.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Group ${groupStep}:</strong> Same character '${currentChar}', count now ${count}
                    </div>
                `;
                
                // Show current processing state
                const currentState = nextTerm + `[${count}${currentChar}...]`;
                showIntermediateState(termIndex, currentState);
                
                setTimeout(() => {
                    processGroup(i + 1);
                }, 1500);
                
            } else {
                // Different character - add current group
                nextTerm += count + currentChar;
                explanation.innerHTML = `Term ${termIndex + 1}: New character! Adding "${count}${currentChar}"`;
                
                processingSteps.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Group ${groupStep}:</strong> Adding "${count}${currentChar}"  "${nextTerm}"
                    </div>
                `;
                
                // Reset for new character
                currentChar = prevTerm[i];
                count = 1;
                
                // Show intermediate result
                const currentState = nextTerm + `[${count}${currentChar}...]`;
                showIntermediateState(termIndex, currentState);
                
                setTimeout(() => {
                    processGroup(i + 1);
                }, 2000);
            }
        }
        
        // Start processing groups
        processGroup(1);
    }
    
    function updateCountSayArray(termsArray) {
        const arrayContainer = document.getElementById('countSayArray');
        arrayContainer.innerHTML = '';
        
        termsArray.forEach((term, index) => {
            const elementDiv = document.createElement('div');
            elementDiv.className = 'array-element dynamic-size';
            
            // Calculate dynamic width based on term length
            const baseWidth = 60;
            const widthIncrement = 15;
            const dynamicWidth = baseWidth + (term.length * widthIncrement);
            
            elementDiv.innerHTML = `
                <div class="element-value dynamic-size count-say-result" 
                     style="width: ${dynamicWidth}px; height: ${dynamicWidth}px;">
                    ${term}
                </div>
                <div class="element-index">${index}</div>
            `;
            arrayContainer.appendChild(elementDiv);
        });
    }
    
    function highlightTermInArray(termIndex) {
        const arrayElements = document.querySelectorAll('#countSayArray .array-element');
        arrayElements.forEach((el, index) => {
            const valueDiv = el.querySelector('.element-value');
            valueDiv.classList.remove('count-say-current', 'pulse');
            
            if (index === termIndex) {
                valueDiv.classList.add('count-say-current', 'pulse');
            }
        });
    }
    
    function showIntermediateState(termIndex, intermediateState) {
        const termsWithIntermediate = [...terms];
        // Add the intermediate state as the next term
        termsWithIntermediate[termIndex] = intermediateState;
        
        const arrayContainer = document.getElementById('countSayArray');
        arrayContainer.innerHTML = '';
        
        termsWithIntermediate.forEach((term, index) => {
            const elementDiv = document.createElement('div');
            elementDiv.className = 'array-element dynamic-size';
            
            if (index === termIndex) {
                // This is the intermediate term being generated
                const baseWidth = 60;
                const widthIncrement = 15;
                const dynamicWidth = baseWidth + (term.length * widthIncrement);
                
                elementDiv.innerHTML = `
                    <div class="element-value dynamic-size count-say-current" 
                         style="width: ${dynamicWidth}px; height: ${dynamicWidth}px;">
                        ${term}
                    </div>
                    <div class="element-index">${index} (generating...)</div>
                `;
            } else {
                // This is a completed term
                const baseWidth = 60;
                const widthIncrement = 15;
                const dynamicWidth = baseWidth + (term.length * widthIncrement);
                
                elementDiv.innerHTML = `
                    <div class="element-value dynamic-size count-say-result" 
                         style="width: ${dynamicWidth}px; height: ${dynamicWidth}px;">
                        ${term}
                    </div>
                    <div class="element-index">${index}</div>
                `;
            }
            arrayContainer.appendChild(elementDiv);
        });
    }
    
    // Start sequence generation
    generateNextTerm(0);
}

// NEW: Perform String Compression Visualization
function performStringCompressionVisualization(inputString) {
    isStringCompressionRunning = true;
    
    const compressionContainer = document.createElement('div');
    compressionContainer.className = 'dual-operation-container';
    compressionContainer.innerHTML = `
        <h5 class="text-center mb-3">String Compression (In-Place)</h5>
        
        <div class="array-group">
            <div class="array-label">Original String</div>
            <div class="original-array-container" id="originalCompressionArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Compression Process</div>
            <div class="transformed-array-container" id="compressionProcessArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>String Compression:</strong> Compress consecutive duplicate characters</p>
            <p class="mb-0" id="compressionExplanation">Starting string compression...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="compressionStepsContainer">
            <h6 class="text-center">Compression Steps</h6>
            <div class="steps-container" id="compressionSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Compressed Length</div>
            <div class="stats-value" id="compressedLengthValue">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3 w-100" id="continueAfterCompression" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array (Auto in 10s)
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(compressionContainer);
    
    executeStringCompression(inputString);
}

// NEW: Execute String Compression with Animation
function executeStringCompression(inputString) {
    const originalContainer = document.getElementById('originalCompressionArray');
    const processContainer = document.getElementById('compressionProcessArray');
    const explanation = document.getElementById('compressionExplanation');
    const stepsContainer = document.getElementById('compressionSteps');
    const compressedLengthValue = document.getElementById('compressedLengthValue');
    const continueButton = document.getElementById('continueAfterCompression');
    
    const chars = inputString.split('');
    let writeIndex = 0;
    let readIndex = 0;
    let step = 0;
    
    // Display original array
    renderArrayInContainer(chars, 'originalCompressionArray');
    renderArrayInContainer([...chars], 'compressionProcessArray');
    
    function compressStep() {
        if (readIndex >= chars.length) {
            // Compression completed
            explanation.innerHTML = `<strong>Compression Completed!</strong> Final compressed length: ${writeIndex}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Compression completed. New length: ${writeIndex}
                </div>
            `;
            
            compressedLengthValue.textContent = writeIndex;
            
            // Show final compressed array
            const finalArray = chars.slice(0, writeIndex);
            showFinalCompressedArray(finalArray);
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterCompression();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterCompression);
            
            return;
        }
        
        step++;
        const currentChar = chars[readIndex];
        let count = 0;
        
        explanation.innerHTML = `Step ${step}: Processing character '${currentChar}'`;
        
        // Count consecutive characters
        function countConsecutive() {
            if (readIndex < chars.length && chars[readIndex] === currentChar) {
                count++;
                
                // Highlight current character being counted
                const processElements = processContainer.querySelectorAll('.array-element');
                if (processElements[readIndex]) {
                    processElements[readIndex].querySelector('.element-value').classList.add('compression-current');
                }
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step}.${count}:</strong> Found '${currentChar}' at index ${readIndex}, count: ${count}
                    </div>
                `;
                
                readIndex++;
                
                if (readIndex < chars.length && chars[readIndex] === currentChar) {
                    setTimeout(countConsecutive, 1000);
                } else {
                    processGroup();
                }
            } else {
                processGroup();
            }
        }
        
        function processGroup() {
            // Write character
            chars[writeIndex] = currentChar;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Write Character:</strong> Written '${currentChar}' at position ${writeIndex}
                </div>
            `;
            
            writeIndex++;
            
            // Write count if needed
            if (count > 1) {
                const countStr = count.toString();
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Write Count:</strong> Writing count "${countStr}" for '${currentChar}'
                    </div>
                `;
                
                function writeCountDigit(digitIndex) {
                    if (digitIndex >= countStr.length) {
                        // Continue with next character
                        updateVisualization();
                        setTimeout(compressStep, 1500);
                        return;
                    }
                    
                    const digit = countStr[digitIndex];
                    chars[writeIndex] = digit;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Write Digit:</strong> Written '${digit}' at position ${writeIndex}
                        </div>
                    `;
                    
                    writeIndex++;
                    updateVisualization();
                    
                    setTimeout(() => {
                        writeCountDigit(digitIndex + 1);
                    }, 1000);
                }
                
                writeCountDigit(0);
            } else {
                updateVisualization();
                setTimeout(compressStep, 1500);
            }
        }
        
        function updateVisualization() {
            // Update the process array visualization
            const displayArray = [...chars];
            // Clear positions beyond writeIndex for clarity
            for (let i = writeIndex; i < displayArray.length; i++) {
                displayArray[i] = '';
            }
            renderArrayInContainer(displayArray, 'compressionProcessArray');
            
            // Highlight written positions
            const processElements = processContainer.querySelectorAll('.array-element');
            for (let i = 0; i < writeIndex; i++) {
                if (processElements[i]) {
                    const valueDiv = processElements[i].querySelector('.element-value');
                    valueDiv.classList.remove('compression-current');
                    if (isNaN(parseInt(chars[i]))) {
                        valueDiv.classList.add('compression-char');
                    } else {
                        valueDiv.classList.add('compression-count');
                    }
                }
            }
            
            compressedLengthValue.textContent = writeIndex;
        }
        
        // Start counting consecutive characters
        countConsecutive();
    }
    
    function showFinalCompressedArray(finalArray) {
        renderArrayInContainer(finalArray, 'compressionProcessArray');
        
        // Highlight the final compressed array
        const processElements = processContainer.querySelectorAll('.array-element');
        processElements.forEach((el, index) => {
            if (index < finalArray.length) {
                const valueDiv = el.querySelector('.element-value');
                valueDiv.classList.add('count-say-result', 'bounce');
            }
        });
    }
    
    // Start compression process
    compressStep();
}

// NEW: Return to Original after Count and Say
function returnToOriginalAfterCountSay() {
    // Reset to original array
    myArray = [...originalArrayForCountSay];
    originalArrayForCountSay = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isCountAndSayRunning = false;
    
    logOperation('Count and Say sequence completed - returned to original array', 'info');
    showNotification('Returned to original array after Count and Say sequence', 'success');
}

// NEW: Return to Original after String Compression
function returnToOriginalAfterCompression() {
    // Reset to original array
    myArray = [...originalArrayForCompression];
    originalArrayForCompression = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isStringCompressionRunning = false;
    
    logOperation('String compression completed - returned to original array', 'info');
    showNotification('Returned to original array after string compression', 'success');
}
// Helper function to render array in specific container
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = '<div class="array-empty-state"><i class="fas fa-layer-group"></i><h4>Array is Empty</h4></div>';
        return;
    }
    
    array.forEach((value, index) => {
        const elementDiv = document.createElement('div');
        elementDiv.className = 'array-element';
        elementDiv.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">${index}</div>
        `;
        container.appendChild(elementDiv);
    });
}
// NEW: Encode/Decode Strings Handler
function handleEncodeDecode() {
    if (isStringOperationRunning) {
        showNotification('A string operation is already in progress', 'warning');
        return;
    }

    const input = stringsInput.value.trim();
    const delimiter = delimiterInput.value.trim() || '#';
    
    if (!input) {
        showNotification('Please enter strings to encode/decode', 'warning');
        stringsInput.focus();
        return;
    }

    // Try to parse the input as JSON array
    let stringsArray;
    try {
        stringsArray = JSON.parse(input);
        if (!Array.isArray(stringsArray)) {
            throw new Error('Input must be a JSON array');
        }
    } catch (e) {
        showNotification('Please enter a valid JSON array format: ["str1", "str2", ...]', 'danger');
        stringsInput.focus();
        return;
    }

    if (delimiter.length !== 1) {
        showNotification('Delimiter must be a single character', 'warning');
        delimiterInput.focus();
        return;
    }

    isStringOperationRunning = true;
    originalArrayForStringOps = [...myArray];
    
    // Show encode/decode visualization
    showEncodeDecodeVisualization(stringsArray, delimiter);
}
// NEW: Set Log Count Handler - IMPROVED VERSION
function handleSetLogCount() {
    const count = parseInt(logCountInput.value);
    
    if (isNaN(count) || count < 1 || count > 20) {
        showNotification('Please enter a valid count between 1 and 20', 'danger');
        logCountInput.focus();
        return;
    }

    logCount = count;
    logEntries = [];
    
    // Create input fields for logs - IMPROVED
    logInputs.innerHTML = '<label class="form-label">Enter Log Entries:</label>';
    for (let i = 0; i < count; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Log ${i + 1}</span>
            <input type="text" class="form-control log-entry" 
                   placeholder='e.g., "dig1 8 1 5 1"' data-index="${i}"
                   id="logEntry${i}">
        `;
        logInputs.appendChild(inputGroup);
    }

    // Show reorder button
    reorderLogsBtn.style.display = 'block';
    
    showNotification(`Set ${count} log entries. Please enter the log data.`, 'success');
}

// NEW: Reorder Logs Handler - FIXED VERSION
function handleReorderLogs() {
    if (isStringOperationRunning) {
        showNotification('A string operation is already in progress', 'warning');
        return;
    }

    // Collect log entries - FIXED SELECTOR
    const logInputElements = document.querySelectorAll('#logInputs .log-entry');
    logEntries = [];
    
    console.log('Found log input elements:', logInputElements.length); // Debug log
    
    for (let i = 0; i < logInputElements.length; i++) {
        const inputElement = logInputElements[i];
        // Check if element exists and has value property
        if (!inputElement || inputElement.value === undefined) {
            showNotification(`Error: Log input at position ${i + 1} is not valid`, 'danger');
            return;
        }
        
        const value = inputElement.value.trim();
        if (value === '') {
            showNotification(`Please enter all log entries. Missing log at position ${i + 1}`, 'danger');
            inputElement.focus();
            return;
        }
        logEntries.push(value);
    }

    if (logEntries.length === 0) {
        showNotification('No log entries to process', 'warning');
        return;
    }

    console.log('Log entries collected:', logEntries); // Debug log
    
    isStringOperationRunning = true;
    originalArrayForStringOps = [...myArray];
    
    // Show reorder logs visualization
    showReorderLogsVisualization();
}


// NEW: Show Encode/Decode Visualization
function showEncodeDecodeVisualization(stringsArray, delimiter) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Encode and Decode Strings</h5>
        
        <div class="array-group">
            <div class="array-label">Original Strings</div>
            <div class="original-array-container" id="originalStrings"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Encoded String</div>
            <div class="transformed-array-container" id="encodedString"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Decoded Strings</div>
            <div class="transformed-array-container" id="decodedStrings"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Encode/Decode Process:</strong> Using length-prefix encoding with "${delimiter}" delimiter</p>
            <p class="mb-0" id="encodeDecodeExplanation">Starting encode/decode process...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="encodeDecodeStepsContainer">
            <h6 class="text-center">Encode/Decode Steps</h6>
            <div class="steps-container" id="encodeDecodeSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterStringOp" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Render original strings
    renderStringArrayInContainer(stringsArray, 'originalStrings');
    
    // Start encode/decode animation
    performEncodeDecodeAnimation(stringsArray, delimiter);
}

// NEW: Perform Encode/Decode Animation
function performEncodeDecodeAnimation(stringsArray, delimiter) {
    const originalContainer = document.getElementById('originalStrings');
    const encodedContainer = document.getElementById('encodedString');
    const decodedContainer = document.getElementById('decodedStrings');
    const explanation = document.getElementById('encodeDecodeExplanation');
    const stepsContainer = document.getElementById('encodeDecodeSteps');
    const continueButton = document.getElementById('continueAfterStringOp');
    
    let step = 0;
    let encodedString = '';
    let decodedArray = [];
    
    function performEncodeDecodeStep() {
        switch (step) {
            case 0:
                // Step 1: Show original strings
                explanation.innerHTML = 'Step 1: Original strings to encode';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Original strings: [${stringsArray.map(s => `"${s}"`).join(', ')}]
                    </div>
                `;
                break;
                
            case 1:
                // Step 2: Start encoding process
                explanation.innerHTML = 'Step 2: Starting encoding process...';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Encoding format: length${delimiter}string
                    </div>
                `;
                break;
                
            case 2:
                // Step 3: Encode each string
                performStringEncoding(0);
                return;
                
            case 3:
                // Step 4: Show complete encoded string
                explanation.innerHTML = `Step 4: Complete encoded string: "${encodedString}"`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 4:</strong> Final encoded string: "${encodedString}"
                    </div>
                `;
                
                // Display encoded string
                renderEncodedStringInContainer(encodedString, 'encodedString');
                break;
                
            case 4:
                // Step 5: Start decoding process
                explanation.innerHTML = 'Step 5: Starting decoding process...';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 5:</strong> Decoding from: "${encodedString}"
                    </div>
                `;
                break;
                
            case 5:
                // Step 6: Decode step by step
                performStringDecoding(0, encodedString);
                return;
                
            case 6:
                // Step 7: Show complete decoded array
                explanation.innerHTML = 'Step 7: Decoding completed successfully!';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 7:</strong> Decoded strings match original: ${JSON.stringify(stringsArray) === JSON.stringify(decodedArray)}
                    </div>
                `;
                
                // Display decoded strings
                renderStringArrayInContainer(decodedArray, 'decodedStrings');
                break;
                
            case 7:
                // Operation completed
                explanation.innerHTML = '<strong>Encode/Decode Operation Completed!</strong> Strings successfully encoded and decoded.';
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Operation completed successfully!
                    </div>
                `;
                
                continueButton.style.display = 'block';
                
                // Auto-return after 10 seconds
                setTimeout(() => {
                    returnToOriginalAfterStringOp();
                }, 10000);
                
                continueButton.addEventListener('click', returnToOriginalAfterStringOp);
                return;
        }
        
        step++;
        setTimeout(performEncodeDecodeStep, 2000);
    }
    
    function performStringEncoding(index) {
        if (index >= stringsArray.length) {
            step++;
            performEncodeDecodeStep();
            return;
        }
        
        const str = stringsArray[index];
        const encodedPart = `${str.length}${delimiter}${str}`;
        
        explanation.innerHTML = `Step 3: Encoding string ${index + 1}: "${str}"  "${encodedPart}"`;
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step 3.${index + 1}:</strong> Encode "${str}"  "${encodedPart}"
            </div>
        `;
        
        // Highlight current string being encoded
        const originalElements = originalContainer.querySelectorAll('.array-element');
        if (index < originalElements.length) {
            const element = originalElements[index].querySelector('.element-value');
            element.classList.add('create', 'pulse');
            
            setTimeout(() => {
                element.classList.remove('create', 'pulse');
            }, 1000);
        }
        
        encodedString += encodedPart;
        
        // Update encoded string display progressively
        setTimeout(() => {
            renderEncodedStringInContainer(encodedString, 'encodedString');
            performStringEncoding(index + 1);
        }, 1500);
    }
    
    function performStringDecoding(index, remainingString) {
        if (remainingString.length === 0) {
            step++;
            performEncodeDecodeStep();
            return;
        }
        
        // Find delimiter
        const delimiterIdx = remainingString.indexOf(delimiter);
        if (delimiterIdx === -1) {
            step++;
            performEncodeDecodeStep();
            return;
        }
        
        const lengthStr = remainingString.substring(0, delimiterIdx);
        const length = parseInt(lengthStr);
        const str = remainingString.substring(delimiterIdx + 1, delimiterIdx + 1 + length);
        
        explanation.innerHTML = `Step 6: Decoding part ${index + 1}: "${lengthStr}${delimiter}${str}"  "${str}"`;
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step 6.${index + 1}:</strong> Decode "${lengthStr}${delimiter}${str}"  "${str}"
            </div>
        `;
        
        decodedArray.push(str);
        const newRemainingString = remainingString.substring(delimiterIdx + 1 + length);
        
        // Update decoded array display progressively
        setTimeout(() => {
            renderStringArrayInContainer(decodedArray, 'decodedStrings');
            performStringDecoding(index + 1, newRemainingString);
        }, 1500);
    }
    
    // Start the process
    performEncodeDecodeStep();
}

// NEW: Show Reorder Logs Visualization - FIXED VERSION
function showReorderLogsVisualization() {
    // Clear any existing content first
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Reorder Data in Log Files</h5>
        
        <div class="array-group">
            <div class="array-label">Original Logs</div>
            <div class="original-array-container" id="originalLogs"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Reordered Logs</div>
            <div class="transformed-array-container" id="reorderedLogs"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Reorder Process:</strong> Letter logs first (sorted), then digit logs (original order)</p>
            <p class="mb-0" id="reorderLogsExplanation">Starting log reordering process...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="reorderLogsStepsContainer">
            <h6 class="text-center">Reorder Steps</h6>
            <div class="steps-container" id="reorderLogsSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterReorderLogs" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    mainContainer.appendChild(dualContainer);
    
    // Render original logs
    renderStringArrayInContainer(logEntries, 'originalLogs');
    
    // Start reorder logs animation after a short delay to ensure DOM is ready
    setTimeout(() => {
        performReorderLogsAnimation();
    }, 100);
}
// NEW: Perform Reorder Logs Animation - SIMPLIFIED AND FIXED
function performReorderLogsAnimation() {
    const originalContainer = document.getElementById('originalLogs');
    const reorderedContainer = document.getElementById('reorderedLogs');
    const explanation = document.getElementById('reorderLogsExplanation');
    const stepsContainer = document.getElementById('reorderLogsSteps');
    const continueButton = document.getElementById('continueAfterReorderLogs');

    // Clear previous steps
    if (stepsContainer) {
        stepsContainer.innerHTML = '';
    }
    
    let currentStep = 0;
    
    // Step 1: Show original logs
    function step1() {
        if (!explanation) return;
        
        explanation.innerHTML = 'Step 1: Original log entries';
        if (stepsContainer) {
            stepsContainer.innerHTML = `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Processing ${logEntries.length} log entries
                </div>
            `;
        }
        
        // Highlight all logs briefly
        if (originalContainer) {
            const elements = originalContainer.querySelectorAll('.array-element');
            elements.forEach((element, index) => {
                setTimeout(() => {
                    const valueDiv = element.querySelector('.element-value');
                    if (valueDiv) {
                        valueDiv.classList.add('info-color', 'pulse');
                        setTimeout(() => {
                            valueDiv.classList.remove('pulse');
                        }, 800);
                    }
                }, index * 200);
            });
        }
        
        setTimeout(step2, 2000);
    }
    
    // Step 2: Separate letter logs and digit logs
    function step2() {
        if (!explanation) return;
        
        explanation.innerHTML = 'Step 2: Separating letter logs and digit logs';
        if (stepsContainer) {
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step 2:</strong> Identifying letter logs and digit logs
                </div>
            `;
        }
        
        const letterLogs = [];
        const digitLogs = [];
        
        let processed = 0;
        
        function processNextLog() {
            if (processed >= logEntries.length) {
                // Store for next steps
                window.tempLetterLogs = letterLogs;
                window.tempDigitLogs = digitLogs;
                
                if (stepsContainer) {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 2 Complete:</strong> Found ${letterLogs.length} letter logs and ${digitLogs.length} digit logs
                        </div>
                    `;
                }
                
                setTimeout(step3, 1500);
                return;
            }
            
            const log = logEntries[processed];
            const firstSpaceIdx = log.indexOf(' ');
            let content = '';
            
            if (firstSpaceIdx !== -1) {
                content = log.substring(firstSpaceIdx + 1);
            }
            
            if (explanation) {
                explanation.innerHTML = `Step 2: Processing log ${processed + 1}: "${log}"`;
            }
            
            // Highlight in original container
            if (originalContainer) {
                const elements = originalContainer.querySelectorAll('.array-element');
                if (elements[processed]) {
                    const element = elements[processed].querySelector('.element-value');
                    if (element) {
                        if (content && content[0].match(/\d/)) {
                            // Digit log
                            element.classList.add('warning-color', 'pulse');
                            digitLogs.push(log);
                        } else {
                            // Letter log
                            element.classList.add('success-color', 'pulse');
                            letterLogs.push(log);
                        }
                        
                        if (stepsContainer) {
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step">
                                    <strong>Step 2.${processed + 1}:</strong> "${log}"  ${content && content[0].match(/\d/) ? 'Digit log' : 'Letter log'}
                                </div>
                            `;
                        }
                        
                        setTimeout(() => {
                            element.classList.remove('pulse');
                            processed++;
                            processNextLog();
                        }, 1000);
                        return;
                    }
                }
            }
            
            // If highlighting fails, just process without animation
            if (content && content[0].match(/\d/)) {
                digitLogs.push(log);
            } else {
                letterLogs.push(log);
            }
            
            processed++;
            setTimeout(processNextLog, 500);
        }
        
        processNextLog();
    }
    
    // Step 3: Sort letter logs
    function step3() {
        if (!explanation) return;
        
        explanation.innerHTML = 'Step 3: Sorting letter logs lexicographically';
        if (stepsContainer) {
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step 3:</strong> Sorting ${window.tempLetterLogs ? window.tempLetterLogs.length : 0} letter logs
                </div>
            `;
        }
        
        if (!window.tempLetterLogs || window.tempLetterLogs.length <= 1) {
            if (stepsContainer) {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3 Complete:</strong> No sorting needed for ${window.tempLetterLogs ? window.tempLetterLogs.length : 0} letter logs
                    </div>
                `;
            }
            setTimeout(step4, 1500);
            return;
        }
        
        // Sort letter logs immediately
        const sortedLetterLogs = [...window.tempLetterLogs].sort((a, b) => {
            const idxA = a.indexOf(' ');
            const idxB = b.indexOf(' ');
            const contentA = a.substring(idxA + 1);
            const contentB = b.substring(idxB + 1);
            const identifierA = a.substring(0, idxA);
            const identifierB = b.substring(0, idxB);
            
            if (contentA !== contentB) {
                return contentA.localeCompare(contentB);
            }
            return identifierA.localeCompare(identifierB);
        });
        
        window.tempLetterLogs = sortedLetterLogs;
        
        // Show sorting animation
        let sortStep = 0;
        const totalSortSteps = 3;
        
        function showSortAnimation() {
            if (sortStep >= totalSortSteps) {
                if (stepsContainer) {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 3 Complete:</strong> Letter logs sorted lexicographically
                        </div>
                    `;
                }
                setTimeout(step4, 1500);
                return;
            }
            
            sortStep++;
            if (explanation) {
                explanation.innerHTML = `Step 3: Sorting letter logs (pass ${sortStep}/${totalSortSteps})`;
            }
            setTimeout(showSortAnimation, 800);
        }
        
        showSortAnimation();
    }
    
    // Step 4: Show final result
    function step4() {
        if (!explanation) return;
        
        explanation.innerHTML = 'Step 4: Combining letter logs (sorted) and digit logs (original order)';
        
        const reorderedLogs = window.tempLetterLogs && window.tempDigitLogs 
            ? [...window.tempLetterLogs, ...window.tempDigitLogs] 
            : [...logEntries]; // Fallback
        
        if (stepsContainer) {
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step 4:</strong> Combined ${window.tempLetterLogs ? window.tempLetterLogs.length : 0} letter logs + ${window.tempDigitLogs ? window.tempDigitLogs.length : 0} digit logs
                </div>
            `;
        }
        
        // Show final reordered logs
        if (reorderedContainer) {
            renderStringArrayInContainer(reorderedLogs, 'reorderedLogs');
        }
        
        // Highlight the result
        if (reorderedContainer) {
            const elements = reorderedContainer.querySelectorAll('.array-element');
            elements.forEach((element, index) => {
                setTimeout(() => {
                    const valueDiv = element.querySelector('.element-value');
                    if (valueDiv) {
                        if (window.tempLetterLogs && index < window.tempLetterLogs.length) {
                            // Letter log (green)
                            valueDiv.classList.add('success-color', 'pulse');
                        } else {
                            // Digit log (yellow)
                            valueDiv.classList.add('warning-color', 'pulse');
                        }
                        setTimeout(() => {
                            valueDiv.classList.remove('pulse');
                        }, 800);
                    }
                }, index * 200);
            });
        }
        
        if (stepsContainer) {
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 4 Complete:</strong> Reordering completed successfully!
                </div>
            `;
        }
        
        setTimeout(finalStep, 3000);
    }
    
    // Final step: Show completion and return button
    function finalStep() {
        if (explanation) {
            explanation.innerHTML = '<strong>Log Reordering Completed!</strong> Logs successfully reordered.';
        }
        
        if (stepsContainer) {
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Letter logs first (sorted), digit logs last
                </div>
            `;
        }
        
        if (continueButton) {
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            const autoReturnTimer = setTimeout(() => {
                cleanupAndReturn();
            }, 10000);
            
            continueButton.addEventListener('click', () => {
                clearTimeout(autoReturnTimer);
                cleanupAndReturn();
            });
        } else {
            // If continue button not found, auto-return after 12 seconds
            setTimeout(cleanupAndReturn, 12000);
        }
    }
    
    function cleanupAndReturn() {
        // Clean up temporary data
        if (window.tempLetterLogs) delete window.tempLetterLogs;
        if (window.tempDigitLogs) delete window.tempDigitLogs;
        
        returnToOriginalAfterStringOp();
    }
    
    // Start the animation
    step1();
}


// NEW: Helper function to render string arrays - ROBUST VERSION
function renderStringArrayInContainer(stringsArray, containerId) {
    const container = document.getElementById(containerId);
    if (!container) {
        console.error('Container not found:', containerId);
        return;
    }
    
    container.innerHTML = '';
    
    if (!stringsArray || stringsArray.length === 0) {
        container.innerHTML = '<div class="array-empty-state"><i class="fas fa-layer-group"></i><h4>No Data</h4></div>';
        return;
    }
    
    stringsArray.forEach((str, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        
        const valueDiv = document.createElement('div');
        valueDiv.className = 'element-value';
        valueDiv.textContent = str;
        valueDiv.style.wordBreak = 'break-word';
        valueDiv.style.minHeight = '60px';
        valueDiv.style.display = 'flex';
        valueDiv.style.alignItems = 'center';
        valueDiv.style.justifyContent = 'center';
        valueDiv.style.textAlign = 'center';
        valueDiv.style.padding = '5px';
        
        const indexDiv = document.createElement('div');
        indexDiv.className = 'element-index';
        indexDiv.textContent = index;
        
        arrayElement.appendChild(valueDiv);
        arrayElement.appendChild(indexDiv);
        container.appendChild(arrayElement);
    });
}
// NEW: Helper function to render encoded string
function renderEncodedStringInContainer(encodedString, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    const arrayElement = document.createElement('div');
    arrayElement.className = 'array-element';
    
    const valueDiv = document.createElement('div');
    valueDiv.className = 'element-value';
    valueDiv.textContent = encodedString;
    valueDiv.style.minWidth = '200px';
    valueDiv.style.wordBreak = 'break-all';
    valueDiv.style.minHeight = '60px';
    valueDiv.style.display = 'flex';
    valueDiv.style.alignItems = 'center';
    valueDiv.style.justifyContent = 'center';
    valueDiv.style.textAlign = 'center';
    valueDiv.style.padding = '5px';
    
    const indexDiv = document.createElement('div');
    indexDiv.className = 'element-index';
    indexDiv.textContent = 'Encoded';
    
    arrayElement.appendChild(valueDiv);
    arrayElement.appendChild(indexDiv);
    container.appendChild(arrayElement);
}

// NEW: Return to Original after String Operations
function returnToOriginalAfterStringOp() {
    // Reset to original array
    myArray = [...originalArrayForStringOps];
    originalArrayForStringOps = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isStringOperationRunning = false;
    
    // Clear inputs
    stringsInput.value = '';
    delimiterInput.value = '#';
    logCountInput.value = '';
    logInputs.innerHTML = '';
    reorderLogsBtn.style.display = 'none';
    logEntries = [];
    logCount = 0;
    
    logOperation('String operation completed - returned to original array', 'info');
    showNotification('Returned to original array after string operation', 'success');
}
// Pattern Search Handler
function handlePatternAlgorithm(algorithm) {
    if (isPatternSearchRunning) {
        showNotification('A pattern search operation is already in progress', 'warning');
        return;
    }

    currentPatternAlgorithm = algorithm;
    
    // Set title based on algorithm
    const algorithmName = algorithm === 'rabin-karp' ? 'Rabin-Karp' : 'Z-Algorithm';
    patternAlgorithmTitle.textContent = `${algorithmName} Pattern Search`;
    
    // Show input group
    patternSearchGroup.style.display = 'block';
    searchTextInput.focus();
    
    // Clear previous inputs
    searchTextInput.value = '';
    searchPatternInput.value = '';
    
    logOperation(`Started ${algorithmName} pattern search operation`, 'info');
}

// Execute Pattern Search
function executePatternSearch() {
    const text = searchTextInput.value.trim();
    const pattern = searchPatternInput.value.trim();
    
    if (text === '') {
        showNotification('Please enter the text to search in', 'danger');
        searchTextInput.focus();
        return;
    }
    
    if (pattern === '') {
        showNotification('Please enter the pattern to search for', 'danger');
        searchPatternInput.focus();
        return;
    }
    
    if (pattern.length > text.length) {
        showNotification('Pattern cannot be longer than text', 'danger');
        searchPatternInput.focus();
        return;
    }
    
    // Store original array
    originalArrayBeforePatternSearch = [...myArray];
    
    // Hide input group
    patternSearchGroup.style.display = 'none';
    
    // Start pattern search visualization
    if (currentPatternAlgorithm === 'rabin-karp') {
        showRabinKarpVisualization(text, pattern);
    } else {
        showZAlgorithmVisualization(text, pattern);
    }
}

// Cancel Pattern Search
function cancelPatternSearch() {
    patternSearchGroup.style.display = 'none';
    searchTextInput.value = '';
    searchPatternInput.value = '';
    currentPatternAlgorithm = null;
    
    logOperation('Cancelled pattern search operation', 'info');
    showNotification('Pattern search operation cancelled', 'info');
}

// Rabin-Karp Algorithm Visualization
function showRabinKarpVisualization(text, pattern) {
    isPatternSearchRunning = true;
    
    const container = document.createElement('div');
    container.className = 'pattern-search-container';
    container.innerHTML = `
        <h5 class="text-center mb-3">Rabin-Karp Algorithm Visualization</h5>
        
        <div class="mb-3">
            <strong>Text:</strong>
            <div class="string-display" id="rabinTextDisplay">${text}</div>
        </div>
        
        <div class="mb-3">
            <strong>Pattern:</strong>
            <div class="string-display" id="rabinPatternDisplay">${pattern}</div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Rabin-Karp Algorithm:</strong> Uses rolling hash to efficiently search for patterns</p>
            <p class="mb-0" id="rabinExplanation">Initializing Rabin-Karp algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="rabinStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="rabinSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Found Indices</div>
            <div class="stats-value" id="rabinResults">[]</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="rabinContinueBtn">
            <i class="fas fa-undo me-1"></i>Return to Original Array (Auto in 10s)
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(container);
    
    executeRabinKarpAlgorithm(text, pattern);
}

// Execute Rabin-Karp Algorithm
function executeRabinKarpAlgorithm(text, pattern) {
    const textDisplay = document.getElementById('rabinTextDisplay');
    const patternDisplay = document.getElementById('rabinPatternDisplay');
    const explanation = document.getElementById('rabinExplanation');
    const stepsContainer = document.getElementById('rabinSteps');
    const resultsDisplay = document.getElementById('rabinResults');
    const continueButton = document.getElementById('rabinContinueBtn');
    
    const n = text.length;
    const m = pattern.length;
    const base = 256;
    const prime = 101;
    const result = [];
    let step = 0;
    
    function executeStep() {
        if (step === 0) {
            // Step 1: Calculate hash values
            explanation.innerHTML = 'Step 1: Calculating hash values for pattern and first window...';
            
            let patternHash = 0;
            let textHash = 0;
            let h = 1;
            
            // Calculate h = base^(m-1) % prime
            for (let i = 0; i < m - 1; i++) {
                h = (h * base) % prime;
            }
            
            // Calculate initial hash values
            for (let i = 0; i < m; i++) {
                patternHash = (base * patternHash + text.charCodeAt(i)) % prime;
                textHash = (base * textHash + text.charCodeAt(i)) % prime;
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Pattern hash = ${patternHash}, First window hash = ${textHash}
                </div>
            `;
            
            // Highlight first window in text
            updateTextDisplay(textDisplay, text, 0, m, 'pattern-current');
            
            step++;
            setTimeout(executeStep, 2000);
            
        } else if (step <= n - m + 1) {
            const i = step - 1;
            
            explanation.innerHTML = `Step ${step + 1}: Checking window starting at index ${i}...`;
            
            // Calculate hash values for current window
            let patternHash = 0;
            let textHash = 0;
            let h = 1;
            
            for (let j = 0; j < m - 1; j++) {
                h = (h * base) % prime;
            }
            
            for (let j = 0; j < m; j++) {
                patternHash = (base * patternHash + pattern.charCodeAt(j)) % prime;
                textHash = (base * textHash + text.charCodeAt(i + j)) % prime;
            }
            
            // Highlight current window
            updateTextDisplay(textDisplay, text, i, m, 'pattern-current');
            
            if (patternHash === textHash) {
                // Hash match - check character by character
                let match = true;
                for (let j = 0; j < m; j++) {
                    if (text[i + j] !== pattern[j]) {
                        match = false;
                        break;
                    }
                }
                
                if (match) {
                    // Pattern found!
                    result.push(i);
                    updateTextDisplay(textDisplay, text, i, m, 'pattern-match');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step + 1}:</strong> Hash match confirmed! Pattern found at index ${i}
                        </div>
                    `;
                    
                    resultsDisplay.textContent = JSON.stringify(result);
                } else {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step + 1}:</strong> Hash collision - characters don't match
                        </div>
                    `;
                }
            } else {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step + 1}:</strong> Hash mismatch - moving to next window
                    </div>
                `;
            }
            
            step++;
            if (step <= n - m + 1) {
                setTimeout(executeStep, 1500);
            } else {
                executeStep(); // Final step
            }
            
        } else {
            // Algorithm completed
            explanation.innerHTML = `<strong>Rabin-Karp Algorithm Completed!</strong> Found ${result.length} occurrence(s)`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Pattern found at indices: [${result.join(', ')}]
                </div>
            `;
            
            // Highlight all matches
            result.forEach((index, idx) => {
                setTimeout(() => {
                    updateTextDisplay(textDisplay, text, index, m, 'pattern-match');
                }, idx * 300);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                resetAfterPatternSearch();
            }, 10000);
            
            continueButton.addEventListener('click', resetAfterPatternSearch);
        }
    }
    
    // Start execution
    executeStep();
}

// Z-Algorithm Visualization
function showZAlgorithmVisualization(text, pattern) {
    isPatternSearchRunning = true;
    
    const container = document.createElement('div');
    container.className = 'pattern-search-container';
    container.innerHTML = `
        <h5 class="text-center mb-3">Z-Algorithm Visualization</h5>
        
        <div class="mb-3">
            <strong>Text:</strong>
            <div class="string-display" id="zTextDisplay">${text}</div>
        </div>
        
        <div class="mb-3">
            <strong>Pattern:</strong>
            <div class="string-display" id="zPatternDisplay">${pattern}</div>
        </div>
        
        <div class="mb-3">
            <strong>Combined String:</strong>
            <div class="string-display" id="zCombinedDisplay">${pattern}$${text}</div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Z-Algorithm:</strong> Uses Z-array to find pattern occurrences</p>
            <p class="mb-0" id="zExplanation">Initializing Z-algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="zStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="zSteps"></div>
        </div>
        
        <div class="z-array-display" id="zArrayDisplay">
            <strong>Z-Array:</strong> Computing...
        </div>
        
        <div class="stats-card mt-3">
            <div>Found Indices</div>
            <div class="stats-value" id="zResults">[]</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="zContinueBtn">
            <i class="fas fa-undo me-1"></i>Return to Original Array (Auto in 10s)
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(container);
    
    executeZAlgorithm(text, pattern);
}

// Execute Z-Algorithm
function executeZAlgorithm(text, pattern) {
    const textDisplay = document.getElementById('zTextDisplay');
    const patternDisplay = document.getElementById('zPatternDisplay');
    const combinedDisplay = document.getElementById('zCombinedDisplay');
    const explanation = document.getElementById('zExplanation');
    const stepsContainer = document.getElementById('zSteps');
    const zArrayDisplay = document.getElementById('zArrayDisplay');
    const resultsDisplay = document.getElementById('zResults');
    const continueButton = document.getElementById('zContinueBtn');
    
    const combined = pattern + '$' + text;
    const n = combined.length;
    const m = pattern.length;
    const z = new Array(n).fill(0);
    const result = [];
    let step = 0;
    let l = 0, r = 0;
    
    function executeStep(i) {
        if (i >= n) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Z-Algorithm Completed!</strong> Found ${result.length} occurrence(s)`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Pattern found at indices: [${result.join(', ')}]
                </div>
            `;
            
            // Display final Z-array
            zArrayDisplay.innerHTML = `<strong>Z-Array:</strong> [${z.join(', ')}]`;
            
            // Highlight all matches in text
            result.forEach((index, idx) => {
                setTimeout(() => {
                    updateTextDisplay(textDisplay, text, index, m, 'pattern-match');
                }, idx * 300);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                resetAfterPatternSearch();
            }, 10000);
            
            continueButton.addEventListener('click', resetAfterPatternSearch);
            
            return;
        }
        
        step++;
        
        if (i === 0) {
            // First element (always length of string)
            z[0] = n;
            explanation.innerHTML = 'Step 1: Initializing Z-array...';
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step 1:</strong> z[0] = ${z[0]} (length of combined string)
                </div>
            `;
            updateZArrayDisplay(zArrayDisplay, z, i);
            setTimeout(() => executeStep(1), 1500);
            
        } else {
            explanation.innerHTML = `Step ${step}: Computing z[${i}]...`;
            
            if (i <= r) {
                // Inside Z-box
                z[i] = Math.min(r - i + 1, z[i - l]);
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step}:</strong> Inside Z-box [${l}, ${r}], z[${i}] = min(${r - i + 1}, ${z[i - l]}) = ${z[i]}
                    </div>
                `;
            }
            
            // Extend the Z-box
            updateCombinedDisplay(combinedDisplay, combined, i, z[i], l, r);
            
            let extendSteps = 0;
            function extendZBox() {
                if (i + z[i] < n && combined[z[i]] === combined[i + z[i]]) {
                    z[i]++;
                    extendSteps++;
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step}.${extendSteps}:</strong> Extending z[${i}] = ${z[i]}
                        </div>
                    `;
                    updateCombinedDisplay(combinedDisplay, combined, i, z[i], l, r);
                    setTimeout(extendZBox, 800);
                } else {
                    // Update Z-box if needed
                    if (i + z[i] - 1 > r) {
                        l = i;
                        r = i + z[i] - 1;
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Step ${step}.${extendSteps + 1}:</strong> Updated Z-box to [${l}, ${r}]
                            </div>
                        `;
                    }
                    
                    // Check if this is a pattern match
                    if (z[i] === m && i > m) {
                        const textIndex = i - m - 1;
                        result.push(textIndex);
                        resultsDisplay.textContent = JSON.stringify(result);
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Match Found:</strong> Pattern at text index ${textIndex}
                            </div>
                        `;
                    }
                    
                    updateZArrayDisplay(zArrayDisplay, z, i);
                    setTimeout(() => executeStep(i + 1), 1000);
                }
            }
            
            extendZBox();
        }
    }
    
    // Start execution
    executeStep(0);
}

// Helper Functions
function updateTextDisplay(displayElement, text, start, length, className) {
    let html = '';
    for (let i = 0; i < text.length; i++) {
        if (i >= start && i < start + length) {
            html += `<span class="${className}">${text[i]}</span>`;
        } else {
            html += text[i];
        }
    }
    displayElement.innerHTML = html;
}

function updateCombinedDisplay(displayElement, combined, currentIndex, zValue, l, r) {
    let html = '';
    for (let i = 0; i < combined.length; i++) {
        if (i === currentIndex) {
            html += `<span class="pattern-current">${combined[i]}</span>`;
        } else if (i >= l && i <= r) {
            html += `<span class="z-box">${combined[i]}</span>`;
        } else if (i >= currentIndex && i < currentIndex + zValue) {
            html += `<span class="pattern-match">${combined[i]}</span>`;
        } else {
            html += combined[i];
        }
    }
    displayElement.innerHTML = html;
}

function updateZArrayDisplay(displayElement, zArray, currentIndex) {
    let html = '<strong>Z-Array:</strong> [';
    for (let i = 0; i < zArray.length; i++) {
        if (i === currentIndex) {
            html += `<span class="pattern-current">${zArray[i]}</span>`;
        } else if (zArray[i] > 0) {
            html += `<span class="pattern-match">${zArray[i]}</span>`;
        } else {
            html += zArray[i];
        }
        if (i < zArray.length - 1) html += ', ';
    }
    html += ']';
    displayElement.innerHTML = html;
}

function resetAfterPatternSearch() {
    // Reset to original array
    myArray = [...originalArrayBeforePatternSearch];
    originalArrayBeforePatternSearch = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isPatternSearchRunning = false;
    currentPatternAlgorithm = null;
    
    // Clear inputs
    searchTextInput.value = '';
    searchPatternInput.value = '';
    
    logOperation('Pattern search completed - returned to original array', 'info');
    showNotification('Returned to original array after pattern search', 'success');
}
// NEW: Word Abbreviation Validation Handler
function handleWordAbbrValidation() {
    const word = wordInput.value.trim();
    const abbr = abbrInput.value.trim();
    
    // Validation
    if (word === '') {
        showNotification('Please enter a word', 'danger');
        wordInput.focus();
        return;
    }
    
    if (abbr === '') {
        showNotification('Please enter an abbreviation', 'danger');
        abbrInput.focus();
        return;
    }
    
    // Validate abbreviation format (alphanumeric only)
    const alphanumericRegex = /^[a-zA-Z0-9]+$/;
    if (!alphanumericRegex.test(abbr)) {
        showNotification('Abbreviation must be alphanumeric only (e.g., w3b4j9)', 'danger');
        abbrInput.focus();
        return;
    }
    
    if (isWordAbbrValidationRunning) {
        showNotification('Word abbreviation validation is already in progress', 'warning');
        return;
    }
    
    isWordAbbrValidationRunning = true;
    originalWord = word;
    originalAbbr = abbr;
    
    // Show validation visualization
    showWordAbbrValidationVisualization(word, abbr);
}
// NEW: Show Word Abbreviation Validation Visualization
function showWordAbbrValidationVisualization(word, abbr) {
    const validationContainer = document.createElement('div');
    validationContainer.className = 'word-abbr-container';
    validationContainer.innerHTML = `
        <h5 class="text-center mb-4">Word Abbreviation Validation</h5>
        
        <div class="array-group">
            <div class="array-label">Word: "${word}"</div>
            <div class="word-display" id="wordDisplay"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Abbreviation: "${abbr}"</div>
            <div class="abbr-display" id="abbrDisplay"></div>
        </div>
        
        <div class="abbr-validation-explanation">
            <p class="mb-2"><strong>Validation Algorithm:</strong> Matching abbreviation with word using two pointers</p>
            <p class="mb-0" id="abbrExplanation">Starting validation process...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="abbrStepsContainer">
            <h6 class="text-center">Validation Steps</h6>
            <div class="steps-container" id="abbrSteps"></div>
        </div>
        
        <div class="validation-result" id="validationResult" style="display: none;"></div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterValidation" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Array Operations
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(validationContainer);
    
    renderWordAndAbbr(word, abbr);
    performWordAbbrValidation(word, abbr);
}
// NEW: Render Word and Abbreviation
function renderWordAndAbbr(word, abbr) {
    const wordDisplay = document.getElementById('wordDisplay');
    const abbrDisplay = document.getElementById('abbrDisplay');
    
    // Clear previous content
    wordDisplay.innerHTML = '';
    abbrDisplay.innerHTML = '';
    
    // Render word characters
    for (let i = 0; i < word.length; i++) {
        const charElement = document.createElement('div');
        charElement.className = 'char-element';
        charElement.textContent = word[i];
        charElement.setAttribute('data-index', i);
        wordDisplay.appendChild(charElement);
    }
    
    // Render abbreviation characters
    for (let i = 0; i < abbr.length; i++) {
        const charElement = document.createElement('div');
        charElement.className = 'char-element';
        charElement.textContent = abbr[i];
        if (abbr[i].match(/\d/)) {
            charElement.classList.add('number');
        }
        charElement.setAttribute('data-index', i);
        abbrDisplay.appendChild(charElement);
    }
}

// NEW: Perform Word Abbreviation Validation with Animation
function performWordAbbrValidation(word, abbr) {
    const wordDisplay = document.getElementById('wordDisplay');
    const abbrDisplay = document.getElementById('abbrDisplay');
    const explanation = document.getElementById('abbrExplanation');
    const stepsContainer = document.getElementById('abbrSteps');
    const validationResult = document.getElementById('validationResult');
    const continueButton = document.getElementById('continueAfterValidation');
    
    let i = 0; // pointer for word
    let j = 0; // pointer for abbr
    let step = 0;
    let isValid = true;
    
    function performValidationStep() {
        if (i >= word.length || j >= abbr.length) {
            // Validation completed
            const finalResult = (i === word.length && j === abbr.length);
            
            if (finalResult) {
                explanation.innerHTML = '<strong>Validation Successful!</strong> Both pointers reached the end simultaneously.';
                validationResult.innerHTML = `
                    <div class="validation-success">
                        <i class="fas fa-check-circle me-2"></i>
                        VALID: "${abbr}" is a valid abbreviation of "${word}"
                    </div>
                `;
                logOperation(`Word abbreviation validation: "${abbr}" is VALID for "${word}"`, 'success');
            } else {
                explanation.innerHTML = '<strong>Validation Failed!</strong> Pointers did not reach the end together.';
                validationResult.innerHTML = `
                    <div class="validation-error">
                        <i class="fas fa-times-circle me-2"></i>
                        INVALID: "${abbr}" is NOT a valid abbreviation of "${word}"
                    </div>
                `;
                logOperation(`Word abbreviation validation: "${abbr}" is INVALID for "${word}"`, 'danger');
            }
            
            validationResult.style.display = 'block';
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToArrayAfterValidation();
            }, 10000);
            
            continueButton.addEventListener('click', returnToArrayAfterValidation);
            
            return;
        }
        
        step++;
        const wordChar = wordDisplay.querySelector(`[data-index="${i}"]`);
        const abbrChar = abbrDisplay.querySelector(`[data-index="${j}"]`);
        
        // Highlight current characters
        if (wordChar) wordChar.classList.add('current');
        if (abbrChar) abbrChar.classList.add('current');
        
        if (abbr[j].match(/[a-zA-Z]/)) {
            // It's a letter - must match exactly
            explanation.innerHTML = `Step ${step}: Comparing letter '${word[i]}' with abbreviation letter '${abbr[j]}'`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${word[i] === abbr[j] ? '' : 'active'}">
                    <strong>Step ${step}:</strong> Letter comparison - Word[${i}]='${word[i]}' vs Abbr[${j}]='${abbr[j]}' - 
                    ${word[i] === abbr[j] ? 'MATCH' : 'MISMATCH'}
                </div>
            `;
            
            setTimeout(() => {
                if (word[i] === abbr[j]) {
                    // Match found
                    if (wordChar) wordChar.classList.remove('current');
                    if (abbrChar) abbrChar.classList.remove('current');
                    if (wordChar) wordChar.classList.add('matched');
                    if (abbrChar) abbrChar.classList.add('matched');
                    
                    i++;
                    j++;
                    performValidationStep();
                } else {
                    // Mismatch - validation failed
                    if (wordChar) wordChar.classList.remove('current');
                    if (abbrChar) abbrChar.classList.remove('current');
                    if (wordChar) wordChar.classList.add('error');
                    if (abbrChar) abbrChar.classList.add('error');
                    
                    explanation.innerHTML = `<strong>Validation Failed!</strong> Letter mismatch at position ${i}`;
                    validationResult.innerHTML = `
                        <div class="validation-error">
                            <i class="fas fa-times-circle me-2"></i>
                            INVALID: Letter '${word[i]}'  '${abbr[j]}' at position ${i}
                        </div>
                    `;
                    validationResult.style.display = 'block';
                    continueButton.style.display = 'block';
                    
                    logOperation(`Word abbreviation validation failed: letter mismatch '${word[i]}'  '${abbr[j]}'`, 'danger');
                    
                    setTimeout(() => {
                        returnToArrayAfterValidation();
                    }, 10000);
                    
                    continueButton.addEventListener('click', returnToArrayAfterValidation);
                }
            }, 1500);
            
        } else {
            // It's a number - skip that many characters
            if (abbr[j] === '0') {
                // Leading zero not allowed
                explanation.innerHTML = `<strong>Validation Failed!</strong> Leading zero not allowed in abbreviation`;
                validationResult.innerHTML = `
                    <div class="validation-error">
                        <i class="fas fa-times-circle me-2"></i>
                        INVALID: Leading zero not allowed in abbreviation
                    </div>
                `;
                validationResult.style.display = 'block';
                continueButton.style.display = 'block';
                
                logOperation(`Word abbreviation validation failed: leading zero not allowed`, 'danger');
                
                setTimeout(() => {
                    returnToArrayAfterValidation();
                }, 10000);
                
                continueButton.addEventListener('click', returnToArrayAfterValidation);
                return;
            }
            
            // Parse the number
            let numStr = '';
            let k = j;
            while (k < abbr.length && abbr[k].match(/\d/)) {
                numStr += abbr[k];
                k++;
            }
            
            const num = parseInt(numStr);
            explanation.innerHTML = `Step ${step}: Found number ${num} - skipping ${num} characters in word`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Number ${num} found - skipping ${num} characters in word
                </div>
            `;
            
            // Highlight the number in abbreviation and characters to skip in word
            setTimeout(() => {
                // Highlight the number part in abbreviation
                for (let m = j; m < k; m++) {
                    const numChar = abbrDisplay.querySelector(`[data-index="${m}"]`);
                    if (numChar) numChar.classList.add('current');
                }
                
                // Highlight characters to skip in word
                for (let m = i; m < i + num && m < word.length; m++) {
                    const skipChar = wordDisplay.querySelector(`[data-index="${m}"]`);
                    if (skipChar) {
                        setTimeout(() => {
                            skipChar.classList.add('skipped');
                        }, (m - i) * 200);
                    }
                }
                
                setTimeout(() => {
                    // Remove highlights and update pointers
                    for (let m = j; m < k; m++) {
                        const numChar = abbrDisplay.querySelector(`[data-index="${m}"]`);
                        if (numChar) numChar.classList.remove('current');
                    }
                    
                    i += num;
                    j = k;
                    performValidationStep();
                }, num * 200 + 500);
            }, 1500);
        }
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
    }
    
    // Start validation process
    performValidationStep();
}

// NEW: Return to Array after Validation
function returnToArrayAfterValidation() {
    // Clear inputs
    wordInput.value = '';
    abbrInput.value = '';
    
    // Remove validation visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isWordAbbrValidationRunning = false;
    
    showNotification('Returned to array operations', 'success');
}
// NEW: Shortest Word Distance Handler
function handleShortestWordDistance() {
    if (isShortestWordDistanceRunning) {
        showNotification('Shortest Word Distance operation is already in progress', 'warning');
        return;
    }

    // Reset arrays
    wordDistanceArray = [];
    word1Positions = [];
    word2Positions = [];
    
    // Show input group
    shortestWordDistanceGroup.style.display = 'block';
    wordArraySize.focus();
    
    // Hide search inputs initially
    wordSearchInputs.style.display = 'none';
    
    logOperation('Started Shortest Word Distance operation', 'info');
}

// NEW: Confirm Word Array Size Handler
function handleConfirmWordArraySize() {
    const size = parseInt(wordArraySize.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        wordArraySize.focus();
        return;
    }
    
    // Create input fields for word array
    wordArrayInputs.innerHTML = '<label class="form-label">Enter words for the array:</label>';
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Word ${i}</span>
            <input type="text" class="form-control word-array-element" 
                   placeholder="Enter word" data-index="${i}">
        `;
        wordArrayInputs.appendChild(inputGroup);
    }
    
    // Add event listeners for word array inputs
    const wordArrayElements = wordArrayInputs.querySelectorAll('.word-array-element');
    wordArrayElements.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('word-array-element')) {
                    nextInput.focus();
                } else {
                    word1Input.focus();
                }
            }
        });
    });
    
    // Show search inputs
    wordSearchInputs.style.display = 'block';
    
    showNotification(`Word array size set to ${size}. Please enter ${size} words.`, 'success');
    logOperation(`Word array size set to ${size}`, 'info');
}

// NEW: Find Shortest Distance Handler
function handleFindShortestDistance() {
    // Collect word array elements
    const wordArrayInputs = document.querySelectorAll('.word-array-element');
    wordDistanceArray = [];
    
    for (let i = 0; i < wordArrayInputs.length; i++) {
        const value = wordArrayInputs[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all words for the array. Missing word at position ${i}`, 'danger');
            wordArrayInputs[i].focus();
            return;
        }
        wordDistanceArray.push(value);
    }
    
    const word1 = word1Input.value.trim();
    const word2 = word2Input.value.trim();
    
    if (word1 === '') {
        showNotification('Please enter word 1', 'danger');
        word1Input.focus();
        return;
    }
    
    if (word2 === '') {
        showNotification('Please enter word 2', 'danger');
        word2Input.focus();
        return;
    }
    
    // Check if both words exist in the array
    if (!wordDistanceArray.includes(word1)) {
        showNotification(`Word "${word1}" not found in the array`, 'danger');
        word1Input.focus();
        return;
    }
    
    if (!wordDistanceArray.includes(word2)) {
        showNotification(`Word "${word2}" not found in the array`, 'danger');
        word2Input.focus();
        return;
    }
    
    // Store original array
    originalArrayForWordDistance = [...myArray];
    
    // Hide input group
    shortestWordDistanceGroup.style.display = 'none';
    
    // Start shortest word distance visualization
    showShortestWordDistanceVisualization(word1, word2);
}

// NEW: Cancel Shortest Word Distance Handler
function handleCancelShortestWordDistance() {
    shortestWordDistanceGroup.style.display = 'none';
    wordArraySize.value = '';
    wordArrayInputs.innerHTML = '';
    word1Input.value = '';
    word2Input.value = '';
    wordSearchInputs.style.display = 'none';
    
    wordDistanceArray = [];
    word1Positions = [];
    word2Positions = [];
    
    logOperation('Cancelled Shortest Word Distance operation', 'info');
    showNotification('Shortest Word Distance operation cancelled', 'info');
}

// NEW: Show Shortest Word Distance Visualization
function showShortestWordDistanceVisualization(word1, word2) {
    isShortestWordDistanceRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Shortest Word Distance: "${word1}" vs "${word2}"</h5>
        
        <div class="array-group">
            <div class="array-label">Word Array</div>
            <div class="original-array-container" id="wordDistanceArray"></div>
        </div>
        
        <div class="word-distance-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find shortest distance between "${word1}" and "${word2}"</p>
            <p class="mb-0" id="wordDistanceExplanation">Initializing shortest word distance algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="wordDistanceStepsContainer">
            <h6 class="text-center">Shortest Word Distance Steps</h6>
            <div class="steps-container" id="wordDistanceSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Shortest Distance Found</div>
            <div class="stats-value" id="shortestDistanceValue">-</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Positions</div>
            <div class="stats-value" id="wordPositionsValue">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterWordDistance" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display the word array
    renderArrayInContainer(wordDistanceArray, 'wordDistanceArray');
    
    // Start word distance algorithm
    performShortestWordDistanceAlgorithm(word1, word2);
}

// NEW: Perform Shortest Word Distance Algorithm
function performShortestWordDistanceAlgorithm(word1, word2) {
    const arrayContainer = document.getElementById('wordDistanceArray');
    const explanation = document.getElementById('wordDistanceExplanation');
    const stepsContainer = document.getElementById('wordDistanceSteps');
    const shortestDistanceValue = document.getElementById('shortestDistanceValue');
    const wordPositionsValue = document.getElementById('wordPositionsValue');
    const continueButton = document.getElementById('continueAfterWordDistance');
    
    // Find all positions of word1 and word2
    word1Positions = [];
    word2Positions = [];
    
    for (let i = 0; i < wordDistanceArray.length; i++) {
        if (wordDistanceArray[i] === word1) {
            word1Positions.push(i);
        }
        if (wordDistanceArray[i] === word2) {
            word2Positions.push(i);
        }
    }
    
    let i = 0, j = 0;
    let minDistance = Infinity;
    let bestI = -1, bestJ = -1;
    let step = 0;
    
    function performWordDistanceStep() {
        if (i >= word1Positions.length || j >= word2Positions.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Shortest distance found: ${minDistance}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Shortest distance between "${word1}" and "${word2}" = ${minDistance}
                </div>
            `;
            
            // Highlight the final shortest distance
            if (bestI !== -1 && bestJ !== -1) {
                const elements = arrayContainer.querySelectorAll('.array-element');
                
                // Highlight the best positions
                elements[word1Positions[bestI]].querySelector('.element-value').classList.add('shortest-distance-highlight');
                elements[word2Positions[bestJ]].querySelector('.element-value').classList.add('shortest-distance-highlight');
                
                // Draw distance line
                drawDistanceLine(arrayContainer, word1Positions[bestI], word2Positions[bestJ]);
            }
            
            shortestDistanceValue.textContent = minDistance;
            wordPositionsValue.textContent = `"${word1}" at ${word1Positions[bestI]}, "${word2}" at ${word2Positions[bestJ]}`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterWordDistance();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterWordDistance);
            
            return;
        }
        
        step++;
        const pos1 = word1Positions[i];
        const pos2 = word2Positions[j];
        const currentDistance = Math.abs(pos1 - pos2);
        
        explanation.innerHTML = `Step ${step}: Comparing "${word1}" at ${pos1} and "${word2}" at ${pos2}, Distance = ${currentDistance}`;
        
        // Highlight current positions
        const elements = arrayContainer.querySelectorAll('.array-element');
        elements[pos1].querySelector('.element-value').classList.add('word1-highlight');
        elements[pos2].querySelector('.element-value').classList.add('word2-highlight');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${currentDistance < minDistance ? 'active' : ''}">
                <strong>Step ${step}:</strong> Compare "${word1}"[${pos1}] and "${word2}"[${pos2}] - Distance = ${currentDistance}
                ${currentDistance < minDistance ? ' - NEW MINIMUM!' : ''}
            </div>
        `;
        
        setTimeout(() => {
            // Update minimum distance if needed
            if (currentDistance < minDistance) {
                minDistance = currentDistance;
                bestI = i;
                bestJ = j;
                
                // Remove previous highlights and add new minimum highlights
                elements[pos1].querySelector('.element-value').classList.remove('word1-highlight');
                elements[pos2].querySelector('.element-value').classList.remove('word2-highlight');
                elements[pos1].querySelector('.element-value').classList.add('shortest-distance-highlight');
                elements[pos2].querySelector('.element-value').classList.add('shortest-distance-highlight');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Update:</strong> New minimum distance found! ${minDistance}
                    </div>
                `;
            } else {
                // Remove temporary highlights
                elements[pos1].querySelector('.element-value').classList.remove('word1-highlight');
                elements[pos2].querySelector('.element-value').classList.remove('word2-highlight');
            }
            
            // Move pointers based on positions
            if (word1Positions[i] < word2Positions[j]) {
                i++;
            } else {
                j++;
            }
            
            // Continue algorithm
            performWordDistanceStep();
        }, 2000);
    }
    
    // Start algorithm
    performWordDistanceStep();
}

// NEW: Draw Distance Line between positions
function drawDistanceLine(container, pos1, pos2) {
    const elements = container.querySelectorAll('.array-element');
    const element1 = elements[pos1];
    const element2 = elements[pos2];
    
    const rect1 = element1.getBoundingClientRect();
    const rect2 = element2.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    
    // Calculate line coordinates
    const x1 = rect1.left + rect1.width / 2 - containerRect.left;
    const y1 = rect1.top + rect1.height - containerRect.top;
    const x2 = rect2.left + rect2.width / 2 - containerRect.left;
    const y2 = rect2.top + rect2.height - containerRect.top;
    
    // Create line element
    const line = document.createElement('div');
    line.className = 'distance-line';
    line.style.left = `${Math.min(x1, x2)}px`;
    line.style.top = `${Math.max(y1, y2) + 10}px`;
    line.style.width = `${Math.abs(x2 - x1)}px`;
    
    container.appendChild(line);
    
    // Add distance text
    const distanceText = document.createElement('div');
    distanceText.className = 'distance-pointer';
    distanceText.textContent = `${Math.abs(pos1 - pos2)}`;
    distanceText.style.left = `${(x1 + x2) / 2 - 10}px`;
    distanceText.style.top = `${Math.max(y1, y2) + 25}px`;
    
    container.appendChild(distanceText);
}

// NEW: Return to Original after Word Distance
function returnToOriginalAfterWordDistance() {
    // Reset to original array
    myArray = [...originalArrayForWordDistance];
    originalArrayForWordDistance = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isShortestWordDistanceRunning = false;
    
    // Clear all word distance data
    wordDistanceArray = [];
    word1Positions = [];
    word2Positions = [];
    
    // Reset input groups
    shortestWordDistanceGroup.style.display = 'none';
    wordArraySize.value = '';
    wordArrayInputs.innerHTML = '';
    word1Input.value = '';
    word2Input.value = '';
    wordSearchInputs.style.display = 'none';
    
    logOperation('Shortest Word Distance completed - returned to original array', 'info');
    showNotification('Returned to original array after Shortest Word Distance operation', 'success');
}
// Helper function to render array in specific container
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = `
            <div class="array-empty-state">
                <i class="fas fa-layer-group"></i>
                <h4>Array is Empty</h4>
                <p>Add some elements to get started!</p>
            </div>
        `;
        return;
    }
    
    array.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element slide-in';
        arrayElement.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}

// NEW: Group Shifted Strings Handler
function handleGroupShiftedStrings() {
    if (isGroupShiftedStringsRunning) {
        showNotification('Group Shifted Strings operation is already in progress', 'warning');
        return;
    }

    // Reset arrays
    shiftedStringsArray = [];
    
    // Show input group
    groupShiftedStringsGroup.style.display = 'block';
    shiftedStringsSize.focus();
    
    // Hide perform button initially
    performGroupShiftedStringsBtn.style.display = 'none';
    
    logOperation('Started Group Shifted Strings operation', 'info');
}

// NEW: Confirm Shifted Strings Size Handler
function handleConfirmShiftedStringsSize() {
    const size = parseInt(shiftedStringsSize.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        shiftedStringsSize.focus();
        return;
    }
    
    shiftedStringsArray = [];
    
    // Create input fields for strings
    shiftedStringsInputs.innerHTML = '<label class="form-label">Enter strings:</label>';
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">String ${i + 1}</span>
            <input type="text" class="form-control shifted-string-element" 
                   placeholder="Enter string" data-index="${i}">
        `;
        shiftedStringsInputs.appendChild(inputGroup);
    }
    
    // Add event listeners for string inputs
    const stringElements = shiftedStringsInputs.querySelectorAll('.shifted-string-element');
    stringElements.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('shifted-string-element')) {
                    nextInput.focus();
                }
            }
        });
    });
    
    // Show perform button
    performGroupShiftedStringsBtn.style.display = 'block';
    
    showNotification(`Array size set to ${size}. Please enter ${size} strings.`, 'success');
    logOperation(`Shifted strings array size set to ${size}`, 'info');
}

// NEW: Perform Group Shifted Strings Handler
function handlePerformGroupShiftedStrings() {
    // Collect string elements
    const stringInputs = document.querySelectorAll('.shifted-string-element');
    shiftedStringsArray = [];
    
    for (let i = 0; i < stringInputs.length; i++) {
        const value = stringInputs[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all strings. Missing string at position ${i + 1}`, 'danger');
            stringInputs[i].focus();
            return;
        }
        shiftedStringsArray.push(value);
    }
    
    // Store original array with unique name
    originalArrayForStringAlgorithms = [...myArray];
    
    // Hide input group
    groupShiftedStringsGroup.style.display = 'none';
    
    // Start group shifted strings visualization
    showGroupShiftedStringsVisualization();
}

// NEW: Cancel Group Shifted Strings Handler
function handleCancelGroupShiftedStrings() {
    groupShiftedStringsGroup.style.display = 'none';
    shiftedStringsSize.value = '';
    shiftedStringsInputs.innerHTML = '';
    performGroupShiftedStringsBtn.style.display = 'none';
    
    shiftedStringsArray = [];
    
    logOperation('Cancelled Group Shifted Strings operation', 'info');
    showNotification('Group Shifted Strings operation cancelled', 'info');
}

// NEW: Flip Game Handler
function handleFlipGame() {
    if (isFlipGameRunning) {
        showNotification('Flip Game operation is already in progress', 'warning');
        return;
    }

    // Show input group
    flipGameGroup.style.display = 'block';
    flipGameInput.focus();
    
    logOperation('Started Flip Game operation', 'info');
}

// NEW: Perform Flip Game Handler
function handlePerformFlipGame() {
    const inputString = flipGameInput.value.trim();
    
    if (inputString === '') {
        showNotification('Please enter a string', 'danger');
        flipGameInput.focus();
        return;
    }
    
    // Validate input - only + and - allowed
    if (!/^[+-]+$/.test(inputString)) {
        showNotification('Please enter a string containing only + and - characters', 'danger');
        flipGameInput.focus();
        return;
    }
    
    // Store original array with unique name
    originalArrayForStringAlgorithms = [...myArray];
    
    // Hide input group
    flipGameGroup.style.display = 'none';
    
    // Start flip game visualization
    showFlipGameVisualization(inputString);
}

// NEW: Cancel Flip Game Handler
function handleCancelFlipGame() {
    flipGameGroup.style.display = 'none';
    flipGameInput.value = '';
    
    logOperation('Cancelled Flip Game operation', 'info');
    showNotification('Flip Game operation cancelled', 'info');
}

// NEW: Show Group Shifted Strings Visualization
function showGroupShiftedStringsVisualization() {
    isGroupShiftedStringsRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Group Shifted Strings Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Input Strings</div>
            <div class="original-array-container" id="inputStringsDisplay"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Grouped Strings</div>
            <div class="transformed-array-container" id="groupedStringsDisplay"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Group strings that are shifted versions of each other</p>
            <p class="mb-0" id="groupShiftedExplanation">Starting Group Shifted Strings algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="groupShiftedStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="groupShiftedSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterGroupShifted" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display input strings
    renderStringArrayInContainer(shiftedStringsArray, 'inputStringsDisplay');
    renderStringArrayInContainer([], 'groupedStringsDisplay');
    
    // Start algorithm animation
    performGroupShiftedStringsAnimation();
}

// NEW: Perform Group Shifted Strings Animation
function performGroupShiftedStringsAnimation() {
    const inputContainer = document.getElementById('inputStringsDisplay');
    const groupedContainer = document.getElementById('groupedStringsDisplay');
    const explanation = document.getElementById('groupShiftedExplanation');
    const stepsContainer = document.getElementById('groupShiftedSteps');
    const continueButton = document.getElementById('continueAfterGroupShifted');
    
    const strings = [...shiftedStringsArray];
    const groups = {};
    let currentStringIndex = 0;
    let step = 0;
    
    function performGroupStep() {
        if (currentStringIndex >= strings.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Found ${Object.keys(groups).length} groups.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Grouping completed! Total groups: ${Object.keys(groups).length}
                </div>
            `;
            
            // Display final grouped strings
            const finalGroups = Object.values(groups);
            renderGroupedStringsInContainer(finalGroups, 'groupedStringsDisplay');
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterStringAlgorithm();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterStringAlgorithm);
            
            return;
        }
        
        const currentString = strings[currentStringIndex];
        step++;
        
        explanation.innerHTML = `Step ${step}: Processing string "${currentString}"`;
        
        // Highlight current string
        const inputElements = inputContainer.querySelectorAll('.array-element');
        const currentElement = inputElements[currentStringIndex].querySelector('.element-value');
        currentElement.classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> Processing string "${currentString}"
            </div>
        `;
        
        setTimeout(() => {
            // Calculate key for current string
            const key = [];
            for (let i = 0; i < currentString.length; i++) {
                const diff = (currentString.charCodeAt(i) - currentString.charCodeAt(0) + 26) % 26;
                key.push(diff.toString());
            }
            const keyTuple = key.join(',');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Key Calculation:</strong> Differences: [${key.join(', ')}]
                </div>
            `;
            
            explanation.innerHTML = `Step ${step}: Key for "${currentString}" is [${key.join(', ')}]`;
            
            setTimeout(() => {
                if (!groups[keyTuple]) {
                    groups[keyTuple] = [];
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>New Group:</strong> Creating new group for key [${key.join(', ')}]
                        </div>
                    `;
                }
                
                groups[keyTuple].push(currentString);
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Group Assignment:</strong> Added "${currentString}" to group [${key.join(', ')}]
                    </div>
                `;
                
                explanation.innerHTML = `Step ${step}: Added "${currentString}" to group [${key.join(', ')}]`;
                
                // Update grouped display
                const currentGroups = Object.values(groups);
                renderGroupedStringsInContainer(currentGroups, 'groupedStringsDisplay');
                
                // Remove highlight
                currentElement.classList.remove('sorting-current');
                currentElement.classList.add('sorting-sorted');
                
                currentStringIndex++;
                performGroupStep();
            }, 1500);
        }, 1500);
    }
    
    // Start algorithm
    performGroupStep();
}

// NEW: Show Flip Game Visualization
function showFlipGameVisualization(inputString) {
    isFlipGameRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Flip Game Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Input String</div>
            <div class="original-array-container" id="inputFlipStringDisplay"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Possible Next Moves</div>
            <div class="transformed-array-container" id="flipResultsDisplay"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Generate all possible next states by flipping "++" to "--"</p>
            <p class="mb-0" id="flipGameExplanation">Starting Flip Game algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="flipGameStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="flipGameSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterFlipGame" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display input string as character array
    renderStringAsArrayInContainer(inputString, 'inputFlipStringDisplay');
    renderStringArrayInContainer([], 'flipResultsDisplay');
    
    // Start algorithm animation
    performFlipGameAnimation(inputString);
}

// NEW: Perform Flip Game Animation
function performFlipGameAnimation(inputString) {
    const inputContainer = document.getElementById('inputFlipStringDisplay');
    const resultsContainer = document.getElementById('flipResultsDisplay');
    const explanation = document.getElementById('flipGameExplanation');
    const stepsContainer = document.getElementById('flipGameSteps');
    const continueButton = document.getElementById('continueAfterFlipGame');
    
    const result = [];
    let currentIndex = 0;
    let step = 0;
    
    function performFlipStep() {
        if (currentIndex >= inputString.length - 1) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Found ${result.length} possible next moves.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Found ${result.length} possible next moves
                </div>
            `;
            
            // Display final results
            renderStringArrayInContainer(result, 'flipResultsDisplay');
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterStringAlgorithm();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterStringAlgorithm);
            
            return;
        }
        
        step++;
        
        if (inputString[currentIndex] === '+' && inputString[currentIndex + 1] === '+') {
            explanation.innerHTML = `Step ${step}: Found "++" at position ${currentIndex}`;
            
            // Highlight the current "++" pair
            const inputElements = inputContainer.querySelectorAll('.array-element');
            const firstElement = inputElements[currentIndex].querySelector('.element-value');
            const secondElement = inputElements[currentIndex + 1].querySelector('.element-value');
            
            firstElement.classList.add('sorting-current');
            secondElement.classList.add('sorting-current');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Found "++" at indices ${currentIndex} and ${currentIndex + 1}
                </div>
            `;
            
            setTimeout(() => {
                // Flip ++ to --
                const newState = inputString.substring(0, currentIndex) + '--' + inputString.substring(currentIndex + 2);
                result.push(newState);
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Flip Operation:</strong> Flipped "++" to "--"  "${newState}"
                    </div>
                `;
                
                explanation.innerHTML = `Step ${step}: Flipped to "${newState}"`;
                
                // Update results display
                renderStringArrayInContainer([...result], 'flipResultsDisplay');
                
                // Remove highlights
                firstElement.classList.remove('sorting-current');
                secondElement.classList.remove('sorting-current');
                firstElement.classList.add('sorting-sorted');
                secondElement.classList.add('sorting-sorted');
                
                currentIndex++;
                performFlipStep();
            }, 1500);
        } else {
            explanation.innerHTML = `Step ${step}: No "++" at position ${currentIndex}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}:</strong> No "++" at position ${currentIndex}, moving to next position
                </div>
            `;
            
            currentIndex++;
            setTimeout(performFlipStep, 1000);
        }
    }
    
    // Start algorithm
    performFlipStep();
}

// NEW: Helper function to render string array
function renderStringArrayInContainer(stringArray, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (stringArray.length === 0) {
        container.innerHTML = '<div class="array-empty-state"><p>No strings to display</p></div>';
        return;
    }
    
    stringArray.forEach((str, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value">${str}</div>
            <div class="element-index">${index}</div>
        `;
        container.appendChild(arrayElement);
    });
}

// NEW: Helper function to render grouped strings
function renderGroupedStringsInContainer(groups, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (groups.length === 0) {
        container.innerHTML = '<div class="array-empty-state"><p>No groups to display</p></div>';
        return;
    }
    
    let elementIndex = 0;
    groups.forEach((group, groupIndex) => {
        const groupHeader = document.createElement('div');
        groupHeader.className = 'array-label';
        groupHeader.textContent = `Group ${groupIndex + 1}`;
        container.appendChild(groupHeader);
        
        const groupContainer = document.createElement('div');
        groupContainer.className = 'original-array-container';
        groupContainer.style.marginBottom = '20px';
        
        group.forEach(str => {
            const arrayElement = document.createElement('div');
            arrayElement.className = 'array-element';
            arrayElement.innerHTML = `
                <div class="element-value">${str}</div>
                <div class="element-index">${elementIndex}</div>
            `;
            groupContainer.appendChild(arrayElement);
            elementIndex++;
        });
        
        container.appendChild(groupContainer);
    });
}

// NEW: Helper function to render string as character array
function renderStringAsArrayInContainer(str, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (!str) {
        container.innerHTML = '<div class="array-empty-state"><p>No string to display</p></div>';
        return;
    }
    
    for (let i = 0; i < str.length; i++) {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value">${str[i]}</div>
            <div class="element-index">${i}</div>
        `;
        container.appendChild(arrayElement);
    }
}

// NEW: Return to Original after String Algorithms (renamed function)
function returnToOriginalAfterStringAlgorithm() {
    // Reset to original array
    myArray = [...originalArrayForStringAlgorithms];
    originalArrayForStringAlgorithms = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset states
    isGroupShiftedStringsRunning = false;
    isFlipGameRunning = false;
    
    // Clear all inputs
    shiftedStringsSize.value = '';
    shiftedStringsInputs.innerHTML = '';
    performGroupShiftedStringsBtn.style.display = 'none';
    flipGameInput.value = '';
    
    logOperation('String algorithm completed - returned to original array', 'info');
    showNotification('Returned to original array after string algorithm', 'success');
}
// NEW: Nim Game Handler
function handleNimGame() {
    if (isNimGameRunning) {
        showNotification('A Nim Game is already in progress', 'warning');
        return;
    }

    // Reset arrays
    nimPiles = [];
    nimArraySize = 0;
    
    // Show input group
    nimGameGroup.style.display = 'block';
    nimArraySizeInput.focus();
    
    // Hide play button initially
    playNimGameBtn.style.display = 'none';
    
    logOperation('Started Nim Game setup', 'info');
}

// NEW: Confirm Nim Size Handler
function handleConfirmNimSize() {
    const size = parseInt(nimArraySizeInput.value);
    
    if (isNaN(size) || size < 1 || size > 10) {
        showNotification('Please enter a valid number of piles between 1 and 10', 'danger');
        nimArraySizeInput.focus();
        return;
    }
    
    nimArraySize = size;
    nimPiles = [];
    
    // Create input fields for pile sizes
    nimPilesInputs.innerHTML = '<label class="form-label">Enter number of stones for each pile:</label>';
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Pile ${i}</span>
            <input type="number" class="form-control nim-pile-element" 
                   placeholder="Number of stones" data-index="${i}" min="1" max="100">
        `;
        nimPilesInputs.appendChild(inputGroup);
    }
    
    // Add event listeners for pile inputs
    const pileElements = nimPilesInputs.querySelectorAll('.nim-pile-element');
    pileElements.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('nim-pile-element')) {
                    nextInput.focus();
                }
            }
        });
    });
    
    // Show play button
    playNimGameBtn.style.display = 'block';
    
    showNotification(`Number of piles set to ${size}. Please enter stone counts.`, 'success');
    logOperation(`Nim Game: ${size} piles configured`, 'info');
}

// NEW: Play Nim Game Handler
function handlePlayNimGame() {
    // Collect pile sizes
    const pileInputs = document.querySelectorAll('.nim-pile-element');
    nimPiles = [];
    
    for (let i = 0; i < pileInputs.length; i++) {
        const value = parseInt(pileInputs[i].value.trim());
        if (isNaN(value) || value < 1) {
            showNotification(`Please enter a valid number of stones for pile ${i}`, 'danger');
            pileInputs[i].focus();
            return;
        }
        nimPiles.push(value);
    }
    
    // Store original array
    originalArrayForNim = [...myArray];
    
    // Hide input group
    nimGameGroup.style.display = 'none';
    
    // Start Nim Game visualization
    showNimGameVisualization();
}

// NEW: Cancel Nim Game Handler
function handleCancelNimGame() {
    nimGameGroup.style.display = 'none';
    nimArraySizeInput.value = '';
    nimPilesInputs.innerHTML = '';
    playNimGameBtn.style.display = 'none';
    
    nimPiles = [];
    nimArraySize = 0;
    
    logOperation('Cancelled Nim Game', 'info');
    showNotification('Nim Game cancelled', 'info');
}

// NEW: Show Nim Game Visualization
function showNimGameVisualization() {
    isNimGameRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Nim Game Analysis</h5>
        
        <div class="array-group">
            <div class="array-label">Piles Configuration</div>
            <div class="original-array-container" id="nimPilesDisplay"></div>
        </div>
        
        <div class="nim-explanation">
            <p class="mb-2"><strong>Nim Game Rules:</strong> Players take turns removing stones from piles. The player who takes the last stone wins.</p>
            <p class="mb-0" id="nimExplanation">Starting Nim Game analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="nimStepsContainer">
            <h6 class="text-center">Nim Game Analysis Steps</h6>
            <div class="steps-container" id="nimSteps"></div>
        </div>
        
        <div class="nim-result" id="nimResultContainer" style="display: none;">
            <h6 class="text-center">Game Result</h6>
            <div id="nimResultContent"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterNim" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display the piles
    renderArrayInContainer(nimPiles.map(p => p.toString()), 'nimPilesDisplay');
    
    // Start Nim Game analysis
    performNimGameAnalysis();
}

// NEW: Perform Nim Game Analysis with Animation
function performNimGameAnalysis() {
    const pilesContainer = document.getElementById('nimPilesDisplay');
    const explanation = document.getElementById('nimExplanation');
    const stepsContainer = document.getElementById('nimSteps');
    const resultContainer = document.getElementById('nimResultContainer');
    const resultContent = document.getElementById('nimResultContent');
    const continueButton = document.getElementById('continueAfterNim');
    
    const piles = [...nimPiles];
    let step = 0;
    let nimSum = 0;
    let canWin = false;
    let strategy = "";
    
    function performNimStep() {
        switch (step) {
            case 0:
                // Step 1: Show initial piles
                explanation.innerHTML = 'Step 1: Initial piles configuration';
                
                // Highlight all piles
                const pileElements = pilesContainer.querySelectorAll('.array-element');
                pileElements.forEach((el, index) => {
                    setTimeout(() => {
                        el.querySelector('.element-value').classList.add('nim-pile');
                    }, index * 300);
                });
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Initial piles: [${piles.join(', ')}]
                    </div>
                `;
                break;
                
            case 1:
                // Step 2: Calculate Nim-sum (XOR of all piles)
                explanation.innerHTML = 'Step 2: Calculating Nim-sum (XOR of all pile sizes)';
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Calculating Nim-sum = ${piles.map(p => p).join('  ')}
                    </div>
                `;
                
                // Calculate Nim-sum with animation
                let currentNimSum = 0;
                const pileElementsCalc = pilesContainer.querySelectorAll('.array-element');
                
                function calculateNimSumStep(index) {
                    if (index >= piles.length) {
                        nimSum = currentNimSum;
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Nim-sum Result:</strong> ${nimSum}
                            </div>
                        `;
                        step++;
                        setTimeout(performNimStep, 1500);
                        return;
                    }
                    
                    explanation.innerHTML = `Step 2: Calculating XOR with pile ${index} (${piles[index]})`;
                    
                    // Highlight current pile
                    pileElementsCalc[index].querySelector('.element-value').classList.add('nim-current');
                    
                    setTimeout(() => {
                        currentNimSum ^= piles[index];
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Step 2.${index + 1}:</strong> Current Nim-sum after pile ${index}: ${currentNimSum}
                            </div>
                        `;
                        
                        // Remove highlight
                        pileElementsCalc[index].querySelector('.element-value').classList.remove('nim-current');
                        
                        // Continue to next pile
                        calculateNimSumStep(index + 1);
                    }, 1000);
                }
                
                calculateNimSumStep(0);
                return; // Important: return here to prevent automatic step increment
                
            case 2:
                // Step 3: Determine if winning position
                explanation.innerHTML = `Step 3: Analyzing game position (Nim-sum = ${nimSum})`;
                
                canWin = nimSum !== 0;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step ${canWin ? 'active' : ''}">
                        <strong>Step 3:</strong> Nim-sum = ${nimSum}  ${canWin ? 'Winning position' : 'Losing position'}
                    </div>
                `;
                break;
                
            case 3:
                // Step 4: Find winning move if possible
                if (canWin) {
                    explanation.innerHTML = 'Step 4: Finding winning move';
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 4:</strong> Finding a winning move...
                        </div>
                    `;
                    
                    // Find winning move with animation
                    const pileElementsMove = pilesContainer.querySelectorAll('.array-element');
                    let moveFound = false;
                    
                    function findWinningMoveStep(i) {
                        if (i >= piles.length || moveFound) {
                            if (!moveFound) {
                                strategy = "Take all stones from any non-empty pile";
                            }
                            step++;
                            setTimeout(performNimStep, 1500);
                            return;
                        }
                        
                        explanation.innerHTML = `Step 4: Checking pile ${i} (${piles[i]} stones)`;
                        
                        // Highlight current pile being checked
                        pileElementsMove[i].querySelector('.element-value').classList.add('nim-current');
                        
                        setTimeout(() => {
                            const target = nimSum ^ piles[i];
                            
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step">
                                    <strong>Step 4.${i + 1}:</strong> Checking pile ${i}: target = ${nimSum}  ${piles[i]} = ${target}
                                </div>
                            `;
                            
                            if (piles[i] >= target) {
                                const remove = piles[i] - target;
                                strategy = `Remove ${remove} stones from pile ${i} (leaving ${target})`;
                                moveFound = true;
                                
                                // Highlight the winning move
                                pileElementsMove[i].querySelector('.element-value').classList.remove('nim-current');
                                pileElementsMove[i].querySelector('.element-value').classList.add('nim-winning-move');
                                
                                stepsContainer.innerHTML += `
                                    <div class="algorithm-step active">
                                        <strong>Winning Move Found:</strong> ${strategy}
                                    </div>
                                `;
                            }
                            
                            if (!moveFound) {
                                pileElementsMove[i].querySelector('.element-value').classList.remove('nim-current');
                            }
                            
                            // Continue to next pile
                            findWinningMoveStep(i + 1);
                        }, 1500);
                    }
                    
                    findWinningMoveStep(0);
                    return; // Important: return here
                } else {
                    strategy = "No winning move - opponent plays optimally";
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step 4:</strong> ${strategy}
                        </div>
                    `;
                }
                break;
                
            case 4:
                // Final step: Show results
                explanation.innerHTML = '<strong>Nim Game Analysis Completed!</strong>';
                
                // Show result container
                resultContainer.style.display = 'block';
                if (canWin) {
                    resultContainer.className = 'nim-result nim-win';
                    resultContent.innerHTML = `
                        <p class="mb-1 text-success"><strong>Can Win: YES</strong></p>
                        <p class="mb-1"><strong>Strategy:</strong> ${strategy}</p>
                        <p class="mb-0">You have a winning strategy!</p>
                    `;
                } else {
                    resultContainer.className = 'nim-result nim-lose';
                    resultContent.innerHTML = `
                        <p class="mb-1 text-danger"><strong>Can Win: NO</strong></p>
                        <p class="mb-1"><strong>Strategy:</strong> ${strategy}</p>
                        <p class="mb-0">Opponent has winning strategy if playing optimally.</p>
                    `;
                }
                
                continueButton.style.display = 'block';
                
                // Auto-return after 10 seconds
                setTimeout(() => {
                    returnToOriginalAfterNim();
                }, 10000);
                
                continueButton.addEventListener('click', returnToOriginalAfterNim);
                return;
        }
        
        step++;
        setTimeout(performNimStep, 1500);
    }
    
    // Start Nim Game analysis
    performNimStep();
}

// NEW: Return to Original after Nim Game
function returnToOriginalAfterNim() {
    // Reset to original array
    myArray = [...originalArrayForNim];
    originalArrayForNim = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isNimGameRunning = false;
    
    // Clear all Nim Game data
    nimPiles = [];
    nimArraySize = 0;
    
    // Reset input groups
    nimGameGroup.style.display = 'none';
    nimArraySizeInput.value = '';
    nimPilesInputs.innerHTML = '';
    playNimGameBtn.style.display = 'none';
    
    logOperation('Nim Game completed - returned to original array', 'info');
    showNotification('Returned to original array after Nim Game', 'success');
}
// Helper function to render array in specific container
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = '<div class="array-empty-state"><i class="fas fa-layer-group"></i><h4>No Elements</h4></div>';
        return;
    }
    
    array.forEach((value, index) => {
        const elementDiv = document.createElement('div');
        elementDiv.className = 'array-element';
        elementDiv.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(elementDiv);
    });
}
// NEW: Can I Win Handler
function handleCanIWin() {
    const maxInt = parseInt(maxChoosableInteger.value);
    const target = parseInt(desiredTotal.value);
    
    // Validation
    if (isNaN(maxInt) || maxInt < 1 || maxInt > 20) {
        showNotification('Please enter a valid max integer between 1 and 20', 'danger');
        maxChoosableInteger.focus();
        return;
    }
    
    if (isNaN(target) || target < 0) {
        showNotification('Please enter a valid desired total ( 0)', 'danger');
        desiredTotal.focus();
        return;
    }
    
    if (isCanIWinRunning) {
        showNotification('Can I Win game is already in progress', 'warning');
        return;
    }
    
    isCanIWinRunning = true;
    
    // Store original array
    originalArrayForCanIWin = [...myArray];
    
    // Start Can I Win visualization
    showCanIWinVisualization(maxInt, target);
}

// NEW: Show Can I Win Visualization
function showCanIWinVisualization(maxInt, target) {
    const gameContainer = document.createElement('div');
    gameContainer.className = 'dual-operation-container';
    gameContainer.innerHTML = `
        <h5 class="text-center mb-3">Can I Win Game Theory</h5>
        
        <div class="array-group">
            <div class="array-label">Available Numbers (1 to ${maxInt})</div>
            <div class="original-array-container" id="availableNumbers"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-trophy"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Game State</div>
            <div class="transformed-array-container" id="gameState"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Game Rules:</strong> Players take turns picking numbers (1-${maxInt}). First to reach/exceed ${target} wins.</p>
            <p class="mb-0" id="gameExplanation">Initializing game analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="gameStepsContainer">
            <h6 class="text-center">Game Analysis Steps</h6>
            <div class="steps-container" id="gameSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Final Result</div>
            <div class="stats-value" id="gameResult">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterGame" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(gameContainer);
    
    // Create available numbers array
    const availableNumbers = Array.from({length: maxInt}, (_, i) => (i + 1).toString());
    renderArrayInContainer(availableNumbers, 'availableNumbers');
    
    // Initialize game state display - show full target as remaining
    renderGameState(maxInt, target, target, 0, 'Initial state - Player 1\'s turn');
    
    // Start game analysis
    performCanIWinAnalysis(maxInt, target);
}

// NEW: Render Game State
function renderGameState(maxInt, target, remainingTotal, usedMask, stateDescription) {
    const gameStateContainer = document.getElementById('gameState');
    
    // Ensure remainingTotal is never negative for display
    const displayRemaining = Math.max(0, remainingTotal);
    
    // Create game state visualization
    const gameStateHTML = `
        <div class="row text-center">
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Remaining to Target</div>
                    <div class="stats-value">${displayRemaining}</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Target</div>
                    <div class="stats-value">${target}</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Used Numbers</div>
                    <div class="stats-value" id="usedNumbersList">${getUsedNumbers(maxInt, usedMask)}</div>
                </div>
            </div>
        </div>
        <div class="mt-3">
            <div class="stats-card">
                <div>Current State</div>
                <div class="stats-value">${stateDescription}</div>
            </div>
        </div>
    `;
    
    gameStateContainer.innerHTML = gameStateHTML;
}

// NEW: Get Used Numbers from Bitmask
function getUsedNumbers(maxInt, usedMask) {
    const usedNumbers = [];
    for (let i = 1; i <= maxInt; i++) {
        const bit = (1 << i);
        if (usedMask & bit) {
            usedNumbers.push(i);
        }
    }
    return usedNumbers.length > 0 ? usedNumbers.join(', ') : 'None';
}

// NEW: Perform Can I Win Analysis with Animation
function performCanIWinAnalysis(maxInt, target) {
    const explanation = document.getElementById('gameExplanation');
    const stepsContainer = document.getElementById('gameSteps');
    const gameResult = document.getElementById('gameResult');
    const continueButton = document.getElementById('continueAfterGame');
    const availableNumbersContainer = document.getElementById('availableNumbers');
    
    let memo = {};
    let stepCounter = 0;
    
    // Check initial conditions
    if (target <= 0) {
        explanation.innerHTML = '<strong>Game Analysis:</strong> Target is 0 or negative - First player wins immediately!';
        gameResult.innerHTML = '<span class="text-success">Player 1 Wins!</span>';
        completeGameAnalysis(true);
        return;
    }
    
    const totalSum = maxInt * (maxInt + 1) / 2;
    if (totalSum < target) {
        explanation.innerHTML = `<strong>Game Analysis:</strong> Total sum (${totalSum}) < target (${target}) - Impossible to reach target!`;
        gameResult.innerHTML = '<span class="text-danger">Player 2 Wins!</span>';
        completeGameAnalysis(false);
        return;
    }
    
    explanation.innerHTML = 'Starting recursive game analysis with memoization...';
    
    function dfs(remaining, usedMask, depth, currentPlayer) {
        stepCounter++;
        const stepId = stepCounter;
        
        // Update explanation - show positive remaining value
        const displayRemaining = Math.max(0, remaining);
        explanation.innerHTML = `Depth ${depth}: ${currentPlayer ? 'Player 1' : 'Player 2'} thinking... Target: ${target}, Remaining: ${displayRemaining}`;
        
        // Highlight current state - use displayRemaining instead of remaining
        renderGameState(maxInt, target, displayRemaining, usedMask, `${currentPlayer ? 'Player 1' : 'Player 2'}'s turn`);
        
        // Add step to visualization
        setTimeout(() => {
            stepsContainer.innerHTML += `
                <div class="algorithm-step" id="step-${stepId}">
                    <strong>Step ${stepId}:</strong> Depth ${depth}, ${currentPlayer ? 'Player 1' : 'Player 2'}, Remaining: ${displayRemaining}, Used: [${getUsedNumbers(maxInt, usedMask)}]
                </div>
            `;
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            // Highlight available numbers
            const availableElements = availableNumbersContainer.querySelectorAll('.array-element');
            availableElements.forEach((el, index) => {
                const number = index + 1;
                const bit = (1 << number);
                const isUsed = (usedMask & bit) !== 0;
                
                if (!isUsed) {
                    el.querySelector('.element-value').classList.add('window-included');
                } else {
                    el.querySelector('.element-value').classList.add('kadane-included');
                }
            });
        }, 500);
        
        return new Promise((resolve) => {
            setTimeout(() => {
                // Base case: current player wins if remaining <= 0
                if (remaining <= 0) {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active" id="result-${stepId}">
                            <strong>Result ${stepId}:</strong> ${currentPlayer ? 'Player 1' : 'Player 2'} wins! Target reached/exceeded.
                        </div>
                    `;
                    // If remaining <= 0, the previous player already won, so current player loses
                    resolve(false);
                    return;
                }
                
                // Check memo
                if (memo[usedMask] !== undefined) {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step" id="memo-${stepId}">
                            <strong>Memo ${stepId}:</strong> Found cached result for state ${usedMask} = ${memo[usedMask]}
                        </div>
                    `;
                    resolve(memo[usedMask]);
                    return;
                }
                
                // Try every unused number
                let canWin = false;
                let promises = [];
                
                for (let i = 1; i <= maxInt; i++) {
                    const bit = (1 << i);
                    if ((usedMask & bit) === 0) {
                        // Highlight this number as being considered
                        setTimeout(() => {
                            const availableElements = availableNumbersContainer.querySelectorAll('.array-element');
                            if (availableElements[i-1]) {
                                availableElements[i-1].querySelector('.element-value').classList.add('sorting-current');
                            }
                            
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step" id="try-${stepId}-${i}">
                                    <strong>Try ${stepId}.${i}:</strong> ${currentPlayer ? 'Player 1' : 'Player 2'} considers number ${i}
                                </div>
                            `;
                            stepsContainer.scrollTop = stepsContainer.scrollHeight;
                        }, 1000);
                        
                        // Recursive call
                        promises.push(
                            new Promise((innerResolve) => {
                                setTimeout(() => {
                                    const newRemaining = remaining - i;
                                    const newUsedMask = usedMask | bit;
                                    
                                    // If this move wins immediately (newRemaining <= 0), or opponent cannot win from the new state
                                    dfs(newRemaining, newUsedMask, depth + 1, !currentPlayer).then((opponentCanWin) => {
                                        // If we can win immediately OR opponent cannot force a win from the new state
                                        if (newRemaining <= 0 || !opponentCanWin) {
                                            canWin = true;
                                            memo[usedMask] = true;
                                            
                                            stepsContainer.innerHTML += `
                                                <div class="algorithm-step active" id="win-${stepId}-${i}">
                                                    <strong>Win ${stepId}.${i}:</strong> ${currentPlayer ? 'Player 1' : 'Player 2'} can win by choosing ${i}!
                                                    ${newRemaining <= 0 ? ' (Immediate win)' : ' (Opponent cannot win)'}
                                                </div>
                                            `;
                                        }
                                        innerResolve();
                                    });
                                }, 2000);
                            })
                        );
                    }
                }
                
                // Wait for all possibilities to be checked
                Promise.all(promises).then(() => {
                    if (!canWin) {
                        memo[usedMask] = false;
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step" id="lose-${stepId}">
                                <strong>Result ${stepId}:</strong> ${currentPlayer ? 'Player 1' : 'Player 2'} cannot force a win from this state
                            </div>
                        `;
                    }
                    resolve(canWin);
                });
            }, 1000);
        });
    }
    
    // Start the analysis - initial call with the full target
    dfs(target, 0, 0, true).then((result) => {
        explanation.innerHTML = `<strong>Game Analysis Complete!</strong> ${result ? 'Player 1 can force a win!' : 'Player 1 cannot force a win.'}`;
        gameResult.innerHTML = result ? 
            '<span class="text-success">Player 1 Wins!</span>' : 
            '<span class="text-danger">Player 2 Wins!</span>';
        
        completeGameAnalysis(result);
    });
}
// NEW: Complete Game Analysis
function completeGameAnalysis(result) {
    const continueButton = document.getElementById('continueAfterGame');
    
    continueButton.style.display = 'block';
    
    // Auto-return after 10 seconds
    setTimeout(() => {
        returnToOriginalAfterGame();
    }, 10000);
    
    continueButton.addEventListener('click', returnToOriginalAfterGame);
    
    logOperation(`Can I Win analysis completed: ${result ? 'Player 1 wins' : 'Player 2 wins'}`, 'info');
}

// NEW: Return to Original after Game
function returnToOriginalAfterGame() {
    // Reset to original array
    myArray = [...originalArrayForCanIWin];
    originalArrayForCanIWin = [];
    
    // Remove game visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isCanIWinRunning = false;
    
    // Clear inputs
    maxChoosableInteger.value = '';
    desiredTotal.value = '';
    
    logOperation('Returned to original array after Can I Win game', 'info');
    showNotification('Returned to original array after game analysis', 'success');
}
// NEW: Predict Winner Handler
function handlePredictWinner() {
    if (isPredictWinnerRunning) {
        showNotification('A prediction game is already in progress', 'warning');
        return;
    }

    // Reset array
    predictWinnerArray = [];
    predictWinnerSize = 0;
    
    // Show input group
    predictWinnerGroup.style.display = 'block';
    predictWinnerSizeInput.focus();
    
    // Hide perform button initially
    performPredictWinnerBtn.style.display = 'none';
    
    logOperation('Started Predict the Winner game', 'info');
}

// NEW: Confirm Predict Winner Size Handler
function handleConfirmPredictWinnerSize() {
    const size = parseInt(predictWinnerSizeInput.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        predictWinnerSizeInput.focus();
        return;
    }
    
    predictWinnerSize = size;
    predictWinnerArray = [];
    
    // Create input fields for array elements
    predictWinnerInputs.innerHTML = '<label class="form-label">Enter array elements (numbers only):</label>';
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="number" class="form-control predict-winner-element" 
                   placeholder="Enter number" data-index="${i}" step="any">
        `;
        predictWinnerInputs.appendChild(inputGroup);
    }
    
    // Add event listeners for array inputs
    const predictWinnerElements = predictWinnerInputs.querySelectorAll('.predict-winner-element');
    predictWinnerElements.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('predict-winner-element')) {
                    nextInput.focus();
                }
            }
        });
    });
    
    // Show perform button
    performPredictWinnerBtn.style.display = 'block';
    
    showNotification(`Array size set to ${size}. Please enter ${size} numbers.`, 'success');
    logOperation(`Predict Winner array size set to ${size}`, 'info');
}

// NEW: Perform Predict Winner Handler
function handlePerformPredictWinner() {
    // Collect array elements
    const predictWinnerElements = document.querySelectorAll('.predict-winner-element');
    predictWinnerArray = [];
    
    for (let i = 0; i < predictWinnerElements.length; i++) {
        const value = predictWinnerElements[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all array elements. Missing element at position ${i}`, 'danger');
            predictWinnerElements[i].focus();
            return;
        }
        
        const numValue = parseFloat(value);
        if (isNaN(numValue)) {
            showNotification(`Please enter valid numbers only. Invalid value at position ${i}`, 'danger');
            predictWinnerElements[i].focus();
            return;
        }
        
        predictWinnerArray.push(numValue);
    }
    
    // Store original array
    originalArrayForPredictWinner = [...myArray];
    
    // Hide input group
    predictWinnerGroup.style.display = 'none';
    
    // Start prediction visualization
    showPredictWinnerVisualization();
}

// NEW: Cancel Predict Winner Handler
function handleCancelPredictWinner() {
    predictWinnerGroup.style.display = 'none';
    predictWinnerSizeInput.value = '';
    predictWinnerInputs.innerHTML = '';
    performPredictWinnerBtn.style.display = 'none';
    
    predictWinnerArray = [];
    predictWinnerSize = 0;
    
    logOperation('Cancelled Predict Winner game', 'info');
    showNotification('Predict Winner game cancelled', 'info');
}

// NEW: Show Predict Winner Visualization
function showPredictWinnerVisualization() {
    isPredictWinnerRunning = true;
    
    const gameContainer = document.createElement('div');
    gameContainer.className = 'predict-winner-container';
    gameContainer.innerHTML = `
        <h5 class="text-center mb-3">Predict the Winner Game</h5>
        
        <div class="array-group">
            <div class="array-label">Game Array</div>
            <div class="original-array-container" id="gameArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Game Rules:</strong> Two players take turns picking from either end of the array. Player with higher total score wins.</p>
            <p class="mb-0" id="gameExplanation">Initializing game analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="gameStepsContainer">
            <h6 class="text-center">Dynamic Programming Analysis</h6>
            <div class="steps-container" id="gameSteps"></div>
        </div>
        
        <div class="dp-table-container mt-3" id="dpTableContainer" style="display: none;">
            <h6 class="text-center">DP Table (score differences)</h6>
            <div class="table-container">
                <table class="dp-table" id="dpTable"></table>
            </div>
        </div>
        
        <div class="game-simulation mt-3" id="gameSimulation" style="display: none;">
            <h6 class="text-center">Optimal Game Simulation</h6>
            <div id="simulationSteps"></div>
        </div>
        
        <div class="game-result mt-3" id="gameResult" style="display: none;"></div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPredictWinner" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(gameContainer);
    
    renderArrayInContainer(predictWinnerArray, 'gameArray');
    
    performPredictWinnerAnalysis();
}

// NEW: Perform Predict Winner Analysis with Animation
function performPredictWinnerAnalysis() {
    const arrayContainer = document.getElementById('gameArray');
    const explanation = document.getElementById('gameExplanation');
    const stepsContainer = document.getElementById('gameSteps');
    const dpTableContainer = document.getElementById('dpTableContainer');
    const dpTable = document.getElementById('dpTable');
    const gameSimulation = document.getElementById('gameSimulation');
    const simulationSteps = document.getElementById('simulationSteps');
    const gameResult = document.getElementById('gameResult');
    const continueButton = document.getElementById('continueAfterPredictWinner');
    
    const nums = [...predictWinnerArray];
    const n = nums.length;
    
    // Create DP table
    const dp = Array(n).fill(0).map(() => Array(n).fill(0));
    let step = 0;
    
    function performAnalysisStep() {
        if (step === 0) {
            // Step 1: Initialize DP table
            explanation.innerHTML = 'Step 1: Initialize DP table for single elements';
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Initialize DP table - for single elements, dp[i][i] = nums[i]
                </div>
            `;
            
            // Initialize diagonal
            for (let i = 0; i < n; i++) {
                dp[i][i] = nums[i];
            }
            
            // Create DP table visualization
            createDPTable(dp, nums);
            dpTableContainer.style.display = 'block';
            
            // Highlight diagonal elements
            setTimeout(() => {
                const dpCells = dpTable.querySelectorAll('td.dp-cell');
                for (let i = 0; i < n; i++) {
                    const cellIndex = i * (n + 1) + 1; // +1 for header row/column
                    if (dpCells[cellIndex]) {
                        setTimeout(() => {
                            dpCells[cellIndex].classList.add('dp-cell-highlight');
                        }, i * 300);
                    }
                }
                
                step++;
                setTimeout(performAnalysisStep, n * 300 + 1000);
            }, 1000);
            
        } else if (step <= n) {
            const length = step + 1;
            
            if (length > n) {
                // Analysis completed
                explanation.innerHTML = 'DP table completed. Analyzing final result...';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final Step:</strong> DP table completed. Final result: dp[0][${n-1}] = ${dp[0][n-1]}
                    </div>
                `;
                
                // Highlight final result
                setTimeout(() => {
                    const dpCells = dpTable.querySelectorAll('td.dp-cell');
                    const finalCellIndex = (n - 1) * n; // dp[0][n-1]
                    if (dpCells[finalCellIndex]) {
                        dpCells[finalCellIndex].classList.add('dp-cell-highlight');
                    }
                    
                    // Determine winner and simulate game
                    const firstPlayerCanWin = dp[0][n-1] >= 0;
                    
                    setTimeout(() => {
                        simulateOptimalGame(firstPlayerCanWin);
                    }, 1500);
                }, 1000);
                
                return;
            }
            
            explanation.innerHTML = `Step ${step + 1}: Processing subarrays of length ${length}`;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step + 1}:</strong> Calculate DP values for subarrays of length ${length}
                </div>
            `;
            
            // Fill DP table for current length
            let subStep = 0;
            
            function performSubStep() {
                if (subStep >= n - length + 1) {
                    step++;
                    setTimeout(performAnalysisStep, 1000);
                    return;
                }
                
                const i = subStep;
                const j = i + length - 1;
                
                explanation.innerHTML = `Calculating dp[${i}][${j}] = max(nums[${i}] - dp[${i+1}][${j}], nums[${j}] - dp[${i}][${j-1}])`;
                
                // Highlight current subarray in main array
                const arrayElements = arrayContainer.querySelectorAll('.array-element');
                for (let k = i; k <= j; k++) {
                    arrayElements[k].querySelector('.element-value').classList.add('available-choice');
                }
                
                // Highlight relevant DP cells
                const dpCells = dpTable.querySelectorAll('td.dp-cell');
                const currentCellIndex = i * n + j;
                const leftCellIndex = (i + 1) * n + j;
                const rightCellIndex = i * n + (j - 1);
                
                if (dpCells[currentCellIndex]) dpCells[currentCellIndex].classList.add('dp-cell-highlight');
                if (dpCells[leftCellIndex]) dpCells[leftCellIndex].classList.add('info-color');
                if (dpCells[rightCellIndex]) dpCells[rightCellIndex].classList.add('info-color');
                
                // Calculate DP value
                const chooseLeft = nums[i] - dp[i + 1][j];
                const chooseRight = nums[j] - dp[i][j - 1];
                dp[i][j] = Math.max(chooseLeft, chooseRight);
                
                setTimeout(() => {
                    // Update DP table
                    updateDPTable(dp, nums);
                    
                    // Remove highlights
                    for (let k = i; k <= j; k++) {
                        arrayElements[k].querySelector('.element-value').classList.remove('available-choice');
                    }
                    
                    if (dpCells[currentCellIndex]) dpCells[currentCellIndex].classList.remove('dp-cell-highlight');
                    if (dpCells[leftCellIndex]) dpCells[leftCellIndex].classList.remove('info-color');
                    if (dpCells[rightCellIndex]) dpCells[rightCellIndex].classList.remove('info-color');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Substep:</strong> dp[${i}][${j}] = max(${nums[i]} - ${dp[i+1][j]}, ${nums[j]} - ${dp[i][j-1]}) = ${dp[i][j]}
                        </div>
                    `;
                    
                    stepsContainer.scrollTop = stepsContainer.scrollHeight;
                    
                    subStep++;
                    setTimeout(performSubStep, 1500);
                }, 2000);
            }
            
            performSubStep();
            
        }
    }
    
    // Start analysis
    performAnalysisStep();
    
    // Helper function to create DP table
    function createDPTable(dp, nums) {
        let tableHTML = '<tr><th>i\\j</th>';
        
        // Header row
        for (let j = 0; j < n; j++) {
            tableHTML += `<th>${j}</th>`;
        }
        tableHTML += '</tr>';
        
        // Data rows
        for (let i = 0; i < n; i++) {
            tableHTML += `<tr><th>${i}</th>`;
            for (let j = 0; j < n; j++) {
                if (i <= j) {
                    tableHTML += `<td class="dp-cell">${dp[i][j]}</td>`;
                } else {
                    tableHTML += '<td>-</td>';
                }
            }
            tableHTML += '</tr>';
        }
        
        dpTable.innerHTML = tableHTML;
    }
    
    // Helper function to update DP table
    function updateDPTable(dp, nums) {
        const dpCells = dpTable.querySelectorAll('td.dp-cell');
        let cellIndex = 0;
        
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (i <= j) {
                    dpCells[cellIndex].textContent = dp[i][j];
                    cellIndex++;
                }
            }
        }
    }
    
    // Simulate optimal game
    function simulateOptimalGame(firstPlayerCanWin) {
        gameSimulation.style.display = 'block';
        explanation.innerHTML = 'Simulating optimal game play...';
        
        const arrayElements = arrayContainer.querySelectorAll('.array-element');
        let i = 0, j = n - 1;
        let player1Score = 0, player2Score = 0;
        let currentPlayer = 1;
        let moveCount = 0;
        
        function performGameStep() {
            if (i > j) {
                // Game completed
                const player1Wins = player1Score >= player2Score;
                
                gameResult.style.display = 'block';
                gameResult.className = `game-result ${player1Wins ? 'win' : 'lose'}`;
                gameResult.innerHTML = `
                    <h5>Game Result</h5>
                    <div class="player-score text-success">Player 1 Score: ${player1Score}</div>
                    <div class="player-score text-info">Player 2 Score: ${player2Score}</div>
                    <div class="player-score ${player1Wins ? 'text-success' : 'text-danger'}">
                        <strong>${player1Wins ? 'Player 1 WINS!' : 'Player 2 WINS!'}</strong>
                    </div>
                    <div class="mt-2">
                        Prediction: First player ${firstPlayerCanWin ? 'CAN win' : 'CANNOT win'} with optimal play
                    </div>
                `;
                
                continueButton.style.display = 'block';
                
                // Auto-return after 15 seconds
                setTimeout(() => {
                    returnToOriginalAfterPredictWinner();
                }, 15000);
                
                continueButton.addEventListener('click', returnToOriginalAfterPredictWinner);
                
                return;
            }
            
            moveCount++;
            
            // Determine optimal move using DP table
            let chosenValue, chosenIndex, moveSide;
            
            if (nums[i] - dp[i + 1][j] >= nums[j] - dp[i][j - 1]) {
                chosenValue = nums[i];
                chosenIndex = i;
                moveSide = 'left';
                i++;
            } else {
                chosenValue = nums[j];
                chosenIndex = j;
                moveSide = 'right';
                j--;
            }
            
            // Update scores
            if (currentPlayer === 1) {
                player1Score += chosenValue;
            } else {
                player2Score += chosenValue;
            }
            
            // Highlight the chosen element
            const chosenElement = arrayElements[chosenIndex].querySelector('.element-value');
            chosenElement.classList.add(currentPlayer === 1 ? 'player1-choice' : 'player2-choice');
            
            // Add simulation step
            simulationSteps.innerHTML += `
                <div class="move-explanation">
                    <strong>Move ${moveCount}:</strong> Player ${currentPlayer} takes ${moveSide} (${chosenValue})<br>
                    Scores: Player 1 = ${player1Score}, Player 2 = ${player2Score}
                </div>
            `;
            
            simulationSteps.scrollTop = simulationSteps.scrollHeight;
            
            explanation.innerHTML = `Player ${currentPlayer} takes ${moveSide} end (${chosenValue})`;
            
            // Switch player and continue
            currentPlayer = 3 - currentPlayer;
            
            setTimeout(() => {
                chosenElement.classList.remove('player1-choice', 'player2-choice');
                performGameStep();
            }, 2000);
        }
        
        performGameStep();
    }
}

// NEW: Return to Original after Predict Winner
function returnToOriginalAfterPredictWinner() {
    // Reset to original array
    myArray = [...originalArrayForPredictWinner];
    originalArrayForPredictWinner = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isPredictWinnerRunning = false;
    
    // Clear all predict winner data
    predictWinnerArray = [];
    predictWinnerSize = 0;
    
    // Reset input groups
    predictWinnerGroup.style.display = 'none';
    predictWinnerSizeInput.value = '';
    predictWinnerInputs.innerHTML = '';
    performPredictWinnerBtn.style.display = 'none';
    
    logOperation('Predict Winner game completed - returned to original array', 'info');
    showNotification('Returned to original array after Predict Winner game', 'success');
}
// NEW: Stone Game Handler
function handleStoneGame() {
    if (isStoneGameRunning) {
        showNotification('Stone game is already in progress', 'warning');
        return;
    }
    
    // Show stone game configuration
    stoneGameGroup.style.display = 'block';
    totalStones.focus();
    
    logOperation('Started stone game configuration', 'info');
}

// NEW: Start Stone Game Handler
function handleStartStoneGame() {
    const total = parseInt(totalStones.value);
    const max = parseInt(maxPick.value);
    const player1 = player1Name.value.trim() || 'Alice';
    const player2 = player2Name.value.trim() || 'Bob';
    
    // Validation
    if (isNaN(total) || total < 5 || total > 100) {
        showNotification('Please enter total stones between 5 and 100', 'danger');
        totalStones.focus();
        return;
    }
    
    if (isNaN(max) || max < 1 || max > 10) {
        showNotification('Please enter max pick between 1 and 10', 'danger');
        maxPick.focus();
        return;
    }
    
    if (player1 === player2) {
        showNotification('Player names must be different', 'warning');
        player2Name.focus();
        return;
    }
    
    // Store original array
    originalArrayForStoneGame = [...myArray];
    
    // Hide configuration
    stoneGameGroup.style.display = 'none';
    
    // Initialize stone game
    initializeStoneGame(total, max, player1, player2);
}

// NEW: Cancel Stone Game Handler
function handleCancelStoneGame() {
    stoneGameGroup.style.display = 'none';
    totalStones.value = '20';
    maxPick.value = '3';
    player1Name.value = 'Alice';
    player2Name.value = 'Bob';
    
    logOperation('Cancelled stone game', 'info');
}

// NEW: Initialize Stone Game
function initializeStoneGame(total, maxPick, player1, player2) {
    isStoneGameRunning = true;
    
    // Initialize game state
    stoneGameState = {
        totalStones: total,
        maxPick: maxPick,
        remainingStones: total,
        currentPlayer: player1,
        player1: player1,
        player2: player2,
        gameLog: []
    };
    
    // Show stone game visualization
    showStoneGameVisualization();
}

// NEW: Show Stone Game Visualization
function showStoneGameVisualization() {
    const gameContainer = document.createElement('div');
    gameContainer.className = 'stone-game-container';
    gameContainer.innerHTML = `
        <h4 class="text-center mb-4"> Stone Game </h4>
        
        <div class="game-info">
            <div class="row">
                <div class="col-md-4">
                    <div class="stats-card">
                        <div>Total Stones</div>
                        <div class="stats-value">${stoneGameState.totalStones}</div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="stats-card">
                        <div>Max Pick</div>
                        <div class="stats-value">${stoneGameState.maxPick}</div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="stats-card">
                        <div>Remaining</div>
                        <div class="stats-value" id="remainingStones">${stoneGameState.remainingStones}</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="player-turn" id="currentPlayerTurn">
             ${stoneGameState.currentPlayer}'s Turn
        </div>
        
        <div class="stone-pile" id="stonePile">
            <!-- Stones will be dynamically generated here -->
        </div>
        
        <div class="game-controls" id="gameControls">
            <!-- Pick buttons will be dynamically generated here -->
        </div>
        
        <div class="game-log" id="gameLog">
            <h6>Game Log</h6>
            <!-- Game log entries will appear here -->
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="endStoneGameBtn" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Array Visualizer
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(gameContainer);
    
    // Initialize the game display
    updateStoneGameDisplay();
    
    // Add game log entry
    addGameLog(`Game started! ${stoneGameState.player1} vs ${stoneGameState.player2}`);
    addGameLog(`Total stones: ${stoneGameState.totalStones}, Max pick: ${stoneGameState.maxPick}`);
    addGameLog(`${stoneGameState.currentPlayer} goes first!`);
    
    logOperation(`Stone game started: ${stoneGameState.player1} vs ${stoneGameState.player2}`, 'success');
}

// NEW: Update Stone Game Display
function updateStoneGameDisplay() {
    const stonePile = document.getElementById('stonePile');
    const gameControls = document.getElementById('gameControls');
    const remainingStones = document.getElementById('remainingStones');
    const currentPlayerTurn = document.getElementById('currentPlayerTurn');
    
    // Update remaining stones
    remainingStones.textContent = stoneGameState.remainingStones;
    
    // Update current player
    currentPlayerTurn.textContent = ` ${stoneGameState.currentPlayer}'s Turn`;
    
    // Clear previous stones and controls
    stonePile.innerHTML = '';
    gameControls.innerHTML = '';
    
    // Generate stones
    for (let i = 1; i <= stoneGameState.remainingStones; i++) {
        const stone = document.createElement('div');
        stone.className = 'stone-item available';
        stone.textContent = i;
        stone.title = `Stone ${i}`;
        stone.addEventListener('click', () => handleStoneClick(i));
        stonePile.appendChild(stone);
    }
    
    // Generate pick buttons
    const maxAllowedPick = Math.min(stoneGameState.maxPick, stoneGameState.remainingStones);
    for (let i = 1; i <= maxAllowedPick; i++) {
        const button = document.createElement('button');
        button.className = 'pick-btn';
        button.textContent = `Take ${i}`;
        button.addEventListener('click', () => handleStonePick(i));
        gameControls.appendChild(button);
    }
    
    // Check for game end
    if (stoneGameState.remainingStones === 0) {
        endStoneGame();
    }
}

// NEW: Handle Stone Click (for visualization)
function handleStoneClick(stoneNumber) {
    // Just highlight the stone for visualization
    const stones = document.querySelectorAll('.stone-item');
    stones[stoneNumber - 1].classList.add('pulse');
    setTimeout(() => {
        stones[stoneNumber - 1].classList.remove('pulse');
    }, 500);
}

// NEW: Handle Stone Pick
function handleStonePick(pickCount) {
    if (pickCount < 1 || pickCount > stoneGameState.maxPick || pickCount > stoneGameState.remainingStones) {
        showNotification('Invalid number of stones to pick', 'danger');
        return;
    }
    
    // Update game state
    stoneGameState.remainingStones -= pickCount;
    
    // Add to game log
    addGameLog(`${stoneGameState.currentPlayer} takes ${pickCount} stone(s). Remaining: ${stoneGameState.remainingStones}`);
    
    // Check if game is over
    if (stoneGameState.remainingStones === 0) {
        addGameLog(` ${stoneGameState.currentPlayer} wins the game!`);
        endStoneGame();
        return;
    }
    
    // Switch players
    stoneGameState.currentPlayer = stoneGameState.currentPlayer === stoneGameState.player1 ? 
        stoneGameState.player2 : stoneGameState.player1;
    
    // Update display
    updateStoneGameDisplay();
    
    // Auto-pick for computer player (simple strategy)
    if (stoneGameState.currentPlayer === stoneGameState.player2) {
        setTimeout(() => {
            autoPickStones();
        }, 2000);
    }
}

// NEW: Auto Pick Stones (Computer Player)
function autoPickStones() {
    if (stoneGameState.remainingStones === 0) return;
    
    // Simple strategy: try to leave opponent in losing position
    let pick = 1;
    const maxAllowed = Math.min(stoneGameState.maxPick, stoneGameState.remainingStones);
    
    // If we can win this turn, take all remaining stones
    if (stoneGameState.remainingStones <= maxAllowed) {
        pick = stoneGameState.remainingStones;
    } else {
        // Try to leave (maxPick + 1) stones for opponent
        const target = stoneGameState.remainingStones - (stoneGameState.maxPick + 1);
        if (target >= 1 && target <= maxAllowed) {
            pick = target;
        } else {
            // Random pick
            pick = Math.floor(Math.random() * maxAllowed) + 1;
        }
    }
    
    handleStonePick(pick);
}

// NEW: Add Game Log Entry
function addGameLog(message) {
    const gameLog = document.getElementById('gameLog');
    const logEntry = document.createElement('div');
    logEntry.className = 'log-entry';
    logEntry.textContent = message;
    gameLog.appendChild(logEntry);
    
    // Scroll to bottom
    gameLog.scrollTop = gameLog.scrollHeight;
    
    // Also add to main operation log
    logOperation(`Stone Game: ${message}`, 'info');
}

// NEW: End Stone Game
function endStoneGame() {
    const endButton = document.getElementById('endStoneGameBtn');
    const currentPlayerTurn = document.getElementById('currentPlayerTurn');
    
    // Show winner
    currentPlayerTurn.innerHTML = `<div class="winning-player"> ${stoneGameState.currentPlayer} Wins! </div>`;
    
    // Show end button
    endButton.style.display = 'block';
    endButton.addEventListener('click', returnToOriginalAfterStoneGame);
    
    // Auto-return after 20 seconds
    setTimeout(() => {
        returnToOriginalAfterStoneGame();
    }, 20000);
    
    logOperation(`Stone game completed - ${stoneGameState.currentPlayer} wins!`, 'success');
    showNotification(`Stone game completed! ${stoneGameState.currentPlayer} wins!`, 'success');
}

// NEW: Return to Original after Stone Game
function returnToOriginalAfterStoneGame() {
    // Reset to original array
    myArray = [...originalArrayForStoneGame];
    originalArrayForStoneGame = [];
    
    // Remove stone game visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isStoneGameRunning = false;
    
    // Clear configuration
    stoneGameGroup.style.display = 'none';
    totalStones.value = '20';
    maxPick.value = '3';
    player1Name.value = 'Alice';
    player2Name.value = 'Bob';
    
    logOperation('Returned to array visualizer after stone game', 'info');
    showNotification('Returned to array visualizer', 'success');
}
// NEW: Gas Station Problem Handler
function handleGasStationProblem() {
    if (isGasStationRunning) {
        showNotification('Gas station problem is already in progress', 'warning');
        return;
    }

    // Reset data
    gasStationData = {
        gas: [],
        cost: [],
        stationCount: 0
    };

    // Show input group
    gasStationGroup.style.display = 'block';
    gasStationCount.focus();

    // Hide solve button initially
    solveGasStationBtn.style.display = 'none';

    logOperation('Started gas station circular route problem', 'info');
}

// NEW: Confirm Gas Station Count Handler
function handleConfirmGasStationCount() {
    const count = parseInt(gasStationCount.value);

    if (isNaN(count) || count < 1 || count > 20) {
        showNotification('Please enter a valid number between 1 and 20', 'danger');
        gasStationCount.focus();
        return;
    }

    gasStationData.stationCount = count;
    gasStationData.gas = [];
    gasStationData.cost = [];

    // Create input fields for gas and cost
    gasStationInputs.innerHTML = `
        <label class="form-label">Enter Gas Available and Travel Cost for Each Station:</label>
        <div class="row">
            <div class="col-6"><strong>Station</strong></div>
            <div class="col-3"><strong>Gas Available</strong></div>
            <div class="col-3"><strong>Travel Cost</strong></div>
        </div>
    `;

    for (let i = 0; i < count; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'row mb-2';
        inputGroup.innerHTML = `
            <div class="col-6 d-flex align-items-center">
                Station ${i}  Station ${(i + 1) % count}
            </div>
            <div class="col-3">
                <input type="number" class="form-control gas-station-input" 
                       data-type="gas" data-index="${i}" placeholder="Gas" min="0">
            </div>
            <div class="col-3">
                <input type="number" class="form-control gas-station-input" 
                       data-type="cost" data-index="${i}" placeholder="Cost" min="0">
            </div>
        `;
        gasStationInputs.appendChild(inputGroup);
    }

    // Add event listeners for inputs
    const gasInputs = gasStationInputs.querySelectorAll('.gas-station-input');
    gasInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.parentElement.nextElementSibling?.querySelector('.gas-station-input');
                if (nextInput) {
                    nextInput.focus();
                } else {
                    solveGasStationBtn.focus();
                }
            }
        });
    });

    // Show solve button
    solveGasStationBtn.style.display = 'block';

    showNotification(`Set ${count} gas stations. Please enter gas and cost values.`, 'success');
    logOperation(`Gas station count set to ${count}`, 'info');
}

// NEW: Solve Gas Station Problem Handler
function handleSolveGasStation() {
    // Collect gas and cost values
    const gasInputs = gasStationInputs.querySelectorAll('input[data-type="gas"]');
    const costInputs = gasStationInputs.querySelectorAll('input[data-type="cost"]');

    gasStationData.gas = [];
    gasStationData.cost = [];

    // Validate and collect gas values
    for (let i = 0; i < gasInputs.length; i++) {
        const gasValue = parseInt(gasInputs[i].value);
        if (isNaN(gasValue) || gasValue < 0) {
            showNotification(`Please enter valid gas value for station ${i}`, 'danger');
            gasInputs[i].focus();
            return;
        }
        gasStationData.gas.push(gasValue);
    }

    // Validate and collect cost values
    for (let i = 0; i < costInputs.length; i++) {
        const costValue = parseInt(costInputs[i].value);
        if (isNaN(costValue) || costValue < 0) {
            showNotification(`Please enter valid cost value for station ${i}`, 'danger');
            costInputs[i].focus();
            return;
        }
        gasStationData.cost.push(costValue);
    }

    // Store original array
    originalArrayForGasStation = [...myArray];

    // Hide input group
    gasStationGroup.style.display = 'none';

    // Start gas station visualization
    showGasStationVisualization();
}

// NEW: Cancel Gas Station Handler
function handleCancelGasStation() {
    gasStationGroup.style.display = 'none';
    gasStationCount.value = '';
    gasStationInputs.innerHTML = '';
    solveGasStationBtn.style.display = 'none';

    gasStationData = {
        gas: [],
        cost: [],
        stationCount: 0
    };

    logOperation('Cancelled gas station problem', 'info');
    showNotification('Gas station operation cancelled', 'info');
}
// NEW: Show Gas Station Visualization
function showGasStationVisualization() {
    isGasStationRunning = true;

    const container = document.createElement('div');
    container.className = 'dual-operation-container';
    container.innerHTML = `
        <h5 class="text-center mb-3">Gas Station Circular Route Problem</h5>
        
        <div class="array-group">
            <div class="array-label">Gas Stations Configuration</div>
            <div class="original-array-container" id="gasStationDisplay"></div>
        </div>

        <div class="operation-explanation">
            <p class="mb-2"><strong>Problem:</strong> Can you travel around the circuit once starting from any station?</p>
            <p class="mb-0" id="gasStationExplanation">Initializing gas station analysis...</p>
        </div>

        <div class="algorithm-steps mt-3" id="gasStationStepsContainer">
            <h6 class="text-center">Gas Station Analysis Steps</h6>
            <div class="steps-container" id="gasStationSteps"></div>
        </div>

        <div class="table-container mt-3" id="gasStationTableContainer" style="display: none;">
            <h6 class="text-center">Detailed Station Analysis</h6>
            <table class="frequency-table">
                <thead>
                    <tr>
                        <th>Station</th>
                        <th>Gas</th>
                        <th>Cost</th>
                        <th>Net</th>
                        <th>Cumulative</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody id="gasStationTableBody"></tbody>
            </table>
        </div>

        <div class="stats-card mt-3" id="gasStationResult" style="display: none;">
            <div>Final Result</div>
            <div class="stats-value" id="gasStationResultValue">-</div>
        </div>

        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterGasStation" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;

    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(container);

    // Display gas stations
    renderGasStations();

    // Start gas station algorithm
    performGasStationAlgorithm();
}

// NEW: Render Gas Stations
function renderGasStations() {
    const container = document.getElementById('gasStationDisplay');
    container.innerHTML = '';

    const n = gasStationData.stationCount;

    for (let i = 0; i < n; i++) {
        const stationElement = document.createElement('div');
        stationElement.className = 'array-element';
        stationElement.innerHTML = `
            <div class="element-value station-gas">
                <div class="station-gas-value">${gasStationData.gas[i]}</div>
                <div class="station-cost-value">${gasStationData.cost[i]}</div>
            </div>
            <div class="element-index">Station ${i}</div>
            <div class="station-arrow"> ${(i + 1) % n}</div>
        `;
        container.appendChild(stationElement);
    }
}

// NEW: Perform Gas Station Algorithm with Animation
function performGasStationAlgorithm() {
    const explanation = document.getElementById('gasStationExplanation');
    const stepsContainer = document.getElementById('gasStationSteps');
    const tableContainer = document.getElementById('gasStationTableContainer');
    const tableBody = document.getElementById('gasStationTableBody');
    const resultDiv = document.getElementById('gasStationResult');
    const resultValue = document.getElementById('gasStationResultValue');
    const continueButton = document.getElementById('continueAfterGasStation');

    const gas = gasStationData.gas;
    const cost = gasStationData.cost;
    const n = gasStationData.stationCount;

    let step = 0;
    let startIndex = 0;
    let currentGas = 0;
    let totalGas = gas.reduce((a, b) => a + b, 0);
    let totalCost = cost.reduce((a, b) => a + b, 0);

    function performAlgorithmStep() {
        if (step === 0) {
            // Step 1: Check total gas vs total cost
            explanation.innerHTML = `Step ${step + 1}: Checking total gas vs total cost`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step + 1}:</strong> Total Gas = ${totalGas}, Total Cost = ${totalCost}
                </div>
            `;

            if (totalGas < totalCost) {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Result:</strong>  Total gas (${totalGas}) < total cost (${totalCost}) - Circuit impossible
                    </div>
                `;
                
                resultValue.innerHTML = ` Cannot complete circuit<br>Total gas insufficient`;
                resultDiv.style.display = 'block';
                showFinalTable();
                return;
            }

            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Result:</strong>  Total gas sufficient, proceeding with station analysis
                </div>
            `;

            step++;
            setTimeout(performAlgorithmStep, 2000);
            
        } else if (step === 1) {
            // Step 2: Find starting station using greedy approach
            explanation.innerHTML = `Step ${step + 1}: Finding optimal starting station using greedy approach`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step + 1}:</strong> Starting from station 0, tracking gas balance
                </div>
            `;

            performStationAnalysis();
        }
    }

    function performStationAnalysis() {
        let currentGas = 0;
        let startIndex = 0;
        let journeyDetails = [];

        function analyzeStation(i) {
            if (i >= n) {
                // Analysis completed
                if (startIndex < n) {
                    explanation.innerHTML = ` Found valid starting station: ${startIndex}`;
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Final:</strong> Valid starting station found at index ${startIndex}
                        </div>
                    `;
                    
                    resultValue.innerHTML = ` Can complete circuit<br>Start from station ${startIndex}`;
                    verifyJourney(startIndex);
                } else {
                    explanation.innerHTML = ` No valid starting station found`;
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Final:</strong> No valid starting station found
                        </div>
                    `;
                    
                    resultValue.innerHTML = ` Cannot complete circuit<br>No valid starting point`;
                    showFinalTable();
                }
                return;
            }

            const netGas = gas[i] - cost[i];
            currentGas += netGas;
            
            journeyDetails.push({
                station: i,
                gas: gas[i],
                cost: cost[i],
                net: netGas,
                cumulative: currentGas,
                status: currentGas >= 0 ? 'OK' : 'FAILED'
            });

            explanation.innerHTML = `Station ${i}: Gas=${gas[i]}, Cost=${cost[i]}, Net=${netGas}, Current=${currentGas}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${currentGas < 0 ? 'active' : ''}">
                    <strong>Station ${i}:</strong> Gas=${gas[i]}, Cost=${cost[i]}, Net=${netGas}, Current Gas=${currentGas}
                    ${currentGas < 0 ? '  Ran out of gas' : '  OK'}
                </div>
            `;

            // Highlight current station
            highlightGasStation(i, currentGas >= 0 ? 'success' : 'danger');

            if (currentGas < 0) {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Restart:</strong> Cannot proceed from station ${startIndex}, trying station ${i + 1}
                    </div>
                `;
                startIndex = i + 1;
                currentGas = 0;
            }

            setTimeout(() => {
                analyzeStation(i + 1);
            }, 2000);
        }

        analyzeStation(0);
    }

    function verifyJourney(startIndex) {
        explanation.innerHTML = `Verifying complete journey starting from station ${startIndex}`;
        
        let currentGas = 0;
        let verificationSteps = '';

        function verifyStep(i) {
            if (i >= n) {
                // Verification completed
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Verification:</strong>  Journey completed successfully from station ${startIndex}
                    </div>
                `;
                
                resultDiv.style.display = 'block';
                showFinalTable(startIndex);
                return;
            }

            const currentStation = (startIndex + i) % n;
            const nextStation = (startIndex + i + 1) % n;
            
            currentGas += gas[currentStation];
            const required = cost[currentStation];

            verificationSteps += `
                <div class="algorithm-step ${currentGas >= required ? '' : 'active'}">
                    Station ${currentStation}: Gas=${gas[currentStation]}, Total=${currentGas}, Need=${required}
                    ${currentGas >= required ? '  Can travel' : '  Cannot travel'}
                </div>
            `;

            if (currentGas >= required) {
                currentGas -= required;
                stepsContainer.innerHTML = verificationSteps;
                
                setTimeout(() => {
                    verifyStep(i + 1);
                }, 1500);
            } else {
                stepsContainer.innerHTML = verificationSteps;
                resultValue.innerHTML = ` Verification failed<br>Cannot complete from station ${startIndex}`;
                showFinalTable();
            }
        }

        verifyStep(0);
    }

    function showFinalTable(startIndex = -1) {
        // Build detailed analysis table
        tableBody.innerHTML = '';
        let cumulative = 0;
        let minCumulative = Infinity;
        let minIndex = -1;

        for (let i = 0; i < n; i++) {
            const net = gas[i] - cost[i];
            cumulative += net;
            
            if (cumulative < minCumulative) {
                minCumulative = cumulative;
                minIndex = i;
            }

            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${i}</td>
                <td>${gas[i]}</td>
                <td>${cost[i]}</td>
                <td>${net}</td>
                <td>${cumulative}</td>
                <td>${cumulative >= 0 ? ' OK' : ' LOW'}</td>
            `;
            if (i === startIndex) {
                row.classList.add('frequency-high-count');
            }
            tableBody.appendChild(row);
        }

        tableContainer.style.display = 'block';
        
        // Add optimal station note
        const optimalStation = (minIndex + 1) % n;
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Optimal Start:</strong> Station ${optimalStation} (following lowest cumulative point)
            </div>
        `;

        // Show continue button and auto-return after 20 seconds
        continueButton.style.display = 'block';
        
        setTimeout(() => {
            returnToOriginalAfterGasStation();
        }, 20000);
        
        continueButton.addEventListener('click', returnToOriginalAfterGasStation);
    }

    function highlightGasStation(index, status) {
        const stations = document.querySelectorAll('.station-gas');
        if (stations[index]) {
            stations[index].classList.remove('success-color', 'danger-color', 'warning-color');
            stations[index].classList.add(status === 'success' ? 'success-color' : 'danger-color');
        }
    }

    // Start algorithm
    performAlgorithmStep();
}

// NEW: Return to Original after Gas Station
function returnToOriginalAfterGasStation() {
    // Reset to original array
    myArray = [...originalArrayForGasStation];
    originalArrayForGasStation = [];

    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();

    // Reset state
    isGasStationRunning = false;

    // Clear all gas station data
    gasStationData = {
        gas: [],
        cost: [],
        stationCount: 0
    };

    // Reset input groups
    gasStationGroup.style.display = 'none';
    gasStationCount.value = '';
    gasStationInputs.innerHTML = '';
    solveGasStationBtn.style.display = 'none';

    logOperation('Gas station problem completed - returned to original array', 'info');
    showNotification('Returned to original array after gas station problem', 'success');
}
// NEW: Candy Distribution Handler
function handleCandyDistribution() {
    if (isCandyDistributionRunning) {
        showNotification('Candy distribution is already in progress', 'warning');
        return;
    }

    // Reset arrays
    candyRatings = [];
    candyArray = [];
    
    // Show input group
    candyInputGroup.style.display = 'block';
    candyArraySize.focus();
    
    // Hide perform button initially
    performCandyDistributionBtn.style.display = 'none';
    
    logOperation('Started candy distribution problem', 'info');
}

// NEW: Confirm Candy Size Handler
function handleConfirmCandySize() {
    const size = parseInt(candyArraySize.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        candyArraySize.focus();
        return;
    }
    
    // Create input fields for ratings
    candyArrayInputs.innerHTML = '<label class="form-label">Enter ratings for each child:</label>';
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Child ${i} Rating</span>
            <input type="number" class="form-control candy-rating-input" 
                   placeholder="Enter rating" data-index="${i}" min="0">
        `;
        candyArrayInputs.appendChild(inputGroup);
    }
    
    // Add event listeners for rating inputs
    const ratingInputs = candyArrayInputs.querySelectorAll('.candy-rating-input');
    ratingInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('candy-rating-input')) {
                    nextInput.focus();
                }
            }
        });
    });
    
    // Show perform button
    performCandyDistributionBtn.style.display = 'block';
    
    showNotification(`Array size set to ${size}. Please enter ${size} ratings.`, 'success');
    logOperation(`Candy distribution array size set to ${size}`, 'info');
}

// NEW: Perform Candy Distribution Handler
function handlePerformCandyDistribution() {
    // Collect ratings
    const ratingInputs = document.querySelectorAll('.candy-rating-input');
    candyRatings = [];
    
    for (let i = 0; i < ratingInputs.length; i++) {
        const value = ratingInputs[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all ratings. Missing rating at position ${i}`, 'danger');
            ratingInputs[i].focus();
            return;
        }
        const rating = parseInt(value);
        if (isNaN(rating) || rating < 0) {
            showNotification(`Please enter valid positive ratings. Invalid at position ${i}`, 'danger');
            ratingInputs[i].focus();
            return;
        }
        candyRatings.push(rating);
    }
    
    // Store original array
    originalArrayForCandy = [...myArray];
    
    // Hide input group
    candyInputGroup.style.display = 'none';
    
    // Start candy distribution visualization
    showCandyDistributionVisualization();
}

// NEW: Cancel Candy Handler
function handleCancelCandy() {
    candyInputGroup.style.display = 'none';
    candyArraySize.value = '';
    candyArrayInputs.innerHTML = '';
    performCandyDistributionBtn.style.display = 'none';
    
    candyRatings = [];
    candyArray = [];
    
    logOperation('Cancelled candy distribution operation', 'info');
    showNotification('Candy distribution operation cancelled', 'info');
}

// NEW: Show Candy Distribution Visualization
function showCandyDistributionVisualization() {
    isCandyDistributionRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Candy Distribution Problem</h5>
        
        <div class="array-group">
            <div class="array-label">Children Ratings</div>
            <div class="original-array-container" id="ratingsArrayDisplay"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Candy Distribution Process</div>
            <div class="transformed-array-container" id="candyArrayDisplay"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Candy Distribution Algorithm:</strong> Each child must get at least 1 candy. Children with higher ratings get more candies than neighbors.</p>
            <p class="mb-0" id="candyExplanation">Initializing candy distribution...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="candyStepsContainer">
            <h6 class="text-center">Candy Distribution Steps</h6>
            <div class="steps-container" id="candySteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Minimum Candies Needed</div>
            <div class="stats-value" id="minCandiesValue">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterCandy" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display the ratings array
    renderRatingsArray(candyRatings, 'ratingsArrayDisplay');
    
    // Initialize candy array with 1 candy each
    const initialCandies = Array(candyRatings.length).fill(1);
    renderCandyArray(candyRatings, initialCandies, 'candyArrayDisplay');
    
    // Start candy distribution animation
    performCandyDistributionAnimation();
}

// NEW: Render Ratings Array
function renderRatingsArray(ratings, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    ratings.forEach((rating, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value candy-initial">
                <div class="candy-rating">${rating}</div>
                <div>Rating</div>
            </div>
            <div class="element-index">Child ${index}</div>
        `;
        container.appendChild(arrayElement);
    });
}

// NEW: Render Candy Array
function renderCandyArray(ratings, candies, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    ratings.forEach((rating, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value candy-initial">
                <div class="candy-rating">${rating}</div>
                <div class="candy-count">${candies[index]} </div>
            </div>
            <div class="element-index">Child ${index}</div>
        `;
        container.appendChild(arrayElement);
    });
}

// NEW: Perform Candy Distribution Animation
function performCandyDistributionAnimation() {
    const ratingsContainer = document.getElementById('ratingsArrayDisplay');
    const candyContainer = document.getElementById('candyArrayDisplay');
    const explanation = document.getElementById('candyExplanation');
    const stepsContainer = document.getElementById('candySteps');
    const minCandiesValue = document.getElementById('minCandiesValue');
    const continueButton = document.getElementById('continueAfterCandy');
    
    const ratings = [...candyRatings];
    const n = ratings.length;
    let candies = Array(n).fill(1);
    let step = 0;
    let totalCandies = 0;
    
    function performCandyStep() {
        if (step === 0) {
            // Step 1: Initialize all with 1 candy
            explanation.innerHTML = 'Step 1: Initialize all children with 1 candy';
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Initialize all ${n} children with 1 candy each
                </div>
            `;
            
            // Highlight all elements
            const candyElements = candyContainer.querySelectorAll('.array-element');
            candyElements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('candy-initial');
                }, index * 200);
            });
            
            minCandiesValue.textContent = n;
            step++;
            
            setTimeout(() => {
                performCandyStep();
            }, 2000);
            
        } else if (step === 1) {
            // Step 2: Left to right pass
            explanation.innerHTML = 'Step 2: Left to right pass - Give more candies to children with higher ratings than left neighbor';
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 2:</strong> Left to right pass
                </div>
            `;
            
            performLeftToRightPass();
            
        } else if (step === 2) {
            // Step 3: Right to left pass
            explanation.innerHTML = 'Step 3: Right to left pass - Give more candies to children with higher ratings than right neighbor';
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 3:</strong> Right to left pass
                </div>
            `;
            
            performRightToLeftPass();
            
        } else {
            // Algorithm completed
            totalCandies = candies.reduce((sum, candy) => sum + candy, 0);
            
            explanation.innerHTML = `<strong>Candy Distribution Completed!</strong> Minimum candies needed: ${totalCandies}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Total candies needed = ${totalCandies}
                </div>
                <div class="algorithm-step active">
                    <strong>Distribution:</strong> ${candies.join(' + ')} = ${totalCandies}
                </div>
            `;
            
            // Highlight final candy distribution
            const candyElements = candyContainer.querySelectorAll('.array-element');
            candyElements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('candy-final');
                }, index * 200);
            });
            
            minCandiesValue.textContent = totalCandies;
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterCandy();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterCandy);
        }
    }
    
    function performLeftToRightPass() {
        let i = 1;
        
        function processLeftToRight() {
            if (i >= n) {
                step++;
                setTimeout(() => {
                    performCandyStep();
                }, 1000);
                return;
            }
            
            explanation.innerHTML = `Left to right: Comparing child ${i} (rating: ${ratings[i]}) with child ${i-1} (rating: ${ratings[i-1]})`;
            
            // Highlight current comparison
            const candyElements = candyContainer.querySelectorAll('.array-element');
            const currentElement = candyElements[i].querySelector('.element-value');
            const leftElement = candyElements[i-1].querySelector('.element-value');
            
            currentElement.classList.add('candy-left-pass');
            leftElement.classList.add('candy-left-pass');
            
            setTimeout(() => {
                if (ratings[i] > ratings[i-1]) {
                    candies[i] = candies[i-1] + 1;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Left-Right ${i}:</strong> Rating[${i}] > Rating[${i-1}]  Candies[${i}] = ${candies[i]} (${candies[i-1]} + 1)
                        </div>
                    `;
                    
                    // Update display
                    renderCandyArray(ratings, candies, 'candyArrayDisplay');
                    
                    // Re-highlight
                    const updatedElements = candyContainer.querySelectorAll('.array-element');
                    updatedElements[i].querySelector('.element-value').classList.add('candy-left-pass');
                    updatedElements[i-1].querySelector('.element-value').classList.add('candy-left-pass');
                } else {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Left-Right ${i}:</strong> Rating[${i}]  Rating[${i-1}]  No change
                        </div>
                    `;
                }
                
                // Remove highlights
                setTimeout(() => {
                    currentElement.classList.remove('candy-left-pass');
                    leftElement.classList.remove('candy-left-pass');
                    
                    i++;
                    processLeftToRight();
                }, 1500);
            }, 1000);
        }
        
        processLeftToRight();
    }
    
    function performRightToLeftPass() {
        let i = n - 2;
        
        function processRightToLeft() {
            if (i < 0) {
                step++;
                setTimeout(() => {
                    performCandyStep();
                }, 1000);
                return;
            }
            
            explanation.innerHTML = `Right to left: Comparing child ${i} (rating: ${ratings[i]}) with child ${i+1} (rating: ${ratings[i+1]})`;
            
            // Highlight current comparison
            const candyElements = candyContainer.querySelectorAll('.array-element');
            const currentElement = candyElements[i].querySelector('.element-value');
            const rightElement = candyElements[i+1].querySelector('.element-value');
            
            currentElement.classList.add('candy-right-pass');
            rightElement.classList.add('candy-right-pass');
            
            setTimeout(() => {
                if (ratings[i] > ratings[i+1]) {
                    candies[i] = Math.max(candies[i], candies[i+1] + 1);
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Right-Left ${i}:</strong> Rating[${i}] > Rating[${i+1}]  Candies[${i}] = max(${candies[i]}, ${candies[i+1]} + 1) = ${candies[i]}
                        </div>
                    `;
                    
                    // Update display
                    renderCandyArray(ratings, candies, 'candyArrayDisplay');
                    
                    // Re-highlight
                    const updatedElements = candyContainer.querySelectorAll('.array-element');
                    updatedElements[i].querySelector('.element-value').classList.add('candy-right-pass');
                    updatedElements[i+1].querySelector('.element-value').classList.add('candy-right-pass');
                } else {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Right-Left ${i}:</strong> Rating[${i}]  Rating[${i+1}]  No change
                        </div>
                    `;
                }
                
                // Remove highlights
                setTimeout(() => {
                    currentElement.classList.remove('candy-right-pass');
                    rightElement.classList.remove('candy-right-pass');
                    
                    i--;
                    processRightToLeft();
                }, 1500);
            }, 1000);
        }
        
        processRightToLeft();
    }
    
    // Start candy distribution process
    performCandyStep();
}

// NEW: Return to Original after Candy Distribution
function returnToOriginalAfterCandy() {
    // Reset to original array
    myArray = [...originalArrayForCandy];
    originalArrayForCandy = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isCandyDistributionRunning = false;
    
    // Clear all candy-related data
    candyRatings = [];
    candyArray = [];
    
    // Reset input groups
    candyInputGroup.style.display = 'none';
    candyArraySize.value = '';
    candyArrayInputs.innerHTML = '';
    performCandyDistributionBtn.style.display = 'none';
    
    logOperation('Candy distribution completed - returned to original array', 'info');
    showNotification('Returned to original array after candy distribution', 'success');
}
// NEW: Task Scheduler Handler
function handleTaskScheduler() {
    if (isTaskSchedulerRunning) {
        showNotification('Task scheduler is already running', 'warning');
        return;
    }

    // Reset task scheduler data
    taskSchedulerTasks = [];
    taskSchedulerCooldown = 0;
    
    // Show input group
    taskSchedulerGroup.style.display = 'block';
    taskArraySize.focus();
    
    // Hide perform button initially
    performTaskSchedulingBtn.style.display = 'none';
    
    logOperation('Started task scheduler with cooldown period operation', 'info');
}

// NEW: Confirm Task Size Handler
function handleConfirmTaskSize() {
    const size = parseInt(taskArraySize.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        taskArraySize.focus();
        return;
    }
    
    // Create input fields for tasks
    taskInputs.innerHTML = '<label class="form-label">Enter tasks (single characters recommended):</label>';
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Task ${i + 1}</span>
            <input type="text" class="form-control task-element" 
                   placeholder="Enter task (e.g., A, B, C)" data-index="${i}" maxlength="1">
        `;
        taskInputs.appendChild(inputGroup);
    }
    
    // Show cooldown input and perform button
    performTaskSchedulingBtn.style.display = 'block';
    cooldownPeriod.focus();
    
    showNotification(`Task count set to ${size}. Please enter ${size} tasks and cooldown period.`, 'success');
    logOperation(`Task count set to ${size}`, 'info');
}

// NEW: Perform Task Scheduling Handler
function handlePerformTaskScheduling() {
    const cooldown = parseInt(cooldownPeriod.value);
    
    if (isNaN(cooldown) || cooldown < 0) {
        showNotification('Please enter a valid cooldown period ( 0)', 'danger');
        cooldownPeriod.focus();
        return;
    }
    
    // Collect tasks
    const taskInputs = document.querySelectorAll('.task-element');
    taskSchedulerTasks = [];
    
    for (let i = 0; i < taskInputs.length; i++) {
        const value = taskInputs[i].value.trim().toUpperCase();
        if (value === '') {
            showNotification(`Please enter all tasks. Missing task at position ${i + 1}`, 'danger');
            taskInputs[i].focus();
            return;
        }
        taskSchedulerTasks.push(value);
    }
    
    taskSchedulerCooldown = cooldown;
    
    // Store original array
    originalArrayForTaskScheduler = [...myArray];
    
    // Hide input group
    taskSchedulerGroup.style.display = 'none';
    
    // Start task scheduling visualization
    showTaskSchedulingVisualization();
}

// NEW: Cancel Task Scheduling Handler
function handleCancelTaskScheduling() {
    taskSchedulerGroup.style.display = 'none';
    taskArraySize.value = '';
    cooldownPeriod.value = '';
    taskInputs.innerHTML = '';
    performTaskSchedulingBtn.style.display = 'none';
    
    taskSchedulerTasks = [];
    taskSchedulerCooldown = 0;
    
    logOperation('Cancelled task scheduling operation', 'info');
    showNotification('Task scheduling operation cancelled', 'info');
}
// NEW: Show Task Scheduling Visualization
function showTaskSchedulingVisualization() {
    isTaskSchedulerRunning = true;
    
    const schedulerContainer = document.createElement('div');
    schedulerContainer.className = 'task-scheduler-container';
    schedulerContainer.innerHTML = `
        <h5 class="text-center mb-3">Task Scheduler with Cooldown Period</h5>
        
        <div class="array-group">
            <div class="array-label">Original Tasks</div>
            <div class="original-array-container" id="originalTasksDisplay"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Cooldown Period:</strong> ${taskSchedulerCooldown} time units between same tasks</p>
            <p class="mb-0" id="taskSchedulerExplanation">Initializing task scheduler...</p>
        </div>
        
        <div class="task-execution-timeline" id="executionTimeline">
            <!-- Execution timeline will be generated here -->
        </div>
        
        <div class="execution-stats">
            <p class="mb-2" id="currentStats">Ready to start execution...</p>
            <div class="stats-card">
                <div>Total Time Units Required</div>
                <div class="stats-value" id="totalTimeUnits">0</div>
            </div>
        </div>
        
        <div class="algorithm-steps mt-3" id="taskSchedulerStepsContainer">
            <h6 class="text-center">Task Scheduling Steps</h6>
            <div class="steps-container" id="taskSchedulerSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterTaskScheduling" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(schedulerContainer);
    
    // Display original tasks
    renderArrayInContainer(taskSchedulerTasks, 'originalTasksDisplay');
    
    // Start task scheduling animation
    performTaskSchedulingAnimation();
}

// NEW: Perform Task Scheduling Animation
function performTaskSchedulingAnimation() {
    const explanation = document.getElementById('taskSchedulerExplanation');
    const timeline = document.getElementById('executionTimeline');
    const currentStats = document.getElementById('currentStats');
    const totalTimeUnits = document.getElementById('totalTimeUnits');
    const stepsContainer = document.getElementById('taskSchedulerSteps');
    const continueButton = document.getElementById('continueAfterTaskScheduling');
    
    const tasks = [...taskSchedulerTasks];
    const cooldown = taskSchedulerCooldown;
    
    let executionSequence = [];
    let lastExecution = {};
    let currentTime = 0;
    let taskIndex = 0;
    let step = 0;
    
    function executeNextTask() {
        if (taskIndex >= tasks.length) {
            // All tasks completed
            explanation.innerHTML = `<strong>Task Scheduling Completed!</strong> All tasks executed successfully.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> All ${tasks.length} tasks completed in ${currentTime} time units
                </div>
            `;
            
            totalTimeUnits.textContent = currentTime;
            currentStats.innerHTML = `<strong>Final Result:</strong> ${tasks.length} tasks completed in ${currentTime} time units`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterTaskScheduling();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterTaskScheduling);
            
            return;
        }
        
        const currentTask = tasks[taskIndex];
        step++;
        
        // Check if task is in cooldown
        if (currentTask in lastExecution && currentTime <= lastExecution[currentTask] + cooldown) {
            // Task is in cooldown, need to wait
            const waitTime = lastExecution[currentTask] + cooldown - currentTime + 1;
            
            explanation.innerHTML = `Task '${currentTask}' is in cooldown. Waiting ${waitTime} time unit(s)...`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Task '${currentTask}' in cooldown. Inserting ${waitTime} IDLE slot(s)
                </div>
            `;
            
            // Add idle time slots
            for (let i = 0; i < waitTime; i++) {
                executionSequence.push({ time: currentTime, task: "IDLE", type: "idle" });
                createTimeSlot(currentTime, "IDLE", "idle");
                currentTime++;
                step++;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step}:</strong> Time ${currentTime - 1}: IDLE (waiting for cooldown)
                    </div>
                `;
                
                // Update stats
                currentStats.innerHTML = `Time ${currentTime}: Waiting for cooldown...`;
                totalTimeUnits.textContent = currentTime;
            }
            
            // Scroll steps container
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            // After waiting, execute the task
            setTimeout(() => {
                executeCurrentTask();
            }, waitTime * 1000);
            
        } else {
            // Task can be executed immediately
            executeCurrentTask();
        }
        
        function executeCurrentTask() {
            // Execute the task
            executionSequence.push({ time: currentTime, task: currentTask, type: "task" });
            
            explanation.innerHTML = `Time ${currentTime}: Executing task '${currentTask}'`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Time ${currentTime}: Executing task '${currentTask}'
                </div>
            `;
            
            // Create and highlight the time slot
            createTimeSlot(currentTime, currentTask, "executing");
            
            // Update last execution time
            lastExecution[currentTask] = currentTime;
            
            // Update stats
            currentStats.innerHTML = `Time ${currentTime}: Executing '${currentTask}' | Completed: ${taskIndex + 1}/${tasks.length} tasks`;
            totalTimeUnits.textContent = currentTime + 1;
            
            // Move to next time unit and task
            currentTime++;
            taskIndex++;
            
            // Scroll steps container
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            // Continue with next task after delay
            setTimeout(executeNextTask, 1500);
        }
    }
    
    function createTimeSlot(time, task, type) {
        const timeSlot = document.createElement('div');
        timeSlot.className = 'time-slot';
        timeSlot.innerHTML = `
            <div class="time-label">T=${time}</div>
            <div class="task-slot ${type === 'executing' ? 'task-executing' : type === 'idle' ? 'task-idle' : 'task-pending'}">
                ${task}
            </div>
            ${type === 'idle' ? '<div class="cooldown-indicator">IDLE</div>' : ''}
        `;
        
        timeline.appendChild(timeSlot);
        
        // Scroll timeline to show latest slot
        timeline.scrollLeft = timeline.scrollWidth;
    }
    
    // Start execution
    executeNextTask();
}

// NEW: Return to Original after Task Scheduling
function returnToOriginalAfterTaskScheduling() {
    // Reset to original array
    myArray = [...originalArrayForTaskScheduler];
    originalArrayForTaskScheduler = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isTaskSchedulerRunning = false;
    
    // Clear all task scheduler data
    taskSchedulerTasks = [];
    taskSchedulerCooldown = 0;
    
    // Reset input groups
    taskSchedulerGroup.style.display = 'none';
    taskArraySize.value = '';
    cooldownPeriod.value = '';
    taskInputs.innerHTML = '';
    performTaskSchedulingBtn.style.display = 'none';
    
    logOperation('Task scheduling completed - returned to original array', 'info');
    showNotification('Returned to original array after task scheduling', 'success');
}
// NEW: Partition Array into Disjoint Intervals Handler
function handlePartitionDisjoint() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isPartitionRunning) {
        showNotification('Partition operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Partition operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    if (myArray.length < 2) {
        showNotification('Array must have at least 2 elements for partitioning', 'warning');
        return;
    }
    
    isPartitionRunning = true;
    
    // Store original array
    originalArrayForPartition = [...myArray];
    
    // Show partition visualization
    showPartitionVisualization();
}
// NEW: Show Partition Visualization
function showPartitionVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Partition Array into Disjoint Intervals</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalPartitionArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Partitioned Array</div>
            <div class="transformed-array-container" id="partitionedArray"></div>
        </div>
        
        <div class="partition-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Partition array such that every element in left  every element in right</p>
            <p class="mb-0" id="partitionExplanation">Initializing partition algorithm...</p>
        </div>
        
        <div class="partition-results mt-3" id="partitionResults" style="display: none;">
            <h6 class="text-center">Partition Results</h6>
            <div class="stats-card">
                <div>Partition Index</div>
                <div class="stats-value" id="partitionIndexValue">-</div>
            </div>
            <div class="stats-card">
                <div>Left Subarray</div>
                <div class="stats-value" id="leftSubarrayValue">-</div>
            </div>
            <div class="stats-card">
                <div>Right Subarray</div>
                <div class="stats-value" id="rightSubarrayValue">-</div>
            </div>
        </div>
        
        <div class="algorithm-steps mt-3" id="partitionStepsContainer">
            <h6 class="text-center">Partition Steps</h6>
            <div class="steps-container" id="partitionSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPartition" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForPartition, 'originalPartitionArray');
    renderArrayInContainer([...originalArrayForPartition], 'partitionedArray');
    
    performPartitionAnimation();
}

// NEW: Perform Partition Animation
function performPartitionAnimation() {
    const originalContainer = document.getElementById('originalPartitionArray');
    const partitionedContainer = document.getElementById('partitionedArray');
    const explanation = document.getElementById('partitionExplanation');
    const stepsContainer = document.getElementById('partitionSteps');
    const partitionResults = document.getElementById('partitionResults');
    const partitionIndexValue = document.getElementById('partitionIndexValue');
    const leftSubarrayValue = document.getElementById('leftSubarrayValue');
    const rightSubarrayValue = document.getElementById('rightSubarrayValue');
    const continueButton = document.getElementById('continueAfterPartition');
    
    const nums = originalArrayForPartition.map(val => parseFloat(val));
    const n = nums.length;
    
    // Step 1: Precompute the minimum from right side
    explanation.innerHTML = "Step 1: Precomputing minimum values from right side...";
    
    let rightMin = new Array(n);
    rightMin[n-1] = nums[n-1];
    
    let step = 0;
    
    function performPartitionStep() {
        if (step === 0) {
            // Initialize rightMin array
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step + 1}:</strong> Initialize rightMin[${n-1}] = ${nums[n-1]}
                </div>
            `;
            
            // Highlight last element
            const originalElements = originalContainer.querySelectorAll('.array-element');
            originalElements[n-1].querySelector('.element-value').classList.add('partition-current-right');
            
            setTimeout(() => {
                step++;
                performPartitionStep();
            }, 1500);
            
        } else if (step <= n-1) {
            // Compute rightMin for remaining positions
            const i = n - 1 - step;
            rightMin[i] = Math.min(nums[i+1], rightMin[i+1]);
            
            explanation.innerHTML = `Step 1: Computing rightMin[${i}] = min(${nums[i+1]}, ${rightMin[i+1]}) = ${rightMin[i]}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step + 1}:</strong> rightMin[${i}] = min(nums[${i+1}]=${nums[i+1]}, rightMin[${i+1}]=${rightMin[i+1]}) = ${rightMin[i]}
                </div>
            `;
            
            // Highlight current computation
            const originalElements = originalContainer.querySelectorAll('.array-element');
            originalElements[i+1].querySelector('.element-value').classList.add('partition-current-right');
            
            setTimeout(() => {
                originalElements[i+1].querySelector('.element-value').classList.remove('partition-current-right');
                step++;
                performPartitionStep();
            }, 1500);
            
        } else if (step === n) {
            // Step 2: Find partition point
            explanation.innerHTML = "Step 2: Finding partition point by tracking left maximum...";
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step + 1}:</strong> Starting partition search with leftMax = ${nums[0]}
                </div>
            `;
            
            let leftMax = nums[0];
            let partitionIndex = -1;
            
            // Highlight first element as initial leftMax
            const originalElements = originalContainer.querySelectorAll('.array-element');
            originalElements[0].querySelector('.element-value').classList.add('partition-current-left');
            
            setTimeout(() => {
                findPartitionPoint(0, leftMax, partitionIndex);
            }, 1500);
            
        }
    }
    
    function findPartitionPoint(i, leftMax, partitionIndex) {
        if (i >= n-1) {
            // Partition search completed
            if (partitionIndex === -1) {
                partitionIndex = n;
            }
            
            explanation.innerHTML = `<strong>Partition Found!</strong> Index = ${partitionIndex}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Partition index = ${partitionIndex}
                </div>
            `;
            
            // Display results
            const leftSubarray = nums.slice(0, partitionIndex);
            const rightSubarray = nums.slice(partitionIndex);
            
            partitionIndexValue.textContent = partitionIndex;
            leftSubarrayValue.textContent = `[${leftSubarray.join(', ')}]`;
            rightSubarrayValue.textContent = `[${rightSubarray.join(', ')}]`;
            partitionResults.style.display = 'block';
            
            // Highlight the partitioned arrays
            const partitionedElements = partitionedContainer.querySelectorAll('.array-element');
            
            // Highlight left subarray
            for (let j = 0; j < partitionIndex; j++) {
                setTimeout(() => {
                    partitionedElements[j].querySelector('.element-value').classList.add('partition-left');
                }, j * 200);
            }
            
            // Highlight right subarray
            for (let j = partitionIndex; j < n; j++) {
                setTimeout(() => {
                    partitionedElements[j].querySelector('.element-value').classList.add('partition-right');
                }, (j - partitionIndex) * 200 + partitionIndex * 200);
            }
            
            // Highlight partition boundary
            setTimeout(() => {
                if (partitionIndex > 0 && partitionIndex < n) {
                    partitionedElements[partitionIndex-1].querySelector('.element-value').classList.add('partition-boundary');
                }
            }, n * 200 + 500);
            
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterPartition();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterPartition);
            
            return;
        }
        
        step++;
        const currentStep = step;
        
        // Check if current position is valid partition
        if (leftMax <= rightMin[i]) {
            partitionIndex = i + 1;
            
            explanation.innerHTML = `Found partition! leftMax(${leftMax})  rightMin[${i}](${rightMin[i]})`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${currentStep + 1}:</strong> Partition found at index ${partitionIndex} (leftMax=${leftMax}  rightMin[${i}]=${rightMin[i]})
                </div>
            `;
            
            // Highlight the partition point
            const originalElements = originalContainer.querySelectorAll('.array-element');
            originalElements[i].querySelector('.element-value').classList.add('partition-boundary');
            
            setTimeout(() => {
                findPartitionPoint(n, leftMax, partitionIndex); // Force completion
            }, 2000);
            
        } else {
            explanation.innerHTML = `Checking position ${i}: leftMax(${leftMax}) > rightMin[${i}](${rightMin[i]}) - Continue searching`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${currentStep + 1}:</strong> leftMax=${leftMax} > rightMin[${i}]=${rightMin[i]} - Continue search
                </div>
            `;
            
            // Update leftMax with next element
            leftMax = Math.max(leftMax, nums[i+1]);
            
            // Highlight the update
            const originalElements = originalContainer.querySelectorAll('.array-element');
            originalElements[i+1].querySelector('.element-value').classList.add('partition-current-left');
            
            setTimeout(() => {
                originalElements[i].querySelector('.element-value').classList.remove('partition-current-left');
                findPartitionPoint(i+1, leftMax, partitionIndex);
            }, 1500);
        }
    }
    
    // Start partition process
    performPartitionStep();
}

// NEW: Return to Original after Partition
function returnToOriginalAfterPartition() {
    // Reset to original array
    myArray = [...originalArrayForPartition];
    originalArrayForPartition = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isPartitionRunning = false;
    
    logOperation('Partition operation completed - returned to original array', 'info');
    showNotification('Returned to original array after partition operation', 'success');
}
// Helper function to render array in specific container
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = '<div class="array-empty-state"><i class="fas fa-layer-group"></i><h4>Array is Empty</h4></div>';
        return;
    }
    
    array.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}
// NEW: Partition Array Handler
function handlePartitionArray() {
    const k = parseInt(partitionKValue.value);
    const n = myArray.length;
    
    // Validation
    if (isNaN(k) || k < 1 || k > n) {
        showNotification(`Please enter a valid k value between 1 and ${n}`, 'danger');
        partitionKValue.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Partition operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    if (isPartitionMaxSumRunning) {
        showNotification('A partition operation is already in progress', 'warning');
        return;
    }
    
    isPartitionMaxSumRunning = true;
    
    // Store original array
    originalArrayForPartitionMaxSum = [...myArray];
    
    // Perform partition visualization
    performPartitionVisualization(k);
}

// NEW: Perform Partition Visualization
function performPartitionVisualization(k) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Partition Array for Maximum Sum (k = ${k})</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalPartitionArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">DP Table Visualization</div>
            <div class="transformed-array-container" id="dpTableContainer"></div>
        </div>
        
        <div class="partition-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Partition array into subarrays of length  k to maximize sum</p>
            <p class="mb-0" id="partitionExplanation">Initializing partition algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="partitionStepsContainer">
            <h6 class="text-center">Partition Algorithm Steps</h6>
            <div class="steps-container" id="partitionSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Maximum Partition Sum</div>
            <div class="stats-value" id="maxPartitionSumValue">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPartition" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForPartitionMaxSum, 'originalPartitionArray');
    
    // Start partition algorithm animation
    executePartitionAlgorithm(k);
}

// NEW: Execute Partition Algorithm with Animation
function executePartitionAlgorithm(k) {
    const originalContainer = document.getElementById('originalPartitionArray');
    const dpTableContainer = document.getElementById('dpTableContainer');
    const explanation = document.getElementById('partitionExplanation');
    const stepsContainer = document.getElementById('partitionSteps');
    const maxPartitionSumValue = document.getElementById('maxPartitionSumValue');
    const continueButton = document.getElementById('continueAfterPartition');
    
    const arr = originalArrayForPartitionMaxSum.map(val => parseFloat(val));
    const n = arr.length;
    let dp = new Array(n + 1).fill(0);
    let step = 0;
    
    function executePartitionStep(i) {
        if (i > n) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Partition Algorithm Completed!</strong> Maximum sum = ${dp[n]}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Maximum partition sum = ${dp[n]}
                </div>
            `;
            
            maxPartitionSumValue.textContent = dp[n];
            
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterPartition();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterPartition);
            
            return;
        }
        
        step++;
        
        if (i === 0) {
            // Initialize
            explanation.innerHTML = `Step ${step}: Initialize DP table with dp[0] = 0`;
            
            // Create initial DP table
            updateDPTable(dp, n, -1);
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Initialize dp[0] = 0
                </div>
            `;
            
            setTimeout(() => {
                executePartitionStep(1);
            }, 1500);
            
        } else {
            explanation.innerHTML = `Step ${step}: Calculating dp[${i}]`;
            
            let currentMax = 0;
            let bestValue = 0;
            
            // Highlight current position in array
            const originalElements = originalContainer.querySelectorAll('.array-element');
            if (i-1 < originalElements.length) {
                originalElements[i-1].querySelector('.element-value').classList.add('partition-highlight');
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Processing element at position ${i-1} (value = ${arr[i-1]})
                </div>
            `;
            
            function processSubarray(j) {
                if (j > Math.min(k, i)) {
                    // Finished processing all possible subarray lengths
                    dp[i] = bestValue;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step}.${j}:</strong> Set dp[${i}] = ${bestValue}
                        </div>
                    `;
                    
                    // Update DP table
                    updateDPTable(dp, n, i);
                    
                    // Remove highlights
                    const allElements = originalContainer.querySelectorAll('.array-element');
                    allElements.forEach(el => {
                        el.querySelector('.element-value').classList.remove('partition-highlight', 'partition-max');
                    });
                    
                    setTimeout(() => {
                        executePartitionStep(i + 1);
                    }, 2000);
                    
                    return;
                }
                
                const currentIndex = i - j;
                currentMax = Math.max(currentMax, arr[currentIndex]);
                
                explanation.innerHTML = `Step ${step}.${j}: Checking subarray length ${j}, current max = ${currentMax}`;
                
                // Highlight the current subarray
                const originalElements = originalContainer.querySelectorAll('.array-element');
                for (let idx = currentIndex; idx < i; idx++) {
                    if (idx >= 0) {
                        const valueDiv = originalElements[idx].querySelector('.element-value');
                        valueDiv.classList.add('partition-highlight');
                        if (idx === currentIndex) {
                            valueDiv.classList.add('partition-max');
                        }
                    }
                }
                
                const candidate = dp[i - j] + currentMax * j;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step ${candidate > bestValue ? 'active' : ''}">
                        <strong>Step ${step}.${j}:</strong> dp[${i-j}] + ${currentMax}  ${j} = ${candidate}
                        ${candidate > bestValue ? ' (NEW BEST!)' : ''}
                    </div>
                `;
                
                if (candidate > bestValue) {
                    bestValue = candidate;
                }
                
                setTimeout(() => {
                    // Remove highlights for next iteration
                    const allElements = originalContainer.querySelectorAll('.array-element');
                    allElements.forEach(el => {
                        el.querySelector('.element-value').classList.remove('partition-highlight', 'partition-max');
                    });
                    
                    processSubarray(j + 1);
                }, 2000);
            }
            
            // Start processing subarrays for current position
            setTimeout(() => {
                processSubarray(1);
            }, 1500);
        }
    }
    
    // Start partition algorithm
    executePartitionStep(0);
}

// NEW: Update DP Table
function updateDPTable(dp, n, currentIndex) {
    const dpTableContainer = document.getElementById('dpTableContainer');
    
    let tableHTML = `
        <table class="dp-table">
            <thead>
                <tr>
                    <th>i</th>
    `;
    
    // Create header row
    for (let i = 0; i <= n; i++) {
        tableHTML += `<th>${i}</th>`;
    }
    
    tableHTML += `
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>dp[i]</strong></td>
    `;
    
    // Create data row
    for (let i = 0; i <= n; i++) {
        const isCurrent = i === currentIndex;
        const isHighlight = i <= currentIndex && dp[i] > 0;
        
        tableHTML += `
            <td class="${isCurrent ? 'dp-current' : ''} ${isHighlight ? 'dp-highlight' : ''}">
                ${dp[i]}
            </td>
        `;
    }
    
    tableHTML += `
                </tr>
            </tbody>
        </table>
    `;
    
    dpTableContainer.innerHTML = tableHTML;
}

// NEW: Return to Original after Partition
function returnToOriginalAfterPartition() {
    // Reset to original array
    myArray = [...originalArrayForPartitionMaxSum];
    originalArrayForPartitionMaxSum = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isPartitionMaxSumRunning = false;
    
    // Clear input
    partitionKValue.value = '';
    
    logOperation('Partition operation completed - returned to original array', 'info');
    showNotification('Returned to original array after partition operation', 'success');
}
// NEW: Partition Labels Operation Handler
function handlePartitionLabelsOperation() {
    const inputString = partitionLabelsStringInput.value.trim();
    
    if (inputString === '') {
        showNotification('Please enter a string to partition', 'danger');
        partitionLabelsStringInput.focus();
        return;
    }
    
    if (isPartitionLabelsOperationRunning) {
        showNotification('Partition labels operation is already in progress', 'warning');
        return;
    }
    
    // Store original array
    originalArrayBeforePartitionLabels = [...myArray];
    
    // Start partition labels visualization
    showPartitionLabelsOperationVisualization(inputString);
}
// NEW: Show Partition Labels Operation Visualization
function showPartitionLabelsOperationVisualization(inputString) {
    isPartitionLabelsOperationRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Partition Labels Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Input String: "${inputString}"</div>
            <div class="original-array-container" id="partitionLabelsStringArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Partitioning Process</div>
            <div class="transformed-array-container" id="partitionLabelsProcessArray"></div>
        </div>
        
        <div class="partition-labels-explanation">
            <p class="mb-2"><strong>Partition Labels Algorithm:</strong> Partition string where each character appears in only one partition</p>
            <p class="mb-0" id="partitionLabelsExplanation">Initializing partition algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="partitionLabelsStepsContainer">
            <h6 class="text-center">Partition Steps</h6>
            <div class="steps-container" id="partitionLabelsSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Partition Sizes</div>
            <div class="stats-value" id="partitionLabelsSizesResult">[]</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Actual Partitions</div>
            <div class="stats-value" id="partitionLabelsStringsResult">[]</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPartitionLabels" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Convert string to array for visualization
    const stringArray = inputString.split('').map((char, index) => `${char}(${index})`);
    renderArrayInContainer(stringArray, 'partitionLabelsStringArray');
    renderArrayInContainer([...stringArray], 'partitionLabelsProcessArray');
    
    // Start partition labels algorithm animation
    performPartitionLabelsAlgorithm(inputString);
}
// NEW: Perform Partition Labels Algorithm Animation
function performPartitionLabelsAlgorithm(inputString) {
    const originalContainer = document.getElementById('partitionLabelsStringArray');
    const processContainer = document.getElementById('partitionLabelsProcessArray');
    const explanation = document.getElementById('partitionLabelsExplanation');
    const stepsContainer = document.getElementById('partitionLabelsSteps');
    const partitionLabelsSizesResult = document.getElementById('partitionLabelsSizesResult');
    const partitionLabelsStringsResult = document.getElementById('partitionLabelsStringsResult');
    const continueButton = document.getElementById('continueAfterPartitionLabels');
    
    const inputStr = inputString;
    const lastOccurrenceMap = {};
    let partitionSizesList = [];
    let partitionStringsList = [];
    let partitionStartIndex = 0;
    let partitionEndIndex = 0;
    let algorithmStepCounter = 0;
    
    // Step 1: Find last occurrence of each character
    function findLastOccurrenceStep(currentIndex) {
        if (currentIndex >= inputStr.length) {
            explanation.innerHTML = 'Step 1 completed: Found last occurrence of all characters';
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1 Complete:</strong> Last occurrence mapping: ${JSON.stringify(lastOccurrenceMap)}
                </div>
            `;
            
            // Move to partitioning step
            setTimeout(() => {
                performPartitioningStep(0);
            }, 2000);
            return;
        }
        
        const currentChar = inputStr[currentIndex];
        lastOccurrenceMap[currentChar] = currentIndex;
        
        explanation.innerHTML = `Step 1: Last occurrence of '${currentChar}' is at index ${currentIndex}`;
        
        // Highlight current character
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentIndex].querySelector('.element-value');
        currentElement.classList.add('partition-labels-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step 1:</strong> Character '${currentChar}' last seen at index ${currentIndex}
            </div>
        `;
        
        setTimeout(() => {
            currentElement.classList.remove('partition-labels-current');
            currentElement.classList.add('partition-labels-included');
            
            findLastOccurrenceStep(currentIndex + 1);
        }, 1000);
    }
    
    // Step 2: Perform partitioning
    function performPartitioningStep(currentIndex) {
        if (currentIndex >= inputStr.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Partitioning Completed!</strong> String partitioned into ${partitionSizesList.length} segments.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Partitioning completed! Total partitions: ${partitionSizesList.length}
                </div>
            `;
            
            // Highlight all partitions
            const processElements = processContainer.querySelectorAll('.array-element');
            let currentPosition = 0;
            
            partitionSizesList.forEach((partitionSize, partitionIndex) => {
                const partitionEndPosition = currentPosition + partitionSize - 1;
                const partitionText = inputStr.substring(currentPosition, partitionEndPosition + 1);
                
                // Highlight each partition with delay
                setTimeout(() => {
                    for (let j = currentPosition; j <= partitionEndPosition; j++) {
                        processElements[j].querySelector('.element-value').classList.add('partition-labels-completed');
                    }
                    
                    // Add boundary after partition (except for last one)
                    if (partitionIndex < partitionSizesList.length - 1) {
                        processElements[partitionEndPosition].classList.add('partition-labels-boundary');
                    }
                }, partitionIndex * 500);
                
                currentPosition += partitionSize;
            });
            
            partitionLabelsSizesResult.textContent = JSON.stringify(partitionSizesList);
            partitionLabelsStringsResult.textContent = JSON.stringify(partitionStringsList);
            
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterPartitionLabels();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterPartitionLabels);
            
            return;
        }
        
        algorithmStepCounter++;
        const currentChar = inputStr[currentIndex];
        
        // Update partitionEndIndex to be the maximum of current partitionEndIndex and last occurrence of current char
        partitionEndIndex = Math.max(partitionEndIndex, lastOccurrenceMap[currentChar]);
        
        explanation.innerHTML = `Step 2: i=${currentIndex}, char='${currentChar}', current end=${partitionEndIndex}, last occurrence=${lastOccurrenceMap[currentChar]}`;
        
        // Highlight current processing
        const processElements = processContainer.querySelectorAll('.array-element');
        const currentElement = processElements[currentIndex].querySelector('.element-value');
        const endElement = processElements[partitionEndIndex].querySelector('.element-value');
        
        currentElement.classList.add('partition-labels-current');
        endElement.classList.add('partition-labels-boundary');
        
        // Highlight all characters in current window
        for (let j = partitionStartIndex; j <= partitionEndIndex; j++) {
            processElements[j].querySelector('.element-value').classList.add('partition-labels-included');
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${algorithmStepCounter}:</strong> i=${currentIndex}, char='${currentChar}'  end=max(${partitionEndIndex}, ${lastOccurrenceMap[currentChar]}) = ${partitionEndIndex}
            </div>
        `;
        
        // Check if we've reached the end of current partition
        if (currentIndex === partitionEndIndex) {
            setTimeout(() => {
                const currentPartitionSize = partitionEndIndex - partitionStartIndex + 1;
                const currentPartitionString = inputStr.substring(partitionStartIndex, partitionEndIndex + 1);
                
                partitionSizesList.push(currentPartitionSize);
                partitionStringsList.push(currentPartitionString);
                
                explanation.innerHTML = `Partition found! Size: ${currentPartitionSize}, String: "${currentPartitionString}"`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Partition ${partitionSizesList.length}:</strong> Size=${currentPartitionSize}, String="${currentPartitionString}"
                    </div>
                `;
                
                // Highlight the completed partition
                for (let j = partitionStartIndex; j <= partitionEndIndex; j++) {
                    processElements[j].querySelector('.element-value').classList.remove('partition-labels-included');
                    processElements[j].querySelector('.element-value').classList.add('partition-labels-completed');
                }
                
                // Add boundary
                if (currentIndex < inputStr.length - 1) {
                    processElements[partitionEndIndex].classList.add('partition-labels-boundary');
                }
                
                // Remove highlights
                currentElement.classList.remove('partition-labels-current');
                endElement.classList.remove('partition-labels-boundary');
                
                // Move partitionStartIndex to next position
                partitionStartIndex = currentIndex + 1;
                
                performPartitioningStep(currentIndex + 1);
            }, 2000);
        } else {
            setTimeout(() => {
                // Remove temporary highlights
                currentElement.classList.remove('partition-labels-current');
                endElement.classList.remove('partition-labels-boundary');
                
                performPartitioningStep(currentIndex + 1);
            }, 1500);
        }
    }
    
    // Start the algorithm
    findLastOccurrenceStep(0);
}
// NEW: Return to Original after Partition Labels
function returnToOriginalAfterPartitionLabels() {
    // Reset to original array
    myArray = [...originalArrayBeforePartitionLabels];
    originalArrayBeforePartitionLabels = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isPartitionLabelsOperationRunning = false;
    
    // Clear input
    partitionLabelsStringInput.value = '';
    
    logOperation('Partition labels operation completed - returned to original array', 'info');
    showNotification('Returned to original array after partition labels operation', 'success');
}
// NEW: Split Array Largest Sum Handler
function handleSplitArrayLargestSum() {
    const k = parseInt(splitArrayK.value);
    const n = myArray.length;
    
    if (isNaN(k) || k < 1 || k > n) {
        showNotification(`Please enter a valid k value between 1 and ${n}`, 'danger');
        splitArrayK.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Split Array Largest Sum requires all array elements to be numbers', 'danger');
        return;
    }
    
    if (isSplitArrayRunning) {
        showNotification('Split array operation is already in progress', 'warning');
        return;
    }
    
    isSplitArrayRunning = true;
    
    // Store original array
    originalArrayForSplit = [...myArray];
    
    // Perform split array visualization
    performSplitArrayVisualization(k);
}

// NEW: Perform Split Array Visualization
function performSplitArrayVisualization(k) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Split Array Largest Sum (k = ${k})</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalSplitArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Binary Search & Split Process</div>
            <div class="transformed-array-container" id="transformedSplitArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Binary search to find minimal largest sum when splitting into ${k} subarrays</p>
            <p class="mb-0" id="splitExplanation">Initializing binary search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="splitStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="splitSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Minimal Largest Sum</div>
            <div class="stats-value" id="minLargestSumValue">-</div>
        </div>
        
        <div id="finalSubarrays" class="mt-3" style="display: none;">
            <h6 class="text-center">Final Subarrays</h6>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSplit" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSplit, 'originalSplitArray');
    renderArrayInContainer([...originalArrayForSplit], 'transformedSplitArray');
    
    executeSplitArrayAlgorithm(k);
}

// NEW: Execute Split Array Algorithm with Animation
function executeSplitArrayAlgorithm(k) {
    const arrayContainer = document.getElementById('transformedSplitArray');
    const explanation = document.getElementById('splitExplanation');
    const stepsContainer = document.getElementById('splitSteps');
    const minLargestSumValue = document.getElementById('minLargestSumValue');
    const finalSubarrays = document.getElementById('finalSubarrays');
    const continueButton = document.getElementById('continueAfterSplit');
    
    const nums = originalArrayForSplit.map(val => parseFloat(val));
    let step = 0;
    
    // Helper function to check if we can split with given max sum
    function canSplit(maxSum) {
        let currentSum = 0;
        let splitsNeeded = 1;
        const splitPoints = [0]; // Start of first subarray
        
        for (let i = 0; i < nums.length; i++) {
            if (currentSum + nums[i] <= maxSum) {
                currentSum += nums[i];
            } else {
                splitsNeeded++;
                currentSum = nums[i];
                splitPoints.push(i);
                if (splitsNeeded > k) {
                    return { canSplit: false, splitPoints };
                }
            }
        }
        splitPoints.push(nums.length); // End of last subarray
        return { canSplit: true, splitPoints };
    }
    
    // Binary search bounds
    let left = Math.max(...nums);
    let right = nums.reduce((sum, num) => sum + num, 0);
    let result = right;
    
    function performBinarySearchStep() {
        if (left > right) {
            // Binary search completed
            explanation.innerHTML = `<strong>Binary Search Completed!</strong> Minimal largest sum = ${result}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Binary search completed. Minimal largest sum = ${result}
                </div>
            `;
            
            minLargestSumValue.textContent = result;
            
            // Show final splitting
            showFinalSplitting(result);
            return;
        }
        
        const mid = Math.floor((left + right) / 2);
        step++;
        
        explanation.innerHTML = `Binary Search Step ${step}: Testing maxSum = ${mid} (range: ${left}-${right})`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> Testing maxSum = ${mid}, Range = [${left}, ${right}]
            </div>
        `;
        
        // Highlight current mid value being tested
        const elements = arrayContainer.querySelectorAll('.array-element');
        elements.forEach(el => {
            el.querySelector('.element-value').classList.add('split-current');
        });
        
        setTimeout(() => {
            const { canSplit: canSplitResult, splitPoints } = canSplit(mid);
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${canSplitResult ? 'active' : ''}">
                    <strong>Test ${step}:</strong> maxSum = ${mid}  ${canSplitResult ? 'CAN split' : 'CANNOT split'}
                </div>
            `;
            
            if (canSplitResult) {
                explanation.innerHTML = `maxSum = ${mid}  CAN split (moving left)`;
                result = mid;
                right = mid - 1;
                
                // Show successful split visualization
                showSplitVisualization(splitPoints, mid, true);
            } else {
                explanation.innerHTML = `maxSum = ${mid}  CANNOT split (moving right)`;
                left = mid + 1;
                
                // Show failed split visualization
                showSplitVisualization(splitPoints, mid, false);
            }
            
            // Remove current highlights
            setTimeout(() => {
                elements.forEach(el => {
                    el.querySelector('.element-value').classList.remove('split-current');
                });
                
                // Continue binary search
                performBinarySearchStep();
            }, 2000);
        }, 1500);
    }
    
    function showSplitVisualization(splitPoints, maxSum, isSuccessful) {
        const elements = arrayContainer.querySelectorAll('.array-element');
        
        // Highlight subarrays with different colors
        for (let i = 0; i < splitPoints.length - 1; i++) {
            const start = splitPoints[i];
            const end = splitPoints[i + 1];
            let subarraySum = 0;
            
            for (let j = start; j < end; j++) {
                elements[j].querySelector('.element-value').classList.add('split-included');
                subarraySum += nums[j];
            }
            
            // Highlight boundary if this is the problematic subarray
            if (!isSuccessful && subarraySum > maxSum && i < splitPoints.length - 2) {
                for (let j = start; j < end; j++) {
                    elements[j].querySelector('.element-value').classList.add('split-boundary');
                }
            }
        }
    }
    
    function showFinalSplitting(finalMaxSum) {
        const { splitPoints } = canSplit(finalMaxSum);
        const elements = arrayContainer.querySelectorAll('.array-element');
        finalSubarrays.style.display = 'block';
        finalSubarrays.innerHTML = '<h6 class="text-center">Final Subarrays</h6>';
        
        // Clear previous highlights
        elements.forEach(el => {
            const valueDiv = el.querySelector('.element-value');
            valueDiv.classList.remove('split-included', 'split-boundary', 'split-current');
        });
        
        // Create and display final subarrays
        for (let i = 0; i < splitPoints.length - 1; i++) {
            const start = splitPoints[i];
            const end = splitPoints[i + 1];
            const subarray = nums.slice(start, end);
            const subarraySum = subarray.reduce((sum, num) => sum + num, 0);
            
            // Highlight this subarray
            for (let j = start; j < end; j++) {
                setTimeout(() => {
                    elements[j].querySelector('.element-value').classList.add('split-optimal');
                }, (j - start) * 200);
            }
            
            // Create subarray display
            const subarrayDiv = document.createElement('div');
            subarrayDiv.className = 'split-subarray';
            subarrayDiv.innerHTML = `
                <div class="subarray-label">Subarray ${i + 1}</div>
                <div class="original-array-container" id="subarray${i}"></div>
                <div class="subarray-sum">Sum: ${subarraySum}</div>
            `;
            finalSubarrays.appendChild(subarrayDiv);
            
            // Render this subarray
            renderArrayInContainer(subarray, `subarray${i}`);
        }
        
        explanation.innerHTML = `<strong>Final Result:</strong> Array split into ${k} subarrays with minimal largest sum = ${finalMaxSum}`;
        
        continueButton.style.display = 'block';
        
        // Auto-return after 20 seconds
        setTimeout(() => {
            returnToOriginalAfterSplit();
        }, 20000);
        
        continueButton.addEventListener('click', returnToOriginalAfterSplit);
    }
    
    // Start binary search
    explanation.innerHTML = `Starting binary search: left = ${left}, right = ${right}`;
    stepsContainer.innerHTML = `
        <div class="algorithm-step active">
            <strong>Initial:</strong> Binary search range = [${left}, ${right}]
        </div>
    `;
    
    setTimeout(() => {
        performBinarySearchStep();
    }, 1000);
}

// NEW: Return to Original after Split Operation
function returnToOriginalAfterSplit() {
    // Reset to original array
    myArray = [...originalArrayForSplit];
    originalArrayForSplit = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isSplitArrayRunning = false;
    
    // Clear input
    splitArrayK.value = '';
    
    logOperation('Split array largest sum operation completed - returned to original array', 'info');
    showNotification('Returned to original array after split operation', 'success');
}
// Helper function to render array in a specific container
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = '<div class="array-empty-state"><i class="fas fa-layer-group"></i><h4>Array is Empty</h4></div>';
        return;
    }
    
    array.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}
// NEW: Split Array with Equal Sum Handler
function handleSplitEqualSum() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length < 3) {
        showNotification('Please add at least 3 elements to the array', 'danger');
        return;
    }
    
    if (isSplitEqualSumRunning) {
        showNotification('Split operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Split operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isSplitEqualSumRunning = true;
    
    // Store original array
    originalArrayForEqualSplit = [...myArray];
    
    // Start split visualization
    showSplitEqualSumVisualization();
}

// NEW: Show Split Equal Sum Visualization
function showSplitEqualSumVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Split Array into Three Equal Sum Parts</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="splitArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find if array can be split into three contiguous parts with equal sum</p>
            <p class="mb-0" id="splitExplanation">Initializing split algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="splitStepsContainer">
            <h6 class="text-center">Split Algorithm Steps</h6>
            <div class="steps-container" id="splitSteps"></div>
        </div>
        
        <div id="splitResult" class="mt-3"></div>
        
        <div id="splitPartsContainer" class="split-parts-container" style="display: none;"></div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSplit" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForEqualSplit, 'splitArray');
    
    performSplitEqualSumAlgorithm();
}

// NEW: Perform Split Equal Sum Algorithm with Animation
function performSplitEqualSumAlgorithm() {
    const arrayContainer = document.getElementById('splitArray');
    const explanation = document.getElementById('splitExplanation');
    const stepsContainer = document.getElementById('splitSteps');
    const resultContainer = document.getElementById('splitResult');
    const partsContainer = document.getElementById('splitPartsContainer');
    const continueButton = document.getElementById('continueAfterSplit');
    
    const nums = originalArrayForEqualSplit.map(val => parseFloat(val));
    const totalSum = nums.reduce((a, b) => a + b, 0);
    let step = 0;
    
    function executeStep() {
        switch (step) {
            case 0:
                // Step 1: Calculate total sum
                explanation.innerHTML = `Step 1: Calculating total sum of the array`;
                
                // Highlight all elements
                const elements = arrayContainer.querySelectorAll('.array-element');
                elements.forEach((el, index) => {
                    setTimeout(() => {
                        el.querySelector('.element-value').classList.add('equal-sum-current');
                    }, index * 200);
                });
                
                setTimeout(() => {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 1:</strong> Total sum = ${totalSum} (${nums.join(' + ')})
                        </div>
                    `;
                    
                    // Remove highlights
                    elements.forEach(el => {
                        el.querySelector('.element-value').classList.remove('equal-sum-current');
                    });
                    
                    step++;
                    executeStep();
                }, nums.length * 200 + 500);
                break;
                
            case 1:
                // Step 2: Check if divisible by 3
                explanation.innerHTML = `Step 2: Checking if total sum is divisible by 3`;
                
                const divisibleBy3 = totalSum % 3 === 0;
                
                setTimeout(() => {
                    if (divisibleBy3) {
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Step 2:</strong> ${totalSum}  3 = ${totalSum / 3} (Divisible by 3 )
                            </div>
                        `;
                    } else {
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Step 2:</strong> ${totalSum}  3 = ${(totalSum / 3).toFixed(2)} (Not divisible by 3 )
                            </div>
                        `;
                        
                        // Show failure result
                        resultContainer.innerHTML = `
                            <div class="equal-sum-result-error">
                                <h6 class="text-danger"><i class="fas fa-times-circle me-2"></i>Equal Sum Split Not Possible</h6>
                                <p class="mb-0">Total sum ${totalSum} is not divisible by 3</p>
                            </div>
                        `;
                        
                        explanation.innerHTML = `<strong>Algorithm Failed:</strong> Total sum not divisible by 3`;
                        
                        // Show continue button
                        continueButton.style.display = 'block';
                        continueButton.addEventListener('click', returnToOriginalAfterEqualSplit);
                        
                        // Auto-return after 20 seconds
                        setTimeout(returnToOriginalAfterEqualSplit, 20000);
                        return;
                    }
                    
                    step++;
                    executeStep();
                }, 1500);
                break;
                
            case 2:
                // Step 3: Find first split point
                const targetSum = totalSum / 3;
                explanation.innerHTML = `Step 3: Finding first split point (target sum = ${targetSum})`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step 3:</strong> Searching for first split point where cumulative sum = ${targetSum}
                    </div>
                `;
                
                findFirstSplitPoint(targetSum, 0);
                break;
        }
    }
    
    function findFirstSplitPoint(targetSum, currentIndex) {
        if (currentIndex >= nums.length - 2) {
            // No first split point found
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step 3 Failed:</strong> No first split point found
                </div>
            `;
            
            resultContainer.innerHTML = `
                <div class="equal-sum-result-error">
                    <h6 class="text-danger"><i class="fas fa-times-circle me-2"></i>Equal Sum Split Not Possible</h6>
                    <p class="mb-0">Cannot find first split point with sum = ${targetSum}</p>
                </div>
            `;
            
            explanation.innerHTML = `<strong>Algorithm Failed:</strong> No first split point found`;
            
            continueButton.style.display = 'block';
            continueButton.addEventListener('click', returnToOriginalAfterEqualSplit);
            setTimeout(returnToOriginalAfterEqualSplit, 20000);
            return;
        }
        
        const elements = arrayContainer.querySelectorAll('.array-element');
        
        // Highlight current element being processed
        if (currentIndex > 0) {
            elements[currentIndex - 1].querySelector('.element-value').classList.remove('equal-sum-current');
        }
        elements[currentIndex].querySelector('.element-value').classList.add('equal-sum-current');
        
        // Calculate cumulative sum up to current index
        let cumulativeSum = 0;
        for (let i = 0; i <= currentIndex; i++) {
            cumulativeSum += nums[i];
        }
        
        explanation.innerHTML = `Step 3: Checking index ${currentIndex}, cumulative sum = ${cumulativeSum}`;
        
        setTimeout(() => {
            if (cumulativeSum === targetSum) {
                // First split point found
                elements[currentIndex].querySelector('.element-value').classList.remove('equal-sum-current');
                elements[currentIndex].querySelector('.element-value').classList.add('equal-sum-split-point');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3 Success:</strong> First split point at index ${currentIndex} (sum = ${cumulativeSum})
                    </div>
                `;
                
                step++;
                findSecondSplitPoint(targetSum, currentIndex + 1, currentIndex);
            } else {
                // Continue searching
                currentIndex++;
                findFirstSplitPoint(targetSum, currentIndex);
            }
        }, 1000);
    }
    
    function findSecondSplitPoint(targetSum, currentIndex, firstSplit) {
        if (currentIndex >= nums.length - 1) {
            // No second split point found
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step 4 Failed:</strong> No second split point found
                </div>
            `;
            
            resultContainer.innerHTML = `
                <div class="equal-sum-result-error">
                    <h6 class="text-danger"><i class="fas fa-times-circle me-2"></i>Equal Sum Split Not Possible</h6>
                    <p class="mb-0">Cannot find second split point with sum = ${targetSum}</p>
                </div>
            `;
            
            explanation.innerHTML = `<strong>Algorithm Failed:</strong> No second split point found`;
            
            continueButton.style.display = 'block';
            continueButton.addEventListener('click', returnToOriginalAfterEqualSplit);
            setTimeout(returnToOriginalAfterEqualSplit, 20000);
            return;
        }
        
        const elements = arrayContainer.querySelectorAll('.array-element');
        
        // Highlight current element being processed
        if (currentIndex > firstSplit + 1) {
            elements[currentIndex - 1].querySelector('.element-value').classList.remove('equal-sum-current');
        }
        elements[currentIndex].querySelector('.element-value').classList.add('equal-sum-current');
        
        // Calculate cumulative sum from firstSplit+1 to currentIndex
        let cumulativeSum = 0;
        for (let i = firstSplit + 1; i <= currentIndex; i++) {
            cumulativeSum += nums[i];
        }
        
        explanation.innerHTML = `Step 4: Finding second split point at index ${currentIndex}, cumulative sum = ${cumulativeSum}`;
        
        setTimeout(() => {
            if (cumulativeSum === targetSum) {
                // Second split point found
                elements[currentIndex].querySelector('.element-value').classList.remove('equal-sum-current');
                elements[currentIndex].querySelector('.element-value').classList.add('equal-sum-split-point');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 4 Success:</strong> Second split point at index ${currentIndex} (sum = ${cumulativeSum})
                    </div>
                `;
                
                // Verify third part
                verifyThirdPart(targetSum, firstSplit, currentIndex);
            } else {
                // Continue searching
                currentIndex++;
                findSecondSplitPoint(targetSum, currentIndex, firstSplit);
            }
        }, 1000);
    }
    
    function verifyThirdPart(targetSum, firstSplit, secondSplit) {
        explanation.innerHTML = `Step 5: Verifying third part sum`;
        
        // Calculate third part sum
        let thirdSum = 0;
        for (let i = secondSplit + 1; i < nums.length; i++) {
            thirdSum += nums[i];
        }
        
        setTimeout(() => {
            if (thirdSum === targetSum) {
                // Success!
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 5 Success:</strong> Third part sum = ${thirdSum} 
                    </div>
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Array can be split into three equal sum parts!
                    </div>
                `;
                
                resultContainer.innerHTML = `
                    <div class="equal-sum-result-success">
                        <h6 class="text-success"><i class="fas fa-check-circle me-2"></i>Equal Sum Split Possible!</h6>
                        <p class="mb-0">Array successfully split into three parts with equal sum ${targetSum}</p>
                    </div>
                `;
                
                // Show the three parts
                showSplitParts(firstSplit, secondSplit);
                
            } else {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step 5 Failed:</strong> Third part sum = ${thirdSum} (expected ${targetSum}) 
                    </div>
                `;
                
                resultContainer.innerHTML = `
                    <div class="equal-sum-result-error">
                        <h6 class="text-danger"><i class="fas fa-times-circle me-2"></i>Equal Sum Split Not Possible</h6>
                        <p class="mb-0">Third part sum ${thirdSum}  ${targetSum}</p>
                    </div>
                `;
            }
            
            explanation.innerHTML = `<strong>Algorithm Completed!</strong>`;
            continueButton.style.display = 'block';
            continueButton.addEventListener('click', returnToOriginalAfterEqualSplit);
            setTimeout(returnToOriginalAfterEqualSplit, 20000);
        }, 1500);
    }
    
    function showSplitParts(firstSplit, secondSplit) {
        const part1 = nums.slice(0, firstSplit + 1);
        const part2 = nums.slice(firstSplit + 1, secondSplit + 1);
        const part3 = nums.slice(secondSplit + 1);
        
        partsContainer.style.display = 'flex';
        partsContainer.innerHTML = `
            <div class="split-part">
                <div class="split-part-title">Part 1 (Sum: ${part1.reduce((a, b) => a + b, 0)})</div>
                <div class="split-part-array">
                    ${part1.map(val => `<div class="split-part-element equal-sum-part1">${val}</div>`).join('')}
                </div>
            </div>
            <div class="split-part">
                <div class="split-part-title">Part 2 (Sum: ${part2.reduce((a, b) => a + b, 0)})</div>
                <div class="split-part-array">
                    ${part2.map(val => `<div class="split-part-element equal-sum-part2">${val}</div>`).join('')}
                </div>
            </div>
            <div class="split-part">
                <div class="split-part-title">Part 3 (Sum: ${part3.reduce((a, b) => a + b, 0)})</div>
                <div class="split-part-array">
                    ${part3.map(val => `<div class="split-part-element equal-sum-part3">${val}</div>`).join('')}
                </div>
            </div>
        `;
        
        // Also highlight the parts in the main array
        const elements = arrayContainer.querySelectorAll('.array-element');
        for (let i = 0; i <= firstSplit; i++) {
            elements[i].querySelector('.element-value').classList.add('equal-sum-part1');
        }
        for (let i = firstSplit + 1; i <= secondSplit; i++) {
            elements[i].querySelector('.element-value').classList.add('equal-sum-part2');
        }
        for (let i = secondSplit + 1; i < nums.length; i++) {
            elements[i].querySelector('.element-value').classList.add('equal-sum-part3');
        }
    }
    
    // Start the algorithm
    executeStep();
}

// NEW: Return to Original after Split Operation
function returnToOriginalAfterEqualSplit() {
    // Reset to original array
    myArray = [...originalArrayForEqualSplit];
    originalArrayForEqualSplit = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isSplitEqualSumRunning = false;
    
    logOperation('Split equal sum operation completed - returned to original array', 'info');
    showNotification('Returned to original array after split operation', 'success');
}
// NEW: Show sequence input group
function showSequenceInput(type) {
    if (isSequenceOperationRunning) {
        showNotification('A sequence operation is already in progress', 'warning');
        return;
    }
    
    // Hide all input groups first
    document.getElementById('kConsecutiveInputGroup').style.display = 'none';
    document.getElementById('increasingSequencesInputGroup').style.display = 'none';
    document.getElementById('balancedStringsInputGroup').style.display = 'none';
    
    // Show the appropriate input group
    switch(type) {
        case 'consecutive':
            document.getElementById('kConsecutiveInputGroup').style.display = 'block';
            document.getElementById('kConsecutiveValue').focus();
            break;
        case 'increasing':
            document.getElementById('increasingSequencesInputGroup').style.display = 'block';
            document.getElementById('kIncreasingValue').focus();
            break;
        case 'balanced':
            document.getElementById('balancedStringsInputGroup').style.display = 'block';
            document.getElementById('balancedStringInput').focus();
            break;
    }
    
    currentSequenceOperation = type;
}

// NEW: Cancel sequence operation
function cancelSequenceOperation(type) {
    document.getElementById('kConsecutiveInputGroup').style.display = 'none';
    document.getElementById('increasingSequencesInputGroup').style.display = 'none';
    document.getElementById('balancedStringsInputGroup').style.display = 'none';
    
    document.getElementById('kConsecutiveValue').value = '';
    document.getElementById('kIncreasingValue').value = '';
    document.getElementById('balancedStringInput').value = '';
    
    currentSequenceOperation = null;
    logOperation('Cancelled sequence operation', 'info');
}

// NEW: Handle sequence operation
function handleSequenceOperation(type) {
    if (isSequenceOperationRunning) {
        showNotification('A sequence operation is already in progress', 'warning');
        return;
    }
    
    switch(type) {
        case 'consecutive':
            handleDivideKConsecutive();
            break;
        case 'increasing':
            handleDivideIncreasingSequences();
            break;
        case 'balanced':
            handleSplitBalancedStrings();
            break;
    }
}

// NEW: Divide Array in Sets of K Consecutive Numbers
function handleDivideKConsecutive() {
    const k = parseInt(document.getElementById('kConsecutiveValue').value);
    
    if (isNaN(k) || k < 2) {
        showNotification('Please enter a valid k value ( 2)', 'danger');
        document.getElementById('kConsecutiveValue').focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if all elements are numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('This operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isSequenceOperationRunning = true;
    originalArrayForSequence = [...myArray];
    
    // Hide input group
    document.getElementById('kConsecutiveInputGroup').style.display = 'none';
    
    // Start visualization
    showKConsecutiveVisualization(k);
}

// NEW: Show K Consecutive Visualization
function showKConsecutiveVisualization(k) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Divide Array in Sets of K Consecutive Numbers (k=${k})</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalSequenceArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Sequence Division Process</div>
            <div class="transformed-array-container" id="transformedSequenceArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Divide array into sequences of ${k} consecutive numbers</p>
            <p class="mb-0" id="sequenceExplanation">Initializing sequence division...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="sequenceStepsContainer">
            <h6 class="text-center">Sequence Division Steps</h6>
            <div class="steps-container" id="sequenceSteps"></div>
        </div>
        
        <div class="sequences-container mt-3" id="sequencesContainer" style="display: none;">
            <h6 class="text-center">Formed Sequences</h6>
            <div id="sequencesList" class="text-center"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSequence" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSequence, 'originalSequenceArray');
    renderArrayInContainer([...originalArrayForSequence], 'transformedSequenceArray');
    
    performKConsecutiveAnimation(k);
}

// NEW: Perform K Consecutive Animation
function performKConsecutiveAnimation(k) {
    const originalContainer = document.getElementById('originalSequenceArray');
    const transformedContainer = document.getElementById('transformedSequenceArray');
    const explanation = document.getElementById('sequenceExplanation');
    const stepsContainer = document.getElementById('sequenceSteps');
    const sequencesContainer = document.getElementById('sequencesContainer');
    const sequencesList = document.getElementById('sequencesList');
    const continueButton = document.getElementById('continueAfterSequence');
    
    const nums = originalArrayForSequence.map(val => parseInt(val));
    const n = nums.length;
    
    // Check divisibility
    if (n % k !== 0) {
        explanation.innerHTML = `<strong>Cannot divide:</strong> ${n} elements not divisible by ${k}`;
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step 1:</strong> Check divisibility - ${n} % ${k} = ${n % k}  0
            </div>
            <div class="algorithm-step active">
                <strong>Result:</strong>  Cannot divide array into sequences of length ${k}
            </div>
        `;
        
        // Highlight error
        const elements = transformedContainer.querySelectorAll('.array-element');
        elements.forEach(el => {
            el.querySelector('.element-value').classList.add('sequence-error');
        });
        
        continueButton.style.display = 'block';
        continueButton.addEventListener('click', returnToOriginalAfterSequence);
        
        // Auto-return after 20 seconds
        setTimeout(returnToOriginalAfterSequence, 20000);
        return;
    }
    
    // Create frequency counter
    const count = {};
    nums.forEach(num => {
        count[num] = (count[num] || 0) + 1;
    });
    
    const sortedNums = Object.keys(count).map(Number).sort((a, b) => a - b);
    let sequences = [];
    let step = 0;
    let success = true;
    
    explanation.innerHTML = `Step ${++step}: Array has ${n} elements, divisible by ${k}. Starting sequence formation...`;
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Step 1:</strong> Check divisibility - ${n} % ${k} = 0 
        </div>
        <div class="algorithm-step active">
            <strong>Step 2:</strong> Frequency count: ${JSON.stringify(count)}
        </div>
        <div class="algorithm-step active">
            <strong>Step 3:</strong> Unique sorted keys: [${sortedNums.join(', ')}]
        </div>
    `;
    
    function processNextNumber(numIndex) {
        if (numIndex >= sortedNums.length) {
            // Algorithm completed
            if (success) {
                explanation.innerHTML = `<strong>Success!</strong> All elements divided into sequences of length ${k}`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong>  SUCCESS: All elements divided into sequences of length ${k}
                    </div>
                `;
                
                // Show all sequences
                sequencesContainer.style.display = 'block';
                sequencesList.innerHTML = '';
                sequences.forEach((seq, idx) => {
                    const seqDiv = document.createElement('div');
                    seqDiv.className = 'sequence-item';
                    seqDiv.textContent = `Sequence ${idx + 1}: [${seq.join(', ')}]`;
                    sequencesList.appendChild(seqDiv);
                });
            }
            
            continueButton.style.display = 'block';
            continueButton.addEventListener('click', returnToOriginalAfterSequence);
            
            // Auto-return after 20 seconds
            setTimeout(returnToOriginalAfterSequence, 20000);
            return;
        }
        
        const num = sortedNums[numIndex];
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Iteration ${numIndex + 1}:</strong> Processing number ${num}
            </div>
        `;
        
        explanation.innerHTML = `Processing number ${num} (count: ${count[num]})`;
        
        // Highlight current number
        const elements = transformedContainer.querySelectorAll('.array-element');
        elements.forEach((el, idx) => {
            if (parseInt(nums[idx]) === num && count[num] > 0) {
                el.querySelector('.element-value').classList.add('sequence-current');
            }
        });
        
        setTimeout(() => {
            while (count[num] > 0) {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>  Starting sequence from ${num}</strong>
                    </div>
                `;
                
                const currentSequence = [num];
                
                // Try to form sequence of length k
                let sequenceValid = true;
                for (let i = 1; i < k; i++) {
                    const nextNum = num + i;
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>    Looking for next number:</strong> ${nextNum}
                        </div>
                    `;
                    
                    if (!count[nextNum] || count[nextNum] < count[num]) {
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>     Not enough ${nextNum}</strong> (has ${count[nextNum] || 0}, need at least ${count[num]})
                            </div>
                        `;
                        sequenceValid = false;
                        success = false;
                        break;
                    }
                    
                    currentSequence.push(nextNum);
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>     Found ${nextNum}</strong>, sequence so far: [${currentSequence.join(', ')}]
                        </div>
                    `;
                }
                
                if (!sequenceValid) {
                    explanation.innerHTML = `<strong>Failed!</strong> Cannot form sequence starting from ${num}`;
                    
                    // Highlight error
                    elements.forEach((el, idx) => {
                        if (parseInt(nums[idx]) === num) {
                            el.querySelector('.element-value').classList.add('sequence-error');
                        }
                    });
                    
                    continueButton.style.display = 'block';
                    continueButton.addEventListener('click', returnToOriginalAfterSequence);
                    
                    // Auto-return after 20 seconds
                    setTimeout(returnToOriginalAfterSequence, 20000);
                    return;
                }
                
                // Decrease counts and mark elements as used
                for (let i = 0; i < k; i++) {
                    const decreaseNum = num + i;
                    count[decreaseNum]--;
                    
                    // Mark elements as used in visualization
                    elements.forEach((el, idx) => {
                        if (parseInt(nums[idx]) === decreaseNum) {
                            const valueDiv = el.querySelector('.element-value');
                            valueDiv.classList.remove('sequence-current');
                            valueDiv.classList.add('sequence-used');
                            valueDiv.textContent = `${nums[idx]} (used)`;
                        }
                    });
                }
                
                sequences.push(currentSequence);
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>   Completed sequence:</strong> [${currentSequence.join(', ')}]
                    </div>
                `;
                
                explanation.innerHTML = `Completed sequence: [${currentSequence.join(', ')}]`;
            }
            
            // Remove current highlight
            elements.forEach((el, idx) => {
                if (parseInt(nums[idx]) === num) {
                    el.querySelector('.element-value').classList.remove('sequence-current');
                }
            });
            
            // Process next number
            processNextNumber(numIndex + 1);
        }, 2000);
    }
    
    // Start processing
    processNextNumber(0);
}

// NEW: Divide Array Into Increasing Sequences
function handleDivideIncreasingSequences() {
    const k = parseInt(document.getElementById('kIncreasingValue').value);
    
    if (isNaN(k) || k < 2) {
        showNotification('Please enter a valid k value ( 2)', 'danger');
        document.getElementById('kIncreasingValue').focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if all elements are numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('This operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isSequenceOperationRunning = true;
    originalArrayForSequence = [...myArray];
    
    // Hide input group
    document.getElementById('increasingSequencesInputGroup').style.display = 'none';
    
    // Start visualization
    showIncreasingSequencesVisualization(k);
}

// NEW: Show Increasing Sequences Visualization
function showIncreasingSequencesVisualization(k) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Divide Array Into Increasing Sequences (k=${k})</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalSequenceArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Sequence Analysis</div>
            <div class="transformed-array-container" id="transformedSequenceArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Check if array can be divided into increasing sequences of length  ${k}</p>
            <p class="mb-0" id="sequenceExplanation">Initializing sequence analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="sequenceStepsContainer">
            <h6 class="text-center">Sequence Analysis Steps</h6>
            <div class="steps-container" id="sequenceSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Maximum Frequency</div>
            <div class="stats-value" id="maxFreqValue">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Maximum Possible Sequences</div>
            <div class="stats-value" id="maxSequencesValue">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSequence" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSequence, 'originalSequenceArray');
    renderArrayInContainer([...originalArrayForSequence], 'transformedSequenceArray');
    
    performIncreasingSequencesAnimation(k);
}

// NEW: Perform Increasing Sequences Animation
function performIncreasingSequencesAnimation(k) {
    const originalContainer = document.getElementById('originalSequenceArray');
    const transformedContainer = document.getElementById('transformedSequenceArray');
    const explanation = document.getElementById('sequenceExplanation');
    const stepsContainer = document.getElementById('sequenceSteps');
    const maxFreqValue = document.getElementById('maxFreqValue');
    const maxSequencesValue = document.getElementById('maxSequencesValue');
    const continueButton = document.getElementById('continueAfterSequence');
    
    const nums = originalArrayForSequence.map(val => parseInt(val));
    const n = nums.length;
    let step = 0;
    
    explanation.innerHTML = `Step ${++step}: Analyzing array for sequence division...`;
    
    // Create frequency counter
    const count = {};
    nums.forEach(num => {
        count[num] = (count[num] || 0) + 1;
    });
    
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Step 1:</strong> Input array: [${nums.join(', ')}], k: ${k}
        </div>
        <div class="algorithm-step active">
            <strong>Step 2:</strong> Frequency count: ${JSON.stringify(count)}
        </div>
    `;
    
    // Find maximum frequency
    const maxFreq = Math.max(...Object.values(count));
    maxFreqValue.textContent = maxFreq;
    
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Step 3:</strong> Maximum frequency of any element: ${maxFreq}
        </div>
    `;
    
    explanation.innerHTML = `Maximum frequency found: ${maxFreq}`;
    
    // Highlight elements with maximum frequency
    const elements = transformedContainer.querySelectorAll('.array-element');
    let maxFreqElements = [];
    Object.keys(count).forEach(num => {
        if (count[num] === maxFreq) {
            maxFreqElements.push(parseInt(num));
        }
    });
    
    setTimeout(() => {
        elements.forEach((el, idx) => {
            if (maxFreqElements.includes(nums[idx])) {
                el.querySelector('.element-value').classList.add('sequence-current');
            }
        });
        
        explanation.innerHTML = `Highlighting elements with maximum frequency (${maxFreq})`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step 4:</strong> Minimum sequences needed (max frequency): ${maxFreq}
            </div>
        `;
        
        setTimeout(() => {
            const totalElements = n;
            const maxPossibleSequences = Math.floor(totalElements / k);
            maxSequencesValue.textContent = maxPossibleSequences;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 5:</strong> Total elements: ${totalElements}
                </div>
                <div class="algorithm-step active">
                    <strong>Step 6:</strong> Maximum possible sequences (total_elements // k): ${maxPossibleSequences}
                </div>
            `;
            
            explanation.innerHTML = `Checking if ${maxFreq}  ${maxPossibleSequences}`;
            
            setTimeout(() => {
                if (maxFreq <= maxPossibleSequences) {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 7:</strong>  SUCCESS: ${maxFreq}  ${maxPossibleSequences}
                        </div>
                        <div class="algorithm-step active">
                            <strong>Result:</strong> We can create ${maxFreq} sequences
                        </div>
                    `;
                    
                    explanation.innerHTML = `<strong>Success!</strong> Array can be divided into increasing sequences`;
                    
                    // Highlight success
                    elements.forEach(el => {
                        el.querySelector('.element-value').classList.add('sequence-highlight');
                    });
                } else {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 7:</strong>  FAILED: ${maxFreq} > ${maxPossibleSequences}
                        </div>
                        <div class="algorithm-step active">
                            <strong>Result:</strong> Need ${maxFreq} sequences but can only create ${maxPossibleSequences}
                        </div>
                    `;
                    
                    explanation.innerHTML = `<strong>Failed!</strong> Cannot divide array into required sequences`;
                    
                    // Highlight error
                    elements.forEach(el => {
                        el.querySelector('.element-value').classList.add('sequence-error');
                    });
                }
                
                continueButton.style.display = 'block';
                continueButton.addEventListener('click', returnToOriginalAfterSequence);
                
                // Auto-return after 20 seconds
                setTimeout(returnToOriginalAfterSequence, 20000);
            }, 2000);
        }, 2000);
    }, 2000);
}

// NEW: Split a String in Balanced Strings
function handleSplitBalancedStrings() {
    const inputString = document.getElementById('balancedStringInput').value.trim().toUpperCase();
    
    if (inputString === '') {
        showNotification('Please enter a string', 'danger');
        document.getElementById('balancedStringInput').focus();
        return;
    }
    
    // Validate string contains only L and R
    if (!/^[LR]+$/i.test(inputString)) {
        showNotification('String should contain only L and R characters', 'danger');
        document.getElementById('balancedStringInput').focus();
        return;
    }
    
    isSequenceOperationRunning = true;
    currentSequenceOperation = 'balanced';
    
    // Don't set originalArrayForSequence for balanced strings
    // since we're not modifying the actual array
    
    // Hide input group
    document.getElementById('balancedStringsInputGroup').style.display = 'none';
    
    // Start visualization
    showBalancedStringsVisualization(inputString);
}
// NEW: Show Balanced Strings Visualization
function showBalancedStringsVisualization(inputString) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Split a String in Balanced Strings</h5>
        
        <div class="array-group">
            <div class="array-label">Input String</div>
            <div class="original-array-container" id="originalStringArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Balanced Strings Detection</div>
            <div class="transformed-array-container" id="transformedStringArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Split string into maximum number of balanced strings (equal L and R)</p>
            <p class="mb-0" id="stringExplanation">Initializing balanced strings detection...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="stringStepsContainer">
            <h6 class="text-center">Balanced Strings Steps</h6>
            <div class="steps-container" id="stringSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Balanced Strings Found</div>
            <div class="stats-value" id="balancedCountValue">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterString" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Array View
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderStringInContainer(inputString, 'originalStringArray');
    renderStringInContainer(inputString, 'transformedStringArray');
    
    performBalancedStringsAnimation(inputString);
}

// NEW: Render string in container
function renderStringInContainer(str, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    for (let i = 0; i < str.length; i++) {
        const charElement = document.createElement('div');
        charElement.className = `balanced-string-char ${str[i]}`;
        charElement.textContent = str[i];
        charElement.setAttribute('data-index', i);
        container.appendChild(charElement);
    }
}

// NEW: Perform Balanced Strings Animation
function performBalancedStringsAnimation(inputString) {
    const originalContainer = document.getElementById('originalStringArray');
    const transformedContainer = document.getElementById('transformedStringArray');
    const explanation = document.getElementById('stringExplanation');
    const stepsContainer = document.getElementById('stringSteps');
    const balancedCountValue = document.getElementById('balancedCountValue');
    const continueButton = document.getElementById('continueAfterString');
    
    const chars = inputString.split('');
    let balance = 0;
    let count = 0;
    let currentSegment = [];
    let step = 0;
    
    explanation.innerHTML = `Step ${++step}: Starting balanced strings detection...`;
    
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Step 1:</strong> Input string: "${inputString}"
        </div>
        <div class="algorithm-step active">
            <strong>Step 2:</strong> Initialize balance = 0, count = 0
        </div>
    `;
    
    function processNextChar(i) {
        if (i >= chars.length) {
            // Algorithm completed
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong>  Found ${count} balanced strings
                </div>
            `;
            
            explanation.innerHTML = `<strong>Completed!</strong> Found ${count} balanced strings`;
            balancedCountValue.textContent = count;
            
            continueButton.style.display = 'block';
            continueButton.addEventListener('click', returnToOriginalAfterSequence);
            
            // Auto-return after 20 seconds
            setTimeout(returnToOriginalAfterSequence, 20000);
            return;
        }
        
        const char = chars[i];
        currentSegment.push(char);
        
        // Update balance
        if (char === 'L') balance++;
        else balance--;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step + 2}:</strong> Character ${i} = '${char}', balance = ${balance}, current segment: "${currentSegment.join('')}"
            </div>
        `;
        
        explanation.innerHTML = `Processing character ${i} ('${char}'), balance: ${balance}`;
        
        // Highlight current character
        const charElements = transformedContainer.querySelectorAll('.balanced-string-char');
        charElements[i].classList.add('current');
        
        setTimeout(() => {
            if (balance === 0) {
                // Found a balanced string
                count++;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong> Balanced string found!</strong> Segment: "${currentSegment.join('')}"
                    </div>
                `;
                
                explanation.innerHTML = `Found balanced string: "${currentSegment.join('')}"`;
                
                // Highlight the balanced segment
                for (let j = i - currentSegment.length + 1; j <= i; j++) {
                    charElements[j].classList.remove('current');
                    charElements[j].classList.add('balanced');
                }
                
                currentSegment = [];
                balancedCountValue.textContent = count;
            }
            
            // Remove current highlight if not balanced
            if (balance !== 0) {
                charElements[i].classList.remove('current');
            }
            
            step++;
            processNextChar(i + 1);
        }, 1500);
    }
    
    // Start processing
    processNextChar(0);
}

// NEW: Return to original after sequence operations
function returnToOriginalAfterSequence() {
    // Only reset to original array if we were working with array operations
    // For balanced strings, we need to preserve the original array state
    if (currentSequenceOperation === 'consecutive' || currentSequenceOperation === 'increasing') {
        // Reset to original array for consecutive and increasing operations
        myArray = [...originalArrayForSequence];
    }
    // For balanced strings, we don't modify myArray, so no need to reset
    
    originalArrayForSequence = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isSequenceOperationRunning = false;
    currentSequenceOperation = null;
    
    // Clear inputs
    document.getElementById('kConsecutiveValue').value = '';
    document.getElementById('kIncreasingValue').value = '';
    document.getElementById('balancedStringInput').value = '';
    
    logOperation('Sequence operation completed - returned to original array', 'info');
    showNotification('Returned to original array after sequence operation', 'success');
}
// NEW: Count Number of Nice Subarrays Handler
function handleCountNiceSubarrays() {
    const k = parseInt(niceSubarrayK.value);
    
    if (isNaN(k) || k < 1) {
        showNotification('Please enter a valid k value ( 1)', 'danger');
        niceSubarrayK.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Nice subarray counting requires all array elements to be numbers', 'danger');
        return;
    }
    
    if (isNiceSubarrayRunning) {
        showNotification('Nice subarray counting is already in progress', 'warning');
        return;
    }
    
    isNiceSubarrayRunning = true;
    
    // Store original array
    originalArrayForNiceSubarray = [...myArray];
    
    // Perform nice subarray visualization
    performNiceSubarrayVisualization(k);
}

// NEW: Perform Nice Subarray Visualization
function performNiceSubarrayVisualization(k) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Count Number of Nice Subarrays (k = ${k})</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="niceSubarrayOriginal"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Nice Subarrays Counting Process</div>
            <div class="transformed-array-container" id="niceSubarrayProcess"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Nice Subarrays:</strong> Count subarrays with exactly ${k} odd numbers</p>
            <p class="mb-0" id="niceSubarrayExplanation">Initializing nice subarray counting...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="niceSubarrayStepsContainer">
            <h6 class="text-center">Nice Subarray Counting Steps</h6>
            <div class="steps-container" id="niceSubarraySteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Total Nice Subarrays</div>
            <div class="stats-value" id="niceSubarrayCount">0</div>
        </div>
        
        <div class="nice-subarray-results mt-3" id="niceSubarrayResults" style="display: none;">
            <h6>Found Nice Subarrays</h6>
            <div id="niceSubarraysList"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterNiceSubarray" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForNiceSubarray, 'niceSubarrayOriginal');
    renderArrayInContainer([...originalArrayForNiceSubarray], 'niceSubarrayProcess');
    
    performNiceSubarrayAlgorithm(k);
}

// NEW: Perform Nice Subarray Algorithm with Animation
function performNiceSubarrayAlgorithm(k) {
    const originalContainer = document.getElementById('niceSubarrayOriginal');
    const processContainer = document.getElementById('niceSubarrayProcess');
    const explanation = document.getElementById('niceSubarrayExplanation');
    const stepsContainer = document.getElementById('niceSubarraySteps');
    const niceSubarrayCount = document.getElementById('niceSubarrayCount');
    const niceSubarrayResults = document.getElementById('niceSubarrayResults');
    const niceSubarraysList = document.getElementById('niceSubarraysList');
    const continueButton = document.getElementById('continueAfterNiceSubarray');
    
    const nums = originalArrayForNiceSubarray.map(val => parseInt(val));
    let totalNiceSubarrays = 0;
    let foundSubarrays = [];
    let step = 0;
    
    // First, classify elements as odd/even
    explanation.innerHTML = 'Step 1: Classifying elements as odd or even';
    
    const elements = processContainer.querySelectorAll('.array-element');
    elements.forEach((el, index) => {
        setTimeout(() => {
            const valueDiv = el.querySelector('.element-value');
            if (nums[index] % 2 === 1) {
                valueDiv.classList.add('nice-subarray-odd');
            } else {
                valueDiv.classList.add('nice-subarray-even');
            }
        }, index * 200);
    });
    
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Step 1:</strong> Classified elements - odd numbers highlighted in orange
        </div>
    `;
    
    // Implement the atMostK function with animation
    function atMostK(kValue) {
        if (kValue < 0) return 0;
        
        let left = 0;
        let count = 0;
        let result = 0;
        let subStep = 0;
        
        function processRightPointer(right) {
            if (right >= nums.length) {
                return result;
            }
            
            subStep++;
            step++;
            
            // Highlight current right pointer
            const currentElements = processContainer.querySelectorAll('.array-element');
            const rightElement = currentElements[right].querySelector('.element-value');
            rightElement.classList.add('nice-subarray-current');
            
            explanation.innerHTML = `Processing element at index ${right}: ${nums[right]} (${nums[right] % 2 === 1 ? 'ODD' : 'EVEN'})`;
            
            // Check if current element is odd
            if (nums[right] % 2 === 1) {
                count++;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> nums[${right}] = ${nums[right]} is ODD  count = ${count}
                    </div>
                `;
            } else {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step}:</strong> nums[${right}] = ${nums[right]} is EVEN  count = ${count}
                    </div>
                `;
            }
            
            // Scroll steps container
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            setTimeout(() => {
                // Adjust left pointer if count exceeds k
                if (count > kValue) {
                    explanation.innerHTML = `Count (${count}) > k (${kValue}), adjusting left pointer`;
                    
                    function adjustLeftPointer() {
                        if (count > kValue && left <= right) {
                            const leftElement = currentElements[left].querySelector('.element-value');
                            leftElement.classList.add('nice-subarray-boundary');
                            
                            setTimeout(() => {
                                if (nums[left] % 2 === 1) {
                                    count--;
                                    stepsContainer.innerHTML += `
                                        <div class="algorithm-step">
                                            <strong>Adjust:</strong> nums[${left}] = ${nums[left]} is ODD  count = ${count}
                                        </div>
                                    `;
                                } else {
                                    stepsContainer.innerHTML += `
                                        <div class="algorithm-step">
                                            <strong>Adjust:</strong> nums[${left}] = ${nums[left]} is EVEN  count = ${count}
                                        </div>
                                    `;
                                }
                                
                                leftElement.classList.remove('nice-subarray-boundary');
                                left++;
                                
                                // Continue adjusting if needed
                                setTimeout(() => {
                                    if (count > kValue) {
                                        adjustLeftPointer();
                                    } else {
                                        completeRightStep(right);
                                    }
                                }, 800);
                            }, 500);
                        } else {
                            completeRightStep(right);
                        }
                    }
                    
                    adjustLeftPointer();
                } else {
                    completeRightStep(right);
                }
                
                function completeRightStep(right) {
                    // Calculate result for current window
                    result += (right - left + 1);
                    
                    // Highlight the current valid window
                    for (let i = left; i <= right; i++) {
                        currentElements[i].querySelector('.element-value').classList.add('nice-subarray-included');
                    }
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Valid Window:</strong> [${left}, ${right}]  result += ${right - left + 1} = ${result}
                        </div>
                    `;
                    
                    niceSubarrayCount.textContent = result;
                    
                    // Remove current highlight and move to next
                    rightElement.classList.remove('nice-subarray-current');
                    
                    // Remove window highlights after delay
                    setTimeout(() => {
                        for (let i = left; i <= right; i++) {
                            currentElements[i].querySelector('.element-value').classList.remove('nice-subarray-included');
                        }
                        
                        // Process next right pointer
                        processRightPointer(right + 1);
                    }, 1000);
                }
            }, 1500);
        }
        
        // Start processing from right = 0
        processRightPointer(0);
        return result;
    }
    
    // Execute atMostK for k and k-1
    setTimeout(() => {
        explanation.innerHTML = `Step 2: Calculating number of subarrays with at most ${k} odd numbers`;
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Phase 1:</strong> Calculate subarrays with at most ${k} odd numbers
            </div>
        `;
        
        const atMostKResult = atMostK(k);
        
        setTimeout(() => {
            explanation.innerHTML = `Step 3: Calculating number of subarrays with at most ${k-1} odd numbers`;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Phase 2:</strong> Calculate subarrays with at most ${k-1} odd numbers
                </div>
            `;
            
            // Reset for second calculation
            const atMostKMinus1Result = atMostK(k - 1);
            
            setTimeout(() => {
                // Calculate final result
                totalNiceSubarrays = atMostKResult - atMostKMinus1Result;
                
                explanation.innerHTML = `<strong>Algorithm Completed!</strong> Nice subarrays = atMost(${k}) - atMost(${k-1}) = ${atMostKResult} - ${atMostKMinus1Result} = ${totalNiceSubarrays}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final Result:</strong> numberOfSubarrays(${k}) = atMost(${k}) - atMost(${k-1}) = ${atMostKResult} - ${atMostKMinus1Result} = ${totalNiceSubarrays}
                    </div>
                `;
                
                niceSubarrayCount.textContent = totalNiceSubarrays;
                
                // Find and display example nice subarrays
                findNiceSubarraysExamples(nums, k);
                niceSubarrayResults.style.display = 'block';
                
                continueButton.style.display = 'block';
                
                // Auto-return after 20 seconds
                setTimeout(() => {
                    returnToOriginalAfterNiceSubarray();
                }, 20000);
                
                continueButton.addEventListener('click', returnToOriginalAfterNiceSubarray);
                
            }, 2000);
        }, 2000);
    }, 2000);
}

// NEW: Find example nice subarrays for display
function findNiceSubarraysExamples(nums, k) {
    const examples = [];
    const n = nums.length;
    
    // Find first few examples
    for (let left = 0; left < n; left++) {
        let oddCount = 0;
        for (let right = left; right < n; right++) {
            if (nums[right] % 2 === 1) {
                oddCount++;
            }
            
            if (oddCount === k) {
                examples.push(`[${left}, ${right}]`);
            }
            
            if (oddCount > k) {
                break;
            }
            
            // Limit examples to avoid too many
            if (examples.length >= 8) break;
        }
        if (examples.length >= 8) break;
    }
    
    const niceSubarraysList = document.getElementById('niceSubarraysList');
    if (examples.length > 0) {
        examples.forEach(example => {
            const subarrayItem = document.createElement('span');
            subarrayItem.className = 'nice-subarray-item';
            subarrayItem.textContent = example;
            niceSubarraysList.appendChild(subarrayItem);
        });
    } else {
        niceSubarraysList.innerHTML = '<p>No nice subarrays found</p>';
    }
}

// NEW: Return to Original after Nice Subarray Operation
function returnToOriginalAfterNiceSubarray() {
    // Reset to original array
    myArray = [...originalArrayForNiceSubarray];
    originalArrayForNiceSubarray = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isNiceSubarrayRunning = false;
    
    // Clear input
    niceSubarrayK.value = '';
    
    logOperation('Nice subarray counting completed - returned to original array', 'info');
    showNotification('Returned to original array after nice subarray counting', 'success');
}
// Helper function to render array in specific container
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = `
            <div class="array-empty-state">
                <i class="fas fa-layer-group"></i>
                <h4>Array is Empty</h4>
            </div>
        `;
        return;
    }
    
    array.forEach((value, index) => {
        const elementDiv = document.createElement('div');
        elementDiv.className = 'array-element';
        elementDiv.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(elementDiv);
    });
}
// NEW: K Different Integers Handler
function handleKDifferentIntegers() {
    const k = parseInt(kDifferentIntegers.value);
    
    if (isNaN(k) || k < 1) {
        showNotification('Please enter a valid k value ( 1)', 'danger');
        kDifferentIntegers.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains integers - more flexible validation
    let allIntegers = true;
    for (let i = 0; i < myArray.length; i++) {
        const num = parseFloat(myArray[i]);
        if (isNaN(num)) {
            allIntegers = false;
            break;
        }
    }
    
    if (!allIntegers) {
        showNotification('This operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    if (isKDistinctRunning) {
        showNotification('K distinct integers operation is already in progress', 'warning');
        return;
    }
    
    isKDistinctRunning = true;
    
    // Store original array
    originalArrayForKDistinct = [...myArray];
    
    // Perform K distinct integers visualization
    performKDistinctVisualization(k);
}
// NEW: Perform K Distinct Visualization
function performKDistinctVisualization(k) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Subarrays with Exactly ${k} Different Integers</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalKDistinctArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Sliding Window Process</div>
            <div class="transformed-array-container" id="transformedKDistinctArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Count subarrays with exactly ${k} distinct integers using sliding window</p>
            <p class="mb-0" id="kDistinctExplanation">Initializing algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="kDistinctStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="kDistinctSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Total Subarrays with Exactly ${k} Distinct Integers</div>
            <div class="stats-value" id="kDistinctCount">0</div>
        </div>
        
        <div class="subarrays-results mt-3" id="kDistinctSubarraysResults" style="display: none;">
            <h6 class="text-center">Found Subarrays</h6>
            <div id="kDistinctSubarraysList" class="mt-2"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterKDistinct" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForKDistinct, 'originalKDistinctArray');
    renderArrayInContainer([...originalArrayForKDistinct], 'transformedKDistinctArray');
    
    executeKDistinctAlgorithm(k);
}
// NEW: Execute K Distinct Algorithm with Animation
function executeKDistinctAlgorithm(k) {
    const originalContainer = document.getElementById('originalKDistinctArray');
    const transformedContainer = document.getElementById('transformedKDistinctArray');
    const explanation = document.getElementById('kDistinctExplanation');
    const stepsContainer = document.getElementById('kDistinctSteps');
    const kDistinctCount = document.getElementById('kDistinctCount');
    const kDistinctSubarraysResults = document.getElementById('kDistinctSubarraysResults');
    const kDistinctSubarraysList = document.getElementById('kDistinctSubarraysList');
    const continueButton = document.getElementById('continueAfterKDistinct');
    
    // Convert array elements to numbers
    const nums = originalArrayForKDistinct.map(val => parseFloat(val));
    let totalCount = 0;
    let foundSubarrays = [];
    let step = 0;
    
    // Helper function to count subarrays with at most k distinct integers
    function atMostK(kValue) {
        if (kValue < 0) return 0;
        
        let left = 0;
        let freq = {};
        let distinctCount = 0;
        let result = 0;
        
        for (let right = 0; right < nums.length; right++) {
            // Add current number to frequency map
            const num = nums[right];
            freq[num] = (freq[num] || 0) + 1;
            
            // If this is a new distinct number
            if (freq[num] === 1) {
                distinctCount++;
            }
            
            // Shrink window if we have more than k distinct numbers
            while (distinctCount > kValue) {
                freq[nums[left]]--;
                if (freq[nums[left]] === 0) {
                    distinctCount--;
                }
                left++;
            }
            
            // Add number of subarrays ending at right
            result += (right - left + 1);
        }
        
        return result;
    }
    
    // Calculate result using the mathematical approach
    totalCount = atMostK(k) - atMostK(k - 1);
    
    // Now perform the visualization by finding actual subarrays
    function findAndDisplaySubarrays() {
        explanation.innerHTML = `Finding all subarrays with exactly ${k} distinct integers...`;
        
        // Find all subarrays with exactly k distinct integers
        foundSubarrays = [];
        for (let start = 0; start < nums.length; start++) {
            const freq = {};
            let distinctCount = 0;
            
            for (let end = start; end < nums.length; end++) {
                const num = nums[end];
                
                // Update frequency and distinct count
                if (!freq[num]) {
                    freq[num] = 0;
                    distinctCount++;
                }
                freq[num]++;
                
                // If we have exactly k distinct integers
                if (distinctCount === k) {
                    foundSubarrays.push({
                        start: start,
                        end: end,
                        subarray: nums.slice(start, end + 1)
                    });
                } 
                // If we exceed k distinct integers, break inner loop
                else if (distinctCount > k) {
                    break;
                }
            }
        }
        
        // Display results
        displayKDistinctResults();
    }
    
    function displayKDistinctResults() {
        step++;
        explanation.innerHTML = `<strong>Algorithm Completed!</strong> Found ${foundSubarrays.length} subarrays with exactly ${k} distinct integers.`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> Found ${foundSubarrays.length} subarrays with exactly ${k} distinct integers
            </div>
            <div class="algorithm-step active">
                <strong>Formula:</strong> exactlyK = atMostK(${k}) - atMostK(${k-1}) = ${atMostK(k)} - ${atMostK(k-1)} = ${totalCount}
            </div>
        `;
        
        kDistinctCount.textContent = totalCount;
        
        // Show found subarrays
        if (foundSubarrays.length > 0) {
            kDistinctSubarraysResults.style.display = 'block';
            kDistinctSubarraysList.innerHTML = '';
            
            // Group subarrays by length for better display
            const groupedSubarrays = {};
            foundSubarrays.forEach(sub => {
                const length = sub.end - sub.start + 1;
                if (!groupedSubarrays[length]) {
                    groupedSubarrays[length] = [];
                }
                groupedSubarrays[length].push(sub);
            });
            
            // Display grouped subarrays
            Object.keys(groupedSubarrays).sort((a, b) => a - b).forEach(length => {
                const group = groupedSubarrays[length];
                const groupDiv = document.createElement('div');
                groupDiv.className = 'mb-3';
                groupDiv.innerHTML = `<strong>Length ${length}:</strong> ${group.length} subarray(s)`;
                
                const subarraysDiv = document.createElement('div');
                subarraysDiv.className = 'd-flex flex-wrap gap-2 mt-1';
                
                group.forEach(sub => {
                    const subarrayBadge = document.createElement('span');
                    subarrayBadge.className = 'badge bg-info subarray-item';
                    subarrayBadge.textContent = `[${sub.start}-${sub.end}]: [${sub.subarray.join(', ')}]`;
                    subarraysDiv.appendChild(subarrayBadge);
                });
                
                groupDiv.appendChild(subarraysDiv);
                kDistinctSubarraysList.appendChild(groupDiv);
            });
        } else {
            kDistinctSubarraysResults.style.display = 'block';
            kDistinctSubarraysList.innerHTML = '<p class="text-center text-muted">No subarrays found</p>';
        }
        
        // Highlight all found subarrays in the array
        highlightKDistinctSubarrays();
    }
       function highlightKDistinctSubarrays() {
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        
        // Reset all elements first
        transformedElements.forEach(el => {
            el.querySelector('.element-value').classList.remove('window-included', 'window-max', 'kadane-included');
        });
        
        if (foundSubarrays.length === 0) {
            // No subarrays found, show continue button immediately
            continueButton.style.display = 'block';
            setTimeout(() => {
                returnToOriginalAfterKDistinct();
            }, 20000);
            continueButton.addEventListener('click', returnToOriginalAfterKDistinct);
            return;
        }
        
        // Highlight each found subarray with a delay
        let delay = 0;
        foundSubarrays.forEach((sub, index) => {
            setTimeout(() => {
                // Highlight the current subarray
                for (let i = sub.start; i <= sub.end; i++) {
                    transformedElements[i].querySelector('.element-value').classList.add('kadane-included');
                }
                
                // If this is the last subarray, add special highlight
                if (index === foundSubarrays.length - 1) {
                    setTimeout(() => {
                        for (let i = sub.start; i <= sub.end; i++) {
                            transformedElements[i].querySelector('.element-value').classList.add('kadane-max-subarray');
                        }
                        
                        // Show continue button
                        continueButton.style.display = 'block';
                        
                        // Auto-return after 20 seconds
                        setTimeout(() => {
                            returnToOriginalAfterKDistinct();
                        }, 20000);
                        
                        continueButton.addEventListener('click', returnToOriginalAfterKDistinct);
                    }, 1000);
                }
            }, delay);
            
            delay += 800; // Delay between highlighting different subarrays
        });
    }
    
    // Start the algorithm
    setTimeout(() => {
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step 1:</strong> Using sliding window approach to count subarrays
            </div>
            <div class="algorithm-step">
                <strong>Step 2:</strong> exactlyK(k) = atMostK(k) - atMostK(k-1)
            </div>
        `;
        
        setTimeout(() => {
            findAndDisplaySubarrays();
        }, 2000);
    }, 1000);
}
// NEW: Return to Original after K Distinct Operation
function returnToOriginalAfterKDistinct() {
    // Reset to original array
    myArray = [...originalArrayForKDistinct];
    originalArrayForKDistinct = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isKDistinctRunning = false;
    
    // Clear input
    kDifferentIntegers.value = '';
    
    logOperation(`K distinct integers operation completed - found subarrays with exactly k different integers`, 'info');
    showNotification('Returned to original array after K distinct integers operation', 'success');
}
// Add this function with other utility functions
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = `
            <div class="array-empty-state">
                <i class="fas fa-layer-group"></i>
                <h4>Array is Empty</h4>
                <p>No elements to display</p>
            </div>
        `;
        return;
    }
    
    array.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}
// NEW: Three Characters Substrings Handler
function handleThreeCharsSubstrings() {
    if (isThreeCharsRunning) {
        showNotification('Three characters substring operation is already in progress', 'warning');
        return;
    }

    // Show input group
    threeCharsInputGroup.style.display = 'block';
    threeCharsInput.focus();
    
    logOperation('Started three characters substring counting operation', 'info');
}

// NEW: Confirm Three Characters Handler
function handleConfirmThreeChars() {
    const inputString = threeCharsInput.value.trim();
    
    if (inputString === '') {
        showNotification('Please enter a string', 'danger');
        threeCharsInput.focus();
        return;
    }
    
    // Check if string contains at least one of each required character
    if (!inputString.includes('a') || !inputString.includes('b') || !inputString.includes('c')) {
        showNotification('String must contain at least one "a", one "b", and one "c" character', 'warning');
        threeCharsInput.focus();
        return;
    }
    
    inputStringForThreeChars = inputString;
    
    // Store original array
    originalArrayForThreeChars = [...myArray];
    
    // Hide input group
    threeCharsInputGroup.style.display = 'none';
    threeCharsInput.value = '';
    
    // Start three characters visualization
    showThreeCharsVisualization();
}

// NEW: Cancel Three Characters Handler
function handleCancelThreeChars() {
    threeCharsInputGroup.style.display = 'none';
    threeCharsInput.value = '';
    
    logOperation('Cancelled three characters substring operation', 'info');
    showNotification('Three characters substring operation cancelled', 'info');
}

// NEW: Show Three Characters Visualization
function showThreeCharsVisualization() {
    isThreeCharsRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Number of Substrings Containing All Three Characters ('a', 'b', 'c')</h5>
        
        <div class="array-group">
            <div class="array-label">Input String: "${inputStringForThreeChars}"</div>
            <div class="original-array-container" id="threeCharsArray"></div>
        </div>
        
        <div class="substring-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Count substrings containing at least one 'a', one 'b', and one 'c'</p>
            <p class="mb-0" id="threeCharsExplanation">Initializing substring counting...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="threeCharsStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="threeCharsSteps"></div>
        </div>
        
        <div class="substring-results mt-3">
            <div class="stats-card">
                <div>Total Valid Substrings</div>
                <div class="stats-value" id="totalValidSubstrings">0</div>
            </div>
            <div id="validSubstringsList" class="mt-3"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterThreeChars" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Convert string to array for visualization
    const stringArray = inputStringForThreeChars.split('').map((char, index) => `${char}(${index})`);
    renderArrayInContainer(stringArray, 'threeCharsArray');
    
    performThreeCharsAlgorithm();
}

// NEW: Perform Three Characters Algorithm with Animation
function performThreeCharsAlgorithm() {
    const arrayContainer = document.getElementById('threeCharsArray');
    const explanation = document.getElementById('threeCharsExplanation');
    const stepsContainer = document.getElementById('threeCharsSteps');
    const totalValidSubstrings = document.getElementById('totalValidSubstrings');
    const validSubstringsList = document.getElementById('validSubstringsList');
    const continueButton = document.getElementById('continueAfterThreeChars');
    
    const s = inputStringForThreeChars;
    let count = 0;
    let lastSeen = [-1, -1, -1]; // [a, b, c]
    let step = 0;
    let allValidSubstrings = [];
    
    function performAlgorithmStep(i) {
        if (i >= s.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Found ${count} valid substrings.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Total valid substrings = ${count}
                </div>
            `;
            
            totalValidSubstrings.textContent = count;
            
            // Display all valid substrings
            if (allValidSubstrings.length > 0) {
                validSubstringsList.innerHTML = '<h6>Valid Substrings Found:</h6>';
                allValidSubstrings.forEach(sub => {
                    const subElement = document.createElement('span');
                    subElement.className = 'valid-substring-item';
                    subElement.textContent = sub;
                    subElement.title = `Substring: ${sub}`;
                    validSubstringsList.appendChild(subElement);
                });
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterThreeChars();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterThreeChars);
            
            return;
        }
        
        step++;
        const char = s[i];
        
        explanation.innerHTML = `Step ${step}: Processing character at index ${i} = '${char}'`;
        
        // Highlight current character
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElement = elements[i].querySelector('.element-value');
        currentElement.classList.add('substring-current');
        
        // Update last seen position
        let charIndex = -1;
        if (char === 'a') charIndex = 0;
        else if (char === 'b') charIndex = 1;
        else if (char === 'c') charIndex = 2;
        
        if (charIndex !== -1) {
            lastSeen[charIndex] = i;
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Character '${char}' at index ${i} - 
                Last seen: a=${lastSeen[0]}, b=${lastSeen[1]}, c=${lastSeen[2]}
            </div>
        `;
        
        setTimeout(() => {
            // Calculate minimum index
            const minIndex = Math.min(...lastSeen);
            
            if (minIndex !== -1) {
                // Valid substring found
                const validCount = minIndex + 1;
                count += validCount;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step} Result:</strong> min(last_seen) = ${minIndex} - 
                        Adding ${validCount} new valid substrings (total: ${count})
                    </div>
                `;
                
                // Highlight the valid substrings range
                for (let start = 0; start <= minIndex; start++) {
                    setTimeout(() => {
                        const startElement = elements[start].querySelector('.element-value');
                        const endElement = elements[i].querySelector('.element-value');
                        
                        startElement.classList.add('substring-start');
                        endElement.classList.add('substring-end');
                        
                        // Store the valid substring
                        const substring = s.substring(start, i + 1);
                        if (!allValidSubstrings.includes(substring)) {
                            allValidSubstrings.push(substring);
                        }
                        
                        setTimeout(() => {
                            startElement.classList.remove('substring-start');
                            endElement.classList.remove('substring-end');
                            startElement.classList.add('substring-valid');
                            endElement.classList.add('substring-valid');
                        }, 500);
                    }, start * 100);
                }
                
                totalValidSubstrings.textContent = count;
            } else {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step} Result:</strong> Not all characters seen yet - no new valid substrings
                    </div>
                `;
            }
            
            // Remove current highlight
            currentElement.classList.remove('substring-current');
            
            // Scroll steps container to bottom
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            // Continue to next character
            setTimeout(() => {
                performAlgorithmStep(i + 1);
            }, 1000 + (minIndex !== -1 ? minIndex * 100 : 0));
            
        }, 1500);
    }
    
    // Start algorithm execution
    performAlgorithmStep(0);
}

// NEW: Return to Original after Three Characters Operation
function returnToOriginalAfterThreeChars() {
    // Reset to original array
    myArray = [...originalArrayForThreeChars];
    originalArrayForThreeChars = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isThreeCharsRunning = false;
    inputStringForThreeChars = '';
    
    logOperation('Three characters substring operation completed - returned to original array', 'info');
    showNotification('Returned to original array after substring operation', 'success');
}
// NEW: Longest Turbulent Subarray Handler
function handleLongestTurbulentSubarray() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isTurbulentRunning) {
        showNotification('Turbulent subarray operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Turbulent subarray operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    if (myArray.length < 2) {
        showNotification('Array must have at least 2 elements for turbulent subarray', 'warning');
        return;
    }
    
    // Store original array
    originalArrayForTurbulent = [...myArray];
    
    // Show turbulent subarray visualization
    showTurbulentSubarrayVisualization();
}

// NEW: Show Turbulent Subarray Visualization
function showTurbulentSubarrayVisualization() {
    isTurbulentRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Longest Turbulent Subarray</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalTurbulentArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Turbulent Subarray Detection</div>
            <div class="transformed-array-container" id="transformedTurbulentArray"></div>
        </div>
        
        <div class="turbulent-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find longest subarray where comparison signs alternate between elements</p>
            <p class="mb-0" id="turbulentExplanation">Initializing turbulent subarray detection...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="turbulentStepsContainer">
            <h6 class="text-center">Turbulent Subarray Detection Steps</h6>
            <div class="steps-container" id="turbulentSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Longest Turbulent Subarray Length</div>
            <div class="stats-value" id="turbulentLengthValue">1</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Turbulent Subarray Indices</div>
            <div class="stats-value" id="turbulentIndicesValue">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterTurbulent" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForTurbulent, 'originalTurbulentArray');
    renderArrayInContainer([...originalArrayForTurbulent], 'transformedTurbulentArray');
    
    performTurbulentSubarrayAnimation();
}

// NEW: Perform Turbulent Subarray Animation
function performTurbulentSubarrayAnimation() {
    const originalContainer = document.getElementById('originalTurbulentArray');
    const transformedContainer = document.getElementById('transformedTurbulentArray');
    const explanation = document.getElementById('turbulentExplanation');
    const stepsContainer = document.getElementById('turbulentSteps');
    const turbulentLengthValue = document.getElementById('turbulentLengthValue');
    const turbulentIndicesValue = document.getElementById('turbulentIndicesValue');
    const continueButton = document.getElementById('continueAfterTurbulent');
    
    const arr = originalArrayForTurbulent.map(val => parseFloat(val));
    const n = arr.length;
    
    let maxLength = 1;
    let currentLength = 1;
    let start = 0;
    let bestStart = 0;
    let bestEnd = 0;
    let step = 0;
    
    // Store all turbulent subarrays found
    let turbulentSubarrays = [];
    
    function performTurbulentStep(i) {
        if (i >= n) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Longest turbulent subarray found.`;
            
            // Store the last turbulent subarray if applicable
            if (currentLength > 1) {
                turbulentSubarrays.push({
                    length: currentLength,
                    subarray: arr.slice(start, bestEnd + 1),
                    start: start,
                    end: bestEnd
                });
            }
            
            const bestSubarray = arr.slice(bestStart, bestEnd + 1);
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Longest turbulent subarray length = ${maxLength}
                </div>
                <div class="algorithm-step active">
                    <strong>Subarray:</strong> [${bestSubarray.join(', ')}]
                </div>
                <div class="algorithm-step active">
                    <strong>Indices:</strong> [${bestStart}, ${bestEnd}]
                </div>
            `;
            
            // Highlight the longest turbulent subarray
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            for (let j = bestStart; j <= bestEnd; j++) {
                setTimeout(() => {
                    transformedElements[j].querySelector('.element-value').classList.add('turbulent-max');
                }, (j - bestStart) * 200);
            }
            
            turbulentLengthValue.textContent = maxLength;
            turbulentIndicesValue.textContent = `${bestStart} to ${bestEnd}`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds as requested
            setTimeout(() => {
                returnToOriginalAfterTurbulent();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterTurbulent);
            
            return;
        }
        
        step++;
        
        if (i === 1) {
            // First comparison
            explanation.innerHTML = `Step ${step}: First comparison between indices 0 and 1`;
            
            const elements = transformedContainer.querySelectorAll('.array-element');
            elements[0].querySelector('.element-value').classList.add('turbulent-current');
            elements[1].querySelector('.element-value').classList.add('turbulent-compare-up');
            
            // Show comparison
            const comparison = arr[1] > arr[0] ? 'UP' : arr[1] < arr[0] ? 'DOWN' : 'EQUAL';
            const comparisonClass = arr[1] > arr[0] ? 'comparison-up' : arr[1] < arr[0] ? 'comparison-down' : 'comparison-equal';
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Compare [0]=${arr[0]} and [1]=${arr[1]}
                    <div class="turbulent-comparison">
                        <span>${arr[0]}</span>
                        <span class="comparison-arrow ${comparisonClass}">${comparison === 'UP' ? '' : comparison === 'DOWN' ? '' : '='}</span>
                        <span>${arr[1]}</span>
                    </div>
                </div>
            `;
            
            setTimeout(() => {
                // Remove temporary highlights
                elements[0].querySelector('.element-value').classList.remove('turbulent-current');
                elements[1].querySelector('.element-value').classList.remove('turbulent-compare-up');
                
                if (arr[1] !== arr[0]) {
                    currentLength = 2;
                    maxLength = Math.max(maxLength, currentLength);
                    if (currentLength === maxLength) {
                        bestStart = start;
                        bestEnd = 1;
                    }
                    
                    elements[0].querySelector('.element-value').classList.add('turbulent-included');
                    elements[1].querySelector('.element-value').classList.add('turbulent-included');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Result:</strong> Turbulent sequence started, length = ${currentLength}
                        </div>
                    `;
                } else {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Result:</strong> Equal values, cannot start turbulent sequence
                        </div>
                    `;
                }
                
                turbulentLengthValue.textContent = maxLength;
                turbulentIndicesValue.textContent = `${bestStart} to ${bestEnd}`;
                
                performTurbulentStep(i + 1);
            }, 2000);
            
        } else {
            // Subsequent comparisons
            explanation.innerHTML = `Step ${step}: Checking turbulence at index ${i}`;
            
            const elements = transformedContainer.querySelectorAll('.array-element');
            
            // Highlight current and previous elements
            elements[i-2].querySelector('.element-value').classList.add('turbulent-current');
            elements[i-1].querySelector('.element-value').classList.add('turbulent-compare-up');
            elements[i].querySelector('.element-value').classList.add('turbulent-compare-down');
            
            // Calculate comparisons
            const prevCompare = arr[i-1] > arr[i-2];
            const currCompare = arr[i] > arr[i-1];
            
            const prevComparison = arr[i-1] > arr[i-2] ? 'UP' : arr[i-1] < arr[i-2] ? 'DOWN' : 'EQUAL';
            const currComparison = arr[i] > arr[i-1] ? 'UP' : arr[i] < arr[i-1] ? 'DOWN' : 'EQUAL';
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Checking turbulence condition
                    <div class="turbulent-comparison">
                        <span>[${i-2}]=${arr[i-2]}</span>
                        <span class="comparison-arrow ${prevComparison === 'UP' ? 'comparison-up' : prevComparison === 'DOWN' ? 'comparison-down' : 'comparison-equal'}">
                            ${prevComparison === 'UP' ? '' : prevComparison === 'DOWN' ? '' : '='}
                        </span>
                        <span>[${i-1}]=${arr[i-1]}</span>
                        <span class="comparison-arrow ${currComparison === 'UP' ? 'comparison-up' : currComparison === 'DOWN' ? 'comparison-down' : 'comparison-equal'}">
                            ${currComparison === 'UP' ? '' : currComparison === 'DOWN' ? '' : '='}
                        </span>
                        <span>[${i}]=${arr[i]}</span>
                    </div>
                </div>
            `;
            
            setTimeout(() => {
                // Remove temporary highlights
                elements[i-2].querySelector('.element-value').classList.remove('turbulent-current');
                elements[i-1].querySelector('.element-value').classList.remove('turbulent-compare-up');
                elements[i].querySelector('.element-value').classList.remove('turbulent-compare-down');
                
                // Check turbulent condition
                const isTurbulent = (arr[i-1] !== arr[i-2] && 
                                   arr[i] !== arr[i-1] && 
                                   prevCompare !== currCompare);
                
                if (isTurbulent) {
                    currentLength++;
                    if (currentLength > maxLength) {
                        maxLength = currentLength;
                        bestStart = start;
                        bestEnd = i;
                    }
                    
                    // Highlight the extended turbulent sequence
                    for (let j = start; j <= i; j++) {
                        elements[j].querySelector('.element-value').classList.add('turbulent-included');
                    }
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Result:</strong> Turbulent condition satisfied! Length = ${currentLength}
                        </div>
                    `;
                    
                } else {
                    // Store current turbulent subarray
                    if (currentLength > 1) {
                        turbulentSubarrays.push({
                            length: currentLength,
                            subarray: arr.slice(start, i),
                            start: start,
                            end: i - 1
                        });
                    }
                    
                    // Reset start position
                    if (arr[i] !== arr[i-1]) {
                        start = i - 1;
                        currentLength = 2;
                        
                        // Highlight new sequence
                        elements[i-1].querySelector('.element-value').classList.add('turbulent-included');
                        elements[i].querySelector('.element-value').classList.add('turbulent-included');
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Result:</strong> Turbulent broken, starting new sequence at index ${start}
                            </div>
                        `;
                    } else {
                        start = i;
                        currentLength = 1;
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Result:</strong> Equal values found, resetting sequence
                            </div>
                        `;
                    }
                }
                
                turbulentLengthValue.textContent = maxLength;
                turbulentIndicesValue.textContent = `${bestStart} to ${bestEnd}`;
                
                performTurbulentStep(i + 1);
            }, 2500);
        }
    }
    
    // Start turbulent detection process
    performTurbulentStep(1);
}

// NEW: Return to Original after Turbulent Operation
function returnToOriginalAfterTurbulent() {
    // Reset to original array
    myArray = [...originalArrayForTurbulent];
    originalArrayForTurbulent = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isTurbulentRunning = false;
    
    logOperation('Longest turbulent subarray operation completed - returned to original array', 'info');
    showNotification('Returned to original array after turbulent subarray operation', 'success');
}
// NEW: Reverse Pairs Handler
function handleReversePairs() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isReversePairsRunning) {
        showNotification('Reverse pairs operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Reverse pairs algorithm requires all array elements to be numbers', 'danger');
        return;
    }
    
    isReversePairsRunning = true;
    
    // Store original array
    originalArrayForReversePairs = [...myArray];
    
    // Show reverse pairs visualization
    showReversePairsVisualization();
}

// NEW: Show Reverse Pairs Visualization
function showReversePairsVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Reverse Pairs Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalReversePairsArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Reverse Pairs Analysis</div>
            <div class="transformed-array-container" id="transformedReversePairsArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Reverse Pairs:</strong> Count pairs (i, j) where i &lt; j and nums[i] &gt; 2 * nums[j]</p>
            <p class="mb-0" id="reversePairsExplanation">Initializing reverse pairs algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="reversePairsStepsContainer">
            <h6 class="text-center">Reverse Pairs Algorithm Steps</h6>
            <div class="steps-container" id="reversePairsSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Reverse Pairs Count</div>
            <div class="stats-value" id="reversePairsCount">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Found Pairs</div>
            <div class="stats-value" id="foundPairsList">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterReversePairs" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForReversePairs, 'originalReversePairsArray');
    renderArrayInContainer([...originalArrayForReversePairs], 'transformedReversePairsArray');
    
    performReversePairsAnimation();
}

// NEW: Perform Reverse Pairs Animation
function performReversePairsAnimation() {
    const originalContainer = document.getElementById('originalReversePairsArray');
    const transformedContainer = document.getElementById('transformedReversePairsArray');
    const explanation = document.getElementById('reversePairsExplanation');
    const stepsContainer = document.getElementById('reversePairsSteps');
    const reversePairsCount = document.getElementById('reversePairsCount');
    const foundPairsList = document.getElementById('foundPairsList');
    const continueButton = document.getElementById('continueAfterReversePairs');
    
    const arr = originalArrayForReversePairs.map(val => parseFloat(val));
    let reversePairs = [];
    let totalPairs = 0;
    let step = 0;
    
    function performReversePairsStep() {
        if (step === 0) {
            // Initial explanation
            explanation.innerHTML = `Starting reverse pairs analysis for array: [${arr.join(', ')}]`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Initialize reverse pairs algorithm
                </div>
                <div class="algorithm-step">
                    <strong>Step 2:</strong> For each pair (i, j) where i &lt; j, check if nums[i] &gt; 2 * nums[j]
                </div>
            `;
            
            step++;
            setTimeout(performReversePairsStep, 1500);
            return;
        }
        
        if (step === 1) {
            // Show the algorithm logic
            explanation.innerHTML = 'Algorithm: Check all pairs (i, j) where i < j';
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 3:</strong> Iterate through all possible pairs (i, j) with i &lt; j
                </div>
            `;
            
            step++;
            setTimeout(performReversePairsStep, 1500);
            return;
        }
        
        // Start checking pairs
        let i = step - 2;
        
        if (i >= arr.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Reverse Pairs Analysis Completed!</strong> Found ${totalPairs} reverse pairs.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Total reverse pairs found = ${totalPairs}
                </div>
            `;
            
            // Highlight all found pairs in the final result
            highlightFoundReversePairs(reversePairs);
            
            reversePairsCount.textContent = totalPairs;
            foundPairsList.textContent = reversePairs.map(pair => `(${pair.i},${pair.j})`).join(', ');
            
            continueButton.style.display = 'block';
            
            // Auto-return after 15 seconds
            setTimeout(() => {
                returnToOriginalAfterReversePairs();
            }, 15000);
            
            continueButton.addEventListener('click', returnToOriginalAfterReversePairs);
            
            return;
        }
        
        explanation.innerHTML = `Checking pairs starting from index ${i}: nums[${i}] = ${arr[i]}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step + 1}:</strong> Checking pairs with i = ${i}, nums[${i}] = ${arr[i]}
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Highlight current i element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentIElement = originalElements[i].querySelector('.element-value');
        currentIElement.classList.add('reverse-highlight');
        
        // Start checking pairs for this i
        checkPairsForI(i, () => {
            // Remove highlight from i
            currentIElement.classList.remove('reverse-highlight');
            
            step++;
            setTimeout(performReversePairsStep, 1000);
        });
    }
    
    function checkPairsForI(i, callback) {
        let j = i + 1;
        
        function checkNextJ() {
            if (j >= arr.length) {
                // All j values checked for this i
                callback();
                return;
            }
            
            explanation.innerHTML = `Checking pair (${i}, ${j}): ${arr[i]} > 2 * ${arr[j]} = ${arr[i] > 2 * arr[j]}`;
            
            // Highlight current j element
            const originalElements = originalContainer.querySelectorAll('.array-element');
            const currentIElement = originalElements[i].querySelector('.element-value');
            const currentJElement = originalElements[j].querySelector('.element-value');
            
            currentIElement.classList.add('reverse-highlight');
            currentJElement.classList.add('search-highlight');
            
            // Check the condition
            const isReversePair = arr[i] > 2 * arr[j];
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${isReversePair ? 'active' : ''}">
                    <strong>Pair (${i}, ${j}):</strong> ${arr[i]} > 2 * ${arr[j]} = ${arr[i] > 2 * arr[j]} 
                    ${isReversePair ? ' REVERSE PAIR FOUND!' : ''}
                </div>
            `;
            
            // Scroll steps container
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            setTimeout(() => {
                if (isReversePair) {
                    // Found a reverse pair
                    totalPairs++;
                    reversePairs.push({ i, j, valueI: arr[i], valueJ: arr[j] });
                    
                    // Highlight the found pair with different colors
                    currentIElement.classList.remove('reverse-highlight');
                    currentJElement.classList.remove('search-highlight');
                    currentIElement.classList.add('success-color', 'pulse');
                    currentJElement.classList.add('warning-color', 'pulse');
                    
                    // Update count immediately
                    reversePairsCount.textContent = totalPairs;
                    foundPairsList.textContent = reversePairs.map(pair => `(${pair.i},${pair.j})`).join(', ');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Reverse Pair Found!</strong> (${i}, ${j}): ${arr[i]} > 2 * ${arr[j]}
                        </div>
                    `;
                    
                    // Keep the highlight for a moment, then continue
                    setTimeout(() => {
                        currentIElement.classList.remove('success-color', 'pulse');
                        currentJElement.classList.remove('warning-color', 'pulse');
                        
                        j++;
                        setTimeout(checkNextJ, 800);
                    }, 1500);
                    
                } else {
                    // Not a reverse pair
                    currentIElement.classList.remove('reverse-highlight');
                    currentJElement.classList.remove('search-highlight');
                    
                    j++;
                    setTimeout(checkNextJ, 800);
                }
            }, 1500);
        }
        
        checkNextJ();
    }
    
    function highlightFoundReversePairs(pairs) {
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        
        // First, clear any existing highlights
        transformedElements.forEach(el => {
            const valueDiv = el.querySelector('.element-value');
            valueDiv.classList.remove('success-color', 'warning-color', 'bounce');
        });
        
        // Highlight all found pairs
        pairs.forEach((pair, index) => {
            setTimeout(() => {
                const iElement = transformedElements[pair.i].querySelector('.element-value');
                const jElement = transformedElements[pair.j].querySelector('.element-value');
                
                iElement.classList.add('success-color', 'bounce');
                jElement.classList.add('warning-color', 'bounce');
                
                // Add pair indicator
                const iIndex = transformedElements[pair.i].querySelector('.element-index');
                const jIndex = transformedElements[pair.j].querySelector('.element-index');
                
                // Clear previous indicators
                iIndex.innerHTML = pair.i.toString();
                jIndex.innerHTML = pair.j.toString();
                
                iIndex.innerHTML += `<br><small class="text-success">Pair ${index + 1}</small>`;
                jIndex.innerHTML += `<br><small class="text-warning">Pair ${index + 1}</small>`;
            }, index * 500);
        });
    }
    
    // Start reverse pairs process
    performReversePairsStep();
}

// NEW: Return to Original after Reverse Pairs
function returnToOriginalAfterReversePairs() {
    // Reset to original array
    myArray = [...originalArrayForReversePairs];
    originalArrayForReversePairs = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isReversePairsRunning = false;
    
    logOperation('Reverse pairs analysis completed - returned to original array', 'info');
    showNotification('Returned to original array after reverse pairs analysis', 'success');
}
// NEW: Inversions Analysis Handler
function handleInversionsAnalysis() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isInversionsAnalysisRunning) {
        showNotification('Inversions analysis is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Inversions analysis requires all array elements to be numbers', 'danger');
        return;
    }
    
    isInversionsAnalysisRunning = true;
    
    // Store original array
    originalArrayForInversions = [...myArray];
    
    // Show inversions analysis visualization
    showInversionsAnalysisVisualization();
}
// NEW: Show Inversions Analysis Visualization
function showInversionsAnalysisVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Global & Local Inversions Analysis</h5>
        
        <div class="array-group">
            <div class="array-label">Array for Analysis</div>
            <div class="original-array-container" id="inversionsArray"></div>
        </div>
        
        <div class="inversion-matrix" id="inversionMatrix">
            <h6 class="text-center mb-3">Inversion Matrix</h6>
            <div id="matrixContent"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Understanding Inversions:</strong></p>
            <p class="mb-1"> <strong>Local Inversion:</strong> Adjacent elements in wrong order (i and i+1)</p>
            <p class="mb-1"> <strong>Global Inversion:</strong> Any elements in wrong order (i and j where i < j)</p>
            <p class="mb-0" id="inversionsExplanation">Starting inversions analysis...</p>
        </div>
        
        <div class="inversion-stats" id="inversionStats">
            <h6 class="text-center">Inversion Statistics</h6>
            <div class="stats-value" id="localCount">Local Inversions: 0</div>
            <div class="stats-value" id="globalCount">Global Inversions: 0</div>
        </div>
        
        <div class="inversion-relationship" id="inversionRelationship" style="display: none;">
            <h6 class="text-center">Relationship Analysis</h6>
            <div id="relationshipContent"></div>
        </div>
        
        <div class="algorithm-steps mt-3" id="inversionsStepsContainer">
            <h6 class="text-center">Analysis Steps</h6>
            <div class="steps-container" id="inversionsSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterInversions" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForInversions, 'inversionsArray');
    createInversionMatrix(originalArrayForInversions);
    
    performInversionsAnalysis();
}
// NEW: Create Inversion Matrix
function createInversionMatrix(arr) {
    const matrixContent = document.getElementById('matrixContent');
    const n = arr.length;
    
    // Clear previous content
    matrixContent.innerHTML = '';
    
    // Create header row
    const headerRow = document.createElement('div');
    headerRow.className = 'matrix-row';
    
    // Add empty corner cell
    const cornerCell = document.createElement('div');
    cornerCell.className = 'matrix-cell header';
    cornerCell.textContent = 'i\\j';
    headerRow.appendChild(cornerCell);
    
    // Add column headers
    for (let j = 0; j < n; j++) {
        const headerCell = document.createElement('div');
        headerCell.className = 'matrix-cell header';
        headerCell.textContent = j;
        headerRow.appendChild(headerCell);
    }
    
    matrixContent.appendChild(headerRow);
    
    // Create matrix rows
    for (let i = 0; i < n; i++) {
        const matrixRow = document.createElement('div');
        matrixRow.className = 'matrix-row';
        
        // Row header
        const rowHeader = document.createElement('div');
        rowHeader.className = 'matrix-cell header';
        rowHeader.textContent = i;
        matrixRow.appendChild(rowHeader);
        
        // Matrix cells
        for (let j = 0; j < n; j++) {
            const cell = document.createElement('div');
            cell.className = 'matrix-cell';
            cell.id = `matrix-${i}-${j}`;
            
            if (i === j) {
                // Diagonal - show value
                cell.className += ' value';
                cell.textContent = arr[i];
            } else if (i > j) {
                // Lower triangle - not applicable
                cell.textContent = '';
                cell.style.background = 'rgba(255,255,255,0.1)';
                cell.style.color = 'rgba(255,255,255,0.5)';
            } else {
                // Upper triangle - will be filled during analysis
                cell.textContent = '';
                cell.style.background = 'rgba(255,255,255,0.05)';
            }
            
            matrixRow.appendChild(cell);
        }
        
        matrixContent.appendChild(matrixRow);
    }
}
// NEW: Perform Inversions Analysis
function performInversionsAnalysis() {
    const arrayContainer = document.getElementById('inversionsArray');
    const explanation = document.getElementById('inversionsExplanation');
    const stepsContainer = document.getElementById('inversionsSteps');
    const localCount = document.getElementById('localCount');
    const globalCount = document.getElementById('globalCount');
    const relationshipDiv = document.getElementById('inversionRelationship');
    const relationshipContent = document.getElementById('relationshipContent');
    const continueButton = document.getElementById('continueAfterInversions');
    
    const arr = originalArrayForInversions.map(val => parseFloat(val));
    const n = arr.length;
    
    let localInversions = [];
    let globalInversions = [];
    let step = 0;
    
    function performAnalysisStep() {
        if (step === 0) {
            // Step 1: Explain what we're doing
            explanation.innerHTML = "Step 1: Understanding what inversions are...";
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Definition of Inversions
                </div>
                <div class="algorithm-step">
                     <strong>Local Inversion:</strong> arr[i] > arr[i+1] (adjacent elements)
                </div>
                <div class="algorithm-step">
                     <strong>Global Inversion:</strong> arr[i] > arr[j] where i < j (any elements)
                </div>
            `;
            step++;
            setTimeout(performAnalysisStep, 3000);
            
        } else if (step === 1) {
            // Step 2: Find local inversions
            explanation.innerHTML = "Step 2: Finding LOCAL inversions (adjacent elements)...";
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 2:</strong> Scanning for local inversions
                </div>
            `;
            
            findLocalInversionsStep(0);
            
        } else if (step === 2) {
            // Step 3: Find global inversions
            explanation.innerHTML = "Step 3: Finding GLOBAL inversions (any elements)...";
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 3:</strong> Scanning for global inversions
                </div>
            `;
            
            findGlobalInversionsStep(0, 1);
            
        } else {
            // Analysis completed
            explanation.innerHTML = "<strong>Analysis Completed!</strong> All inversions found and analyzed.";
            
            // Show relationship analysis
            showRelationshipAnalysis();
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterInversions();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterInversions);
        }
    }
    
    function findLocalInversionsStep(i) {
        if (i >= n - 1) {
            // Local inversions completed
            localCount.textContent = `Local Inversions: ${localInversions.length}`;
            step++;
            setTimeout(performAnalysisStep, 1000);
            return;
        }
        
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElement = elements[i].querySelector('.element-value');
        const nextElement = elements[i + 1].querySelector('.element-value');
        
        // Highlight current pair being checked
        currentElement.classList.add('sorting-current');
        nextElement.classList.add('sorting-compared');
        
        explanation.innerHTML = `Checking positions ${i} and ${i+1}: ${arr[i]} vs ${arr[i+1]}`;
        
        setTimeout(() => {
            if (arr[i] > arr[i + 1]) {
                // Found local inversion
                localInversions.push({
                    indices: [i, i + 1],
                    values: [arr[i], arr[i + 1]],
                    type: 'local'
                });
                
                currentElement.classList.remove('sorting-current');
                nextElement.classList.remove('sorting-compared');
                currentElement.classList.add('local-inversion');
                nextElement.classList.add('local-inversion');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Local Inversion Found:</strong> [${i}](${arr[i]}) > [${i+1}](${arr[i+1]})
                    </div>
                `;
                
                // Update matrix
                const matrixCell = document.getElementById(`matrix-${i}-${i + 1}`);
                matrixCell.textContent = 'L';
                matrixCell.classList.add('local');
                
            } else {
                currentElement.classList.remove('sorting-current');
                nextElement.classList.remove('sorting-compared');
            }
            
            // Move to next pair
            setTimeout(() => findLocalInversionsStep(i + 1), 1000);
        }, 1500);
    }
    
    function findGlobalInversionsStep(i, j) {
        if (i >= n - 1) {
            // Global inversions completed
            globalCount.textContent = `Global Inversions: ${globalInversions.length}`;
            step++;
            setTimeout(performAnalysisStep, 1000);
            return;
        }
        
        if (j >= n) {
            // Move to next i
            findGlobalInversionsStep(i + 1, i + 2);
            return;
        }
        
        const elements = arrayContainer.querySelectorAll('.array-element');
        const elementI = elements[i].querySelector('.element-value');
        const elementJ = elements[j].querySelector('.element-value');
        
        // Highlight current pair being checked
        elementI.classList.add('sorting-current');
        elementJ.classList.add('sorting-compared');
        
        explanation.innerHTML = `Checking positions ${i} and ${j}: ${arr[i]} vs ${arr[j]}`;
        
        setTimeout(() => {
            if (arr[i] > arr[j]) {
                // Found global inversion
                globalInversions.push({
                    indices: [i, j],
                    values: [arr[i], arr[j]],
                    type: 'global'
                });
                
                elementI.classList.remove('sorting-current');
                elementJ.classList.remove('sorting-compared');
                elementI.classList.add('global-inversion');
                elementJ.classList.add('global-inversion');
                
                // Create connection line
                createConnectionLine(i, j);
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Global Inversion Found:</strong> [${i}](${arr[i]}) > [${j}](${arr[j]})
                    </div>
                `;
                
                // Update matrix
                const matrixCell = document.getElementById(`matrix-${i}-${j}`);
                matrixCell.textContent = 'G';
                matrixCell.classList.add('inversion');
                
            } else {
                elementI.classList.remove('sorting-current');
                elementJ.classList.remove('sorting-compared');
            }
            
            // Move to next j
            setTimeout(() => findGlobalInversionsStep(i, j + 1), 800);
        }, 1200);
    }
    
    function createConnectionLine(startIdx, endIdx) {
        const elements = arrayContainer.querySelectorAll('.array-element');
        const startRect = elements[startIdx].getBoundingClientRect();
        const endRect = elements[endIdx].getBoundingClientRect();
        const containerRect = arrayContainer.getBoundingClientRect();
        
        const line = document.createElement('div');
        line.className = 'inversion-connection-line';
        
        const startX = startRect.left + startRect.width / 2 - containerRect.left;
        const endX = endRect.left + endRect.width / 2 - containerRect.left;
        const y = startRect.top + startRect.height / 2 - containerRect.top;
        
        line.style.width = Math.abs(endX - startX) + 'px';
        line.style.left = Math.min(startX, endX) + 'px';
        line.style.top = y + 'px';
        
        arrayContainer.appendChild(line);
    }
    
    function showRelationshipAnalysis() {
        relationshipDiv.style.display = 'block';
        
        const localCount = localInversions.length;
        const globalCount = globalInversions.length;
        const localAlsoGlobal = localInversions.filter(localInv => 
            globalInversions.some(globalInv => 
                globalInv.indices[0] === localInv.indices[0] && 
                globalInv.indices[1] === localInv.indices[1]
            )
        ).length;
        
        let relationshipHTML = `
            <p><strong>Key Insight:</strong> Every LOCAL inversion is also a GLOBAL inversion</p>
            <p> Total Local Inversions: ${localCount}</p>
            <p> Total Global Inversions: ${globalCount}</p>
            <p> Local inversions that are also global: ${localAlsoGlobal}</p>
            <p> Global inversions that are NOT local: ${globalCount - localCount}</p>
        `;
        
        if (localCount === globalCount) {
            relationshipHTML += `
                <div class="alert alert-success mt-2">
                    <strong>Special Property Found!</strong><br>
                    All global inversions are also local inversions!<br>
                    This array has the "ideal" inversion property.
                </div>
            `;
        } else {
            relationshipHTML += `
                <div class="alert alert-info mt-2">
                    <strong>Normal Case:</strong><br>
                    There are global inversions that are not local inversions.<br>
                    This is the typical case for most arrays.
                </div>
            `;
        }
        
        relationshipContent.innerHTML = relationshipHTML;
    }
    
    // Start analysis
    performAnalysisStep();
}
// NEW: Return to Original after Inversions Analysis
function returnToOriginalAfterInversions() {
    // Reset to original array
    myArray = [...originalArrayForInversions];
    originalArrayForInversions = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isInversionsAnalysisRunning = false;
    
    logOperation('Inversions analysis completed - returned to original array', 'info');
    showNotification('Returned to original array after inversions analysis', 'success');
}
// NEW: Summary Ranges Handler
function handleSummaryRanges() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isSummaryRangesRunning) {
        showNotification('Summary ranges operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Summary ranges requires all array elements to be numbers', 'danger');
        return;
    }
    
    isSummaryRangesRunning = true;
    
    // Store original array
    originalArrayForSummaryRanges = [...myArray];
    
    // Perform summary ranges visualization
    performSummaryRangesVisualization();
}

// NEW: Find Right Interval Handler
function handleFindRightInterval() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isFindRightIntervalRunning) {
        showNotification('Find right interval operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains intervals (pairs of numbers)
    let validIntervals = true;
    if (myArray.length % 2 !== 0) {
        showNotification('Find right interval requires even number of elements (pairs for intervals)', 'danger');
        return;
    }
    
    // Convert array to intervals
    const intervals = [];
    for (let i = 0; i < myArray.length; i += 2) {
        const start = parseFloat(myArray[i]);
        const end = parseFloat(myArray[i + 1]);
        
        if (isNaN(start) || isNaN(end)) {
            validIntervals = false;
            break;
        }
        intervals.push([start, end]);
    }
    
    if (!validIntervals) {
        showNotification('Find right interval requires all elements to be numbers representing intervals [start, end]', 'danger');
        return;
    }
    
    isFindRightIntervalRunning = true;
    
    // Store original array
    originalArrayForRightInterval = [...myArray];
    
    // Perform find right interval visualization
    performFindRightIntervalVisualization(intervals);
}

// NEW: Perform Summary Ranges Visualization
function performSummaryRangesVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Summary Ranges Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalSummaryArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Summary Ranges Result</div>
            <div class="transformed-array-container" id="transformedSummaryArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Summary Ranges:</strong> Find smallest sorted list of ranges that cover all numbers</p>
            <p class="mb-0" id="summaryExplanation">Starting summary ranges algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="summaryStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="summarySteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Ranges Found</div>
            <div class="stats-value" id="rangesCount">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Compression Ratio</div>
            <div class="stats-value" id="compressionRatio">1.00</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSummary" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSummaryRanges, 'originalSummaryArray');
    renderArrayInContainer([], 'transformedSummaryArray');
    
    executeSummaryRangesAlgorithm();
}

// NEW: Execute Summary Ranges Algorithm
function executeSummaryRangesAlgorithm() {
    const originalContainer = document.getElementById('originalSummaryArray');
    const transformedContainer = document.getElementById('transformedSummaryArray');
    const explanation = document.getElementById('summaryExplanation');
    const stepsContainer = document.getElementById('summarySteps');
    const rangesCount = document.getElementById('rangesCount');
    const compressionRatio = document.getElementById('compressionRatio');
    const continueButton = document.getElementById('continueAfterSummary');
    
    const nums = originalArrayForSummaryRanges.map(val => parseInt(val)).sort((a, b) => a - b);
    const ranges = [];
    let step = 0;
    let currentRange = [];
    
    function executeSummaryStep(i) {
        if (i >= nums.length) {
            // Algorithm completed
            if (currentRange.length > 0) {
                // Add the last range
                if (currentRange.length === 1) {
                    ranges.push(`'${currentRange[0]}'`);
                } else {
                    ranges.push(`'${currentRange[0]}->${currentRange[currentRange.length - 1]}'`);
                }
            }
            
            explanation.innerHTML = `<strong>Summary Ranges Completed!</strong> Found ${ranges.length} ranges.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Found ${ranges.length} ranges covering ${nums.length} numbers
                </div>
            `;
            
            // Display the ranges
            renderRangesInContainer(ranges, 'transformedSummaryArray');
            
            rangesCount.textContent = ranges.length;
            const ratio = nums.length / ranges.length;
            compressionRatio.textContent = ratio.toFixed(2);
            
            continueButton.style.display = 'block';
            
            // Auto-return after 15 seconds
            setTimeout(() => {
                returnToOriginalAfterSummary();
            }, 15000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSummary);
            
            return;
        }
        
        step++;
        
        if (i === 0) {
            // First element
            explanation.innerHTML = `Step ${step}: Start first range with number ${nums[i]}`;
            currentRange = [nums[i]];
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Start range with ${nums[i]}
                </div>
            `;
            
            // Highlight the first element
            const originalElements = originalContainer.querySelectorAll('.array-element');
            originalElements[i].querySelector('.element-value').classList.add('create');
            
            setTimeout(() => {
                executeSummaryStep(i + 1);
            }, 1500);
            
        } else {
            const currentNum = nums[i];
            const prevNum = nums[i - 1];
            
            if (currentNum === prevNum + 1) {
                // Consecutive number - continue current range
                explanation.innerHTML = `Step ${step}: ${currentNum} is consecutive to ${prevNum} - continue range`;
                
                currentRange.push(currentNum);
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step}:</strong> ${currentNum} consecutive to ${prevNum} - range continues
                    </div>
                `;
                
                // Highlight current element
                const originalElements = originalContainer.querySelectorAll('.array-element');
                originalElements[i].querySelector('.element-value').classList.add('info-color');
                
                setTimeout(() => {
                    executeSummaryStep(i + 1);
                }, 1500);
                
            } else {
                // Non-consecutive - end current range and start new one
                explanation.innerHTML = `Step ${step}: ${currentNum} breaks sequence - end current range`;
                
                // Add completed range
                if (currentRange.length === 1) {
                    ranges.push(`'${currentRange[0]}'`);
                } else {
                    ranges.push(`'${currentRange[0]}->${currentRange[currentRange.length - 1]}'`);
                }
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> Range ended: ${currentRange.length === 1 ? 
                            `Single number ${currentRange[0]}` : 
                            `From ${currentRange[0]} to ${currentRange[currentRange.length - 1]} (${currentRange.length} numbers)`}
                    </div>
                `;
                
                // Start new range
                currentRange = [currentNum];
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step + 0.5}:</strong> Start new range with ${currentNum}
                    </div>
                `;
                
                // Highlight the break and new start
                const originalElements = originalContainer.querySelectorAll('.array-element');
                originalElements[i].querySelector('.element-value').classList.add('create');
                
                // Update ranges display
                renderRangesInContainer(ranges, 'transformedSummaryArray');
                
                setTimeout(() => {
                    executeSummaryStep(i + 1);
                }, 2000);
            }
        }
    }
    
    // Start algorithm
    executeSummaryStep(0);
}

// NEW: Perform Find Right Interval Visualization
function performFindRightIntervalVisualization(intervals) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find Right Interval Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Intervals</div>
            <div class="original-array-container" id="originalIntervalArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Right Interval Mapping</div>
            <div class="transformed-array-container" id="transformedIntervalArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Find Right Interval:</strong> For each interval, find the right interval with smallest start  current end</p>
            <p class="mb-0" id="intervalExplanation">Starting find right interval algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="intervalStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="intervalSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterInterval" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderIntervalsInContainer(intervals, 'originalIntervalArray');
    renderArrayInContainer([], 'transformedIntervalArray');
    
    executeFindRightIntervalAlgorithm(intervals);
}

// NEW: Execute Find Right Interval Algorithm
function executeFindRightIntervalAlgorithm(intervals) {
    const originalContainer = document.getElementById('originalIntervalArray');
    const transformedContainer = document.getElementById('transformedIntervalArray');
    const explanation = document.getElementById('intervalExplanation');
    const stepsContainer = document.getElementById('intervalSteps');
    const continueButton = document.getElementById('continueAfterInterval');
    
    // Create indexed intervals
    const indexedIntervals = intervals.map((interval, idx) => [...interval, idx]);
    
    // Sort by start point
    const sortedIntervals = [...indexedIntervals].sort((a, b) => a[0] - b[0]);
    const sortedStarts = sortedIntervals.map(interval => interval[0]);
    
    const result = new Array(intervals.length).fill(-1);
    let step = 0;
    
    function executeIntervalStep(i) {
        if (i >= sortedIntervals.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Find Right Interval Completed!</strong> Processed ${intervals.length} intervals.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Right interval mapping completed
                </div>
            `;
            
            // Display the result
            renderRightIntervalResult(result, 'transformedIntervalArray');
            
            continueButton.style.display = 'block';
            
            // Auto-return after 15 seconds
            setTimeout(() => {
                returnToOriginalAfterInterval();
            }, 15000);
            
            continueButton.addEventListener('click', returnToOriginalAfterInterval);
            
            return;
        }
        
        step++;
        
        const [start, end, origIdx] = sortedIntervals[i];
        
        explanation.innerHTML = `Step ${step}: Processing interval ${origIdx} [${start}, ${end}]`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> Interval ${origIdx} [${start}, ${end}] - Find start  ${end}
            </div>
        `;
        
        // Highlight current interval
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const intervalIndex = origIdx * 2; // Each interval takes 2 elements in display
        originalElements[intervalIndex].querySelector('.element-value').classList.add('sorting-current');
        originalElements[intervalIndex + 1].querySelector('.element-value').classList.add('sorting-current');
        
        // Binary search for right interval
        let left = 0, right = sortedStarts.length - 1;
        let rightIntervalIdx = -1;
        
        function performBinarySearch() {
            if (left > right) {
                // Search completed
                if (rightIntervalIdx !== -1) {
                    const [rightStart, rightEnd, rightOrigIdx] = sortedIntervals[rightIntervalIdx];
                    result[origIdx] = rightOrigIdx;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step}.${1}:</strong> Found interval ${rightOrigIdx} [${rightStart}, ${rightEnd}] with start ${rightStart}  ${end}
                        </div>
                    `;
                    
                    // Highlight the found interval
                    const foundIntervalIndex = rightOrigIdx * 2;
                    originalElements[foundIntervalIndex].querySelector('.element-value').classList.add('success-color');
                    originalElements[foundIntervalIndex + 1].querySelector('.element-value').classList.add('success-color');
                    
                } else {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step}.${1}:</strong> No right interval found for [${start}, ${end}]
                        </div>
                    `;
                }
                
                // Update result display
                renderRightIntervalResult(result, 'transformedIntervalArray');
                
                // Remove highlights and continue
                setTimeout(() => {
                    originalElements[intervalIndex].querySelector('.element-value').classList.remove('sorting-current');
                    originalElements[intervalIndex + 1].querySelector('.element-value').classList.remove('sorting-current');
                    
                    if (rightIntervalIdx !== -1) {
                        const foundIntervalIndex = sortedIntervals[rightIntervalIdx][2] * 2;
                        originalElements[foundIntervalIndex].querySelector('.element-value').classList.remove('success-color');
                        originalElements[foundIntervalIndex + 1].querySelector('.element-value').classList.remove('success-color');
                    }
                    
                    executeIntervalStep(i + 1);
                }, 2000);
                
                return;
            }
            
            const mid = Math.floor((left + right) / 2);
            const [midStart, midEnd, midOrigIdx] = sortedIntervals[mid];
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}.${mid - left + 1}:</strong> Check interval ${midOrigIdx} [${midStart}, ${midEnd}] - ${midStart}  ${end}? ${midStart >= end ? 'YES' : 'NO'}
                </div>
            `;
            
            // Highlight the checked interval
            const midIntervalIndex = midOrigIdx * 2;
            originalElements[midIntervalIndex].querySelector('.element-value').classList.add('sorting-compared');
            
            setTimeout(() => {
                originalElements[midIntervalIndex].querySelector('.element-value').classList.remove('sorting-compared');
                
                if (sortedStarts[mid] >= end) {
                    rightIntervalIdx = mid;
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
                
                performBinarySearch();
            }, 1500);
        }
        
        // Start binary search
        performBinarySearch();
    }
    
    // Start algorithm
    executeIntervalStep(0);
}

// NEW: Helper function to render ranges
function renderRangesInContainer(ranges, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    ranges.forEach((range, index) => {
        const rangeElement = document.createElement('div');
        rangeElement.className = 'array-element';
        rangeElement.innerHTML = `
            <div class="element-value create" style="min-width: 100px;">
                ${range}
            </div>
            <div class="element-index">Range ${index + 1}</div>
        `;
        container.appendChild(rangeElement);
    });
}

// NEW: Helper function to render intervals
function renderIntervalsInContainer(intervals, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    intervals.forEach((interval, index) => {
        const intervalGroup = document.createElement('div');
        intervalGroup.className = 'd-flex align-items-center mb-2';
        intervalGroup.innerHTML = `
            <div class="array-element me-2">
                <div class="element-value">${interval[0]}</div>
                <div class="element-index">Start</div>
            </div>
            <div class="array-element">
                <div class="element-value">${interval[1]}</div>
                <div class="element-index">End</div>
            </div>
            <small class="ms-2 text-muted">Interval ${index}</small>
        `;
        container.appendChild(intervalGroup);
    });
}

// NEW: Helper function to render right interval result
function renderRightIntervalResult(result, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    result.forEach((rightIdx, index) => {
        const resultElement = document.createElement('div');
        resultElement.className = 'array-element';
        const bgClass = rightIdx === -1 ? 'danger-color' : 'success-color';
        resultElement.innerHTML = `
            <div class="element-value ${bgClass}" style="min-width: 80px;">
                ${rightIdx === -1 ? 'None' : rightIdx}
            </div>
            <div class="element-index">For interval ${index}</div>
        `;
        container.appendChild(resultElement);
    });
}

// NEW: Return to Original after Summary Ranges
function returnToOriginalAfterSummary() {
    myArray = [...originalArrayForSummaryRanges];
    originalArrayForSummaryRanges = [];
    isSummaryRangesRunning = false;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    logOperation('Summary ranges completed - returned to original array', 'info');
    showNotification('Returned to original array after summary ranges', 'success');
}

// NEW: Return to Original after Find Right Interval
function returnToOriginalAfterInterval() {
    myArray = [...originalArrayForRightInterval];
    originalArrayForRightInterval = [];
    isFindRightIntervalRunning = false;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    logOperation('Find right interval completed - returned to original array', 'info');
    showNotification('Returned to original array after find right interval', 'success');
}
// NEW: Minimum Arrows Handler
function handleMinArrows() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isMinArrowsRunning) {
        showNotification('Minimum arrows operation is already in progress', 'warning');
        return;
    }
    
    // Check if array can be converted to intervals
    // For this demo, we'll generate sample intervals based on array values
    balloonIntervals = generateIntervalsFromArray(myArray);
    
    if (balloonIntervals.length === 0) {
        showNotification('Could not generate valid intervals from array', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForArrows = [...myArray];
    
    // Show minimum arrows visualization
    showMinArrowsVisualization();
}

// NEW: Generate intervals from array for demonstration
function generateIntervalsFromArray(arr) {
    const intervals = [];
    
    // Convert array elements to intervals
    // For demo purposes, create intervals based on array indices and values
    for (let i = 0; i < arr.length; i++) {
        const num = parseFloat(arr[i]);
        if (!isNaN(num)) {
            // Create interval around the number
            const start = Math.max(0, Math.floor(num - Math.random() * 3));
            const end = Math.floor(num + Math.random() * 3 + 1);
            if (start <= end) {
                intervals.push([start, end]);
            }
        } else {
            // For non-numeric values, create intervals based on index
            const start = i * 2;
            const end = start + Math.floor(Math.random() * 3) + 1;
            intervals.push([start, end]);
        }
    }
    
    return intervals;
}
// NEW: Show Minimum Arrows Visualization
function showMinArrowsVisualization() {
    isMinArrowsRunning = true;
    
    const container = document.createElement('div');
    container.className = 'dual-operation-container';
    container.innerHTML = `
        <h5 class="text-center mb-3"> Minimum Arrows to Burst Balloons</h5>
        
        <div class="array-group">
            <div class="array-label">Balloon Intervals [start, end]</div>
            <div class="intervals-container" id="intervalsContainer"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find minimum arrows to burst all overlapping balloons</p>
            <p class="mb-0" id="arrowsExplanation">Initializing algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="arrowsStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="arrowsSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Minimum Arrows Needed</div>
            <div class="stats-value" id="minArrowsValue">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Arrow Positions</div>
            <div class="stats-value" id="arrowPositionsValue">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterArrows" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(container);
    
    renderIntervalsVisualization();
    performMinArrowsAlgorithm();
}

// NEW: Render Intervals Visualization
function renderIntervalsVisualization() {
    const container = document.getElementById('intervalsContainer');
    container.innerHTML = '';
    
    // Find the overall range for visualization
    const allStarts = balloonIntervals.map(interval => interval[0]);
    const allEnds = balloonIntervals.map(interval => interval[1]);
    const minVal = Math.min(...allStarts);
    const maxVal = Math.max(...allEnds);
    const range = maxVal - minVal;
    
    balloonIntervals.forEach((interval, index) => {
        const [start, end] = interval;
        
        const intervalItem = document.createElement('div');
        intervalItem.className = 'interval-item';
        intervalItem.innerHTML = `
            <div class="interval-range">[${start}, ${end}]</div>
            <div class="interval-visual">
                <div class="interval-bar" id="intervalBar${index}"></div>
            </div>
            <div class="balloon-interval" id="balloon${index}">Balloon ${index}</div>
        `;
        
        container.appendChild(intervalItem);
        
        // Set the visual bar position and width
        setTimeout(() => {
            const bar = document.getElementById(`intervalBar${index}`);
            if (bar) {
                const leftPercent = ((start - minVal) / range) * 100;
                const widthPercent = ((end - start) / range) * 100;
                bar.style.left = `${leftPercent}%`;
                bar.style.width = `${widthPercent}%`;
            }
        }, 100);
    });
}

// NEW: Perform Minimum Arrows Algorithm with Animation
function performMinArrowsAlgorithm() {
    const explanation = document.getElementById('arrowsExplanation');
    const stepsContainer = document.getElementById('arrowsSteps');
    const minArrowsValue = document.getElementById('minArrowsValue');
    const arrowPositionsValue = document.getElementById('arrowPositionsValue');
    const continueButton = document.getElementById('continueAfterArrows');
    
    // Sort balloons by end position
    const sortedBalloons = [...balloonIntervals].sort((a, b) => a[1] - b[1]);
    let arrows = 0;
    let arrowPositions = [];
    let currentArrow = -Infinity;
    let step = 0;
    
    explanation.innerHTML = `Step ${++step}: Sorting balloons by end position`;
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Step ${step}:</strong> Sorting balloons by end position
        </div>
    `;
    
    // Highlight sorted order
    setTimeout(() => {
        highlightSortedBalloons(sortedBalloons);
        
        setTimeout(() => {
            explanation.innerHTML = `Step ${++step}: Starting arrow placement strategy`;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Initialize arrow placement
                </div>
            `;
            
            processBalloonsRecursively(0);
        }, 2000);
    }, 1500);
    
    function processBalloonsRecursively(index) {
        if (index >= sortedBalloons.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Found minimum arrows: ${arrows}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Minimum arrows needed = ${arrows}
                </div>
                <div class="algorithm-step active">
                    <strong>Arrow Positions:</strong> ${arrowPositions.join(', ')}
                </div>
            `;
            
            minArrowsValue.textContent = arrows;
            arrowPositionsValue.textContent = arrowPositions.join(', ');
            
            // Show final arrow positions on visualization
            showFinalArrowPositions(arrowPositions);
            
            continueButton.style.display = 'block';
            
            // Auto-return after 15 seconds
            setTimeout(() => {
                returnToOriginalAfterArrows();
            }, 15000);
            
            continueButton.addEventListener('click', returnToOriginalAfterArrows);
            
            return;
        }
        
        const [start, end] = sortedBalloons[index];
        step++;
        
        if (currentArrow < start) {
            // Need new arrow
            arrows++;
            currentArrow = end;
            arrowPositions.push(currentArrow);
            
            explanation.innerHTML = `Step ${step}: Shooting arrow ${arrows} at position ${currentArrow}`;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Arrow ${arrows} at position ${currentArrow} - bursts balloon [${start}, ${end}]
                </div>
            `;
            
            // Show arrow animation
            shootArrowAnimation(currentArrow, index, () => {
                // Find all balloons burst by this arrow
                const burstBalloons = [];
                for (let i = index; i < sortedBalloons.length; i++) {
                    const [s, e] = sortedBalloons[i];
                    if (s <= currentArrow && currentArrow <= e) {
                        burstBalloons.push(i);
                    }
                }
                
                // Highlight burst balloons
                highlightBurstBalloons(burstBalloons, () => {
                    // Continue with next unburst balloon
                    let nextIndex = index + 1;
                    while (nextIndex < sortedBalloons.length) {
                        const [nextStart, nextEnd] = sortedBalloons[nextIndex];
                        if (nextStart > currentArrow) {
                            break;
                        }
                        nextIndex++;
                    }
                    
                    processBalloonsRecursively(nextIndex);
                });
            });
            
        } else {
            // Current arrow can burst this balloon
            explanation.innerHTML = `Step ${step}: Arrow at ${currentArrow} bursts balloon [${start}, ${end}]`;
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}:</strong> Existing arrow at ${currentArrow} bursts balloon [${start}, ${end}]
                </div>
            `;
            
            // Highlight as burst by existing arrow
            highlightBalloonBurst(index, () => {
                processBalloonsRecursively(index + 1);
            });
        }
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
    }
}

// NEW: Helper function to highlight sorted balloons
function highlightSortedBalloons(sortedBalloons) {
    sortedBalloons.forEach((interval, sortedIndex) => {
        const originalIndex = balloonIntervals.findIndex(
            orig => orig[0] === interval[0] && orig[1] === interval[1]
        );
        
        if (originalIndex !== -1) {
            const balloon = document.getElementById(`balloon${originalIndex}`);
            const bar = document.getElementById(`intervalBar${originalIndex}`);
            
            if (balloon && bar) {
                setTimeout(() => {
                    balloon.classList.add('balloon-active');
                    bar.style.background = 'var(--warning-color)';
                    
                    // Add sorted index label
                    balloon.textContent = `Balloon ${originalIndex}  Sorted ${sortedIndex}`;
                }, sortedIndex * 200);
            }
        }
    });
}

// NEW: Shoot arrow animation
function shootArrowAnimation(arrowPos, balloonIndex, callback) {
    const allStarts = balloonIntervals.map(interval => interval[0]);
    const allEnds = balloonIntervals.map(interval => interval[1]);
    const minVal = Math.min(...allStarts);
    const maxVal = Math.max(...allEnds);
    const range = maxVal - minVal;
    
    const arrowPercent = ((arrowPos - minVal) / range) * 100;
    
    // Create arrow marker
    const intervalVisuals = document.querySelectorAll('.interval-visual');
    intervalVisuals.forEach(visual => {
        const arrowMarker = document.createElement('div');
        arrowMarker.className = 'arrow-marker';
        arrowMarker.style.left = `${arrowPercent}%`;
        
        const arrowLabel = document.createElement('div');
        arrowLabel.className = 'arrow-label';
        arrowLabel.textContent = `Arrow at ${arrowPos}`;
        arrowLabel.style.left = `${arrowPercent}%`;
        
        visual.appendChild(arrowMarker);
        visual.appendChild(arrowLabel);
        
        // Add shot animation
        setTimeout(() => {
            arrowMarker.classList.add('arrow-shot');
            arrowLabel.classList.add('arrow-shot');
        }, 500);
    });
    
    setTimeout(callback, 1500);
}

// NEW: Highlight burst balloons
function highlightBurstBalloons(balloonIndices, callback) {
    let completed = 0;
    
    balloonIndices.forEach((balloonIndex, idx) => {
        setTimeout(() => {
            const balloon = document.getElementById(`balloon${balloonIndex}`);
            const bar = document.getElementById(`intervalBar${balloonIndex}`);
            
            if (balloon && bar) {
                balloon.classList.add('balloon-burst');
                bar.style.background = 'var(--success-color)';
                balloon.textContent = `Balloon ${balloonIndex}  BURST`;
            }
            
            completed++;
            if (completed === balloonIndices.length) {
                setTimeout(callback, 500);
            }
        }, idx * 300);
    });
}

// NEW: Highlight single balloon burst
function highlightBalloonBurst(balloonIndex, callback) {
    const balloon = document.getElementById(`balloon${balloonIndex}`);
    const bar = document.getElementById(`intervalBar${balloonIndex}`);
    
    if (balloon && bar) {
        balloon.classList.add('balloon-burst');
        bar.style.background = 'var(--success-color)';
        balloon.textContent = `Balloon ${balloonIndex}  BURST`;
    }
    
    setTimeout(callback, 800);
}

// NEW: Show final arrow positions
function showFinalArrowPositions(arrowPositions) {
    const allStarts = balloonIntervals.map(interval => interval[0]);
    const allEnds = balloonIntervals.map(interval => interval[1]);
    const minVal = Math.min(...allStarts);
    const maxVal = Math.max(...allEnds);
    
    arrowPositions.forEach((arrowPos, index) => {
        const arrowPercent = ((arrowPos - minVal) / (maxVal - minVal)) * 100;
        
        const intervalVisuals = document.querySelectorAll('.interval-visual');
        intervalVisuals.forEach(visual => {
            const finalArrow = document.createElement('div');
            finalArrow.className = 'arrow-marker';
            finalArrow.style.left = `${arrowPercent}%`;
            finalArrow.style.background = 'var(--danger-color)';
            finalArrow.style.zIndex = '10';
            
            const finalLabel = document.createElement('div');
            finalLabel.className = 'arrow-label';
            finalLabel.textContent = `Arrow ${index + 1}`;
            finalLabel.style.left = `${arrowPercent}%`;
            finalLabel.style.background = 'var(--danger-color)';
            finalLabel.style.zIndex = '10';
            
            visual.appendChild(finalArrow);
            visual.appendChild(finalLabel);
        });
    });
}

// NEW: Return to Original after Arrows Operation
function returnToOriginalAfterArrows() {
    // Reset to original array
    myArray = [...originalArrayForArrows];
    originalArrayForArrows = [];
    balloonIntervals = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMinArrowsRunning = false;
    
    logOperation('Minimum arrows operation completed - returned to original array', 'info');
    showNotification('Returned to original array after minimum arrows operation', 'success');
}
// NEW: Teemo Attacking Handler
function handleTeemoAttacking() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add attack times first.', 'warning');
        return;
    }
    
    if (isTeemoAttackingRunning) {
        showNotification('Teemo attacking operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers (attack times)
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Teemo attacking requires all array elements to be numbers (attack times)', 'danger');
        return;
    }
    
    // Check if array is sorted (attack times should be in order)
    const sortedArray = [...myArray].sort((a, b) => parseFloat(a) - parseFloat(b));
    const isSorted = JSON.stringify(myArray.map(Number)) === JSON.stringify(sortedArray.map(Number));
    
    if (!isSorted) {
        showNotification('Attack times should be in ascending order. Auto-sorting...', 'warning');
        myArray = sortedArray;
        renderArray();
    }
    
    // Ask for duration
    const duration = prompt('Enter poison duration (in time units):');
    if (duration === null) return;
    
    const poisonDuration = parseFloat(duration);
    if (isNaN(poisonDuration) || poisonDuration <= 0) {
        showNotification('Please enter a valid positive duration', 'danger');
        return;
    }
    
    teemoDuration = poisonDuration;
    isTeemoAttackingRunning = true;
    
    // Store original array
    originalArrayForTeemo = [...myArray];
    
    // Show Teemo attacking visualization
    showTeemoAttackingVisualization();
}

// NEW: Show Teemo Attacking Visualization - IMPROVED
function showTeemoAttackingVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Teemo Attacking - Poison Duration Calculation</h5>
        
        <div class="array-group">
            <div class="array-label">Attack Times Array</div>
            <div class="original-array-container" id="teemoAttackTimes"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Poison Effect Timeline Visualization</div>
            <div class="teemo-timeline-container">
                <div class="timeline-axis" id="timelineAxis"></div>
                <div class="timeline-segments" id="teemoTimeline"></div>
                <div class="timeline-legend">
                    <div class="legend-item">
                        <div class="legend-color legend-normal"></div>
                        <span>Normal Poison Duration</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color legend-overlap"></div>
                        <span>Overlapping Poison</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color legend-active"></div>
                        <span>Currently Active</span>
                    </div>
                </div>
                <div class="timeline-stats">
                    <div class="timeline-stat">
                        <div>Poison Duration</div>
                        <div class="timeline-stat-value">${teemoDuration}</div>
                    </div>
                    <div class="timeline-stat">
                        <div>Total Attacks</div>
                        <div class="timeline-stat-value">${myArray.length}</div>
                    </div>
                    <div class="timeline-stat">
                        <div>Time Range</div>
                        <div class="timeline-stat-value" id="timeRange">0-0</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Calculate total poisoned time with duration ${teemoDuration}</p>
            <p class="mb-0" id="teemoExplanation">Initializing poison duration calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="teemoStepsContainer">
            <h6 class="text-center">Poison Duration Calculation Steps</h6>
            <div class="steps-container" id="teemoSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Total Poisoned Time</div>
            <div class="stats-value" id="totalPoisonedTime">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Current Calculation</div>
            <div class="stats-value" id="currentCalculation">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterTeemo" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForTeemo, 'teemoAttackTimes');
    
    performTeemoAttackingAnimation();
}
// NEW: Perform Teemo Attacking Animation - IMPROVED
function performTeemoAttackingAnimation() {
    const attackContainer = document.getElementById('teemoAttackTimes');
    const timelineContainer = document.getElementById('teemoTimeline');
    const timelineAxis = document.getElementById('timelineAxis');
    const explanation = document.getElementById('teemoExplanation');
    const stepsContainer = document.getElementById('teemoSteps');
    const totalPoisonedTime = document.getElementById('totalPoisonedTime');
    const currentCalculation = document.getElementById('currentCalculation');
    const timeRange = document.getElementById('timeRange');
    const continueButton = document.getElementById('continueAfterTeemo');
    
    const attackTimes = originalArrayForTeemo.map(val => parseFloat(val));
    let totalPoisoned = 0;
    let step = 0;
    
    // Calculate timeline scale
    const maxTime = Math.max(...attackTimes) + teemoDuration;
    const minTime = Math.min(...attackTimes);
    const timeRangeValue = maxTime - minTime;
    const scaleFactor = Math.min(500 / (timeRangeValue || 1), 50); // Dynamic scaling
    
    timeRange.textContent = `${minTime}-${maxTime}`;
    
    // Create timeline axis
    timelineAxis.innerHTML = '';
    for (let i = minTime; i <= maxTime; i += Math.ceil(timeRangeValue / 10)) {
        const tick = document.createElement('div');
        tick.className = 'timeline-axis-label';
        tick.style.left = `${((i - minTime) * scaleFactor) + 10}px`;
        tick.textContent = i;
        timelineAxis.appendChild(tick);
    }
    
    function performTeemoStep(i) {
        if (i >= attackTimes.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong> Calculation Completed!</strong> Total poisoned time = ${totalPoisoned} units`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong> Final Result:</strong> Total poisoned duration = <strong>${totalPoisoned}</strong> time units
                </div>
            `;
            
            totalPoisonedTime.textContent = totalPoisoned;
            currentCalculation.textContent = 'COMPLETED';
            
            // Highlight all timeline segments
            const segments = timelineContainer.querySelectorAll('.timeline-segment');
            segments.forEach(segment => {
                segment.classList.add('active');
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 15 seconds
            setTimeout(() => {
                returnToOriginalAfterTeemo();
            }, 15000);
            
            continueButton.addEventListener('click', returnToOriginalAfterTeemo);
            
            return;
        }
        
        step++;
        
        if (i === 0) {
            // First attack
            explanation.innerHTML = ` Step ${step}: First attack at time <strong>${attackTimes[i]}</strong>`;
            currentCalculation.textContent = `First attack: +${teemoDuration}`;
            
            const attackElements = attackContainer.querySelectorAll('.array-element');
            attackElements[i].querySelector('.element-value').classList.add('teemo-attack');
            
            // Create timeline segment for first attack
            const segment = document.createElement('div');
            segment.className = 'timeline-segment active';
            segment.style.left = `${(attackTimes[i] - minTime) * scaleFactor + 10}px`;
            segment.style.width = `${teemoDuration * scaleFactor}px`;
            segment.style.top = '10px';
            
            const label = document.createElement('div');
            label.className = 'segment-label';
            label.textContent = `Attack ${i}`;
            segment.appendChild(label);
            
            const duration = document.createElement('div');
            duration.className = 'segment-duration';
            duration.textContent = `${teemoDuration} units`;
            segment.appendChild(duration);
            
            segment.innerHTML += `<div style="font-size: 0.8rem;">${attackTimes[i]}${attackTimes[i] + teemoDuration}</div>`;
            
            timelineContainer.appendChild(segment);
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong> Step ${step}:</strong> First attack at <strong>${attackTimes[i]}</strong> - poison until <strong>${attackTimes[i] + teemoDuration}</strong><br>
                    <em>Adding full duration: +${teemoDuration}</em>
                </div>
            `;
            
            totalPoisoned += teemoDuration;
            totalPoisonedTime.textContent = totalPoisoned;
            
            setTimeout(() => {
                segment.classList.remove('active');
                performTeemoStep(i + 1);
            }, 3000);
            
        } else if (i < attackTimes.length) {
            const prevAttack = attackTimes[i - 1];
            const currentAttack = attackTimes[i];
            const timeDiff = currentAttack - prevAttack;
            
            explanation.innerHTML = ` Step ${step}: Attack at time <strong>${currentAttack}</strong>, <strong>${timeDiff}</strong> units after previous attack`;
            
            const attackElements = attackContainer.querySelectorAll('.array-element');
            
            // Highlight current and previous attacks
            attackElements[i - 1].querySelector('.element-value').classList.add('teemo-poison');
            attackElements[i].querySelector('.element-value').classList.add('teemo-attack');
            
            // Calculate overlap and effective duration
            const overlap = Math.max(0, (prevAttack + teemoDuration) - currentAttack);
            const effectiveDuration = Math.min(teemoDuration, timeDiff);
            
            currentCalculation.textContent = `Time diff: ${timeDiff}, Effective: ${effectiveDuration}${overlap > 0 ? `, OVERLAP: ${overlap}` : ''}`;
            
            let stepExplanation = '';
            if (overlap > 0) {
                explanation.innerHTML += ` -  <strong>OVERLAP DETECTED!</strong>`;
                attackElements[i - 1].querySelector('.element-value').classList.add('teemo-overlap');
                attackElements[i].querySelector('.element-value').classList.add('teemo-overlap');
                stepExplanation = `<br><em>Overlap detected! Previous poison still active. Adding only ${effectiveDuration} instead of full ${teemoDuration}</em>`;
            } else {
                stepExplanation = `<br><em>No overlap. Adding effective duration: ${effectiveDuration}</em>`;
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${overlap > 0 ? 'active' : ''}">
                    <strong> Step ${step}:</strong> 
                    Time difference = <strong>${timeDiff}</strong><br>
                    ${overlap > 0 ? ` Overlap = <strong>${overlap}</strong><br>` : ''}
                    Effective duration = <strong>${effectiveDuration}</strong>
                    ${stepExplanation}
                </div>
            `;
            
            // Create timeline segment
            const segment = document.createElement('div');
            segment.className = `timeline-segment ${overlap > 0 ? 'overlap active' : 'active'}`;
            segment.style.left = `${(currentAttack - minTime) * scaleFactor + 10}px`;
            segment.style.width = `${teemoDuration * scaleFactor}px`;
            segment.style.top = `${(i % 3) * 45 + 10}px`; // Stagger segments for clarity
            
            const label = document.createElement('div');
            label.className = 'segment-label';
            label.textContent = `Attack ${i}${overlap > 0 ? ' (OVERLAP!)' : ''}`;
            segment.appendChild(label);
            
            const duration = document.createElement('div');
            duration.className = 'segment-duration';
            duration.textContent = `${effectiveDuration} units${overlap > 0 ? ' ' : ''}`;
            segment.appendChild(duration);
            
            segment.innerHTML += `<div style="font-size: 0.8rem;">${currentAttack}${currentAttack + teemoDuration}</div>`;
            
            timelineContainer.appendChild(segment);
            
            totalPoisoned += effectiveDuration;
            totalPoisonedTime.textContent = totalPoisoned;
            
            setTimeout(() => {
                // Remove active and overlap highlights
                segment.classList.remove('active');
                if (overlap > 0) {
                    attackElements[i - 1].querySelector('.element-value').classList.remove('teemo-overlap');
                    attackElements[i].querySelector('.element-value').classList.remove('teemo-overlap');
                }
                
                performTeemoStep(i + 1);
            }, 3500);
        }
    }
    
    // Start the algorithm
    setTimeout(() => {
        performTeemoStep(0);
    }, 1000);
}
// NEW: Return to Original after Teemo Operation
function returnToOriginalAfterTeemo() {
    // Reset to original array
    myArray = [...originalArrayForTeemo];
    originalArrayForTeemo = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isTeemoAttackingRunning = false;
    teemoDuration = 0;
    
    logOperation('Teemo attacking operation completed - returned to original array', 'info');
    showNotification('Returned to original array after Teemo operation', 'success');
}
// NEW: Buildings With Ocean View Handler
function handleBuildingsOceanView() {
    if (isOceanViewRunning) {
        showNotification('Ocean view operation is already in progress', 'warning');
        return;
    }

    // Show input group
    buildingsOceanViewGroup.style.display = 'block';
    buildingHeights.focus();
    
    logOperation('Started buildings with ocean view operation', 'info');
}

// NEW: Confirm Building Heights Handler
function handleConfirmBuildingHeights() {
    const heightsInput = buildingHeights.value.trim();
    
    if (heightsInput === '') {
        showNotification('Please enter building heights', 'danger');
        buildingHeights.focus();
        return;
    }
    
    // Parse heights
    const heights = heightsInput.split(',').map(item => {
        const num = parseFloat(item.trim());
        if (isNaN(num)) {
            showNotification(`Invalid number: ${item}`, 'danger');
            buildingHeights.focus();
            return null;
        }
        return num;
    }).filter(item => item !== null);
    
    if (heights.length === 0) {
        showNotification('Please enter valid building heights', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForOceanView = [...myArray];
    
    // Set the building heights as current array
    myArray = heights.map(h => h.toString());
    
    // Hide input group
    buildingsOceanViewGroup.style.display = 'none';
    buildingHeights.value = '';
    
    // Start ocean view visualization
    showOceanViewVisualization(heights);
}

// NEW: Show Ocean View Visualization
function showOceanViewVisualization(heights) {
    isOceanViewRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Buildings With Ocean View</h5>
        
        <div class="array-group">
            <div class="array-label">Building Heights</div>
            <div class="original-array-container" id="oceanViewArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Ocean View Result</div>
            <div class="transformed-array-container" id="oceanViewResult"></div>
        </div>
        
        <div class="ocean-view-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find buildings with no taller building to their right</p>
            <p class="mb-0" id="oceanViewExplanation">Starting ocean view analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="oceanViewStepsContainer">
            <h6 class="text-center">Ocean View Analysis Steps</h6>
            <div class="steps-container" id="oceanViewSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Buildings With Ocean View</div>
            <div class="stats-value" id="oceanViewBuildings">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterOceanView" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(heights.map(h => h.toString()), 'oceanViewArray');
    renderArrayInContainer([], 'oceanViewResult');
    
    performOceanViewAnalysis(heights);
}

// NEW: Perform Ocean View Analysis with Animation
function performOceanViewAnalysis(heights) {
    const arrayContainer = document.getElementById('oceanViewArray');
    const resultContainer = document.getElementById('oceanViewResult');
    const explanation = document.getElementById('oceanViewExplanation');
    const stepsContainer = document.getElementById('oceanViewSteps');
    const oceanViewBuildings = document.getElementById('oceanViewBuildings');
    const continueButton = document.getElementById('continueAfterOceanView');
    
    const n = heights.length;
    let result = [];
    let maxHeight = 0;
    let step = 0;
    
    function performOceanViewStep(i) {
        if (i < 0) {
            // Analysis completed
            explanation.innerHTML = `<strong>Ocean View Analysis Completed!</strong> Found ${result.length} buildings with ocean view.`;
            
            // Reverse result to show in increasing order
            result = result.reverse();
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Buildings with ocean view: [${result.join(', ')}]
                </div>
            `;
            
            // Highlight the final ocean view buildings in result
            const resultElements = resultContainer.querySelectorAll('.array-element');
            result.forEach((buildingIndex, idx) => {
                setTimeout(() => {
                    resultElements[buildingIndex].querySelector('.element-value').classList.add('ocean-view');
                }, idx * 300);
            });
            
            oceanViewBuildings.textContent = `[${result.join(', ')}]`;
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterOceanView();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterOceanView);
            
            return;
        }
        
        step++;
        explanation.innerHTML = `Step ${step}: Checking building at index ${i} (height = ${heights[i]})`;
        
        // Highlight current building being checked
        const arrayElements = arrayContainer.querySelectorAll('.array-element');
        const currentElement = arrayElements[i].querySelector('.element-value');
        currentElement.classList.add('current-ocean-check');
        
        // Highlight max height so far
        if (maxHeight > 0) {
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}:</strong> Checking building [${i}] = ${heights[i]}, Max height so far = ${maxHeight}
                </div>
            `;
        } else {
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}:</strong> Checking building [${i}] = ${heights[i]} (first building from right)
                </div>
            `;
        }
        
        setTimeout(() => {
            if (heights[i] > maxHeight) {
                // This building has ocean view
                result.push(i);
                maxHeight = heights[i];
                
                explanation.innerHTML = `Step ${step}: Building ${i} has ocean view! New max height = ${maxHeight}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Ocean View Found!</strong> Building [${i}] = ${heights[i]} > ${maxHeight - heights[i]} (previous max)
                    </div>
                `;
                
                // Highlight as ocean view
                currentElement.classList.remove('current-ocean-check');
                currentElement.classList.add('ocean-view');
                
                // Update result display
                const resultArray = [...result].reverse().map(idx => heights[idx].toString());
                renderArrayInContainer(resultArray, 'oceanViewResult');
                
                // Highlight max height
                currentElement.classList.add('max-height-so-far');
                
            } else {
                // No ocean view
                explanation.innerHTML = `Step ${step}: Building ${i} has NO ocean view (height  max height)`;

                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>No Ocean View:</strong> Building [${i}] = ${heights[i]}  ${maxHeight} (max height)
                    </div>
                `;
                
                // Highlight as no ocean view
                currentElement.classList.remove('current-ocean-check');
                currentElement.classList.add('no-ocean-view');
            }
            
            // Move to next building (from right to left)
            performOceanViewStep(i - 1);
        }, 2000);
    }
    
    // Start analysis from rightmost building
    performOceanViewStep(n - 1);
}

// NEW: Return to Original after Ocean View
function returnToOriginalAfterOceanView() {
    // Reset to original array
    myArray = [...originalArrayForOceanView];
    originalArrayForOceanView = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isOceanViewRunning = false;
    
    logOperation('Ocean view analysis completed - returned to original array', 'info');
    showNotification('Returned to original array after ocean view analysis', 'success');
}

// NEW: Create Target Array Handler
function handleCreateTargetArray() {
    if (isTargetArrayRunning) {
        showNotification('Target array operation is already in progress', 'warning');
        return;
    }

    // Reset arrays
    targetArrayValues = [];
    targetArrayIndices = [];
    
    // Show input group
    createTargetArrayGroup.style.display = 'block';
    targetArrayValuesInput.focus();
    
    // Hide perform button initially
    performTargetArrayBtn.style.display = 'none';
    
    logOperation('Started create target array operation', 'info');
}

// NEW: Confirm Target Values Handler
function handleConfirmTargetValues() {
    const valuesInput = targetArrayValuesInput.value.trim();
    
    if (valuesInput === '') {
        showNotification('Please enter values array', 'danger');
        targetArrayValuesInput.focus();
        return;
    }
    
    // Parse values
    targetArrayValues = valuesInput.split(',').map(item => item.trim()).filter(item => item !== '');
    
    if (targetArrayValues.length === 0) {
        showNotification('Please enter valid values', 'danger');
        return;
    }
    
    showNotification(`Values array set with ${targetArrayValues.length} elements`, 'success');
    logOperation(`Target values array set with ${targetArrayValues.length} elements`, 'info');
    
    // Focus on indices input
    targetArrayIndicesInput.focus();
}

// NEW: Confirm Target Indices Handler
function handleConfirmTargetIndices() {
    const indicesInput = targetArrayIndicesInput.value.trim();
    
    if (indicesInput === '') {
        showNotification('Please enter indices array', 'danger');
        targetArrayIndicesInput.focus();
        return;
    }
    
    // Parse indices
    targetArrayIndices = indicesInput.split(',').map(item => {
        const num = parseInt(item.trim());
        if (isNaN(num) || num < 0) {
            showNotification(`Invalid index: ${item}`, 'danger');
            targetArrayIndicesInput.focus();
            return null;
        }
        return num;
    }).filter(item => item !== null);
    
    if (targetArrayIndices.length === 0) {
        showNotification('Please enter valid indices', 'danger');
        return;
    }
    
    // Check if indices array size matches values array size
    if (targetArrayIndices.length !== targetArrayValues.length) {
        showNotification(`Indices array size (${targetArrayIndices.length}) must match values array size (${targetArrayValues.length})`, 'danger');
        targetArrayIndicesInput.focus();
        return;
    }
    
    // Check if all indices are within valid range
    const maxIndex = targetArrayValues.length - 1;
    const invalidIndices = targetArrayIndices.filter(idx => idx > maxIndex);
    if (invalidIndices.length > 0) {
        showNotification(`Invalid indices: ${invalidIndices.join(', ')}. Must be between 0 and ${maxIndex}`, 'danger');
        targetArrayIndicesInput.focus();
        return;
    }
    
    showNotification(`Indices array validated successfully`, 'success');
    logOperation(`Target indices array set with ${targetArrayIndices.length} elements`, 'info');
    
    // Show perform button
    performTargetArrayBtn.style.display = 'block';
}

// NEW: Perform Target Array Handler
function handlePerformTargetArray() {
    // Store original array
    originalArrayForTargetArray = [...myArray];
    
    // Hide input group
    createTargetArrayGroup.style.display = 'none';
    targetArrayValuesInput.value = '';
    targetArrayIndicesInput.value = '';
    performTargetArrayBtn.style.display = 'none';
    
    // Start target array visualization
    showTargetArrayVisualization(targetArrayValues, targetArrayIndices);
}

// NEW: Cancel Target Array Handler
function handleCancelTargetArray() {
    createTargetArrayGroup.style.display = 'none';
    targetArrayValuesInput.value = '';
    targetArrayIndicesInput.value = '';
    performTargetArrayBtn.style.display = 'none';
    
    targetArrayValues = [];
    targetArrayIndices = [];
    
    logOperation('Cancelled target array operation', 'info');
    showNotification('Target array operation cancelled', 'info');
}

// NEW: Show Target Array Visualization
function showTargetArrayVisualization(values, indices) {
    isTargetArrayRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Create Target Array in Given Order</h5>
        
        <div class="array-group">
            <div class="array-label">Values Array (nums)</div>
            <div class="original-array-container" id="targetValuesArray"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Indices Array (index)</div>
            <div class="original-array-container" id="targetIndicesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Target Array Construction</div>
            <div class="transformed-array-container" id="targetArrayConstruction"></div>
        </div>
        
        <div class="target-array-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Insert values[i] at index[i] in target array</p>
            <p class="mb-0" id="targetArrayExplanation">Starting target array construction...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="targetArrayStepsContainer">
            <h6 class="text-center">Target Array Construction Steps</h6>
            <div class="steps-container" id="targetArraySteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterTargetArray" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(values, 'targetValuesArray');
    renderArrayInContainer(indices.map(i => i.toString()), 'targetIndicesArray');
    renderArrayInContainer([], 'targetArrayConstruction');
    
    performTargetArrayConstruction(values, indices);
}

// NEW: Perform Target Array Construction with Animation
function performTargetArrayConstruction(values, indices) {
    const valuesContainer = document.getElementById('targetValuesArray');
    const indicesContainer = document.getElementById('targetIndicesArray');
    const targetContainer = document.getElementById('targetArrayConstruction');
    const explanation = document.getElementById('targetArrayExplanation');
    const stepsContainer = document.getElementById('targetArraySteps');
    const continueButton = document.getElementById('continueAfterTargetArray');
    
    let target = [];
    let step = 0;
    
    function performConstructionStep(i) {
        if (i >= values.length) {
            // Construction completed
            explanation.innerHTML = `<strong>Target Array Construction Completed!</strong> Final target array created.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Target array = [${target.join(', ')}]
                </div>
            `;
            
            // Highlight final target array
            const targetElements = targetContainer.querySelectorAll('.array-element');
            targetElements.forEach((el, idx) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('target-final');
                }, idx * 200);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterTargetArray();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterTargetArray);
            
            return;
        }
        
        step++;
        const value = values[i];
        const index = indices[i];
        
        explanation.innerHTML = `Step ${step}: Insert values[${i}]=${value} at index[${i}]=${index}`;
        
        // Highlight current value and index
        const valueElements = valuesContainer.querySelectorAll('.array-element');
        const indexElements = indicesContainer.querySelectorAll('.array-element');
        
        if (i < valueElements.length) {
            valueElements[i].querySelector('.element-value').classList.add('target-insert');
        }
        if (i < indexElements.length) {
            indexElements[i].querySelector('.element-value').classList.add('target-insert');
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> Insert nums[${i}]=${value} at index=${index}
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights from inputs
            if (i < valueElements.length) {
                valueElements[i].querySelector('.element-value').classList.remove('target-insert');
            }
            if (i < indexElements.length) {
                indexElements[i].querySelector('.element-value').classList.remove('target-insert');
            }
            
            // Show insertion process
            explanation.innerHTML = `Step ${step}: Inserting ${value} at position ${index} in target array`;
            
            // If target array has elements at or beyond insertion point, highlight them as shifting
            if (index < target.length) {
                for (let j = index; j < target.length; j++) {
                    setTimeout(() => {
                        const tempElements = targetContainer.querySelectorAll('.array-element');
                        if (j < tempElements.length) {
                            tempElements[j].querySelector('.element-value').classList.add('target-shifted');
                        }
                    }, (j - index) * 300);
                }
            }
            
            setTimeout(() => {
                // Perform the insertion
                target.splice(index, 0, value);
                
                // Update target array display
                renderArrayInContainer(target, 'targetArrayConstruction');
                
                // Highlight the newly inserted element
                const newTargetElements = targetContainer.querySelectorAll('.array-element');
                if (index < newTargetElements.length) {
                    newTargetElements[index].querySelector('.element-value').classList.add('target-insert');
                }
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Inserted:</strong> Target array after insertion: [${target.join(', ')}]
                    </div>
                `;
                
                // Remove shifting highlights
                setTimeout(() => {
                    const allTargetElements = targetContainer.querySelectorAll('.array-element');
                    allTargetElements.forEach(el => {
                        el.querySelector('.element-value').classList.remove('target-shifted', 'target-insert');
                    });
                    
                    // Move to next step
                    performConstructionStep(i + 1);
                }, 1000);
            }, 1500);
        }, 1500);
    }
    
    // Start construction process
    performConstructionStep(0);
}

// NEW: Return to Original after Target Array
function returnToOriginalAfterTargetArray() {
    // Reset to original array
    myArray = [...originalArrayForTargetArray];
    originalArrayForTargetArray = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isTargetArrayRunning = false;
    
    // Clear arrays
    targetArrayValues = [];
    targetArrayIndices = [];
    
    logOperation('Target array construction completed - returned to original array', 'info');
    showNotification('Returned to original array after target array construction', 'success');
}
// NEW: Decompress Run-Length Encoded List Handler
function handleDecompressRLE() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length % 2 !== 0) {
        showNotification('Run-length encoded array must have even length (pairs of [freq, val])', 'danger');
        return;
    }
    
    // Check if frequencies are valid positive integers
    for (let i = 0; i < myArray.length; i += 2) {
        const freq = parseInt(myArray[i]);
        if (isNaN(freq) || freq < 0) {
            showNotification('Frequency values must be non-negative integers', 'danger');
            return;
        }
    }
    
    if (isRLEOperationActive) {
        showNotification('RLE decompression is already in progress', 'warning');
        return;
    }
    
    isRLEOperationActive = true;
    
    // Store original array
    originalArrayForRLEOperation = [...myArray];
    
    // Show RLE decompression visualization
    showRLEVisualization();
}

// NEW: Array Nesting Handler
function handleArrayNesting() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if all elements are valid indices
    for (let i = 0; i < myArray.length; i++) {
        const val = parseInt(myArray[i]);
        if (isNaN(val) || val < 0 || val >= myArray.length) {
            showNotification('Array nesting requires all elements to be valid indices (0 to n-1)', 'danger');
            return;
        }
    }
    
    if (isNestingOperationActive) {
        showNotification('Array nesting operation is already in progress', 'warning');
        return;
    }
    
    isNestingOperationActive = true;
    
    // Store original array
    originalArrayForNestingOperation = [...myArray];
    
    // Show array nesting visualization
    showNestingVisualization();
}

// NEW: Show RLE Decompression Visualization
function showRLEVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Decompress Run-Length Encoded List</h5>
        
        <div class="array-group">
            <div class="array-label">Encoded Array [freq, val, freq, val, ...]</div>
            <div class="original-array-container" id="originalRLEArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Decompressed Array</div>
            <div class="transformed-array-container" id="decompressedArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Convert pairs [frequency, value] to expanded array</p>
            <p class="mb-0" id="rleExplanation">Starting RLE decompression...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="rleStepsContainer">
            <h6 class="text-center">Decompression Steps</h6>
            <div class="steps-container" id="rleSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterRLE" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForRLEOperation, 'originalRLEArray');
    renderArrayInContainer([], 'decompressedArray');
    
    performRLEAnimation();
}

// NEW: Perform RLE Decompression Animation
function performRLEAnimation() {
    const originalContainer = document.getElementById('originalRLEArray');
    const decompressedContainer = document.getElementById('decompressedArray');
    const explanation = document.getElementById('rleExplanation');
    const stepsContainer = document.getElementById('rleSteps');
    const continueButton = document.getElementById('continueAfterRLE');
    
    const encodedArray = [...originalArrayForRLEOperation];
    let decompressedArray = [];
    let currentPair = 0;
    let totalElements = 0;
    
    function performDecompressionStep() {
        if (currentPair >= encodedArray.length) {
            // Decompression completed
            explanation.innerHTML = `<strong>Decompression Completed!</strong> Expanded ${encodedArray.length} elements to ${decompressedArray.length} elements.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Decompressed array: [${decompressedArray.join(', ')}]
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterRLE();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterRLE);
            
            return;
        }
        
        const freqIndex = currentPair;
        const valIndex = currentPair + 1;
        const freq = parseInt(encodedArray[freqIndex]);
        const val = encodedArray[valIndex];
        
        // Highlight current pair in original array
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const freqElement = originalElements[freqIndex].querySelector('.element-value');
        const valElement = originalElements[valIndex].querySelector('.element-value');
        
        freqElement.classList.add('rle-freq');
        valElement.classList.add('rle-val');
        
        explanation.innerHTML = `Processing pair [${freq}, ${val}]: Adding ${freq} occurrence(s) of ${val}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentPair/2 + 1}:</strong> Processing [freq=${freq}, val=${val}] - Adding ${freq}  ${val}
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Add elements to decompressed array one by one
            let addedCount = 0;
            
            function addElement() {
                if (addedCount < freq) {
                    decompressedArray.push(val);
                    
                    // Update decompressed array display
                    renderArrayInContainer(decompressedArray, 'decompressedArray');
                    
                    // Highlight the newly added element
                    const decompressedElements = decompressedContainer.querySelectorAll('.array-element');
                    const newElement = decompressedElements[decompressedElements.length - 1].querySelector('.element-value');
                    newElement.classList.add('rle-decompressed');
                    
                    addedCount++;
                    totalElements++;
                    
                    setTimeout(() => {
                        newElement.classList.remove('rle-decompressed');
                        addElement();
                    }, 500);
                } else {
                    // Move to next pair
                    freqElement.classList.remove('rle-freq');
                    valElement.classList.remove('rle-val');
                    
                    currentPair += 2;
                    performDecompressionStep();
                }
            }
            
            addElement();
        }, 1500);
    }
    
    // Start decompression process
    performDecompressionStep();
}

// NEW: Show Array Nesting Visualization
function showNestingVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Array Nesting - Find Longest Chain</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array (indices as values)</div>
            <div class="original-array-container" id="originalNestingArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find the longest set S[k] = {nums[k], nums[nums[k]], ...}</p>
            <p class="mb-0" id="nestingExplanation">Starting array nesting analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="nestingStepsContainer">
            <h6 class="text-center">Nesting Analysis Steps</h6>
            <div class="steps-container" id="nestingSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Longest Nest Length</div>
            <div class="stats-value" id="longestNestLength">0</div>
        </div>
        
        <div class="nesting-chain mt-3" id="longestNestChain" style="display: none;">
            <h6>Longest Nest Chain</h6>
            <div id="nestChainElements"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterNesting" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForNestingOperation, 'originalNestingArray');
    
    performNestingAnimation();
}

// NEW: Perform Array Nesting Animation
function performNestingAnimation() {
    const originalContainer = document.getElementById('originalNestingArray');
    const explanation = document.getElementById('nestingExplanation');
    const stepsContainer = document.getElementById('nestingSteps');
    const longestNestLength = document.getElementById('longestNestLength');
    const longestNestChain = document.getElementById('longestNestChain');
    const nestChainElements = document.getElementById('nestChainElements');
    const continueButton = document.getElementById('continueAfterNesting');
    
    const nums = originalArrayForNestingOperation.map(val => parseInt(val));
    const visited = new Array(nums.length).fill(false);
    let maxLength = 0;
    let maxChain = [];
    let currentIndex = 0;
    let step = 0;
    
    function performNestingStep() {
        if (currentIndex >= nums.length) {
            // Analysis completed
            explanation.innerHTML = `<strong>Array Nesting Analysis Completed!</strong> Longest nest length = ${maxLength}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Maximum nesting length = ${maxLength}
                </div>
            `;
            
            // Show the longest chain
            longestNestChain.style.display = 'block';
            nestChainElements.innerHTML = '';
            
            maxChain.forEach((val, idx) => {
                const chainItem = document.createElement('span');
                chainItem.className = 'nesting-chain-item';
                chainItem.textContent = val;
                if (idx === 0) chainItem.classList.add('current');
                nestChainElements.appendChild(chainItem);
            });
            
            // Highlight the longest chain in original array
            const originalElements = originalContainer.querySelectorAll('.array-element');
            maxChain.forEach(val => {
                const index = nums.indexOf(parseInt(val));
                if (index !== -1) {
                    originalElements[index].querySelector('.element-value').classList.add('nesting-max');
                }
            });
            
            longestNestLength.textContent = maxLength;
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterNesting();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterNesting);
            
            return;
        }
        
        if (visited[currentIndex]) {
            currentIndex++;
            performNestingStep();
            return;
        }
        
        step++;
        explanation.innerHTML = `Starting from index ${currentIndex}: nums[${currentIndex}] = ${nums[currentIndex]}`;
        
        let current = currentIndex;
        let chain = [];
        let count = 0;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> Starting new chain from index ${currentIndex}
            </div>
        `;
        
        function followChain() {
            if (visited[current]) {
                // Chain completed
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Chain ${step} Complete:</strong> Length = ${count}
                    </div>
                `;
                
                if (count > maxLength) {
                    maxLength = count;
                    maxChain = [...chain];
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>New Longest Chain!</strong> Length = ${maxLength}
                        </div>
                    `;
                    
                    longestNestLength.textContent = maxLength;
                }
                
                currentIndex++;
                performNestingStep();
                return;
            }
            
            // Follow the chain
            visited[current] = true;
            count++;
            chain.push(nums[current]);
            
            // Highlight current element
            const originalElements = originalContainer.querySelectorAll('.array-element');
            const currentElement = originalElements[current].querySelector('.element-value');
            currentElement.classList.add('nesting-current');
            
            explanation.innerHTML = `Chain ${step}: nums[${current}] = ${nums[current]}  nums[${nums[current]}] = ${nums[nums[current]]}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}.${count}:</strong> nums[${current}] = ${nums[current]}  next index = ${nums[current]}
                </div>
            `;
            
            // Scroll steps container
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            setTimeout(() => {
                currentElement.classList.remove('nesting-current');
                currentElement.classList.add('nesting-visited');
                
                current = nums[current];
                followChain();
            }, 1500);
        }
        
        followChain();
    }
    
    // Start nesting analysis
    performNestingStep();
}

// NEW: Return to Original after RLE
function returnToOriginalAfterRLE() {
    // Reset to original array
    myArray = [...originalArrayForRLEOperation];
    originalArrayForRLEOperation = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isRLEOperationActive = false;
    
    logOperation('RLE decompression completed - returned to original array', 'info');
    showNotification('Returned to original array after RLE decompression', 'success');
}

// NEW: Return to Original after Nesting
function returnToOriginalAfterNesting() {
    // Reset to original array
    myArray = [...originalArrayForNestingOperation];
    originalArrayForNestingOperation = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isNestingOperationActive = false;
    
    logOperation('Array nesting analysis completed - returned to original array', 'info');
    showNotification('Returned to original array after nesting analysis', 'success');
}
// NEW: Queue Reconstruction Handler
function handleQueueReconstruction() {
    if (isQueueReconstructionRunning) {
        showNotification('Queue reconstruction is already in progress', 'warning');
        return;
    }

    // Reset queue data
    queuePeople = [];
    queueSizeValue = 0;
    
    // Show input group
    queueReconstructionGroup.style.display = 'block';
    queueSizeInput.focus(); // Updated to queueSizeInput
    
    // Hide perform button initially
    performQueueReconstructionBtn.style.display = 'none';
    
    logOperation('Started queue reconstruction operation', 'info');
}

// NEW: Confirm Queue Size Handler
function handleConfirmQueueSize() {
    const size = parseInt(queueSizeInput.value); // Updated to queueSizeInput
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        queueSizeInput.focus(); // Updated to queueSizeInput
        return;
    }
    
    queueSizeValue = size;
    
    // Create input fields for people data
    queueInputs.innerHTML = '<label class="form-label">Enter People Data [height, k]:</label>';
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Person ${i}</span>
            <input type="number" class="form-control queue-height" 
                   placeholder="Height" data-index="${i}" min="1" max="100">
            <input type="number" class="form-control queue-k" 
                   placeholder="k value" data-index="${i}" min="0" max="${size-1}">
        `;
        queueInputs.appendChild(inputGroup);
    }
    
    // Add event listeners for queue inputs
    const heightInputs = queueInputs.querySelectorAll('.queue-height');
    const kInputs = queueInputs.querySelectorAll('.queue-k');
    
    heightInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('queue-k')) {
                    nextInput.focus();
                }
            }
        });
    });
    
    kInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextGroup = input.closest('.input-group').nextElementSibling;
                if (nextGroup) {
                    nextGroup.querySelector('.queue-height').focus();
                } else {
                    performQueueReconstructionBtn.focus();
                }
            }
        });
    });
    
    // Show perform button
    performQueueReconstructionBtn.style.display = 'block';
    
    showNotification(`Queue size set to ${size}. Please enter height and k values for each person.`, 'success');
    logOperation(`Queue size set to ${size}`, 'info');
}

// NEW: Perform Queue Reconstruction Handler
function handlePerformQueueReconstruction() {
    // Collect people data
    const heightInputs = queueInputs.querySelectorAll('.queue-height');
    const kInputs = queueInputs.querySelectorAll('.queue-k');
    
    queuePeople = [];
    
    for (let i = 0; i < heightInputs.length; i++) {
        const height = parseInt(heightInputs[i].value);
        const k = parseInt(kInputs[i].value);
        
        if (isNaN(height) || height < 1 || height > 100) {
            showNotification(`Please enter valid height (1-100) for person ${i}`, 'danger');
            heightInputs[i].focus();
            return;
        }
        
        if (isNaN(k) || k < 0 || k >= queueSizeValue) {
            showNotification(`Please enter valid k value (0-${queueSizeValue-1}) for person ${i}`, 'danger');
            kInputs[i].focus();
            return;
        }
        
        queuePeople.push([height, k]);
    }
    
    // Store original array
    originalArrayForQueueReconstruction = [...myArray]; // Updated to originalArrayForQueueReconstruction
    
    // Hide input group
    queueReconstructionGroup.style.display = 'none';
    
    // Start queue reconstruction visualization
    showQueueReconstructionVisualization();
}

// NEW: Cancel Queue Reconstruction Handler
function handleCancelQueueReconstruction() {
    queueReconstructionGroup.style.display = 'none';
    queueSizeInput.value = ''; // Updated to queueSizeInput
    queueInputs.innerHTML = '';
    performQueueReconstructionBtn.style.display = 'none';
    
    queuePeople = [];
    queueSizeValue = 0;
    
    logOperation('Cancelled queue reconstruction operation', 'info');
    showNotification('Queue reconstruction operation cancelled', 'info');
}

// NEW: Show Queue Reconstruction Visualization
function showQueueReconstructionVisualization() {
    isQueueReconstructionRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Queue Reconstruction by Height</h5>
        
        <div class="array-group">
            <div class="array-label">Original People Array</div>
            <div class="original-array-container" id="originalQueueArray"></div>
            <div class="array-title mt-2">People Data: [${queuePeople.map(p => `[${p[0]},${p[1]}]`).join(', ')}]</div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Reconstructed Queue</div>
            <div class="transformed-array-container" id="transformedQueueArray"></div>
            <div class="array-title mt-2" id="reconstructedData">Reconstructed: </div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Sort by height descending, then insert each person at position k</p>
            <p class="mb-0" id="queueExplanation">Starting queue reconstruction...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="queueStepsContainer">
            <h6 class="text-center">Queue Reconstruction Steps</h6>
            <div class="steps-container" id="queueSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterQueue" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display the people array as visual elements
    renderQueueArray(queuePeople, 'originalQueueArray');
    renderQueueArray([], 'transformedQueueArray');
    
    // Start queue reconstruction animation
    performQueueReconstructionAnimation();
}

// NEW: Render Queue Array (special rendering for people data)
function renderQueueArray(peopleArray, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    peopleArray.forEach((person, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        
        const valueDiv = document.createElement('div');
        valueDiv.className = 'element-value';
        valueDiv.textContent = `${person[0]}`;
        valueDiv.title = `Height: ${person[0]}, k: ${person[1]}`;
        
        const indexDiv = document.createElement('div');
        indexDiv.className = 'element-index';
        indexDiv.textContent = `k=${person[1]}`;
        
        arrayElement.appendChild(valueDiv);
        arrayElement.appendChild(indexDiv);
        container.appendChild(arrayElement);
    });
    
    // Show empty state if no elements
    if (peopleArray.length === 0) {
        container.innerHTML = '<div class="array-empty-state"><i class="fas fa-users"></i><h6>Queue is Empty</h6></div>';
    }
}

// NEW: Perform Queue Reconstruction Animation
function performQueueReconstructionAnimation() {
    const originalContainer = document.getElementById('originalQueueArray');
    const transformedContainer = document.getElementById('transformedQueueArray');
    const reconstructedData = document.getElementById('reconstructedData');
    const explanation = document.getElementById('queueExplanation');
    const stepsContainer = document.getElementById('queueSteps');
    const continueButton = document.getElementById('continueAfterQueue');
    
    // Step 1: Sort people by height descending, then by k ascending
    explanation.innerHTML = 'Step 1: Sorting people by height descending, then by k ascending';
    
    const sortedPeople = [...queuePeople].sort((a, b) => {
        if (a[0] !== b[0]) {
            return b[0] - a[0]; // Height descending
        }
        return a[1] - b[1]; // k ascending
    });
    
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Step 1:</strong> Sorted people array: [${sortedPeople.map(p => `[${p[0]},${p[1]}]`).join(', ')}]
        </div>
    `;
    
    setTimeout(() => {
        // Highlight the sorted array
        const originalElements = originalContainer.querySelectorAll('.array-element');
        originalElements.forEach((el, index) => {
            setTimeout(() => {
                el.querySelector('.element-value').classList.add('sorting-sorted');
            }, index * 300);
        });
        
        setTimeout(() => {
            // Step 2: Start reconstruction
            explanation.innerHTML = 'Step 2: Starting queue reconstruction by inserting people at their k positions';
            
            let result = [];
            let currentStep = 0;
            
            function insertNextPerson() {
                if (currentStep >= sortedPeople.length) {
                    // Reconstruction completed
                    explanation.innerHTML = `<strong>Queue Reconstruction Completed!</strong>`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Final:</strong> Queue reconstruction completed: [${result.map(p => `[${p[0]},${p[1]}]`).join(', ')}]
                        </div>
                    `;
                    
                    reconstructedData.textContent = `Reconstructed: [${result.map(p => `[${p[0]},${p[1]}]`).join(', ')}]`;
                    
                    // Highlight final result
                    const transformedElements = transformedContainer.querySelectorAll('.array-element');
                    transformedElements.forEach((el, index) => {
                        setTimeout(() => {
                            el.querySelector('.element-value').classList.add('create', 'bounce');
                        }, index * 200);
                    });
                    
                    continueButton.style.display = 'block';
                    
                    // Auto-return after 20 seconds
                    setTimeout(() => {
                        returnToOriginalAfterQueue();
                    }, 20000);
                    
                    continueButton.addEventListener('click', returnToOriginalAfterQueue);
                    
                    return;
                }
                
                const person = sortedPeople[currentStep];
                const k = person[1];
                
                explanation.innerHTML = `Step ${currentStep + 2}: Inserting person [${person[0]},${person[1]}] at position ${k}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${currentStep + 2}:</strong> Insert [${person[0]},${person[1]}] at index ${k}
                    </div>
                `;
                
                // Highlight the person being inserted in original array
                const originalElements = originalContainer.querySelectorAll('.array-element');
                const personIndex = queuePeople.findIndex(p => p[0] === person[0] && p[1] === person[1]);
                if (personIndex !== -1) {
                    originalElements[personIndex].querySelector('.element-value').classList.add('window-current');
                }
                
                setTimeout(() => {
                    // Insert at position k
                    result.splice(k, 0, person);
                    
                    // Update transformed array display
                    renderQueueArray(result, 'transformedQueueArray');
                    
                    // Highlight the inserted element
                    const transformedElements = transformedContainer.querySelectorAll('.array-element');
                    if (transformedElements[k]) {
                        transformedElements[k].querySelector('.element-value').classList.add('create', 'pulse');
                    }
                    
                    // Remove highlight from original
                    if (personIndex !== -1) {
                        originalElements[personIndex].querySelector('.element-value').classList.remove('window-current');
                    }
                    
                    currentStep++;
                    insertNextPerson();
                }, 1500);
            }
            
            // Start insertion process
            insertNextPerson();
        }, 1000);
    }, 2000);
}

// NEW: Return to Original after Queue Reconstruction
function returnToOriginalAfterQueue() {
    // Reset to original array
    myArray = [...originalArrayForQueueReconstruction]; // Updated to originalArrayForQueueReconstruction
    originalArrayForQueueReconstruction = []; // Updated to originalArrayForQueueReconstruction
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isQueueReconstructionRunning = false;
    
    // Clear all queue-related data
    queuePeople = [];
    queueSizeValue = 0;
    
    // Reset input groups
    queueReconstructionGroup.style.display = 'none';
    queueSizeInput.value = ''; // Updated to queueSizeInput
    queueInputs.innerHTML = '';
    performQueueReconstructionBtn.style.display = 'none';
    
    logOperation('Queue reconstruction completed - returned to original array', 'info');
    showNotification('Returned to original array after queue reconstruction', 'success');
}
// NEW: Crawler Log Folder Handler
function handleCrawlerLogFolder() {
    if (isCrawlerLogRunning) {
        showNotification('Crawler log simulation is already in progress', 'warning');
        return;
    }

    // Reset arrays
    crawlerLogs = [];
    crawlerLogSize = 0;
    
    // Show input group
    document.getElementById('crawlerLogGroup').style.display = 'block';
    document.getElementById('crawlerLogSize').focus();
    
    // Hide perform button initially
    document.getElementById('performCrawlerLogBtn').style.display = 'none';
    
    logOperation('Started crawler log folder simulation', 'info');
}

// NEW: Confirm Crawler Log Size Handler
function handleConfirmCrawlerLogSize() {
    const size = parseInt(document.getElementById('crawlerLogSize').value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        document.getElementById('crawlerLogSize').focus();
        return;
    }
    
    crawlerLogSize = size;
    crawlerLogs = [];
    
    // Create input fields for log entries
    const crawlerLogInputs = document.getElementById('crawlerLogInputs');
    crawlerLogInputs.innerHTML = '<label class="form-label">Enter Log Entries (Patterns: "../", "./", "d1/", "d2/", etc.):</label>';
    
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Log ${i}</span>
            <input type="text" class="form-control crawler-log-element" 
                   placeholder='e.g., "../", "./", "d1/"' data-index="${i}">
        `;
        crawlerLogInputs.appendChild(inputGroup);
    }
    
    // Add event listeners for log inputs
    const logElements = crawlerLogInputs.querySelectorAll('.crawler-log-element');
    logElements.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('crawler-log-element')) {
                    nextInput.focus();
                }
            }
        });
    });
    
    // Show perform button
    document.getElementById('performCrawlerLogBtn').style.display = 'block';
    
    showNotification(`Log array size set to ${size}. Please enter ${size} log entries.`, 'success');
    logOperation(`Crawler log array size set to ${size}`, 'info');
}

// NEW: Perform Crawler Log Handler
function handlePerformCrawlerLog() {
    // Collect log entries
    const logInputs = document.querySelectorAll('.crawler-log-element');
    crawlerLogs = [];
    
    const validPatterns = ['../', './'];
    
    for (let i = 0; i < logInputs.length; i++) {
        const value = logInputs[i].value.trim();
        
        // Validation for log patterns
        if (value === '') {
            showNotification(`Please enter all log entries. Missing entry at position ${i}`, 'danger');
            logInputs[i].focus();
            return;
        }
        
        // Check if it matches valid patterns or directory pattern (ends with /)
        if (!validPatterns.includes(value) && !/^[a-zA-Z0-9]+\/$/.test(value)) {
            showNotification(`Invalid log pattern at position ${i}. Use "../", "./", or directory patterns like "d1/"`, 'danger');
            logInputs[i].focus();
            return;
        }
        
        crawlerLogs.push(value);
    }
    
    // Store original array
    originalArrayForCrawler = [...myArray];
    
    // Hide input group
    document.getElementById('crawlerLogGroup').style.display = 'none';
    
    // Start crawler log visualization
    showCrawlerLogVisualization();
}

// NEW: Cancel Crawler Log Handler
function handleCancelCrawlerLog() {
    document.getElementById('crawlerLogGroup').style.display = 'none';
    document.getElementById('crawlerLogSize').value = '';
    document.getElementById('crawlerLogInputs').innerHTML = '';
    document.getElementById('performCrawlerLogBtn').style.display = 'none';
    
    crawlerLogs = [];
    crawlerLogSize = 0;
    
    logOperation('Cancelled crawler log simulation', 'info');
    showNotification('Crawler log operation cancelled', 'info');
}

// NEW: Show Crawler Log Visualization
function showCrawlerLogVisualization() {
    isCrawlerLogRunning = true;
    
    const crawlerContainer = document.createElement('div');
    crawlerContainer.className = 'crawler-path-container';
    crawlerContainer.innerHTML = `
        <h5 class="text-center mb-4">Crawler Log Folder Simulation</h5>
        
        <div class="array-group">
            <div class="array-label">Log Entries Array</div>
            <div class="original-array-container" id="crawlerLogArray"></div>
        </div>
        
        <div class="operation-arrow text-center my-3">
            <i class="fas fa-arrow-down fa-2x"></i>
        </div>
        
        <div class="path-visualization" id="pathVisualization">
            <div class="path-segment main">Main</div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Crawler Log Algorithm:</strong> Simulating folder navigation based on log commands</p>
            <p class="mb-0" id="crawlerExplanation">Starting crawler log simulation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="crawlerStepsContainer">
            <h6 class="text-center">Crawler Steps</h6>
            <div class="steps-container" id="crawlerSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Final Depth</div>
            <div class="stats-value" id="finalDepthValue">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterCrawler" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(crawlerContainer);
    
    renderArrayInContainer(crawlerLogs, 'crawlerLogArray');
    
    performCrawlerLogAnimation();
}

// NEW: Perform Crawler Log Animation
function performCrawlerLogAnimation() {
    const logArrayContainer = document.getElementById('crawlerLogArray');
    const pathVisualization = document.getElementById('pathVisualization');
    const explanation = document.getElementById('crawlerExplanation');
    const stepsContainer = document.getElementById('crawlerSteps');
    const finalDepthValue = document.getElementById('finalDepthValue');
    const continueButton = document.getElementById('continueAfterCrawler');
    
    let depth = 0;
    let currentPath = ['Main'];
    let step = 0;
    
    function performCrawlerStep(i) {
        if (i >= crawlerLogs.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Crawler Log Simulation Completed!</strong> Final depth: ${depth}`;
            
            stepsContainer.innerHTML += `
                <div class="crawler-step active">
                    <strong>Final:</strong> Simulation completed. Final depth = ${depth}
                </div>
            `;
            
            finalDepthValue.textContent = depth;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterCrawler();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterCrawler);
            
            return;
        }
        
        const log = crawlerLogs[i];
        step++;
        
        // Highlight current log element
        const logElements = logArrayContainer.querySelectorAll('.array-element');
        const currentLogElement = logElements[i].querySelector('.element-value');
        currentLogElement.classList.add('log-element', 'current');
        
        explanation.innerHTML = `Step ${step}: Processing log "${log}"`;
        
        if (log === '../') {
            // Move up one level
            if (depth > 0) {
                depth--;
                currentPath.pop();
                
                stepsContainer.innerHTML += `
                    <div class="crawler-step active">
                        <strong>Step ${step}:</strong> "${log}" - Move up one level. New depth: ${depth}
                    </div>
                `;
                
                explanation.innerHTML = `Step ${step}: "${log}" - Moved up one level. Current depth: ${depth}`;
            } else {
                stepsContainer.innerHTML += `
                    <div class="crawler-step">
                        <strong>Step ${step}:</strong> "${log}" - Already at main folder. Depth remains: ${depth}
                    </div>
                `;
                
                explanation.innerHTML = `Step ${step}: "${log}" - Already at main folder. Cannot move up further.`;
            }
            
        } else if (log === './') {
            // Stay in current folder
            stepsContainer.innerHTML += `
                <div class="crawler-step">
                    <strong>Step ${step}:</strong> "${log}" - Stay in current folder. Depth: ${depth}
                </div>
            `;
            
            explanation.innerHTML = `Step ${step}: "${log}" - Staying in current folder.`;
            
        } else {
            // Move into child folder
            depth++;
            const folderName = log.replace('/', '');
            currentPath.push(folderName);
            
            stepsContainer.innerHTML += `
                <div class="crawler-step active">
                    <strong>Step ${step}:</strong> "${log}" - Move into folder "${folderName}". New depth: ${depth}
                </div>
            `;
            
            explanation.innerHTML = `Step ${step}: "${log}" - Moved into folder "${folderName}". Current depth: ${depth}`;
        }
        
        // Update path visualization
        updatePathVisualization(currentPath);
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Remove current highlight
            currentLogElement.classList.remove('current');
            
            // Move to next step
            performCrawlerStep(i + 1);
        }, 2000);
    }
    
    // Start crawler process
    performCrawlerStep(0);
}

// NEW: Update Path Visualization
function updatePathVisualization(path) {
    const pathVisualization = document.getElementById('pathVisualization');
    pathVisualization.innerHTML = '';
    
    path.forEach((segment, index) => {
        // Add arrow between segments (except before first segment)
        if (index > 0) {
            const arrow = document.createElement('span');
            arrow.className = 'path-arrow';
            arrow.innerHTML = '';
            pathVisualization.appendChild(arrow);
        }
        
        const segmentDiv = document.createElement('div');
        segmentDiv.className = `path-segment ${index === 0 ? 'main' : ''} ${index === path.length - 1 ? 'active' : ''}`;
        segmentDiv.textContent = segment;
        pathVisualization.appendChild(segmentDiv);
    });
}

// NEW: Return to Original after Crawler Log
function returnToOriginalAfterCrawler() {
    // Reset to original array
    myArray = [...originalArrayForCrawler];
    originalArrayForCrawler = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isCrawlerLogRunning = false;
    
    // Clear all crawler-related data
    crawlerLogs = [];
    crawlerLogSize = 0;
    
    // Reset input groups
    document.getElementById('crawlerLogGroup').style.display = 'none';
    document.getElementById('crawlerLogSize').value = '';
    document.getElementById('crawlerLogInputs').innerHTML = '';
    document.getElementById('performCrawlerLogBtn').style.display = 'none';
    
    logOperation('Crawler log simulation completed - returned to original array', 'info');
    showNotification('Returned to original array after crawler log simulation', 'success');
}
// NEW: Single Number II Handler
function handleSingleNumberII() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isSingleNumberRunning) {
        showNotification('A single number operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseInt(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Single Number operations require all array elements to be integers', 'danger');
        return;
    }
    
    isSingleNumberRunning = true;
    
    // Store original array
    originalArrayForSingleNumber = [...myArray];
    
    // Show Single Number II visualization
    showSingleNumberIIVisualization();
}

// NEW: Single Number III Handler
function handleSingleNumberIII() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isSingleNumberRunning) {
        showNotification('A single number operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseInt(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Single Number operations require all array elements to be integers', 'danger');
        return;
    }
    
    isSingleNumberRunning = true;
    
    // Store original array
    originalArrayForSingleNumber = [...myArray];
    
    // Show Single Number III visualization
    showSingleNumberIIIVisualization();
}

// NEW: Show Single Number II Visualization
function showSingleNumberIIVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Single Number II - Every element appears 3 times except one</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalSingleNumberArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Bit Counting Process</div>
            <div class="transformed-array-container" id="transformedSingleNumberArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Count bits at each position. For each bit position, 
            the count will be 3n or 3n+1. The extra 1 comes from the single number.</p>
            <p class="mb-0" id="singleNumberExplanation">Initializing Single Number II algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="singleNumberStepsContainer">
            <h6 class="text-center">Bit Counting Steps</h6>
            <div class="steps-container" id="singleNumberSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Single Number Found</div>
            <div class="stats-value" id="singleNumberValue">-</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Algorithm Used</div>
            <div class="stats-value" id="algorithmUsed">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSingleNumber" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSingleNumber, 'originalSingleNumberArray');
    renderArrayInContainer([...originalArrayForSingleNumber], 'transformedSingleNumberArray');
    
    performSingleNumberIIAnimation();
}

// NEW: Show Single Number III Visualization
function showSingleNumberIIIVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Single Number III - Two elements appear once, others appear twice</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalSingleNumberArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Partitioning Process</div>
            <div class="transformed-array-container" id="transformedSingleNumberArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> XOR all numbers, find differing bit, partition into two groups, 
            then XOR each group separately to find the two unique numbers.</p>
            <p class="mb-0" id="singleNumberExplanation">Initializing Single Number III algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="singleNumberStepsContainer">
            <h6 class="text-center">Partitioning Steps</h6>
            <div class="steps-container" id="singleNumberSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>First Unique Number</div>
            <div class="stats-value" id="firstUniqueValue">-</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Second Unique Number</div>
            <div class="stats-value" id="secondUniqueValue">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSingleNumber" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSingleNumber, 'originalSingleNumberArray');
    renderArrayInContainer([...originalArrayForSingleNumber], 'transformedSingleNumberArray');
    
    performSingleNumberIIIAnimation();
}

// NEW: Perform Single Number II Animation
function performSingleNumberIIAnimation() {
    const originalContainer = document.getElementById('originalSingleNumberArray');
    const transformedContainer = document.getElementById('transformedSingleNumberArray');
    const explanation = document.getElementById('singleNumberExplanation');
    const stepsContainer = document.getElementById('singleNumberSteps');
    const singleNumberValue = document.getElementById('singleNumberValue');
    const algorithmUsed = document.getElementById('algorithmUsed');
    const continueButton = document.getElementById('continueAfterSingleNumber');
    
    const nums = originalArrayForSingleNumber.map(num => parseInt(num));
    let result = 0;
    let step = 0;
    
    // Method 1: Bit counting approach
    function performBitCountingStep(bitPosition) {
        if (bitPosition >= 32) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Single Number II Algorithm Completed!</strong> Found the unique number.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Unique number found using bit counting method
                </div>
            `;
            
            // Highlight the unique number in original array
            const originalElements = originalContainer.querySelectorAll('.array-element');
            originalElements.forEach((el, index) => {
                if (parseInt(nums[index]) === result) {
                    el.querySelector('.element-value').classList.add('non-repeating');
                } else {
                    el.querySelector('.element-value').classList.add('repeating');
                }
            });
            
            singleNumberValue.textContent = result;
            algorithmUsed.textContent = 'Bit Counting Method';
            
            // Show optimized method result
            const optimizedResult = singleNumberIIOptimized(nums);
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Optimized Method:</strong> Also returns ${optimizedResult} (using finite state automaton)
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterSingleNumber();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSingleNumber);
            
            return;
        }
        
        step++;
        explanation.innerHTML = `Step ${step}: Counting bits at position ${bitPosition}`;
        
        let count = 0;
        
        // Count bits at current position with animation
        function countBit(index) {
            if (index >= nums.length) {
                // Counting completed for this bit position
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step}:</strong> Bit position ${bitPosition} count = ${count}
                    </div>
                `;
                
                // Check if this bit should be set in result
                if (count % 3 === 1) {
                    if (bitPosition === 31) {
                        result -= (1 << 31);
                    } else {
                        result |= (1 << bitPosition);
                    }
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step}:</strong> Count % 3 = 1, setting bit ${bitPosition} in result
                        </div>
                    `;
                    
                    singleNumberValue.textContent = result;
                }
                
                // Move to next bit position
                setTimeout(() => {
                    performBitCountingStep(bitPosition + 1);
                }, 1000);
                
                return;
            }
            
            // Highlight current element being checked
            const elements = transformedContainer.querySelectorAll('.array-element');
            const currentElement = elements[index].querySelector('.element-value');
            currentElement.classList.add('checked-element');
            
            // Check if bit is set
            if ((nums[index] >> bitPosition) & 1) {
                count++;
                currentElement.classList.add('frequency-highlight');
            }
            
            setTimeout(() => {
                currentElement.classList.remove('checked-element');
                
                // Continue counting
                countBit(index + 1);
            }, 500);
        }
        
        // Start counting for this bit position
        countBit(0);
    }
    
    // Start the algorithm
    performBitCountingStep(0);
}

// NEW: Perform Single Number III Animation
function performSingleNumberIIIAnimation() {
    const originalContainer = document.getElementById('originalSingleNumberArray');
    const transformedContainer = document.getElementById('transformedSingleNumberArray');
    const explanation = document.getElementById('singleNumberExplanation');
    const stepsContainer = document.getElementById('singleNumberSteps');
    const firstUniqueValue = document.getElementById('firstUniqueValue');
    const secondUniqueValue = document.getElementById('secondUniqueValue');
    const continueButton = document.getElementById('continueAfterSingleNumber');
    
    const nums = originalArrayForSingleNumber.map(num => parseInt(num));
    let step = 0;
    
    function performPartitionStep() {
        step++;
        
        if (step === 1) {
            // Step 1: XOR all numbers
            explanation.innerHTML = `Step ${step}: XOR all numbers to find XOR of the two unique numbers`;
            
            let xorAll = 0;
            let currentIndex = 0;
            
            function performXOR(index) {
                if (index >= nums.length) {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step}:</strong> XOR of all numbers = ${xorAll}
                        </div>
                    `;
                    
                    step++;
                    performPartitionStep(xorAll);
                    return;
                }
                
                // Highlight current element
                const elements = transformedContainer.querySelectorAll('.array-element');
                const currentElement = elements[index].querySelector('.element-value');
                currentElement.classList.add('checked-element');
                
                xorAll ^= nums[index];
                
                setTimeout(() => {
                    currentElement.classList.remove('checked-element');
                    performXOR(index + 1);
                }, 600);
            }
            
            performXOR(0);
            
        } else if (step === 2) {
            // Step 2: Find rightmost set bit
            const xorAll = arguments[0];
            explanation.innerHTML = `Step ${step}: Find rightmost set bit in XOR result (${xorAll})`;
            
            const rightmostSetBit = xorAll & -xorAll;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Rightmost set bit = ${rightmostSetBit} (bit position ${Math.log2(rightmostSetBit)})
                </div>
            `;
            
            step++;
            performPartitionStep(xorAll, rightmostSetBit);
            
        } else if (step === 3) {
            // Step 3: Partition numbers based on the set bit
            const [xorAll, rightmostSetBit] = arguments;
            explanation.innerHTML = `Step ${step}: Partition numbers into two groups based on bit ${rightmostSetBit}`;
            
            let num1 = 0, num2 = 0;
            let currentIndex = 0;
            
            function performPartition(index) {
                if (index >= nums.length) {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step}:</strong> Partitioning completed. Unique numbers: ${num1} and ${num2}
                        </div>
                    `;
                    
                    // Show alternative method result
                    const alternativeResult = singleNumberIIIAlternative(nums);
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Alternative Method:</strong> Also returns [${alternativeResult.join(', ')}]
                        </div>
                    `;
                    
                    firstUniqueValue.textContent = num1;
                    secondUniqueValue.textContent = num2;
                    
                    // Highlight unique numbers in original array
                    const originalElements = originalContainer.querySelectorAll('.array-element');
                    originalElements.forEach((el, idx) => {
                        if (nums[idx] === num1 || nums[idx] === num2) {
                            el.querySelector('.element-value').classList.add('non-repeating');
                        } else {
                            el.querySelector('.element-value').classList.add('repeating');
                        }
                    });
                    
                    continueButton.style.display = 'block';
                    
                    // Auto-return after 20 seconds
                    setTimeout(() => {
                        returnToOriginalAfterSingleNumber();
                    }, 20000);
                    
                    continueButton.addEventListener('click', returnToOriginalAfterSingleNumber);
                    
                    return;
                }
                
                const elements = transformedContainer.querySelectorAll('.array-element');
                const currentElement = elements[index].querySelector('.element-value');
                
                if (nums[index] & rightmostSetBit) {
                    // Group 1: numbers with this bit set
                    num1 ^= nums[index];
                    currentElement.classList.add('two-pointer-left');
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step}.${index + 1}:</strong> [${index}]=${nums[index]}  Group 1 (bit set), XOR result = ${num1}
                        </div>
                    `;
                } else {
                    // Group 2: numbers without this bit set
                    num2 ^= nums[index];
                    currentElement.classList.add('two-pointer-right');
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step}.${index + 1}:</strong> [${index}]=${nums[index]}  Group 2 (bit not set), XOR result = ${num2}
                        </div>
                    `;
                }
                
                setTimeout(() => {
                    currentElement.classList.remove('two-pointer-left', 'two-pointer-right');
                    performPartition(index + 1);
                }, 800);
            }
            
            performPartition(0);
        }
    }
    
    // Start the algorithm
    performPartitionStep();
}

// NEW: Single Number II Optimized (as in Python code)
function singleNumberIIOptimized(nums) {
    let ones = 0, twos = 0;
    for (let num of nums) {
        ones = (ones ^ num) & ~twos;
        twos = (twos ^ num) & ~ones;
    }
    return ones;
}

// NEW: Single Number III Alternative (as in Python code)
function singleNumberIIIAlternative(nums) {
    let xorResult = 0;
    for (let num of nums) {
        xorResult ^= num;
    }
    
    let diffBit = 1;
    while ((xorResult & diffBit) === 0) {
        diffBit <<= 1;
    }
    
    let group1 = 0, group2 = 0;
    for (let num of nums) {
        if (num & diffBit) {
            group1 ^= num;
        } else {
            group2 ^= num;
        }
    }
    
    return [group1, group2];
}

// NEW: Return to Original after Single Number Operations
function returnToOriginalAfterSingleNumber() {
    // Reset to original array
    myArray = [...originalArrayForSingleNumber];
    originalArrayForSingleNumber = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isSingleNumberRunning = false;
    
    logOperation('Single Number operation completed - returned to original array', 'info');
    showNotification('Returned to original array after Single Number operation', 'success');
}
// NEW: Handle String Operation Selection
function handleStringOperation(operation) {
    if (isStringOpRunning) {
        showNotification('A string operation is already in progress', 'warning');
        return;
    }
    
    currentStringOpType = operation;
    
    // Reset arrays
    stringOpArray = [];
    stringOpArraySize = 0;
    
    // Show input group
    stringOperationGroup.style.display = 'block';
    
    // Set title based on operation
    if (operation === 'maxProduct') {
        stringOperationTitle.textContent = 'Maximum Product of Word Lengths - Enter Array Details';
    } else {
        stringOperationTitle.textContent = 'Count Consistent Strings - Enter Array Details';
    }
    
    // Hide perform button initially
    performStringOperationBtn.style.display = 'none';
    
    stringArraySizeInput.focus();
    
    logOperation(`Started ${operation === 'maxProduct' ? 'Maximum Product of Word Lengths' : 'Count Consistent Strings'} operation`, 'info');
}

// NEW: Confirm String Array Size
function handleConfirmStringArraySize() {
    const size = parseInt(stringArraySizeInput.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        stringArraySizeInput.focus();
        return;
    }
    
    stringOpArraySize = size;
    stringOpArray = [];
    
    // Create input fields for string array
    stringArrayInputs.innerHTML = '<label class="form-label">Enter words/strings:</label>';
    
    // For Count Consistent Strings, we need an additional input for allowed characters
    if (currentStringOpType === 'countConsistent') {
        const allowedGroup = document.createElement('div');
        allowedGroup.className = 'input-group mb-3';
        allowedGroup.innerHTML = `
            <span class="input-group-text">Allowed Characters</span>
            <input type="text" class="form-control" id="allowedCharacters" 
                   placeholder="e.g., ab, abc, etc." maxlength="26">
        `;
        stringArrayInputs.appendChild(allowedGroup);
    }
    
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Word ${i}</span>
            <input type="text" class="form-control string-array-element" 
                   placeholder="Enter word/string" data-index="${i}">
        `;
        stringArrayInputs.appendChild(inputGroup);
    }
    
    // Add event listeners for string array inputs
    const stringElements = stringArrayInputs.querySelectorAll('.string-array-element');
    stringElements.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('string-array-element')) {
                    nextInput.focus();
                } else {
                    performStringOperationBtn.focus();
                }
            }
        });
    });
    
    // Show perform button
    performStringOperationBtn.style.display = 'block';
    
    showNotification(`Array size set to ${size}. Please enter ${size} words.`, 'success');
    logOperation(`String array size set to ${size}`, 'info');
}

// NEW: Perform String Operation
function handlePerformStringOperation() {
    // Collect string array elements
    const stringElements = document.querySelectorAll('.string-array-element');
    stringOpArray = [];
    
    for (let i = 0; i < stringElements.length; i++) {
        const value = stringElements[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all words. Missing word at position ${i}`, 'danger');
            stringElements[i].focus();
            return;
        }
        stringOpArray.push(value);
    }
    
    // For Count Consistent Strings, collect allowed characters
    let allowedChars = '';
    if (currentStringOpType === 'countConsistent') {
        const allowedInput = document.getElementById('allowedCharacters');
        allowedChars = allowedInput.value.trim();
        if (allowedChars === '') {
            showNotification('Please enter allowed characters', 'danger');
            allowedInput.focus();
            return;
        }
    }
    
    // Store original array
    originalArrayForStringOp = [...myArray];
    
    // Hide input group
    stringOperationGroup.style.display = 'none';
    
    // Start operation visualization
    if (currentStringOpType === 'maxProduct') {
        showMaxProductVisualization();
    } else {
        showCountConsistentVisualization(allowedChars);
    }
}

// NEW: Cancel String Operation
function handleCancelStringOperation() {
    stringOperationGroup.style.display = 'none';
    stringArraySizeInput.value = '';
    stringArrayInputs.innerHTML = '';
    performStringOperationBtn.style.display = 'none';
    
    stringOpArray = [];
    stringOpArraySize = 0;
    currentStringOpType = null;
    
    logOperation('Cancelled string operation', 'info');
    showNotification('String operation cancelled', 'info');
}

// NEW: Show Maximum Product of Word Lengths Visualization
function showMaxProductVisualization() {
    isStringOpRunning = true;
    
    const operationContainer = document.createElement('div');
    operationContainer.className = 'string-operation-container';
    operationContainer.innerHTML = `
        <h5 class="text-center mb-3">Maximum Product of Word Lengths</h5>
        
        <div class="string-operation-group">
            <div class="string-operation-label">Input Words</div>
            <div class="original-array-container" id="wordsArrayDisplay"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find maximum product of word lengths where words share no common letters</p>
            <p class="mb-0" id="maxProductExplanation">Initializing algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="maxProductStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="maxProductSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Maximum Product Found</div>
            <div class="stats-value" id="maxProductValue">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterStringOp" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(operationContainer);
    
    // Display the words as string elements
    renderStringArray(stringOpArray, 'wordsArrayDisplay');
    
    // Start algorithm animation
    performMaxProductAlgorithm();
}

// NEW: Perform Maximum Product of Word Lengths Algorithm
function performMaxProductAlgorithm() {
    const wordsContainer = document.getElementById('wordsArrayDisplay');
    const explanation = document.getElementById('maxProductExplanation');
    const stepsContainer = document.getElementById('maxProductSteps');
    const maxProductValue = document.getElementById('maxProductValue');
    const continueButton = document.getElementById('continueAfterStringOp');
    
    const words = stringOpArray;
    let bitmasks = [];
    let maxProduct = 0;
    let bestPair = [];
    let step = 0;
    
    function performAlgorithmStep() {
        if (step === 0) {
            // Step 1: Create bitmask for each word
            explanation.innerHTML = "Step 1: Creating bitmask for each word";
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Creating bitmask representation for each word
                </div>
            `;
            
            createBitmasksStepByStep(0);
            
        } else if (step === 1) {
            // Step 2: Find maximum product
            explanation.innerHTML = "Step 2: Finding maximum product of word lengths with no common letters";
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 2:</strong> Checking all word pairs for common letters
                </div>
            `;
            
            findMaxProductStepByStep(0, 1);
            
        } else {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Maximum product: ${maxProduct}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Maximum product = ${maxProduct} (words: "${bestPair[0]}" and "${bestPair[1]}")
                </div>
            `;
            
            // Highlight the best pair
            const wordElements = wordsContainer.querySelectorAll('.string-element');
            const index1 = words.indexOf(bestPair[0]);
            const index2 = words.indexOf(bestPair[1]);
            
            if (index1 !== -1 && index2 !== -1) {
                wordElements[index1].classList.add('product-highlight');
                wordElements[index2].classList.add('product-highlight');
            }
            
            maxProductValue.textContent = maxProduct;
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterStringOp();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterStringOp);
        }
    }
    
    function createBitmasksStepByStep(wordIndex) {
        if (wordIndex >= words.length) {
            step++;
            performAlgorithmStep();
            return;
        }
        
        const word = words[wordIndex];
        let mask = 0;
        let charIndex = 0;
        
        explanation.innerHTML = `Creating bitmask for word "${word}"`;
        
        function processNextChar() {
            if (charIndex >= word.length) {
                bitmasks.push(mask);
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Word ${wordIndex}:</strong> "${word}"  bitmask: ${mask.toString(2).padStart(26, '0')}
                    </div>
                `;
                
                // Highlight the current word
                const wordElements = wordsContainer.querySelectorAll('.string-element');
                wordElements[wordIndex].classList.add('info-color');
                
                setTimeout(() => {
                    wordElements[wordIndex].classList.remove('info-color');
                    createBitmasksStepByStep(wordIndex + 1);
                }, 1000);
                
                return;
            }
            
            const char = word[charIndex];
            const pos = char.charCodeAt(0) - 'a'.charCodeAt(0);
            mask |= (1 << pos);
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Word ${wordIndex}:</strong> char '${char}'  pos ${pos}, mask: ${mask.toString(2).padStart(26, '0')}
                </div>
            `;
            
            charIndex++;
            setTimeout(processNextChar, 500);
        }
        
        processNextChar();
    }
    
    function findMaxProductStepByStep(i, j) {
        if (i >= words.length - 1) {
            step++;
            performAlgorithmStep();
            return;
        }
        
        if (j >= words.length) {
            findMaxProductStepByStep(i + 1, i + 2);
            return;
        }
        
        const word1 = words[i];
        const word2 = words[j];
        const mask1 = bitmasks[i];
        const mask2 = bitmasks[j];
        
        explanation.innerHTML = `Checking pair: "${word1}" and "${word2}"`;
        
        // Highlight the current pair
        const wordElements = wordsContainer.querySelectorAll('.string-element');
        wordElements[i].classList.add('sorting-current');
        wordElements[j].classList.add('sorting-compared');
        
        // Check if words share common letters
        const commonLetters = (mask1 & mask2) === 0;
        
        setTimeout(() => {
            if (commonLetters) {
                const product = word1.length * word2.length;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Pair (${i},${j}):</strong> "${word1}" & "${word2}"  No common letters, product = ${product}
                    </div>
                `;
                
                if (product > maxProduct) {
                    maxProduct = product;
                    bestPair = [word1, word2];
                    
                    // Highlight as new best pair
                    wordElements[i].classList.add('success-color');
                    wordElements[j].classList.add('success-color');
                }
            } else {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Pair (${i},${j}):</strong> "${word1}" & "${word2}"  Common letters exist
                    </div>
                `;
            }
            
            // Remove temporary highlights
            wordElements[i].classList.remove('sorting-current');
            wordElements[j].classList.remove('sorting-compared');
            
            // Scroll steps container
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            // Continue with next pair
            findMaxProductStepByStep(i, j + 1);
        }, 1500);
    }
    
    // Start algorithm
    performAlgorithmStep();
}

// NEW: Show Count Consistent Strings Visualization
function showCountConsistentVisualization(allowedChars) {
    isStringOpRunning = true;
    
    const operationContainer = document.createElement('div');
    operationContainer.className = 'string-operation-container';
    operationContainer.innerHTML = `
        <h5 class="text-center mb-3">Count Consistent Strings</h5>
        
        <div class="string-operation-group">
            <div class="string-operation-label">Allowed Characters: "${allowedChars}"</div>
            <div class="bitmask-display" id="allowedMaskDisplay">
                <div>Allowed Characters Bitmask:</div>
                <div class="bitmask-bits" id="allowedBits"></div>
            </div>
        </div>
        
        <div class="string-operation-group">
            <div class="string-operation-label">Words to Check</div>
            <div class="original-array-container" id="wordsToCheckDisplay"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Count how many words consist only of allowed characters</p>
            <p class="mb-0" id="countConsistentExplanation">Initializing algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="countConsistentStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="countConsistentSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Consistent Strings Count</div>
            <div class="stats-value" id="consistentCountValue">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterStringOp" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(operationContainer);
    
    // Display allowed characters bitmask
    renderAllowedBitmask(allowedChars);
    
    // Display the words as string elements
    renderStringArray(stringOpArray, 'wordsToCheckDisplay');
    
    // Start algorithm animation
    performCountConsistentAlgorithm(allowedChars);
}

// NEW: Perform Count Consistent Strings Algorithm
function performCountConsistentAlgorithm(allowedChars) {
    const wordsContainer = document.getElementById('wordsToCheckDisplay');
    const explanation = document.getElementById('countConsistentExplanation');
    const stepsContainer = document.getElementById('countConsistentSteps');
    const consistentCountValue = document.getElementById('consistentCountValue');
    const continueButton = document.getElementById('continueAfterStringOp');
    
    const words = stringOpArray;
    let consistentCount = 0;
    let step = 0;
    
    // Create allowed mask
    let allowedMask = 0;
    for (let char of allowedChars) {
        const pos = char.charCodeAt(0) - 'a'.charCodeAt(0);
        allowedMask |= (1 << pos);
    }
    
    function performAlgorithmStep() {
        if (step === 0) {
            // Step 1: Check each word
            explanation.innerHTML = "Step 1: Checking each word against allowed characters";
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Checking each word for consistency with allowed characters
                </div>
            `;
            
            checkWordsStepByStep(0);
            
        } else {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Consistent strings count: ${consistentCount}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Total consistent strings = ${consistentCount}
                </div>
            `;
            
            consistentCountValue.textContent = consistentCount;
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterStringOp();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterStringOp);
        }
    }
    
    function checkWordsStepByStep(wordIndex) {
        if (wordIndex >= words.length) {
            step++;
            performAlgorithmStep();
            return;
        }
        
        const word = words[wordIndex];
        let wordMask = 0;
        let charIndex = 0;
        
        explanation.innerHTML = `Checking word "${word}"`;
        
        // Highlight the current word
        const wordElements = wordsContainer.querySelectorAll('.string-element');
        wordElements[wordIndex].classList.add('sorting-current');
        
        function processNextChar() {
            if (charIndex >= word.length) {
                // Check if word is consistent
                const isConsistent = (wordMask & (~allowedMask)) === 0;
                
                if (isConsistent) {
                    consistentCount++;
                    wordElements[wordIndex].classList.add('consistent');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Word ${wordIndex}:</strong> "${word}"  CONSISTENT 
                        </div>
                    `;
                } else {
                    wordElements[wordIndex].classList.add('inconsistent');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Word ${wordIndex}:</strong> "${word}"  NOT CONSISTENT 
                        </div>
                    `;
                }
                
                // Remove temporary highlight
                wordElements[wordIndex].classList.remove('sorting-current');
                
                // Scroll steps container
                stepsContainer.scrollTop = stepsContainer.scrollHeight;
                
                setTimeout(() => {
                    checkWordsStepByStep(wordIndex + 1);
                }, 1000);
                
                return;
            }
            
            const char = word[charIndex];
            const pos = char.charCodeAt(0) - 'a'.charCodeAt(0);
            wordMask |= (1 << pos);
            
            // Check if this character is allowed
            const isCharAllowed = (allowedMask & (1 << pos)) !== 0;
            
            if (!isCharAllowed) {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Word ${wordIndex}:</strong> char '${char}'  NOT ALLOWED 
                    </div>
                `;
            } else {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Word ${wordIndex}:</strong> char '${char}'  ALLOWED 
                    </div>
                `;
            }
            
            charIndex++;
            setTimeout(processNextChar, 500);
        }
        
        processNextChar();
    }
    
    // Start algorithm
    performAlgorithmStep();
}

// NEW: Render String Array
function renderStringArray(strings, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    strings.forEach((str, index) => {
        const stringElement = document.createElement('div');
        stringElement.className = 'string-element';
        stringElement.textContent = str;
        stringElement.setAttribute('data-index', index);
        container.appendChild(stringElement);
    });
}

// NEW: Render Allowed Bitmask
function renderAllowedBitmask(allowedChars) {
    const bitsContainer = document.getElementById('allowedBits');
    bitsContainer.innerHTML = '';
    
    // Create 26 bits for a-z
    for (let i = 0; i < 26; i++) {
        const char = String.fromCharCode('a'.charCodeAt(0) + i);
        const bitElement = document.createElement('div');
        bitElement.className = 'bitmask-bit';
        bitElement.textContent = char;
        
        // Check if this character is in allowedChars
        if (allowedChars.includes(char)) {
            bitElement.classList.add('active');
        }
        
        bitsContainer.appendChild(bitElement);
    }
}

// NEW: Return to Original after String Operation
function returnToOriginalAfterStringOp() {
    // Reset to original array
    myArray = [...originalArrayForStringOp];
    originalArrayForStringOp = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isStringOpRunning = false;
    currentStringOpType = null;
    
    // Clear all string operation data
    stringOpArray = [];
    stringOpArraySize = 0;
    
    logOperation('String operation completed - returned to original array', 'info');
    showNotification('Returned to original array after string operation', 'success');
}
// NEW: Subarray Bitwise ORs Handler
function handleSubarrayBitwiseORs() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isBitwiseOperationRunning) {
        showNotification('A bitwise operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains valid integers for bitwise operations
    let allIntegers = true;
    for (let i = 0; i < myArray.length; i++) {
        const num = parseInt(myArray[i]);
        if (isNaN(num) || !Number.isInteger(num) || num < 0) {
            allIntegers = false;
            break;
        }
    }
    
    if (!allIntegers) {
        showNotification('Bitwise operations require all array elements to be non-negative integers', 'danger');
        return;
    }
    
    isBitwiseOperationRunning = true;
    
    // Store original array
    originalArrayForBitwise = [...myArray];
    
    // Perform Subarray Bitwise ORs visualization
    performSubarrayBitwiseORsAnimation();
}

// NEW: Bitwise AND of Numbers Range Handler
function handleBitwiseAndRange() {
    if (isRangeBitwiseRunning) {
        showNotification('A range bitwise operation is already in progress', 'warning');
        return;
    }
    
    // Show input dialog for range
    const left = prompt('Enter left bound of range (non-negative integer):');
    const right = prompt('Enter right bound of range (non-negative integer):');
    
    if (left === null || right === null) {
        return; // User cancelled
    }
    
    const leftNum = parseInt(left);
    const rightNum = parseInt(right);
    
    if (isNaN(leftNum) || isNaN(rightNum) || !Number.isInteger(leftNum) || !Number.isInteger(rightNum) || 
        leftNum < 0 || rightNum < 0 || leftNum > rightNum) {
        showNotification('Please enter valid non-negative integers with left  right', 'danger');
        return;
    }
    
    isRangeBitwiseRunning = true;
    
    // Perform Bitwise AND Range visualization
    performBitwiseAndRangeAnimation(leftNum, rightNum);
}
// NEW: Perform Subarray Bitwise ORs Animation
function performSubarrayBitwiseORsAnimation() {
    const arr = originalArrayForBitwise.map(val => parseInt(val));
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Subarray Bitwise ORs - Count Distinct Results</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalBitwiseArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Bitwise OR Operations</div>
            <div class="transformed-array-container" id="transformedBitwiseArray"></div>
        </div>
        
        <div class="bitwise-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Count distinct bitwise ORs of all subarrays</p>
            <p class="mb-0" id="bitwiseExplanation">Initializing algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="bitwiseStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="bitwiseSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Distinct Bitwise OR Results</div>
            <div class="stats-value" id="distinctResultsCount">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>All Distinct Values</div>
            <div class="stats-value" id="distinctValuesList">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterBitwise" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForBitwise, 'originalBitwiseArray');
    renderArrayInContainer([...originalArrayForBitwise], 'transformedBitwiseArray');
    
    executeSubarrayBitwiseORsAlgorithm(arr);
}

// NEW: Execute Subarray Bitwise ORs Algorithm
function executeSubarrayBitwiseORsAlgorithm(arr) {
    const originalContainer = document.getElementById('originalBitwiseArray');
    const transformedContainer = document.getElementById('transformedBitwiseArray');
    const explanation = document.getElementById('bitwiseExplanation');
    const stepsContainer = document.getElementById('bitwiseSteps');
    const distinctResultsCount = document.getElementById('distinctResultsCount');
    const distinctValuesList = document.getElementById('distinctValuesList');
    const continueButton = document.getElementById('continueAfterBitwise');
    
    let result = new Set();
    let current = new Set();
    let step = 0;
    let i = 0;
    
    function executeBitwiseStep() {
        if (i >= arr.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Found ${result.size} distinct bitwise OR results.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Total distinct bitwise OR results = ${result.size}
                </div>
            `;
            
            distinctResultsCount.textContent = result.size;
            distinctValuesList.textContent = Array.from(result).sort((a, b) => a - b).join(', ');
            
            // Highlight all elements in original array
            const originalElements = originalContainer.querySelectorAll('.array-element');
            originalElements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('bitwise-distinct');
                }, index * 200);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterBitwise();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterBitwise);
            
            return;
        }
        
        step++;
        const num = arr[i];
        
        explanation.innerHTML = `Processing element [${i}] = ${num} (binary: ${num.toString(2)})`;
        
        // Highlight current element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[i].querySelector('.element-value');
        currentElement.classList.add('bitwise-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> Processing arr[${i}] = ${num}
            </div>
        `;
        
        setTimeout(() => {
            // Create new set for current position
            const newCurrent = new Set();
            newCurrent.add(num);
            
            // Show current element being processed
            currentElement.classList.remove('bitwise-current');
            currentElement.classList.add('bitwise-or-result');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}.1:</strong> Initialize newCurrent with {${num}}
                </div>
            `;
            
            // Process previous results with current element
            let substep = 0;
            const currentArray = Array.from(current);
            
            function processPreviousResults() {
                if (substep >= currentArray.length) {
                    // Finished processing previous results
                    current = newCurrent;
                    
                    // Add all values to result set
                    newCurrent.forEach(val => result.add(val));
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step}.3:</strong> Updated result set. Current size: ${result.size}
                        </div>
                    `;
                    
                    distinctResultsCount.textContent = result.size;
                    distinctValuesList.textContent = Array.from(result).sort((a, b) => a - b).join(', ');
                    
                    // Update transformed array to show current state
                    const displayArray = Array.from(newCurrent).map(val => val.toString());
                    renderArrayInContainer(displayArray, 'transformedBitwiseArray');
                    
                    // Highlight the transformed array elements
                    setTimeout(() => {
                        const transformedElements = transformedContainer.querySelectorAll('.array-element');
                        transformedElements.forEach(el => {
                            el.querySelector('.element-value').classList.add('bitwise-or-result');
                        });
                        
                        i++;
                        executeBitwiseStep();
                    }, 1000);
                    
                    return;
                }
                
                const prevVal = currentArray[substep];
                const orResult = prevVal | num;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step}.2.${substep + 1}:</strong> ${prevVal} | ${num} = ${orResult}
                    </div>
                `;
                
                newCurrent.add(orResult);
                substep++;
                
                setTimeout(processPreviousResults, 800);
            }
            
            processPreviousResults();
        }, 1000);
    }
    
    // Start algorithm execution
    executeBitwiseStep();
}

// NEW: Perform Bitwise AND Range Animation
function performBitwiseAndRangeAnimation(left, right) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Bitwise AND of Numbers Range [${left}, ${right}]</h5>
        
        <div class="array-group">
            <div class="array-label">Range: ${left} to ${right}</div>
            <div class="original-array-container" id="rangeDisplay"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Bitwise AND Process</div>
            <div class="transformed-array-container" id="bitwiseProcessDisplay"></div>
        </div>
        
        <div class="bitwise-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find common prefix of binary representations</p>
            <p class="mb-0" id="rangeBitwiseExplanation">Initializing algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="rangeBitwiseStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="rangeBitwiseSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Bitwise AND Result</div>
            <div class="stats-value" id="bitwiseAndResult">-</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Binary Representation</div>
            <div class="stats-value" id="binaryRepresentation">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterRangeBitwise" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Create a visual representation of the range
    const rangeArray = [];
    const maxDisplay = Math.min(right, left + 10); // Show max 10 numbers for display
    for (let i = left; i <= maxDisplay; i++) {
        rangeArray.push(i.toString());
    }
    if (right > maxDisplay) {
        rangeArray.push('...');
        rangeArray.push(right.toString());
    }
    
    renderArrayInContainer(rangeArray, 'rangeDisplay');
    renderArrayInContainer([], 'bitwiseProcessDisplay');
    
    executeBitwiseAndRangeAlgorithm(left, right);
}

// NEW: Execute Bitwise AND Range Algorithm
function executeBitwiseAndRangeAlgorithm(left, right) {
    const rangeContainer = document.getElementById('rangeDisplay');
    const processContainer = document.getElementById('bitwiseProcessDisplay');
    const explanation = document.getElementById('rangeBitwiseExplanation');
    const stepsContainer = document.getElementById('rangeBitwiseSteps');
    const bitwiseAndResult = document.getElementById('bitwiseAndResult');
    const binaryRepresentation = document.getElementById('binaryRepresentation');
    const continueButton = document.getElementById('continueAfterRangeBitwise');
    
    let shift = 0;
    let currentLeft = left;
    let currentRight = right;
    let step = 0;
    
    function executeRangeStep() {
        if (currentLeft === currentRight || currentLeft === 0) {
            // Algorithm completed
            const result = currentLeft << shift;
            
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Bitwise AND = ${result}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Result = ${currentLeft} << ${shift} = ${result}
                </div>
            `;
            
            bitwiseAndResult.textContent = result;
            binaryRepresentation.textContent = `Left: ${currentLeft.toString(2)} << ${shift} = ${result.toString(2)}`;
            
            // Show final result
            const resultArray = [result.toString()];
            renderArrayInContainer(resultArray, 'bitwiseProcessDisplay');
            
            // Highlight the result
            setTimeout(() => {
                const processElements = processContainer.querySelectorAll('.array-element');
                if (processElements.length > 0) {
                    processElements[0].querySelector('.element-value').classList.add('bitwise-distinct');
                }
            }, 500);
            
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterRangeBitwise();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterRangeBitwise);
            
            return;
        }
        
        step++;
        
        explanation.innerHTML = `Step ${step}: left=${currentLeft}, right=${currentRight}, shift=${shift}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> left=${currentLeft} (binary: ${currentLeft.toString(2)}), right=${currentRight} (binary: ${currentRight.toString(2)})
            </div>
        `;
        
        // Show current state in process container
        const processArray = [
            `Left: ${currentLeft}`,
            `Right: ${currentRight}`,
            `Shift: ${shift}`
        ];
        renderArrayInContainer(processArray, 'bitwiseProcessDisplay');
        
        setTimeout(() => {
            // Right shift both numbers
            const newLeft = currentLeft >> 1;
            const newRight = currentRight >> 1;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}.1:</strong> Right shift: left=${newLeft}, right=${newRight}
                </div>
            `;
            
            currentLeft = newLeft;
            currentRight = newRight;
            shift++;
            
            executeRangeStep();
        }, 1500);
    }
    
    // Special case: if left and right are the same
    if (left === right) {
        explanation.innerHTML = `<strong>Special Case:</strong> left = right, so AND is the number itself`;
        bitwiseAndResult.textContent = left;
        binaryRepresentation.textContent = left.toString(2);
        
        const resultArray = [left.toString()];
        renderArrayInContainer(resultArray, 'bitwiseProcessDisplay');
        
        setTimeout(() => {
            const processElements = processContainer.querySelectorAll('.array-element');
            if (processElements.length > 0) {
                processElements[0].querySelector('.element-value').classList.add('bitwise-distinct');
            }
        }, 500);
        
        continueButton.style.display = 'block';
        
        setTimeout(() => {
            returnToOriginalAfterRangeBitwise();
        }, 20000);
        
        continueButton.addEventListener('click', returnToOriginalAfterRangeBitwise);
    } else {
        // Start algorithm execution
        executeRangeStep();
    }
}

// NEW: Return to Original after Bitwise Operations
function returnToOriginalAfterBitwise() {
    // Reset to original array
    myArray = [...originalArrayForBitwise];
    originalArrayForBitwise = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isBitwiseOperationRunning = false;
    
    logOperation('Subarray Bitwise ORs completed - returned to original array', 'info');
    showNotification('Returned to original array after bitwise operation', 'success');
}

// NEW: Return to Original after Range Bitwise
function returnToOriginalAfterRangeBitwise() {
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isRangeBitwiseRunning = false;
    
    logOperation('Bitwise AND Range completed - returned to original array', 'info');
    showNotification('Returned to original array after range bitwise operation', 'success');
}
// NEW: Start Hamming Operation
function startHammingOperation(operation) {
    if (isHammingOperationRunning) {
        showNotification('A Hamming operation is already in progress', 'warning');
        return;
    }

    currentHammingOperation = operation;
    hammingArray = [];
    
    // Show input group
    hammingOperationsGroup.style.display = 'block';
    hammingArraySize.focus();
    
    // Set appropriate label
    if (operation === 'weight') {
        hammingOperationLabel.textContent = 'Hamming Weight - Enter Array Details';
    } else {
        hammingOperationLabel.textContent = 'Hamming Distance - Enter Array Details';
    }
    
    // Hide perform button initially
    performHammingOperationBtn.style.display = 'none';
    
    logOperation(`Started ${operation === 'weight' ? 'Hamming Weight' : 'Hamming Distance'} operation`, 'info');
}

// NEW: Confirm Hamming Array Size
function handleConfirmHammingArraySize() {
    const size = parseInt(hammingArraySize.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        hammingArraySize.focus();
        return;
    }
    
    hammingArray = [];
    
    // Create input fields for array
    hammingArrayInputs.innerHTML = `<label class="form-label">Enter ${size} integer elements:</label>`;
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="number" class="form-control hamming-array-element" 
                   placeholder="Enter integer" data-index="${i}">
        `;
        hammingArrayInputs.appendChild(inputGroup);
    }
    
    // Add event listeners for array inputs
    const hammingArrayElements = hammingArrayInputs.querySelectorAll('.hamming-array-element');
    hammingArrayElements.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('hamming-array-element')) {
                    nextInput.focus();
                }
            }
        });
    });
    
    // Show perform button
    performHammingOperationBtn.style.display = 'block';
    
    showNotification(`Array size set to ${size}. Please enter ${size} integers.`, 'success');
    logOperation(`Hamming operation array size set to ${size}`, 'info');
}

// NEW: Perform Hamming Operation
function handlePerformHammingOperation() {
    // Collect array elements
    const hammingArrayInputs = document.querySelectorAll('.hamming-array-element');
    hammingArray = [];
    
    for (let i = 0; i < hammingArrayInputs.length; i++) {
        const value = hammingArrayInputs[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all elements. Missing element at position ${i}`, 'danger');
            hammingArrayInputs[i].focus();
            return;
        }
        
        const numValue = parseInt(value);
        if (isNaN(numValue)) {
            showNotification(`Please enter valid integers only. Invalid value at position ${i}`, 'danger');
            hammingArrayInputs[i].focus();
            return;
        }
        
        hammingArray.push(numValue);
    }
    
    // Store original array
    originalArrayForHamming = [...myArray];
    
    // Hide input group
    hammingOperationsGroup.style.display = 'none';
    
    // Start operation visualization
    if (currentHammingOperation === 'weight') {
        performHammingWeightVisualization();
    } else {
        performHammingDistanceVisualization();
    }
}

// NEW: Cancel Hamming Operation
function handleCancelHammingOperation() {
    hammingOperationsGroup.style.display = 'none';
    hammingArraySize.value = '';
    hammingArrayInputs.innerHTML = '';
    performHammingOperationBtn.style.display = 'none';
    
    hammingArray = [];
    currentHammingOperation = null;
    
    logOperation('Cancelled Hamming operation', 'info');
    showNotification('Hamming operation cancelled', 'info');
}

// NEW: Perform Hamming Weight Visualization
function performHammingWeightVisualization() {
    isHammingOperationRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Hamming Weight - Count 1 Bits in Array</h5>
        
        <div class="array-group">
            <div class="array-label">Input Array (Decimal)</div>
            <div class="original-array-container" id="hammingInputArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Binary Representation</div>
            <div class="transformed-array-container" id="hammingBinaryArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Hamming Weight:</strong> Count total number of 1 bits across all numbers</p>
            <p class="mb-0" id="hammingExplanation">Starting Hamming weight calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="hammingStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="hammingSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Total Hamming Weight (1 Bits Count)</div>
            <div class="stats-value" id="hammingWeightResult">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterHamming" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display input array
    renderArrayInContainer(hammingArray.map(num => num.toString()), 'hammingInputArray');
    
    // Start Hamming weight calculation
    executeHammingWeightAlgorithm();
}

// NEW: Execute Hamming Weight Algorithm with Animation
function executeHammingWeightAlgorithm() {
    const inputContainer = document.getElementById('hammingInputArray');
    const binaryContainer = document.getElementById('hammingBinaryArray');
    const explanation = document.getElementById('hammingExplanation');
    const stepsContainer = document.getElementById('hammingSteps');
    const hammingWeightResult = document.getElementById('hammingWeightResult');
    const continueButton = document.getElementById('continueAfterHamming');
    
    let totalOnes = 0;
    let currentNumberIndex = 0;
    let currentBitPosition = 0;
    
    function executeHammingStep() {
        if (currentNumberIndex >= hammingArray.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Hamming Weight Calculation Completed!</strong> Total 1 bits: ${totalOnes}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Total Hamming Weight = ${totalOnes} across all numbers
                </div>
            `;
            
            hammingWeightResult.textContent = totalOnes;
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterHamming();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterHamming);
            
            return;
        }
        
        const currentNumber = hammingArray[currentNumberIndex];
        const binaryString = currentNumber.toString(2).padStart(8, '0');
        
        if (currentBitPosition === 0) {
            // Start processing new number
            explanation.innerHTML = `Processing number ${currentNumber} (binary: ${binaryString})`;
            
            // Display binary representation
            renderArrayInContainer([binaryString], 'hammingBinaryArray');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Number ${currentNumberIndex + 1}:</strong> ${currentNumber} (binary: ${binaryString})
                </div>
            `;
            
            // Highlight current number in input array
            const inputElements = inputContainer.querySelectorAll('.array-element');
            inputElements[currentNumberIndex].querySelector('.element-value').classList.add('sorting-current');
        }
        
        if (currentBitPosition < binaryString.length) {
            const currentBit = binaryString[binaryString.length - 1 - currentBitPosition];
            
            explanation.innerHTML = `Checking bit ${currentBitPosition} of ${currentNumber}: ${currentBit}`;
            
            // Highlight current bit in binary representation
            const binaryElements = binaryContainer.querySelectorAll('.array-element');
            const binaryValue = binaryElements[0].querySelector('.element-value');
            
            // Create visual representation of bit checking
            setTimeout(() => {
                if (currentBit === '1') {
                    totalOnes++;
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Bit ${currentBitPosition}:</strong> Found 1! Total ones so far: ${totalOnes}
                        </div>
                    `;
                    
                    // Highlight the 1 bit
                    binaryValue.classList.add('success-color');
                    
                    setTimeout(() => {
                        binaryValue.classList.remove('success-color');
                        currentBitPosition++;
                        executeHammingStep();
                    }, 1000);
                } else {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Bit ${currentBitPosition}:</strong> Found 0
                        </div>
                    `;
                    
                    currentBitPosition++;
                    executeHammingStep();
                }
            }, 500);
        } else {
            // Move to next number
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Completed:</strong> Number ${currentNumber} has ${(currentNumber.toString(2).match(/1/g) || []).length} ones
                </div>
            `;
            
            // Remove highlight from current number
            const inputElements = inputContainer.querySelectorAll('.array-element');
            inputElements[currentNumberIndex].querySelector('.element-value').classList.remove('sorting-current');
            
            currentNumberIndex++;
            currentBitPosition = 0;
            executeHammingStep();
        }
        
        // Update result display
        hammingWeightResult.textContent = totalOnes;
    }
    
    // Start execution
    executeHammingStep();
}

// NEW: Perform Hamming Distance Visualization
function performHammingDistanceVisualization() {
    isHammingOperationRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Total Hamming Distance Between All Pairs</h5>
        
        <div class="array-group">
            <div class="array-label">Input Array</div>
            <div class="original-array-container" id="hammingInputArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Binary Representations</div>
            <div class="transformed-array-container" id="hammingBinaryArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Hamming Distance:</strong> Sum of different bits between all number pairs</p>
            <p class="mb-0" id="hammingExplanation">Starting Hamming distance calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="hammingStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="hammingSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Total Hamming Distance</div>
            <div class="stats-value" id="hammingDistanceResult">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterHamming" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display input array
    renderArrayInContainer(hammingArray.map(num => num.toString()), 'hammingInputArray');
    
    // Display binary representations
    const binaryArray = hammingArray.map(num => num.toString(2).padStart(8, '0'));
    renderArrayInContainer(binaryArray, 'hammingBinaryArray');
    
    // Start Hamming distance calculation
    executeHammingDistanceAlgorithm();
}

// NEW: Execute Hamming Distance Algorithm with Animation
function executeHammingDistanceAlgorithm() {
    const inputContainer = document.getElementById('hammingInputArray');
    const binaryContainer = document.getElementById('hammingBinaryArray');
    const explanation = document.getElementById('hammingExplanation');
    const stepsContainer = document.getElementById('hammingSteps');
    const hammingDistanceResult = document.getElementById('hammingDistanceResult');
    const continueButton = document.getElementById('continueAfterHamming');
    
    let totalDistance = 0;
    let currentBitPosition = 0;
    let currentPairIndex = 0;
    let pairsProcessed = 0;
    const totalPairs = (hammingArray.length * (hammingArray.length - 1)) / 2;
    
    function executeHammingStep() {
        if (currentBitPosition >= 32) {
            // All bit positions processed
            explanation.innerHTML = `<strong>Hamming Distance Calculation Completed!</strong> Total distance: ${totalDistance}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Total Hamming Distance = ${totalDistance} across all ${totalPairs} pairs
                </div>
            `;
            
            hammingDistanceResult.textContent = totalDistance;
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterHamming();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterHamming);
            
            return;
        }
        
        if (currentPairIndex === 0) {
            // Start new bit position
            explanation.innerHTML = `Processing bit position ${currentBitPosition}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Bit Position ${currentBitPosition}:</strong> Counting ones and zeros
                </div>
            `;
        }
        
        // Count ones at current bit position
        let countOnes = 0;
        for (let i = 0; i < hammingArray.length; i++) {
            if ((hammingArray[i] >> currentBitPosition) & 1) {
                countOnes++;
            }
        }
        
        const countZeros = hammingArray.length - countOnes;
        const bitContribution = countOnes * countZeros;
        
        explanation.innerHTML = `Bit ${currentBitPosition}: ${countOnes} ones  ${countZeros} zeros = ${bitContribution}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${bitContribution > 0 ? 'active' : ''}">
                <strong>Bit ${currentBitPosition}:</strong> ${countOnes} ones, ${countZeros} zeros  Contribution: ${bitContribution}
            </div>
        `;
        
        totalDistance += bitContribution;
        
        // Highlight bits in binary representation
        setTimeout(() => {
            const binaryElements = binaryContainer.querySelectorAll('.array-element');
            binaryElements.forEach((element, index) => {
                const binaryValue = hammingArray[index].toString(2).padStart(8, '0');
                const bitValue = binaryValue[binaryValue.length - 1 - currentBitPosition];
                const valueDiv = element.querySelector('.element-value');
                
                if (bitValue === '1') {
                    valueDiv.classList.add('info-color');
                } else {
                    valueDiv.classList.add('warning-color');
                }
            });
            
            setTimeout(() => {
                // Remove highlights
                const allValueDivs = binaryContainer.querySelectorAll('.element-value');
                allValueDivs.forEach(div => {
                    div.classList.remove('info-color', 'warning-color');
                });
                
                currentBitPosition++;
                executeHammingStep();
            }, 1500);
        }, 500);
        
        // Update result display
        hammingDistanceResult.textContent = totalDistance;
    }
    
    // Start execution
    executeHammingStep();
}

// NEW: Return to Original after Hamming Operations
function returnToOriginalAfterHamming() {
    // Reset to original array
    myArray = [...originalArrayForHamming];
    originalArrayForHamming = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isHammingOperationRunning = false;
    currentHammingOperation = null;
    
    // Clear all Hamming-related data
    hammingArray = [];
    
    // Reset input groups
    hammingOperationsGroup.style.display = 'none';
    hammingArraySize.value = '';
    hammingArrayInputs.innerHTML = '';
    performHammingOperationBtn.style.display = 'none';
    
    logOperation('Hamming operation completed - returned to original array', 'info');
    showNotification('Returned to original array after Hamming operation', 'success');
}
// NEW: Shortest Superstring Handler
function handleShortestSuperstring() {
    const count = parseInt(superstringCount.value);
    
    if (isNaN(count) || count < 2 || count > 10) {
        showNotification('Please enter a valid number between 2 and 10', 'danger');
        superstringCount.focus();
        return;
    }
    
    if (isSuperstringRunning) {
        showNotification('A superstring operation is already in progress', 'warning');
        return;
    }
    
    // Reset strings array
    superstringStrings = [];
    
    // Create input fields for strings
    superstringInputs.innerHTML = '<label class="form-label">Enter Strings:</label>';
    for (let i = 0; i < count; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">String ${i + 1}</span>
            <input type="text" class="form-control superstring-input" 
                   placeholder="Enter string" data-index="${i}">
        `;
        superstringInputs.appendChild(inputGroup);
    }
    
    // Add event listeners for inputs
    const stringInputs = superstringInputs.querySelectorAll('.superstring-input');
    stringInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('superstring-input')) {
                    nextInput.focus();
                }
            }
        });
    });
    
    // Show input group
    superstringInputGroup.style.display = 'block';
    
    logOperation(`Started shortest superstring operation with ${count} strings`, 'info');
}

// NEW: Perform Superstring Handler
function handlePerformSuperstring() {
    // Collect all string inputs
    const stringInputs = document.querySelectorAll('.superstring-input');
    superstringStrings = [];
    
    for (let i = 0; i < stringInputs.length; i++) {
        const value = stringInputs[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all strings. Missing string ${i + 1}`, 'danger');
            stringInputs[i].focus();
            return;
        }
        superstringStrings.push(value);
    }
    
    // Store original array
    originalArrayForSuperstring = [...myArray];
    
    // Hide input group
    superstringInputGroup.style.display = 'none';
    
    // Start superstring visualization
    showSuperstringVisualization();
}

// NEW: Cancel Superstring Handler
function handleCancelSuperstring() {
    superstringInputGroup.style.display = 'none';
    superstringCount.value = '';
    superstringInputs.innerHTML = '';
    superstringStrings = [];
    
    logOperation('Cancelled shortest superstring operation', 'info');
    showNotification('Superstring operation cancelled', 'info');
}

// NEW: Find Overlap Function
function findOverlap(a, b) {
    const maxOverlap = Math.min(a.length, b.length);
    for (let i = maxOverlap; i > 0; i--) {
        if (a.endsWith(b.substring(0, i))) {
            return i;
        }
    }
    return 0;
}

// NEW: Greedy Superstring Algorithm
function greedySuperstring(strings) {
    let currentStrings = [...strings];
    const steps = [];
    
    while (currentStrings.length > 1) {
        let maxOverlap = -1;
        let bestI = -1, bestJ = -1;
        let bestMerge = "";
        
        // Find the pair with maximum overlap
        for (let i = 0; i < currentStrings.length; i++) {
            for (let j = 0; j < currentStrings.length; j++) {
                if (i !== j) {
                    const overlap = findOverlap(currentStrings[i], currentStrings[j]);
                    if (overlap > maxOverlap) {
                        maxOverlap = overlap;
                        bestI = i;
                        bestJ = j;
                        bestMerge = currentStrings[i] + currentStrings[j].substring(overlap);
                    }
                }
            }
        }
        
        if (bestI !== -1 && bestJ !== -1) {
            // Record the step
            steps.push({
                strings: [...currentStrings],
                mergedI: bestI,
                mergedJ: bestJ,
                overlap: maxOverlap,
                mergedString: bestMerge,
                remainingStrings: currentStrings.length - 2
            });
            
            // Merge the best pair
            const newStrings = [bestMerge];
            for (let k = 0; k < currentStrings.length; k++) {
                if (k !== bestI && k !== bestJ) {
                    newStrings.push(currentStrings[k]);
                }
            }
            currentStrings = newStrings;
        } else {
            break;
        }
    }
    
    return {
        superstring: currentStrings[0] || "",
        steps: steps
    };
}

// NEW: Show Superstring Visualization
function showSuperstringVisualization() {
    isSuperstringRunning = true;
    
    const container = document.createElement('div');
    container.className = 'superstring-container';
    container.innerHTML = `
        <h4 class="text-center mb-4">Shortest Superstring (Greedy Algorithm)</h4>
        
        <div class="superstring-visualization">
            <h5>Original Strings</h5>
            <div id="originalStringsDisplay" class="mb-3"></div>
        </div>
        
        <div class="superstring-visualization">
            <h5>Greedy Algorithm Steps</h5>
            <div id="superstringSteps" class="mb-3"></div>
        </div>
        
        <div class="superstring-final" id="finalResult" style="display: none;">
            <h5>Final Result</h5>
            <div id="superstringResult"></div>
        </div>
        
        <div class="algorithm-explanation mt-3">
            <h6>Shortest Superstring Algorithm</h6>
            <p>The Shortest Superstring Problem is NP-hard. This visualization shows a greedy algorithm that:</p>
            <ol>
                <li>Repeatedly finds the pair of strings with maximum overlap</li>
                <li>Merges them by overlapping the common part</li>
                <li>Continues until only one string remains</li>
            </ol>
            <div class="code-snippet">
                function greedySuperstring(strings) {<br>
                &nbsp;&nbsp;while (strings.length > 1) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;// Find pair with max overlap<br>
                &nbsp;&nbsp;&nbsp;&nbsp;let maxOverlap = -1, bestI, bestJ;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;for (i in strings) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (j in strings) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (i != j) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;overlap = findOverlap(strings[i], strings[j])<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (overlap > maxOverlap) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxOverlap = overlap<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bestI = i, bestJ = j<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                &nbsp;&nbsp;&nbsp;&nbsp;// Merge and repeat<br>
                &nbsp;&nbsp;&nbsp;&nbsp;merged = strings[bestI] + strings[bestJ].substring(maxOverlap)<br>
                &nbsp;&nbsp;&nbsp;&nbsp;strings = [merged] + other strings<br>
                &nbsp;&nbsp;}<br>
                &nbsp;&nbsp;return strings[0]<br>
                }
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSuperstring" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(container);
    
    // Display original strings
    const originalStringsDisplay = document.getElementById('originalStringsDisplay');
    superstringStrings.forEach((str, index) => {
        const strElement = document.createElement('div');
        strElement.className = 'mb-2';
        strElement.innerHTML = `<span class="string-highlight">String ${index + 1}:</span> "${str}" (Length: ${str.length})`;
        originalStringsDisplay.appendChild(strElement);
    });
    
    // Start the superstring algorithm animation
    performSuperstringAnimation();
}

// NEW: Perform Superstring Animation
function performSuperstringAnimation() {
    const stepsContainer = document.getElementById('superstringSteps');
    const finalResult = document.getElementById('finalResult');
    const superstringResult = document.getElementById('superstringResult');
    const continueButton = document.getElementById('continueAfterSuperstring');
    
    const result = greedySuperstring(superstringStrings);
    const steps = result.steps;
    let currentStep = 0;
    
    function performStep() {
        if (currentStep >= steps.length) {
            // Algorithm completed
            finalResult.style.display = 'block';
            superstringResult.innerHTML = `
                <p><strong>Shortest Superstring:</strong> "${result.superstring}"</p>
                <p><strong>Length:</strong> ${result.superstring.length}</p>
                <p><strong>Total Merges:</strong> ${steps.length}</p>
                <p><strong>Compression Ratio:</strong> ${((1 - result.superstring.length / superstringStrings.reduce((sum, str) => sum + str.length, 0)) * 100).toFixed(2)}% reduction</p>
            `;
            
            // Highlight the final result
            setTimeout(() => {
                const finalElement = document.createElement('div');
                finalElement.className = 'superstring-step active';
                finalElement.innerHTML = `
                    <h6> Algorithm Complete!</h6>
                    <p>The greedy algorithm found a superstring of length <strong>${result.superstring.length}</strong></p>
                    <p><strong>Final Superstring:</strong> "${result.superstring}"</p>
                `;
                stepsContainer.appendChild(finalElement);
                
                // Scroll to final result
                finalElement.scrollIntoView({ behavior: 'smooth' });
            }, 1000);
            
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterSuperstring();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSuperstring);
            
            return;
        }
        
        const step = steps[currentStep];
        
        // Create step visualization
        const stepElement = document.createElement('div');
        stepElement.className = 'superstring-step';
        stepElement.innerHTML = `
            <h6>Step ${currentStep + 1}: Merge Strings</h6>
            <p><strong>Current Strings:</strong> [${step.strings.map(s => `"${s}"`).join(', ')}]</p>
            <p><strong>Selected Pair:</strong> "${step.strings[step.mergedI]}" + "${step.strings[step.mergedJ]}"</p>
            <p><strong>Overlap:</strong> <span class="superstring-overlap">${step.overlap} characters</span></p>
            <p><strong>Merged Result:</strong> <span class="superstring-merged">"${step.mergedString}"</span></p>
            <p><strong>Remaining Strings:</strong> ${step.remainingStrings + 1}</p>
        `;
        
        stepsContainer.appendChild(stepElement);
        
        // Add visual highlight animation
        setTimeout(() => {
            stepElement.classList.add('active');
            stepElement.scrollIntoView({ behavior: 'smooth' });
            
            // Show overlap visualization
            const overlapViz = document.createElement('div');
            overlapViz.className = 'code-snippet mt-2';
            
            const str1 = step.strings[step.mergedI];
            const str2 = step.strings[step.mergedJ];
            const overlap = step.overlap;
            
            let visualization = '';
            if (overlap > 0) {
                visualization = `
                    "${str1}"<br>
                    ${' '.repeat(str1.length - overlap)}"${str2}"<br>
                    ${' '.repeat(str1.length - overlap)}${'^'.repeat(overlap)} Overlap: ${overlap} chars
                `;
            } else {
                visualization = `
                    "${str1}" + "${str2}"<br>
                    No overlap - concatenating
                `;
            }
            
            overlapViz.innerHTML = visualization;
            stepElement.appendChild(overlapViz);
            
            currentStep++;
            setTimeout(performStep, 3000); // Wait 3 seconds before next step
        }, 500);
    }
    
    // Start the animation
    performStep();
}

// NEW: Return to Original after Superstring
function returnToOriginalAfterSuperstring() {
    // Reset to original array
    myArray = [...originalArrayForSuperstring];
    originalArrayForSuperstring = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isSuperstringRunning = false;
    
    // Clear all superstring-related data
    superstringStrings = [];
    superstringCount.value = '';
    superstringInputs.innerHTML = '';
    superstringInputGroup.style.display = 'none';
    
    logOperation('Shortest superstring operation completed - returned to original array', 'info');
    showNotification('Returned to original array after superstring operation', 'success');
}
// NEW: Gray Code Button Handler
function handleGrayCodeButton() {
    if (isGrayCodeRunning) {
        showNotification('Gray code generation is already in progress', 'warning');
        return;
    }
    
    // Show input group
    grayCodeInputGroup.style.display = 'flex';
    grayCodeBits.focus();
    
    logOperation('Started Gray code sequence generation', 'info');
}

// NEW: Generate Gray Code Handler
function handleGenerateGrayCode() {
    const bits = parseInt(grayCodeBits.value);
    
    if (isNaN(bits) || bits < 1 || bits > 5) {
        showNotification('Please enter a valid number of bits between 1 and 5', 'danger');
        grayCodeBits.focus();
        return;
    }
    
    // Store original array
    originalArrayForGrayCode = [...myArray];
    
    // Hide input group
    grayCodeInputGroup.style.display = 'none';
    
    // Start Gray code visualization
    showGrayCodeVisualization(bits);
}

// NEW: Cancel Gray Code Handler
function handleCancelGrayCode() {
    grayCodeInputGroup.style.display = 'none';
    grayCodeBits.value = '3';
    logOperation('Cancelled Gray code generation', 'info');
    showNotification('Gray code generation cancelled', 'info');
}

// NEW: Show Gray Code Visualization
function showGrayCodeVisualization(bits) {
    isGrayCodeRunning = true;
    
    const grayCodeContainer = document.createElement('div');
    grayCodeContainer.className = 'dual-operation-container';
    grayCodeContainer.innerHTML = `
        <h5 class="text-center mb-3">Gray Code Generator (${bits}-bit)</h5>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Gray Code Property:</strong> Successive numbers differ by exactly one bit</p>
            <p class="mb-0" id="grayCodeExplanation">Generating ${bits}-bit Gray code sequence...</p>
        </div>
        
        <div class="gray-code-steps-container" id="grayCodeSteps">
            <!-- Steps will be inserted here -->
        </div>
        
        <div class="gray-code-sequence" id="grayCodeSequence">
            <!-- Gray code sequence will be inserted here -->
        </div>
        
        <div class="table-container mt-3" id="grayCodeTableContainer">
            <!-- Gray code table will be inserted here -->
        </div>
        
        <div class="gray-code-verification mt-3" id="grayCodeVerification">
            <!-- Verification results will be inserted here -->
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterGrayCode" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(grayCodeContainer);
    
    // Generate and display Gray code
    generateAndDisplayGrayCode(bits);
}

// NEW: Generate and Display Gray Code
function generateAndDisplayGrayCode(bits) {
    const explanation = document.getElementById('grayCodeExplanation');
    const stepsContainer = document.getElementById('grayCodeSteps');
    const sequenceContainer = document.getElementById('grayCodeSequence');
    const tableContainer = document.getElementById('grayCodeTableContainer');
    const verificationContainer = document.getElementById('grayCodeVerification');
    const continueButton = document.getElementById('continueAfterGrayCode');
    
    // Calculate total numbers
    const totalNumbers = Math.pow(2, bits);
    
    // Generate Gray code using binary reflection method
    explanation.innerHTML = `Step 1: Generating ${bits}-bit Gray code using binary reflection method...`;
    
    let grayCodes = ['0', '1']; // Start with 1-bit Gray code
    
    // Show initial step
    stepsContainer.innerHTML = `
        <div class="gray-code-step active">
            <strong>Initial 1-bit Gray Code:</strong> [${grayCodes.join(', ')}]
        </div>
    `;
    
    let currentIteration = 1;
    
    function generateNextGrayCode() {
        if (currentIteration >= bits) {
            // All bits generated
            displayFinalGrayCode(grayCodes, bits);
            return;
        }
        
        currentIteration++;
        explanation.innerHTML = `Step ${currentIteration}: Reflecting and prefixing to generate ${currentIteration}-bit Gray code...`;
        
        // Reflect and prefix method
        const reflected = [...grayCodes].reverse();
        const prefixed0 = grayCodes.map(code => '0' + code);
        const prefixed1 = reflected.map(code => '1' + code);
        
        grayCodes = [...prefixed0, ...prefixed1];
        
        stepsContainer.innerHTML += `
            <div class="gray-code-step active">
                <strong>Step ${currentIteration} (${currentIteration}-bit):</strong> 
                Prefix 0 to original: [${prefixed0.join(', ')}]<br>
                Prefix 1 to reflected: [${prefixed1.join(', ')}]<br>
                <strong>New ${currentIteration}-bit Gray Code:</strong> [${grayCodes.join(', ')}]
            </div>
        `;
        
        // Scroll to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Show intermediate sequence
        displayGrayCodeSequence(grayCodes);
        
        setTimeout(generateNextGrayCode, 2000);
    }
    
    // Start generation
    setTimeout(() => {
        displayGrayCodeSequence(grayCodes);
        setTimeout(generateNextGrayCode, 1500);
    }, 1000);
    
    // Function to display Gray code sequence
    function displayGrayCodeSequence(codes) {
        sequenceContainer.innerHTML = '';
        codes.forEach((code, index) => {
            const codeItem = document.createElement('div');
            codeItem.className = 'gray-code-item';
            codeItem.textContent = code;
            codeItem.title = `Decimal: ${index}, Gray: ${code}`;
            sequenceContainer.appendChild(codeItem);
        });
    }
    
    // Function to display final Gray code
    function displayFinalGrayCode(codes, bits) {
        explanation.innerHTML = `<strong>${bits}-bit Gray Code Generation Complete!</strong>`;
        
        // Create Gray code table
        const tableHTML = createGrayCodeTable(codes, bits);
        tableContainer.innerHTML = tableHTML;
        
        // Verify Gray code property
        verifyGrayCodeProperty(codes, bits);
        
        // Show continue button
        continueButton.style.display = 'block';
        
        // Auto-return after 20 seconds
        clearTimeout(grayCodeReturnTimer);
        grayCodeReturnTimer = setTimeout(() => {
            returnToOriginalAfterGrayCode();
        }, 20000);
        
        continueButton.addEventListener('click', () => {
            clearTimeout(grayCodeReturnTimer);
            returnToOriginalAfterGrayCode();
        });
    }
}

// NEW: Create Gray Code Table
function createGrayCodeTable(codes, bits) {
    const totalNumbers = codes.length;
    let tableHTML = `
        <h6 class="text-center mb-3">${bits}-bit Gray Code Table</h6>
        <table class="gray-code-table">
            <thead>
                <tr>
                    <th>Decimal</th>
                    <th>Binary (${bits}-bit)</th>
                    <th>Gray Code</th>
                    <th>Gray Binary</th>
                </tr>
            </thead>
            <tbody>
    `;
    
    for (let i = 0; i < totalNumbers; i++) {
        const binary = i.toString(2).padStart(bits, '0');
        const grayCode = codes[i];
        const grayDecimal = parseInt(grayCode, 2);
        
        tableHTML += `
            <tr>
                <td>${i}</td>
                <td>${binary}</td>
                <td>${grayDecimal}</td>
                <td class="gray-code-cell">${grayCode}</td>
            </tr>
        `;
    }
    
    tableHTML += `
            </tbody>
        </table>
    `;
    
    return tableHTML;
}

// NEW: Verify Gray Code Property
function verifyGrayCodeProperty(codes, bits) {
    const verificationContainer = document.getElementById('grayCodeVerification');
    let allValid = true;
    let verificationHTML = `
        <h6>Verifying Gray Code Properties</h6>
        <div class="mt-2">
            <strong>Gray Code Sequence:</strong> [${codes.map(code => `'${code}'`).join(', ')}]
        </div>
        <div class="mt-2">
            <strong>Verifying one-bit difference between successive codes:</strong>
    `;
    
    for (let i = 0; i < codes.length - 1; i++) {
        const code1 = codes[i];
        const code2 = codes[i + 1];
        const bitDifference = countBitDifference(code1, code2);
        const isValid = bitDifference === 1;
        
        if (!isValid) allValid = false;
        
        verificationHTML += `
            <div class="gray-code-step ${isValid ? 'active' : ''}">
                Step ${i}${i+1}: ${code1}  ${code2}, 
                <span class="bit-change">Bits changed: ${bitDifference}</span>
                ${isValid ? '<span class="checkmark"></span>' : '<span class="text-danger"></span>'}
            </div>
        `;
    }
    
    verificationHTML += `
        </div>
        <div class="mt-2 ${allValid ? 'text-success' : 'text-danger'}">
            <strong>Gray code property verified:</strong> ${allValid ? 'True ' : 'False '}
        </div>
    `;
    
    verificationContainer.innerHTML = verificationHTML;
    verificationContainer.className = `gray-code-verification ${allValid ? 'success' : ''}`;
}

// Helper function: Count bit differences
function countBitDifference(str1, str2) {
    let difference = 0;
    for (let i = 0; i < str1.length; i++) {
        if (str1[i] !== str2[i]) {
            difference++;
        }
    }
    return difference;
}

// NEW: Return to Original after Gray Code
function returnToOriginalAfterGrayCode() {
    // Reset to original array
    myArray = [...originalArrayForGrayCode];
    originalArrayForGrayCode = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isGrayCodeRunning = false;
    grayCodeBits.value = '3';
    
    logOperation('Gray code generation completed - returned to original array', 'info');
    showNotification('Returned to original array after Gray code demonstration', 'success');
}
// NEW: Smallest Divisor Handler
function handleSmallestDivisor() {
    const threshold = parseFloat(thresholdValue.value);
    
    if (isNaN(threshold) || threshold < 1) {
        showNotification('Please enter a valid threshold value  1', 'danger');
        thresholdValue.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains only positive integers
    let allPositiveIntegers = true;
    for (let i = 0; i < myArray.length; i++) {
        const num = parseInt(myArray[i]);
        if (isNaN(num) || num <= 0 || !Number.isInteger(num)) {
            allPositiveIntegers = false;
            break;
        }
    }
    
    if (!allPositiveIntegers) {
        showNotification('Smallest divisor algorithm requires all array elements to be positive integers', 'danger');
        return;
    }
    
    if (isSmallestDivisorRunning) {
        showNotification('Smallest divisor operation is already in progress', 'warning');
        return;
    }
    
    isSmallestDivisorRunning = true;
    
    // Store original array
    originalArrayForSmallestDivisor = [...myArray];
    
    // Perform smallest divisor visualization
    performSmallestDivisorVisualization(threshold);
}
// NEW: Perform Smallest Divisor Visualization
function performSmallestDivisorVisualization(threshold) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find Smallest Divisor Given Threshold ( ${threshold})</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalDivisorArray"></div>
        </div>
        
        <div class="algorithm-explanation mt-3">
            <p class="mb-2"><strong>Problem:</strong> Find smallest divisor d such that  ceil(arr[i] / d)  ${threshold}</p>
            <p class="mb-0" id="divisorExplanation">Initializing binary search...</p>
        </div>
        
        <div class="divisor-binary-search-visualization" id="binarySearchVisualization">
            <!-- Binary search visualization will be added here -->
        </div>
        
        <div class="algorithm-steps mt-3" id="divisorStepsContainer">
            <h6 class="text-center">Binary Search Steps</h6>
            <div class="steps-container" id="divisorSteps"></div>
        </div>
        
        <div class="divisor-calculation" id="divisorCalculation" style="display: none;">
            <h6 class="text-center">Current Calculation</h6>
            <div id="currentCalculationSteps"></div>
        </div>
        
        <div class="stats-card mt-3" id="currentDivisorStats">
            <div>Current Divisor</div>
            <div class="stats-value" id="currentDivisorValue">-</div>
        </div>
        
        <div class="stats-card mt-2" id="currentSumStats">
            <div>Current Sum</div>
            <div class="stats-value" id="currentSumValue">-</div>
        </div>
        
        <div class="stats-card mt-2" id="resultStats" style="display: none;">
            <div>Smallest Divisor Found</div>
            <div class="stats-value" id="resultDivisorValue">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterDivisor" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSmallestDivisor, 'originalDivisorArray');
    
    executeSmallestDivisorAlgorithm(threshold);
}
// NEW: Execute Smallest Divisor Algorithm with Animation
function executeSmallestDivisorAlgorithm(threshold) {
    const arrayContainer = document.getElementById('originalDivisorArray');
    const explanation = document.getElementById('divisorExplanation');
    const stepsContainer = document.getElementById('divisorSteps');
    const binarySearchViz = document.getElementById('binarySearchVisualization');
    const divisorCalc = document.getElementById('divisorCalculation');
    const currentCalcSteps = document.getElementById('currentCalculationSteps');
    const currentDivisorValue = document.getElementById('currentDivisorValue');
    const currentSumValue = document.getElementById('currentSumValue');
    const resultStats = document.getElementById('resultStats');
    const resultDivisorValue = document.getElementById('resultDivisorValue');
    const continueButton = document.getElementById('continueAfterDivisor');
    
    const arr = originalArrayForSmallestDivisor.map(val => parseInt(val));
    let left = 1;
    let right = Math.max(...arr);
    let stepCount = 0;
    
    function updateBinarySearchVisualization(l, m, r) {
        binarySearchViz.innerHTML = `
            <div class="divisor-range">
                <div class="divisor-range-item divisor-range-left">
                    <div class="divisor-range-value">${l}</div>
                    <div class="divisor-range-label">Left</div>
                </div>
                <div class="divisor-arrow">
                    <i class="fas fa-arrow-right"></i>
                </div>
                <div class="divisor-range-item divisor-range-mid">
                    <div class="divisor-range-value">${m}</div>
                    <div class="divisor-range-label">Mid (Testing)</div>
                </div>
                <div class="divisor-arrow">
                    <i class="fas fa-arrow-right"></i>
                </div>
                <div class="divisor-range-item divisor-range-right">
                    <div class="divisor-range-value">${r}</div>
                    <div class="divisor-range-label">Right</div>
                </div>
            </div>
        `;
    }
    
    function calculateDivisionSum(divisor) {
        let sum = 0;
        const steps = [];
        
        for (let i = 0; i < arr.length; i++) {
            const quotient = Math.ceil(arr[i] / divisor);
            sum += quotient;
            steps.push(`ceil(${arr[i]} / ${divisor}) = ${quotient}`);
        }
        
        return { sum, steps };
    }
    
    function performBinarySearchStep(l, r) {
        stepCount++;
        
        if (l >= r) {
            // Binary search completed
            explanation.innerHTML = `<strong>Binary Search Completed!</strong> Smallest divisor found.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${stepCount}:</strong> Left (${l})  Right (${r}) - Search space reduced to single value
                </div>
            `;
            
            // Final calculation
            const finalDivisor = l;
            const { sum: finalSum, steps: finalSteps } = calculateDivisionSum(finalDivisor);
            
            divisorCalc.style.display = 'block';
            currentCalcSteps.innerHTML = '';
            finalSteps.forEach((step, idx) => {
                const stepDiv = document.createElement('div');
                stepDiv.className = 'divisor-calculation-step active';
                stepDiv.textContent = step;
                currentCalcSteps.appendChild(stepDiv);
            });
            
            currentDivisorValue.textContent = finalDivisor;
            currentSumValue.textContent = `${finalSum} ( ${threshold})`;
            
            // Show final result
            resultStats.style.display = 'block';
            resultDivisorValue.textContent = finalDivisor;
            
            // Highlight final divisor
            explanation.innerHTML = `<strong>Success!</strong> Smallest divisor = ${finalDivisor} with sum = ${finalSum}  ${threshold}`;
            
            // Show all array elements with final divisor calculation
            const elements = arrayContainer.querySelectorAll('.array-element');
            elements.forEach((el, index) => {
                setTimeout(() => {
                    const valueDiv = el.querySelector('.element-value');
                    valueDiv.classList.add('divisor-final');
                    
                    // Update element display to show calculation
                    const originalValue = arr[index];
                    const quotient = Math.ceil(originalValue / finalDivisor);
                    const displayText = `${originalValue}  ${quotient}`;
                    
                    const calculationSpan = document.createElement('span');
                    calculationSpan.className = 'd-block small';
                    calculationSpan.textContent = `ceil(${originalValue}/${finalDivisor})=${quotient}`;
                    
                    valueDiv.innerHTML = originalValue;
                    valueDiv.appendChild(calculationSpan);
                }, index * 200);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterDivisor();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterDivisor);
            
            logOperation(`Smallest divisor found: ${finalDivisor} (sum = ${finalSum}  ${threshold})`, 'success');
            
            return finalDivisor;
        }
        
        const mid = Math.floor((l + r) / 2);
        
        explanation.innerHTML = `Step ${stepCount}: Binary search - Testing divisor = ${mid} (range: ${l} to ${r})`;
        
        // Update binary search visualization
        updateBinarySearchVisualization(l, mid, r);
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${stepCount}:</strong> Testing divisor = ${mid} (left=${l}, right=${r})
            </div>
        `;
        
        // Show calculation for current divisor
        divisorCalc.style.display = 'block';
        currentCalcSteps.innerHTML = '';
        
        currentDivisorValue.textContent = mid;
        currentSumValue.textContent = 'Calculating...';
        
        // Calculate division sum with animation
        let currentSum = 0;
        let calculationSteps = [];
        
        function calculateStepByStep(index) {
            if (index >= arr.length) {
                // Calculation complete
                const sumResult = calculateDivisionSum(mid);
                currentSum = sumResult.sum;
                
                currentSumValue.textContent = `${currentSum} ${currentSum > threshold ? '>' : ''} ${threshold}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step ${currentSum > threshold ? 'active' : ''}">
                        <strong>Calculation:</strong> Sum = ${currentSum} ${currentSum > threshold ? '>' : ''} ${threshold}
                    </div>
                `;
                
                // Determine next binary search step
                if (currentSum > threshold) {
                    explanation.innerHTML = `Step ${stepCount}: Sum (${currentSum}) > threshold (${threshold}) - Need larger divisor`;
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Decision:</strong> Sum > threshold  increase left to ${mid + 1}
                        </div>
                    `;
                    
                    // Highlight all elements as "too large"
                    const elements = arrayContainer.querySelectorAll('.array-element');
                    elements.forEach(el => {
                        el.querySelector('.element-value').classList.add('divisor-too-large');
                    });
                    
                    setTimeout(() => {
                        elements.forEach(el => {
                            el.querySelector('.element-value').classList.remove('divisor-too-large');
                        });
                        performBinarySearchStep(mid + 1, r);
                    }, 2000);
                    
                } else {
                    explanation.innerHTML = `Step ${stepCount}: Sum (${currentSum})  threshold (${threshold}) - Try smaller divisor`;
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Decision:</strong> Sum  threshold  decrease right to ${mid}
                        </div>
                    `;
                    
                    // Highlight all elements as "good/too small"
                    const elements = arrayContainer.querySelectorAll('.array-element');
                    elements.forEach(el => {
                        el.querySelector('.element-value').classList.add('divisor-too-small');
                    });
                    
                    setTimeout(() => {
                        elements.forEach(el => {
                            el.querySelector('.element-value').classList.remove('divisor-too-small');
                        });
                        performBinarySearchStep(l, mid);
                    }, 2000);
                }
                
                return;
            }
            
            // Show calculation for current element
            const element = arr[index];
            const quotient = Math.ceil(element / mid);
            currentSum += quotient;
            
            const stepDiv = document.createElement('div');
            stepDiv.className = 'divisor-calculation-step active';
            stepDiv.textContent = `ceil(${element} / ${mid}) = ${quotient}`;
            currentCalcSteps.appendChild(stepDiv);
            
            // Highlight current element being calculated
            const elements = arrayContainer.querySelectorAll('.array-element');
            const currentElement = elements[index].querySelector('.element-value');
            currentElement.classList.add('divisor-calculated');
            
            // Update display temporarily to show calculation
            const originalText = currentElement.textContent;
            currentElement.innerHTML = `${element}<br><small>${mid}=${quotient}</small>`;
            
            setTimeout(() => {
                currentElement.classList.remove('divisor-calculated');
                currentElement.innerHTML = originalText;
                
                // Move to next element
                calculateStepByStep(index + 1);
            }, 800);
        }
        
        // Start step-by-step calculation
        setTimeout(() => calculateStepByStep(0), 1000);
    }
    
    // Initialize
    stepsContainer.innerHTML = `
        <div class="algorithm-step active">
            <strong>Initialization:</strong> Array = [${arr.join(', ')}], Threshold = ${threshold}
        </div>
        <div class="algorithm-step">
            <strong>Search Range:</strong> Left = 1, Right = ${right} (max array value)
        </div>
    `;
    
    // Start binary search
    performBinarySearchStep(left, right);
}
// NEW: Return to Original after Smallest Divisor Operation
function returnToOriginalAfterDivisor() {
    // Reset to original array
    myArray = [...originalArrayForSmallestDivisor];
    originalArrayForSmallestDivisor = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isSmallestDivisorRunning = false;
    
    // Clear input
    thresholdValue.value = '';
    
    logOperation('Smallest divisor operation completed - returned to original array', 'info');
    showNotification('Returned to original array after smallest divisor operation', 'success');
}
// NEW: H-Index Handler
function handleHIndex() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains valid numbers (citation counts)
    let allValidNumbers = true;
    let hasNegative = false;
    
    for (let i = 0; i < myArray.length; i++) {
        const num = parseFloat(myArray[i]);
        if (isNaN(num)) {
            allValidNumbers = false;
            break;
        }
        if (num < 0) {
            hasNegative = true;
        }
    }
    
    if (!allValidNumbers) {
        showNotification('H-Index requires all array elements to be valid numbers (citation counts)', 'danger');
        return;
    }
    
    if (hasNegative) {
        showNotification('Citation counts should be non-negative. Negative values will be treated as 0.', 'warning');
    }
    
    if (isHIndexRunning) {
        showNotification('H-Index calculation is already in progress', 'warning');
        return;
    }
    
    isHIndexRunning = true;
    hIndexBtn.disabled = true;
    
    // Store original array
    originalArrayForHIndex = [...myArray];
    
    // Show H-Index visualization
    showHIndexVisualization();
}
// NEW: Show H-Index Visualization
function showHIndexVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <div class="h-index-header">
            <h5 class="text-center mb-2">H-Index Calculator - Research Impact Analysis</h5>
            <p class="mb-0">Measures research impact based on citation counts</p>
        </div>
        
        <div class="array-group">
            <div class="array-label">Original Citations Array</div>
            <div class="original-array-container" id="originalHIndexArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-sort-amount-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Sorted Citations (Descending)</div>
            <div class="transformed-array-container" id="sortedHIndexArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>H-Index Calculation:</strong> A researcher has index h if h of their papers have at least h citations each</p>
            <p class="mb-0" id="hIndexExplanation">Starting H-Index calculation...</p>
        </div>
        
        <div class="h-index-results mt-3">
            <h6 class="text-center">H-Index Calculation Steps</h6>
            <div id="hIndexSteps" class="mt-2"></div>
        </div>
        
        <div class="h-index-table-container" id="hIndexTableContainer" style="display: none;">
            <table class="h-index-table">
                <thead>
                    <tr>
                        <th>Paper #</th>
                        <th>Citations</th>
                        <th>Paper #  Citations?</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody id="hIndexTableBody">
                </tbody>
            </table>
        </div>
        
        <div class="h-index-summary" id="hIndexSummary" style="display: none;">
            <h6 class="text-center mb-3">Research Impact Summary</h6>
            <div id="hIndexResults"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterHIndex" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForHIndex, 'originalHIndexArray');
    renderArrayInContainer([...originalArrayForHIndex], 'sortedHIndexArray');
    
    performHIndexCalculation();
}
// NEW: Perform H-Index Calculation with Animation
function performHIndexCalculation() {
    const originalContainer = document.getElementById('originalHIndexArray');
    const sortedContainer = document.getElementById('sortedHIndexArray');
    const explanation = document.getElementById('hIndexExplanation');
    const stepsContainer = document.getElementById('hIndexSteps');
    const tableContainer = document.getElementById('hIndexTableContainer');
    const tableBody = document.getElementById('hIndexTableBody');
    const resultsContainer = document.getElementById('hIndexResults');
    const summaryContainer = document.getElementById('hIndexSummary');
    const continueButton = document.getElementById('continueAfterHIndex');
    
    // Convert to numbers
    const citations = originalArrayForHIndex.map(val => {
        const num = parseFloat(val);
        return num < 0 ? 0 : num; // Treat negative as 0
    });
    
    const sortedCitations = [...citations].sort((a, b) => b - a); // Descending order
    let hIndex = 0;
    let currentStep = 0;
    
    function performHIndexStep() {
        switch (currentStep) {
            case 0:
                // Step 1: Show original array
                explanation.innerHTML = 'Step 1: Original citation counts';
                stepsContainer.innerHTML = `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Original citation counts: [${citations.join(', ')}]
                    </div>
                `;
                
                // Highlight all original elements
                const originalElements = originalContainer.querySelectorAll('.array-element');
                originalElements.forEach((el, index) => {
                    setTimeout(() => {
                        el.querySelector('.element-value').classList.add('h-index-paper');
                    }, index * 200);
                });
                break;
                
            case 1:
                // Step 2: Sort in descending order
                explanation.innerHTML = 'Step 2: Sort citations in descending order';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Sorting citations: ${citations.join(', ')}  ${sortedCitations.join(', ')}
                    </div>
                `;
                
                // Update sorted array display
                renderArrayInContainer(sortedCitations, 'sortedHIndexArray');
                
                // Highlight sorted elements
                setTimeout(() => {
                    const sortedElements = sortedContainer.querySelectorAll('.array-element');
                    sortedElements.forEach((el, index) => {
                        setTimeout(() => {
                            el.querySelector('.element-value').classList.add('h-index-paper');
                        }, index * 200);
                    });
                }, 500);
                break;
                
            case 2:
                // Step 3: Show table and start comparison
                explanation.innerHTML = 'Step 3: Compare paper number vs citation count';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> For H-Index, we need h papers with at least h citations each
                    </div>
                `;
                
                tableContainer.style.display = 'block';
                break;
                
            default:
                const paperIndex = currentStep - 3;
                
                if (paperIndex < sortedCitations.length) {
                    const paperNum = paperIndex + 1;
                    const citation = sortedCitations[paperIndex];
                    const conditionMet = paperNum <= citation;
                    
                    explanation.innerHTML = `Checking Paper ${paperNum}: ${citation} citations`;
                    
                    // Highlight current paper in sorted array
                    const sortedElements = sortedContainer.querySelectorAll('.array-element');
                    const currentElement = sortedElements[paperIndex].querySelector('.element-value');
                    currentElement.classList.add('h-index-current');
                    
                    // Add row to table
                    const rowClass = conditionMet ? 'h-index-match' : 'h-index-nomatch';
                    const statusIcon = conditionMet ? ' YES' : ' NO';
                    const statusText = conditionMet ? 'Qualifies for H-Index' : 'Does not qualify';
                    
                    tableBody.innerHTML += `
                        <tr class="${rowClass}">
                            <td>${paperNum}</td>
                            <td>${citation}</td>
                            <td>${statusIcon}</td>
                            <td>${statusText}</td>
                        </tr>
                    `;
                    
                    setTimeout(() => {
                        // Update element appearance based on condition
                        if (conditionMet) {
                            currentElement.classList.remove('h-index-current');
                            currentElement.classList.add('h-index-qualified');
                            hIndex = paperNum;
                            
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step active">
                                    <strong>Paper ${paperNum}:</strong> ${citation} citations  ${paperNum}  H-Index = ${hIndex}
                                </div>
                            `;
                        } else {
                            currentElement.classList.remove('h-index-current');
                            currentElement.classList.add('h-index-disqualified');
                            
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step">
                                    <strong>Paper ${paperNum}:</strong> ${citation} citations < ${paperNum}  Stop condition met
                                </div>
                            `;
                            
                            // Show final result
                            setTimeout(() => {
                                showHIndexFinalResult();
                            }, 1500);
                            return;
                        }
                        
                        // Move to next paper
                        currentStep++;
                        setTimeout(performHIndexStep, 1500);
                    }, 1500);
                    
                    return;
                } else {
                    // All papers qualified
                    showHIndexFinalResult();
                    return;
                }
        }
        
        currentStep++;
        setTimeout(performHIndexStep, 2000);
    }
    
    function showHIndexFinalResult() {
        explanation.innerHTML = `<strong>H-Index Calculation Complete!</strong>`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Final H-Index:</strong> ${hIndex}
            </div>
        `;
        
        // Show summary
        summaryContainer.style.display = 'block';
        
        // Count papers by citation ranges
        const paperCounts = {
            high: sortedCitations.filter(c => c >= 10).length,
            medium: sortedCitations.filter(c => c >= 5 && c < 10).length,
            low: sortedCitations.filter(c => c >= 1 && c < 5).length,
            zero: sortedCitations.filter(c => c === 0).length
        };
        
        // Generate detailed summary
        let summaryHTML = `
            <p>You have published <strong>${sortedCitations.length}</strong> research papers with the following citation counts:</p>
            <ul class="mb-3">
        `;
        
        if (paperCounts.high > 0) {
            summaryHTML += `<li>${paperCounts.high} paper${paperCounts.high > 1 ? 's' : ''} with 10+ citations</li>`;
        }
        if (paperCounts.medium > 0) {
            summaryHTML += `<li>${paperCounts.medium} paper${paperCounts.medium > 1 ? 's' : ''} with 5-9 citations</li>`;
        }
        if (paperCounts.low > 0) {
            summaryHTML += `<li>${paperCounts.low} paper${paperCounts.low > 1 ? 's' : ''} with 1-4 citations</li>`;
        }
        if (paperCounts.zero > 0) {
            summaryHTML += `<li>${paperCounts.zero} paper${paperCounts.zero > 1 ? 's' : ''} with 0 citations</li>`;
        }
        
        summaryHTML += `
            </ul>
            <div class="alert alert-success mb-3">
                <h5 class="mb-2"> <strong>Your H-Index is ${hIndex}</strong></h5>
                <p class="mb-0">This means you have ${hIndex} papers that have received at least ${hIndex} citations each.</p>
            </div>
            
            <div class="alert alert-info mb-3">
                <h6 class="mb-2"> <strong>What this means for you:</strong></h6>
                <ul class="mb-0">
                    <li>${hIndex >= 5 ? 'Excellent!' : hIndex >= 3 ? 'Good!' : 'Developing!'} research impact measurement</li>
                    <li>Your work is getting ${hIndex >= 3 ? 'consistent' : 'some'} attention in your field</li>
                    <li>${hIndex >= 5 ? 'Strong foundation for academic promotions and grant applications' : 'Good foundation for building your research portfolio'}</li>
                </ul>
            </div>
            
            <div class="text-center">
                <small class="text-muted">Note: H-Index of ${hIndex} is ${hIndex >= 5 ? 'excellent' : hIndex >= 3 ? 'good' : 'a starting point'} for ${sortedCitations.length === 1 ? 'a single paper' : sortedCitations.length + ' papers'}</small>
            </div>
        `;
        
        resultsContainer.innerHTML = summaryHTML;
        
        continueButton.style.display = 'block';
        
        // Auto-return after 20 seconds
        setTimeout(() => {
            returnToOriginalAfterHIndex();
        }, 20000);
        
        continueButton.addEventListener('click', returnToOriginalAfterHIndex);
    }
    
    // Start the H-Index calculation
    performHIndexStep();
}
// NEW: Return to Original after H-Index
function returnToOriginalAfterHIndex() {
    // Reset to original array
    myArray = [...originalArrayForHIndex];
    originalArrayForHIndex = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isHIndexRunning = false;
    hIndexBtn.disabled = false;
    
    logOperation('H-Index calculation completed - returned to original array', 'info');
    showNotification('Returned to original array after H-Index calculation', 'success');
}
// NEW: Capacity To Ship Packages Handler
function handleCapacityToShip() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isCapacityCalculationRunning) {
        showNotification('A capacity calculation is already in progress', 'warning');
        return;
    }
    
    // Show input for days
    capacityInputGroup.style.display = 'block';
    capacityDaysInput.focus();
    
    logOperation('Started capacity to ship packages calculation', 'info');
}

// NEW: Confirm Capacity Calculation Handler
function handleConfirmCapacity() {
    const days = parseInt(capacityDaysInput.value);
    
    if (isNaN(days) || days < 1) {
        showNotification('Please enter a valid number of days (minimum 1)', 'danger');
        capacityDaysInput.focus();
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Capacity calculation requires all array elements to be numbers', 'danger');
        capacityDaysInput.focus();
        return;
    }
    
    if (days > myArray.length) {
        showNotification(`Days (${days}) cannot exceed number of packages (${myArray.length})`, 'warning');
        capacityDaysInput.focus();
        return;
    }
    
    capacityDays = days;
    
    // Store original array
    originalArrayForCapacity = [...myArray];
    
    // Hide input group
    capacityInputGroup.style.display = 'none';
    capacityDaysInput.value = '';
    
    // Start capacity calculation visualization
    showCapacityCalculationVisualization();
}

// NEW: Cancel Capacity Calculation Handler
function handleCancelCapacity() {
    capacityInputGroup.style.display = 'none';
    capacityDaysInput.value = '';
    
    logOperation('Cancelled capacity calculation', 'info');
    showNotification('Capacity calculation cancelled', 'info');
}

// NEW: Show Capacity Calculation Visualization
function showCapacityCalculationVisualization() {
    isCapacityCalculationRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Capacity To Ship Packages (Days: ${capacityDays})</h5>
        
        <div class="array-group">
            <div class="array-label">Package Weights</div>
            <div class="original-array-container" id="capacityArray"></div>
        </div>
        
        <div class="binary-search-range mt-3" id="binarySearchRange">
            <p class="mb-2"><strong>Binary Search Range:</strong></p>
            <p class="mb-0">Left (min capacity) = max(weights), Right (max capacity) = sum(weights)</p>
            <p class="mb-0" id="rangeValue">Calculating...</p>
        </div>
        
        <div class="algorithm-explanation mt-3">
            <p class="mb-2"><strong>Algorithm:</strong> Binary search for minimum capacity to ship all packages within ${capacityDays} days</p>
            <p class="mb-0" id="capacityExplanation">Initializing capacity calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="capacityStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="capacitySteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Minimum Capacity Required</div>
            <div class="stats-value" id="minCapacityValue">Calculating...</div>
        </div>
        
        <div id="dailyDistribution" class="mt-3" style="display: none;">
            <h6 class="text-center">Optimal Daily Distribution</h6>
            <div id="distributionContainer"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterCapacity" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array (Auto in 20s)
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForCapacity, 'capacityArray');
    
    // Start capacity calculation animation
    performCapacityCalculationAnimation();
}

// NEW: Perform Capacity Calculation Animation
function performCapacityCalculationAnimation() {
    const arrayContainer = document.getElementById('capacityArray');
    const explanation = document.getElementById('capacityExplanation');
    const stepsContainer = document.getElementById('capacitySteps');
    const minCapacityValue = document.getElementById('minCapacityValue');
    const rangeValue = document.getElementById('rangeValue');
    const continueButton = document.getElementById('continueAfterCapacity');
    const dailyDistribution = document.getElementById('dailyDistribution');
    const distributionContainer = document.getElementById('distributionContainer');
    
    const weights = originalArrayForCapacity.map(val => parseFloat(val));
    const days = capacityDays;
    
    // Initialize binary search range
    const left = Math.max(...weights);
    const right = weights.reduce((sum, weight) => sum + weight, 0);
    
    let currentLeft = left;
    let currentRight = right;
    let step = 0;
    let mid = 0;
    let result = 0;
    
    // Function to check if we can ship with given capacity
    function canShip(capacity) {
        let currentLoad = 0;
        let daysNeeded = 1;
        
        for (let i = 0; i < weights.length; i++) {
            if (currentLoad + weights[i] > capacity) {
                // Start a new day
                daysNeeded++;
                currentLoad = weights[i];
                
                if (daysNeeded > days) {
                    return false;
                }
            } else {
                currentLoad += weights[i];
            }
        }
        
        return true;
    }
    
    function updateRangeDisplay() {
        rangeValue.innerHTML = `
            Left = ${currentLeft}, Right = ${currentRight}, Mid = ${mid}<br>
            Testing capacity ${mid}...
        `;
    }
    
    function performCalculationStep() {
        if (currentLeft >= currentRight) {
            // Binary search completed
            result = currentLeft;
            
            explanation.innerHTML = `<strong>Binary Search Completed!</strong> Minimum capacity found: ${result}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Minimum capacity = ${result} (binary search converged)
                </div>
            `;
            
            minCapacityValue.textContent = result;
            
            // Show optimal distribution
            showOptimalDistribution(result, weights, days);
            
            // Auto-return after 20 seconds
            const autoReturnTimer = setTimeout(() => {
                returnToOriginalAfterCapacity();
            }, 20000);
            
            continueButton.style.display = 'block';
            continueButton.addEventListener('click', () => {
                clearTimeout(autoReturnTimer);
                returnToOriginalAfterCapacity();
            });
            
            return;
        }
        
        step++;
        mid = Math.floor((currentLeft + currentRight) / 2);
        
        explanation.innerHTML = `Step ${step}: Testing capacity ${mid} (range [${currentLeft}, ${currentRight}])`;
        updateRangeDisplay();
        
        // Highlight all elements initially
        const elements = arrayContainer.querySelectorAll('.array-element');
        elements.forEach(el => {
            el.querySelector('.element-value').classList.remove('capacity-highlight', 'capacity-overload', 'capacity-fits');
        });
        
        // Test if we can ship with current capacity
        const canShipResult = canShip(mid);
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${canShipResult ? 'active' : ''}">
                <strong>Step ${step}:</strong> Testing capacity ${mid} - 
                ${canShipResult ? ' Can ship' : ' Cannot ship'}
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Animate the shipping simulation
        simulateShippingWithCapacity(mid, weights, days, canShipResult, () => {
            if (canShipResult) {
                // Can ship with this capacity, try smaller capacity
                currentRight = mid;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Update:</strong> Capacity ${mid} works, trying smaller (right = ${mid})
                    </div>
                `;
            } else {
                // Cannot ship with this capacity, need larger capacity
                currentLeft = mid + 1;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Update:</strong> Capacity ${mid} fails, trying larger (left = ${mid + 1})
                    </div>
                `;
            }
            
            // Continue with next step
            setTimeout(performCalculationStep, 2000);
        });
    }
    
    // Start the calculation process
    updateRangeDisplay();
    setTimeout(performCalculationStep, 1000);
}

// NEW: Simulate Shipping with Given Capacity
function simulateShippingWithCapacity(capacity, weights, days, canShipResult, callback) {
    const arrayContainer = document.getElementById('capacityArray');
    const explanation = document.getElementById('capacityExplanation');
    const elements = arrayContainer.querySelectorAll('.array-element');
    
    let currentDay = 1;
    let currentLoad = 0;
    let dayStartIndex = 0;
    let animationStep = 0;
    
    function simulateStep(i) {
        if (i >= weights.length) {
            // Simulation completed
            if (currentDay <= days) {
                // Highlight the last day's packages
                for (let j = dayStartIndex; j < weights.length; j++) {
                    elements[j].querySelector('.element-value').classList.add('capacity-fits');
                }
            }
            
            setTimeout(() => {
                // Reset all highlights
                elements.forEach(el => {
                    el.querySelector('.element-value').classList.remove('capacity-highlight', 'capacity-overload', 'capacity-fits', 'capacity-current-day');
                });
                callback();
            }, 1500);
            return;
        }
        
        const weight = weights[i];
        
        if (currentLoad + weight > capacity) {
            // Start a new day
            explanation.innerHTML = `Capacity ${capacity}: Day ${currentDay} complete (${currentLoad} weight), starting Day ${currentDay + 1}`;
            
            // Highlight previous day's packages
            for (let j = dayStartIndex; j < i; j++) {
                elements[j].querySelector('.element-value').classList.add(canShipResult ? 'capacity-fits' : 'capacity-overload');
            }
            
            currentDay++;
            
            if (currentDay > days) {
                // Exceeded allowed days
                explanation.innerHTML = ` Capacity ${capacity}: Exceeded ${days} days at package ${i}`;
                elements[i].querySelector('.element-value').classList.add('capacity-overload');
                
                setTimeout(() => {
                    callback();
                }, 1500);
                return;
            }
            
            currentLoad = weight;
            dayStartIndex = i;
            
            // Highlight current day start
            elements[i].querySelector('.element-value').classList.add('capacity-current-day');
            
        } else {
            // Add to current day
            currentLoad += weight;
            explanation.innerHTML = `Capacity ${capacity}: Day ${currentDay}, Current load: ${currentLoad}`;
            
            // Highlight current package
            elements[i].querySelector('.element-value').classList.add('capacity-highlight');
            
            // Remove highlight after delay
            setTimeout(() => {
                elements[i].querySelector('.element-value').classList.remove('capacity-highlight');
            }, 500);
        }
        
        // Continue to next package
        setTimeout(() => {
            simulateStep(i + 1);
        }, 800);
    }
    
    // Start simulation
    explanation.innerHTML = `Capacity ${capacity}: Starting Day 1`;
    elements[0].querySelector('.element-value').classList.add('capacity-current-day');
    simulateStep(0);
}

// NEW: Show Optimal Distribution
function showOptimalDistribution(capacity, weights, days) {
    const dailyDistribution = document.getElementById('dailyDistribution');
    const distributionContainer = document.getElementById('distributionContainer');
    
    dailyDistribution.style.display = 'block';
    
    let currentDay = 1;
    let currentLoad = 0;
    let dayPackages = [];
    let allDays = [];
    
    for (let i = 0; i < weights.length; i++) {
        if (currentLoad + weights[i] > capacity) {
            // Start a new day
            allDays.push({
                day: currentDay,
                load: currentLoad,
                packages: [...dayPackages]
            });
            
            currentDay++;
            currentLoad = weights[i];
            dayPackages = [weights[i]];
        } else {
            currentLoad += weights[i];
            dayPackages.push(weights[i]);
        }
    }
    
    // Add the last day
    allDays.push({
        day: currentDay,
        load: currentLoad,
        packages: [...dayPackages]
    });
    
    // Create distribution visualization
    let html = '';
    allDays.forEach(dayInfo => {
        html += `
            <div class="day-container">
                <div class="day-label">Day ${dayInfo.day}: Total = ${dayInfo.load}</div>
                <div class="original-array-container">
                    ${dayInfo.packages.map(weight => `
                        <div class="array-element">
                            <div class="element-value capacity-fits">${weight}</div>
                            <div class="element-index">Weight</div>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    });
    
    distributionContainer.innerHTML = html;
    
    // Also update explanation
    const explanation = document.getElementById('capacityExplanation');
    explanation.innerHTML += `<br><strong>Distribution:</strong> ${allDays.length} days used (Target: ${days})`;
}

// NEW: Return to Original after Capacity Calculation
function returnToOriginalAfterCapacity() {
    // Reset to original array
    myArray = [...originalArrayForCapacity];
    originalArrayForCapacity = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isCapacityCalculationRunning = false;
    
    logOperation('Capacity calculation completed - returned to original array', 'info');
    showNotification('Returned to original array after capacity calculation', 'success');
}
// NEW: Koko Eating Bananas Handler
function handleKokoBananas() {
    const hours = parseInt(kokoHoursInput.value);
    
    if (isNaN(hours) || hours < 1) {
        showNotification('Please enter a valid number of hours (minimum 1)', 'danger');
        kokoHoursInput.focus();
        return;
    }
    
    kokoHours = hours;
    
    // Show pile input group
    kokoInputGroup.style.display = 'block';
    kokoPileCountInput.focus();
    
    logOperation(`Started Koko Eating Bananas algorithm with h=${hours} hours`, 'info');
}

// NEW: Confirm Koko Piles Handler
function handleConfirmKokoPiles() {
    const pileCount = parseInt(kokoPileCountInput.value);
    
    if (isNaN(pileCount) || pileCount < 1 || pileCount > 10) {
        showNotification('Please enter a valid number of piles between 1 and 10', 'danger');
        kokoPileCountInput.focus();
        return;
    }
    
    // Create input fields for piles
    kokoPileInputs.innerHTML = '<label class="form-label">Enter banana counts for each pile:</label>';
    kokoPiles = [];
    
    for (let i = 0; i < pileCount; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Pile ${i + 1}</span>
            <input type="number" class="form-control koko-pile-input" 
                   placeholder="Bananas in pile" min="1" value="${Math.floor(Math.random() * 20) + 1}" data-index="${i}">
        `;
        kokoPileInputs.appendChild(inputGroup);
    }
    
    // Add event listeners for pile inputs
    const pileInputs = kokoPileInputs.querySelectorAll('.koko-pile-input');
    pileInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('koko-pile-input')) {
                    nextInput.focus();
                }
            }
        });
    });
    
    // Show start button
    startKokoAlgorithmBtn.style.display = 'block';
    
    showNotification(`Set ${pileCount} banana piles. Please enter the banana counts.`, 'success');
    logOperation(`Created ${pileCount} banana piles`, 'info');
}

// NEW: Start Koko Algorithm Handler
function handleStartKokoAlgorithm() {
    // Collect pile values
    const pileInputs = kokoPileInputs.querySelectorAll('.koko-pile-input');
    kokoPiles = [];
    
    for (let i = 0; i < pileInputs.length; i++) {
        const value = parseInt(pileInputs[i].value);
        if (isNaN(value) || value < 1) {
            showNotification(`Please enter a valid banana count for pile ${i + 1} (minimum 1)`, 'danger');
            pileInputs[i].focus();
            return;
        }
        kokoPiles.push(value);
    }
    
    if (kokoPiles.length === 0) {
        showNotification('Please set up banana piles first', 'warning');
        return;
    }
    
    // Store original array
    originalArrayForKoko = [...myArray];
    
    // Hide input group
    kokoInputGroup.style.display = 'none';
    
    // Start Koko's algorithm visualization
    showKokoAlgorithmVisualization();
}

// NEW: Cancel Koko Handler
function handleCancelKoko() {
    kokoInputGroup.style.display = 'none';
    kokoHoursInput.value = '';
    kokoPileCountInput.value = '';
    kokoPileInputs.innerHTML = '';
    startKokoAlgorithmBtn.style.display = 'none';
    
    kokoPiles = [];
    kokoHours = 0;
    
    logOperation('Cancelled Koko Eating Bananas operation', 'info');
    showNotification('Koko operation cancelled', 'info');
}
// NEW: Show Koko Algorithm Visualization
function showKokoAlgorithmVisualization() {
    isKokoAlgorithmRunning = true;
    
    // Update array with banana piles for visualization
    myArray = kokoPiles.map(pile => pile.toString());
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Koko Eating Bananas Algorithm</h5>
        
        <div class="koko-speed-display">
            <p class="mb-2">Find minimum eating speed (k) to finish all bananas in ${kokoHours} hours</p>
            <div class="speed-value" id="currentSpeed">k = 0</div>
            <p class="mb-0">Piles: [${kokoPiles.join(', ')}] | Hours available: ${kokoHours}</p>
        </div>
        
        <div class="array-group">
            <div class="array-label">Banana Piles</div>
            <div class="original-array-container" id="kokoPilesArray"></div>
        </div>
        
        <div class="koko-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Binary search for minimum eating speed k</p>
            <p class="mb-0" id="kokoExplanation">Initializing algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="kokoStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="kokoSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Total Bananas</div>
            <div class="stats-value" id="totalBananas">${kokoPiles.reduce((a, b) => a + b, 0)}</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Maximum Pile</div>
            <div class="stats-value" id="maxPile">${Math.max(...kokoPiles)}</div>
        </div>
        
        <div class="stats-card mt-2" id="optimalSpeedContainer" style="display: none;">
            <div>Optimal Speed Found</div>
            <div class="stats-value" id="optimalSpeedValue">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterKoko" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(myArray, 'kokoPilesArray');
    
    // Initialize all piles with koko-pile class
    setTimeout(() => {
        const pilesContainer = document.getElementById('kokoPilesArray');
        const pileElements = pilesContainer.querySelectorAll('.array-element');
        pileElements.forEach(el => {
            el.querySelector('.element-value').classList.add('koko-pile');
        });
    }, 100);
    
    // Start Koko's algorithm animation
    performKokoAlgorithmAnimation();
}

// NEW: Perform Koko's Algorithm Animation
function performKokoAlgorithmAnimation() {
    const pilesContainer = document.getElementById('kokoPilesArray');
    const explanation = document.getElementById('kokoExplanation');
    const stepsContainer = document.getElementById('kokoSteps');
    const currentSpeedDisplay = document.getElementById('currentSpeed');
    const optimalSpeedContainer = document.getElementById('optimalSpeedContainer');
    const optimalSpeedValue = document.getElementById('optimalSpeedValue');
    const continueButton = document.getElementById('continueAfterKoko');
    
    const piles = kokoPiles;
    const h = kokoHours;
    let left = 1;
    let right = Math.max(...piles);
    let step = 0;
    let optimalSpeed = 0;
    
    function canFinish(speed) {
        let hoursNeeded = 0;
        for (let pile of piles) {
            hoursNeeded += Math.ceil(pile / speed);
            if (hoursNeeded > h) {
                return false;
            }
        }
        return true;
    }
    
    function performBinarySearchStep() {
              if (left >= right) {
            // Algorithm completed
            optimalSpeed = left;
            
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Optimal eating speed found!`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step + 1}:</strong> Binary search complete! left = right = ${optimalSpeed}
                </div>
                <div class="algorithm-step active">
                    <strong>Final Result:</strong> Minimum eating speed k = ${optimalSpeed} bananas/hour
                </div>
            `;
            
            currentSpeedDisplay.textContent = `k = ${optimalSpeed}`;
            currentSpeedDisplay.style.color = 'var(--primary-color)';
            
            optimalSpeedContainer.style.display = 'block';
            optimalSpeedValue.textContent = optimalSpeed;
            
            // Show the explanation message with the exact format requested
            stepsContainer.innerHTML += `
                <div class="koko-explanation mt-3">
                    <p class="mb-1"><strong>Final Message:</strong></p>
                    <p class="mb-0" style="font-size: 1.1rem; font-weight: bold; color: var(--primary-color);">
                        Algorithm completed optimal speed is ${optimalSpeed} bananas per hour speed
                    </p>
                </div>
            `;
            
            // Highlight the optimal speed in the array
            const pileElements = pilesContainer.querySelectorAll('.array-element');
            pileElements.forEach((el, index) => {
                const valueDiv = el.querySelector('.element-value');
                valueDiv.classList.remove('koko-current-speed', 'koko-valid-speed', 'koko-invalid-speed');
                
                if (piles[index] <= optimalSpeed) {
                    setTimeout(() => {
                        valueDiv.classList.add('koko-optimal-speed');
                    }, index * 200);
                } else {
                    setTimeout(() => {
                        valueDiv.classList.add('koko-valid-speed');
                    }, index * 200);
                }
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterKoko();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterKoko);
            
            return;
        }
        
        step++;
        const mid = Math.floor(left + (right - left) / 2);
        
        explanation.innerHTML = `Step ${step}: Testing speed k = ${mid} (search range: [${left}, ${right}])`;
        currentSpeedDisplay.textContent = `k = ${mid}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> Testing speed k = ${mid}
            </div>
        `;
        
        // Highlight current speed being tested
        const pileElements = pilesContainer.querySelectorAll('.array-element');
        pileElements.forEach(el => {
            el.querySelector('.element-value').classList.add('koko-current-speed');
        });
        
        setTimeout(() => {
            // Remove current speed highlight
            pileElements.forEach(el => {
                el.querySelector('.element-value').classList.remove('koko-current-speed');
            });
            
            // Test if Koko can finish with this speed
            explanation.innerHTML = `Step ${step}: Calculating hours needed for k = ${mid}...`;
            
            let hoursNeeded = 0;
            let hourCalculations = [];
            
            for (let i = 0; i < piles.length; i++) {
                const pile = piles[i];
                const hoursForPile = Math.ceil(pile / mid);
                hoursNeeded += hoursForPile;
                hourCalculations.push(`Pile ${i+1}: ${pile}/${mid} = ${hoursForPile} hours`);
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Calculation:</strong> ${hourCalculations.join(' | ')}
                </div>
                <div class="algorithm-step ${hoursNeeded <= h ? 'active' : ''}">
                    <strong>Total hours:</strong> ${hoursNeeded} ${hoursNeeded <= h ? '' : '>'} ${h} (h)
                </div>
            `;
            
            // Scroll steps container
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            if (hoursNeeded <= h) {
                // Speed is valid (can finish in time)
                explanation.innerHTML = `Step ${step}: Speed ${mid} is VALID (${hoursNeeded} hours  ${h} hours)`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Decision:</strong> Speed ${mid} is VALID  Try smaller speed (right = ${mid})
                    </div>
                `;
                
                // Highlight as valid
                pileElements.forEach(el => {
                    el.querySelector('.element-value').classList.add('koko-valid-speed');
                });
                
                right = mid;
            } else {
                // Speed is invalid (cannot finish in time)
                explanation.innerHTML = `Step ${step}: Speed ${mid} is INVALID (${hoursNeeded} hours > ${h} hours)`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Decision:</strong> Speed ${mid} is INVALID  Need larger speed (left = ${mid + 1})
                    </div>
                `;
                
                // Highlight as invalid
                pileElements.forEach(el => {
                    el.querySelector('.element-value').classList.add('koko-invalid-speed');
                });
                
                left = mid + 1;
            }
            
            setTimeout(() => {
                // Remove validation highlights
                pileElements.forEach(el => {
                    el.querySelector('.element-value').classList.remove('koko-valid-speed', 'koko-invalid-speed');
                });
                
                // Continue with next step
                performBinarySearchStep();
            }, 2000);
        }, 1500);
    }
    
    // Start binary search
    performBinarySearchStep();
}

// NEW: Return to Original after Koko's Algorithm
function returnToOriginalAfterKoko() {
    // Reset to original array
    myArray = [...originalArrayForKoko];
    originalArrayForKoko = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isKokoAlgorithmRunning = false;
    
    // Clear all Koko-related data
    kokoPiles = [];
    kokoHours = 0;
    
    // Reset input groups
    kokoInputGroup.style.display = 'none';
    kokoHoursInput.value = '';
    kokoPileCountInput.value = '';
    kokoPileInputs.innerHTML = '';
    startKokoAlgorithmBtn.style.display = 'none';
    
    logOperation('Koko Eating Bananas algorithm completed - returned to original array', 'info');
    showNotification('Returned to original array after Koko\'s algorithm', 'success');
}
// NEW: First Bad Version Handler
function handleFirstBadVersion() {
    const n = parseInt(versionCount.value);
    
    if (isNaN(n) || n < 1 || n > 100) {
        showNotification('Please enter a valid number between 1 and 100', 'danger');
        versionCount.focus();
        return;
    }
    
    if (isBadVersionRunning) {
        showNotification('First Bad Version algorithm is already running', 'warning');
        return;
    }
    
    isBadVersionRunning = true;
    
    // Store original array
    originalArrayForBadVersion = [...myArray];
    
    // Generate array of versions
    generateBadVersionArray(n);
}

// NEW: Generate Bad Version Array
function generateBadVersionArray(n) {
    // Randomly select the first bad version (between 1 and n)
    const firstBad = Math.floor(Math.random() * n) + 1;
    firstBadVersionIndex = firstBad - 1; // Convert to 0-based index
    
    // Create array: G for good (false), B for bad (true)
    badVersionArray = [];
    for (let i = 0; i < n; i++) {
        if (i < firstBadVersionIndex) {
            badVersionArray.push('G'); // Good version
        } else {
            badVersionArray.push('B'); // Bad version
        }
    }
    
    // Temporarily replace myArray with the version array
    const tempArray = [...myArray];
    myArray = [...badVersionArray];
    
    // Show visualization
    showBadVersionVisualization(n, firstBad);
    
    // Store the real first bad index for later use
    window.badVersionFirstBad = firstBadVersionIndex;
    
    // Show information about the generated array
    logOperation(`Generated version array with ${n} versions. First bad version is at position ${firstBad} (index ${firstBadVersionIndex})`, 'info');
}

// NEW: Show Bad Version Visualization
function showBadVersionVisualization(n, firstBad) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">First Bad Version Algorithm (n = ${n})</h5>
        
        <div class="array-group">
            <div class="array-label">Versions Array [G=Good, B=Bad]</div>
            <div class="original-array-container" id="versionArrayDisplay"></div>
        </div>
        
        <div class="version-explanation">
            <p class="mb-2"><strong>Problem:</strong> Find first bad version in array where all versions after a bad version are also bad</p>
            <p class="mb-0" id="versionExplanation">Initializing first bad version search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="versionStepsContainer">
            <h6 class="text-center">Binary Search Steps (First Bad Version)</h6>
            <div class="steps-container" id="versionSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>First Bad Version Found</div>
            <div class="stats-value" id="firstBadVersionValue">Not found yet</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Total API Calls (isBadVersion())</div>
            <div class="stats-value" id="apiCallsCount">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterBadVersion" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Render the version array with special styling
    renderVersionArray();
    
    // Start the algorithm animation
    performFirstBadVersionAlgorithm();
}

// NEW: Render Version Array with special styling
function renderVersionArray() {
    const container = document.getElementById('versionArrayDisplay');
    container.innerHTML = '';
    
    badVersionArray.forEach((value, index) => {
        const elementDiv = document.createElement('div');
        elementDiv.className = 'array-element';
        
        const valueDiv = document.createElement('div');
        valueDiv.className = `element-value element-version ${value === 'G' ? 'good-version' : 'bad-version'}`;
        valueDiv.textContent = value;
        
        const indexDiv = document.createElement('div');
        indexDiv.className = 'element-index';
        indexDiv.textContent = `${index + 1}`; // Show 1-based index for versions
        
        elementDiv.appendChild(valueDiv);
        elementDiv.appendChild(indexDiv);
        container.appendChild(elementDiv);
    });
}

// NEW: Perform First Bad Version Algorithm (Binary Search variation)
function performFirstBadVersionAlgorithm() {
    const container = document.getElementById('versionArrayDisplay');
    const explanation = document.getElementById('versionExplanation');
    const stepsContainer = document.getElementById('versionSteps');
    const firstBadVersionValue = document.getElementById('firstBadVersionValue');
    const apiCallsCount = document.getElementById('apiCallsCount');
    const continueButton = document.getElementById('continueAfterBadVersion');
    
    let left = 0;
    let right = badVersionArray.length - 1;
    let firstBad = -1;
    let apiCalls = 0;
    let step = 0;
    
    function isBadVersion(index) {
        apiCalls++;
        apiCallsCount.textContent = apiCalls;
        return badVersionArray[index] === 'B';
    }
    
    function performAlgorithmStep() {
        if (left > right) {
            // Algorithm completed
            if (firstBad !== -1) {
                explanation.innerHTML = `<strong>Algorithm Completed!</strong> First bad version found at position ${firstBad + 1}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> Algorithm completed! First bad version is version ${firstBad + 1}
                    </div>
                `;
                
                // Highlight the first bad version
                const versionElements = container.querySelectorAll('.array-element');
                const firstBadElement = versionElements[firstBad].querySelector('.element-version');
                firstBadElement.classList.remove('current-version');
                firstBadElement.classList.add('first-bad-found');
                
                firstBadVersionValue.textContent = `Version ${firstBad + 1}`;
                
            } else {
                explanation.innerHTML = `<strong>Algorithm Completed!</strong> No bad version found`;
                firstBadVersionValue.textContent = 'No bad version found';
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterBadVersion();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterBadVersion);
            
            return;
        }
        
        step++;
        const mid = Math.floor((left + right) / 2);
        
        // Update explanation
        explanation.innerHTML = `Step ${step}: Checking version ${mid + 1} (left=${left + 1}, right=${right + 1}, mid=${mid + 1})`;
        
        // Highlight current mid element
        const versionElements = container.querySelectorAll('.array-element');
        const midElement = versionElements[mid].querySelector('.element-version');
        midElement.classList.add('current-version');
        
        // Highlight left and right ranges
        for (let i = left; i <= right; i++) {
            if (i !== mid) {
                const element = versionElements[i].querySelector('.element-version');
                if (i < mid) {
                    element.classList.add('left-search');
                } else {
                    element.classList.add('right-search');
                }
            }
        }
        
        setTimeout(() => {
            // Check if mid is bad version
            const isBad = isBadVersion(mid);
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${isBad ? 'active' : ''}">
                    <strong>Step ${step}:</strong> isBadVersion(${mid + 1}) = ${isBad ? 'true (BAD)' : 'false (GOOD)'}
                </div>
            `;
            
            // Scroll steps container
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            // Remove temporary highlights
            midElement.classList.remove('current-version');
            for (let i = left; i <= right; i++) {
                const element = versionElements[i].querySelector('.element-version');
                element.classList.remove('left-search', 'right-search');
            }
            
            if (isBad) {
                // If mid is bad, first bad is at mid or before mid
                firstBad = mid;
                right = mid - 1; // Search in left half
                
                // Highlight that we found a bad version
                midElement.classList.add('bad-version');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}.1:</strong> Found bad version at ${mid + 1}. Searching left half (${left + 1} to ${right + 1}) for earlier bad version
                    </div>
                `;
            } else {
                // If mid is good, first bad is after mid
                left = mid + 1; // Search in right half
                
                // Highlight that this is good
                midElement.classList.add('good-version');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step}.1:</strong> Version ${mid + 1} is good. Searching right half (${left + 1} to ${right + 1})
                    </div>
                `;
            }
            
            // Continue to next step
            setTimeout(performAlgorithmStep, 1500);
        }, 1500);
    }
    
    // Start algorithm
    performAlgorithmStep();
}

// NEW: Return to Original after Bad Version Algorithm
function returnToOriginalAfterBadVersion() {
    // Restore original array
    myArray = [...originalArrayForBadVersion];
    originalArrayForBadVersion = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isBadVersionRunning = false;
    
    // Clear input
    versionCount.value = '';
    
    logOperation('First Bad Version algorithm completed - returned to original array', 'info');
    showNotification('Returned to original array after First Bad Version algorithm', 'success');
}
// NEW: House Robber Handler
function handleHouseRobber() {
    if (isHouseRobberRunning) {
        showNotification('House Robber operation is already in progress', 'warning');
        return;
    }
    
    // Show input group
    houseRobberGroup.style.display = 'block';
    houseValues.focus();
    
    // Set example value
    houseValues.value = '1,2,4,8,16';
    
    logOperation('Started House Robber problem', 'info');
}

// NEW: Confirm House Robber Handler
function handleConfirmHouseRobber() {
    const input = houseValues.value.trim();
    
    if (input === '') {
        showNotification('Please enter house values or use current array', 'warning');
        houseValues.focus();
        return;
    }
    
    // Parse input values
    const values = input.split(',').map(item => {
        const trimmed = item.trim();
        return isNaN(parseFloat(trimmed)) ? trimmed : parseFloat(trimmed);
    }).filter(item => !isNaN(item));
    
    if (values.length === 0) {
        showNotification('Please enter valid numeric house values', 'danger');
        houseValues.focus();
        return;
    }
    
    if (values.length > 20) {
        showNotification('Maximum 20 houses allowed for visualization', 'warning');
        return;
    }
    
    // Store original array
    originalArrayForRobber = [...myArray];
    
    // Set house values as current array
    myArray = values.map(v => v.toString());
    
    // Hide input group
    houseRobberGroup.style.display = 'none';
    houseValues.value = '';
    
    // Start House Robber visualization
    showHouseRobberVisualization();
}

// NEW: Use Current Array Handler
function handleUseCurrentArray() {
    if (myArray.length === 0) {
        showNotification('Current array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if all elements are numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('House Robber requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForRobber = [...myArray];
    
    // Hide input group
    houseRobberGroup.style.display = 'none';
    houseValues.value = '';
    
    // Start House Robber visualization
    showHouseRobberVisualization();
}

// NEW: Generate Random Houses Handler
function handleGenerateRandomHouses() {
    // Generate random houses (5-10 houses, values 1-50)
    const numHouses = Math.floor(Math.random() * 6) + 5; // 5-10 houses
    const randomHouses = [];
    
    for (let i = 0; i < numHouses; i++) {
        randomHouses.push(Math.floor(Math.random() * 50) + 1);
    }
    
    // Update input field
    houseValues.value = randomHouses.join(', ');
    
    showNotification(`Generated ${numHouses} random houses`, 'success');
    logOperation(`Generated random houses: ${randomHouses.join(', ')}`, 'info');
}

// NEW: Cancel House Robber Handler
function handleCancelHouseRobber() {
    houseRobberGroup.style.display = 'none';
    houseValues.value = '';
    
    logOperation('Cancelled House Robber operation', 'info');
    showNotification('House Robber operation cancelled', 'info');
}

// NEW: Show House Robber Visualization
function showHouseRobberVisualization() {
    isHouseRobberRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">House Robber Problem - Maximum Sum of Non-Adjacent Elements</h5>
        
        <div class="array-group">
            <div class="array-label">Houses (Values)</div>
            <div class="original-array-container" id="originalHousesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Dynamic Programming Table</div>
            <div class="dp-table-container">
                <table class="dp-table" id="dpTable">
                    <thead>
                        <tr>
                            <th>House i</th>
                            <th>Value</th>
                            <th>Option 1 (Skip)</th>
                            <th>Option 2 (Rob)</th>
                            <th>DP[i] = max(Option1, Option2)</th>
                        </tr>
                    </thead>
                    <tbody id="dpTableBody">
                    </tbody>
                </table>
            </div>
        </div>
        
        <div class="decision-explanation">
            <p class="mb-2"><strong>Decision Process:</strong></p>
            <p class="mb-1">Option 1 (Skip house i): Keep best from first i-1 houses = DP[i-1]</p>
            <p class="mb-0">Option 2 (Rob house i): Value[i] + best from houses 0 to i-2 = Value[i] + DP[i-2]</p>
        </div>
        
        <div class="option-container" id="currentDecision">
            <!-- Options will be dynamically added here -->
        </div>
        
        <div class="algorithm-steps mt-3" id="robberStepsContainer">
            <h6 class="text-center">House Robber Steps</h6>
            <div class="steps-container" id="robberSteps"></div>
        </div>
        
        <div class="robber-results" id="robberResults" style="display: none;">
            <h6 class="text-center">Final Results</h6>
            <div class="house-robber-summary" id="robberSummary"></div>
            <div id="backtrackingSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterRobber" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array (Auto in 20s)
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Render houses array
    renderArrayInContainer(myArray, 'originalHousesArray', true);
    
    // Start House Robber algorithm
    performHouseRobberAlgorithm();
}

// NEW: Modified renderArrayInContainer to support house robber
function renderArrayInContainer(array, containerId, isHouseRobber = false) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (array.length === 0) {
        const emptyState = document.createElement('div');
        emptyState.className = 'array-empty-state';
        emptyState.innerHTML = `
            <i class="fas fa-layer-group"></i>
            <h4>Array is Empty</h4>
            <p>Add some elements to get started!</p>
        `;
        container.appendChild(emptyState);
        return;
    }
    
    array.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.setAttribute('data-index', index);
        
        const valueDiv = document.createElement('div');
        valueDiv.className = 'element-value';
        valueDiv.textContent = value;
        
        // Add house robber specific classes if needed
        if (isHouseRobber) {
            valueDiv.classList.add('house-value');
            valueDiv.setAttribute('data-house-index', index);
        }
        
        const indexDiv = document.createElement('div');
        indexDiv.className = 'element-index';
        indexDiv.textContent = `House ${index}`;
        
        arrayElement.appendChild(valueDiv);
        arrayElement.appendChild(indexDiv);
        container.appendChild(arrayElement);
    });
}

// NEW: Perform House Robber Algorithm
function performHouseRobberAlgorithm() {
    const housesContainer = document.getElementById('originalHousesArray');
    const dpTableBody = document.getElementById('dpTableBody');
    const currentDecision = document.getElementById('currentDecision');
    const robberSteps = document.getElementById('robberSteps');
    const robberResults = document.getElementById('robberResults');
    const robberSummary = document.getElementById('robberSummary');
    const backtrackingSteps = document.getElementById('backtrackingSteps');
    const continueButton = document.getElementById('continueAfterRobber');
    
    const houses = myArray.map(val => parseFloat(val));
    const n = houses.length;
    
    // Initialize DP array
    robberDP = new Array(n).fill(0);
    robberHouses = [];
    
    let step = 0;
    let currentHouse = 0;
    
    function performRobberStep() {
        if (currentHouse >= n) {
            // Algorithm completed
            robberSteps.innerHTML += `
                <div class="backtrack-step final">
                    <strong>Algorithm Complete!</strong> Maximum amount = $${robberDP[n-1]}
                </div>
            `;
            
            // Show results section
            robberResults.style.display = 'block';
            
            // Perform backtracking
            performBacktracking();
            return;
        }
        
        step++;
        const houseValue = houses[currentHouse];
        
        // Update steps
        robberSteps.innerHTML += `
            <div class="backtrack-step">
                <strong>Step ${step}: Processing House ${currentHouse} (Value: $${houseValue})</strong>
            </div>
        `;
        
        // Clear current decision
        currentDecision.innerHTML = '';
        
        if (currentHouse === 0) {
            // First house - must rob it
            robberDP[0] = houseValue;
            
            // Highlight house
            highlightHouse(currentHouse, 'rob');
            
            // Update DP table
            updateDPTable(currentHouse, houseValue, 0, houseValue, houseValue, 'rob');
            
            // Show decision
            currentDecision.innerHTML = `
                <div class="option-box rob selected">
                    <strong>House 0 Decision:</strong><br>
                    Only one house, must rob it<br>
                    <strong>DP[0] = $${houseValue}</strong>
                </div>
            `;
            
            robberSteps.innerHTML += `
                <div class="backtrack-step">
                    First house only: DP[0] = $${houseValue}
                </div>
            `;
            
            setTimeout(() => {
                currentHouse++;
                performRobberStep();
            }, 2000);
            
        } else if (currentHouse === 1) {
            // Second house - choose max of first two houses
            const option1 = robberDP[0]; // Skip house 1
            const option2 = houseValue;  // Rob house 1
            robberDP[1] = Math.max(option1, option2);
            
            // Highlight appropriate house
            if (option1 >= option2) {
                // Skip house 1, keep house 0
                highlightHouse(0, 'rob');
                highlightHouse(1, 'skip');
            } else {
                // Rob house 1, skip house 0
                highlightHouse(0, 'skip');
                highlightHouse(1, 'rob');
            }
            
            // Update DP table
            updateDPTable(currentHouse, houseValue, option1, option2, robberDP[1], 
                         option1 >= option2 ? 'skip' : 'rob');
            
            // Show decision
            currentDecision.innerHTML = `
                <div class="option-box ${option1 >= option2 ? 'skip selected' : 'skip'}">
                    <strong>Option 1: Skip House 1</strong><br>
                    Keep DP[0] = $${option1}
                </div>
                <div class="option-box ${option2 > option1 ? 'rob selected' : 'rob'}">
                    <strong>Option 2: Rob House 1</strong><br>
                    Value = $${option2}
                </div>
            `;
            
            robberSteps.innerHTML += `
                <div class="backtrack-step">
                    DP[1] = max(DP[0]=$${option1}, Value[1]=$${option2}) = $${robberDP[1]}
                </div>
            `;
            
            setTimeout(() => {
                currentHouse++;
                performRobberStep();
            }, 2500);
            
        } else {
            // General case (i >= 2)
            const option1 = robberDP[currentHouse - 1];  // Skip current house
            const option2 = houseValue + robberDP[currentHouse - 2];  // Rob current house
            robberDP[currentHouse] = Math.max(option1, option2);
            
            // Highlight houses
            highlightHouse(currentHouse, option1 >= option2 ? 'skip' : 'rob');
            
            // Update DP table
            updateDPTable(currentHouse, houseValue, option1, option2, robberDP[currentHouse],
                         option1 >= option2 ? 'skip' : 'rob');
            
            // Show decision with animation
            currentDecision.innerHTML = `
                <div class="option-box ${option1 >= option2 ? 'skip selected' : 'skip'}">
                    <strong>Option 1: Skip House ${currentHouse}</strong><br>
                    Keep DP[${currentHouse-1}] = $${option1}<br>
                    <small>Best from first ${currentHouse-1} houses</small>
                </div>
                <div class="option-box ${option2 > option1 ? 'rob selected' : 'rob'}">
                    <strong>Option 2: Rob House ${currentHouse}</strong><br>
                    $${houseValue} + DP[${currentHouse-2}] = $${option2}<br>
                    <small>Current + best from first ${currentHouse-2} houses</small>
                </div>
            `;
            
            robberSteps.innerHTML += `
                <div class="backtrack-step">
                    DP[${currentHouse}] = max($${option1}, $${option2}) = $${robberDP[currentHouse]}
                </div>
            `;
            
            // Animate the decision
            setTimeout(() => {
                const selectedOption = option1 >= option2 ? 'skip' : 'rob';
                const optionBoxes = currentDecision.querySelectorAll('.option-box');
                optionBoxes.forEach(box => {
                    if (box.classList.contains(selectedOption)) {
                        box.classList.add('selected');
                    }
                });
                
                setTimeout(() => {
                    currentHouse++;
                    performRobberStep();
                }, 1500);
            }, 500);
        }
        
        // Scroll to bottom of steps
        robberSteps.scrollTop = robberSteps.scrollHeight;
    }
    
    // NEW: Update DP Table
    function updateDPTable(houseIndex, houseValue, option1, option2, dpValue, decision) {
        const row = document.createElement('tr');
        row.id = `dp-row-${houseIndex}`;
        
        // Style based on decision
        let option1Class = 'dp-cell-option1';
        let option2Class = 'dp-cell-option2';
        
        if (houseIndex === 0) {
            // First house
            row.innerHTML = `
                <td><strong>${houseIndex}</strong></td>
                <td>$${houseValue}</td>
                <td>-</td>
                <td>$${houseValue}</td>
                <td class="dp-cell-optimal">$${dpValue}</td>
            `;
        } else if (houseIndex === 1) {
            // Second house
            row.innerHTML = `
                <td><strong>${houseIndex}</strong></td>
                <td>$${houseValue}</td>
                <td class="${option1Class}">$${option1}</td>
                <td class="${option2Class}">$${option2}</td>
                <td class="dp-cell-optimal">$${dpValue}</td>
            `;
        } else {
            // General case
            row.innerHTML = `
                <td><strong>${houseIndex}</strong></td>
                <td>$${houseValue}</td>
                <td class="${option1Class}">DP[${houseIndex-1}] = $${option1}</td>
                <td class="${option2Class}">$${houseValue} + DP[${houseIndex-2}] = $${option2}</td>
                <td class="dp-cell-optimal">$${dpValue}</td>
            `;
        }
        
        dpTableBody.appendChild(row);
        
        // Highlight the row
        setTimeout(() => {
            row.classList.add('dp-cell-highlight');
            setTimeout(() => {
                row.classList.remove('dp-cell-highlight');
            }, 1500);
        }, 100);
    }
    
    // NEW: Highlight House
    function highlightHouse(index, action) {
        const housesElements = housesContainer.querySelectorAll('.array-element');
        if (index < housesElements.length) {
            const valueDiv = housesElements[index].querySelector('.element-value');
            
            // Remove previous classes
            valueDiv.classList.remove('robbed-house', 'skipped-house');
            
            // Add arrow and label for robbed houses
            if (action === 'rob') {
                valueDiv.classList.add('robbed-house');
                
                // Add arrow
                const arrow = document.createElement('div');
                arrow.className = 'house-arrow';
                arrow.innerHTML = '<br><small>robbed</small>';
                housesElements[index].appendChild(arrow);
                
            } else if (action === 'skip') {
                valueDiv.classList.add('skipped-house');
            }
        }
    }
    
    // NEW: Perform Backtracking
    function performBacktracking() {
        backtrackingSteps.innerHTML = `
            <div class="backtrack-step final">
                <strong>--- Backtracking to Find Robbed Houses ---</strong>
            </div>
        `;
        
        let i = n - 1;
        let backtrackSteps = [];
        
        function performBacktrackStep() {
            if (i < 0) {
                // Backtracking completed
                backtrackingSteps.innerHTML += `
                    <div class="backtrack-step final">
                        <strong>Backtracking Complete!</strong>
                    </div>
                `;
                
                // Display final summary
                displayFinalSummary();
                return;
            }
            
            if (i === 0) {
                // First house
                if (robberDP[0] > 0) {
                    robberHouses.push(0);
                    backtrackingSteps.innerHTML += `
                        <div class="backtrack-step">
                            <strong>House 0:</strong> DP[0] > 0  Robbed house 0 ($${houses[0]})
                        </div>
                    `;
                }
                i = -1; // Done
            } else if (robberDP[i] === robberDP[i-1]) {
                // We skipped this house
                backtrackingSteps.innerHTML += `
                    <div class="backtrack-step">
                        <strong>House ${i}:</strong> DP[${i}] = DP[${i-1}]  Skipped house ${i}
                    </div>
                `;
                i--;
            } else {
                // We robbed this house
                robberHouses.push(i);
                backtrackingSteps.innerHTML += `
                    <div class="backtrack-step">
                        <strong>House ${i}:</strong> DP[${i}]  DP[${i-1}]  Robbed house ${i} ($${houses[i]})
                    </div>
                `;
                i -= 2; // Skip adjacent house
            }
            
            // Highlight current backtracking step
            highlightBacktrackStep(i + 1);
            
            setTimeout(performBacktrackStep, 1500);
        }
        
        // Start backtracking
        setTimeout(performBacktrackStep, 1000);
    }
    
    // NEW: Highlight Backtrack Step
    function highlightBacktrackStep(houseIndex) {
        const housesElements = housesContainer.querySelectorAll('.array-element');
        housesElements.forEach((element, index) => {
            const valueDiv = element.querySelector('.element-value');
            valueDiv.classList.remove('dp-cell-highlight');
            
            if (index === houseIndex) {
                valueDiv.classList.add('dp-cell-highlight');
            }
        });
    }
    
    // NEW: Display Final Summary
    function displayFinalSummary() {
        // Sort robbed houses in ascending order
        robberHouses.sort((a, b) => a - b);
        
        const totalValue = robberHouses.reduce((sum, idx) => sum + houses[idx], 0);
        
        // Create visual representation
        let visualHTML = '<div class="mt-3"><strong>Visual Representation:</strong></div>';
        for (let j = 0; j < n; j++) {
            const symbol = robberHouses.includes(j) ? '' : '';
            visualHTML += `
                <div class="d-flex justify-content-between align-items-center mb-1 p-2" 
                     style="background: rgba(255,255,255,0.05); border-radius: 5px;">
                    <span>House ${j}: $${houses[j]}</span>
                    <span>${symbol} ${robberHouses.includes(j) ? 'Robbed' : 'Skipped'}</span>
                </div>
            `;
        }
        
        robberSummary.innerHTML = `
            <h5 class="mb-3">FINAL RESULT</h5>
            <p class="mb-2"><strong>Maximum Amount:</strong> $${robberDP[n-1]}</p>
            <p class="mb-2"><strong>Houses to Rob:</strong> [${robberHouses.join(', ')}]</p>
            <p class="mb-2"><strong>Values Robbed:</strong> [${robberHouses.map(idx => houses[idx]).join(', ')}]</p>
            <p class="mb-0"><strong>Total:</strong> $${totalValue}</p>
            ${visualHTML}
        `;
        
        // Show continue button
        continueButton.style.display = 'block';
        
        // Auto-return after 20 seconds
        const autoReturnTimer = setTimeout(() => {
            returnToOriginalAfterRobber();
        }, 20000);
        
        continueButton.addEventListener('click', () => {
            clearTimeout(autoReturnTimer);
            returnToOriginalAfterRobber();
        });
        
        logOperation(`House Robber completed: Maximum amount = $${robberDP[n-1]}`, 'success');
    }
    
    // Start the algorithm
    performRobberStep();
}

// NEW: Return to Original after House Robber
function returnToOriginalAfterRobber() {
    // Reset to original array
    myArray = [...originalArrayForRobber];
    originalArrayForRobber = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isHouseRobberRunning = false;
    robberHouses = [];
    robberDP = [];
    
    // Reset input group
    houseRobberGroup.style.display = 'none';
    houseValues.value = '';
    
    logOperation('House Robber completed - returned to original array', 'info');
    showNotification('Returned to original array after House Robber', 'success');
}
// NEW: Maximum Subarray Sum with One Deletion Handler
function handleMaxSubarrayOneDeletion() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isMaxSubarrayOneDeletionRunning) {
        showNotification('Maximum subarray sum operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Maximum subarray sum operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForMaxSubarray = [...myArray];
    isMaxSubarrayOneDeletionRunning = true;
    
    // Show visualization
    showMaxSubarrayOneDeletionVisualization();
}

// NEW: Show Maximum Subarray Sum with One Deletion Visualization
function showMaxSubarrayOneDeletionVisualization() {
    const container = document.createElement('div');
    container.className = 'dual-operation-container';
    container.innerHTML = `
        <div class="leetcode-title">LeetCode 1186: Maximum Subarray Sum with One Deletion</div>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalMaxSubarrayArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Problem:</strong> Find maximum sum of contiguous subarray allowing at most one element deletion</p>
            <p class="mb-0" id="maxSubarrayExplanation">Initializing algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="maxSubarrayStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="maxSubarraySteps" style="max-height: 200px; overflow-y: auto;"></div>
        </div>
        
        <div class="row mt-3">
            <div class="col-md-6">
                <div class="stats-card">
                    <div>Forward DP Array</div>
                    <div class="stats-value" id="forwardDPValue">-</div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="stats-card">
                    <div>Backward DP Array</div>
                    <div class="stats-value" id="backwardDPValue">-</div>
                </div>
            </div>
        </div>
        
        <div class="row mt-2">
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Maximum Sum</div>
                    <div class="stats-value" id="maxSumResult">0</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Optimal Subarray</div>
                    <div class="stats-value" id="optimalIndices">-</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Deleted Element</div>
                    <div class="stats-value" id="deletedIndex">None</div>
                </div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMaxSubarray" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(container);
    
    renderArrayInContainer(originalArrayForMaxSubarray, 'originalMaxSubarrayArray');
    
    performMaxSubarrayOneDeletionAnimation();
}

// NEW: Perform Maximum Subarray Sum with One Deletion Animation
function performMaxSubarrayOneDeletionAnimation() {
    const arrayContainer = document.getElementById('originalMaxSubarrayArray');
    const explanation = document.getElementById('maxSubarrayExplanation');
    const stepsContainer = document.getElementById('maxSubarraySteps');
    const forwardDPValue = document.getElementById('forwardDPValue');
    const backwardDPValue = document.getElementById('backwardDPValue');
    const maxSumResult = document.getElementById('maxSumResult');
    const optimalIndices = document.getElementById('optimalIndices');
    const deletedIndex = document.getElementById('deletedIndex');
    const continueButton = document.getElementById('continueAfterMaxSubarray');
    
    const arr = originalArrayForMaxSubarray.map(val => parseFloat(val));
    const n = arr.length;
    let forward = new Array(n).fill(0);
    let backward = new Array(n).fill(0);
    
    // Clear any existing highlights
    const elements = arrayContainer.querySelectorAll('.array-element');
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.className = 'element-value';
    });
    
    // Handle small arrays
    if (n === 1) {
        explanation.innerHTML = `<strong>Single element array:</strong> Maximum sum = ${arr[0]}`;
        stepsContainer.innerHTML = `
            <div class="algorithm-step active">
                <strong>Step 1:</strong> Single element array - maximum sum is the element itself
            </div>
        `;
        maxSumResult.textContent = arr[0];
        optimalIndices.textContent = '0 to 0';
        deletedIndex.textContent = 'None';
        
        // Highlight the single element
        elements[0].querySelector('.element-value').classList.add('max-subarray-highlight');
        
        completeMaxSubarrayOperation(arr[0], 0, 0, -1);
        return;
    }
    
    let forwardIndex = 0;
    let backwardIndex = n - 1;
    
    function highlightElement(index, className, duration = 800) {
        const element = elements[index].querySelector('.element-value');
        element.classList.add(className);
        
        setTimeout(() => {
            element.classList.remove(className);
        }, duration);
    }
    
    function highlightSubarray(start, end, className, duration = 1500) {
        for (let i = start; i <= end; i++) {
            setTimeout(() => {
                elements[i].querySelector('.element-value').classList.add(className);
            }, (i - start) * 200);
        }
        
        if (duration > 0) {
            setTimeout(() => {
                for (let i = start; i <= end; i++) {
                    elements[i].querySelector('.element-value').classList.remove(className);
                }
            }, duration);
        }
    }
    
    function addStep(message, isActive = true) {
        const stepDiv = document.createElement('div');
        stepDiv.className = `algorithm-step ${isActive ? 'active' : ''}`;
        stepDiv.innerHTML = `<strong>Step ${stepsContainer.children.length + 1}:</strong> ${message}`;
        stepsContainer.appendChild(stepDiv);
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
    }
    
    function performForwardStep() {
        if (forwardIndex >= n) {
            // Forward calculation complete
            forwardDPValue.textContent = `[${forward.join(', ')}]`;
            addStep(`Forward DP calculation complete: [${forward.join(', ')}]`, true);
            explanation.innerHTML = 'Forward DP array calculated. Starting backward DP calculation...';
            
            // Start backward calculation
            setTimeout(performBackwardStep, 1500);
            return;
        }
        
        if (forwardIndex === 0) {
            forward[0] = arr[0];
            explanation.innerHTML = `Calculating forward[0] = arr[0] = ${arr[0]}`;
            addStep(`forward[0] = arr[0] = ${arr[0]}`, true);
            
            highlightElement(0, 'forward-sum-highlight');
            
            forwardIndex++;
            setTimeout(performForwardStep, 1500);
        } else {
            const prev = forward[forwardIndex - 1];
            const candidate = prev + arr[forwardIndex];
            forward[forwardIndex] = Math.max(arr[forwardIndex], candidate);
            
            explanation.innerHTML = `Calculating forward[${forwardIndex}] = max(arr[${forwardIndex}]=${arr[forwardIndex]}, forward[${forwardIndex-1}]+arr[${forwardIndex}]=${candidate}) = ${forward[forwardIndex]}`;
            addStep(`forward[${forwardIndex}] = max(${arr[forwardIndex]}, ${candidate}) = ${forward[forwardIndex]}`, true);
            
            // Highlight current and previous elements
            highlightElement(forwardIndex - 1, 'forward-sum-highlight', 1200);
            setTimeout(() => {
                highlightElement(forwardIndex, 'forward-sum-highlight', 800);
            }, 400);
            
            forwardIndex++;
            setTimeout(performForwardStep, 1800);
        }
    }
    
    function performBackwardStep() {
        if (backwardIndex < 0) {
            // Backward calculation complete
            backwardDPValue.textContent = `[${backward.join(', ')}]`;
            addStep(`Backward DP calculation complete: [${backward.join(', ')}]`, true);
            explanation.innerHTML = 'Both DP arrays calculated. Finding maximum subarray...';
            
            // Start finding maximum
            setTimeout(findMaximumSubarray, 1500);
            return;
        }
        
        if (backwardIndex === n - 1) {
            backward[n - 1] = arr[n - 1];
            explanation.innerHTML = `Calculating backward[${n-1}] = arr[${n-1}] = ${arr[n-1]}`;
            addStep(`backward[${n-1}] = arr[${n-1}] = ${arr[n-1]}`, true);
            
            highlightElement(n - 1, 'backward-sum-highlight');
            
            backwardIndex--;
            setTimeout(performBackwardStep, 1500);
        } else {
            const next = backward[backwardIndex + 1];
            const candidate = next + arr[backwardIndex];
            backward[backwardIndex] = Math.max(arr[backwardIndex], candidate);
            
            explanation.innerHTML = `Calculating backward[${backwardIndex}] = max(arr[${backwardIndex}]=${arr[backwardIndex]}, backward[${backwardIndex+1}]+arr[${backwardIndex}]=${candidate}) = ${backward[backwardIndex]}`;
            addStep(`backward[${backwardIndex}] = max(${arr[backwardIndex]}, ${candidate}) = ${backward[backwardIndex]}`, true);
            
            // Highlight current and next elements
            highlightElement(backwardIndex + 1, 'backward-sum-highlight', 1200);
            setTimeout(() => {
                highlightElement(backwardIndex, 'backward-sum-highlight', 800);
            }, 400);
            
            backwardIndex--;
            setTimeout(performBackwardStep, 1800);
        }
    }
    
    function findMaximumSubarray() {
        // Clear all highlights first
        elements.forEach(el => {
            const valueDiv = el.querySelector('.element-value');
            valueDiv.className = 'element-value';
        });
        
        // Step 1: Find maximum with no deletion
        explanation.innerHTML = 'Step 1: Finding maximum subarray with NO deletion...';
        
        let maxNoDeletion = forward[0];
        let maxNoDeletionIdx = 0;
        for (let i = 1; i < n; i++) {
            if (forward[i] > maxNoDeletion) {
                maxNoDeletion = forward[i];
                maxNoDeletionIdx = i;
            }
        }
        
        // Find the actual subarray for maxNoDeletion
        let start = maxNoDeletionIdx;
        let currentSum = arr[start];
        while (start > 0 && forward[start] === currentSum && forward[start-1] > 0) {
            start--;
            currentSum += arr[start];
        }
        
        addStep(`Maximum with NO deletion: ${maxNoDeletion} (indices ${start} to ${maxNoDeletionIdx})`, true);
        
        // Highlight the no-deletion subarray
        highlightSubarray(start, maxNoDeletionIdx, 'max-subarray-highlight', 2500);
        
        setTimeout(() => {
            // Step 2: Find maximum with one deletion
            explanation.innerHTML = 'Step 2: Finding maximum subarray with ONE deletion...';
            
            let maxWithDeletion = -Infinity;
            let bestDeleteIdx = -1;
            let bestLeftIdx = -1;
            let bestRightIdx = -1;
            
            // Check each possible deletion
            for (let i = 0; i < n; i++) {
                let leftMax = (i > 0) ? forward[i-1] : 0;
                let rightMax = (i < n-1) ? backward[i+1] : 0;
                let deletionSum = leftMax + rightMax;
                
                if (deletionSum > maxWithDeletion) {
                    maxWithDeletion = deletionSum;
                    bestDeleteIdx = i;
                    
                    // Find left subarray
                    bestLeftIdx = (i > 0) ? i-1 : -1;
                    if (bestLeftIdx !== -1) {
                        while (bestLeftIdx > 0 && forward[bestLeftIdx] === arr[bestLeftIdx] + forward[bestLeftIdx-1]) {
                            bestLeftIdx--;
                        }
                    }
                    
                    // Find right subarray
                    bestRightIdx = (i < n-1) ? i+1 : -1;
                    if (bestRightIdx !== -1) {
                        while (bestRightIdx < n-1 && backward[bestRightIdx] === arr[bestRightIdx] + backward[bestRightIdx+1]) {
                            bestRightIdx++;
                        }
                    }
                }
            }
            
            // Show element value with deletion
            const deleteValue = bestDeleteIdx !== -1 ? arr[bestDeleteIdx] : null;
            const deleteDisplay = bestDeleteIdx !== -1 ? `(delete ${deleteValue} at index ${bestDeleteIdx})` : '';
            addStep(`Maximum with ONE deletion: ${maxWithDeletion} ${deleteDisplay}`, true);
            
            // Clear highlights and show deletion subarray
            setTimeout(() => {
                elements.forEach(el => {
                    const valueDiv = el.querySelector('.element-value');
                    valueDiv.className = 'element-value';
                });
                
                if (bestDeleteIdx !== -1) {
                    // Highlight deleted element
                    highlightElement(bestDeleteIdx, 'deletion-highlight', 2000);
                    
                    // Highlight left subarray
                    if (bestLeftIdx !== -1) {
                        highlightSubarray(bestLeftIdx, bestDeleteIdx - 1, 'max-subarray-highlight', 0);
                    }
                    
                    // Highlight right subarray
                    if (bestRightIdx !== -1) {
                        setTimeout(() => {
                            highlightSubarray(bestDeleteIdx + 1, bestRightIdx, 'max-subarray-highlight', 0);
                        }, 800);
                    }
                }
                
                setTimeout(() => {
                    // Step 3: Compare both options
                    explanation.innerHTML = 'Step 3: Comparing both options...';
                    
                    const finalMax = Math.max(maxNoDeletion, maxWithDeletion);
                    let finalStart, finalEnd, finalDeleteIdx;
                    
                    if (finalMax === maxNoDeletion && maxNoDeletion >= maxWithDeletion) {
                        // No deletion is better or equal
                        finalStart = start;
                        finalEnd = maxNoDeletionIdx;
                        finalDeleteIdx = -1;
                        addStep(`NO deletion is better: ${maxNoDeletion} >= ${maxWithDeletion}`, true);
                    } else {
                        // Deletion is better
                        finalStart = bestLeftIdx;
                        finalEnd = bestRightIdx;
                        finalDeleteIdx = bestDeleteIdx;
                        addStep(`ONE deletion is better: ${maxWithDeletion} > ${maxNoDeletion}`, true);
                    }
                    
                    // Clear all highlights
                    elements.forEach(el => {
                        const valueDiv = el.querySelector('.element-value');
                        valueDiv.className = 'element-value';
                    });
                    
                    // Show final result
                    setTimeout(() => {
                        explanation.innerHTML = `<strong>Final Result:</strong> Maximum sum = ${finalMax}`;
                        
                        if (finalDeleteIdx !== -1) {
                            const deleteVal = arr[finalDeleteIdx];
                            addStep(`Optimal solution: Delete ${deleteVal} at index ${finalDeleteIdx}, take subarray [${finalStart}, ${finalEnd}]`, true);
                            
                            // Highlight deleted element
                            highlightElement(finalDeleteIdx, 'deletion-highlight', 0);
                            
                            // Highlight final subarray (excluding deleted element)
                            for (let i = finalStart; i <= finalEnd; i++) {
                                if (i !== finalDeleteIdx) {
                                    setTimeout(() => {
                                        elements[i].querySelector('.element-value').classList.add('max-subarray-highlight');
                                    }, (i - finalStart) * 300);
                                }
                            }
                        } else {
                            addStep(`Optimal solution: No deletion needed, subarray [${finalStart}, ${finalEnd}]`, true);
                            highlightSubarray(finalStart, finalEnd, 'max-subarray-highlight', 0);
                        }
                        
                        // Update result display
                        maxSumResult.textContent = finalMax;
                        optimalIndices.textContent = `${finalStart} to ${finalEnd}`;
                        deletedIndex.textContent = finalDeleteIdx === -1 ? 'None' : `${arr[finalDeleteIdx]} at index ${finalDeleteIdx}`;
                        
                        completeMaxSubarrayOperation(finalMax, finalStart, finalEnd, finalDeleteIdx);
                    }, 1500);
                }, 2500);
            }, 1500);
        }, 3000);
    }
    
    // Start the algorithm
    setTimeout(performForwardStep, 1000);
}

// NEW: Complete Maximum Subarray Operation
function completeMaxSubarrayOperation(maxSum, start, end, deleteIdx) {
    const continueButton = document.getElementById('continueAfterMaxSubarray');
    const explanation = document.getElementById('maxSubarrayExplanation');
    const arr = originalArrayForMaxSubarray.map(val => parseFloat(val));
    
    // Show element value with deletion in completion message
    const deleteDisplay = deleteIdx !== -1 ? `(deleted ${arr[deleteIdx]} at index ${deleteIdx})` : '(no deletion)';
    explanation.innerHTML = `<strong>Algorithm Completed!</strong> Maximum sum = ${maxSum} ${deleteDisplay}`;
    
    continueButton.style.display = 'block';
    
    // Auto-return after 20 seconds
    const autoReturnTimer = setTimeout(() => {
        returnToOriginalAfterMaxSubarray();
    }, 20000);
    
    continueButton.addEventListener('click', () => {
        clearTimeout(autoReturnTimer);
        returnToOriginalAfterMaxSubarray();
    });
}

// NEW: Return to Original after Maximum Subarray Operation
function returnToOriginalAfterMaxSubarray() {
    // Reset to original array
    myArray = [...originalArrayForMaxSubarray];
    originalArrayForMaxSubarray = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMaxSubarrayOneDeletionRunning = false;
    
    logOperation('Maximum subarray sum with one deletion operation completed', 'info');
    showNotification('Returned to original array after maximum subarray sum operation', 'success');
}
// NEW: Maximum Length of Pair Chain Handler
function handleMaxPairChain() {
    if (isPairChainRunning) {
        showNotification('Pair chain operation is already in progress', 'warning');
        return;
    }
    
    // Reset arrays
    pairArray = [];
    pairChainResults = [];
    
    // Show input group
    pairInputGroup.style.display = 'block';
    pairCountInput.focus();
    
    // Hide perform button initially
    performPairChainBtn.style.display = 'none';
    
    logOperation('Started maximum pair chain length operation', 'info');
    showNotification('Enter the number of pairs you want to analyze', 'info');
}

// NEW: Confirm Pair Count Handler
function handleConfirmPairCount() {
    const count = parseInt(pairCountInput.value);
    
    if (isNaN(count) || count < 1 || count > 20) {
        showNotification('Please enter a valid number between 1 and 20', 'danger');
        pairCountInput.focus();
        return;
    }
    
    // Create input fields for pairs
    pairsInputs.innerHTML = '<label class="form-label">Enter Pairs in format [a,b]:</label>';
    for (let i = 0; i < count; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Pair ${i + 1}</span>
            <input type="text" class="form-control pair-input" 
                   placeholder="[a,b] e.g., [1,2]" data-index="${i}">
        `;
        pairsInputs.appendChild(inputGroup);
    }
    
    // Add event listeners for pair inputs
    const pairInputs = pairsInputs.querySelectorAll('.pair-input');
    pairInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('pair-input')) {
                    nextInput.focus();
                }
            }
        });
    });
    
    // Show perform button
    performPairChainBtn.style.display = 'block';
    
    showNotification(`Enter ${count} pairs in the format [a,b] (e.g., [1,2])`, 'success');
    logOperation(`Number of pairs set to ${count}`, 'info');
}

// NEW: Perform Pair Chain Handler
// NEW: Maximum Length of Pair Chain Handler
function handleMaxPairChain() {
    if (isPairChainRunning) {
        showNotification('Pair chain operation is already in progress', 'warning');
        return;
    }
    
    // Reset arrays
    pairArray = [];
    pairChainResults = [];
    
    // Show input group
    pairInputGroup.style.display = 'block';
    pairCountInput.focus();
    
    // Hide perform button initially
    performPairChainBtn.style.display = 'none';
    
    logOperation('Started maximum pair chain length operation', 'info');
    showNotification('Enter the number of pairs you want to analyze. Negative numbers are allowed.', 'info');
}

// NEW: Confirm Pair Count Handler
function handleConfirmPairCount() {
    const count = parseInt(pairCountInput.value);
    
    if (isNaN(count) || count < 1 || count > 20) {
        showNotification('Please enter a valid number between 1 and 20', 'danger');
        pairCountInput.focus();
        return;
    }
    
    // Create input fields for pairs
    pairsInputs.innerHTML = '<label class="form-label">Enter Pairs in format [a,b]:</label>';
    for (let i = 0; i < count; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Pair ${i + 1}</span>
            <input type="text" class="form-control pair-input" 
                   placeholder="[a,b] e.g., [-1,2] or [1,2]" data-index="${i}">
        `;
        pairsInputs.appendChild(inputGroup);
    }
    
    // Add event listeners for pair inputs
    const pairInputs = pairsInputs.querySelectorAll('.pair-input');
    pairInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('pair-input')) {
                    nextInput.focus();
                }
            }
        });
    });
    
    // Show perform button
    performPairChainBtn.style.display = 'block';
    
    showNotification(`Enter ${count} pairs in the format [a,b] (e.g., [-1,2] or [1,2]) - Negative numbers allowed`, 'success');
    logOperation(`Number of pairs set to ${count}`, 'info');
}

// NEW: Perform Pair Chain Handler
function handlePerformPairChain() {
    // Collect pair inputs
    const pairInputs = document.querySelectorAll('.pair-input');
    pairArray = [];
    
    for (let i = 0; i < pairInputs.length; i++) {
        const input = pairInputs[i].value.trim();
        if (input === '') {
            showNotification(`Please enter all pairs. Missing pair at position ${i + 1}`, 'danger');
            pairInputs[i].focus();
            return;
        }
        
        // Parse pair input (format: [a,b]) - UPDATED TO ACCEPT NEGATIVE NUMBERS
        const match = input.match(/\[(-?\d+)\s*,\s*(-?\d+)\]/);
        if (!match) {
            showNotification(`Invalid format for pair ${i + 1}. Use format [a,b] where a and b can be negative (e.g., [-1,2] or [1,2])`, 'danger');
            pairInputs[i].focus();
            return;
        }
        
        const a = parseInt(match[1]);
        const b = parseInt(match[2]);
        
        if (a >= b) {
            showNotification(`For pair ${i + 1}: a (${a}) must be less than b (${b})`, 'danger');
            pairInputs[i].focus();
            return;
        }
        
        pairArray.push([a, b]);
    }
    
    if (pairArray.length === 0) {
        showNotification('No valid pairs entered', 'warning');
        return;
    }
    
    // Store original array
    originalArrayForPairChain = [...myArray];
    
    // Hide input group
    pairInputGroup.style.display = 'none';
    
    // Start pair chain visualization
    showPairChainVisualization();
}

// NEW: Cancel Pair Chain Handler
function handleCancelPairChain() {
    pairInputGroup.style.display = 'none';
    pairCountInput.value = '';
    pairsInputs.innerHTML = '';
    performPairChainBtn.style.display = 'none';
    
    pairArray = [];
    pairChainResults = [];
    
    logOperation('Cancelled pair chain operation', 'info');
    showNotification('Pair chain operation cancelled', 'info');
}

// NEW: Show Pair Chain Visualization
function showPairChainVisualization() {
    isPairChainRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Maximum Length of Pair Chain</h5>
        
        <div class="mb-3">
            <div class="array-label">Input Pairs</div>
            <div class="pair-container" id="pairContainer"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Dynamic Programming approach to find longest chain where b < c in [a,b] and [c,d]</p>
            <p class="mb-2"><strong>Note:</strong> Both a and b can be negative numbers. Only requirement: a < b</p>
            <p class="mb-0" id="pairChainExplanation">Initializing algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="pairChainStepsContainer">
            <h6 class="text-center">Dynamic Programming Steps</h6>
            <div class="steps-container" id="pairChainSteps"></div>
        </div>
        
        <div class="table-container mt-3">
            <table class="pair-table">
                <thead>
                    <tr>
                        <th>Pair</th>
                        <th>DP Value</th>
                        <th>Chain</th>
                    </tr>
                </thead>
                <tbody id="dpTableBody"></tbody>
            </table>
        </div>
        
        <div class="stats-card mt-3">
            <div>Maximum Chain Length</div>
            <div class="stats-value" id="maxChainLength">0</div>
        </div>
        
        <div class="mb-3" id="chainVisualizationContainer" style="display: none;">
            <div class="array-label">Longest Chain Found</div>
            <div class="pair-chain-container" id="longestChainContainer"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPairChain" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display the input pairs
    renderPairs(pairArray);
    
    // Start DP algorithm animation
    performPairChainAlgorithm();
}

// NEW: Render Pairs Function
function renderPairs(pairs) {
    const container = document.getElementById('pairContainer');
    container.innerHTML = '';
    
    pairs.forEach((pair, index) => {
        const pairElement = document.createElement('div');
        pairElement.className = 'pair-element';
        pairElement.dataset.index = index;
        pairElement.innerHTML = `
            <div class="pair-value">[${pair[0]}, ${pair[1]}]</div>
            <div class="pair-index">Pair ${index}</div>
        `;
        container.appendChild(pairElement);
    });
}

// NEW: Perform Pair Chain Algorithm with Animation
function performPairChainAlgorithm() {
    const explanation = document.getElementById('pairChainExplanation');
    const stepsContainer = document.getElementById('pairChainSteps');
    const dpTableBody = document.getElementById('dpTableBody');
    const maxChainLength = document.getElementById('maxChainLength');
    const chainVisualizationContainer = document.getElementById('chainVisualizationContainer');
    const longestChainContainer = document.getElementById('longestChainContainer');
    const continueButton = document.getElementById('continueAfterPairChain');
    
    // Create a copy of pairs and sort by first element
    const pairs = [...pairArray];
    
    // Step 1: Sort pairs by first element
    explanation.innerHTML = 'Step 1: Sorting pairs by first element...';
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Step 1:</strong> Sorting pairs by first element (a)
        </div>
    `;
    
    // Highlight all pairs
    const pairElements = document.querySelectorAll('.pair-element');
    pairElements.forEach(el => {
        el.classList.add('pair-active');
    });
    
    setTimeout(() => {
        // Sort the pairs
        pairs.sort((a, b) => a[0] - b[0]);
        
        // Update display with sorted pairs
        renderPairs(pairs);
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step 1 Complete:</strong> Pairs sorted: ${pairs.map(p => `[${p[0]},${p[1]}]`).join(', ')}
            </div>
        `;
        
        // Remove highlights
        pairElements.forEach(el => {
            el.classList.remove('pair-active');
        });
        
        // Initialize DP table
        const n = pairs.length;
        const dp = new Array(n).fill(1);
        const chains = new Array(n).fill([]);
        
        // Initialize table display
        dpTableBody.innerHTML = '';
        for (let i = 0; i < n; i++) {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>[${pairs[i][0]}, ${pairs[i][1]}]</td>
                <td class="dp-cell-${i}">1</td>
                <td class="chain-cell-${i}">[${pairs[i][0]},${pairs[i][1]}]</td>
            `;
            dpTableBody.appendChild(row);
        }
        
        explanation.innerHTML = 'Step 2: Initialized DP array with all 1s';
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step 2:</strong> Initialize DP array: dp = [${dp.join(', ')}]
            </div>
        `;
        
        // Highlight all DP cells
        for (let i = 0; i < n; i++) {
            const cell = document.querySelector(`.dp-cell-${i}`);
            cell.classList.add('dp-highlight');
        }
        
        setTimeout(() => {
            // Remove initial highlights
            for (let i = 0; i < n; i++) {
                const cell = document.querySelector(`.dp-cell-${i}`);
                cell.classList.remove('dp-highlight');
            }
            
            // Start DP computation
            performDPComputation(pairs, dp, chains, 0);
        }, 1500);
    }, 2000);
    
    // NEW: Perform DP Computation with Animation
    function performDPComputation(pairs, dp, chains, i) {
        if (i >= pairs.length) {
            // DP computation completed
            const maxLength = Math.max(...dp);
            const maxIndex = dp.indexOf(maxLength);
            
            explanation.innerHTML = `<strong>DP Computation Completed!</strong> Maximum chain length found.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final Step:</strong> DP computation completed. Maximum value = ${maxLength}
                </div>
            `;
            
            // Highlight the maximum value
            const maxCell = document.querySelector(`.dp-cell-${maxIndex}`);
            maxCell.classList.add('chain-highlight');
            
            maxChainLength.textContent = maxLength;
            
            // Show longest chain
            showLongestChain(pairs, dp, maxIndex);
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterPairChain();
            }, 20000);
            
            continueButton.style.display = 'block';
            continueButton.addEventListener('click', returnToOriginalAfterPairChain);
            
            return;
        }
        
        if (i === 0) {
            // First element
            explanation.innerHTML = `Starting DP computation...`;
            setTimeout(() => {
                performDPComputation(pairs, dp, chains, i + 1);
            }, 1000);
            return;
        }
        
        explanation.innerHTML = `Computing dp[${i}] for pair [${pairs[i][0]},${pairs[i][1]}]`;
        
        // Highlight current pair
        const currentPairElement = document.querySelector(`.pair-element[data-index="${i}"]`);
        currentPairElement.classList.add('pair-chain-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${i + 2}:</strong> Computing dp[${i}] for pair [${pairs[i][0]},${pairs[i][1]}]
            </div>
        `;
        
        setTimeout(() => {
            let bestChain = [pairs[i]];
            let bestLength = 1;
            
            // Check all previous pairs
            performPreviousPairsCheck(pairs, dp, chains, i, 0, bestChain, bestLength);
        }, 1500);
    }
    
    // NEW: Check Previous Pairs with Animation
    function performPreviousPairsCheck(pairs, dp, chains, i, j, bestChain, bestLength) {
        if (j >= i) {
            // All previous pairs checked
            dp[i] = bestLength;
            chains[i] = bestChain;
            
            // Update DP table
            const dpCell = document.querySelector(`.dp-cell-${i}`);
            const chainCell = document.querySelector(`.chain-cell-${i}`);
            
            dpCell.textContent = bestLength;
            dpCell.classList.add('dp-highlight');
            
            chainCell.textContent = bestChain.map(p => `[${p[0]},${p[1]}]`).join('  ');
            chainCell.classList.add('chain-highlight');
            
            explanation.innerHTML = `dp[${i}] = ${bestLength}, Chain: ${bestChain.map(p => `[${p[0]},${p[1]}]`).join('  ')}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Result:</strong> dp[${i}] = ${bestLength} (Chain length)
                </div>
            `;
            
            // Remove current pair highlight
            const currentPairElement = document.querySelector(`.pair-element[data-index="${i}"]`);
            currentPairElement.classList.remove('pair-chain-current');
            
            setTimeout(() => {
                // Remove highlights
                dpCell.classList.remove('dp-highlight');
                chainCell.classList.remove('chain-highlight');
                
                // Move to next i
                performDPComputation(pairs, dp, chains, i + 1);
            }, 2000);
            
            return;
        }
        
        explanation.innerHTML = `Checking if pair [${pairs[j][0]},${pairs[j][1]}] can chain with [${pairs[i][0]},${pairs[i][1]}]`;
        
        // Highlight both pairs being compared
        const pairJElement = document.querySelector(`.pair-element[data-index="${j}"]`);
        const pairIElement = document.querySelector(`.pair-element[data-index="${i}"]`);
        
        pairJElement.classList.add('pair-chain-compatible');
        pairIElement.classList.add('pair-chain-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Check:</strong> Compare [${pairs[j][0]},${pairs[j][1]}] with [${pairs[i][0]},${pairs[i][1]}]
                - Checking if ${pairs[j][1]} < ${pairs[i][0]}
            </div>
        `;
        
        setTimeout(() => {
            // Check compatibility condition: b < c where [a,b] is pair j and [c,d] is pair i
            if (pairs[j][1] < pairs[i][0]) {
                // They can chain!
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong> Compatible:</strong> ${pairs[j][1]} < ${pairs[i][0]} - Can chain!
                        Current dp[${j}] = ${dp[j]}, New chain length would be ${dp[j] + 1}
                    </div>
                `;
                
                // Highlight compatible connection
                pairJElement.classList.remove('pair-chain-compatible');
                pairJElement.classList.add('pair-chain-included');
                
                if (dp[j] + 1 > bestLength) {
                    bestLength = dp[j] + 1;
                    bestChain = [...chains[j], pairs[i]];
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>New Best:</strong> Updated chain length to ${bestLength}
                        </div>
                    `;
                }
                
                setTimeout(() => {
                    pairJElement.classList.remove('pair-chain-included');
                    performPreviousPairsCheck(pairs, dp, chains, i, j + 1, bestChain, bestLength);
                }, 1500);
            } else {
                // Cannot chain
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong> Not Compatible:</strong> ${pairs[j][1]} >= ${pairs[i][0]} - Cannot chain
                    </div>
                `;
                
                pairJElement.classList.remove('pair-chain-compatible');
                
                setTimeout(() => {
                    performPreviousPairsCheck(pairs, dp, chains, i, j + 1, bestChain, bestLength);
                }, 1000);
            }
        }, 1500);
    }
}

// NEW: Show Longest Chain Visualization
function showLongestChain(pairs, dp, maxIndex) {
    const chainVisualizationContainer = document.getElementById('chainVisualizationContainer');
    const longestChainContainer = document.getElementById('longestChainContainer');
    
    // Find the longest chain by backtracking
    let maxLength = Math.max(...dp);
    let chain = [];
    
    // Backtrack to find the chain
    for (let i = maxIndex; i >= 0 && maxLength > 0; i--) {
        if (dp[i] === maxLength) {
            chain.unshift(pairs[i]);
            maxLength--;
        }
    }
    
    // Show the visualization container
    chainVisualizationContainer.style.display = 'block';
    
    // Display the chain
    longestChainContainer.innerHTML = '';
    
    chain.forEach((pair, index) => {
        const pairElement = document.createElement('div');
        pairElement.className = 'pair-element pair-chain-included';
        pairElement.innerHTML = `
            <div class="pair-value">[${pair[0]}, ${pair[1]}]</div>
            <div class="pair-index">Step ${index + 1}</div>
        `;
        longestChainContainer.appendChild(pairElement);
        
        // Add connector arrow if not the last element
        if (index < chain.length - 1) {
            const connector = document.createElement('div');
            connector.className = 'pair-connector';
            connector.innerHTML = '<i class="fas fa-arrow-right"></i>';
            longestChainContainer.appendChild(connector);
            
            // Add animated line
            const line = document.createElement('div');
            line.className = 'pair-chain-line';
            longestChainContainer.appendChild(line);
        }
    });
    
    const explanation = document.getElementById('pairChainExplanation');
    explanation.innerHTML = `<strong>Longest Chain Found:</strong> ${chain.length} pairs: ${chain.map(p => `[${p[0]},${p[1]}]`).join('  ')}`;
}

// NEW: Return to Original after Pair Chain
function returnToOriginalAfterPairChain() {
    // Reset to original array
    myArray = [...originalArrayForPairChain];
    originalArrayForPairChain = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isPairChainRunning = false;
    
    // Clear all pair-related data
    pairArray = [];
    pairChainResults = [];
    
    // Reset input groups
    pairInputGroup.style.display = 'none';
    pairCountInput.value = '';
    pairsInputs.innerHTML = '';
    performPairChainBtn.style.display = 'none';
    
    logOperation('Pair chain operation completed - returned to original array', 'info');
    showNotification('Returned to original array after pair chain operation', 'success');
}
// Helper function to render array in specific container
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = '<div class="array-empty-state">No elements to display</div>';
        return;
    }
    
    array.forEach((value, index) => {
        const elementDiv = document.createElement('div');
        elementDiv.className = 'array-element slide-in';
        elementDiv.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(elementDiv);
    });
}
// NEW: Arithmetic Slices Handler
function handleArithmeticSlices() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length < 3) {
        showNotification('Array must have at least 3 elements for arithmetic slices', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Arithmetic slices require all array elements to be numbers', 'danger');
        return;
    }
    
    if (isArithmeticSlicesRunning) {
        showNotification('Arithmetic slices operation is already in progress', 'warning');
        return;
    }
    
    isArithmeticSlicesRunning = true;
    
    // Store original array
    originalArrayForArithmetic = [...myArray];
    
    // Show arithmetic slices visualization
    showArithmeticSlicesVisualization();
}
// NEW: Show Arithmetic Slices Visualization
function showArithmeticSlicesVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Arithmetic Slices Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalArithmeticArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Arithmetic Slices:</strong> Find all contiguous subarrays with at least 3 elements where the difference between consecutive elements is constant</p>
            <p class="mb-0" id="arithmeticExplanation">Initializing arithmetic slices algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="arithmeticStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="arithmeticSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Total Arithmetic Slices Found</div>
            <div class="stats-value" id="arithmeticSlicesCount">0</div>
        </div>
        
        <div class="arithmetic-results mt-3" id="arithmeticResults" style="display: none;">
            <h6 class="text-center">Arithmetic Slices Found</h6>
            <div id="arithmeticSlicesList" class="mt-2"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterArithmetic" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForArithmetic, 'originalArithmeticArray');
    
    performArithmeticSlicesAlgorithm();
}
// NEW: Perform Arithmetic Slices Algorithm with Animation
function performArithmeticSlicesAlgorithm() {
    const arrayContainer = document.getElementById('originalArithmeticArray');
    const explanation = document.getElementById('arithmeticExplanation');
    const stepsContainer = document.getElementById('arithmeticSteps');
    const arithmeticSlicesCount = document.getElementById('arithmeticSlicesCount');
    const arithmeticResults = document.getElementById('arithmeticResults');
    const arithmeticSlicesList = document.getElementById('arithmeticSlicesList');
    const continueButton = document.getElementById('continueAfterArithmetic');
    
    const arr = originalArrayForArithmetic.map(val => parseFloat(val));
    const n = arr.length;
    let totalSlices = 0;
    let currentLength = 2; // Start with 2 elements
    let allSlices = [];
    let currentSliceStart = 0;
    let step = 0;
    
    // Clear results
    arithmeticSlicesList.innerHTML = '';
    
    function performAlgorithmStep(i) {
        if (i >= n) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Found ${totalSlices} arithmetic slices.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Total arithmetic slices = ${totalSlices}
                </div>
            `;
            
            arithmeticSlicesCount.textContent = totalSlices;
            
            // Show all found slices
            if (totalSlices > 0) {
                arithmeticResults.style.display = 'block';
                
                // Group slices by length for better display
                const groupedSlices = {};
                allSlices.forEach(slice => {
                    const length = slice.end - slice.start + 1;
                    if (!groupedSlices[length]) {
                        groupedSlices[length] = [];
                    }
                    groupedSlices[length].push(slice);
                });
                
                // Display grouped slices
                Object.keys(groupedSlices).sort((a, b) => b - a).forEach(length => {
                    const slices = groupedSlices[length];
                    const sliceGroup = document.createElement('div');
                    sliceGroup.className = 'mb-3';
                    sliceGroup.innerHTML = `<strong>Length ${length} slices (${slices.length}):</strong>`;
                    
                    slices.forEach((slice, idx) => {
                        const sliceValues = arr.slice(slice.start, slice.end + 1);
                        const sliceElement = document.createElement('div');
                        sliceElement.className = 'arithmetic-slice-item d-inline-block';
                        sliceElement.textContent = `[${sliceValues.join(', ')}]`;
                        sliceElement.title = `Indices: ${slice.start} to ${slice.end}`;
                        sliceElement.style.cursor = 'pointer';
                        
                        // Add click to highlight the slice
                        sliceElement.addEventListener('click', () => {
                            highlightArithmeticSlice(slice.start, slice.end);
                        });
                        
                        sliceGroup.appendChild(sliceElement);
                        if (idx < slices.length - 1) {
                            sliceGroup.appendChild(document.createTextNode(' '));
                        }
                    });
                    
                    arithmeticSlicesList.appendChild(sliceGroup);
                });
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterArithmetic();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterArithmetic);
            
            return;
        }
        
        step++;
        
        if (i < 2) {
            // Initialize steps
            if (i === 0) {
                explanation.innerHTML = `Step ${step}: Initialize algorithm. Array has ${n} elements.`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step}:</strong> Starting arithmetic slices detection
                    </div>
                `;
                
                // Highlight first two elements
                const elements = arrayContainer.querySelectorAll('.array-element');
                elements[0].querySelector('.element-value').classList.add('arithmetic-slice-start');
                elements[1].querySelector('.element-value').classList.add('arithmetic-slice-middle');
                
                setTimeout(() => {
                    performAlgorithmStep(i + 1);
                }, 1000);
                
            } else if (i === 1) {
                explanation.innerHTML = `Step ${step}: Need at least 3 elements for arithmetic slices.`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step}:</strong> Minimum 3 elements required for arithmetic slices
                    </div>
                `;
                
                setTimeout(() => {
                    performAlgorithmStep(i + 1);
                }, 1000);
            }
            
            return;
        }
        
        // Check if current three elements form an arithmetic sequence
        const diff1 = arr[i-1] - arr[i-2];
        const diff2 = arr[i] - arr[i-1];
        const isArithmetic = diff1 === diff2;
        
        // Highlight the three elements being checked
        const elements = arrayContainer.querySelectorAll('.array-element');
        
        // Clear previous current highlights
        elements.forEach(el => {
            el.querySelector('.element-value').classList.remove('arithmetic-slice-current');
        });
        
        // Highlight current three elements
        for (let j = i-2; j <= i; j++) {
            const element = elements[j].querySelector('.element-value');
            if (j === i-2) element.classList.add('arithmetic-slice-start');
            if (j === i-1) element.classList.add('arithmetic-slice-middle');
            if (j === i) element.classList.add('arithmetic-slice-end');
        }
        
        elements[i].querySelector('.element-value').classList.add('arithmetic-slice-current');
        
        explanation.innerHTML = `Step ${step}: Checking indices ${i-2}, ${i-1}, ${i}: differences ${diff1} and ${diff2}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${isArithmetic ? 'active' : ''}">
                <strong>Step ${step}:</strong> Check arr[${i-2}]=${arr[i-2]}, arr[${i-1}]=${arr[i-1]}, arr[${i}]=${arr[i]}<br>
                Difference1: ${arr[i-1]} - ${arr[i-2]} = ${diff1}<br>
                Difference2: ${arr[i]} - ${arr[i-1]} = ${diff2}<br>
                ${isArithmetic ? ' Arithmetic sequence found!' : ' Not arithmetic'}
            </div>
        `;
        
        setTimeout(() => {
            if (isArithmetic) {
                // Extend the arithmetic sequence
                currentLength++;
                
                // For each new element added, it creates (currentLength - 2) new arithmetic slices
                const newSlices = currentLength - 2;
                totalSlices += newSlices;
                
                // Add all new slices to the list
                for (let start = i - currentLength + 1; start <= i - 2; start++) {
                    const slice = { start: start, end: i };
                    allSlices.push(slice);
                    
                    // Highlight the slice
                    highlightArithmeticSliceTemporarily(start, i);
                }
                
                explanation.innerHTML = `Step ${step}: Extended arithmetic sequence to length ${currentLength}. Added ${newSlices} new slices.`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Extended:</strong> Sequence length: ${currentLength}, New slices: ${newSlices}, Total: ${totalSlices}
                    </div>
                `;
                
                // Highlight that the difference matches
                elements[i-1].querySelector('.element-value').classList.add('arithmetic-difference-match');
                elements[i].querySelector('.element-value').classList.add('arithmetic-difference-match');
                
            } else {
                // Reset the sequence
                if (currentLength >= 3) {
                    explanation.innerHTML = `Step ${step}: Arithmetic sequence ended. Length was ${currentLength}.`;
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Sequence ended:</strong> Previous sequence length was ${currentLength}
                        </div>
                    `;
                }
                
                currentLength = 2;
                currentSliceStart = i - 1;
                
                // Reset highlights
                for (let j = 0; j <= i; j++) {
                    const element = elements[j].querySelector('.element-value');
                    element.classList.remove('arithmetic-slice-start', 'arithmetic-slice-middle', 
                                          'arithmetic-slice-end', 'arithmetic-slice-current',
                                          'arithmetic-difference-match');
                }
                
                // Set new starting point
                elements[i-1].querySelector('.element-value').classList.add('arithmetic-slice-start');
                elements[i].querySelector('.element-value').classList.add('arithmetic-slice-middle');
            }
            
            arithmeticSlicesCount.textContent = totalSlices;
            
            // Continue to next element
            performAlgorithmStep(i + 1);
        }, 2000);
    }
    
    // Helper function to temporarily highlight a slice
    function highlightArithmeticSliceTemporarily(start, end) {
        const elements = arrayContainer.querySelectorAll('.array-element');
        
        for (let j = start; j <= end; j++) {
            elements[j].querySelector('.element-value').classList.add('arithmetic-slice-end');
        }
        
        setTimeout(() => {
            for (let j = start; j <= end; j++) {
                elements[j].querySelector('.element-value').classList.remove('arithmetic-slice-end');
            }
        }, 500);
    }
    
    // Helper function to highlight a slice on click
    function highlightArithmeticSlice(start, end) {
        const elements = arrayContainer.querySelectorAll('.array-element');
        
        // Clear all highlights first
        elements.forEach(el => {
            el.querySelector('.element-value').classList.remove('arithmetic-slice-start', 
                                                               'arithmetic-slice-middle',
                                                               'arithmetic-slice-end');
        });
        
        // Highlight the selected slice
        for (let j = start; j <= end; j++) {
            const element = elements[j].querySelector('.element-value');
            if (j === start) element.classList.add('arithmetic-slice-start');
            else if (j === end) element.classList.add('arithmetic-slice-end');
            else element.classList.add('arithmetic-slice-middle');
        }
        
        explanation.innerHTML = `Showing arithmetic slice [${start}..${end}]: [${arr.slice(start, end + 1).join(', ')}]`;
    }
    
    // Start the algorithm
    performAlgorithmStep(0);
}
// NEW: Return to Original after Arithmetic Slices
function returnToOriginalAfterArithmetic() {
    // Reset to original array
    myArray = [...originalArrayForArithmetic];
    originalArrayForArithmetic = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isArithmeticSlicesRunning = false;
    
    logOperation('Arithmetic slices operation completed - returned to original array', 'info');
    showNotification('Returned to original array after arithmetic slices operation', 'success');
}
// Helper function to render array in a specific container
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (array.length === 0) {
        const emptyState = document.createElement('div');
        emptyState.className = 'array-empty-state';
        emptyState.innerHTML = `
            <i class="fas fa-layer-group"></i>
            <h4>Array is Empty</h4>
            <p>No elements to display</p>
        `;
        container.appendChild(emptyState);
        return;
    }
    
    array.forEach((value, index) => {
        const elementDiv = document.createElement('div');
        elementDiv.className = 'array-element';
        
        const valueDiv = document.createElement('div');
        valueDiv.className = 'element-value';
        valueDiv.textContent = value;
        
        const indexDiv = document.createElement('div');
        indexDiv.className = 'element-index';
        indexDiv.textContent = `[${index}]`;
        
        elementDiv.appendChild(valueDiv);
        elementDiv.appendChild(indexDiv);
        container.appendChild(elementDiv);
    });
}
// NEW: Unique Paths Handler
function handleUniquePaths() {
    if (isUniquePathsRunning) {
        showNotification('Unique Paths operation is already in progress', 'warning');
        return;
    }
    
    // Show input group
    uniquePathsInputGroup.style.display = 'block';
    gridRows.focus();
    
    logOperation('Started Unique Paths DP visualization', 'info');
}

// NEW: Confirm Unique Paths Handler
function handleConfirmUniquePaths() {
    const rows = parseInt(gridRows.value);
    const cols = parseInt(gridCols.value);
    
    if (isNaN(rows) || rows < 1 || rows > 10) {
        showNotification('Please enter valid number of rows (1-10)', 'danger');
        gridRows.focus();
        return;
    }
    
    if (isNaN(cols) || cols < 1 || cols > 10) {
        showNotification('Please enter valid number of columns (1-10)', 'danger');
        gridCols.focus();
        return;
    }
    
    // Hide input group
    uniquePathsInputGroup.style.display = 'none';
    gridRows.value = '';
    gridCols.value = '';
    
    // Start unique paths visualization
    showUniquePathsVisualization(rows, cols);
}

// NEW: Cancel Unique Paths Handler
function handleCancelUniquePaths() {
    uniquePathsInputGroup.style.display = 'none';
    gridRows.value = '';
    gridCols.value = '';
    
    logOperation('Cancelled Unique Paths operation', 'info');
}

// NEW: Show Unique Paths Visualization
function showUniquePathsVisualization(m, n) {
    isUniquePathsRunning = true;
    
    const container = document.createElement('div');
    container.className = 'unique-paths-container';
    container.innerHTML = `
        <h4 class="text-center mb-4 title-animation">Unique Paths DP Visualization</h4>
        
        <div class="unique-paths-stats">
            <div class="stats-item">
                <div class="stats-label">Grid Size</div>
                <div class="stats-value">${m}${n}</div>
            </div>
            <div class="stats-item">
                <div class="stats-label">Current Row</div>
                <div class="stats-value" id="currentRow">0</div>
            </div>
            <div class="stats-item">
                <div class="stats-label">Current Column</div>
                <div class="stats-value" id="currentCol">0</div>
            </div>
        </div>
        
        <div class="dp-explanation">
            <h5>1D DP Array Approach</h5>
            <p class="mb-2">dp[j] = number of ways to reach current row, column j</p>
            <p class="mb-2"><strong>Recurrence:</strong> dp[j] = dp[j] (from above) + dp[j-1] (from left)</p>
            <p class="mb-0" id="dpExplanation">Initializing DP array for first row...</p>
        </div>
        
        <div class="dp-array-container" id="dpArrayContainer">
            <!-- DP array elements will be inserted here -->
        </div>
        
        <div class="grid-container" id="gridContainer" style="grid-template-columns: repeat(${n}, 1fr);">
            <!-- Grid cells will be inserted here -->
        </div>
        
        <div class="path-visualization" id="pathVisualization">
            <h6>Path Tracing</h6>
            <div id="pathSteps"></div>
        </div>
        
        <div class="algorithm-steps mt-3" id="algorithmStepsContainer">
            <h6 class="text-center">DP Algorithm Steps</h6>
            <div class="steps-container" id="algorithmSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Total Unique Paths</div>
            <div class="stats-value" id="totalPaths">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="autoReturnBtn">
            <i class="fas fa-history me-1"></i>Return to Original Array (Auto in 20s)
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(container);
    
    // Initialize DP array visualization
    initializeDPArray(n);
    
    // Initialize grid visualization
    initializeGrid(m, n);
    
    // Start the DP algorithm animation
    startDPAlgorithm(m, n);
    
    // Setup auto-return timer
    setupAutoReturnTimer();
}

// NEW: Initialize DP Array
function initializeDPArray(n) {
    const dpContainer = document.getElementById('dpArrayContainer');
    dpContainer.innerHTML = '<h6 class="text-center w-100">DP Array (1D)</h6>';
    
    for (let j = 0; j < n; j++) {
        const dpElement = document.createElement('div');
        dpElement.className = 'dp-array-element';
        dpElement.innerHTML = `
            <div class="dp-index">dp[${j}]</div>
            <div class="dp-value" id="dpValue${j}">1</div>
        `;
        dpContainer.appendChild(dpElement);
    }
}

// NEW: Initialize Grid
function initializeGrid(m, n) {
    const gridContainer = document.getElementById('gridContainer');
    gridContainer.innerHTML = '';
    
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            const cell = document.createElement('div');
            cell.className = 'grid-cell';
            cell.id = `cell-${i}-${j}`;
            cell.innerHTML = `(${i},${j})`;
            
            if (i === 0 && j === 0) {
                cell.classList.add('start-cell');
                cell.innerHTML = 'START';
            } else if (i === m - 1 && j === n - 1) {
                cell.classList.add('end-cell');
                cell.innerHTML = 'END';
            } else if (i === 0 || j === 0) {
                cell.classList.add('path-count');
                cell.innerHTML = '1 way';
            }
            
            gridContainer.appendChild(cell);
        }
    }
}

// NEW: Start DP Algorithm Animation
function startDPAlgorithm(m, n) {
    const dpValues = Array(n).fill(1); // Initialize DP array
    const totalPathsElement = document.getElementById('totalPaths');
    const currentRowElement = document.getElementById('currentRow');
    const currentColElement = document.getElementById('currentCol');
    const dpExplanation = document.getElementById('dpExplanation');
    const pathSteps = document.getElementById('pathSteps');
    const algorithmSteps = document.getElementById('algorithmSteps');
    const autoReturnBtn = document.getElementById('autoReturnBtn');
    
    let stepDelay = 1500; // Delay between steps in milliseconds
    let currentStep = 0;
    
    // Update initial state
    updateDPArrayDisplay(dpValues);
    totalPathsElement.textContent = dpValues[n - 1];
    
    // Show initial explanation
    dpExplanation.innerHTML = `<strong>Initial state (row 0):</strong> dp = [${dpValues.join(', ')}]`;
    algorithmSteps.innerHTML = `
        <div class="algorithm-step active">
            <strong>Step 0:</strong> Initialize DP array for first row
        </div>
        <div class="algorithm-step">
            <strong>Step 0:</strong> dp[j] = 1 for all j (only right moves possible in first row)
        </div>
    `;
    
    // Highlight first row in grid
    highlightGridRow(0, n, 'above-cell');
    
    function executeAlgorithmStep(i, j) {
        if (i >= m) {
            // Algorithm completed
            dpExplanation.innerHTML = `<strong>Algorithm Completed!</strong> Total unique paths = ${dpValues[n - 1]}`;
            
            algorithmSteps.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Total unique paths to (${m-1},${n-1}) = ${dpValues[n - 1]}
                </div>
            `;
            
            // Show combinatorial formula verification
            const combFormula = `C(${m + n - 2}, ${n - 1}) = ${combination(m + n - 2, n - 1)}`;
            algorithmSteps.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Verification:</strong> Combinatorial formula ${combFormula}
                </div>
            `;
            
            // Highlight the final path
            highlightAllPaths(m, n, dpValues);
            
            // Enable auto-return button
            autoReturnBtn.addEventListener('click', returnToOriginalAfterUniquePaths);
            
            return;
        }
        
        currentStep++;
        
        if (i === 0) {
            // First row is already initialized
            setTimeout(() => {
                // Move to next row
                currentRowElement.textContent = i + 1;
                executeAlgorithmStep(i + 1, 1);
            }, stepDelay);
            return;
        }
        
        if (j >= n) {
            // Row completed, move to next row
            dpExplanation.innerHTML = `<strong>Row ${i} completed:</strong> dp = [${dpValues.join(', ')}]`;
            algorithmSteps.innerHTML += `
                <div class="algorithm-step">
                    <strong>Row ${i} complete:</strong> DP array updated
                </div>
            `;
            
            // Update grid for completed row
            highlightGridRow(i, n, 'current-cell');
            
            setTimeout(() => {
                if (i + 1 < m) {
                    currentRowElement.textContent = i + 1;
                    currentColElement.textContent = 0;
                    executeAlgorithmStep(i + 1, 1);
                } else {
                    executeAlgorithmStep(i + 1, 0); // Signal completion
                }
            }, stepDelay);
            
            return;
        }
        
        // Update current cell information
        currentRowElement.textContent = i;
        currentColElement.textContent = j;
        
        // Highlight current grid cell
        highlightGridCell(i, j);
        
        // Show DP formula explanation
        const fromAbove = dpValues[j];
        const fromLeft = dpValues[j - 1];
        const newValue = fromAbove + fromLeft;
        
        dpExplanation.innerHTML = `
            <strong>Processing cell (${i},${j}):</strong><br>
            dp[${j}] = ${fromAbove}(from above) + ${fromLeft}(from left) = ${newValue}
        `;
        
        // Add to algorithm steps
        algorithmSteps.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentStep}:</strong> dp[${j}] = ${fromAbove}(above) + ${fromLeft}(left) = ${newValue}
            </div>
        `;
        
        // Scroll steps container
        algorithmSteps.scrollTop = algorithmSteps.scrollHeight;
        
        // Show path visualization
        showPathStep(i, j, fromAbove, fromLeft, newValue);
        
        // Highlight DP array elements being used
        highlightDPElements(j, j - 1);
        
        setTimeout(() => {
            // Update DP value
            dpValues[j] = newValue;
            
            // Update DP array display
            updateDPArrayDisplay(dpValues);
            
            // Highlight updated DP element
            highlightUpdatedDPElement(j);
            
            // Update total paths display
            totalPathsElement.textContent = dpValues[n - 1];
            
            // Update grid cell with path count
            updateGridCell(i, j, newValue);
            
            // Move to next column
            setTimeout(() => {
                executeAlgorithmStep(i, j + 1);
            }, stepDelay);
            
        }, stepDelay);
    }
    
    // Start algorithm execution
    setTimeout(() => {
        executeAlgorithmStep(0, 0);
    }, 1000);
}

// NEW: Update DP Array Display
function updateDPArrayDisplay(dpValues) {
    for (let j = 0; j < dpValues.length; j++) {
        const dpValueElement = document.getElementById(`dpValue${j}`);
        if (dpValueElement) {
            dpValueElement.textContent = dpValues[j];
        }
    }
}

// NEW: Highlight Grid Row
function highlightGridRow(row, cols, className) {
    for (let j = 0; j < cols; j++) {
        const cell = document.getElementById(`cell-${row}-${j}`);
        if (cell) {
            cell.classList.add(className);
            setTimeout(() => {
                cell.classList.remove(className);
            }, 1000);
        }
    }
}

// NEW: Highlight Grid Cell
function highlightGridCell(i, j) {
    // Remove previous highlights
    document.querySelectorAll('.grid-cell.current-cell').forEach(cell => {
        cell.classList.remove('current-cell');
    });
    
    const cell = document.getElementById(`cell-${i}-${j}`);
    if (cell) {
        cell.classList.add('current-cell');
        
        // Also highlight above and left cells
        if (i > 0) {
            const aboveCell = document.getElementById(`cell-${i-1}-${j}`);
            if (aboveCell) aboveCell.classList.add('above-cell');
        }
        
        if (j > 0) {
            const leftCell = document.getElementById(`cell-${i}-${j-1}`);
            if (leftCell) leftCell.classList.add('left-cell');
        }
    }
}

// NEW: Update Grid Cell with Path Count
function updateGridCell(i, j, pathCount) {
    const cell = document.getElementById(`cell-${i}-${j}`);
    if (cell) {
        cell.innerHTML = `${pathCount} ways`;
        cell.classList.add('path-count');
        
        // Remove temporary highlights
        if (i > 0) {
            const aboveCell = document.getElementById(`cell-${i-1}-${j}`);
            if (aboveCell) aboveCell.classList.remove('above-cell');
        }
        
        if (j > 0) {
            const leftCell = document.getElementById(`cell-${i}-${j-1}`);
            if (leftCell) leftCell.classList.remove('left-cell');
        }
    }
}

// NEW: Highlight DP Elements
function highlightDPElements(currentIndex, leftIndex) {
    // Remove previous highlights
    document.querySelectorAll('.dp-array-element.current').forEach(el => {
        el.classList.remove('current');
    });
    
    document.querySelectorAll('.dp-array-element.updated').forEach(el => {
        el.classList.remove('updated');
    });
    
    // Highlight current element
    const currentElement = document.querySelector(`.dp-array-element:nth-child(${currentIndex + 2})`); // +2 for header
    if (currentElement) {
        currentElement.classList.add('current');
    }
    
    // Highlight left element
    if (leftIndex >= 0) {
        const leftElement = document.querySelector(`.dp-array-element:nth-child(${leftIndex + 2})`);
        if (leftElement) {
            leftElement.classList.add('current');
        }
    }
}

// NEW: Highlight Updated DP Element
function highlightUpdatedDPElement(index) {
    const element = document.querySelector(`.dp-array-element:nth-child(${index + 2})`);
    if (element) {
        element.classList.remove('current');
        element.classList.add('updated');
        
        // Remove updated class after animation
        setTimeout(() => {
            element.classList.remove('updated');
        }, 1000);
    }
}

// NEW: Show Path Step
function showPathStep(i, j, fromAbove, fromLeft, newValue) {
    const pathSteps = document.getElementById('pathSteps');
    const step = document.createElement('div');
    step.className = 'path-step active';
    
    let pathDesc = '';
    if (i === 0 && j === 0) {
        pathDesc = 'Start position';
    } else if (i === 0 || j === 0) {
        pathDesc = 'Only 1 way (all right or all down moves)';
    } else {
        pathDesc = `Paths to (${i},${j}): ${fromAbove} from above + ${fromLeft} from left = ${newValue} total`;
    }
    
    step.innerHTML = `
        <strong>Cell (${i},${j}):</strong> ${pathDesc}
    `;
    
    pathSteps.appendChild(step);
    
    // Scroll to bottom
    pathSteps.scrollTop = pathSteps.scrollHeight;
    
    // Limit to last 10 steps
    const steps = pathSteps.querySelectorAll('.path-step');
    if (steps.length > 10) {
        steps[0].remove();
    }
}

// NEW: Highlight All Paths
function highlightAllPaths(m, n, dpValues) {
    // Highlight all cells with their path counts
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            const cell = document.getElementById(`cell-${i}-${j}`);
            if (cell) {
                let pathCount = 1;
                if (i > 0 && j > 0) {
                    // For demonstration, show the DP value at the time this cell was processed
                    pathCount = dpValues[j];
                } else if (i > 0 || j > 0) {
                    pathCount = 1;
                } else {
                    pathCount = 1; // Start cell
                }
                
                cell.innerHTML = `${pathCount}`;
                cell.classList.add('path-count');
                
                // Add animation delay for visual effect
                setTimeout(() => {
                    cell.classList.add('pulse');
                }, (i * n + j) * 100);
            }
        }
    }
}

// NEW: Combinatorial function for verification
function combination(n, k) {
    if (k > n) return 0;
    if (k === 0 || k === n) return 1;
    
    let result = 1;
    for (let i = 1; i <= k; i++) {
        result = result * (n - k + i) / i;
    }
    return result;
}

// NEW: Setup Auto-Return Timer
function setupAutoReturnTimer() {
    // Clear any existing timer
    if (uniquePathsTimer) {
        clearTimeout(uniquePathsTimer);
    }
    
    // Set new timer for 20 seconds
    uniquePathsTimer = setTimeout(() => {
        returnToOriginalAfterUniquePaths();
    }, 20000);
}

// NEW: Return to Original after Unique Paths
function returnToOriginalAfterUniquePaths() {
    // Clear timer
    if (uniquePathsTimer) {
        clearTimeout(uniquePathsTimer);
        uniquePathsTimer = null;
    }
    
    // Reset state
    isUniquePathsRunning = false;
    
    // Remove visualization and return to normal array view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    logOperation('Unique Paths DP visualization completed - returned to original array', 'info');
    showNotification('Returned to original array after Unique Paths visualization', 'success');
}
// NEW: Coin Change Handler
function handleCoinChange() {
    if (isCoinChangeRunning) {
        showNotification('Coin change operation is already in progress', 'warning');
        return;
    }

    // Reset arrays
    coinArray = [];
    targetAmount = 0;
    coinChangeStep = 0;
    
    // Show input group
    coinChangeGroup.style.display = 'block';
    coinCount.focus();
    
    logOperation('Started coin change (minimum coins) operation', 'info');
}

// NEW: Confirm Coin Count Handler
function handleConfirmCoinCount() {
    const count = parseInt(coinCount.value);
    
    if (isNaN(count) || count < 1 || count > 20) {
        showNotification('Please enter a valid number between 1 and 20', 'danger');
        coinCount.focus();
        return;
    }
    
    // Create input fields for coins
    coinInputs.innerHTML = '<label class="form-label">Enter coin denominations:</label>';
    for (let i = 0; i < count; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Coin ${i + 1}</span>
            <input type="number" class="form-control coin-denomination" 
                   placeholder="Enter value" data-index="${i}" min="1">
        `;
        coinInputs.appendChild(inputGroup);
    }
    
    // Add event listeners for coin inputs
    const coinElements = coinInputs.querySelectorAll('.coin-denomination');
    coinElements.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('coin-denomination')) {
                    nextInput.focus();
                } else {
                    targetAmountInput.focus();
                }
            }
        });
    });
    
    showNotification(`Set ${count} coin types. Please enter denominations.`, 'success');
    logOperation(`Coin types set to ${count}`, 'info');
}

// NEW: Perform Coin Change Handler
function handlePerformCoinChange() {
    // Collect coin denominations
    const coinElements = document.querySelectorAll('.coin-denomination');
    coinArray = [];
    
    for (let i = 0; i < coinElements.length; i++) {
        const value = parseInt(coinElements[i].value.trim());
        if (isNaN(value) || value < 1) {
            showNotification(`Please enter valid positive coin denomination at position ${i + 1}`, 'danger');
            coinElements[i].focus();
            return;
        }
        coinArray.push(value);
    }
    
    // Get target amount
    const amount = parseInt(targetAmountInput.value);
    if (isNaN(amount) || amount < 1) {
        showNotification('Please enter a valid positive target amount', 'danger');
        targetAmountInput.focus();
        return;
    }
    
    targetAmount = amount;
    
    // Sort coin array for better visualization
    coinArray.sort((a, b) => a - b);
    
    // Store original array
    originalArrayForCoinChange = [...myArray];
    
    // Hide input group
    coinChangeGroup.style.display = 'none';
    
    // Start coin change visualization
    showCoinChangeVisualization();
}

// NEW: Cancel Coin Change Handler
function handleCancelCoinChange() {
    coinChangeGroup.style.display = 'none';
    coinCount.value = '';
    targetAmountInput.value = '';
    coinInputs.innerHTML = '';
    
    coinArray = [];
    targetAmount = 0;
    
    logOperation('Cancelled coin change operation', 'info');
    showNotification('Coin change operation cancelled', 'info');
}

// NEW: Show Coin Change Visualization
function showCoinChangeVisualization() {
    isCoinChangeRunning = true;
    
    // Create visualization container
    const container = document.createElement('div');
    container.className = 'dual-operation-container';
    container.innerHTML = `
        <h5 class="text-center mb-3">Coin Change - Minimum Number of Coins</h5>
        
        <div class="array-group">
            <div class="array-label">Coin Denominations</div>
            <div class="original-array-container" id="coinArrayDisplay"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Target Amount</div>
            <div class="stats-value">${targetAmount}</div>
        </div>
        
        <div class="dp-table-container" id="dpTableContainer">
            <h6 class="text-center mb-3">DP Table Construction</h6>
            <div id="dpTableDisplay"></div>
        </div>
        
        <div class="coin-change-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Dynamic Programming - dp[i] = minimum coins needed for amount i</p>
            <p class="mb-0" id="coinChangeExplanation">Initializing DP table...</p>
        </div>
        
        <div class="coin-change-steps" id="coinChangeStepsContainer">
            <h6 class="text-center">DP Table Construction Steps</h6>
            <div id="coinChangeSteps"></div>
        </div>
        
        <div class="stats-card mt-3" id="solutionResult" style="display: none;">
            <div>Minimum Coins Required</div>
            <div class="stats-value" id="minCoinsValue">0</div>
        </div>
        
        <div id="solutionCoinsContainer" style="display: none;">
            <h6 class="text-center">Coin Combination</h6>
            <div class="solution-coins" id="solutionCoins"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterCoinChange" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(container);
    
    // Display the coin array
    renderArrayInContainer(coinArray.map(c => c.toString()), 'coinArrayDisplay');
    
    // Start DP table construction
    constructDPTable();
}

/// UPDATED: Construct DP Table with Animation - Optimized for large amounts
function constructDPTable() {
    const explanation = document.getElementById('coinChangeExplanation');
    const stepsContainer = document.getElementById('coinChangeSteps');
    const dpTableDisplay = document.getElementById('dpTableDisplay');
    const dpTableContainer = document.getElementById('dpTableContainer');
    
    // Determine if we need compact view (for amounts > 50)
    const needCompactView = targetAmount > 50;
    if (needCompactView) {
        dpTableContainer.classList.add('compact-view');
        explanation.innerHTML = `Large amount detected (${targetAmount}). Using compact view for DP table.`;
    }
    
    // Initialize DP table
    dpTable = new Array(coinArray.length + 1);
    for (let i = 0; i <= coinArray.length; i++) {
        dpTable[i] = new Array(targetAmount + 1);
        for (let j = 0; j <= targetAmount; j++) {
            if (j === 0) {
                dpTable[i][j] = 0; // 0 coins needed for amount 0
            } else if (i === 0) {
                dpTable[i][j] = Infinity; // No coins available
            } else {
                dpTable[i][j] = Infinity;
            }
        }
    }
    
    coinChangeStep = 0;
    let currentRow = 0;
    
    function renderDPTable(highlightRow = -1, highlightCol = -1) {
        let html = `
            <table class="dp-table">
                <thead>
                    <tr>
                        <th>Coins\Amount</th>
        `;
        
        // Column headers (amounts) - Group by 10s for better readability
        for (let j = 0; j <= targetAmount; j++) {
            // Add group headers every 10 columns for readability
            if (targetAmount > 30 && j % 10 === 0 && j > 0) {
                html += `<th class="amount-group-header">${j}</th>`;
            } else {
                html += `<th>${j}</th>`;
            }
        }
        
        html += `</tr></thead><tbody>`;
        
        // Table rows - only show first 20 rows at a time for performance
        const maxVisibleRows = Math.min(coinArray.length + 1, 30);
        const startRow = Math.max(0, currentRow - 10);
        
        for (let i = startRow; i <= Math.min(startRow + maxVisibleRows, coinArray.length); i++) {
            if (i < 0) continue;
            
            html += `<tr>`;
            // Row header
            if (i === 0) {
                html += `<th></th>`;
            } else {
                html += `<th>${coinArray[i-1]}</th>`;
            }
            
            // Table cells - show all columns but with virtual scrolling
            for (let j = 0; j <= targetAmount; j++) {
                // Group columns by 5s for large amounts
                if (targetAmount > 100 && j % 5 !== 0 && j > 0) {
                    continue; // Skip some columns for very large amounts
                }
                
                let cellClass = 'dp-cell';
                let cellValue = dpTable[i][j];
                
                // Add tooltip data
                const tooltip = `dp[${i}][${j}] = ${cellValue === Infinity ? '' : cellValue}`;
                
                if (cellValue === Infinity) {
                    cellValue = '';
                    cellClass += ' impossible';
                }
                
                if (i === highlightRow && j === highlightCol) {
                    cellClass += ' current';
                } else if (i <= currentRow && j <= targetAmount) {
                    if (dpTable[i][j] !== Infinity) {
                        cellClass += ' updated';
                    }
                }
                
                if (i === 0 || j === 0) {
                    cellClass += ' initial';
                }
                
                // Add group styling for every 5th column
                if (j % 5 === 0 && j > 0) {
                    cellClass += ' amount-group';
                }
                
                html += `<td class="${cellClass}" data-tooltip="${tooltip}">${cellValue}</td>`;
            }
            
            html += `</tr>`;
        }
        
        html += `</tbody></table>`;
        dpTableDisplay.innerHTML = html;
        
        // Add column count indicator for large tables
        if (targetAmount > 100) {
            const infoDiv = document.createElement('div');
            infoDiv.className = 'text-center mt-2 text-muted';
            infoDiv.style.fontSize = '0.8rem';
            infoDiv.innerHTML = `Showing columns in steps of 5. Total amount: ${targetAmount}`;
            dpTableDisplay.appendChild(infoDiv);
        }
        
        // Scroll to highlight column if needed
        if (highlightCol > 0) {
            const tableContainer = dpTableDisplay.querySelector('.dp-table');
            if (tableContainer) {
                const scrollLeft = (highlightCol * 40) - 200; // Approximate scroll
                dpTableContainer.scrollLeft = Math.max(0, scrollLeft);
            }
        }
    }
    
    function performDPStep() {
        if (currentRow > coinArray.length) {
            // DP table construction completed
            explanation.innerHTML = `<strong>DP Table Construction Completed!</strong>`;
            
            stepsContainer.innerHTML += `
                <div class="coin-change-step active">
                    <strong>Step ${coinChangeStep}:</strong> DP table construction completed. Minimum coins for amount ${targetAmount} = ${dpTable[coinArray.length][targetAmount]}
                </div>
            `;
            
            // Render final complete table
            renderCompleteDPTable();
            
            // Find and display solution
            setTimeout(() => {
                findSolutionPath();
            }, 1500);
            
            return;
        }
        
        coinChangeStep++;
        
        if (currentRow === 0) {
            // Initialize first row
            explanation.innerHTML = `Step ${coinChangeStep}: Initializing first row (no coins available)`;
            
            stepsContainer.innerHTML += `
                <div class="coin-change-step active">
                    <strong>Step ${coinChangeStep}:</strong> Initialize dp[0][j] = Infinity for j > 0 (no coins available)
                </div>
            `;
            
            renderDPTable(0, 0);
            
            setTimeout(() => {
                currentRow++;
                performDPStep();
            }, 1500);
            
        } else {
            const coin = coinArray[currentRow - 1];
            
            explanation.innerHTML = `Step ${coinChangeStep}: Processing coin denomination ${coin}`;
            
            stepsContainer.innerHTML += `
                <div class="coin-change-step active">
                    <strong>Step ${coinChangeStep}:</strong> Processing coin ${coin} (row ${currentRow})
                </div>
            `;
            
            let col = 0;
            let processed = 0;
            const maxPerBatch = Math.min(20, Math.ceil(targetAmount / 10));
            
            function processColumn() {
                if (col > targetAmount) {
                    // Row completed
                    explanation.innerHTML = `Row ${currentRow} completed. Minimum coins so far: ${dpTable[currentRow][targetAmount]}`;
                    
                    stepsContainer.innerHTML += `
                        <div class="coin-change-step">
                            <strong>Row ${currentRow} Complete:</strong> Processed coin ${coin}
                        </div>
                    `;
                    
                    currentRow++;
                    setTimeout(performDPStep, 1000);
                    return;
                }
                
                // Process batch of columns
                const endCol = Math.min(col + maxPerBatch, targetAmount);
                
                for (let j = col; j <= endCol; j++) {
                    if (j < coin) {
                        // Can't use this coin, copy from above
                        dpTable[currentRow][j] = dpTable[currentRow - 1][j];
                    } else {
                        // Can use this coin
                        const withoutCoin = dpTable[currentRow - 1][j];
                        const withCoin = 1 + dpTable[currentRow][j - coin];
                        dpTable[currentRow][j] = Math.min(withoutCoin, withCoin);
                    }
                    processed++;
                }
                
                // Update progress
                const progress = Math.round((processed / (targetAmount + 1)) * 100);
                explanation.innerHTML = `Step ${coinChangeStep}.${col}: Processing amount ${col}-${endCol} (${progress}%)`;
                
                // Render table with highlights
                renderDPTable(currentRow, col);
                
                // Scroll steps container
                stepsContainer.scrollTop = stepsContainer.scrollHeight;
                
                col = endCol + 1;
                
                // Continue processing with delay for animation
                setTimeout(processColumn, 300);
            }
            
            processColumn();
        }
    }
    
    function renderCompleteDPTable() {
        let html = `
            <div class="mb-3">
                <h6 class="text-center">Complete DP Table</h6>
                <small class="text-muted d-block text-center">Showing key columns only for readability</small>
            </div>
            <table class="dp-table">
                <thead>
                    <tr>
                        <th>Coins\Amount</th>
        `;
        
        // Show only key columns in final view
        const showAllColumns = targetAmount <= 50;
        const columnStep = targetAmount > 100 ? 10 : targetAmount > 50 ? 5 : 1;
        
        for (let j = 0; j <= targetAmount; j++) {
            if (showAllColumns || j % columnStep === 0 || j === targetAmount || j === 0) {
                html += `<th>${j}</th>`;
            }
        }
        
        html += `</tr></thead><tbody>`;
        
        // Show all rows
        for (let i = 0; i <= coinArray.length; i++) {
            html += `<tr>`;
            // Row header
            if (i === 0) {
                html += `<th></th>`;
            } else {
                html += `<th>${coinArray[i-1]}</th>`;
            }
            
            // Table cells
            for (let j = 0; j <= targetAmount; j++) {
                if (!showAllColumns && j % columnStep !== 0 && j !== targetAmount && j !== 0) {
                    continue;
                }
                
                let cellClass = 'dp-cell';
                let cellValue = dpTable[i][j];
                
                if (cellValue === Infinity) {
                    cellValue = '';
                    cellClass += ' impossible';
                }
                
                if (i === 0 || j === 0) {
                    cellClass += ' initial';
                }
                
                // Highlight the solution column
                if (j === targetAmount && i === coinArray.length) {
                    cellClass += ' solution';
                }
                
                html += `<td class="${cellClass}">${cellValue}</td>`;
            }
            
            html += `</tr>`;
        }
        
        html += `</tbody></table>`;
        
        // Add column info
        if (!showAllColumns) {
            html += `
                <div class="text-center mt-2 text-muted" style="font-size: 0.8rem;">
                    Showing columns in steps of ${columnStep}. Total amount: ${targetAmount}
                </div>
            `;
        }
        
        dpTableDisplay.innerHTML = html;
    }
    
    // Start DP table construction
    renderDPTable();
    setTimeout(performDPStep, 1000);
}

// NEW: Find Solution Path
function findSolutionPath() {
    const explanation = document.getElementById('coinChangeExplanation');
    const stepsContainer = document.getElementById('coinChangeSteps');
    const minCoinsValue = document.getElementById('minCoinsValue');
    const solutionResult = document.getElementById('solutionResult');
    const solutionCoinsContainer = document.getElementById('solutionCoinsContainer');
    const solutionCoins = document.getElementById('solutionCoins');
    const continueButton = document.getElementById('continueAfterCoinChange');
    const dpTableDisplay = document.getElementById('dpTableDisplay');
    
    const minCoins = dpTable[coinArray.length][targetAmount];
    
    if (minCoins === Infinity) {
        // No solution found
        explanation.innerHTML = `<strong>No Solution Found!</strong> Cannot make amount ${targetAmount} with given coins`;
        
        stepsContainer.innerHTML += `
            <div class="coin-change-step active">
                <strong>Result:</strong> Impossible to make amount ${targetAmount} with given coins
            </div>
        `;
        
        minCoinsValue.textContent = 'Impossible';
        solutionResult.style.display = 'block';
        
    } else {
        // Find solution path
        explanation.innerHTML = `<strong>Finding Solution Path...</strong> Minimum coins needed: ${minCoins}`;
        
        stepsContainer.innerHTML += `
            <div class="coin-change-step active">
                <strong>Step ${coinChangeStep + 1}:</strong> Minimum coins required = ${minCoins}
            </div>
        `;
        
        // Backtrack to find coins used
        let i = coinArray.length;
        let j = targetAmount;
        solutionPath = [];
        
        function backtrack() {
            if (j === 0) {
                // Backtracking completed
                explanation.innerHTML = `<strong>Solution Found!</strong> Coins used: ${solutionPath.join(', ')}`;
                
                stepsContainer.innerHTML += `
                    <div class="coin-change-step active">
                        <strong>Solution:</strong> ${solutionPath.join(' + ')} = ${targetAmount}
                    </div>
                `;
                
                // Display solution
                minCoinsValue.textContent = minCoins;
                solutionResult.style.display = 'block';
                
                // Display coins visually
                solutionCoins.innerHTML = '';
                solutionPath.forEach(coin => {
                    const coinElement = document.createElement('div');
                    coinElement.className = 'solution-coin';
                    coinElement.textContent = coin;
                    solutionCoins.appendChild(coinElement);
                });
                solutionCoinsContainer.style.display = 'block';
                
                // Highlight coins in the coin array
                const coinArrayContainer = document.getElementById('coinArrayDisplay');
                const coinElements = coinArrayContainer.querySelectorAll('.array-element');
                
                coinArray.forEach((coin, index) => {
                    const count = solutionPath.filter(c => c === coin).length;
                    if (count > 0) {
                        const coinElement = coinElements[index].querySelector('.element-value');
                        coinElement.classList.add('coin-highlight');
                        coinElement.innerHTML = `${coin}<br><small>${count}</small>`;
                    }
                });
                
                // Highlight DP table path
                highlightDPPath();
                
                // Show continue button
                continueButton.style.display = 'block';
                
                // Auto-return after 20 seconds
                setTimeout(() => {
                    returnToOriginalAfterCoinChange();
                }, 20000);
                
                continueButton.addEventListener('click', returnToOriginalAfterCoinChange);
                
                return;
            }
            
            if (dpTable[i][j] === dpTable[i-1][j]) {
                // Coin not used, move up
                i--;
            } else {
                // Coin used
                solutionPath.push(coinArray[i-1]);
                j -= coinArray[i-1];
            }
            
            setTimeout(backtrack, 1000);
        }
        
        backtrack();
    }
}
// NEW: Highlight DP Path
// UPDATED: Highlight DP Path - Optimized for large tables
function highlightDPPath() {
    const dpTableDisplay = document.getElementById('dpTableDisplay');
    const cells = dpTableDisplay.querySelectorAll('td.dp-cell');
    
    if (cells.length === 0) {
        console.warn('No DP cells found to highlight');
        return;
    }
    
    // Calculate the path
    let i = coinArray.length;
    let j = targetAmount;
    const pathCells = [];
    const pathCoins = [];
    
    // Backtrack to find the path
    while (j > 0 && i > 0) {
        // Calculate approximate cell index
        const columnStep = targetAmount > 100 ? 10 : targetAmount > 50 ? 5 : 1;
        const visibleColumns = Math.floor(targetAmount / columnStep) + 2;
        const cellRow = i;
        const cellCol = Math.floor(j / columnStep) + 1;
        const cellIndex = (cellRow * visibleColumns) + cellCol;
        
        pathCells.push(Math.min(cellIndex, cells.length - 1));
        
        if (dpTable[i][j] === dpTable[i-1][j]) {
            // Coin not used, move up
            i--;
        } else {
            // Coin used
            pathCoins.push(coinArray[i-1]);
            j -= coinArray[i-1];
        }
    }
    
    // Add starting point (0,0)
    pathCells.push(0);
    
    // Highlight path cells with animation
    pathCells.forEach((cellIndex, idx) => {
        const safeIndex = Math.min(cellIndex, cells.length - 1);
        if (cells[safeIndex]) {
            setTimeout(() => {
                cells[safeIndex].classList.add('path');
                cells[safeIndex].classList.add('solution');
                
                // Add tooltip
                const tooltip = pathCoins[idx] ? `Coin used: ${pathCoins[idx]}` : 'Starting point';
                cells[safeIndex].setAttribute('data-tooltip', cells[safeIndex].getAttribute('data-tooltip') + ` | ${tooltip}`);
            }, idx * 300);
        }
    });
    
    // If no cells were highlighted, show a summary instead
    if (pathCells.length === 0) {
        const explanation = document.getElementById('coinChangeExplanation');
        explanation.innerHTML += `<br><small class="text-warning">Path highlighting simplified for large table. See solution coins above.</small>`;
    }
}

// NEW: Helper function to highlight coins in solution
function highlightCoinsInSolution() {
    const coinArrayContainer = document.getElementById('coinArrayDisplay');
    if (!coinArrayContainer) return;
    
    const coinElements = coinArrayContainer.querySelectorAll('.array-element');
    const coinCounts = {};
    
    // Count coins in solution
    solutionPath.forEach(coin => {
        coinCounts[coin] = (coinCounts[coin] || 0) + 1;
    });
    
    // Highlight coins
    coinArray.forEach((coin, index) => {
        if (coinCounts[coin] > 0 && coinElements[index]) {
            const coinElement = coinElements[index].querySelector('.element-value');
            coinElement.classList.add('coin-highlight');
            coinElement.innerHTML = `${coin}<br><small>${coinCounts[coin]}</small>`;
        }
    });
}
// NEW: Return to Original after Coin Change
function returnToOriginalAfterCoinChange() {
    // Reset to original array
    myArray = [...originalArrayForCoinChange];
    originalArrayForCoinChange = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isCoinChangeRunning = false;
    
    // Clear all coin change data
    coinArray = [];
    targetAmount = 0;
    coinChangeStep = 0;
    dpTable = [];
    solutionPath = [];
    
    // Reset input groups
    coinChangeGroup.style.display = 'none';
    coinCount.value = '';
    targetAmountInput.value = '';
    coinInputs.innerHTML = '';
    
    logOperation('Coin change operation completed - returned to original array', 'info');
    showNotification('Returned to original array after coin change operation', 'success');
}
// NEW: Handle Decode Ways Algorithm
function handleDecodeWays() {
    const input = decodeWaysInput.value.trim();
    
    // Validation
    if (input === '') {
        showNotification('Please enter a numeric string', 'danger');
        decodeWaysInput.focus();
        return;
    }
    
    // Check if input contains only digits
    if (!/^\d+$/.test(input)) {
        showNotification('Please enter only numeric characters (0-9)', 'danger');
        decodeWaysInput.focus();
        return;
    }
    
    if (isDecodeWaysRunning) {
        showNotification('Decode Ways algorithm is already running', 'warning');
        return;
    }
    
    isDecodeWaysRunning = true;
    
    // Store original array
    originalArrayForDecodeWays = [...myArray];
    
    // Show decode ways visualization
    showDecodeWaysVisualization(input);
}

// NEW: Show Decode Ways Visualization
function showDecodeWaysVisualization(input) {
    const decodeContainer = document.createElement('div');
    decodeContainer.className = 'decode-container';
    decodeContainer.innerHTML = `
        <h5 class="text-center mb-3">Decode Ways Algorithm</h5>
        
        <div class="text-center mb-4">
            <h6>Input String: <span class="text-warning">"${input}"</span></h6>
            <p class="mb-2">Convert digits to letters using mapping: A=1, B=2, C=3, ..., Z=26</p>
        </div>
        
        <div class="string-display text-center mb-4" id="stringDisplay">
            <!-- Digits will be displayed here -->
        </div>
        
        <div class="dp-array-container" id="dpArrayDisplay">
            <!-- DP array will be displayed here -->
        </div>
        
        <div class="algorithm-steps mt-3" id="decodeStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="decodeSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Number of Ways to Decode</div>
            <div class="stats-value" id="decodeWaysResult">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterDecode" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(decodeContainer);
    
    // Display the input string
    displayInputString(input);
    
    // Initialize DP array display
    initializeDPArrayDisplay(input.length);
    
    // Start decode ways algorithm with animation
    performDecodeWaysAlgorithm(input);
}

// NEW: Display Input String
function displayInputString(input) {
    const stringDisplay = document.getElementById('stringDisplay');
    stringDisplay.innerHTML = '';
    
    for (let i = 0; i < input.length; i++) {
        const digitSpan = document.createElement('span');
        digitSpan.className = 'decode-digit';
        digitSpan.textContent = input[i];
        digitSpan.title = `Index ${i}: ${input[i]}`;
        stringDisplay.appendChild(digitSpan);
        
        // Add index label below
        const indexSpan = document.createElement('div');
        indexSpan.className = 'digit-index';
        indexSpan.textContent = i;
        indexSpan.style.cssText = 'font-size: 0.7rem; color: var(--secondary-color); margin-top: 5px;';
        stringDisplay.appendChild(indexSpan);
        
        // Add space between digits
        if (i < input.length - 1) {
            stringDisplay.appendChild(document.createTextNode(' '));
        }
    }
}

// NEW: Initialize DP Array Display
function initializeDPArrayDisplay(n) {
    const dpArrayDisplay = document.getElementById('dpArrayDisplay');
    dpArrayDisplay.innerHTML = '';
    
    // Add dp[0] - empty string
    const dp0 = document.createElement('div');
    dp0.className = 'dp-element';
    dp0.innerHTML = `
        <div class="dp-value">1</div>
        <div class="dp-index">dp[0]</div>
        <div class="dp-label" style="font-size: 0.7rem; margin-top: 5px;">''</div>
    `;
    dpArrayDisplay.appendChild(dp0);
    
    // Add dp[1] to dp[n]
    for (let i = 1; i <= n; i++) {
        const dpElement = document.createElement('div');
        dpElement.className = 'dp-element';
        dpElement.id = `dp${i}`;
        dpElement.innerHTML = `
            <div class="dp-value">0</div>
            <div class="dp-index">dp[${i}]</div>
            <div class="dp-label" style="font-size: 0.7rem; margin-top: 5px;">?</div>
        `;
        dpArrayDisplay.appendChild(dpElement);
    }
}

// NEW: Perform Decode Ways Algorithm with Animation
function performDecodeWaysAlgorithm(input) {
    const decodeSteps = document.getElementById('decodeSteps');
    const decodeWaysResult = document.getElementById('decodeWaysResult');
    const continueButton = document.getElementById('continueAfterDecode');
    
    const n = input.length;
    const dp = new Array(n + 1).fill(0);
    let step = 0;
    
    // Clear steps container
    decodeSteps.innerHTML = '';
    
    // Step 1: Check if string is empty
    addDecodeStep(++step, "Checking input string...");
    
    setTimeout(() => {
        if (n === 0) {
            addDecodeStep(++step, "Empty string  0 ways to decode", "invalid");
            decodeWaysResult.textContent = "0";
            completeDecodeAlgorithm(0);
            return;
        }
        
        // Step 2: Check if string starts with '0'
        addDecodeStep(++step, `Checking first character: "${input[0]}"`);
        
        // Highlight first digit
        highlightDigit(0);
        
        setTimeout(() => {
            if (input[0] === '0') {
                addDecodeStep(++step, "String starts with '0'  0 ways (no letter maps to '0')", "invalid");
                decodeWaysResult.textContent = "0";
                completeDecodeAlgorithm(0);
                return;
            }
            
            // Step 3: Initialize DP array
            addDecodeStep(++step, "Initializing DP array:");
            addDecodeStep(++step, "dp[0] = 1 (empty string has 1 way to decode)");
            addDecodeStep(++step, `dp[1] = 1 (first digit "${input[0]}" can be decoded as "${getLetter(parseInt(input[0]))}")`);
            
            // Update DP array display
            dp[0] = 1;
            dp[1] = 1;
            
            updateDPElement(0, 1, "''");
            updateDPElement(1, 1, input[0]);
            
            // Remove highlight from first digit
            removeHighlightDigit(0);
            
            // Start main algorithm
            setTimeout(() => {
                performMainDecodeAlgorithm(input, dp, step + 1);
            }, 2000);
        }, 1500);
    }, 1000);
}

// NEW: Perform Main Decode Algorithm
function performMainDecodeAlgorithm(input, dp, startStep) {
    const n = input.length;
    let step = startStep;
    
    function processPosition(i) {
        if (i > n) {
            // Algorithm completed
            addDecodeStep(++step, `Algorithm completed! Total ways to decode "${input}": ${dp[n]}`);
            decodeWaysResult.textContent = dp[n];
            completeDecodeAlgorithm(dp[n]);
            return;
        }
        
        // Add separator
        decodeSteps.innerHTML += `<div style="border-top: 1px dashed var(--secondary-color); margin: 10px 0;"></div>`;
        
        addDecodeStep(++step, `Processing position i=${i} (character: "${input[i-1] || 'N/A'}")`);
        
        // Highlight current digit
        highlightDigit(i-1);
        
        // Highlight current DP element
        highlightDPElement(i);
        
        setTimeout(() => {
            const singleDigit = parseInt(input[i-1]);
            const twoDigit = i > 1 ? parseInt(input.substring(i-2, i)) : 0;
            
            addDecodeStep(++step, `Single digit: ${singleDigit}`);
            addDecodeStep(++step, `Two-digit number: ${twoDigit} ("${i > 1 ? input.substring(i-2, i) : 'N/A'}")`);
            
            dp[i] = 0;
            
            // Check single digit
            setTimeout(() => {
                if (singleDigit !== 0) {
                    addDecodeStep(++step, ` Single digit ${singleDigit} is valid (1-9)`);
                    addDecodeStep(++step, `  Can be decoded as: "${getLetter(singleDigit)}"`);
                    addDecodeStep(++step, `  Adding dp[${i-1}] = ${dp[i-1]} to dp[${i}]`);
                    
                    dp[i] += dp[i-1];
                    
                    // Show connection to dp[i-1]
                    highlightDPElement(i-1, 'info');
                    
                    setTimeout(() => {
                        updateDPElement(i, dp[i], input.substring(0, i));
                        removeHighlightDPElement(i-1);
                    }, 1000);
                    
                } else {
                    addDecodeStep(++step, ` Single digit ${singleDigit} is invalid (cannot decode '0')`, "invalid");
                    markDigitInvalid(i-1);
                }
                
                // Check two-digit number
                setTimeout(() => {
                    if (i > 1) {
                        // Highlight the pair of digits
                        highlightDigitPair(i-2, i-1);
                        
                        setTimeout(() => {
                            if (twoDigit >= 10 && twoDigit <= 26) {
                                addDecodeStep(++step, ` Two-digit ${twoDigit} is valid (10-26)`);
                                addDecodeStep(++step, `  Can be decoded as: "${getLetter(twoDigit)}"`);
                                addDecodeStep(++step, `  Adding dp[${i-2}] = ${dp[i-2]} to dp[${i}]`);
                                
                                dp[i] += dp[i-2];
                                
                                // Show connection to dp[i-2]
                                highlightDPElement(i-2, 'info');
                                
                                setTimeout(() => {
                                    updateDPElement(i, dp[i], input.substring(0, i));
                                    removeHighlightDPElement(i-2);
                                    removeHighlightDigitPair(i-2, i-1);
                                }, 1000);
                                
                            } else {
                                addDecodeStep(++step, ` Two-digit ${twoDigit} is invalid (not in 10-26 range)`, "invalid");
                                removeHighlightDigitPair(i-2, i-1);
                            }
                            
                            // Move to next position
                            setTimeout(() => {
                                removeHighlightDigit(i-1);
                                removeHighlightDPElement(i);
                                processPosition(i + 1);
                            }, 1500);
                        }, 1000);
                    } else {
                        // Move to next position
                        setTimeout(() => {
                            removeHighlightDigit(i-1);
                            removeHighlightDPElement(i);
                            processPosition(i + 1);
                        }, 1500);
                    }
                }, 1500);
            }, 1500);
        }, 1000);
    }
    
    // Start processing from position 2
    processPosition(2);
}

// NEW: Helper Functions for Decode Ways Algorithm

function addDecodeStep(stepNumber, message, type = "normal") {
    const decodeSteps = document.getElementById('decodeSteps');
    const stepDiv = document.createElement('div');
    stepDiv.className = `decode-step ${type === "invalid" ? "invalid" : type === "active" ? "active" : ""}`;
    stepDiv.innerHTML = `<strong>Step ${stepNumber}:</strong> ${message}`;
    decodeSteps.appendChild(stepDiv);
    
    // Scroll to bottom
    decodeSteps.scrollTop = decodeSteps.scrollHeight;
}

function highlightDigit(index) {
    const digits = document.querySelectorAll('.decode-digit');
    if (digits[index]) {
        digits[index].classList.add('current');
    }
}

function removeHighlightDigit(index) {
    const digits = document.querySelectorAll('.decode-digit');
    if (digits[index]) {
        digits[index].classList.remove('current');
    }
}

function markDigitInvalid(index) {
    const digits = document.querySelectorAll('.decode-digit');
    if (digits[index]) {
        digits[index].classList.add('invalid');
    }
}

function highlightDigitPair(start, end) {
    const digits = document.querySelectorAll('.decode-digit');
    if (digits[start] && digits[end]) {
        digits[start].classList.add('pair');
        digits[end].classList.add('pair');
    }
}

function removeHighlightDigitPair(start, end) {
    const digits = document.querySelectorAll('.decode-digit');
    if (digits[start] && digits[end]) {
        digits[start].classList.remove('pair');
        digits[end].classList.remove('pair');
    }
}

function highlightDPElement(index, type = 'active') {
    const dpElement = document.getElementById(`dp${index}`);
    if (dpElement) {
        if (type === 'active') {
            dpElement.classList.add('active');
        } else if (type === 'info') {
            dpElement.classList.add('updated');
        }
    }
}

function removeHighlightDPElement(index) {
    const dpElement = document.getElementById(`dp${index}`);
    if (dpElement) {
        dpElement.classList.remove('active', 'updated');
    }
}

function updateDPElement(index, value, substring) {
    const dpElement = document.getElementById(`dp${index}`);
    if (dpElement) {
        const valueDiv = dpElement.querySelector('.dp-value');
        const labelDiv = dpElement.querySelector('.dp-label');
        
        valueDiv.textContent = value;
        labelDiv.textContent = `"${substring}"`;
        
        dpElement.classList.add('updated');
        
        // Remove updated class after animation
        setTimeout(() => {
            dpElement.classList.remove('updated');
        }, 1000);
    }
}

function getLetter(number) {
    if (number >= 1 && number <= 26) {
        return String.fromCharCode(64 + number); // A=65 in ASCII
    }
    return '?';
}

function completeDecodeAlgorithm(result) {
    const continueButton = document.getElementById('continueAfterDecode');
    
    // Show all possible decodings if result is small
    if (result > 0 && result <= 5) {
        showExampleDecodings();
    }
    
    continueButton.style.display = 'block';
    
    // Auto-return after 20 seconds
    const autoReturnTimer = setTimeout(() => {
        returnToOriginalAfterDecode();
    }, 20000);
    
    continueButton.addEventListener('click', () => {
        clearTimeout(autoReturnTimer);
        returnToOriginalAfterDecode();
    });
}

// NEW: Show Example Decodings
function showExampleDecodings() {
    const input = decodeWaysInput.value.trim();
    const decodeSteps = document.getElementById('decodeSteps');
    
    // Add separator
    decodeSteps.innerHTML += `<div style="border-top: 2px solid var(--success-color); margin: 15px 0;"></div>`;
    
    // Add example decoding
    const exampleDiv = document.createElement('div');
    exampleDiv.className = 'decoding-example';
    exampleDiv.innerHTML = `
        <strong>Example Decodings for "${input}":</strong><br>
        <small>(A=1, B=2, C=3, ..., Z=26)</small><br><br>
    `;
    
    // Generate some example decodings (simplified)
    const examples = generateExampleDecodings(input);
    
    if (examples.length > 0) {
        examples.forEach((example, idx) => {
            const exampleItem = document.createElement('div');
            exampleItem.style.margin = '5px 0';
            exampleItem.innerHTML = `
                ${idx + 1}. ${formatDecodingExample(example)}
            `;
            exampleDiv.appendChild(exampleItem);
        });
    } else {
        exampleDiv.innerHTML += '<div>No valid decodings found</div>';
    }
    
    decodeSteps.appendChild(exampleDiv);
}

// NEW: Generate Example Decodings (simplified)
function generateExampleDecodings(input) {
    const examples = [];
    
    // Simple recursive function to find decodings
    function findDecodings(str, index, current, results) {
        if (index === str.length) {
            results.push([...current]);
            return;
        }
        
        // Try single digit
        const single = parseInt(str[index]);
        if (single !== 0) {
            current.push(single.toString());
            findDecodings(str, index + 1, current, results);
            current.pop();
        }
        
        // Try two digits
        if (index + 1 < str.length) {
            const twoDigit = parseInt(str.substring(index, index + 2));
            if (twoDigit >= 10 && twoDigit <= 26) {
                current.push(twoDigit.toString());
                findDecodings(str, index + 2, current, results);
                current.pop();
            }
        }
    }
    
    const results = [];
    findDecodings(input, 0, [], results);
    
    // Convert to letter representations (limit to 5 examples)
    results.slice(0, 5).forEach(decoding => {
        const letters = decoding.map(num => getLetter(parseInt(num))).join('');
        const numbers = decoding.join(', ');
        examples.push({ letters, numbers });
    });
    
    return examples;
}

function formatDecodingExample(example) {
    return `
        <span class="letter-mapping valid">${example.letters}</span> 
         (${example.numbers})
    `;
}

// NEW: Return to Original after Decode Ways
function returnToOriginalAfterDecode() {
    // Reset to original array
    myArray = [...originalArrayForDecodeWays];
    originalArrayForDecodeWays = [];
    
    // Remove decode visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isDecodeWaysRunning = false;
    
    // Clear input
    decodeWaysInput.value = '';
    
    logOperation('Decode Ways algorithm completed - returned to original array', 'info');
    showNotification('Returned to original array after Decode Ways algorithm', 'success');
}
// NEW: Partition Equal Subset Sum Handler
function handlePartitionEqualSubsetSum() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isPartitionEqualRunning) {
        showNotification('Partition operation is already in progress', 'warning');
        return;
    }
    
    // Check if all elements are numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        const num = parseFloat(myArray[i]);
        if (isNaN(num)) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Partition Equal Subset Sum requires all elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForPartitionEqual = [...myArray];
    isPartitionEqualRunning = true;
    
    // Show partition visualization
    showPartitionEqualVisualization();
}

// NEW: Show Partition Equal Visualization
function showPartitionEqualVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Partition Equal Subset Sum Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalPartitionEqualArray"></div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Total Sum</div>
            <div class="stats-value" id="totalSumValue">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Target Sum (Total/2)</div>
            <div class="stats-value" id="targetSumValue">0</div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Dynamic Programming Table</div>
            <div class="partition-table" id="dpTableContainer"></div>
        </div>
        
        <div class="partition-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Check if array can be partitioned into two subsets with equal sum</p>
            <p class="mb-0" id="partitionEqualExplanation">Initializing partition algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="partitionEqualStepsContainer">
            <h6 class="text-center">Partition Steps (Dynamic Programming)</h6>
            <div class="steps-container" id="partitionEqualSteps"></div>
        </div>
        
        <div class="mt-3" id="partitionEqualResultContainer" style="display: none;">
            <h6 class="text-center">Partition Result</h6>
            <div class="stats-card">
                <div>Can Partition?</div>
                <div class="stats-value" id="partitionEqualResult">Checking...</div>
            </div>
            <div class="mt-2" id="partitionEqualSubsetsContainer"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPartitionEqual" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForPartitionEqual, 'originalPartitionEqualArray');
    
    performPartitionEqualAlgorithm();
}

// NEW: Perform Partition Equal Algorithm with Animation
function performPartitionEqualAlgorithm() {
    const originalContainer = document.getElementById('originalPartitionEqualArray');
    const totalSumValue = document.getElementById('totalSumValue');
    const targetSumValue = document.getElementById('targetSumValue');
    const dpTableContainer = document.getElementById('dpTableContainer');
    const explanation = document.getElementById('partitionEqualExplanation');
    const stepsContainer = document.getElementById('partitionEqualSteps');
    const resultContainer = document.getElementById('partitionEqualResultContainer');
    const partitionResult = document.getElementById('partitionEqualResult');
    const subsetsContainer = document.getElementById('partitionEqualSubsetsContainer');
    const continueButton = document.getElementById('continueAfterPartitionEqual');
    
    const nums = originalArrayForPartitionEqual.map(val => parseFloat(val));
    const totalSum = nums.reduce((sum, num) => sum + num, 0);
    
    // Update sum displays
    totalSumValue.textContent = totalSum;
    
    // Step 1: Check if total sum is odd
    explanation.innerHTML = "Step 1: Check if total sum is even";
    stepsContainer.innerHTML += `
        <div class="algorithm-step">
            <strong>Step 1:</strong> Total sum = ${totalSum}
        </div>
    `;
    
    setTimeout(() => {
        if (totalSum % 2 !== 0) {
            explanation.innerHTML = `Step 1: Total sum ${totalSum} is odd  Cannot partition equally`;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Result:</strong> Total sum ${totalSum} is odd  Partition impossible
                </div>
            `;
            
            partitionResult.textContent = "NO (Odd total sum)";
            partitionResult.style.color = "var(--danger-color)";
            resultContainer.style.display = "block";
            
            continueButton.style.display = "block";
            setTimeout(() => {
                returnToOriginalAfterPartitionEqual();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterPartitionEqual);
            return;
        }
        
        const target = totalSum / 2;
        targetSumValue.textContent = target;
        
        explanation.innerHTML = `Step 2: Target sum = Total sum / 2 = ${target}`;
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step 2:</strong> Target sum = ${totalSum} / 2 = ${target}
            </div>
        `;
        
        // Initialize DP table
        setTimeout(() => {
            explanation.innerHTML = "Step 3: Initialize DP table";
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step 3:</strong> Initialize DP table (0 to ${target})
                </div>
            `;
            
            // Create DP table visualization
            dpTableContainer.innerHTML = '';
            for (let i = 0; i <= target; i++) {
                const cell = document.createElement('div');
                cell.className = 'partition-cell';
                cell.textContent = i;
                if (i === 0) {
                    cell.classList.add('target');
                    cell.textContent = "0 ";
                }
                dpTableContainer.appendChild(cell);
            }
            
            // Initialize DP array
            const dp = new Array(target + 1).fill(false);
            dp[0] = true;
            
            let currentNumIndex = 0;
            
            function processNextNumber() {
                if (currentNumIndex >= nums.length) {
                    // All numbers processed
                    explanation.innerHTML = `Step 5: Check if target ${target} is achievable`;
                    
                    // Highlight target cell
                    const dpCells = dpTableContainer.querySelectorAll('.partition-cell');
                    const targetCell = dpCells[target];
                    
                    setTimeout(() => {
                        if (dp[target]) {
                            targetCell.classList.add('possible');
                            targetCell.textContent = `${target} `;
                            
                            explanation.innerHTML = `<strong>Success!</strong> Target sum ${target} is achievable`;
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step active">
                                    <strong>Result:</strong> Target ${target} is achievable  Partition POSSIBLE
                                </div>
                            `;
                            
                            partitionResult.textContent = "YES";
                            partitionResult.style.color = "var(--success-color)";
                            
                            // Find and display subsets
                            findAndDisplayPartitionSubsets(nums, target);
                            
                        } else {
                            targetCell.classList.add('impossible');
                            targetCell.textContent = `${target} `;
                            
                            explanation.innerHTML = `<strong>Failed!</strong> Target sum ${target} is NOT achievable`;
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step active">
                                    <strong>Result:</strong> Target ${target} is NOT achievable  Partition IMPOSSIBLE
                                </div>
                            `;
                            
                            partitionResult.textContent = "NO";
                            partitionResult.style.color = "var(--danger-color)";
                        }
                        
                        resultContainer.style.display = "block";
                        continueButton.style.display = "block";
                        
                        // Auto-return after 20 seconds
                        setTimeout(() => {
                            returnToOriginalAfterPartitionEqual();
                        }, 20000);
                        
                        continueButton.addEventListener('click', returnToOriginalAfterPartitionEqual);
                    }, 1000);
                    
                    return;
                }
                
                const num = nums[currentNumIndex];
                explanation.innerHTML = `Step 4: Processing number ${num} (index ${currentNumIndex})`;
                
                // Highlight current number in original array
                const originalElements = originalContainer.querySelectorAll('.array-element');
                originalElements[currentNumIndex].querySelector('.element-value').classList.add('partition-current');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step 4.${currentNumIndex + 1}:</strong> Process number ${num}
                    </div>
                `;
                
                setTimeout(() => {
                    // Process DP backwards
                    let updates = [];
                    
                    // Find which sums can be formed
                    for (let i = target; i >= num; i--) {
                        if (dp[i - num] && !dp[i]) {
                            dp[i] = true;
                            updates.push(i);
                        }
                    }
                    
                    // Highlight updated cells in DP table
                    const dpCells = dpTableContainer.querySelectorAll('.partition-cell');
                    updates.forEach(sum => {
                        setTimeout(() => {
                            dpCells[sum].classList.add('possible');
                            dpCells[sum].textContent = `${sum} `;
                            
                            // Show which sum contributed
                            const originalCell = dpCells[sum - num];
                            if (originalCell) {
                                originalCell.style.boxShadow = '0 0 10px var(--warning-color)';
                                setTimeout(() => {
                                    originalCell.style.boxShadow = '';
                                }, 1000);
                            }
                        }, (updates.indexOf(sum) * 300));
                    });
                    
                    // Remove highlight from current number
                    setTimeout(() => {
                        originalElements[currentNumIndex].querySelector('.element-value').classList.remove('partition-current');
                        currentNumIndex++;
                        processNextNumber();
                    }, updates.length * 300 + 500);
                    
                }, 1000);
            }
            
            // Start processing numbers
            processNextNumber();
            
        }, 1000);
        
    }, 1000);
}

// NEW: Find and display partition subsets
function findAndDisplayPartitionSubsets(nums, target) {
    const subsetsContainer = document.getElementById('partitionEqualSubsetsContainer');
    
    // Find one possible subset that sums to target
    const n = nums.length;
    const dp = new Array(target + 1).fill(false);
    const elementUsed = new Array(n).fill(false);
    dp[0] = true;
    
    // Build DP table
    for (let i = 0; i < n; i++) {
        for (let j = target; j >= nums[i]; j--) {
            if (dp[j - nums[i]] && !dp[j]) {
                dp[j] = true;
            }
        }
    }
    
    // Backtrack to find subset
    let remaining = target;
    const subset1 = [];
    const subset2 = [];
    const used = new Array(n).fill(false);
    
    for (let i = n - 1; i >= 0; i--) {
        if (remaining >= nums[i] && dp[remaining - nums[i]]) {
            subset1.push(nums[i]);
            used[i] = true;
            remaining -= nums[i];
        }
    }
    
    // Remaining elements go to subset2
    for (let i = 0; i < n; i++) {
        if (!used[i]) {
            subset2.push(nums[i]);
        }
    }
    
    // Display subsets
    subsetsContainer.innerHTML = `
        <div class="mt-3">
            <h6>Example Partition:</h6>
            <div class="row">
                <div class="col-md-6">
                    <div class="stats-card">
                        <div>Subset 1 (Sum = ${target})</div>
                        <div class="stats-value">${subset1.join(' + ')} = ${target}</div>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="stats-card">
                        <div>Subset 2 (Sum = ${target})</div>
                        <div class="stats-value">${subset2.join(' + ')} = ${target}</div>
                    </div>
                </div>
            </div>
        </div>
    `;
}

// NEW: Return to Original after Partition Equal
function returnToOriginalAfterPartitionEqual() {
    // Reset to original array
    myArray = [...originalArrayForPartitionEqual];
    originalArrayForPartitionEqual = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isPartitionEqualRunning = false;
    
    logOperation('Partition Equal Subset Sum completed - returned to original array', 'info');
    showNotification('Returned to original array after partition operation', 'success');
}
// NEW: Target Sum Handler
function handleTargetSum() {
    const target = parseInt(targetSumInput.value);
    
    if (isNaN(target)) {
        showNotification('Please enter a valid target sum', 'danger');
        targetSumInput.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    let numericArray = [];
    
    for (let i = 0; i < myArray.length; i++) {
        const num = parseFloat(myArray[i]);
        if (isNaN(num)) {
            allNumbers = false;
            break;
        }
        numericArray.push(num);
    }
    
    if (!allNumbers) {
        showNotification('Target sum operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    if (isTargetSumRunning) {
        showNotification('A target sum operation is already in progress', 'warning');
        return;
    }
    
    isTargetSumRunning = true;
    
    // Store original array
    originalArrayForTargetSum = [...myArray];
    
    // Start target sum visualization
    showTargetSumVisualization(numericArray, target);
}
// NEW: Target Sum Handler
function handleTargetSum() {
    const target = parseInt(targetSumInput.value);
    
    if (isNaN(target)) {
        showNotification('Please enter a valid target sum', 'danger');
        targetSumInput.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    let numericArray = [];
    
    for (let i = 0; i < myArray.length; i++) {
        const num = parseFloat(myArray[i]);
        if (isNaN(num)) {
            allNumbers = false;
            break;
        }
        numericArray.push(num);
    }
    
    if (!allNumbers) {
        showNotification('Target sum operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    if (isTargetSumRunning) {
        showNotification('A target sum operation is already in progress', 'warning');
        return;
    }
    
    isTargetSumRunning = true;
    
    // Store original array
    originalArrayForTargetSum = [...myArray];
    
    // Start target sum visualization
    showTargetSumVisualization(numericArray, target);
}
// NEW: Show Target Sum Visualization
function showTargetSumVisualization(nums, target) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Target Sum (assign + or - to get ${target})</h5>
        
        <div class="array-group">
            <div class="array-label">Array Numbers</div>
            <div class="original-array-container" id="targetSumArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Problem:</strong> Find number of ways to assign '+' or '-' to each number to get target sum = ${target}</p>
            <p class="mb-0" id="targetSumExplanation">Starting target sum calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="targetSumStepsContainer">
            <h6 class="text-center">Recursive DFS Steps (Memoization)</h6>
            <div class="steps-container" id="targetSumSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Total Ways Found</div>
            <div class="stats-value" id="totalWaysValue">0</div>
        </div>
        
        <div class="target-sum-results mt-3" id="targetSumResults" style="display: none;">
            <h6 class="text-center">Valid Expressions</h6>
            <div id="expressionsList" class="mt-2 text-center"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterTargetSum" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(nums.map(n => n.toString()), 'targetSumArray');
    
    performTargetSumAlgorithm(nums, target);
}

// NEW: Perform Target Sum Algorithm with Animation
function performTargetSumAlgorithm(nums, target) {
    const arrayContainer = document.getElementById('targetSumArray');
    const explanation = document.getElementById('targetSumExplanation');
    const stepsContainer = document.getElementById('targetSumSteps');
    const totalWaysValue = document.getElementById('totalWaysValue');
    const resultsContainer = document.getElementById('targetSumResults');
    const expressionsList = document.getElementById('expressionsList');
    const continueButton = document.getElementById('continueAfterTargetSum');
    
    const memo = new Map();
    targetSumResults = [];
    let stepCounter = 0;
    let totalWays = 0;
    
    // Function to generate all expressions
    function generateExpressions(currentPath) {
        if (currentPath.length === nums.length) {
            // Calculate sum of current expression
            let sum = 0;
            let expression = "";
            
            for (let i = 0; i < nums.length; i++) {
                if (currentPath[i] === '+') {
                    sum += nums[i];
                    expression += `+${nums[i]}`;
                } else {
                    sum -= nums[i];
                    expression += `-${nums[i]}`;
                }
            }
            
            // Check if matches target
            if (sum === target) {
                targetSumResults.push({
                    expression: expression.substring(1), // Remove leading +
                    sum: sum
                });
                totalWays++;
            }
            return;
        }
        
        // Try '+' for current number
        currentPath.push('+');
        generateExpressions([...currentPath]);
        currentPath.pop();
        
        // Try '-' for current number
        currentPath.push('-');
        generateExpressions([...currentPath]);
        currentPath.pop();
    }
    
    // Recursive DFS function with memoization
    async function dfs(index, currentSum, currentExpression, depth = 0) {
        stepCounter++;
        
        // Create memo key
        const memoKey = `${index}_${currentSum}`;
        
        // Check memo
        if (memo.has(memoKey)) {
            explanation.innerHTML = `Step ${stepCounter}: Memo hit! Already computed ways from index ${index} with sum ${currentSum}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${stepCounter}:</strong> Memo hit at (index=${index}, sum=${currentSum})  ${memo.get(memoKey)} ways
                </div>
            `;
            
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            totalWaysValue.textContent = totalWays;
            
            return memo.get(memoKey);
        }
        
        if (index === nums.length) {
            // Base case: reached end of array
            if (currentSum === target) {
                explanation.innerHTML = `Step ${stepCounter}: Found match! Expression "${currentExpression}" = ${currentSum}`;
                
                // Highlight this successful path
                const elements = arrayContainer.querySelectorAll('.array-element');
                for (let i = 0; i < elements.length; i++) {
                    setTimeout(() => {
                        elements[i].querySelector('.element-value').classList.add('target-sum-match');
                    }, i * 200);
                }
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${stepCounter}:</strong> Found valid expression! "${currentExpression}" = ${currentSum} 
                    </div>
                `;
                
                // Store the valid expression
                targetSumResults.push({
                    expression: currentExpression,
                    sum: currentSum
                });
                totalWays++;
                totalWaysValue.textContent = totalWays;
                
                // Wait to show the highlight
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                // Remove highlights
                for (let i = 0; i < elements.length; i++) {
                    elements[i].querySelector('.element-value').classList.remove('target-sum-match');
                }
                
                memo.set(memoKey, 1);
                return 1;
            } else {
                explanation.innerHTML = `Step ${stepCounter}: End reached with sum ${currentSum} (target is ${target})`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${stepCounter}:</strong> End reached - sum ${currentSum}  target ${target}
                    </div>
                `;
                
                memo.set(memoKey, 0);
                return 0;
            }
        }
        
        // Highlight current element being processed
        explanation.innerHTML = `Step ${stepCounter}: Processing number ${nums[index]} at index ${index} (current sum: ${currentSum})`;
        
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElement = elements[index].querySelector('.element-value');
        currentElement.classList.add('target-sum-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${stepCounter}:</strong> Processing nums[${index}] = ${nums[index]} (current sum: ${currentSum})
            </div>
        `;
        
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Wait for animation
        await new Promise(resolve => setTimeout(resolve, 1500));
        
        // Try '+' option
        explanation.innerHTML = `Step ${stepCounter}+1: Trying '+' for ${nums[index]}  sum becomes ${currentSum + nums[index]}`;
        
        currentElement.classList.remove('target-sum-current');
        currentElement.classList.add('target-sum-positive');
        
        const addExpression = currentExpression ? `${currentExpression}+${nums[index]}` : `+${nums[index]}`;
        const addWays = await dfs(index + 1, currentSum + nums[index], addExpression, depth + 1);
        
        // Wait before trying '-'
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Try '-' option
        explanation.innerHTML = `Step ${stepCounter}+2: Trying '-' for ${nums[index]}  sum becomes ${currentSum - nums[index]}`;
        
        currentElement.classList.remove('target-sum-positive');
        currentElement.classList.add('target-sum-negative');
        
        const subtractExpression = currentExpression ? `${currentExpression}-${nums[index]}` : `-${nums[index]}`;
        const subtractWays = await dfs(index + 1, currentSum - nums[index], subtractExpression, depth + 1);
        
        // Remove highlight
        currentElement.classList.remove('target-sum-negative');
        
        const total = addWays + subtractWays;
        memo.set(memoKey, total);
        
        explanation.innerHTML = `Step ${stepCounter}+3: From index ${index} with sum ${currentSum}, found ${total} ways (${addWays} from +, ${subtractWays} from -)`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${total > 0 ? 'active' : ''}">
                <strong>Step:</strong> Memo[(${index},${currentSum})] = ${addWays} + ${subtractWays} = ${total} ways
            </div>
        `;
        
        return total;
    }
    
    // Start the algorithm
    dfs(0, 0, "", 0).then(() => {
        // Algorithm completed
        explanation.innerHTML = `<strong>Target Sum Algorithm Completed!</strong> Found ${totalWays} way(s) to reach target ${target}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Final:</strong> Total ways to get sum ${target} = ${totalWays}
            </div>
        `;
        
        // Show results if any found
        if (targetSumResults.length > 0) {
            resultsContainer.style.display = 'block';
            expressionsList.innerHTML = '';
            
            // Show all valid expressions (limit to first 10 for display)
            const displayResults = targetSumResults.slice(0, 10);
            
            displayResults.forEach((result, idx) => {
                const expressionDiv = document.createElement('div');
                expressionDiv.className = 'target-sum-expression slide-in';
                expressionDiv.innerHTML = `${result.expression} = ${result.sum}`;
                expressionsList.appendChild(expressionDiv);
            });
            
            if (targetSumResults.length > 10) {
                const moreDiv = document.createElement('div');
                moreDiv.className = 'text-muted mt-2';
                moreDiv.textContent = `... and ${targetSumResults.length - 10} more expressions`;
                expressionsList.appendChild(moreDiv);
            }
        }
        
        continueButton.style.display = 'block';
        
        // Auto-return after 20 seconds
        setTimeout(() => {
            returnToOriginalAfterTargetSum();
        }, 20000);
        
        continueButton.addEventListener('click', returnToOriginalAfterTargetSum);
    });
}

// NEW: Return to Original after Target Sum
function returnToOriginalAfterTargetSum() {
    // Reset to original array
    myArray = [...originalArrayForTargetSum];
    originalArrayForTargetSum = [];
    targetSumResults = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isTargetSumRunning = false;
    
    // Clear input
    targetSumInput.value = '';
    
    logOperation('Target sum operation completed - returned to original array', 'info');
    showNotification('Returned to original array after target sum operation', 'success');
}
// Helper function to render array in a specific container
function renderArrayInContainer(arr, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (arr.length === 0) {
        container.innerHTML = '<div class="array-empty-state"><i class="fas fa-layer-group"></i><h4>Array is Empty</h4></div>';
        return;
    }
    
    arr.forEach((value, index) => {
        const elementDiv = document.createElement('div');
        elementDiv.className = 'array-element';
        
        const valueDiv = document.createElement('div');
        valueDiv.className = 'element-value';
        valueDiv.textContent = value;
        
        const indexDiv = document.createElement('div');
        indexDiv.className = 'element-index';
        indexDiv.textContent = `[${index}]`;
        
        elementDiv.appendChild(valueDiv);
        elementDiv.appendChild(indexDiv);
        container.appendChild(elementDiv);
    });
}
// NEW: Word Break Handler
function handleWordBreak() {
    if (isWordBreakRunning) {
        showNotification('Word break operation is already in progress', 'warning');
        return;
    }
    
    // Show input group
    wordBreakGroup.style.display = 'block';
    wordBreakStringInput.focus();
    
    // Set example values
    wordBreakStringInput.value = 'leetcode';
    wordDictInput.value = 'leet,code';
    
    logOperation('Started word break problem', 'info');
    showNotification('Enter a string and dictionary words to check word break', 'info');
}

// NEW: Perform Word Break Handler
function handlePerformWordBreak() {
    const s = wordBreakStringInput.value.trim();
    const dictStr = wordDictInput.value.trim();
    
    if (s === '') {
        showNotification('Please enter a string to check', 'danger');
        wordBreakStringInput.focus();
        return;
    }
    
    if (dictStr === '') {
        showNotification('Please enter dictionary words', 'danger');
        wordDictInput.focus();
        return;
    }
    
    // Parse dictionary words
    const dict = dictStr.split(',').map(word => word.trim()).filter(word => word !== '');
    
    if (dict.length === 0) {
        showNotification('Please enter valid dictionary words', 'danger');
        wordDictInput.focus();
        return;
    }
    
    // Store original array
    originalArrayForWordBreak = [...myArray];
    
    // Set data
    wordBreakString = s;
    wordDict = dict;
    
    // Hide input group
    wordBreakGroup.style.display = 'none';
    
    // Start word break visualization
    showWordBreakVisualization();
}

// NEW: Cancel Word Break Handler
function handleCancelWordBreak() {
    wordBreakGroup.style.display = 'none';
    wordBreakStringInput.value = '';
    wordDictInput.value = '';
    
    wordBreakString = '';
    wordDict = [];
    
    logOperation('Cancelled word break operation', 'info');
    showNotification('Word break operation cancelled', 'info');
}

// NEW: Show Word Break Visualization
function showWordBreakVisualization() {
    isWordBreakRunning = true;
    
    const container = document.createElement('div');
    container.className = 'word-break-container';
    container.innerHTML = `
        <h5 class="text-center mb-3">Word Break Problem</h5>
        
        <div class="mb-4">
            <h6 class="text-center">String to Analyze:</h6>
            <div class="word-break-string" id="wordBreakStringDisplay">${wordBreakString}</div>
        </div>
        
        <div class="mb-4">
            <h6 class="text-center">Dictionary Words:</h6>
            <div class="d-flex flex-wrap justify-content-center" id="wordDictDisplay"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Dynamic Programming - dp[i] = true if s[0:i] can be segmented</p>
            <p class="mb-0" id="wordBreakExplanation">Initializing word break algorithm...</p>
        </div>
        
        <div class="mb-4">
            <h6 class="text-center">DP Table (dp[i] for i=0 to n):</h6>
            <div class="dp-table" id="dpTable"></div>
        </div>
        
        <div class="mb-4">
            <h6 class="text-center">String Segmentation:</h6>
            <div id="segmentationDisplay" class="text-center"></div>
        </div>
        
        <div class="stats-card mt-3" id="resultContainer" style="display: none;">
            <div>Result</div>
            <div class="stats-value" id="wordBreakResult"></div>
        </div>
        
        <div class="algorithm-steps mt-3" id="wordBreakStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="wordBreakSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterWordBreak" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(container);
    
    // Display dictionary words
    const dictDisplay = document.getElementById('wordDictDisplay');
    wordDict.forEach(word => {
        const wordSpan = document.createElement('span');
        wordSpan.className = 'word-break-segment';
        wordSpan.textContent = word;
        dictDisplay.appendChild(wordSpan);
    });
    
    // Initialize DP table display
    initializeDPTable();
    
    // Start word break algorithm animation
    performWordBreakAnimation();
}

// NEW: Initialize DP Table
function initializeDPTable() {
    const dpTable = document.getElementById('dpTable');
    const n = wordBreakString.length;
    
    // Add index row
    for (let i = 0; i <= n; i++) {
        const cell = document.createElement('div');
        cell.className = 'dp-cell';
        cell.textContent = i;
        cell.id = `dp-cell-${i}`;
        dpTable.appendChild(cell);
    }
    
    // Add initial value (dp[0] = true)
    const dp0 = document.getElementById('dp-cell-0');
    dp0.classList.add('true');
    dp0.textContent = 'T';
}

// NEW: Perform Word Break Animation
function performWordBreakAnimation() {
    const explanation = document.getElementById('wordBreakExplanation');
    const stepsContainer = document.getElementById('wordBreakSteps');
    const resultContainer = document.getElementById('resultContainer');
    const resultDiv = document.getElementById('wordBreakResult');
    const segmentationDisplay = document.getElementById('segmentationDisplay');
    const continueButton = document.getElementById('continueAfterWordBreak');
    
    const s = wordBreakString;
    const wordSet = new Set(wordDict);
    const n = s.length;
    
    // dp[i] means s[0:i] can be segmented
    const dp = new Array(n + 1).fill(false);
    dp[0] = true;  // empty string
    const segmentation = new Array(n + 1).fill('');
    
    let step = 0;
    let i = 1;
    
    function performStep() {
        if (i > n) {
            // Algorithm completed
            const result = dp[n];
            
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Final result: dp[${n}] = ${result}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${result ? 'active' : ''}">
                    <strong>Final:</strong> dp[${n}] = ${result} - String ${result ? 'CAN' : 'CANNOT'} be segmented
                </div>
            `;
            
            // Show result with appropriate color
            resultContainer.style.display = 'block';
            if (result) {
                resultDiv.innerHTML = `<span class="text-success">YES - String can be segmented</span>`;
                resultDiv.innerHTML += `<br><small>Segmentation: ${segmentation[n] || 'Not found'}</small>`;
                
                // Display segmentation
                if (segmentation[n]) {
                    const segments = segmentation[n].split(' ');
                    segments.forEach(segment => {
                        const segSpan = document.createElement('span');
                        segSpan.className = 'word-break-segment';
                        segSpan.textContent = segment;
                        segmentationDisplay.appendChild(segSpan);
                    });
                }
            } else {
                resultDiv.innerHTML = `<span class="text-danger">NO - String cannot be segmented</span>`;
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterWordBreak();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterWordBreak);
            
            return;
        }
        
        step++;
        explanation.innerHTML = `Step ${step}: Checking if s[0:${i}] can be segmented`;
        
        // Highlight current i in DP table
        const currentCell = document.getElementById(`dp-cell-${i}`);
        currentCell.classList.add('current');
        
        // Also highlight the substring in the string display
        const stringDisplay = document.getElementById('wordBreakStringDisplay');
        const originalHTML = stringDisplay.innerHTML;
        stringDisplay.innerHTML = 
            `<span class="text-warning">${s.substring(0, i)}</span>` + 
            `<span>${s.substring(i)}</span>`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Checking dp[${i}] - substring "${s.substring(0, i)}"
            </div>
        `;
        
        let found = false;
        let j = 0;
        
        function checkSubstring() {
            if (j >= i) {
                // Finished checking all j for current i
                setTimeout(() => {
                    // Update DP cell
                    currentCell.classList.remove('current');
                    if (dp[i]) {
                        currentCell.classList.add('true');
                        currentCell.textContent = 'T';
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Result:</strong> dp[${i}] = TRUE (found valid segmentation)
                            </div>
                        `;
                    } else {
                        currentCell.textContent = 'F';
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Result:</strong> dp[${i}] = FALSE (no valid segmentation found)
                            </div>
                        `;
                    }
                    
                    // Restore string display
                    stringDisplay.innerHTML = originalHTML;
                    
                    // Move to next i
                    i++;
                    setTimeout(performStep, 1000);
                }, 1000);
                
                return;
            }
            
            // Check if s[0:j] can be segmented and s[j:i] is in dictionary
            if (dp[j]) {
                const substring = s.substring(j, i);
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Checking:</strong> dp[${j}] = true and substring "${substring}" 
                        ${wordSet.has(substring) ? 'IS in dictionary' : 'is NOT in dictionary'}
                    </div>
                `;
                
                // Highlight the substring being checked
                stringDisplay.innerHTML = 
                    `<span class="text-info">${s.substring(0, j)}</span>` +
                    `<span class="text-warning">${s.substring(j, i)}</span>` +
                    `<span>${s.substring(i)}</span>`;
                
                setTimeout(() => {
                    if (wordSet.has(substring)) {
                        // Found valid segmentation
                        dp[i] = true;
                        segmentation[i] = (segmentation[j] ? segmentation[j] + ' ' : '') + substring;
                        found = true;
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>FOUND:</strong> "${substring}" is in dictionary! dp[${i}] = true
                            </div>
                        `;
                        
                        // Skip remaining j values since we found a valid segmentation
                        j = i; // This will exit the loop
                    }
                    
                    j++;
                    checkSubstring();
                }, 1500);
            } else {
                j++;
                checkSubstring();
            }
        }
        
        // Start checking substrings for current i
        setTimeout(checkSubstring, 1000);
    }
    
    // Start algorithm
    performStep();
}

// NEW: Return to Original after Word Break
function returnToOriginalAfterWordBreak() {
    // Reset to original array
    myArray = [...originalArrayForWordBreak];
    originalArrayForWordBreak = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state and clear inputs
    isWordBreakRunning = false;
    wordBreakString = '';
    wordDict = [];
    wordBreakGroup.style.display = 'none';
    wordBreakStringInput.value = '';
    wordDictInput.value = '';
    
    // Highlight all elements
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation('Word break operation completed - returned to original array', 'info');
    showNotification('Returned to original array after word break demonstration', 'success');
}
// NEW: Max Rectangle Handler
function handleMaxRectangle() {
    const k = parseInt(maxRectangleSum.value);
    
    if (isNaN(k)) {
        showNotification('Please enter a valid target sum K', 'danger');
        maxRectangleSum.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('This algorithm requires all array elements to be numbers', 'danger');
        return;
    }
    
    if (isMaxRectangleRunning) {
        showNotification('Max rectangle operation is already in progress', 'warning');
        return;
    }
    
    isMaxRectangleRunning = true;
    
    // Store original array
    originalArrayForMaxRectangle = [...myArray];
    
    // Perform max rectangle visualization
    performMaxRectangleVisualization(k);
}

// NEW: Perform Max Rectangle Visualization
function performMaxRectangleVisualization(k) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Maximum Subarray Sum No Larger Than ${k}</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalMaxRectangleArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Algorithm Process Visualization</div>
            <div class="transformed-array-container" id="transformedMaxRectangleArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find maximum subarray sum no larger than ${k}</p>
            <p class="mb-0" id="maxRectangleExplanation">Initializing algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="maxRectangleStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="maxRectangleSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Maximum Sum Found</div>
            <div class="stats-value" id="maxRectangleSumValue">-</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Subarray Indices</div>
            <div class="stats-value" id="maxRectangleIndices">-</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Subarray Elements</div>
            <div class="stats-value" id="maxRectangleElements">-</div>
        </div>
        
        <div class="prefix-sum-table-container mt-3" style="display: none;">
            <h6 class="text-center">Prefix Sums Tracking</h6>
            <div class="table-container">
                <table class="table table-dark frequency-table" id="prefixSumTable">
                    <thead>
                        <tr>
                            <th>Index</th>
                            <th>Prefix Sum</th>
                            <th>Sorted Prefixes</th>
                        </tr>
                    </thead>
                    <tbody id="prefixSumTableBody"></tbody>
                </table>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMaxRectangle" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForMaxRectangle, 'originalMaxRectangleArray');
    renderArrayInContainer([...originalArrayForMaxRectangle], 'transformedMaxRectangleArray');
    
    executeMaxRectangleAlgorithm(k);
}

// NEW: Execute Max Rectangle Algorithm with Animation
function executeMaxRectangleAlgorithm(k) {
    const originalContainer = document.getElementById('originalMaxRectangleArray');
    const transformedContainer = document.getElementById('transformedMaxRectangleArray');
    const explanation = document.getElementById('maxRectangleExplanation');
    const stepsContainer = document.getElementById('maxRectangleSteps');
    const maxRectangleSumValue = document.getElementById('maxRectangleSumValue');
    const maxRectangleIndices = document.getElementById('maxRectangleIndices');
    const maxRectangleElements = document.getElementById('maxRectangleElements');
    const prefixSumTableContainer = document.querySelector('.prefix-sum-table-container');
    const prefixSumTableBody = document.getElementById('prefixSumTableBody');
    const continueButton = document.getElementById('continueAfterMaxRectangle');
    
    const arr = originalArrayForMaxRectangle.map(val => parseFloat(val));
    let prefixSum = 0;
    let maxSum = -Infinity;
    let sortedPrefixes = [0];
    let maxStart = 0;
    let maxEnd = 0;
    let currentStart = 0;
    let step = 0;
    
    // Show prefix sum table
    prefixSumTableContainer.style.display = 'block';
    updatePrefixSumTable(prefixSumTableBody, -1, 0, sortedPrefixes);
    
    function updatePrefixSumTable(tableBody, index, currentPrefix, sortedPrefixes) {
        tableBody.innerHTML = '';
        
        if (index === -1) {
            // Initial state
            tableBody.innerHTML = `
                <tr>
                    <td>-</td>
                    <td>-</td>
                    <td>[0]</td>
                </tr>
            `;
        } else {
            tableBody.innerHTML = `
                <tr>
                    <td>${index}</td>
                    <td>${currentPrefix}</td>
                    <td>[${sortedPrefixes.join(', ')}]</td>
                </tr>
            `;
        }
    }
    
    function performAlgorithmStep(i) {
        if (i >= arr.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Maximum subarray sum no larger than ${k} found.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Maximum sum = ${maxSum} from indices ${maxStart} to ${maxEnd}
                </div>
            `;
            
            // Highlight the maximum subarray
            const originalElements = originalContainer.querySelectorAll('.array-element');
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            
            for (let j = maxStart; j <= maxEnd; j++) {
                setTimeout(() => {
                    originalElements[j].querySelector('.element-value').classList.add('kadane-max-subarray');
                    transformedElements[j].querySelector('.element-value').classList.add('kadane-max-subarray');
                }, (j - maxStart) * 200);
            }
            
            maxRectangleSumValue.textContent = maxSum;
            maxRectangleIndices.textContent = `${maxStart} to ${maxEnd}`;
            maxRectangleElements.textContent = `[${arr.slice(maxStart, maxEnd + 1).join(', ')}]`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 20 seconds
            setTimeout(() => {
                returnToOriginalAfterMaxRectangle();
            }, 20000);
            
            continueButton.addEventListener('click', returnToOriginalAfterMaxRectangle);
            
            return;
        }
        
        step++;
        
        // Highlight current element being processed
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        
        originalElements[i].querySelector('.element-value').classList.add('kadane-current');
        transformedElements[i].querySelector('.element-value').classList.add('kadane-current');
        
        // Step 1: Update prefix sum
        explanation.innerHTML = `Step ${step}: Processing element [${i}] = ${arr[i]}`;
        
        setTimeout(() => {
            // Add current number to running prefix sum
            prefixSum += arr[i];
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}.1:</strong> Prefix sum updated: ${prefixSum - arr[i]} + ${arr[i]} = ${prefixSum}
                </div>
            `;
            
            // Update prefix sum table
            updatePrefixSumTable(prefixSumTableBody, i, prefixSum, sortedPrefixes);
            
            // Step 2: Calculate target
            const target = prefixSum - k;
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}.2:</strong> Need old_prefix  ${prefixSum} - ${k} = ${target}
                </div>
            `;
            
            // Step 3: Find smallest old_prefix  target using binary search
            setTimeout(() => {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step}.3:</strong> Searching in sorted_prefixes [${sortedPrefixes.join(', ')}] for value  ${target}
                    </div>
                `;
                
                // Simulate binary search in sorted_prefixes
                performBinarySearchInPrefixes(i, target, prefixSum);
            }, 1000);
        }, 1000);
        
        function performBinarySearchInPrefixes(i, target, currentPrefix) {
            // Find index using binary search
            let left = 0;
            let right = sortedPrefixes.length - 1;
            let idx = sortedPrefixes.length; // Default to length if not found
            
            // Animate binary search
            function animateBinarySearchStep() {
                if (left > right) {
                    // Binary search completed
                    processSearchResult(idx, i, target, currentPrefix);
                    return;
                }
                
                const mid = Math.floor((left + right) / 2);
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step}.3.${mid}:</strong> Checking sorted_prefixes[${mid}] = ${sortedPrefixes[mid]}  ${target}?
                    </div>
                `;
                
                if (sortedPrefixes[mid] >= target) {
                    idx = mid;
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
                
                setTimeout(animateBinarySearchStep, 500);
            }
            
            animateBinarySearchStep();
        }
        
        function processSearchResult(idx, i, target, currentPrefix) {
            setTimeout(() => {
                if (idx < sortedPrefixes.length) {
                    const old_prefix = sortedPrefixes[idx];
                    const current_sum = currentPrefix - old_prefix;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step}.4:</strong> Found old_prefix = ${old_prefix} at index ${idx}
                        </div>
                        <div class="algorithm-step">
                            <strong>Step ${step}.5:</strong> Subarray sum = ${currentPrefix} - ${old_prefix} = ${current_sum}
                        </div>
                    `;
                    
                    // Highlight the potential subarray
                    if (current_sum > maxSum) {
                        maxSum = current_sum;
                        
                        // Find start index for this subarray
                        // This is simplified - in real algorithm we'd track the index of each prefix
                        let tempStart = 0;
                        for (let j = 0; j <= i; j++) {
                            let tempSum = 0;
                            for (let m = j; m <= i; m++) {
                                tempSum += arr[m];
                            }
                            if (Math.abs(tempSum - current_sum) < 0.001) {
                                tempStart = j;
                                break;
                            }
                        }
                        
                        maxStart = tempStart;
                        maxEnd = i;
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Step ${step}.6:</strong> New maximum found! Updated max_sum = ${maxSum} (indices ${maxStart}-${maxEnd})
                            </div>
                        `;
                        
                        // Highlight the new maximum subarray briefly
                        const transformedElements = transformedContainer.querySelectorAll('.array-element');
                        for (let j = maxStart; j <= maxEnd; j++) {
                            transformedElements[j].querySelector('.element-value').classList.add('kadane-included');
                        }
                        
                        setTimeout(() => {
                            for (let j = maxStart; j <= maxEnd; j++) {
                                transformedElements[j].querySelector('.element-value').classList.remove('kadane-included');
                            }
                        }, 1500);
                    }
                } else {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step}.4:</strong> No suitable old_prefix found in sorted_prefixes
                        </div>
                    `;
                }
                
                // Step 7: Insert current prefix into sorted_prefixes
                setTimeout(() => {
                    // Insert in sorted order (simulating bisect.insort)
                    let insertIdx = sortedPrefixes.length;
                    for (let j = 0; j < sortedPrefixes.length; j++) {
                        if (currentPrefix <= sortedPrefixes[j]) {
                            insertIdx = j;
                            break;
                        }
                    }
                    
                    sortedPrefixes.splice(insertIdx, 0, currentPrefix);
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step}.7:</strong> Added ${currentPrefix} to sorted_prefixes: [${sortedPrefixes.join(', ')}]
                        </div>
                    `;
                    
                    // Update prefix sum table
                    updatePrefixSumTable(prefixSumTableBody, i, currentPrefix, sortedPrefixes);
                    
                    // Remove current element highlight
                    const originalElements = originalContainer.querySelectorAll('.array-element');
                    const transformedElements = transformedContainer.querySelectorAll('.array-element');
                    
                    originalElements[i].querySelector('.element-value').classList.remove('kadane-current');
                    transformedElements[i].querySelector('.element-value').classList.remove('kadane-current');
                    
                    // Update statistics
                    maxRectangleSumValue.textContent = maxSum === -Infinity ? '-' : maxSum;
                    if (maxSum !== -Infinity) {
                        maxRectangleIndices.textContent = `${maxStart} to ${maxEnd}`;
                        maxRectangleElements.textContent = `[${arr.slice(maxStart, maxEnd + 1).join(', ')}]`;
                    }
                    
                    // Move to next element
                    performAlgorithmStep(i + 1);
                }, 1000);
            }, 500);
        }
    }
    
    // Start algorithm
    performAlgorithmStep(0);
}

// NEW: Return to Original after Max Rectangle
function returnToOriginalAfterMaxRectangle() {
    // Reset to original array
    myArray = [...originalArrayForMaxRectangle];
    originalArrayForMaxRectangle = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMaxRectangleRunning = false;
    
    // Clear input
    maxRectangleSum.value = '';
    
    logOperation('Max rectangle operation completed - returned to original array', 'info');
    showNotification('Returned to original array after max rectangle operation', 'success');
}
// NEW: LRU Cache Handler
function handleLRUCache() {
    if (isLRUCacheRunning) {
        showNotification('LRU Cache simulation is already running', 'warning');
        return;
    }
    
    // Store original array
    originalArrayForLRU = [...myArray];
    isLRUCacheRunning = true;
    
    // Show LRU Cache interface
    showLRUCacheInterface();
}

// NEW: Show LRU Cache Interface
function showLRUCacheInterface() {
    const lruContainer = document.createElement('div');
    lruContainer.className = 'lru-cache-container';
    lruContainer.innerHTML = `
        <div class="lru-cache-header">
            <h4 class="mb-0">LRU Cache Simulation</h4>
            <div class="lru-cache-stats">
                <div class="lru-stat-card">
                    <div class="lru-stat-label">Capacity</div>
                    <div class="lru-stat-value" id="lruCapacity">${lruCapacity}</div>
                </div>
                <div class="lru-stat-card">
                    <div class="lru-stat-label">Size</div>
                    <div class="lru-stat-value" id="lruSize">0</div>
                </div>
                <div class="lru-stat-card">
                    <div class="lru-stat-label">Hits</div>
                    <div class="lru-stat-value" id="lruHits">0</div>
                </div>
                <div class="lru-stat-card">
                    <div class="lru-stat-label">Misses</div>
                    <div class="lru-stat-value" id="lruMisses">0</div>
                </div>
            </div>
        </div>
        
        <div class="lru-cache-visualization">
            <div class="lru-cache-sections">
                <div class="lru-section">
                    <div class="lru-section-title">Cache Array (Order: LRU  MRU)</div>
                    <div class="lru-array-container" id="lruArrayContainer">
                        <div class="lru-cache-empty" id="lruArrayEmpty">
                            <i class="fas fa-layer-group"></i>
                            <p>Cache is empty</p>
                        </div>
                    </div>
                </div>
                
                <div class="lru-section">
                    <div class="lru-section-title">HashMap (Key  Index)</div>
                    <div class="lru-hashmap-container" id="lruHashMapContainer">
                        <div class="lru-cache-empty" id="lruHashMapEmpty">
                            <i class="fas fa-database"></i>
                            <p>HashMap is empty</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="lru-cache-operations">
                <div class="lru-capacity-selector">
                    <label>Set Capacity:</label>
                    <input type="number" class="lru-capacity-input" id="lruCapacityInput" 
                           value="${lruCapacity}" min="1" max="10">
                    <button class="lru-operation-btn" id="setCapacityBtn">
                        <i class="fas fa-check"></i> Set
                    </button>
                </div>
                
                <div class="lru-cache-operations">
                    <input type="text" class="lru-operation-input" id="lruKeyInput" 
                           placeholder="Enter key (e.g., A)">
                    <input type="text" class="lru-operation-input" id="lruValueInput" 
                           placeholder="Enter value (e.g., value_A)">
                    <button class="lru-operation-btn" id="lruPutBtn">
                        <i class="fas fa-plus-circle"></i> PUT
                    </button>
                    <button class="lru-operation-btn" id="lruGetBtn">
                        <i class="fas fa-search"></i> GET
                    </button>
                </div>
            </div>
            
            <div class="lru-log">
                <div class="lru-log-title">Operation Log</div>
                <div id="lruOperationLog">
                    <div class="lru-log-entry">
                        LRU Cache initialized with capacity ${lruCapacity}
                    </div>
                </div>
            </div>
            
            <div class="text-center mt-3">
                <button class="btn btn-outline-light" id="resetLRUBtn">
                    <i class="fas fa-undo me-2"></i>Reset LRU Cache
                </button>
                <button class="btn btn-outline-light ms-2" id="exitLRUBtn">
                    <i class="fas fa-times me-2"></i>Exit Simulation
                </button>
                <div class="text-muted mt-2">
                    <small>Press <kbd>Shift+R</kbd> to reset to original array</small>
                </div>
            </div>
        </div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(lruContainer);
    
    // Initialize LRU Cache
    initializeLRUCache();
    
    // Add event listeners for LRU operations
    document.getElementById('setCapacityBtn').addEventListener('click', handleSetCapacity);
    document.getElementById('lruPutBtn').addEventListener('click', handleLRUPut);
    document.getElementById('lruGetBtn').addEventListener('click', handleLRUGet);
    document.getElementById('resetLRUBtn').addEventListener('click', handleResetLRU);
    document.getElementById('exitLRUBtn').addEventListener('click', handleExitLRU);
    
    // Add Enter key support
    document.getElementById('lruCapacityInput').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') handleSetCapacity();
    });
    document.getElementById('lruKeyInput').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') handleLRUPut();
    });
    document.getElementById('lruValueInput').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') handleLRUPut();
    });
}

// NEW: LRU Cache Class
class LRUCache {
    constructor(capacity) {
        this.capacity = capacity;
        this.cache = []; // Array stores keys in order: [LRU, ..., MRU]
        this.map = new Map(); // HashMap: key -> {value, index}
        this.hits = 0;
        this.misses = 0;
        this.operations = 0;
    }
    
    // Update visualization
    updateVisualization() {
        this.renderArray();
        this.renderHashMap();
        this.updateStats();
    }
    
    // Render cache array
    renderArray() {
        const container = document.getElementById('lruArrayContainer');
        const emptyState = document.getElementById('lruArrayEmpty');
        
        if (this.cache.length === 0) {
            if (emptyState) emptyState.style.display = 'flex';
            return;
        }
        
        if (emptyState) emptyState.style.display = 'none';
        
        container.innerHTML = '';
        
        this.cache.forEach((key, index) => {
            const entry = this.map.get(key);
            const element = document.createElement('div');
            element.className = 'lru-array-element';
            element.innerHTML = `
                <div class="lru-array-value" data-key="${key}" id="array-${key}">
                    <div class="lru-array-key">${key}</div>
                    <div class="lru-array-data">${entry ? entry.value : 'N/A'}</div>
                </div>
                <div class="lru-array-index">Index: ${index}</div>
            `;
            container.appendChild(element);
        });
    }
    
    // Render hashmap
    renderHashMap() {
        const container = document.getElementById('lruHashMapContainer');
        const emptyState = document.getElementById('lruHashMapEmpty');
        
        if (this.map.size === 0) {
            if (emptyState) emptyState.style.display = 'flex';
            return;
        }
        
        if (emptyState) emptyState.style.display = 'none';
        
        container.innerHTML = '';
        
        this.map.forEach((entry, key) => {
            const element = document.createElement('div');
            element.className = 'lru-hashmap-entry';
            element.innerHTML = `
                <div class="lru-hashmap-key">${key}</div>
                <div class="lru-hashmap-value">${entry.value}</div>
                <div class="lru-hashmap-index">Index: ${entry.index}</div>
            `;
            container.appendChild(element);
        });
    }
    
    // Update statistics
    updateStats() {
        document.getElementById('lruCapacity').textContent = this.capacity;
        document.getElementById('lruSize').textContent = this.cache.length;
        document.getElementById('lruHits').textContent = this.hits;
        document.getElementById('lruMisses').textContent = this.misses;
    }
    
    // Add log entry
    addLog(message, type = 'info') {
        const logContainer = document.getElementById('lruOperationLog');
        const logEntry = document.createElement('div');
        logEntry.className = `lru-log-entry lru-log-${type}`;
        logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        
        logContainer.appendChild(logEntry);
        logContainer.scrollTop = logContainer.scrollHeight;
    }
    
    // Animate element access
    animateAccess(key, animationType) {
        const element = document.getElementById(`array-${key}`);
        if (element) {
            element.classList.add(animationType);
            setTimeout(() => {
                element.classList.remove(animationType);
            }, 1000);
        }
    }
    
    // PUT operation
    put(key, value) {
        this.operations++;
        
        if (this.map.has(key)) {
            // Key exists - update value and move to MRU position
            const entry = this.map.get(key);
            entry.value = value;
            
            // Remove from current position
            const index = entry.index;
            this.cache.splice(index, 1);
            
            // Add to end (MRU position)
            this.cache.push(key);
            
            // Update indices
            this.updateIndices();
            
            this.addLog(`Updated key "${key}" with value "${value}" (moved to MRU)`, 'success');
            this.animateAccess(key, 'lru-access-animation');
        } else {
            // New key
            if (this.cache.length >= this.capacity) {
                // Evict LRU
                const lruKey = this.cache[0];
                this.cache.shift();
                this.map.delete(lruKey);
                
                this.addLog(`Evicted LRU key "${lruKey}" (capacity reached)`, 'warning');
                
                // Animate eviction
                const evictedElement = document.getElementById(`array-${lruKey}`);
                if (evictedElement) {
                    evictedElement.classList.add('lru-evict-animation');
                    setTimeout(() => {
                        if (evictedElement.parentNode) {
                            evictedElement.parentNode.remove();
                        }
                    }, 1000);
                }
            }
            
            // Add new key at MRU position
            this.cache.push(key);
            this.map.set(key, { value, index: this.cache.length - 1 });
            
            this.addLog(`Inserted key "${key}" with value "${value}"`, 'success');
            this.animateAccess(key, 'lru-insert-animation');
        }
        
        this.updateVisualization();
    }
    
    // GET operation
    // Update the GET operation in LRU Cache class
get(key) {
    this.operations++;
    
    if (!this.map.has(key)) {
        this.misses++;
        this.addLog(`GET "${key}" - MISS (key not found)`, 'danger');
        this.updateVisualization();
        return null;
    }
    
    this.hits++;
    
    // Move to MRU position
    const entry = this.map.get(key);
    const value = entry.value;
    
    // Remove from current position
    const index = entry.index;
    this.cache.splice(index, 1);
    
    // Add to end (MRU position)
    this.cache.push(key);
    
    // Update indices
    this.updateIndices();
    
    this.addLog(`GET "${key}" - HIT (value: "${value}")`, 'success');
    this.updateVisualization();
    
    return value;
}
    
    // Update indices after array modification
    updateIndices() {
        this.cache.forEach((key, index) => {
            if (this.map.has(key)) {
                this.map.get(key).index = index;
            }
        });
    }
}

// NEW: Initialize LRU Cache
function initializeLRUCache() {
    lruCache = new LRUCache(lruCapacity);
    lruCache.updateVisualization();
}

// NEW: Handle Set Capacity
function handleSetCapacity() {
    const capacityInput = document.getElementById('lruCapacityInput');
    const newCapacity = parseInt(capacityInput.value);
    
    if (isNaN(newCapacity) || newCapacity < 1 || newCapacity > 10) {
        showNotification('Please enter a valid capacity between 1 and 10', 'danger');
        return;
    }
    
    lruCapacity = newCapacity;
    lruCache.capacity = newCapacity;
    
    // If cache size exceeds new capacity, evict LRU elements
    while (lruCache.cache.length > lruCache.capacity) {
        const lruKey = lruCache.cache[0];
        lruCache.cache.shift();
        lruCache.map.delete(lruKey);
        lruCache.addLog(`Evicted "${lruKey}" due to capacity reduction`, 'warning');
    }
    
    lruCache.updateIndices();
    lruCache.updateVisualization();
    lruCache.addLog(`Capacity changed to ${newCapacity}`, 'info');
    
    showNotification(`LRU Cache capacity set to ${newCapacity}`, 'success');
}

// NEW: Handle LRU Put
// NEW: Handle LRU Put with better feedback
function handleLRUPut() {
    const keyInput = document.getElementById('lruKeyInput');
    const valueInput = document.getElementById('lruValueInput');
    
    const key = keyInput.value.trim().toUpperCase();
    const value = valueInput.value.trim();
    
    if (key === '' || value === '') {
        showNotification('Please enter both key and value', 'warning');
        return;
    }
    
    lruCache.put(key, value);
    
    // Show operation feedback
    const operationsContainer = document.querySelector('.lru-cache-operations');
    const feedbackDiv = document.createElement('div');
    feedbackDiv.className = 'get-feedback get-feedback-success';
    feedbackDiv.style.cssText = `
        width: 100%;
        margin: 10px 0;
        padding: 15px;
        border-radius: 10px;
        font-size: 1.1rem;
        text-align: center;
        animation: fadeIn 0.5s ease;
        background: linear-gradient(135deg, var(--info-color), #3498db);
    `;
    feedbackDiv.innerHTML = `
        <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
            <i class="fas fa-plus-circle" style="font-size: 1.5rem;"></i>
            <div>
                <strong style="font-size: 1.2rem;"> INSERTED</strong><br>
                <span>Key: <code style="background: rgba(255,255,255,0.2); padding: 2px 8px; border-radius: 4px;">${key}</code></span>
                <span> = Value: <code style="background: rgba(255,255,255,0.2); padding: 2px 8px; border-radius: 4px;">${value}</code></span>
            </div>
        </div>
    `;
    
    // Remove any existing feedback
    const existingFeedback = operationsContainer.querySelector('.get-feedback');
    if (existingFeedback) {
        existingFeedback.remove();
    }
    
    operationsContainer.appendChild(feedbackDiv);
    
    // Auto-remove feedback after 3 seconds
    setTimeout(() => {
        if (feedbackDiv.parentNode) {
            feedbackDiv.style.opacity = '0';
            feedbackDiv.style.transition = 'opacity 0.5s ease';
            setTimeout(() => {
                if (feedbackDiv.parentNode) {
                    feedbackDiv.remove();
                }
            }, 500);
        }
    }, 3000);
    
    // Clear inputs
    keyInput.value = '';
    valueInput.value = '';
    keyInput.focus();
    
    // Also show main notification
    showNotification(`PUT "${key}" = "${value}" completed`, 'success');
}

// NEW: Handle LRU Get
// NEW: Handle LRU Get with enhanced feedback
function handleLRUGet() {
    const keyInput = document.getElementById('lruKeyInput');
    const key = keyInput.value.trim().toUpperCase();
    
    if (key === '') {
        showNotification('Please enter a key to get', 'warning');
        return;
    }
    
    const value = lruCache.get(key);
    
    // Get the operations container to show feedback
    const operationsContainer = document.querySelector('.lru-cache-operations');
    
    // Create a prominent feedback message
    const feedbackDiv = document.createElement('div');
    feedbackDiv.className = `get-feedback ${value !== null ? 'get-feedback-success' : 'get-feedback-error'}`;
    feedbackDiv.style.cssText = `
        width: 100%;
        margin: 10px 0;
        padding: 15px;
        border-radius: 10px;
        font-size: 1.1rem;
        text-align: center;
        animation: fadeIn 0.5s ease;
    `;
    
    if (value !== null) {
        feedbackDiv.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                <i class="fas fa-check-circle" style="font-size: 1.5rem;"></i>
                <div>
                    <strong style="font-size: 1.2rem;"> FOUND</strong><br>
                    <span>Key: <code style="background: rgba(255,255,255,0.2); padding: 2px 8px; border-radius: 4px;">${key}</code></span>
                    <span>  Value: <code style="background: rgba(255,255,255,0.2); padding: 2px 8px; border-radius: 4px;">${value}</code></span>
                </div>
            </div>
        `;
    } else {
        feedbackDiv.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                <i class="fas fa-times-circle" style="font-size: 1.5rem;"></i>
                <div>
                    <strong style="font-size: 1.2rem;"> NOT FOUND</strong><br>
                    <span>Key: <code style="background: rgba(255,255,255,0.2); padding: 2px 8px; border-radius: 4px;">${key}</code> is not in cache</span>
                </div>
            </div>
        `;
    }
    
    // Remove any existing feedback
    const existingFeedback = operationsContainer.querySelector('.get-feedback');
    if (existingFeedback) {
        existingFeedback.remove();
    }
    
    operationsContainer.appendChild(feedbackDiv);
    
    // Auto-remove feedback after 4 seconds
    setTimeout(() => {
        if (feedbackDiv.parentNode) {
            feedbackDiv.style.opacity = '0';
            feedbackDiv.style.transition = 'opacity 0.5s ease';
            setTimeout(() => {
                if (feedbackDiv.parentNode) {
                    feedbackDiv.remove();
                }
            }, 500);
        }
    }, 4000);
    
    if (value === null) {
        // Value not found - keep key in input for retry with selection
        keyInput.focus();
        keyInput.select();
        
        // Also show main notification
        showNotification(`GET "${key}" - MISS (key not found)`, 'danger');
    } else {
        // Value found - clear input
        keyInput.value = '';
        keyInput.focus();
        
        // Also show main notification
        showNotification(`GET "${key}" = "${value}" (HIT)`, 'success');
        
        // Trigger enhanced hit animation
        triggerEnhancedHitAnimation(key, value);
    }
}
// NEW: Enhanced hit animation
function triggerEnhancedHitAnimation(key, value) {
    // Animate array element
    const arrayElement = document.getElementById(`array-${key}`);
    if (arrayElement) {
        // Add hit animation class
        arrayElement.classList.add('lru-hit-animation');
        
        // Temporarily increase size and add glow
        arrayElement.style.transition = 'all 0.3s ease';
        
        // After animation completes, remove class
        setTimeout(() => {
            arrayElement.classList.remove('lru-hit-animation');
            arrayElement.style.transition = '';
        }, 1800);
    }
    
    // Also highlight hashmap entry
    highlightHashMapEntry(key);
}

// NEW: Highlight hashmap entry
function highlightHashMapEntry(key) {
    // Find all hashmap entries
    const hashmapEntries = document.querySelectorAll('.lru-hashmap-entry');
    hashmapEntries.forEach(entry => {
        const keyElement = entry.querySelector('.lru-hashmap-key');
        if (keyElement && keyElement.textContent.trim() === key) {
            // Add highlight effect
            entry.style.backgroundColor = 'var(--success-color)';
            entry.style.boxShadow = '0 0 20px var(--success-color)';
            entry.style.transform = 'scale(1.05)';
            entry.style.transition = 'all 0.3s ease';
            
            // Remove highlight after 1.5 seconds
            setTimeout(() => {
                entry.style.backgroundColor = '';
                entry.style.boxShadow = '';
                entry.style.transform = '';
                entry.style.transition = '';
            }, 1500);
        }
    });
}
// NEW: Handle Reset LRU
function handleResetLRU() {
    initializeLRUCache();
    lruCache.addLog('LRU Cache reset to initial state', 'info');
    showNotification('LRU Cache reset successfully', 'success');
}

// NEW: Handle Exit LRU
function handleExitLRU() {
    resetAfterLRUCache();
}

// NEW: Reset after LRU Cache
function resetAfterLRUCache() {
    // Reset to original array
    myArray = [...originalArrayForLRU];
    originalArrayForLRU = [];
    
    // Remove LRU visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isLRUCacheRunning = false;
    lruCache = null;
    
    // Show notification
    showNotification('Returned to original array from LRU Cache simulation', 'success');
    logOperation('LRU Cache simulation completed', 'info');
}
// NEW: LFU Cache Class (updated to handle both string and number keys)
// NEW: LFU Cache Class (Updated)
class LFUCacheVisualizer {
    constructor(capacity = 3) {
        this.capacity = capacity;
        this.cache = new Map(); // key -> {value, frequency}
        this.freqMap = new Map(); // frequency -> Set of keys
        this.minFreq = 0;
        this.history = [];
        this.operations = 0;
    }
    
    logOperation(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        this.history.push({
            message: `${timestamp}: ${message}`,
            type: type,
            operation: this.operations++
        });
        return this.history[this.history.length - 1];
    }
    
    get(key) {
        const log = this.logOperation(`GET(${key})`, 'get');
        
        if (!this.cache.has(key)) {
            log.message += '  KEY NOT FOUND';
            return null;
        }
        
        const node = this.cache.get(key);
        const oldFreq = node.frequency;
        
        // Remove from old frequency bucket
        const oldBucket = this.freqMap.get(oldFreq);
        oldBucket.delete(key);
        if (oldBucket.size === 0) {
            this.freqMap.delete(oldFreq);
            if (this.minFreq === oldFreq) {
                this.minFreq = oldFreq + 1;
            }
        }
        
        // Update frequency
        node.frequency++;
        this.cache.set(key, node);
        
        // Add to new frequency bucket
        const newFreq = node.frequency;
        if (!this.freqMap.has(newFreq)) {
            this.freqMap.set(newFreq, new Set());
        }
        this.freqMap.get(newFreq).add(key);
        
        log.message += `  FOUND value=${node.value}, frequency=${oldFreq}${newFreq}`;
        return node.value;
    }
    
    put(key, value) {
        const log = this.logOperation(`PUT(${key}, ${value})`, 'put');
        
        if (this.capacity === 0) {
            log.message += '  CACHE CAPACITY IS 0';
            return;
        }
        
        if (this.cache.has(key)) {
            // Update existing key
            const node = this.cache.get(key);
            const oldFreq = node.frequency;
            
            // Remove from old frequency bucket
            const oldBucket = this.freqMap.get(oldFreq);
            oldBucket.delete(key);
            if (oldBucket.size === 0) {
                this.freqMap.delete(oldFreq);
                if (this.minFreq === oldFreq) {
                    this.minFreq = oldFreq + 1;
                }
            }
            
            // Update value and frequency
            node.value = value;
            node.frequency++;
            
            // Add to new frequency bucket
            const newFreq = node.frequency;
            if (!this.freqMap.has(newFreq)) {
                this.freqMap.set(newFreq, new Set());
            }
            this.freqMap.get(newFreq).add(key);
            
            this.cache.set(key, node);
            log.message += `  UPDATED, frequency=${oldFreq}${newFreq}`;
            log.type = 'update';
            return;
        }
        
        // Check if cache is full
        if (this.cache.size >= this.capacity) {
            // Evict LFU element
            const lfuKeys = this.freqMap.get(this.minFreq);
            const lfuKey = lfuKeys.values().next().value;
            
            lfuKeys.delete(lfuKey);
            if (lfuKeys.size === 0) {
                this.freqMap.delete(this.minFreq);
            }
            
            this.cache.delete(lfuKey);
            this.logOperation(`EVICTED key=${lfuKey} (frequency=${this.minFreq})`, 'evict');
            log.message += `  EVICTED ${lfuKey}`;
        }
        
        // Add new element
        const newNode = { value: value, frequency: 1 };
        this.cache.set(key, newNode);
        
        if (!this.freqMap.has(1)) {
            this.freqMap.set(1, new Set());
        }
        this.freqMap.get(1).add(key);
        this.minFreq = 1;
        
        log.message += `  ADDED, frequency=1`;
    }
    
    getState() {
        const buckets = {};
        for (let [freq, keys] of this.freqMap) {
            buckets[freq] = Array.from(keys).map(key => ({
                key: key,
                value: this.cache.get(key).value,
                frequency: this.cache.get(key).frequency
            }));
        }
        
        const hashmap = {};
        for (let [key, node] of this.cache) {
            hashmap[key] = {
                value: node.value,
                frequency: node.frequency
            };
        }
        
        return {
            capacity: this.capacity,
            size: this.cache.size,
            minFreq: this.minFreq,
            buckets: buckets,
            hashmap: hashmap,
            history: [...this.history]
        };
    }
    
    reset() {
        this.cache.clear();
        this.freqMap.clear();
        this.minFreq = 0;
        this.history = [];
        this.operations = 0;
    }
    
    // NEW: Change capacity dynamically
    setCapacity(newCapacity) {
        if (newCapacity < 0) return;
        
        const oldCapacity = this.capacity;
        this.capacity = newCapacity;
        
        // If new capacity is smaller, evict excess items
        if (this.cache.size > newCapacity) {
            const evictCount = this.cache.size - newCapacity;
            for (let i = 0; i < evictCount; i++) {
                // Evict LFU elements
                const lfuKeys = this.freqMap.get(this.minFreq);
                if (lfuKeys && lfuKeys.size > 0) {
                    const lfuKey = lfuKeys.values().next().value;
                    
                    lfuKeys.delete(lfuKey);
                    if (lfuKeys.size === 0) {
                        this.freqMap.delete(this.minFreq);
                        // Find new min frequency
                        if (this.freqMap.size > 0) {
                            this.minFreq = Math.min(...Array.from(this.freqMap.keys()));
                        } else {
                            this.minFreq = 0;
                        }
                    }
                    
                    this.cache.delete(lfuKey);
                    this.logOperation(`CAPACITY CHANGE: Evicted key=${lfuKey}`, 'evict');
                }
            }
        }
        
        this.logOperation(`Capacity changed: ${oldCapacity}  ${newCapacity}`, 'info');
    }
}
// NEW: LFU Cache Handler - Now asks for capacity
// NEW: LFU Cache Handler (Updated)
function handleLFUCache() {
    if (isLFURunning) {
        showNotification('LFU Cache visualization is already running', 'warning');
        return;
    }
    
    // Get capacity from input
    const capacityInput = document.getElementById('lfuCapacityInput');
    let capacity = parseInt(capacityInput.value);
    
    // Validate capacity
    if (isNaN(capacity) || capacity < 1) {
        showNotification('Please enter a valid capacity (minimum 1)', 'danger');
        capacityInput.focus();
        return;
    }
    
    if (capacity > 20) {
        showNotification('Capacity too large. Maximum is 20.', 'warning');
        capacity = 20;
        capacityInput.value = 20;
    }
    
    isLFURunning = true;
    
    // Store original array
    originalArrayForLFU = [...myArray];
    
    // Initialize LFU Cache with user-defined capacity
    lfuCache = new LFUCacheVisualizer(capacity);
    lfuHistory = [];
    
    // Show LFU Cache visualization
    showLFUVisualization(capacity);
}

// NEW: Show LFU Cache Visualization (updated to accept capacity)
// NEW: Show LFU Cache Visualization (Updated)
function showLFUVisualization(capacity) {
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    
    const lfuContainer = document.createElement('div');
    lfuContainer.className = 'lfu-container glass-card';
    lfuContainer.innerHTML = `
        <div class="lfu-header">
            <i class="fas fa-database me-2"></i>LFU Cache Visualization (Capacity: ${capacity})
        </div>
        
        <div class="lfu-stats">
            <div class="lfu-stat-card">
                <div>Cache Size</div>
                <div class="lfu-stat-value" id="lfuSize">0 / ${capacity}</div>
            </div>
            <div class="lfu-stat-card">
                <div>Min Frequency</div>
                <div class="lfu-stat-value" id="lfuMinFreq">0</div>
            </div>
            <div class="lfu-stat-card">
                <div>Current Capacity</div>
                <div class="lfu-stat-value" id="lfuCapacity">${capacity}</div>
            </div>
            <div class="lfu-stat-card">
                <div>Total Operations</div>
                <div class="lfu-stat-value" id="lfuOps">0</div>
            </div>
        </div>
        
        <div class="lfu-visualization">
            <div class="lfu-section">
                <div class="lfu-section-title">
                    <i class="fas fa-layer-group me-2"></i>Frequency Buckets
                </div>
                <div class="bucket-container" id="lfuBuckets">
                    <!-- Buckets will be dynamically added here -->
                    <div class="bucket">
                        <div class="bucket-header">
                            <span>Frequency 1</span>
                            <span>Items: 0</span>
                        </div>
                        <div class="bucket-items">
                            <div class="bucket-empty">Empty</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="lfu-section">
                <div class="lfu-section-title">
                    <i class="fas fa-table me-2"></i>HashMap
                </div>
                <div class="hashmap-container" id="lfuHashMap">
                    <!-- Hashmap entries will be dynamically added here -->
                    <div class="hashmap-empty">Empty</div>
                </div>
            </div>
        </div>
        
        <div class="lfu-controls">
            <div class="lfu-input-group">
                <input type="text" class="form-control" id="lfuKeyInput" placeholder="Key (e.g., A, 1, X2)" maxlength="10">
                <input type="text" class="form-control" id="lfuValueInput" placeholder="Value">
                <button class="btn btn-glow" id="lfuPutBtn">
                    <i class="fas fa-plus me-1"></i>PUT
                </button>
            </div>
            
            <div class="lfu-input-group">
                <input type="text" class="form-control" id="lfuGetKeyInput" placeholder="Key to GET">
                <button class="btn btn-glow" id="lfuGetBtn">
                    <i class="fas fa-search me-1"></i>GET
                </button>
            </div>
            
            <div class="lfu-input-group">
                <input type="number" class="form-control" id="lfuNewCapacity" placeholder="New Capacity" min="1" max="20">
                <button class="btn btn-glow" id="lfuChangeCapacityBtn">
                    <i class="fas fa-exchange-alt me-1"></i>Change Capacity
                </button>
            </div>
        </div>
        
        <div class="lfu-controls mt-2">
            <button class="btn btn-outline-light" id="lfuResetBtn">
                <i class="fas fa-redo me-1"></i>Reset Cache
            </button>
            
            <button class="btn btn-outline-light" id="lfuBackBtn">
                <i class="fas fa-arrow-left me-1"></i>Back to Array
            </button>
            
            <button class="btn btn-outline-light" id="lfuDemoBtn">
                <i class="fas fa-play me-1"></i>Demo Sequence
            </button>
        </div>
        
        <div class="lfu-section-title mt-4">
            <i class="fas fa-history me-2"></i>Operation Log
        </div>
        <div class="lfu-operation-log" id="lfuOperationLog">
            <!-- Operation logs will appear here -->
            <div class="lfu-log-entry">Cache initialized with capacity ${capacity}</div>
        </div>
        
        <div class="mt-3 text-center text-muted">
            <small><i class="fas fa-info-circle me-1"></i>Keys can be letters, numbers, or alphanumeric. Press Left Shift + R to reset to original array.</small>
        </div>
    `;
    
    mainContainer.appendChild(lfuContainer);
    
    // Initialize LFU Cache display
    updateLFUDisplay();
    
    // Add event listeners for LFU controls
    document.getElementById('lfuPutBtn').addEventListener('click', handleLFUPut);
    document.getElementById('lfuGetBtn').addEventListener('click', handleLFUGet);
    document.getElementById('lfuResetBtn').addEventListener('click', handleLFUReset);
    document.getElementById('lfuBackBtn').addEventListener('click', handleLFUBack);
    document.getElementById('lfuChangeCapacityBtn').addEventListener('click', handleLFUChangeCapacity);
    document.getElementById('lfuDemoBtn').addEventListener('click', handleLFUDemo);
    
    // Add Enter key support for inputs
    document.getElementById('lfuKeyInput').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') handleLFUPut();
    });
    document.getElementById('lfuValueInput').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') handleLFUPut();
    });
    document.getElementById('lfuGetKeyInput').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') handleLFUGet();
    });
    document.getElementById('lfuNewCapacity').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') handleLFUChangeCapacity();
    });
    
    logOperation(`Started LFU Cache visualization with capacity ${capacity}`, 'info');
}
// NEW: Handle LFU Change Capacity
function handleLFUChangeCapacity() {
    if (!lfuCache) return;
    
    const newCapacityInput = document.getElementById('lfuNewCapacity');
    const newCapacity = parseInt(newCapacityInput.value);
    
    if (isNaN(newCapacity) || newCapacity < 1) {
        showNotification('Please enter a valid capacity (minimum 1)', 'warning');
        newCapacityInput.focus();
        return;
    }
    
    if (newCapacity > 20) {
        showNotification('Maximum capacity is 20', 'warning');
        newCapacityInput.value = 20;
        newCapacityInput.focus();
        return;
    }
    
    // Change capacity
    lfuCache.setCapacity(newCapacity);
    
    // Update display
    const state = lfuCache.getState();
    updateLFUDisplay(state);
    
    // Update capacity display
    document.getElementById('lfuCapacity').textContent = newCapacity;
    document.getElementById('lfuSize').textContent = `${state.size} / ${newCapacity}`;
    
    // Update header
    const header = document.querySelector('.lfu-header');
    header.innerHTML = `<i class="fas fa-database me-2"></i>LFU Cache Visualization (Capacity: ${newCapacity})`;
    
    // Clear input
    newCapacityInput.value = '';
    
    showNotification(`Capacity changed to ${newCapacity}`, 'success');
}

// NEW: Handle LFU Demo Sequence
function handleLFUDemo() {
    if (!lfuCache) return;
    
    const capacity = lfuCache.capacity;
    
    // Clear cache first
    lfuCache.reset();
    
    // Demo sequence based on capacity
    const demoKeys = ['A', 'B', 'C', 'D', 'E', 'F'];
    const demoValues = ['Value_A', 'Value_B', 'Value_C', 'Value_D', 'Value_E', 'Value_F'];
    
    // Perform demo operations
    let step = 0;
    
    function performDemoStep() {
        if (step >= 8) {
            showNotification('Demo sequence completed', 'success');
            return;
        }
        
        setTimeout(() => {
            switch(step) {
                case 0:
                    // PUT first 3 items
                    for (let i = 0; i < Math.min(3, capacity); i++) {
                        lfuCache.put(demoKeys[i], demoValues[i]);
                    }
                    updateLFUDisplay(lfuCache.getState());
                    break;
                    
                case 1:
                    // GET A multiple times to increase its frequency
                    lfuCache.get('A');
                    updateLFUDisplay(lfuCache.getState());
                    highlightLFUElement('A', 'found');
                    break;
                    
                case 2:
                    // GET A again
                    lfuCache.get('A');
                    updateLFUDisplay(lfuCache.getState());
                    highlightLFUElement('A', 'found');
                    break;
                    
                case 3:
                    // GET B
                    lfuCache.get('B');
                    updateLFUDisplay(lfuCache.getState());
                    highlightLFUElement('B', 'found');
                    break;
                    
                case 4:
                    // PUT D (may cause eviction if capacity < 4)
                    lfuCache.put('D', 'Value_D');
                    updateLFUDisplay(lfuCache.getState());
                    highlightLFUElement('D', 'put');
                    break;
                    
                case 5:
                    // GET non-existent key
                    lfuCache.get('X');
                    updateLFUDisplay(lfuCache.getState());
                    break;
                    
                case 6:
                    // PUT E (may cause eviction)
                    lfuCache.put('E', 'Value_E');
                    updateLFUDisplay(lfuCache.getState());
                    highlightLFUElement('E', 'put');
                    break;
                    
                case 7:
                    // GET D
                    lfuCache.get('D');
                    updateLFUDisplay(lfuCache.getState());
                    highlightLFUElement('D', 'found');
                    break;
            }
            
            step++;
            performDemoStep();
        }, 1500);
    }
    
    performDemoStep();
}
// NEW: Update LFU Display
// NEW: Update LFU Display (Updated)
function updateLFUDisplay(state = null) {
    if (!state && lfuCache) {
        state = lfuCache.getState();
    }
    
    if (!state) return;
    
    // Update stats
    document.getElementById('lfuSize').textContent = `${state.size} / ${state.capacity}`;
    document.getElementById('lfuMinFreq').textContent = state.minFreq;
    document.getElementById('lfuOps').textContent = state.history.length;
    
    // Update buckets display
    const bucketsContainer = document.getElementById('lfuBuckets');
    bucketsContainer.innerHTML = '';
    
    // Sort frequencies
    const frequencies = Object.keys(state.buckets).map(f => parseInt(f)).sort((a, b) => a - b);
    
    if (frequencies.length === 0) {
        bucketsContainer.innerHTML = `
            <div class="bucket">
                <div class="bucket-header">
                    <span>No frequency buckets</span>
                    <span>Items: 0</span>
                </div>
                <div class="bucket-items">
                    <div class="bucket-empty">Cache is empty</div>
                </div>
            </div>
        `;
    } else {
        frequencies.forEach(freq => {
            const bucketItems = state.buckets[freq];
            const bucketHtml = `
                <div class="bucket">
                    <div class="bucket-header">
                        <span>Frequency ${freq}</span>
                        <span>Items: ${bucketItems.length}</span>
                    </div>
                    <div class="bucket-items">
                        ${bucketItems.map(item => `
                            <div class="bucket-item" data-key="${item.key}">
                                <div class="item-key">${item.key}</div>
                                <div class="item-value">${item.value}</div>
                                <div class="item-freq">${item.frequency}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            bucketsContainer.innerHTML += bucketHtml;
        });
    }
    
    // Update hashmap display
    const hashmapContainer = document.getElementById('lfuHashMap');
    const hashmapEntries = Object.entries(state.hashmap);
    
    if (hashmapEntries.length === 0) {
        hashmapContainer.innerHTML = '<div class="hashmap-empty">Empty</div>';
    } else {
        hashmapContainer.innerHTML = hashmapEntries.map(([key, data]) => `
            <div class="hashmap-entry">
                <span class="hashmap-key">${key} </span>
                <span class="hashmap-value">(value: ${data.value}, freq: ${data.frequency})</span>
            </div>
        `).join('');
    }
    
    // Update operation log
    const logContainer = document.getElementById('lfuOperationLog');
    logContainer.innerHTML = state.history.slice(-10).reverse().map(log => `
        <div class="lfu-log-entry ${log.type === 'get' ? 'lfu-log-get' : 
                                     log.type === 'put' ? 'lfu-log-put' :
                                     log.type === 'evict' ? 'lfu-log-evict' : 'lfu-log-update'}">
            ${log.message}
        </div>
    `).join('');
    
    // Scroll log to top
    logContainer.scrollTop = 0;
}

// NEW: Handle LFU Put Operation (updated to accept any key)
// NEW: Handle LFU Put Operation (Updated)
function handleLFUPut() {
    if (!lfuCache) return;
    
    const keyInput = document.getElementById('lfuKeyInput');
    const valueInput = document.getElementById('lfuValueInput');
    
    const key = keyInput.value.trim();
    const value = valueInput.value.trim();
    
    if (!key) {
        showNotification('Please enter a key', 'warning');
        keyInput.focus();
        return;
    }
    
    if (!value) {
        showNotification('Please enter a value', 'warning');
        valueInput.focus();
        return;
    }
    
    // Check if key is valid (alphanumeric, max 10 chars)
    if (!/^[a-zA-Z0-9]{1,10}$/.test(key)) {
        showNotification('Key must be 1-10 alphanumeric characters', 'warning');
        keyInput.focus();
        return;
    }
    
    // Perform PUT operation
    lfuCache.put(key, value);
    
    // Update display
    const state = lfuCache.getState();
    updateLFUDisplay(state);
    
    // Clear inputs
    valueInput.value = '';
    keyInput.focus();
    
    // Highlight the added/updated element
    highlightLFUElement(key, 'put');
}

// NEW: Handle LFU Get Operation (Updated)
function handleLFUGet() {
    if (!lfuCache) return;
    
    const keyInput = document.getElementById('lfuGetKeyInput');
    const key = keyInput.value.trim();
    
    if (!key) {
        showNotification('Please enter a key to GET', 'warning');
        keyInput.focus();
        return;
    }
    
    // Check if key is valid (alphanumeric)
    if (!/^[a-zA-Z0-9]{1,10}$/.test(key)) {
        showNotification('Key must be 1-10 alphanumeric characters', 'warning');
        keyInput.focus();
        return;
    }
    
    // Perform GET operation
    const result = lfuCache.get(key);
    const state = lfuCache.getState();
    
    // Update display
    updateLFUDisplay(state);
    
    // Clear input
    keyInput.value = '';
    keyInput.focus();
    
    // Highlight the element
    if (result !== null) {
        highlightLFUElement(key, 'found');
        showNotification(`Key "${key}" found with value: ${result}`, 'success');
    } else {
        // Show red highlight for not found
        const allItems = document.querySelectorAll('.bucket-item');
        let found = false;
        
        allItems.forEach(item => {
            if (item.dataset.key === key) {
                item.classList.add('not-found', 'lfu-highlight');
                found = true;
                setTimeout(() => {
                    item.classList.remove('lfu-highlight');
                }, 1000);
            }
        });
        
        if (!found) {
            // Create temporary not-found indicator
            const bucketsContainer = document.getElementById('lfuBuckets');
            const tempDiv = document.createElement('div');
            tempDiv.className = 'bucket-item not-found lfu-highlight';
            tempDiv.style.position = 'absolute';
            tempDiv.style.top = '50%';
            tempDiv.style.left = '50%';
            tempDiv.style.transform = 'translate(-50%, -50%)';
            tempDiv.style.zIndex = '1000';
            tempDiv.innerHTML = `
                <div class="item-key">${key}</div>
                <div class="item-value">NOT FOUND</div>
            `;
            bucketsContainer.appendChild(tempDiv);
            
            setTimeout(() => {
                tempDiv.remove();
            }, 1500);
        }
        
        showNotification(`Key "${key}" not found in cache`, 'warning');
    }
}

// NEW: Highlight LFU Element (updated)
function highlightLFUElement(key, type) {
    const bucketItems = document.querySelectorAll('.bucket-item');
    
    bucketItems.forEach(item => {
        if (item.dataset.key === key) {
            item.classList.remove('found', 'not-found', 'lfu-highlight', 'lfu-element');
            
            if (type === 'found') {
                item.classList.add('found', 'lfu-highlight');
            } else if (type === 'not-found') {
                item.classList.add('not-found');
            } else if (type === 'put') {
                item.classList.add('lfu-element', 'lfu-highlight');
            }
            
            // Remove highlight after animation
            setTimeout(() => {
                item.classList.remove('lfu-highlight');
                if (type !== 'not-found') {
                    item.classList.remove('found', 'lfu-element');
                }
            }, 1000);
        }
    });
}

// NEW: Handle LFU Reset
function handleLFUReset() {
    if (!lfuCache) return;
    
    lfuCache.reset();
    updateLFUDisplay(lfuCache.getState());
    showNotification('LFU Cache reset successfully', 'info');
}

// NEW: Handle LFU Back
function handleLFUBack() {
    // Return to original array
    myArray = [...originalArrayForLFU];
    
    // Remove LFU visualization
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isLFURunning = false;
    lfuCache = null;
    originalArrayForLFU = [];
    
    logOperation('Returned from LFU Cache visualization to array', 'info');
    showNotification('Returned to array view', 'success');
}
// NEW: Find Median from Data Stream Handler
function handleFindMedianStream() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isMedianOperationRunning) {
        showNotification('A median operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Median operations require all array elements to be numbers', 'danger');
        return;
    }
    
    isMedianOperationRunning = true;
    originalArrayForMedian = [...myArray];
    
    // Show median stream visualization
    showMedianStreamVisualization();
}

// NEW: Sliding Window Median Click Handler
function handleSlidingWindowMedianClick() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Median operations require all array elements to be numbers', 'danger');
        return;
    }
    
    // Show input for window size
    slidingWindowInputGroup.style.display = 'flex';
    slidingWindowK.focus();
    slidingWindowK.placeholder = `Enter k (1 to ${myArray.length})`;
    slidingWindowK.max = myArray.length;
}

// NEW: Confirm Sliding Window Handler
function handleConfirmSlidingWindow() {
    const k = parseInt(slidingWindowK.value);
    
    if (isNaN(k) || k < 1 || k > myArray.length) {
        showNotification(`Please enter a valid window size between 1 and ${myArray.length}`, 'danger');
        slidingWindowK.focus();
        return;
    }
    
    if (isSlidingWindowMedianRunning) {
        showNotification('A sliding window median operation is already in progress', 'warning');
        return;
    }
    
    kValue = k;
    isSlidingWindowMedianRunning = true;
    originalArrayForMedian = [...myArray];
    
    // Hide input group
    slidingWindowInputGroup.style.display = 'none';
    slidingWindowK.value = '';
    
    // Show sliding window median visualization
    showSlidingWindowMedianVisualization(k);
}

// NEW: Cancel Sliding Window Handler
function handleCancelSlidingWindow() {
    slidingWindowInputGroup.style.display = 'none';
    slidingWindowK.value = '';
}

// NEW: Show Median Stream Visualization
function showMedianStreamVisualization() {
    const visualizationContainer = document.createElement('div');
    visualizationContainer.className = 'median-visualization-container';
    visualizationContainer.innerHTML = `
        <h5 class="text-center mb-3">Find Median from Data Stream</h5>
        
        <div class="array-group">
            <div class="array-label">Data Stream (Array Elements)</div>
            <div class="original-array-container" id="medianStreamArray"></div>
        </div>
        
        <div class="heaps-container">
            <div class="heap-box">
                <div class="heap-title">Max Heap (Left/Smaller Half)</div>
                <div class="heap-elements" id="maxHeapElements"></div>
            </div>
            
            <div class="heap-box">
                <div class="heap-title">Min Heap (Right/Larger Half)</div>
                <div class="heap-elements" id="minHeapElements"></div>
            </div>
        </div>
        
        <div class="median-value-display" id="currentMedianValue">
            Current Median: Calculating...
        </div>
        
        <div class="step-explanation">
            <div class="step-title" id="stepTitle">Algorithm Initialization</div>
            <div class="step-details" id="stepDetails">Using two-heaps approach to maintain median in O(log n) time</div>
        </div>
        
        <div class="algorithm-steps mt-3" id="medianStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="medianSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMedian" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(visualizationContainer);
    
    renderArrayInContainer(originalArrayForMedian, 'medianStreamArray');
    
    // Start median stream algorithm animation
    performMedianStreamAnimation();
}

// NEW: Perform Median Stream Animation
function performMedianStreamAnimation() {
    const streamArrayContainer = document.getElementById('medianStreamArray');
    const maxHeapContainer = document.getElementById('maxHeapElements');
    const minHeapContainer = document.getElementById('minHeapElements');
    const medianValue = document.getElementById('currentMedianValue');
    const stepTitle = document.getElementById('stepTitle');
    const stepDetails = document.getElementById('stepDetails');
    const stepsContainer = document.getElementById('medianSteps');
    const continueButton = document.getElementById('continueAfterMedian');
    
    const data = originalArrayForMedian.map(val => parseFloat(val));
    let maxHeap = [];  // Stores smaller half (as negatives for max heap)
    let minHeap = [];  // Stores larger half
    let currentStep = 0;
    let currentIndex = 0;
    
    function addNumberToHeaps(num, index) {
        currentStep++;
        
        // Step 1: Highlight current number being processed
        stepTitle.textContent = `Step ${currentStep}: Processing Element ${num}`;
        stepDetails.textContent = `Adding ${num} to the appropriate heap while maintaining balance`;
        
        const streamElements = streamArrayContainer.querySelectorAll('.array-element');
        streamElements[index].querySelector('.element-value').classList.add('median-element');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentStep}:</strong> Processing element ${num} (index ${index})
            </div>
        `;
        
        setTimeout(() => {
            // Step 2: Add to max heap first (smaller half)
            stepTitle.textContent = `Step ${currentStep}.1: Push to Max Heap`;
            stepDetails.textContent = `Always push to max heap first: maxHeap.push(${num})`;
            
            maxHeap.push(-num);
            maxHeap.sort((a, b) => a - b); // Simulate heap behavior for visualization
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${currentStep}.1:</strong> Pushed ${num} to max_heap (as -${num})
                </div>
            `;
            
            updateHeapVisualization();
            
            setTimeout(() => {
                // Step 3: Ensure maxHeap's largest <= minHeap's smallest
                if (maxHeap.length > 0 && minHeap.length > 0 && -maxHeap[0] > minHeap[0]) {
                    stepTitle.textContent = `Step ${currentStep}.2: Balance Heaps`;
                    stepDetails.textContent = `maxHeap[0] (${-maxHeap[0]}) > minHeap[0] (${minHeap[0]}), moving -${-maxHeap[0]} to minHeap`;
                    
                    const movedValue = -maxHeap.shift();
                    minHeap.push(movedValue);
                    minHeap.sort((a, b) => a - b);
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${currentStep}.2:</strong> Moved ${movedValue} from max_heap to min_heap
                        </div>
                    `;
                    
                    updateHeapVisualization();
                    
                    setTimeout(() => {
                        checkAndBalanceHeaps();
                    }, 1500);
                } else {
                    checkAndBalanceHeaps();
                }
            }, 1500);
        }, 1500);
        
        function checkAndBalanceHeaps() {
            // Step 4: Balance sizes
            if (maxHeap.length > minHeap.length + 1) {
                stepTitle.textContent = `Step ${currentStep}.3: Rebalance Size`;
                stepDetails.textContent = `max_heap size (${maxHeap.length}) > min_heap size (${minHeap.length}) + 1, moving element`;
                
                const movedValue = -maxHeap.shift();
                minHeap.push(movedValue);
                minHeap.sort((a, b) => a - b);
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${currentStep}.3:</strong> Rebalanced: Moved ${movedValue} from max_heap to min_heap
                    </div>
                `;
                
                updateHeapVisualization();
                
                setTimeout(() => {
                    calculateMedian();
                }, 1500);
            } else if (minHeap.length > maxHeap.length) {
                stepTitle.textContent = `Step ${currentStep}.3: Rebalance Size`;
                stepDetails.textContent = `min_heap size (${minHeap.length}) > max_heap size (${maxHeap.length}), moving element`;
                
                const movedValue = minHeap.shift();
                maxHeap.push(-movedValue);
                maxHeap.sort((a, b) => a - b);
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${currentStep}.3:</strong> Rebalanced: Moved ${movedValue} from min_heap to max_heap
                    </div>
                `;
                
                updateHeapVisualization();
                
                setTimeout(() => {
                    calculateMedian();
                }, 1500);
            } else {
                calculateMedian();
            }
        }
        
        function calculateMedian() {
            // Step 5: Calculate and display median
            let median;
            if (maxHeap.length > minHeap.length) {
                median = -maxHeap[0];
                stepTitle.textContent = `Step ${currentStep}.4: Calculate Median`;
                stepDetails.textContent = `max_heap size > min_heap size, median = max_heap[0] = ${median}`;
            } else {
                median = (-maxHeap[0] + minHeap[0]) / 2;
                stepTitle.textContent = `Step ${currentStep}.4: Calculate Median`;
                stepDetails.textContent = `Equal heap sizes, median = (max_heap[0] + min_heap[0]) / 2 = (${-maxHeap[0]} + ${minHeap[0]}) / 2 = ${median}`;
            }
            
            medianValue.innerHTML = `Current Median: <strong>${median.toFixed(2)}</strong>`;
            medianValue.classList.add('pulse');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${currentStep}.4:</strong> Median after processing ${num}: ${median.toFixed(2)}
                </div>
            `;
            
            setTimeout(() => {
                medianValue.classList.remove('pulse');
                
                // Move to next number or complete
                if (currentIndex < data.length - 1) {
                    currentIndex++;
                    addNumberToHeaps(data[currentIndex], currentIndex);
                } else {
                    completeMedianStream();
                }
            }, 2000);
        }
    }
    
    function updateHeapVisualization() {
        // Update max heap visualization
        maxHeapContainer.innerHTML = '';
        maxHeap.forEach((val, idx) => {
            const elementDiv = document.createElement('div');
            elementDiv.className = 'element-value max-heap-element';
            elementDiv.textContent = `${-val}`;
            if (idx === 0) {
                elementDiv.classList.add('pulse');
            }
            maxHeapContainer.appendChild(elementDiv);
        });
        
        // Update min heap visualization
        minHeapContainer.innerHTML = '';
        minHeap.forEach((val, idx) => {
            const elementDiv = document.createElement('div');
            elementDiv.className = 'element-value min-heap-element';
            elementDiv.textContent = `${val}`;
            if (idx === 0) {
                elementDiv.classList.add('pulse');
            }
            minHeapContainer.appendChild(elementDiv);
        });
    }
    
    function completeMedianStream() {
        stepTitle.textContent = 'Algorithm Completed!';
        stepDetails.textContent = `Final median of the entire data stream: ${calculateFinalMedian()}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Final Result:</strong> Median of all ${data.length} elements = ${calculateFinalMedian()}
            </div>
        `;
        
        medianValue.innerHTML = `Final Median: <strong>${calculateFinalMedian()}</strong>`;
        medianValue.classList.add('bounce');
        
        continueButton.style.display = 'block';
        
        // Auto-return after 20 seconds
        setTimeout(() => {
            returnToOriginalAfterMedian();
        }, 20000);
        
        continueButton.addEventListener('click', returnToOriginalAfterMedian);
    }
    
    function calculateFinalMedian() {
        if (maxHeap.length > minHeap.length) {
            return -maxHeap[0];
        } else {
            return ((-maxHeap[0] + minHeap[0]) / 2).toFixed(2);
        }
    }
    
    // Start the animation
    addNumberToHeaps(data[0], 0);
}

// NEW: Show Sliding Window Median Visualization
function showSlidingWindowMedianVisualization(k) {
    const visualizationContainer = document.createElement('div');
    visualizationContainer.className = 'median-visualization-container';
    visualizationContainer.innerHTML = `
        <h5 class="text-center mb-3">Sliding Window Median (k = ${k})</h5>
        
        <div class="window-container">
            <div class="array-label">Array with Sliding Window</div>
            <div class="original-array-container" id="slidingWindowArray"></div>
            <div class="window-indicator" id="windowIndicator">Window: [0 - ${k-1}]</div>
        </div>
        
        <div class="window-slider">
            <i class="fas fa-chevron-left"></i>
            <div class="array-label">Sliding Window</div>
            <i class="fas fa-chevron-right"></i>
        </div>
        
        <div class="heaps-container">
            <div class="heap-box">
                <div class="heap-title">Max Heap (Left/Smaller Half)</div>
                <div class="heap-elements" id="swMaxHeapElements"></div>
                <div class="heap-title mt-2">Invalid Elements</div>
                <div class="heap-elements" id="swMaxInvalidElements"></div>
            </div>
            
            <div class="heap-box">
                <div class="heap-title">Min Heap (Right/Larger Half)</div>
                <div class="heap-elements" id="swMinHeapElements"></div>
                <div class="heap-title mt-2">Invalid Elements</div>
                <div class="heap-elements" id="swMinInvalidElements"></div>
            </div>
        </div>
        
        <div class="median-value-display" id="swCurrentMedianValue">
            Window Median: Calculating...
        </div>
        
        <div class="step-explanation">
            <div class="step-title" id="swStepTitle">Initializing First Window</div>
            <div class="step-details" id="swStepDetails">Using two-heaps with lazy deletion for sliding window</div>
        </div>
        
        <div class="algorithm-steps mt-3" id="swStepsContainer">
            <h6 class="text-center">Sliding Window Steps</h6>
            <div class="steps-container" id="swSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSWMedian" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(visualizationContainer);
    
    renderArrayInContainer(originalArrayForMedian, 'slidingWindowArray');
    
    // Start sliding window median algorithm animation
    performSlidingWindowMedianAnimation(k);
}

// NEW: Perform Sliding Window Median Animation
function performSlidingWindowMedianAnimation(k) {
    const windowArrayContainer = document.getElementById('slidingWindowArray');
    const windowIndicator = document.getElementById('windowIndicator');
    const maxHeapContainer = document.getElementById('swMaxHeapElements');
    const minHeapContainer = document.getElementById('swMinHeapElements');
    const maxInvalidContainer = document.getElementById('swMaxInvalidElements');
    const minInvalidContainer = document.getElementById('swMinInvalidElements');
    const medianValue = document.getElementById('swCurrentMedianValue');
    const stepTitle = document.getElementById('swStepTitle');
    const stepDetails = document.getElementById('swStepDetails');
    const stepsContainer = document.getElementById('swSteps');
    const continueButton = document.getElementById('continueAfterSWMedian');
    
    const data = originalArrayForMedian.map(val => parseFloat(val));
    let maxHeap = [];      // Stores smaller half (as negatives)
    let minHeap = [];      // Stores larger half
    let toRemove = new Map();  // Track elements to remove lazily
    let maxHeapSize = 0;   // Actual size excluding invalid
    let minHeapSize = 0;   // Actual size excluding invalid
    let currentWindow = 0; // Current window start index
    let step = 0;
    let medians = [];
    
    function initializeFirstWindow() {
        stepTitle.textContent = 'Step 1: Initialize First Window';
        stepDetails.textContent = `Adding first ${k} elements to the heaps`;
        
        // Highlight the first window
        const windowElements = windowArrayContainer.querySelectorAll('.array-element');
        for (let i = 0; i < k; i++) {
            windowElements[i].querySelector('.element-value').classList.add('window-boundary');
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step 1:</strong> Initializing first window [0 - ${k-1}]
            </div>
        `;
        
        // Add elements one by one with animation
        let elementIndex = 0;
        
        function addNextElement() {
            if (elementIndex >= k) {
                // All elements added, calculate first median
                setTimeout(() => {
                    rebalanceHeaps();
                    calculateWindowMedian(0);
                }, 1000);
                return;
            }
            
            const num = data[elementIndex];
            stepTitle.textContent = `Step 1.${elementIndex + 1}: Add ${num} to Heaps`;
            stepDetails.textContent = `Adding element ${num} at index ${elementIndex} to appropriate heap`;
            
            // Highlight current element
            const windowElements = windowArrayContainer.querySelectorAll('.array-element');
            windowElements[elementIndex].querySelector('.element-value').classList.add('median-element');
            
            setTimeout(() => {
                // Add to appropriate heap
                if (maxHeap.length === 0 || num <= -maxHeap[0]) {
                    maxHeap.push(-num);
                    maxHeap.sort((a, b) => a - b);
                    maxHeapSize++;
                    stepDetails.textContent = `${num}  maxHeap[0], added to max_heap`;
                } else {
                    minHeap.push(num);
                    minHeap.sort((a, b) => a - b);
                    minHeapSize++;
                    stepDetails.textContent = `${num} > maxHeap[0], added to min_heap`;
                }
                
                updateSlidingWindowVisualization();
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step 1.${elementIndex + 1}:</strong> Added ${num} to ${num <= (maxHeap.length > 0 ? -maxHeap[0] : Infinity) ? 'max_heap' : 'min_heap'}
                    </div>
                `;
                
                elementIndex++;
                setTimeout(addNextElement, 1500);
            }, 1500);
        }
        
        addNextElement();
    }
    
    function rebalanceHeaps() {
        // Clean invalid elements from tops
        cleanTop(maxHeap, -1, 'max');
        cleanTop(minHeap, 1, 'min');
        
        // Balance sizes
        while (maxHeapSize > minHeapSize + 1) {
            const movedValue = -maxHeap.shift();
            minHeap.push(movedValue);
            minHeap.sort((a, b) => a - b);
            maxHeapSize--;
            minHeapSize++;
        }
        
        while (maxHeapSize < minHeapSize) {
            const movedValue = minHeap.shift();
            maxHeap.push(-movedValue);
            maxHeap.sort((a, b) => a - b);
            minHeapSize--;
            maxHeapSize++;
        }
        
        updateSlidingWindowVisualization();
    }
    
    function cleanTop(heap, factor, heapType) {
        while (heap.length > 0) {
            const num = heap[0] * factor;
            if (toRemove.has(num) && toRemove.get(num) > 0) {
                const removed = heap.shift() * factor;
                toRemove.set(removed, toRemove.get(removed) - 1);
                if (toRemove.get(removed) === 0) {
                    toRemove.delete(removed);
                }
            } else {
                break;
            }
        }
    }
    
    function calculateWindowMedian(windowStart) {
        step++;
        stepTitle.textContent = `Step ${step + 1}: Calculate Median for Window [${windowStart} - ${windowStart + k - 1}]`;
        
        // Clean tops before calculating median
        cleanTop(maxHeap, -1, 'max');
        cleanTop(minHeap, 1, 'min');
        
        let median;
        if (maxHeapSize > minHeapSize) {
            median = -maxHeap[0];
            stepDetails.textContent = `max_heap size > min_heap size, median = max_heap[0] = ${median}`;
        } else {
            median = (-maxHeap[0] + minHeap[0]) / 2;
            stepDetails.textContent = `Equal heap sizes, median = (max_heap[0] + minHeap[0]) / 2 = (${-maxHeap[0]} + ${minHeap[0]}) / 2 = ${median.toFixed(2)}`;
        }
        
        medians.push(median);
        
        medianValue.innerHTML = `Window [${windowStart}-${windowStart + k - 1}] Median: <strong>${typeof median === 'number' ? median.toFixed(2) : median}</strong>`;
        medianValue.classList.add('pulse');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step + 1}:</strong> Median for window [${windowStart}-${windowStart + k - 1}] = ${typeof median === 'number' ? median.toFixed(2) : median}
            </div>
        `;
        
        // Highlight median element(s) in array
        const windowElements = windowArrayContainer.querySelectorAll('.array-element');
        if (maxHeapSize > minHeapSize) {
            // Single median element
            for (let i = windowStart; i < windowStart + k; i++) {
                if (Math.abs(data[i] - median) < 0.0001) {
                    windowElements[i].querySelector('.element-value').classList.add('current-median');
                    break;
                }
            }
        }
        
        setTimeout(() => {
            medianValue.classList.remove('pulse');
            
            // Remove current window highlights
            for (let i = windowStart; i < windowStart + k; i++) {
                windowElements[i].querySelector('.element-value').classList.remove('current-median', 'window-boundary');
            }
            
            // Slide window or complete
            if (windowStart + k < data.length) {
                slideWindow(windowStart + 1);
            } else {
                completeSlidingWindowMedian();
            }
        }, 2000);
    }
    
    function slideWindow(newStart) {
        const oldElement = data[newStart - 1];
        const newElement = data[newStart + k - 1];
        
        step++;
        stepTitle.textContent = `Step ${step + 1}: Slide Window`;
        stepDetails.textContent = `Remove ${oldElement} (index ${newStart - 1}), Add ${newElement} (index ${newStart + k - 1})`;
        
        // Highlight elements being removed and added
        const windowElements = windowArrayContainer.querySelectorAll('.array-element');
        windowElements[newStart - 1].querySelector('.element-value').classList.add('invalid-element');
        windowElements[newStart + k - 1].querySelector('.element-value').classList.add('median-element');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step + 1}:</strong> Sliding window: Remove ${oldElement}, Add ${newElement}
            </div>
        `;
        
        setTimeout(() => {
            // Remove old element (lazy deletion)
            toRemove.set(oldElement, (toRemove.get(oldElement) || 0) + 1);
            if (oldElement <= -maxHeap[0]) {
                maxHeapSize--;
            } else {
                minHeapSize--;
            }
            
            // Add new element
            if (maxHeap.length === 0 || newElement <= -maxHeap[0]) {
                maxHeap.push(-newElement);
                maxHeap.sort((a, b) => a - b);
                maxHeapSize++;
            } else {
                minHeap.push(newElement);
                minHeap.sort((a, b) => a - b);
                minHeapSize++;
            }
            
            // Update window indicator
            windowIndicator.textContent = `Window: [${newStart} - ${newStart + k - 1}]`;
            
            // Highlight new window
            for (let i = newStart; i < newStart + k; i++) {
                windowElements[i].querySelector('.element-value').classList.add('window-boundary');
            }
            
            updateSlidingWindowVisualization();
            
            setTimeout(() => {
                rebalanceHeaps();
                calculateWindowMedian(newStart);
            }, 1500);
        }, 1500);
    }
    
    function updateSlidingWindowVisualization() {
        // Update max heap
        maxHeapContainer.innerHTML = '';
        maxHeap.forEach((val, idx) => {
            const elementDiv = document.createElement('div');
            const num = -val;
            elementDiv.className = 'element-value max-heap-element';
            elementDiv.textContent = `${num}`;
            if (toRemove.has(num) && toRemove.get(num) > 0) {
                elementDiv.classList.add('invalid-element');
            }
            if (idx === 0) {
                elementDiv.classList.add('pulse');
            }
            maxHeapContainer.appendChild(elementDiv);
        });
        
        // Update min heap
        minHeapContainer.innerHTML = '';
        minHeap.forEach((val, idx) => {
            const elementDiv = document.createElement('div');
            elementDiv.className = 'element-value min-heap-element';
            elementDiv.textContent = `${val}`;
            if (toRemove.has(val) && toRemove.get(val) > 0) {
                elementDiv.classList.add('invalid-element');
            }
            if (idx === 0) {
                elementDiv.classList.add('pulse');
            }
            minHeapContainer.appendChild(elementDiv);
        });
        
        // Update invalid elements
        maxInvalidContainer.innerHTML = '';
        minInvalidContainer.innerHTML = '';
        
        toRemove.forEach((count, num) => {
            if (count > 0) {
                const elementDiv = document.createElement('div');
                elementDiv.className = 'element-value invalid-element';
                elementDiv.textContent = `${num} (${count})`;
                
                // Determine which heap this invalid element belongs to
                if (maxHeap.some(val => -val === num)) {
                    maxInvalidContainer.appendChild(elementDiv);
                } else if (minHeap.some(val => val === num)) {
                    minInvalidContainer.appendChild(elementDiv);
                }
            }
        });
    }
    
    function completeSlidingWindowMedian() {
        stepTitle.textContent = 'Algorithm Completed!';
        stepDetails.textContent = `Calculated medians for ${medians.length} windows: ${medians.map(m => typeof m === 'number' ? m.toFixed(2) : m).join(', ')}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Final Result:</strong> Medians for all windows = [${medians.map(m => typeof m === 'number' ? m.toFixed(2) : m).join(', ')}]
            </div>
        `;
        
        medianValue.innerHTML = `All Medians: <strong>[${medians.map(m => typeof m === 'number' ? m.toFixed(2) : m).join(', ')}]</strong>`;
        medianValue.classList.add('bounce');
        
        continueButton.style.display = 'block';
        
        // Auto-return after 20 seconds
        setTimeout(() => {
            returnToOriginalAfterMedian();
        }, 20000);
        
        continueButton.addEventListener('click', returnToOriginalAfterMedian);
    }
    
    // Start the sliding window median animation
    initializeFirstWindow();
}

// NEW: Return to Original after Median Operations
function returnToOriginalAfterMedian() {
    // Reset to original array
    myArray = [...originalArrayForMedian];
    originalArrayForMedian = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset states
    isMedianOperationRunning = false;
    isSlidingWindowMedianRunning = false;
    kValue = 0;
    
    // Hide input group if visible
    slidingWindowInputGroup.style.display = 'none';
    slidingWindowK.value = '';
    
    logOperation('Median algorithm completed - returned to original array', 'info');
    showNotification('Returned to original array after median algorithm', 'success');
}
// NEW: Calendar Handler
function handleCalendar() {
    if (isCalendarRunning) {
        showNotification('A calendar operation is already in progress', 'warning');
        return;
    }

    // Reset calendar data
    calendarEvents = [];
    bookedEvents = [];
    currentCalendarStep = 0;
    
    // Show calendar input group
    calendarGroup.style.display = 'block';
    numEvents.focus();
    
    // Hide perform button initially
    performCalendarBtn.style.display = 'none';
    
    logOperation('Started My Calendar operation', 'info');
}

// NEW: Confirm Number of Events Handler
function handleConfirmNumEvents() {
    const num = parseInt(numEvents.value);
    
    if (isNaN(num) || num < 1 || num > 20) {
        showNotification('Please enter a valid number between 1 and 20', 'danger');
        numEvents.focus();
        return;
    }
    
    // Create input fields for calendar events
    calendarEventsInputs.innerHTML = '<label class="form-label">Enter Events (start, end):</label>';
    for (let i = 0; i < num; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Event ${i + 1}</span>
            <input type="number" class="form-control calendar-event-start" 
                   placeholder="Start time" data-index="${i}" min="0" max="100">
            <input type="number" class="form-control calendar-event-end" 
                   placeholder="End time" data-index="${i}" min="0" max="100">
        `;
        calendarEventsInputs.appendChild(inputGroup);
    }
    
    // Show perform button
    performCalendarBtn.style.display = 'block';
    
    showNotification(`Set to ${num} events. Please enter start and end times.`, 'success');
    logOperation(`Number of events set to ${num}`, 'info');
}

// NEW: Perform Calendar Handler
function handlePerformCalendar() {
    // Collect event data
    const startInputs = document.querySelectorAll('.calendar-event-start');
    const endInputs = document.querySelectorAll('.calendar-event-end');
    
    calendarEvents = [];
    
    for (let i = 0; i < startInputs.length; i++) {
        const start = parseInt(startInputs[i].value);
        const end = parseInt(endInputs[i].value);
        
        if (isNaN(start) || isNaN(end)) {
            showNotification(`Please enter valid times for Event ${i + 1}`, 'danger');
            startInputs[i].focus();
            return;
        }
        
        if (start >= end) {
            showNotification(`For Event ${i + 1}, end time must be greater than start time`, 'danger');
            endInputs[i].focus();
            return;
        }
        
        if (start < 0 || end > 100) {
            showNotification(`For Event ${i + 1}, times must be between 0 and 100`, 'danger');
            startInputs[i].focus();
            return;
        }
        
        calendarEvents.push([start, end, i]); // Store with original index
    }
    
    if (calendarEvents.length === 0) {
        showNotification('Please enter at least one event', 'warning');
        return;
    }
    
    // Store original array
    originalArrayBeforeCalendar = [...myArray];
    
    // Hide input group
    calendarGroup.style.display = 'none';
    
    // Start calendar visualization
    showCalendarVisualization();
}

// NEW: Cancel Calendar Handler
function handleCancelCalendar() {
    calendarGroup.style.display = 'none';
    numEvents.value = '';
    calendarEventsInputs.innerHTML = '';
    performCalendarBtn.style.display = 'none';
    
    calendarEvents = [];
    bookedEvents = [];
    
    logOperation('Cancelled calendar operation', 'info');
    showNotification('Calendar operation cancelled', 'info');
}

// NEW: Show Calendar Visualization
function showCalendarVisualization() {
    isCalendarRunning = true;
    
    // Create calendar visualization container
    const calendarContainer = document.createElement('div');
    calendarContainer.className = 'calendar-container';
    calendarContainer.innerHTML = `
        <h5 class="text-center mb-3">My Calendar - Event Booking System</h5>
        
        <div class="calendar-stats">
            <div class="calendar-stat-card">
                <div class="calendar-stat-label">Total Events</div>
                <div class="calendar-stat-value" id="totalEventsCount">${calendarEvents.length}</div>
            </div>
            <div class="calendar-stat-card">
                <div class="calendar-stat-label">Booked Events</div>
                <div class="calendar-stat-value" id="bookedEventsCount">0</div>
            </div>
            <div class="calendar-stat-card">
                <div class="calendar-stat-label">Rejected Events</div>
                <div class="calendar-stat-value" id="rejectedEventsCount">0</div>
            </div>
        </div>
        
        <div class="calendar-timeline">
            <div class="timeline-scale" id="timelineScale"></div>
            <div class="timeline-track" id="timelineTrack"></div>
        </div>
        
        <div class="booking-result" id="currentBookingResult">
            <p class="mb-1"><strong>Current Status:</strong> Ready to start booking</p>
            <p class="mb-0" id="bookingDetails">Click "Start Booking" to begin</p>
        </div>
        
        <div class="calendar-events-list" id="eventsList">
            <h6 class="text-center mb-3">All Events</h6>
            <div id="eventsListItems"></div>
        </div>
        
        <div class="algorithm-steps mt-3" id="calendarStepsContainer">
            <h6 class="text-center">Booking Steps</h6>
            <div class="steps-container" id="calendarSteps"></div>
        </div>
        
        <div class="text-center mt-4">
            <button class="btn btn-glow" id="startBookingBtn">
                <i class="fas fa-play me-2"></i>Start Booking Events
            </button>
            <button class="btn btn-outline-light ms-2" id="autoCompleteBtn">
                <i class="fas fa-forward me-2"></i>Auto Complete All
            </button>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterCalendar" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(calendarContainer);
    
    // Initialize timeline
    initializeTimeline();
    renderEventsList();
    
    // Add event listeners
    document.getElementById('startBookingBtn').addEventListener('click', startBookingProcess);
    document.getElementById('autoCompleteBtn').addEventListener('click', autoCompleteBooking);
}

// NEW: Initialize Timeline
function initializeTimeline() {
    const timelineScale = document.getElementById('timelineScale');
    const timelineTrack = document.getElementById('timelineTrack');
    
    // Clear previous content
    timelineScale.innerHTML = '';
    timelineTrack.innerHTML = '';
    
    // Add time markers (0 to 100)
    for (let i = 0; i <= 100; i += 10) {
        const timeMarker = document.createElement('div');
        timeMarker.className = 'timeline-scale-item';
        timeMarker.textContent = i;
        timeMarker.style.flex = '1';
        timeMarker.style.textAlign = 'center';
        timelineScale.appendChild(timeMarker);
    }
    
    // Add time unit markers
    for (let i = 0; i <= 100; i += 5) {
        const timeUnit = document.createElement('div');
        timeUnit.className = 'time-unit';
        timeUnit.style.left = `${i}%`;
        
        if (i % 10 === 0) {
            timeUnit.style.height = '15px';
            timeUnit.style.background = 'rgba(255, 255, 255, 0.4)';
        }
        
        timelineTrack.appendChild(timeUnit);
        
        if (i % 20 === 0) {
            const label = document.createElement('div');
            label.className = 'time-unit-label';
            label.textContent = i;
            label.style.left = `${i}%`;
            timelineTrack.appendChild(label);
        }
    }
}

// NEW: Render Events List
function renderEventsList() {
    const eventsListItems = document.getElementById('eventsListItems');
    eventsListItems.innerHTML = '';
    
    calendarEvents.forEach((event, index) => {
        const eventItem = document.createElement('div');
        eventItem.className = 'calendar-event-item';
        eventItem.id = `event-item-${index}`;
        eventItem.innerHTML = `
            <div>
                <strong>Event ${index + 1}:</strong> [${event[0]}, ${event[1]})
                <span class="ms-2 event-status status-pending">Pending</span>
            </div>
            <div class="text-muted">
                Duration: ${event[1] - event[0]} units
            </div>
        `;
        eventsListItems.appendChild(eventItem);
    });
}

// NEW: Start Booking Process
function startBookingProcess() {
    if (currentCalendarStep >= calendarEvents.length) {
        showNotification('All events have been processed', 'info');
        return;
    }
    
    const startBookingBtn = document.getElementById('startBookingBtn');
    startBookingBtn.disabled = true;
    
    processNextBooking();
}

// NEW: Process Next Booking
function processNextBooking() {
    if (currentCalendarStep >= calendarEvents.length) {
        // All events processed
        showNotification('All events processed!', 'success');
        
        // Show final results
        const bookingResult = document.getElementById('currentBookingResult');
        bookingResult.innerHTML = `
            <p class="mb-1"><strong>Booking Complete!</strong></p>
            <p class="mb-1">Total Events: ${calendarEvents.length}</p>
            <p class="mb-1">Successfully Booked: ${bookedEvents.length}</p>
            <p class="mb-0">Rejected: ${calendarEvents.length - bookedEvents.length}</p>
        `;
        bookingResult.className = 'booking-result booking-success';
        
        // Show sorted events at top
        showSortedEvents();
        
        // Show continue button
        document.getElementById('continueAfterCalendar').style.display = 'block';
        document.getElementById('continueAfterCalendar').addEventListener('click', returnToOriginalAfterCalendar);
        
        // Auto-return after 20 seconds
        setTimeout(() => {
            returnToOriginalAfterCalendar();
        }, 20000);
        
        return;
    }
    
    const event = calendarEvents[currentCalendarStep];
    const [start, end, originalIndex] = event;
    
    // Update UI for current event
    const eventItem = document.getElementById(`event-item-${currentCalendarStep}`);
    eventItem.querySelector('.event-status').className = 'event-status status-pending';
    eventItem.querySelector('.event-status').textContent = 'Processing';
    
    // Show current booking attempt
    const bookingResult = document.getElementById('currentBookingResult');
    bookingResult.innerHTML = `
        <p class="mb-1"><strong>Attempting to book Event ${currentCalendarStep + 1}:</strong></p>
        <p class="mb-1">Time Slot: [${start}, ${end})</p>
        <p class="mb-0" id="bookingStatusText">Checking for overlaps...</p>
    `;
    bookingResult.className = 'booking-result';
    
    // Add to steps
    const stepsContainer = document.getElementById('calendarSteps');
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Step ${currentCalendarStep + 1}:</strong> Attempting to book [${start}, ${end})
        </div>
    `;
    stepsContainer.scrollTop = stepsContainer.scrollHeight;
    
    // Check for overlaps
    checkEventOverlap(start, end, currentCalendarStep);
}

// NEW: Check Event Overlap
function checkEventOverlap(start, end, eventIndex) {
    const timelineTrack = document.getElementById('timelineTrack');
    const eventItem = document.getElementById(`event-item-${eventIndex}`);
    const bookingStatusText = document.getElementById('bookingStatusText');
    
    // Show the event on timeline (temporary)
    const eventMarker = document.createElement('div');
    eventMarker.className = 'timeline-marker event-processing';
    eventMarker.id = `temp-event-${eventIndex}`;
    eventMarker.style.left = `${start}%`;
    eventMarker.style.width = `${end - start}%`;
    eventMarker.innerHTML = `E${eventIndex + 1}`;
    timelineTrack.appendChild(eventMarker);
    
    // Check for overlaps with booked events
    let hasOverlap = false;
    let overlappingEvents = [];
    
    bookedEvents.forEach(bookedEvent => {
        const [bStart, bEnd, bIndex] = bookedEvent;
        
        // Check overlap: start < bookedEvent.end && end > bookedEvent.start
        if (start < bEnd && end > bStart) {
            hasOverlap = true;
            overlappingEvents.push(bIndex);
            
            // Show overlap line
            const overlapStart = Math.max(start, bStart);
            const overlapEnd = Math.min(end, bEnd);
            
            const overlapLine = document.createElement('div');
            overlapLine.className = 'event-overlap-line';
            overlapLine.style.left = `${overlapStart}%`;
            overlapLine.style.width = `${overlapEnd - overlapStart}%`;
            timelineTrack.appendChild(overlapLine);
            
            // Highlight conflicting event
            const bookedMarker = document.getElementById(`event-${bIndex}`);
            if (bookedMarker) {
                bookedMarker.classList.add('event-conflict');
                setTimeout(() => {
                    bookedMarker.classList.remove('event-conflict');
                }, 2000);
            }
        }
    });
    
    // Process result after delay
    setTimeout(() => {
        if (hasOverlap) {
            // Event conflicts - cannot book
            bookingStatusText.innerHTML = `<span class="text-danger"><strong> Overlap detected!</strong> Conflicts with event(s): ${overlappingEvents.map(i => i + 1).join(', ')}</span>`;
            
            eventMarker.className = 'timeline-marker event-failure';
            eventMarker.innerHTML = `E${eventIndex + 1} `;
            
            eventItem.querySelector('.event-status').className = 'event-status status-rejected';
            eventItem.querySelector('.event-status').textContent = 'Rejected';
            
            // Add to steps
            const stepsContainer = document.getElementById('calendarSteps');
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Result:</strong> <span class="text-danger">REJECTED - Overlaps with existing events</span>
                </div>
            `;
            
            // Update stats
            const rejectedCount = document.getElementById('rejectedEventsCount');
            rejectedCount.textContent = parseInt(rejectedCount.textContent) + 1;
            
        } else {
            // No overlap - can book
            bookingStatusText.innerHTML = `<span class="text-success"><strong> No overlaps found! Event booked successfully.</strong></span>`;
            
            eventMarker.className = 'timeline-marker event-success';
            eventMarker.id = `event-${eventIndex}`;
            eventMarker.innerHTML = `E${eventIndex + 1}`;
            
            // Add to booked events
            bookedEvents.push([start, end, eventIndex]);
            
            eventItem.querySelector('.event-status').className = 'event-status status-booked';
            eventItem.querySelector('.event-status').textContent = 'Booked';
            
            // Add to steps
            const stepsContainer = document.getElementById('calendarSteps');
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Result:</strong> <span class="text-success">BOOKED SUCCESSFULLY</span>
                </div>
            `;
            
            // Update stats
            const bookedCount = document.getElementById('bookedEventsCount');
            bookedCount.textContent = bookedEvents.length;
        }
        
        // Update booking result with success/failure
        const bookingResult = document.getElementById('currentBookingResult');
        if (hasOverlap) {
            bookingResult.className = 'booking-result booking-failure';
        } else {
            bookingResult.className = 'booking-result booking-success';
        }
        
        // Move to next step after delay
        setTimeout(() => {
            currentCalendarStep++;
            
            // Re-enable start button
            const startBookingBtn = document.getElementById('startBookingBtn');
            startBookingBtn.disabled = false;
            startBookingBtn.textContent = `Book Next Event (${currentCalendarStep + 1}/${calendarEvents.length})`;
            
            // Update progress
            if (currentCalendarStep < calendarEvents.length) {
                bookingResult.innerHTML = `
                    <p class="mb-1"><strong>Ready for next booking:</strong></p>
                    <p class="mb-0">Next Event ${currentCalendarStep + 1}: [${calendarEvents[currentCalendarStep][0]}, ${calendarEvents[currentCalendarStep][1]})</p>
                `;
                bookingResult.className = 'booking-result';
            } else {
                // All events processed
                showNotification('All events have been processed!', 'success');
                
                bookingResult.innerHTML = `
                    <p class="mb-1"><strong>Booking Complete!</strong></p>
                    <p class="mb-1">Total Events: ${calendarEvents.length}</p>
                    <p class="mb-1">Successfully Booked: ${bookedEvents.length}</p>
                    <p class="mb-0">Rejected: ${calendarEvents.length - bookedEvents.length}</p>
                `;
                bookingResult.className = 'booking-result booking-success';
                
                // Show sorted events at top
                showSortedEvents();
                
                // Show continue button
                document.getElementById('continueAfterCalendar').style.display = 'block';
                document.getElementById('continueAfterCalendar').addEventListener('click', returnToOriginalAfterCalendar);
                
                // Auto-return after 20 seconds
                setTimeout(() => {
                    returnToOriginalAfterCalendar();
                }, 20000);
            }
        }, 1500);
        
    }, 1500);
}

// NEW: Auto Complete All Bookings
function autoCompleteBooking() {
    const startBookingBtn = document.getElementById('startBookingBtn');
    const autoCompleteBtn = document.getElementById('autoCompleteBtn');
    startBookingBtn.disabled = true;
    autoCompleteBtn.disabled = true;
    
    // Process all remaining events quickly
    function processAllEvents() {
        if (currentCalendarStep >= calendarEvents.length) {
            startBookingBtn.disabled = false;
            autoCompleteBtn.disabled = false;
            return;
        }
        
        const event = calendarEvents[currentCalendarStep];
        const [start, end, originalIndex] = event;
        
        // Quick check for overlaps
        let hasOverlap = false;
        bookedEvents.forEach(bookedEvent => {
            const [bStart, bEnd, bIndex] = bookedEvent;
            if (start < bEnd && end > bStart) {
                hasOverlap = true;
            }
        });
        
        // Update UI quickly
        const eventItem = document.getElementById(`event-item-${currentCalendarStep}`);
        const timelineTrack = document.getElementById('timelineTrack');
        
        if (!hasOverlap) {
            // Book the event
            bookedEvents.push([start, end, currentCalendarStep]);
            
            const eventMarker = document.createElement('div');
            eventMarker.className = 'timeline-marker event-success';
            eventMarker.id = `event-${currentCalendarStep}`;
            eventMarker.style.left = `${start}%`;
            eventMarker.style.width = `${end - start}%`;
            eventMarker.innerHTML = `E${currentCalendarStep + 1}`;
            timelineTrack.appendChild(eventMarker);
            
            eventItem.querySelector('.event-status').className = 'event-status status-booked';
            eventItem.querySelector('.event-status').textContent = 'Booked';
            
            // Update booked count
            const bookedCount = document.getElementById('bookedEventsCount');
            bookedCount.textContent = bookedEvents.length;
        } else {
            eventItem.querySelector('.event-status').className = 'event-status status-rejected';
            eventItem.querySelector('.event-status').textContent = 'Rejected';
            
            // Update rejected count
            const rejectedCount = document.getElementById('rejectedEventsCount');
            rejectedCount.textContent = parseInt(rejectedCount.textContent) + 1;
        }
        
        // Add to steps
        const stepsContainer = document.getElementById('calendarSteps');
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${!hasOverlap ? 'active' : ''}">
                <strong>Event ${currentCalendarStep + 1}:</strong> [${start}, ${end}) - 
                ${!hasOverlap ? '<span class="text-success">BOOKED</span>' : '<span class="text-danger">REJECTED (overlap)</span>'}
            </div>
        `;
        
        currentCalendarStep++;
        
        // Process next event after short delay
        setTimeout(processAllEvents, 300);
    }
    
    // Start processing
    processAllEvents();
}

// NEW: Show Sorted Events at Top
function showSortedEvents() {
    // Sort booked events by start time
    const sortedEvents = [...bookedEvents].sort((a, b) => a[0] - b[0]);
    
    // Display sorted events at the top
    const calendarContainer = document.querySelector('.calendar-container');
    const sortedEventsDiv = document.createElement('div');
    sortedEventsDiv.className = 'booking-result booking-success mt-3';
    sortedEventsDiv.innerHTML = `
        <h6 class="text-center mb-2"> Final Sorted Booked Events</h6>
        <div class="d-flex flex-wrap justify-content-center gap-2" id="sortedEventsList">
            ${sortedEvents.map((event, index) => `
                <span class="badge bg-success p-2">
                    [${event[0]}, ${event[1]})
                </span>
            `).join('')}
        </div>
        ${sortedEvents.length === 0 ? '<p class="text-center mt-2 text-muted">No events were successfully booked</p>' : ''}
    `;
    
    // Insert at the beginning of calendar container
    calendarContainer.insertBefore(sortedEventsDiv, calendarContainer.firstChild.nextSibling);
}

// NEW: Return to Original after Calendar
function returnToOriginalAfterCalendar() {
    // Reset to original array
    myArray = [...originalArrayBeforeCalendar];
    originalArrayBeforeCalendar = [];
    
    // Remove calendar visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isCalendarRunning = false;
    calendarEvents = [];
    bookedEvents = [];
    currentCalendarStep = 0;
    
    // Reset input group
    calendarGroup.style.display = 'none';
    numEvents.value = '';
    calendarEventsInputs.innerHTML = '';
    performCalendarBtn.style.display = 'none';
    
    logOperation('Calendar operation completed - returned to original array', 'info');
    showNotification('Returned to original array after calendar operation', 'success');
}
// Render the array visually
// Update the renderArray function
function renderArray() {
    if (myArray.length === 0) {
        arrayContainer.innerHTML = `
            <div class="array-empty-state">
                <i class="fas fa-layer-group"></i>
                <h4>Array is Empty</h4>
                <p>Add some elements to get started!</p>
            </div>
        `;
        return;
    }
    
    arrayContainer.innerHTML = '';
    
    // Add transformation label if applicable
    if (currentTransformationType) {
        const label = document.createElement('div');
        label.className = 'w-100 text-center mb-3';
        label.innerHTML = `
            <span class="badge bg-success">
                <i class="fas fa-calculator me-1"></i>
                ${currentTransformationType === 'cumulative' ? 'Cumulative Sum Array' : 'Prefix Sum Array'}
            </span>
        `;
        arrayContainer.appendChild(label);
    }
    
    myArray.forEach((value, index) => {
        const element = document.createElement('div');
        element.className = 'array-element slide-in';
        element.style.animationDelay = `${index * 0.1}s`;
        
        const valueDiv = document.createElement('div');
        valueDiv.className = 'element-value';
        valueDiv.textContent = value;
        
        const indexDiv = document.createElement('div');
        indexDiv.className = 'element-index';
        indexDiv.textContent = `[${index}]`;
        
        element.appendChild(valueDiv);
        element.appendChild(indexDiv);
        
        arrayContainer.appendChild(element);
    });
    
    // Update memory address display
    updateMemoryAddress();

}
        
        // Highlight an element with animation
        function highlightElement(index, operation, callback = null) {
            const elements = document.querySelectorAll('.array-element');
            if (index < 0 || index >= elements.length) return;
            
            const valueDiv = elements[index].querySelector('.element-value');
            valueDiv.classList.add(operation);
            
            // Different animations for different operations
            switch(operation) {
                case 'create':
                    valueDiv.classList.add('bounce', 'color-change');
                    break;
                case 'read':
                    valueDiv.classList.add('pulse');
                    break;
                case 'update':
                    valueDiv.classList.add('flip');
                    break;
                case 'delete':
                    valueDiv.classList.add('shake');
                    break;
                case 'search':
                    valueDiv.classList.add('pulse', 'color-change');
                    break;
            }
            
            // Reset classes after animation
            setTimeout(() => {
                valueDiv.classList.remove(operation, 'bounce', 'pulse', 'flip', 'shake', 'color-change');
                if (callback) callback();
            }, 1000);
        }
        
        // Update statistics
        // Update statistics
function updateStats() {
    arrayLength.textContent = myArray.length;
    firstElement.textContent = myArray.length > 0 ? myArray[0] : '-';
    lastElement.textContent = myArray.length > 0 ? myArray[myArray.length - 1] : '-';
    sumElements.textContent = calculateSum();
    productElements.textContent = calculateProduct();
    totalOperations.textContent = ++operationCount;
    // Calculate mode
    calculateMode();
}
// NEW: Calculate Mode Function
function calculateMode() {
    if (myArray.length === 0) {
        modeElements.textContent = '-';
        return;
    }
    
    // Count frequency of each element
    const frequencyMap = {};
    let maxFrequency = 0;
    let modes = [];
    
    // Count occurrences
    myArray.forEach(item => {
        frequencyMap[item] = (frequencyMap[item] || 0) + 1;
        if (frequencyMap[item] > maxFrequency) {
            maxFrequency = frequencyMap[item];
        }
    });
    
    // Find all elements with max frequency
    for (const [key, value] of Object.entries(frequencyMap)) {
        if (value === maxFrequency) {
            modes.push(key);
        }
    }
    
    // Display mode(s)
    if (modes.length === 1) {
        modeElements.textContent = `${modes[0]} (${maxFrequency} times)`;
    } else if (modes.length > 1) {
        modeElements.textContent = `${modes.slice(0, 3).join(', ')}${modes.length > 3 ? '...' : ''} (${maxFrequency} times each)`;
    } else {
        modeElements.textContent = 'No mode';
    }
    
    // Optional: Add special styling for multiple modes
    if (modes.length > 1) {
        modeElements.style.color = 'var(--warning-color)';
        modeElements.title = `Multiple modes: ${modes.join(', ')}`;
    } else {
        modeElements.style.color = '';
        modeElements.title = '';
    }
}
        
        // Log operations
        function logOperation(message, type) {
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            
            operationLog.prepend(logEntry);
            
            // Limit log entries to 10
            if (operationLog.children.length > 10) {
                operationLog.removeChild(operationLog.lastChild);
            }
        }
        
        // Show notification
        function showNotification(message, type) {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
            notification.style.top = '20px';
            notification.style.right = '20px';
            notification.style.zIndex = '1050';
            notification.style.minWidth = '300px';
            notification.innerHTML = `
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            
            document.body.appendChild(notification);
            
            // Auto remove after 3 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 3000);
        }
      // Helper function for icons (add if not exists)
function getIconForType(type) {
    switch(type) {
        case 'success': return 'check-circle';
        case 'warning': return 'exclamation-triangle';
        case 'danger': return 'times-circle';
        case 'info': 
        default: return 'info-circle';
    }
}
// Browser History Visualization Class
class BrowserHistoryVisualization {
    constructor(homepage) {
        this.history = [homepage];
        this.curr = 0;
        this.end = 0;
        this.operations = [];
        this.addOperation(`Initialized browser history with homepage: "${homepage}"`);
    }
    
    visit(url) {
        // Clear forward history when visiting new page
        this.curr += 1;
        if (this.curr < this.history.length) {
            this.history[this.curr] = url;
            this.addOperation(`Visited "${url}" - Overwrote forward history at position ${this.curr}`);
        } else {
            this.history.push(url);
            this.addOperation(`Visited "${url}" - Added to history at position ${this.curr}`);
        }
        this.end = this.curr;
        this.addOperation(`Updated end pointer to ${this.end}`);
    }
    
    back(steps) {
        const newPos = Math.max(0, this.curr - steps);
        this.addOperation(`Back ${steps} steps: Moving from position ${this.curr} to ${newPos}`);
        this.curr = newPos;
        return this.history[this.curr];
    }
    
    forward(steps) {
        const newPos = Math.min(this.end, this.curr + steps);
        this.addOperation(`Forward ${steps} steps: Moving from position ${this.curr} to ${newPos}`);
        this.curr = newPos;
        return this.history[this.curr];
    }
    
    addOperation(description) {
        this.operations.push(description);
    }
    
    getCurrentState() {
        return {
            history: [...this.history],
            current: this.curr,
            end: this.end,
            currentPage: this.history[this.curr],
            operations: [...this.operations]
        };
    }
}  
// NEW: Ordered Stream Class Implementation
class OrderedStream {
    constructor(n) {
        this.data = Array(n + 1).fill(null); // 1-based indexing
        this.ptr = 1; // next expected index
        this.size = n;
        this.chunks = [];
    }

    insert(idKey, value) {
        if (idKey < 1 || idKey > this.size) {
            throw new Error(`Index ${idKey} is out of bounds. Must be between 1 and ${this.size}`);
        }
        
        this.data[idKey] = value;
        const result = [];

        // If current idKey is what we're waiting for, return all consecutive chunks
        if (idKey === this.ptr) {
            while (this.ptr < this.data.length && this.data[this.ptr] !== null) {
                result.push(this.data[this.ptr]);
                this.ptr++;
            }
            if (result.length > 0) {
                this.chunks.push([...result]);
            }
        }
        
        return result;
    }

    getCurrentState() {
        return {
            data: this.data.slice(1), // Convert to 0-based for display
            pointer: this.ptr,
            chunks: this.chunks,
            fullStream: this.getFullStream()
        };
    }

    getFullStream() {
        const result = [];
        for (let i = 1; i <= this.size; i++) {
            if (this.data[i] !== null) {
                result.push(this.data[i]);
            }
        }
        return result;
    }
}
    // In the sample data initialization, update:
setTimeout(() => {
    myArray = [1,2,3,4];
    originalArray = []; // Reset original array
    isSubarray = false; // Reset subarray flag
    renderArray();
    updateStats();
    logOperation('Array initialized with sample data', 'info');
}, 1000);
    </script>
</body>
</html>
