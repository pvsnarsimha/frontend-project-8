<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Array Visualizer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
:root {
    --primary-color: #87CEEB; /* Soft Sky Blue */
    --secondary-color: #5D8AA8; /* Airforce Blue */
    --success-color: #A7C4A0; /* Pale Sage */
    --danger-color: #9FB6A2; /* Seafoam Green */
    --warning-color: #B0C4DE; /* Light Steel Blue */
    --info-color: #98B4C5; /* Cadet Grey */
    --dark-color: #2F2F2F; /* Soft Black */
    --light-color: #F8F8FF; /* Off-White */
}

body {
    background: linear-gradient(135deg, #E6F3FF 0%, #F0F8FF 100%);
    color: #2F2F2F;
    min-height: 100vh;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.glass-card {
    background: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(10px);
    border-radius: 15px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 8px 32px rgba(141, 182, 212, 0.2);
    padding: 20px;
    margin-bottom: 20px;
}

.array-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: flex-end;
    min-height: 300px;
    padding: 20px;
    margin: 20px 0;
    transition: all 0.5s ease;
    gap: 10px;
}

.array-element {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0 5px 15px 5px;
    transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    transform-origin: bottom;
    flex-shrink: 0;
}

.element-value {
    background: var(--primary-color);
    color: #2F2F2F;
    width: 60px;
    height: 60px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 10px;
    font-weight: bold;
    font-size: 1.2rem;
    box-shadow: 0 4px 15px rgba(135, 206, 235, 0.3);
    transition: all 0.3s ease;
    flex-shrink: 0;
    border: 1px solid rgba(255, 255, 255, 0.5);
}

.element-index {
    margin-top: 10px;
    font-size: 0.8rem;
    color: var(--secondary-color);
}

.btn-glow {
    background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
    border: none;
    color: #2F2F2F;
    padding: 10px 20px;
    border-radius: 50px;
    font-weight: bold;
    box-shadow: 0 4px 15px rgba(135, 206, 235, 0.3);
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.btn-glow:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 20px rgba(135, 206, 235, 0.4);
}

.btn-glow:active {
    transform: translateY(1px);
}

.btn-glow::after {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
    transition: 0.5s;
}

.btn-glow:hover::after {
    left: 100%;
}

.form-control {
    background: rgba(255, 255, 255, 0.7);
    border: 1px solid rgba(141, 182, 212, 0.3);
    color: #2F2F2F;
    border-radius: 10px;
}

.form-control:focus {
    background: rgba(255, 255, 255, 0.9);
    border-color: var(--primary-color);
    box-shadow: 0 0 0 0.25rem rgba(135, 206, 235, 0.25);
    color: #2F2F2F;
}

.stats-card {
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    text-align: center;
    border: 1px solid rgba(255, 255, 255, 0.3);
}

.stats-value {
    font-size: 1.5rem;
    font-weight: bold;
    color: var(--secondary-color);
    word-break: break-all;
    max-height: 60px;
    overflow-y: auto;
}

.highlight {
    animation: highlight 1s ease;
}

@keyframes highlight {
    0% { transform: scale(1); box-shadow: 0 4px 15px rgba(135, 206, 235, 0.3); }
    50% { transform: scale(1.2); box-shadow: 0 0 25px var(--warning-color); }
    100% { transform: scale(1); box-shadow: 0 4px 15px rgba(135, 206, 235, 0.3); }
}

.pulse {
    animation: pulse 0.5s ease;
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

.slide-in {
    animation: slideIn 0.5s ease;
}

@keyframes slideIn {
    from { transform: translateY(50px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}

.slide-out {
    animation: slideOut 0.5s ease;
}

@keyframes slideOut {
    from { transform: translateY(0); opacity: 1; }
    to { transform: translateY(50px); opacity: 0; }
}

.shake {
    animation: shake 0.5s ease;
}

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-10px); }
    75% { transform: translateX(10px); }
}

.flip {
    animation: flip 0.6s ease;
}

@keyframes flip {
    0% { transform: rotateY(0); }
    50% { transform: rotateY(180deg); }
    100% { transform: rotateY(360deg); }
}

.bounce {
    animation: bounce 0.5s ease;
}

@keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-20px); }
}

.color-change {
    animation: colorChange 1s ease;
}

@keyframes colorChange {
    0% { background-color: var(--primary-color); }
    50% { background-color: var(--success-color); }
    100% { background-color: var(--primary-color); }
}

.operation-log {
    max-height: 200px;
    overflow-y: auto;
    background: rgba(255, 255, 255, 0.5);
    border-radius: 10px;
    padding: 10px;
    margin-top: 10px;
    border: 1px solid rgba(255, 255, 255, 0.3);
}

.log-entry {
    padding: 5px 10px;
    margin: 5px 0;
    border-radius: 5px;
    background: rgba(255, 255, 255, 0.7);
    font-size: 0.9rem;
    animation: slideIn 0.3s ease;
    color: #2F2F2F;
}

.log-success {
    border-left: 4px solid var(--success-color);
}

.log-warning {
    border-left: 4px solid var(--warning-color);
}

.log-danger {
    border-left: 4px solid var(--danger-color);
}

.log-info {
    border-left: 4px solid var(--info-color);
}

.array-empty-state {
    text-align: center;
    padding: 40px;
    color: var(--secondary-color);
}

.array-empty-state i {
    font-size: 3rem;
    margin-bottom: 15px;
    opacity: 0.5;
}

.element-value.read {
    background: var(--info-color);
}

.element-value.update {
    background: var(--warning-color);
}

.element-value.delete {
    background: var(--danger-color);
}

.element-value.create {
    background: var(--success-color);
}

.element-value.search {
    background: var(--secondary-color);
}

.element-value.linear-search-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
}

.element-value.linear-search-checked {
    background: var(--info-color);
}

.element-value.linear-search-found {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
}

.title-animation {
    background: linear-gradient(45deg, var(--primary-color), var(--secondary-color), var(--info-color), var(--success-color));
    background-size: 400% 400%;
    background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: gradientShift 5s ease infinite;
    color:white;
}

@keyframes gradientShift {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

.tab-content {
    padding: 15px 0;
}

.nav-tabs .nav-link {
    color: rgba(47, 47, 47, 0.7);
    border: none;
    border-radius: 10px 10px 0 0;
    background: rgba(255, 255, 255, 0.5);
}

.nav-tabs .nav-link.active {
    color: #2F2F2F;
    background: rgba(255, 255, 255, 0.9);
    border: none;
}

.search-results {
    margin-top: 10px;
    padding: 10px;
    border-radius: 10px;
    background: rgba(255, 255, 255, 0.6);
    border: 1px solid rgba(255, 255, 255, 0.3);
}

.algorithm-explanation {
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    font-size: 0.9rem;
    border: 1px solid rgba(255, 255, 255, 0.3);
}

.algorithm-step {
    margin-bottom: 10px;
    padding: 8px;
    border-left: 3px solid var(--info-color);
    background: rgba(255, 255, 255, 0.5);
}

.algorithm-step.active {
    border-left: 3px solid var(--success-color);
    background: rgba(167, 196, 160, 0.2);
}

.code-snippet {
    background: rgba(255, 255, 255, 0.7);
    padding: 10px;
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    margin: 10px 0;
    font-size: 0.85rem;
    border: 1px solid rgba(255, 255, 255, 0.3);
}

/* Responsive adjustments for smaller screens */
@media (max-width: 768px) {
    .element-value {
        width: 50px;
        height: 50px;
        font-size: 1rem;
    }
    
    .array-element {
        margin: 0 3px 10px 3px;
    }
}

/* Additional styles for various visualizations */
.subarrays-container {
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border: 1px solid rgba(255, 255, 255, 0.3);
}

.subarray-item {
    background: var(--primary-color) !important;
    color: #2F2F2F;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
}

.subarray-item:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(135, 206, 235, 0.3);
}

/* Binary search styles */
.element-value.binary-search-left {
    background: var(--info-color);
    opacity: 0.7;
}

.element-value.binary-search-right {
    background: var(--secondary-color);
    opacity: 0.7;
}

.element-value.binary-search-mid {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
}

.element-value.binary-search-found {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
}

/* Occurrence search styles */
.element-value.first-occurrence {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
}

.element-value.last-occurrence {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
}

.element-value.all-occurrence {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.search-highlight {
    animation: searchHighlight 2s ease-in-out;
}

@keyframes searchHighlight {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

/* Element analysis styles */
.element-value.element-exists {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
}

.element-value.min-element {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: minMaxPulse 2s ease-in-out;
}

.element-value.max-element {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: minMaxPulse 2s ease-in-out;
}

@keyframes minMaxPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

/* Shift highlight styles */
.element-value.shift-highlight {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    animation: shiftPulse 0.5s ease;
}

@keyframes shiftPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.2); }
}

/* Traversal styles */
.element-value.traverse-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: traversePulse 0.5s ease-in-out;
}

.element-value.traverse-completed {
    background: var(--info-color);
    opacity: 0.8;
}

@keyframes traversePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

/* Transformation styles */
.element-value.cumulative-highlight {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.prefix-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

@keyframes transformPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.element-value.transform-animation {
    animation: transformPulse 0.8s ease-in-out;
}

/* Dual array styles */
.dual-array-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 30px;
    margin: 20px 0;
}

.array-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
}

.array-label {
    color: var(--secondary-color);
    font-size: 0.9rem;
    margin-bottom: 10px;
    font-weight: bold;
    text-align: center;
}

.original-array-container, .transformed-array-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: flex-end;
    padding: 15px;
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    margin: 10px 0;
    min-height: 150px;
    width: 100%;
    border: 1px solid rgba(255, 255, 255, 0.3);
}

.transformed-array-container {
    background: rgba(167, 196, 160, 0.3);
    border: 1px solid var(--success-color);
}

.transformation-arrow {
    font-size: 2rem;
    color: var(--primary-color);
    margin: 10px 0;
    animation: bounce 1s infinite;
}

.transformation-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Reverse and rotation styles */
.element-value.reverse-highlight {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
}

.element-value.rotate-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.swap-animation {
    animation: swapMove 1s ease-in-out;
}

@keyframes swapMove {
    0% { transform: translateX(0) scale(1.1); }
    50% { transform: translateX(var(--swap-distance)) scale(1.3); }
    100% { transform: translateX(0) scale(1.1); }
}

.dual-operation-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 30px;
    margin: 20px 0;
}

.operation-arrow {
    font-size: 1.5rem;
    color: var(--primary-color);
    margin: 10px 0;
    animation: bounce 1s infinite;
}

.operation-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Fill and swap styles */
.element-value.fill-highlight {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.swap-highlight {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
}

/* Subarray sum styles */
.element-value.subarray-sum-match {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
    animation: subarraySumPulse 1s ease-in-out;
}

@keyframes subarraySumPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.subarray-sum-results {
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--success-color);
}

.subarray-sum-item {
    background: var(--success-color) !important;
    color: #2F2F2F;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
}

.subarray-sum-item:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(167, 196, 160, 0.4);
}

/* Two pointer styles */
.element-value.two-pointer-left {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: twoPointerPulse 0.5s ease-in-out;
}

.element-value.two-pointer-right {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: twoPointerPulse 0.5s ease-in-out;
}

.element-value.two-pointer-meet {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: twoPointerMeet 1s ease-in-out;
}

@keyframes twoPointerPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes twoPointerMeet {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.two-pointer-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Sorting styles */
.element-value.sorting-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: sortingPulse 0.5s ease-in-out;
}

.element-value.sorting-compared {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.sorting-swap {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: swapHighlight 0.8s ease-in-out;
}

.element-value.sorting-sorted {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

@keyframes sortingPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes swapHighlight {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.sorting-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Validation styles */
.element-value.sorted-correct {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.sorted-incorrect {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
    animation: shake 0.5s ease;
}

.element-value.partial-sorted {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.partial-unsorted {
    background: var(--info-color);
    opacity: 0.7;
}

.validation-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Color utility classes */
.warning-color {
    background: var(--warning-color) !important;
}

.success-color {
    background: var(--success-color) !important;
}

.info-color {
    background: var(--info-color) !important;
}

/* Stable sort styles */
.element-value.stable-sort-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: stableSortPulse 0.5s ease-in-out;
}

.element-value.stable-sort-compared {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.stable-sort-swapped {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: stableSortSwap 0.8s ease-in-out;
}

.element-value.stable-sort-stable {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
    border: 2px solid var(--success-color);
}

.element-value.stable-sort-original-position {
    background: var(--primary-color);
    border: 2px dashed white;
}

@keyframes stableSortPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes stableSortSwap {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.stable-sort-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Merge array styles */
.merge-array-container {
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--info-color);
}

.array-title {
    color: var(--secondary-color);
    font-size: 1rem;
    font-weight: bold;
    margin-bottom: 10px;
    text-align: center;
}

/* Window styles */
.element-value.window-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: windowPulse 0.5s ease-in-out;
}

.element-value.window-included {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.window-max {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: maxWindowPulse 1s ease-in-out;
}

.element-value.window-left {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
}

.element-value.window-right {
    background: var(--primary-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--primary-color);
    border: 3px solid white;
}

@keyframes windowPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes maxWindowPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.window-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Two pointer sort styles */
.element-value.two-pointer-sort-left {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: twoPointerSortPulse 0.5s ease-in-out;
}

.element-value.two-pointer-sort-right {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: twoPointerSortPulse 0.5s ease-in-out;
}

.element-value.two-pointer-sort-swap {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: twoPointerSortSwap 0.8s ease-in-out;
}

.element-value.two-pointer-sort-sorted {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

.element-value.kadane-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
}

.element-value.kadane-max-subarray {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: kadaneHighlight 1s ease-in-out;
}

.element-value.kadane-included {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
}

@keyframes twoPointerSortPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes twoPointerSortSwap {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes kadaneHighlight {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

/* Zero movement styles */
.element-value.zero-element {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.non-zero-element {
    background: var(--info-color);
    transform: scale(1.05);
    box-shadow: 0 0 15px var(--info-color);
}

.element-value.zero-movement-current {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: zeroMovementPulse 0.5s ease-in-out;
}

.element-value.zero-movement-target {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

@keyframes zeroMovementPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.zero-movement-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Rearrange styles */
.element-value.negative-value {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.positive-value {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.rearrange-current {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: rearrangePulse 0.5s ease-in-out;
}

.element-value.rearrange-target {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

@keyframes rearrangePulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.rearrange-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Segregate styles */
.element-value.even-number {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.odd-number {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.segregate-current {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: segregatePulse 0.5s ease-in-out;
}

.element-value.segregate-target {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

@keyframes segregatePulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.segregate-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Frequency styles */
.element-value.frequency-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.duplicate-highlight {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: duplicatePulse 0.5s ease-in-out;
}

@keyframes duplicatePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

/* Frequency table styles */
.frequency-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    overflow: hidden;
}

.frequency-table th {
    background: var(--primary-color);
    color: #2F2F2F;
    padding: 12px;
    text-align: left;
    font-weight: bold;
}

.frequency-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
}

.frequency-table tr:last-child td {
    border-bottom: none;
}

.frequency-table tr:hover {
    background: rgba(255, 255, 255, 0.4);
}

.frequency-high-count {
    background: rgba(176, 196, 222, 0.3);
    font-weight: bold;
}

.frequency-duplicate {
    background: rgba(159, 182, 162, 0.3);
    font-weight: bold;
}

.frequency-unique {
    background: rgba(167, 196, 160, 0.3);
}

.table-container {
    max-height: 300px;
    overflow-y: auto;
    margin: 15px 0;
    border-radius: 10px;
    background: rgba(255, 255, 255, 0.6);
}

.table-animation {
    animation: slideIn 0.5s ease;
}

.stats-highlight {
    background: var(--info-color);
    padding: 10px;
    border-radius: 5px;
    margin: 10px 0;
    text-align: center;
    font-weight: bold;
}

/* Non-repeating styles */
.element-value.non-repeating {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: nonRepeatingPulse 1s ease-in-out;
}

.element-value.repeating {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
    opacity: 0.7;
}

.element-value.unique-element {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: uniquePulse 0.8s ease-in-out;
}

.element-value.checked-element {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--warning-color);
}

@keyframes nonRepeatingPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

@keyframes uniquePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

/* Unique elements table */
.unique-elements-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    overflow: hidden;
}

.unique-elements-table th {
    background: var(--primary-color);
    color: #2F2F2F;
    padding: 12px;
    text-align: left;
    font-weight: bold;
}

.unique-elements-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
}

.unique-elements-table tr:last-child td {
    border-bottom: none;
}

.unique-elements-table tr:hover {
    background: rgba(255, 255, 255, 0.4);
}

.frequency-unique {
    background: rgba(167, 196, 160, 0.3);
    font-weight: bold;
}

.frequency-duplicate {
    background: rgba(159, 182, 162, 0.3);
}

/* Majority element styles */
.element-value.majority-candidate {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: majorityPulse 0.5s ease-in-out;
}

.element-value.majority-count-increase {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: majorityHighlight 1s ease-in-out;
}

.element-value.majority-count-decrease {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

.element-value.majority-found {
    background: var(--success-color);
    transform: scale(1.4);
    box-shadow: 0 0 35px var(--success-color);
    border: 4px solid white;
    animation: majorityFound 2s ease-in-out infinite;
}

.element-value.majority-current {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
}

@keyframes majorityPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes majorityHighlight {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes majorityFound {
    0%, 100% { transform: scale(1.4); }
    50% { transform: scale(1.7); }
}

.majority-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Dutch flag styles */
.element-value.dutch-low {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: dutchPulse 0.5s ease-in-out;
}

.element-value.dutch-mid {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: dutchPulse 0.5s ease-in-out;
}

.element-value.dutch-high {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: dutchPulse 0.5s ease-in-out;
}

.element-value.dutch-swap {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: dutchSwap 0.8s ease-in-out;
}

.element-value.dutch-sorted {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

@keyframes dutchPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes dutchSwap {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.dutch-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Shift delete styles */
.element-value.shift-delete-target {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: shiftDeletePulse 0.5s ease-in-out;
}

.element-value.shift-left-moving {
    background: var(--warning-color);
    transform: translateX(-20px);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
    transition: all 0.5s ease;
}

.element-value.shift-left-completed {
    background: var(--info-color);
    transform: scale(1.1);
}

@keyframes shiftDeletePulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.shift-delete-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Pivot styles */
.element-value.pivot-low {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.pivot-high {
    background: var(--secondary-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--secondary-color);
    border: 2px solid white;
}

.element-value.pivot-mid {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: pivotPulse 0.5s ease-in-out;
}

.element-value.pivot-found {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: pivotFound 1s ease-in-out;
}

.element-value.rotation-highlight {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
    animation: rotationPulse 0.8s ease-in-out;
}

@keyframes pivotPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes pivotFound {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes rotationPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.pivot-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Rotated search styles */
.element-value.rotated-search-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: rotatedSearchPulse 0.5s ease-in-out;
}

.element-value.rotated-search-boundary {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.rotated-search-mid {
    background: var(--primary-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--primary-color);
    border: 3px solid white;
    animation: rotatedSearchMid 1s ease-in-out;
}

.element-value.rotated-search-found {
    background: var(--success-color);
    transform: scale(1.4);
    box-shadow: 0 0 35px var(--success-color);
    border: 4px solid white;
    animation: rotatedSearchFound 2s ease-in-out infinite;
}

.element-value.rotated-sorted-half {
    background: var(--secondary-color);
    opacity: 0.8;
}

@keyframes rotatedSearchPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes rotatedSearchMid {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes rotatedSearchFound {
    0%, 100% { transform: scale(1.4); }
    50% { transform: scale(1.7); }
}

.rotated-search-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Progression styles */
.element-value.ap-term {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
    animation: apTermPulse 0.8s ease-in-out;
}

.element-value.gp-term {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
    animation: gpTermPulse 0.8s ease-in-out;
}

.element-value.progression-formula {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: formulaHighlight 1s ease-in-out;
}

@keyframes apTermPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes gpTermPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes formulaHighlight {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.progression-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.progression-formula-display {
    background: rgba(255, 255, 255, 0.7);
    padding: 10px;
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    margin: 10px 0;
    font-size: 0.9rem;
    border: 1px solid var(--primary-color);
}

/* Kth element styles */
.element-value.kth-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: kthPulse 0.5s ease-in-out;
}

.element-value.kth-target {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: kthFound 1s ease-in-out;
}

.element-value.kth-compared {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.kth-partition {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
}

@keyframes kthPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes kthFound {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.kth-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Selection and insertion sort styles */
.element-value.selection-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: selectionPulse 0.5s ease-in-out;
}

.element-value.selection-min {
    background: var(--info-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--info-color);
    border: 3px solid white;
    animation: selectionMinPulse 0.8s ease-in-out;
}

.element-value.selection-compared {
    background: var(--secondary-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--secondary-color);
    border: 2px solid white;
}

.element-value.selection-swap {
    background: var(--danger-color);
    transform: scale(1.4);
    box-shadow: 0 0 35px var(--danger-color);
    border: 3px solid white;
    animation: selectionSwap 1s ease-in-out;
}

.element-value.selection-sorted {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

.element-value.insertion-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: insertionPulse 0.5s ease-in-out;
}

.element-value.insertion-key {
    background: var(--info-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--info-color);
    border: 3px solid white;
    animation: insertionKeyPulse 0.8s ease-in-out;
}

.element-value.insertion-compared {
    background: var(--secondary-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--secondary-color);
    border: 2px solid white;
}

.element-value.insertion-shift {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 2px solid white;
    animation: insertionShift 0.5s ease-in-out;
}

.element-value.insertion-sorted {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

@keyframes selectionPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes selectionMinPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes selectionSwap {
    0%, 100% { transform: scale(1.4); }
    50% { transform: scale(1.8); }
}

@keyframes insertionKeyPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes insertionShift {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

/* Cyclic shift styles */
.element-value.cyclic-shift-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: cyclicShiftPulse 0.5s ease-in-out;
}

/* Cyclic Shift Styles */
.element-value.cyclic-shift-moving {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: cyclicShiftMove 0.8s ease-in-out;
    z-index: 10;
}

.element-value.cyclic-shift-original {
    background: var(--info-color);
    opacity: 0.7;
}

.element-value.cyclic-shift-completed {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

.element-value.cyclic-shift-new-position {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

@keyframes cyclicShiftPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes cyclicShiftMove {
    0% { transform: scale(1.2) translateX(0); }
    50% { transform: scale(1.3) translateX(var(--move-distance)); }
    100% { transform: scale(1.2) translateX(0); }
}

.cyclic-shift-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Negation styles */
.element-value.negation-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: negationPulse 0.5s ease-in-out;
}

.element-value.negation-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
    animation: negationHighlight 1s ease-in-out;
}

@keyframes negationPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes negationHighlight {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

/* N/3 Elements styles */
.element-value.n3-candidate-1 {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: n3Candidate1Pulse 0.5s ease-in-out;
}

.element-value.n3-candidate-2 {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: n3Candidate2Pulse 0.5s ease-in-out;
}

.element-value.n3-count-increase {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: n3CountIncrease 1s ease-in-out;
}

.element-value.n3-count-decrease {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

.element-value.n3-found {
    background: var(--success-color);
    transform: scale(1.4);
    box-shadow: 0 0 35px var(--success-color);
    border: 4px solid white;
    animation: n3Found 2s ease-in-out infinite;
}

.element-value.n3-current {
    background: var(--primary-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--primary-color);
    border: 3px solid white;
}

@keyframes n3Candidate1Pulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes n3Candidate2Pulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes n3CountIncrease {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes n3Found {
    0%, 100% { transform: scale(1.4); }
    50% { transform: scale(1.7); }
}

/* Next Greater Element styles */
.element-value.nge-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: ngeCurrentPulse 0.5s ease-in-out;
}

.element-value.nge-processed {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.nge-found {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: ngeFound 1s ease-in-out;
}

.element-value.nge-no-greater {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

.stack-element {
    background: var(--secondary-color);
    color: #2F2F2F;
    padding: 10px;
    margin: 5px;
    border-radius: 5px;
    font-weight: bold;
    text-align: center;
    min-width: 60px;
    animation: stackSlideIn 0.5s ease;
}

.stack-container {
    display: flex;
    flex-direction: column-reverse;
    align-items: center;
    margin: 15px 0;
    padding: 10px;
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    min-height: 200px;
    justify-content: flex-end;
}

.stack-label {
    color: var(--secondary-color);
    font-size: 0.9rem;
    margin-bottom: 10px;
    font-weight: bold;
}

@keyframes ngeCurrentPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes ngeFound {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes stackSlideIn {
    from { transform: translateY(-20px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}

.nge-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.n3-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.element-value.shallow-copy-original {
    background: var(--primary-color);
    border: 2px solid white;
}

.element-value.shallow-copy-reference {
    background: var(--warning-color);
    border: 2px dashed white;
    animation: referencePulse 1s ease-in-out;
}

.element-value.shallow-copy-modified {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: shallowCopyPulse 0.8s ease-in-out;
}

.element-value.shallow-copy-affected {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

@keyframes referencePulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

@keyframes shallowCopyPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.shallow-copy-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--warning-color);
}

/* Add these to the existing CSS */
.element-value.merge-sort-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: mergeSortPulse 0.5s ease-in-out;
}

.element-value.merge-sort-compare {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.merge-sort-merge {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.merge-sort-sorted {
    background: var(--success-color);
    transform: scale(1.05);
    box-shadow: 0 0 15px var(--success-color);
}

.element-value.merge-sort-left {
    background: var(--info-color);
    opacity: 0.8;
}

.element-value.merge-sort-right {
    background: var(--warning-color);
    opacity: 0.8;
}

@keyframes mergeSortPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.merge-sort-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.element-value.insert-sorted-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: insertSortedPulse 0.5s ease-in-out;
}

.element-value.insert-sorted-compared {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.insert-sorted-position {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: insertSortedPosition 1s ease-in-out;
}

.element-value.insert-sorted-new-element {
    background: var(--primary-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--primary-color);
    border: 3px dashed white;
    animation: newElementPulse 1s ease-in-out infinite;
}

@keyframes insertSortedPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes insertSortedPosition {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes newElementPulse {
    0%, 100% { 
        transform: scale(1.2);
        box-shadow: 0 0 25px var(--primary-color);
    }
    50% { 
        transform: scale(1.4);
        box-shadow: 0 0 35px var(--primary-color);
    }
}

.insert-sorted-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add to existing CSS */
.element-value.random-generated {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
    animation: randomGeneratePulse 0.8s ease-in-out;
}

@keyframes randomGeneratePulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.random-array-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.char-array-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: flex-end;
    min-height: 150px;
    padding: 20px;
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    margin: 20px 0;
    transition: all 0.5s ease;
    gap: 10px;
}

.char-element-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0 5px 15px 5px;
    transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    transform-origin: bottom;
    flex-shrink: 0;
}

.char-element {
    background: var(--info-color);
    color: #2F2F2F;
    width: 60px;
    height: 60px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 10px;
    font-weight: bold;
    font-size: 1.2rem;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    transition: all 0.3s ease;
    flex-shrink: 0;
}

.char-element.special-char {
    background: var(--warning-color);
}

.char-element.space-char {
    background: var(--secondary-color);
    opacity: 0.7;
}

.char-element.highlight {
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    background: var(--success-color);
}

.char-index {
    margin-top: 10px;
    font-size: 0.8rem;
    color: var(--secondary-color);
}

.char-code {
    font-size: 0.7rem;
    color: var(--secondary-color);
    margin-top: 5px;
    text-align: center;
}

.string-display {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    font-family: 'Courier New', monospace;
    font-size: 1.2rem;
    text-align: center;
    border: 1px solid var(--primary-color);
    min-height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.conversion-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    border-left: 4px solid var(--info-color);
}

/* Responsive adjustments for smaller screens */
@media (max-width: 768px) {
    .char-element {
        width: 50px;
        height: 50px;
        font-size: 1rem;
    }
    
    .char-element-wrapper {
        margin: 0 3px 10px 3px;
    }
}

/* Add these to the existing CSS */
.custom-comparator-container {
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--info-color);
}

.dictionary-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    overflow: hidden;
}

.dictionary-table th {
    background: var(--primary-color);
    color: #2F2F2F;
    padding: 12px;
    text-align: left;
    font-weight: bold;
}

.dictionary-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
}

.dictionary-table tr:last-child td {
    border-bottom: none;
}

.dictionary-table tr:hover {
    background: rgba(255, 255, 255, 0.4);
}

.action-buttons {
    display: flex;
    gap: 5px;
}

.btn-sm {
    padding: 5px 10px;
    font-size: 0.8rem;
}

.editable-field {
    background: rgba(255, 255, 255, 0.7);
    border: 1px dashed var(--info-color);
    border-radius: 3px;
    padding: 2px 5px;
    cursor: pointer;
}

.editable-field:focus {
    background: rgba(255, 255, 255, 0.9);
    border: 1px solid var(--info-color);
    outline: none;
}

.sort-configuration {
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border-left: 4px solid var(--warning-color);
}

.sort-step {
    background: rgba(255, 255, 255, 0.6);
    border-radius: 5px;
    padding: 10px;
    margin: 5px 0;
    border-left: 3px solid var(--info-color);
}

.sort-step.active {
    border-left: 3px solid var(--success-color);
    background: rgba(167, 196, 160, 0.2);
}

.dictionary-record-highlight {
    background: var(--warning-color);
    transform: scale(1.05);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
    animation: recordHighlight 0.5s ease-in-out;
}

@keyframes recordHighlight {
    0%, 100% { transform: scale(1.05); }
    50% { transform: scale(1.1); }
}

.dictionary-record-sorted {
    background: var(--success-color);
    transform: scale(1.02);
    box-shadow: 0 0 15px var(--success-color);
}

.confirmation-dialog {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 2px solid var(--danger-color);
    text-align: center;
}

.preview-highlight {
    background: rgba(176, 196, 222, 0.3);
    border: 1px solid var(--warning-color);
}

/* Add these to the existing CSS */
.element-value.quick-sort-pivot {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: quickSortPulse 0.8s ease-in-out;
}

.element-value.quick-sort-partition {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 2px solid white;
}

.element-value.quick-sort-sorted {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
}

.element-value.heap-sort-parent {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 2px solid white;
}

.element-value.heap-sort-child {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
}

.element-value.heap-sort-heapified {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

@keyframes quickSortPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

/* Add these to the existing CSS */
.element-value.even-number-sorted {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.odd-number-sorted {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.absolute-sorted {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
    animation: transformPulse 0.8s ease-in-out;
}

.element-value.positive-value-sorted {
    background: var(--info-color);
    transform: scale(1.05);
    box-shadow: 0 0 15px var(--info-color);
}

.element-value.negative-value-sorted {
    background: var(--warning-color);
    transform: scale(1.05);
    box-shadow: 0 0 15px var(--warning-color);
}

.element-value.sorting-move {
    animation: sortingMove 0.8s ease-in-out;
}

@keyframes sortingMove {
    0% { transform: translateX(0) scale(1.1); }
    50% { transform: translateX(var(--move-distance)) scale(1.3); }
    100% { transform: translateX(0) scale(1.1); }
}

/* Add these to the existing CSS */
.element-value.triplet-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
    animation: tripletPulse 0.8s ease-in-out;
}

.element-value.quadruplet-highlight {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
    animation: quadrupletPulse 0.8s ease-in-out;
}

.element-value.triplet-current {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: tripletCurrentPulse 0.5s ease-in-out;
}

.element-value.quadruplet-current {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: quadrupletCurrentPulse 0.5s ease-in-out;
}

@keyframes tripletPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes quadrupletPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes tripletCurrentPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

@keyframes quadrupletCurrentPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.triplet-results, .quadruplet-results {
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--info-color);
}

.triplet-item, .quadruplet-item {
    background: var(--info-color) !important;
    color: #2F2F2F;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
    display: inline-block;
}

.quadruplet-item {
    background: var(--warning-color) !important;
}

.triplet-item:hover, .quadruplet-item:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(135, 206, 235, 0.3);
}

/* Add these to the existing CSS */
.element-value.equilibrium-left {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.equilibrium-right {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.equilibrium-point {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: equilibriumPulse 1s ease-in-out;
}

@keyframes equilibriumPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.equilibrium-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.equilibrium-stats {
    display: flex;
    justify-content: space-around;
    margin: 10px 0;
}

.equilibrium-stat {
    text-align: center;
    padding: 10px;
    background: rgba(255, 255, 255, 0.6);
    border-radius: 8px;
    min-width: 100px;
}

.equilibrium-stat-value {
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--primary-color);
}

/* Add these to the existing CSS */
.water-container {
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--info-color);
}

.water-bar {
    background: var(--info-color);
    margin: 0 2px;
    border-radius: 5px 5px 0 0;
    transition: all 0.5s ease;
    position: relative;
}

.water-filled {
    background: var(--primary-color);
    border-radius: 0 0 5px 5px;
    position: absolute;
    bottom: 0;
    width: 100%;
    transition: all 0.5s ease;
}

.water-pointer-left {
    background: var(--warning-color);
    border: 3px solid white;
    box-shadow: 0 0 20px var(--warning-color);
}

.water-pointer-right {
    background: var(--success-color);
    border: 3px solid white;
    box-shadow: 0 0 20px var(--success-color);
}

.water-current-area {
    background: var(--danger-color);
    border: 3px solid white;
    box-shadow: 0 0 25px var(--danger-color);
    animation: waterPulse 1s ease-in-out;
}

@keyframes waterPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.water-level {
    background: rgba(152, 180, 197, 0.3);
    border: 1px dashed var(--info-color);
}

/* Add these to the existing CSS */
.element-value.two-sum-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: twoSumPulse 0.5s ease-in-out;
}

.element-value.two-sum-checked {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.two-sum-found {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: twoSumFound 1s ease-in-out;
}

@keyframes twoSumPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes twoSumFound {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.two-sum-results {
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--success-color);
}

.two-sum-pair {
    background: var(--success-color) !important;
    color: #2F2F2F;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
    display: inline-block;
}

.two-sum-pair:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(167, 196, 160, 0.4);
}

/* Add these to the existing CSS */
.element-value.gcd-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
    animation: gcdLcmPulse 0.8s ease-in-out;
}

.element-value.lcm-highlight {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
    animation: gcdLcmPulse 0.8s ease-in-out;
}

.element-value.gcd-lcm-result {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: resultPulse 1s ease-in-out;
}

@keyframes gcdLcmPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes resultPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.gcd-lcm-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.element-value.prime-number {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
    animation: primePulse 0.8s ease-in-out;
}

.element-value.composite-number {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
    animation: compositePulse 0.8s ease-in-out;
}

.element-value.sieve-current {
    background: var(--warning-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: sieveCurrentPulse 0.5s ease-in-out;
}

.element-value.sieve-multiple {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--info-color);
    border: 2px solid white;
}

@keyframes primePulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes compositePulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.2); }
}

@keyframes sieveCurrentPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.prime-sieve-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.primes-list {
    background: rgba(167, 196, 160, 0.3);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border: 1px solid var(--success-color);
}

.prime-item {
    background: var(--success-color) !important;
    color: #2F2F2F;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
    display: inline-block;
}

.prime-item:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(167, 196, 160, 0.4);
}

/* Add these to the existing CSS */
.element-value.substring-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: substringPulse 0.5s ease-in-out;
}

.element-value.substring-included {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.substring-duplicate {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: substringDuplicate 0.8s ease-in-out;
}

.element-value.substring-max {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: substringMax 1s ease-in-out;
}

@keyframes substringPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes substringDuplicate {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes substringMax {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.substring-window {
    position: relative;
    margin: 10px 0;
    padding: 10px;
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    border: 2px solid var(--info-color);
}

.substring-window-label {
    position: absolute;
    top: -10px;
    left: 10px;
    background: var(--info-color);
    color: #2F2F2F;
    padding: 2px 8px;
    border-radius: 5px;
    font-size: 0.8rem;
    font-weight: bold;
}

.char-array-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    padding: 15px;
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    margin: 10px 0;
    min-height: 100px;
}

.char-element {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0 8px 10px 8px;
    transition: all 0.3s ease;
}

.char-value {
    background: var(--primary-color);
    color: #2F2F2F;
    width: 50px;
    height: 50px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 8px;
    font-weight: bold;
    font-size: 1.1rem;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    transition: all 0.3s ease;
}

.char-index {
    margin-top: 5px;
    font-size: 0.7rem;
    color: var(--secondary-color);
}

/* Add these to the existing CSS */
.element-value.product-window-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: productWindowPulse 0.5s ease-in-out;
}

.element-value.product-window-included {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.product-window-valid {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.product-window-invalid {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

@keyframes productWindowPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.product-subarray-item {
    background: var(--success-color) !important;
    color: #2F2F2F;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
    display: inline-block;
}

.product-subarray-item:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(167, 196, 160, 0.4);
}

/* Add these to the existing CSS */
.element-value.leader-element {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: leaderPulse 1s ease-in-out;
}

.element-value.leader-candidate {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 2px solid white;
}

.element-value.leader-compared {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
}

.element-value.non-leader {
    background: var(--danger-color);
    opacity: 0.7;
}

@keyframes leaderPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.leader-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    overflow: hidden;
}

.leader-table th {
    background: var(--primary-color);
    color: #2F2F2F;
    padding: 12px;
    text-align: left;
    font-weight: bold;
}

.leader-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
}

.leader-table tr:last-child td {
    border-bottom: none;
}

.leader-table tr:hover {
    background: rgba(255, 255, 255, 0.4);
}

.leader-position {
    background: rgba(167, 196, 160, 0.3);
    font-weight: bold;
}

/* Add these to the existing CSS */
.element-value.jump-game-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: jumpGamePulse 0.5s ease-in-out;
}

.element-value.jump-game-reachable {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.jump-game-unreachable {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
    opacity: 0.7;
}

.element-value.jump-game-possible {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: jumpGameSuccess 1s ease-in-out;
}

@keyframes jumpGamePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes jumpGameSuccess {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.jump-game-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    overflow: hidden;
}

.jump-game-table th {
    background: var(--primary-color);
    color: #2F2F2F;
    padding: 12px;
    text-align: left;
    font-weight: bold;
}

.jump-game-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
}

.jump-game-table tr:last-child td {
    border-bottom: none;
}

.jump-game-table tr:hover {
    background: rgba(255, 255, 255, 0.4);
}

.jump-game-reachable-cell {
    background: rgba(167, 196, 160, 0.3);
    font-weight: bold;
}

.jump-game-unreachable-cell {
    background: rgba(159, 182, 162, 0.3);
}

.jump-game-current-cell {
    background: rgba(176, 196, 222, 0.3);
    font-weight: bold;
}

.jump-game-result {
    padding: 15px;
    border-radius: 10px;
    margin: 15px 0;
    text-align: center;
    font-size: 1.2rem;
    font-weight: bold;
    animation: slideIn 0.5s ease;
}

.jump-game-success {
    background: rgba(167, 196, 160, 0.3);
    border-left: 4px solid var(--success-color);
    color: var(--success-color);
}

.jump-game-failure {
    background: rgba(159, 182, 162, 0.3);
    border-left: 4px solid var(--danger-color);
    color: var(--danger-color);
}

/* Add these to the existing CSS */
.element-value.buy-day {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: buySellPulse 1s ease-in-out;
}

.element-value.sell-day {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: buySellPulse 1s ease-in-out;
}

.element-value.profit-calculation {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.current-min {
    background: var(--info-color);
    transform: scale(1.15);
    box-shadow: 0 0 22px var(--info-color);
    border: 2px solid white;
}

@keyframes buySellPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.stock-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.profit-highlight {
    background: var(--success-color);
    padding: 10px;
    border-radius: 5px;
    margin: 10px 0;
    text-align: center;
    font-weight: bold;
    animation: profitPulse 2s ease-in-out;
}

@keyframes profitPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

/* Add these to the existing CSS */
.element-value.subarray-near-zero {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: nearZeroPulse 1s ease-in-out;
}

.element-value.subarray-candidate {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

@keyframes nearZeroPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.near-zero-results {
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--success-color);
}

.near-zero-item {
    background: var(--success-color) !important;
    color: #2F2F2F;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
    display: inline-block;
}

.near-zero-item:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(167, 196, 160, 0.4);
}

.near-zero-best {
    background: var(--warning-color) !important;
    border: 2px solid white;
    animation: bestSubarrayPulse 2s infinite;
}

@keyframes bestSubarrayPulse {
    0%, 100% { transform: scale(1.05); }
    50% { transform: scale(1.15); }
}

/* Add these to the existing CSS */
.char-array-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    padding: 15px;
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    margin: 10px 0;
    min-height: 80px;
}

.char-element {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0 5px 10px 5px;
    transition: all 0.3s ease;
}

.char-value {
    background: var(--primary-color);
    color: #2F2F2F;
    width: 50px;
    height: 50px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 8px;
    font-weight: bold;
    font-size: 1.1rem;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    transition: all 0.3s ease;
}

.char-index {
    margin-top: 5px;
    font-size: 0.7rem;
    color: var(--secondary-color);
}

.char-value.window-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 2px solid white;
}

.char-value.window-included {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
}

.char-value.window-required {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

.char-value.window-satisfied {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
}

.char-value.window-minimum {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: minWindowPulse 1s ease-in-out;
}

@keyframes minWindowPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.frequency-display {
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border-left: 4px solid var(--info-color);
}

.frequency-item {
    display: inline-block;
    background: var(--primary-color);
    color: #2F2F2F;
    padding: 5px 10px;
    margin: 2px;
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
}

/* Add these to the existing CSS */
.element-value.k-consecutive-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: kConsecutivePulse 0.5s ease-in-out;
}

.element-value.k-consecutive-included {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.k-consecutive-max {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: kConsecutiveMaxPulse 1s ease-in-out;
}

.element-value.k-consecutive-min {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: kConsecutiveMinPulse 1s ease-in-out;
}

@keyframes kConsecutivePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes kConsecutiveMaxPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes kConsecutiveMinPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.k-consecutive-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.element-value.rearrange-min {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: rearrangeMinMaxPulse 0.5s ease-in-out;
}

.element-value.rearrange-max {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: rearrangeMinMaxPulse 0.5s ease-in-out;
}

.element-value.rearrange-current {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: rearrangeCurrentPulse 0.5s ease-in-out;
}

.element-value.rearrange-target {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
}

@keyframes rearrangeMinMaxPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes rearrangeCurrentPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.rearrange-minmax-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.element-value.permutation-pivot {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: permutationPulse 0.5s ease-in-out;
}

.element-value.permutation-swap {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: permutationSwap 0.8s ease-in-out;
}

.element-value.permutation-reverse {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

@keyframes permutationPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes permutationSwap {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.permutation-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.element-value.consecutive-sequence {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
    animation: consecutivePulse 1s ease-in-out;
}

.element-value.consecutive-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: consecutiveCurrent 0.5s ease-in-out;
}

.element-value.consecutive-max {
    background: var(--info-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--info-color);
    border: 3px solid white;
    animation: consecutiveMax 1s ease-in-out;
}

@keyframes consecutivePulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes consecutiveCurrent {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes consecutiveMax {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.consecutive-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Add these to the existing CSS */
.element-value.interval-start {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.interval-end {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.interval-overlap {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: intervalPulse 0.8s ease-in-out;
}

.element-value.interval-merged {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: mergedPulse 1s ease-in-out;
}

.interval-container {
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--info-color);
}

.interval-item {
    background: var(--primary-color) !important;
    color: #2F2F2F;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
    display: inline-block;
}

.interval-item.overlapping {
    background: var(--warning-color) !important;
}

.interval-item.merged {
    background: var(--success-color) !important;
    transform: scale(1.05);
}

@keyframes intervalPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes mergedPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.interval-visualization {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin: 15px 0;
}

.interval-line {
    display: flex;
    align-items: center;
    padding: 10px;
    background: rgba(255, 255, 255, 0.6);
    border-radius: 5px;
    position: relative;
}

.interval-label {
    min-width: 120px;
    font-weight: bold;
    color: var(--secondary-color);
}

.interval-range {
    flex: 1;
    height: 30px;
    background: rgba(255, 255, 255, 0.4);
    border-radius: 15px;
    position: relative;
    overflow: hidden;
}

.interval-segment {
    position: absolute;
    height: 100%;
    border-radius: 15px;
    transition: all 0.5s ease;
}

.interval-segment.original {
    background: var(--primary-color);
    opacity: 0.7;
}

.interval-segment.overlap {
    background: var(--danger-color);
    z-index: 2;
}

.interval-segment.merged {
    background: var(--success-color);
    z-index: 3;
}

.horizontal-arrays-container {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    justify-content: center;
}

.horizontal-array-group {
    flex: 0 0 auto;
}

/* Add these to the existing CSS */
.element-value.set-operation-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.set-operation-included {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
}

.element-value.set-operation-excluded {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
    opacity: 0.7;
}

.set-operation-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.set-operation-result {
    background: rgba(167, 196, 160, 0.3);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border: 1px solid var(--success-color);
}

/* Add these to the existing CSS */
.subset-comp-element-match {
    background: var(--success-color) !important;
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
    animation: subsetMatchPulse 0.5s ease-in-out;
}

.subset-comp-element-not-found {
    background: var(--danger-color) !important;
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
    animation: subsetNotFoundPulse 0.5s ease-in-out;
}

.superset-comp-element-match {
    background: var(--info-color) !important;
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
    animation: supersetMatchPulse 0.5s ease-in-out;
}

@keyframes subsetMatchPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes subsetNotFoundPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes supersetMatchPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.subset-comp-container {
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--info-color);
}

.superset-comp-container {
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--warning-color);
}

.memory-address-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
    animation: memoryPulse 1s ease-in-out;
}

@keyframes memoryPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.memory-address-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    overflow: hidden;
}

.memory-address-table th {
    background: var(--primary-color);
    color: #2F2F2F;
    padding: 12px;
    text-align: left;
    font-weight: bold;
}

.memory-address-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
}

.memory-address-table tr:last-child td {
    border-bottom: none;
}

.memory-address-table tr:hover {
    background: rgba(255, 255, 255, 0.4);
}

/* Add these to the existing CSS */
.element-value.comparison-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: comparisonPulse 0.5s ease-in-out;
}

.element-value.comparison-checked {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.comparison-found {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: foundHighlight 1s ease-in-out;
}

.element-value.comparison-not-found {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: notFoundHighlight 1s ease-in-out;
}

@keyframes comparisonPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes foundHighlight {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

@keyframes notFoundHighlight {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

/* Add these to the existing CSS */
.element-value.statistical-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
    animation: statisticalPulse 0.8s ease-in-out;
}

.element-value.mean-highlight {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.deviation-highlight {
    background: var(--primary-color);
    transform: scale(1.05);
    box-shadow: 0 0 15px var(--primary-color);
    border: 1px solid white;
}

@keyframes statisticalPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.stats-positive {
    color: var(--success-color) !important;
    font-weight: bold;
}

.stats-negative {
    color: var(--danger-color) !important;
    font-weight: bold;
}

.stats-zero {
    color: #2F2F2F !important;
    font-weight: bold;
}

.statistical-explanation {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    border-left: 4px solid var(--info-color);
}

.covariance-table, .correlation-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    overflow: hidden;
}

.covariance-table th, .correlation-table th {
    background: var(--primary-color);
    color: #2F2F2F;
    padding: 12px;
    text-align: center;
    font-weight: bold;
}

.covariance-table td, .correlation-table td {
    padding: 10px 12px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    text-align: center;
}

.statistical-formula {
    background: rgba(255, 255, 255, 0.7);
    padding: 12px;
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    margin: 10px 0;
    font-size: 0.9rem;
    text-align: center;
    border-left: 4px solid var(--warning-color);
}
/* Add these to the existing CSS */
.element-value.statistical-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
    animation: statisticalPulse 0.8s ease-in-out;
}

.element-value.mean-element {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
}

.element-value.median-element {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
}

@keyframes statisticalPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.stats-result-card {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border-left: 4px solid var(--info-color);
}

.calculation-steps {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
}
/* Add these to the existing CSS */
.element-wise-max-element {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: elementWisePulse 1s ease-in-out;
}

.element-wise-min-element {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: elementWisePulse 1s ease-in-out;
}

@keyframes elementWisePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.element-wise-source {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-wise-comparison {
    background: var(--primary-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--primary-color);
}
/* Add these to the existing CSS */
.element-value.logical-true {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.logical-false {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

.element-value.logical-operation-current {
    background: var(--warning-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: logicalPulse 0.5s ease-in-out;
}

.element-value.logical-operation-result {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: resultPulse 1s ease-in-out;
}

@keyframes logicalPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

@keyframes resultPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.logical-operation-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--info-color);
}

.array-title {
    color: var(--secondary-color);
    font-size: 1rem;
    font-weight: bold;
    margin-bottom: 10px;
    text-align: center;
}
/* Add these to the existing CSS */
.element-value.statistical-mean {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.statistical-deviation {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.statistical-variance {
    background: var(--primary-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--primary-color);
    border: 2px solid white;
}

.element-value.statistical-stddev {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
}

.statistical-results {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--info-color);
}

.statistical-formula {
    background: rgba(0, 0, 0, 0.3);
    padding: 10px;
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    margin: 10px 0;
    font-size: 0.85rem;
    text-align: center;
}
/* Add these to the existing CSS */
.element-value.scalar-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
    animation: scalarPulse 0.5s ease-in-out;
}

@keyframes scalarPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}
/* Add these to the existing CSS */
.element-value.trig-operation-original {
    background: var(--primary-color);
    border: 2px dashed white;
}

.element-value.trig-operation-transformed {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
    animation: trigPulse 0.8s ease-in-out;
}

.element-value.trig-operation-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: trigHighlight 0.5s ease-in-out;
}

@keyframes trigPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes trigHighlight {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.trig-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}
/* Add these to the existing CSS */
.element-value.range-min {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: rangePulse 2s ease-in-out;
}

.element-value.range-max {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: rangePulse 2s ease-in-out;
}

.element-value.range-current {
    background: var(--primary-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--primary-color);
    border: 2px solid white;
}

@keyframes rangePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.range-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.range-result {
    background: rgba(0, 184, 148, 0.2);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    text-align: center;
    border: 2px solid var(--success-color);
}
/* Add these to the existing CSS */
.element-value.math-operation-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: mathOperationPulse 0.5s ease-in-out;
}

.element-value.math-operation-completed {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
}

.element-value.math-operation-result {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

@keyframes mathOperationPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.math-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}
/* Add these styles to the CSS section */
.element-value.pancake-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: pancakePulse 0.5s ease-in-out;
}

.element-value.pancake-flip-range {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

.element-value.pancake-sorted {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

.element-value.pancake-max {
    background: var(--info-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--info-color);
    border: 3px solid white;
    animation: pancakeMaxPulse 0.8s ease-in-out;
}

@keyframes pancakePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes pancakeMaxPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.pancake-flip-animation {
    animation: pancakeFlip 0.8s ease-in-out;
}

@keyframes pancakeFlip {
    0% { transform: rotateX(0deg); }
    50% { transform: rotateX(180deg); }
    100% { transform: rotateX(0deg); }
}

.pancake-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}
/* Add these to the existing CSS */
.element-value.stock-span-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: stockSpanPulse 0.5s ease-in-out;
}

.element-value.stock-span-compared {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.stock-span-greater {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.stock-span-result {
    background: var(--primary-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--primary-color);
    border: 2px solid white;
}

.stock-span-value {
    background: var(--secondary-color);
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    font-weight: bold;
    margin-top: 5px;
    font-size: 0.8rem;
}

@keyframes stockSpanPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.monotonic-stack-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--info-color);
}

.stack-item {
    background: var(--warning-color);
    color: white;
    padding: 8px 12px;
    margin: 5px;
    border-radius: 5px;
    display: inline-block;
    transition: all 0.3s ease;
}

.stack-item.active {
    background: var(--success-color);
    transform: scale(1.1);
}
/* Add these to the existing CSS */
.element-value.and-pair-current {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: andOrPulse 0.5s ease-in-out;
}

.element-value.or-pair-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: andOrPulse 0.5s ease-in-out;
}

.element-value.max-and-pair {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: maxPairHighlight 1s ease-in-out;
}

.element-value.max-or-pair {
    background: var(--primary-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--primary-color);
    border: 3px solid white;
    animation: maxPairHighlight 1s ease-in-out;
}

@keyframes andOrPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes maxPairHighlight {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.logical-results {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
}
.logical-results .stats-card {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 0;
    height: 100%;
    transition: all 0.3s ease;
}

.logical-results .stats-card:hover {
    background: rgba(255, 255, 255, 0.15);
    transform: translateY(-2px);
}

.logical-results .stats-value {
    font-size: 0.9rem;
    line-height: 1.3;
    margin-bottom: 5px;
    word-break: break-all;
}

.logical-results .stats-value:last-child {
    margin-bottom: 0;
}

/* Animation for results update */
.stats-value {
    transition: all 0.3s ease;
}

.stats-value.updated {
    background: rgba(108, 92, 231, 0.2);
    border-radius: 5px;
    padding: 2px 5px;
}


.logical-result-item {
    background: var(--primary-color) !important;
    color: white;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
}
/* Add these to the existing CSS */
.element-value.histogram-bar {
    background: var(--primary-color);
    height: var(--bar-height);
    width: 50px;
    margin: 0 2px;
    border-radius: 5px 5px 0 0;
    position: relative;
    transition: all 0.3s ease;
}

.element-value.histogram-current {
    background: var(--warning-color);
    box-shadow: 0 0 20px var(--warning-color);
    z-index: 10;
}

.element-value.histogram-in-stack {
    background: var(--info-color);
    border: 2px solid white;
}

.element-value.histogram-max-area {
    background: var(--success-color);
    box-shadow: 0 0 25px var(--success-color);
    transform: scale(1.05);
    z-index: 20;
    animation: histogramPulse 2s ease-in-out infinite;
}

.element-value.histogram-left-boundary {
    background: var(--secondary-color);
    opacity: 0.8;
}

.element-value.histogram-right-boundary {
    background: var(--danger-color);
    opacity: 0.8;
}

@keyframes histogramPulse {
    0%, 100% { transform: scale(1.05); }
    50% { transform: scale(1.1); }
}

.histogram-container {
    display: flex;
    align-items: flex-end;
    justify-content: center;
    min-height: 400px;
    padding: 20px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 15px;
    margin: 20px 0;
    position: relative;
}

.histogram-bar-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0 5px;
    position: relative;
}

.histogram-bar-label {
    margin-top: 10px;
    font-size: 0.8rem;
    color: var(--secondary-color);
    text-align: center;
}

.histogram-area-display {
    position: absolute;
    background: rgba(255, 255, 255, 0.9);
    color: var(--dark-color);
    padding: 5px 10px;
    border-radius: 5px;
    font-weight: bold;
    z-index: 30;
    pointer-events: none;
    transition: all 0.3s ease;
}

.stack-visualization {
    display: flex;
    flex-direction: column-reverse;
    align-items: center;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin: 15px 0;
    min-height: 150px;
}

.stack-item {
    background: var(--info-color);
    color: white;
    padding: 8px 15px;
    margin: 2px 0;
    border-radius: 5px;
    font-weight: bold;
    transition: all 0.3s ease;
}

.stack-item.active {
    background: var(--warning-color);
    transform: scale(1.1);
}

.area-calculation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border-left: 4px solid var(--info-color);
}

.area-formula {
    font-family: 'Courier New', monospace;
    background: rgba(0, 0, 0, 0.3);
    padding: 10px;
    border-radius: 5px;
    margin: 10px 0;
}
/* Add these to the existing CSS */
.element-value.basket-fruit {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.basket-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: basketPulse 0.5s ease-in-out;
}

.element-value.basket-max {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: basketMaxPulse 1s ease-in-out;
}

.element-value.basket-removed {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

@keyframes basketPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes basketMaxPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.basket-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}
/* Add these to the existing CSS */
.element-value.element-wise-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.element-wise-result {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: elementWisePulse 0.8s ease-in-out;
}

@keyframes elementWisePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.element-wise-operation-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    margin: 20px 0;
}

.element-wise-array-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
}

.element-wise-arrow {
    font-size: 1.5rem;
    color: var(--primary-color);
    margin: 10px 0;
    animation: bounce 1s infinite;
}

.element-wise-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}
/* Add these to the existing CSS */
.element-value.logical-not-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: logicalPulse 0.5s ease-in-out;
}

.element-value.logical-xor-current {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

@keyframes logicalPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}
/* Add these to the existing CSS */
.element-value.transform-current {
    background: var(--warning-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: transformPulse 0.5s ease-in-out;
}

.element-value.transform-compared {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.transform-reduced {
    background: var(--danger-color);
    transform: scale(1.4);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: reduceAnimation 0.8s ease-in-out;
}

.element-value.transform-valid {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

@keyframes transformPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

@keyframes reduceAnimation {
    0% { transform: scale(1.4); background: var(--danger-color); }
    50% { transform: scale(1.6); background: var(--warning-color); }
    100% { transform: scale(1.4); background: var(--danger-color); }
}

.transform-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.operations-counter {
    background: var(--primary-color);
    color: white;
    padding: 10px 15px;
    border-radius: 10px;
    font-weight: bold;
    margin: 10px 0;
    text-align: center;
}
/* Add these to the existing CSS */
.element-value.flip-highlight {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: flipHighlight 0.5s ease-in-out;
}

.element-value.flip-candidate {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.flip-performed {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: flipPerformed 1s ease-in-out;
}

@keyframes flipHighlight {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes flipPerformed {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.binary-representation {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    font-family: 'Courier New', monospace;
    text-align: center;
}

.binary-digit {
    display: inline-block;
    width: 30px;
    height: 30px;
    line-height: 30px;
    margin: 2px;
    background: var(--primary-color);
    color: white;
    border-radius: 5px;
    font-weight: bold;
}

.binary-digit.flipped {
    background: var(--danger-color);
    animation: digitFlip 0.5s ease-in-out;
}

@keyframes digitFlip {
    0% { transform: rotateY(0); }
    50% { transform: rotateY(180deg); }
    100% { transform: rotateY(360deg); }
}
/* Add these to the existing CSS */
.element-value.xor-highlight {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.xor-current {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: xorPulse 0.5s ease-in-out;
}

.element-value.xor-result {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

@keyframes xorPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.xor-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.xor-operation {
    font-family: 'Courier New', monospace;
    background: rgba(0, 0, 0, 0.3);
    padding: 5px 10px;
    border-radius: 5px;
    margin: 0 5px;
}
/* Add these to the existing CSS */
.element-value.abs-diff-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: absDiffPulse 0.5s ease-in-out;
}

.element-value.abs-diff-compared {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.abs-diff-max {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: absDiffMaxPulse 1s ease-in-out;
}

@keyframes absDiffPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes absDiffMaxPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.abs-diff-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    overflow: hidden;
    font-size: 0.85rem;
}

.abs-diff-table th {
    background: var(--primary-color);
    color: white;
    padding: 10px;
    text-align: center;
    font-weight: bold;
}

.abs-diff-table td {
    padding: 8px 10px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    text-align: center;
}

.abs-diff-table tr:last-child td {
    border-bottom: none;
}

.abs-diff-table tr:hover {
    background: rgba(255, 255, 255, 0.1);
}

.abs-diff-highlight {
    background: rgba(0, 184, 148, 0.2);
    font-weight: bold;
}

.abs-diff-results {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--info-color);
}

.diff-value {
    font-size: 1.2rem;
    font-weight: bold;
    padding: 10px;
    border-radius: 5px;
    margin: 5px 0;
    text-align: center;
}

.diff1-value {
    background: rgba(116, 185, 255, 0.2);
    border: 2px solid var(--info-color);
}

.diff2-value {
    background: rgba(253, 203, 110, 0.2);
    border: 2px solid var(--warning-color);
}

.max-diff-value {
    background: rgba(0, 184, 148, 0.3);
    border: 3px solid var(--success-color);
    animation: pulse 1s ease-in-out;
}
/* Add these to the existing CSS */
.element-value.circular-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: circularPulse 0.5s ease-in-out;
}

.element-value.circular-included {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.circular-max-subarray {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: circularMaxPulse 1s ease-in-out;
}

.element-value.circular-min-subarray {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: circularMinPulse 1s ease-in-out;
}

@keyframes circularPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes circularMaxPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes circularMinPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.5); }
}

.circular-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    overflow: hidden;
}

.circular-table th {
    background: var(--primary-color);
    color: white;
    padding: 12px;
    text-align: left;
    font-weight: bold;
}

.circular-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.circular-table tr:last-child td {
    border-bottom: none;
}

.circular-table tr:hover {
    background: rgba(255, 255, 255, 0.1);
}

.circular-step-active {
    background: rgba(0, 184, 148, 0.2) !important;
    font-weight: bold;
}

.circular-value-highlight {
    background: rgba(255, 193, 7, 0.2);
    font-weight: bold;
}
/* Add these to the existing CSS */
.element-value.wiggle-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: wigglePulse 0.5s ease-in-out;
}

.element-value.wiggle-compared {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.wiggle-swapped {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: wiggleSwap 0.8s ease-in-out;
}

.element-value.wiggle-correct {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

.element-value.wiggle-incorrect {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--danger-color);
    animation: shake 0.5s ease;
}

@keyframes wigglePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes wiggleSwap {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.wiggle-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}
/* Add these to the existing CSS */
.element-value.max-distance-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: maxDistancePulse 0.5s ease-in-out;
}

.element-value.max-distance-pair {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: maxDistanceHighlight 1s ease-in-out;
}

.element-value.max-distance-checked {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
}

@keyframes maxDistancePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes maxDistanceHighlight {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.max-distance-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}
/* Add these to the existing CSS */
.element-value.pair-element {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.pair-current {
    background: var(--warning-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: pairPulse 0.5s ease-in-out;
}

.element-value.pair-match {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: pairMatch 1s ease-in-out;
}

@keyframes pairPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

@keyframes pairMatch {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.pairs-results {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--success-color);
}

.pair-item {
    background: var(--success-color) !important;
    color: white;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
    display: inline-block;
}

.pair-item:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(0, 184, 148, 0.4);
}
/* Add these to the existing CSS */
.element-value.valid-element {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.invalid-element {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

.element-value.window-boundary {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: windowBoundaryPulse 1s ease-in-out;
}

.element-value.swap-candidate {
    background: var(--info-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--info-color);
    border: 3px solid white;
    animation: swapCandidatePulse 0.8s ease-in-out;
}

.element-value.swap-performed {
    background: var(--primary-color);
    transform: scale(1.4);
    box-shadow: 0 0 35px var(--primary-color);
    border: 3px solid white;
    animation: swapPerformed 1s ease-in-out;
}

@keyframes windowBoundaryPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes swapCandidatePulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

@keyframes swapPerformed {
    0%, 100% { transform: scale(1.4); }
    50% { transform: scale(1.6); }
}

.swaps-results {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--info-color);
}

.swap-operation {
    background: var(--info-color) !important;
    color: white;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
    display: inline-block;
}

.swap-operation:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(116, 185, 255, 0.4);
}
/* Add these to the existing CSS */
.element-value.repeating-element {
    background: var(--danger-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--danger-color);
    border: 3px solid white;
    animation: repeatingPulse 1s ease-in-out;
}

.element-value.checked-repeating {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.non-repeating-check {
    background: var(--info-color);
    transform: scale(1.05);
    box-shadow: 0 0 15px var(--info-color);
}

@keyframes repeatingPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.repeating-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--danger-color);
}
/* Add these to the existing CSS */
.element-value.true-condition {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.false-condition {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.conditional-result {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: conditionalPulse 0.8s ease-in-out;
}

@keyframes conditionalPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.conditional-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}
/* Add these to the existing CSS */
.element-value.true-condition {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
    animation: conditionalPulse 0.8s ease-in-out;
}

.element-value.false-condition {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
    animation: conditionalPulse 0.8s ease-in-out;
}

.element-value.conditional-result {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: conditionalPulse 0.8s ease-in-out;
}

@keyframes conditionalPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.conditional-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

/* Ensure the sorting classes are defined */
.element-value.sorting-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
}

.element-value.sorting-compared {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.success-color {
    background: var(--success-color) !important;
}

.warning-color {
    background: var(--warning-color) !important;
}
/* Add these to the existing CSS */
.element-value.predicate-match {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: predicatePulse 0.8s ease-in-out;
}

.element-value.predicate-nomatch {
    background: var(--danger-color);
    opacity: 0.6;
    transform: scale(0.9);
}

@keyframes predicatePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.predicate-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}
/* Add these to the existing CSS */
.matrix-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    margin: 20px 0;
}

.matrix-row {
    display: flex;
    gap: 10px;
    justify-content: center;
}

.matrix-element {
    background: var(--primary-color);
    color: white;
    width: 60px;
    height: 60px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 10px;
    font-weight: bold;
    font-size: 1.2rem;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    transition: all 0.5s ease;
    animation: matrixAppear 0.6s ease;
}

@keyframes matrixAppear {
    from {
        transform: scale(0) rotate(180deg);
        opacity: 0;
    }
    to {
        transform: scale(1) rotate(0deg);
        opacity: 1;
    }
}

.reshape-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.matrix-label {
    color: var(--secondary-color);
    font-size: 1rem;
    font-weight: bold;
    margin-bottom: 10px;
    text-align: center;
}
/* Add these to the existing CSS */
.element-value.transform-animation {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: transformPulse 0.8s ease-in-out;
}

@keyframes transformPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}
/* Add these to the existing CSS */
.element-value.shuffle-current {
    background: var(--warning-color);
    transform: scale(1.3);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: shufflePulse 0.5s ease-in-out;
}

.element-value.shuffle-swap {
    background: var(--danger-color);
    transform: scale(1.2);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

.element-value.shuffle-completed {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

@keyframes shufflePulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.shuffle-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}
/* Add these to the existing CSS */
.element-value.bin-interval-highlight {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
    animation: binPulse 0.5s ease-in-out;
}

.element-value.bin-boundary {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
}

.element-value.bin-count-highlight {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: binCountPulse 1s ease-in-out;
}

@keyframes binPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes binCountPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.bin-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    overflow: hidden;
}

.bin-table th {
    background: var(--primary-color);
    color: white;
    padding: 12px;
    text-align: left;
    font-weight: bold;
}

.bin-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.bin-table tr:last-child td {
    border-bottom: none;
}

.bin-table tr:hover {
    background: rgba(255, 255, 255, 0.1);
}

.bin-interval-high-count {
    background: rgba(255, 193, 7, 0.2);
    font-weight: bold;
}

.bin-visualization {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border-left: 4px solid var(--info-color);
}
/* Enhanced Stock Market Styles */
.investment-insight {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 15px;
    border-radius: 10px;
    margin: 10px 0;
    text-align: center;
}

.performance-metric {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    padding: 10px;
    margin: 5px 0;
    border-left: 4px solid var(--info-color);
}

.metric-positive {
    border-left-color: var(--success-color) !important;
    background: rgba(0, 184, 148, 0.1);
}

.metric-negative {
    border-left-color: var(--danger-color) !important;
    background: rgba(255, 118, 117, 0.1);
}

.volatility-indicator {
    display: inline-block;
    padding: 4px 8px;
    border-radius: 15px;
    font-size: 0.8rem;
    margin: 2px;
}

.volatility-high {
    background: var(--danger-color);
    color: white;
}

.volatility-medium {
    background: var(--warning-color);
    color: black;
}

.volatility-low {
    background: var(--success-color);
    color: white;
}

.financial-summary {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--primary-color);
}

.business-insight {
    background: rgba(116, 185, 255, 0.1);
    border-left: 4px solid var(--info-color);
    padding: 10px;
    margin: 8px 0;
    border-radius: 5px;
    font-size: 0.9rem;
}
/* Add these to your existing CSS */
.momentum-positive {
    background: linear-gradient(135deg, #00b894, #00a085) !important;
    color: white;
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(0, 184, 148, 0.4);
}

.momentum-negative {
    background: linear-gradient(135deg, #ff7675, #e66767) !important;
    color: white;
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(255, 118, 117, 0.4);
}

.roc-indicator {
    border: 3px solid transparent;
    background-clip: padding-box;
}

.roc-high {
    border-color: #00b894;
    animation: pulse-roc 2s infinite;
}

.roc-low {
    border-color: #ff7675;
    animation: pulse-roc 2s infinite;
}

@keyframes pulse-roc {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

.gap-up {
    background: rgba(0, 184, 148, 0.3) !important;
    border-left: 6px solid #00b894 !important;
}

.gap-down {
    background: rgba(255, 118, 117, 0.3) !important;
    border-left: 6px solid #ff7675 !important;
}

.intraday-gain {
    box-shadow: 0 0 20px rgba(0, 184, 148, 0.5);
    animation: glow-gain 1.5s ease-in-out infinite alternate;
}

.intraday-loss {
    box-shadow: 0 0 20px rgba(255, 118, 117, 0.5);
    animation: glow-loss 1.5s ease-in-out infinite alternate;
}

@keyframes glow-gain {
    from { box-shadow: 0 0 10px rgba(0, 184, 148, 0.5); }
    to { box-shadow: 0 0 20px rgba(0, 184, 148, 0.8); }
}

@keyframes glow-loss {
    from { box-shadow: 0 0 10px rgba(255, 118, 117, 0.5); }
    to { box-shadow: 0 0 20px rgba(255, 118, 117, 0.8); }
}

.dual-operation-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 15px;
    padding: 20px;
    margin: 15px 0;
    border: 1px solid var(--primary-color);
}

.array-group {
    margin: 10px 0;
}

.array-label {
    font-weight: bold;
    margin-bottom: 8px;
    color: var(--info-color);
    text-align: center;
}

.operation-arrow {
    text-align: center;
    margin: 15px 0;
    font-size: 1.5rem;
    color: var(--primary-color);
}

.financial-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin: 15px 0;
    border-left: 4px solid var(--warning-color);
}
/* Add these to your existing CSS */
.technical-indicator {
    border-radius: 10px;
    transition: all 0.3s ease;
}

.moving-average {
    background: linear-gradient(135deg, #667eea, #764ba2) !important;
    color: white;
    border: 2px solid #5a6fd8;
}

.macd-line {
    background: linear-gradient(135deg, #f093fb, #f5576c) !important;
    color: white;
    border: 2px solid #e668a3;
}

.macd-signal {
    background: linear-gradient(135deg, #4facfe, #00f2fe) !important;
    color: white;
    border: 2px solid #2aa9e0;
}

.bollinger-band {
    background: linear-gradient(135deg, #43e97b, #38f9d7) !important;
    color: white;
    border: 2px solid #2de28d;
}

.volatility-high {
    animation: volatility-pulse 1.5s ease-in-out infinite;
}

@keyframes volatility-pulse {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.05); opacity: 0.8; }
    100% { transform: scale(1); opacity: 1; }
}

.trend-up {
    box-shadow: 0 0 15px rgba(0, 184, 148, 0.6);
    animation: trend-up-glow 2s ease-in-out infinite alternate;
}

.trend-down {
    box-shadow: 0 0 15px rgba(255, 118, 117, 0.6);
    animation: trend-down-glow 2s ease-in-out infinite alternate;
}

@keyframes trend-up-glow {
    from { box-shadow: 0 0 10px rgba(0, 184, 148, 0.4); }
    to { box-shadow: 0 0 20px rgba(0, 184, 148, 0.8); }
}

@keyframes trend-down-glow {
    from { box-shadow: 0 0 10px rgba(255, 118, 117, 0.4); }
    to { box-shadow: 0 0 20px rgba(255, 118, 117, 0.8); }
}

.calculation-step {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    padding: 10px;
    margin: 5px 0;
    border-left: 4px solid var(--info-color);
    transition: all 0.3s ease;
}

.calculation-step.active {
    background: rgba(255, 255, 255, 0.1);
    border-left-color: var(--warning-color);
    transform: translateX(5px);
}

.period-selector {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid var(--primary-color);
    border-radius: 8px;
    padding: 10px;
    margin: 10px 0;
}

.period-label {
    font-weight: bold;
    color: var(--info-color);
    margin-bottom: 8px;
}
/* Enhanced Matrix Styles */
.matrix-container {
    display: grid;
    gap: 8px;
    margin: 15px 0;
    justify-content: center;
    padding: 10px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
}

.matrix-row {
    display: flex;
    gap: 8px;
    justify-content: center;
}

.matrix-cell {
    width: 60px;
    height: 60px;
    background: var(--primary-color);
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 8px;
    font-weight: bold;
    font-size: 0.9rem;
    transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    position: relative;
    overflow: hidden;
}

.matrix-cell::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: 0.5s;
}

.matrix-cell.highlight {
    background: var(--warning-color);
    transform: scale(1.15);
    box-shadow: 0 0 20px var(--warning-color);
    z-index: 10;
}

.matrix-cell.highlight::before {
    left: 100%;
}

.matrix-cell.result {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--success-color);
}

.matrix-cell.processing {
    background: var(--info-color);
    transform: scale(1.05);
}

.axis-operation-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    border-left: 4px solid var(--info-color);
    transition: all 0.3s ease;
}

.axis-operation-explanation.highlight {
    background: rgba(255, 255, 255, 0.15);
    border-left: 4px solid var(--warning-color);
}

/* Add pulse animation for better visibility */
@keyframes matrixPulse {
    0%, 100% { 
        transform: scale(1.15);
        box-shadow: 0 0 20px var(--warning-color);
    }
    50% { 
        transform: scale(1.25);
        box-shadow: 0 0 30px var(--warning-color);
    }
}

.matrix-cell.highlight.pulse {
    animation: matrixPulse 1s ease-in-out;
}

/* Step animation */
.algorithm-step {
    transition: all 0.3s ease;
    margin-bottom: 8px;
    padding: 10px;
    border-radius: 5px;
}

.algorithm-step.active {
    background: rgba(255, 255, 255, 0.1);
    border-left: 4px solid var(--success-color);
    transform: translateX(5px);
}
/* Add these to the existing CSS */
.element-value.stat-min-highlight {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: statPulse 1s ease-in-out;
}

.element-value.stat-max-highlight {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: statPulse 1s ease-in-out;
}

.element-value.stat-n-smallest {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.stat-n-largest {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

@keyframes statPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.stats-results-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    border-left: 4px solid var(--info-color);
}

.stats-result-item {
    background: var(--primary-color);
    color: white;
    padding: 8px 12px;
    margin: 5px;
    border-radius: 5px;
    display: inline-block;
    font-family: 'Courier New', monospace;
}
/* Add these to the existing CSS */
.parentheses-valid {
    background: var(--success-color) !important;
    color: white;
    padding: 10px;
    border-radius: 5px;
    text-align: center;
    font-weight: bold;
    margin: 10px 0;
    animation: slideIn 0.5s ease;
}

.parentheses-invalid {
    background: var(--danger-color) !important;
    color: white;
    padding: 10px;
    border-radius: 5px;
    text-align: center;
    font-weight: bold;
    margin: 10px 0;
    animation: shake 0.5s ease;
}

.parentheses-current {
    background: var(--warning-color) !important;
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: parenthesesPulse 0.5s ease-in-out;
}

.parentheses-matched {
    background: var(--success-color) !important;
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.parentheses-unmatched {
    background: var(--danger-color) !important;
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
    animation: shake 0.5s ease;
}

@keyframes parenthesesPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.parentheses-stack-item {
    background: var(--info-color) !important;
    color: white;
    font-family: 'Courier New', monospace;
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
    transition: all 0.3s ease;
}

.parentheses-stack-item.current {
    background: var(--warning-color) !important;
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--warning-color);
}
/* Add these to the existing CSS */
.element-value.kadane-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: kadaneCurrentPulse 0.5s ease-in-out;
}

.element-value.kadane-included {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.kadane-max-subarray {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: kadaneHighlight 1s ease-in-out;
}

@keyframes kadaneCurrentPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes kadaneHighlight {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}
/* Add these to the existing CSS */
.palindrome-valid {
    background: var(--success-color) !important;
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: palindromePulse 1s ease-in-out;
}

.palindrome-invalid {
    background: var(--danger-color) !important;
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: palindromePulse 1s ease-in-out;
}

.anagram-valid {
    background: var(--success-color) !important;
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: anagramPulse 1s ease-in-out;
}

.anagram-invalid {
    background: var(--danger-color) !important;
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--danger-color);
    border: 3px solid white;
    animation: anagramPulse 1s ease-in-out;
}

@keyframes palindromePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes anagramPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.string-operation-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    margin: 20px 0;
}

.string-input-group {
    width: 100%;
    max-width: 400px;
}

.string-display {
    font-size: 1.5rem;
    font-weight: bold;
    padding: 15px;
    border-radius: 10px;
    background: rgba(255, 255, 255, 0.1);
    text-align: center;
    min-height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 10px 0;
}

.character-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 8px;
    margin: 15px 0;
}

.character-box {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--primary-color);
    color: white;
    border-radius: 5px;
    font-weight: bold;
    font-size: 1.1rem;
    transition: all 0.3s ease;
}

.character-box.highlight {
    background: var(--warning-color);
    transform: scale(1.2);
}
/* Add these to the existing CSS */
.element-value.range-sum-highlight {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: rangeSumPulse 1s ease-in-out;
}

.element-value.range-sum-current {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

@keyframes rangeSumPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.range-sum-results {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--success-color);
}
/* Add these to the existing CSS */
.element-value.daily-temp-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: dailyTempPulse 0.5s ease-in-out;
}

.element-value.daily-temp-stack {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.daily-temp-warmer {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: dailyTempWarmer 1s ease-in-out;
}

.element-value.daily-temp-processed {
    background: var(--secondary-color);
    opacity: 0.7;
}

@keyframes dailyTempPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes dailyTempWarmer {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.daily-temp-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.daily-temp-result {
    background: rgba(0, 184, 148, 0.2);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border: 1px solid var(--success-color);
}
/* Add these to the existing CSS */
.element-value.palindrome-center {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: palindromePulse 0.5s ease-in-out;
}

.element-value.palindrome-expanding {
    background: var(--warning-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--warning-color);
    border: 3px solid white;
}

.element-value.palindrome-found {
    background: var(--success-color);
    transform: scale(1.4);
    box-shadow: 0 0 35px var(--success-color);
    border: 3px solid white;
    animation: palindromeFound 1s ease-in-out;
}

.element-value.longest-palindrome {
    background: var(--danger-color);
    transform: scale(1.5);
    box-shadow: 0 0 40px var(--danger-color);
    border: 4px solid white;
    animation: longestPalindrome 2s ease-in-out infinite;
}

@keyframes palindromePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes palindromeFound {
    0%, 100% { transform: scale(1.4); }
    50% { transform: scale(1.6); }
}

@keyframes longestPalindrome {
    0%, 100% { transform: scale(1.5); }
    50% { transform: scale(1.7); }
}

.palindrome-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.palindrome-stats {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--success-color);
}
/* Add these to the existing CSS */
.dp-table {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    overflow-x: auto;
}

.dp-cell {
    transition: all 0.3s ease;
    border: 1px solid rgba(255, 255, 255, 0.2);
}

.dp-header {
    font-weight: bold;
    background: var(--primary-color) !important;
}

.dp-cell:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}
/* Add these to the existing CSS */
.element-value.backtrack-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: backtrackPulse 0.5s ease-in-out;
}

.element-value.backtrack-included {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.backtrack-skipped {
    background: var(--danger-color);
    opacity: 0.6;
    transform: scale(0.9);
}

.element-value.backtrack-valid {
    background: var(--info-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--info-color);
    border: 3px solid white;
    animation: validPulse 1s ease-in-out;
}

@keyframes backtrackPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes validPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.combination-result {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 10px;
    border-left: 4px solid var(--success-color);
}

.subset-item {
    background: var(--primary-color);
    color: white;
    padding: 8px 12px;
    margin: 5px;
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    display: inline-block;
    transition: all 0.3s ease;
}

.subset-item:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(108, 92, 231, 0.4);
}

.backtrack-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}
/* Add these to the existing CSS */
.element-value.parenthesis-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: parenthesisPulse 0.5s ease-in-out;
}

.element-value.parenthesis-match {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
}

.element-value.parenthesis-invalid {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
}

@keyframes parenthesisPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.dp-table {
    display: grid;
    gap: 2px;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.1);
    padding: 10px;
    border-radius: 10px;
}

.dp-row {
    display: grid;
    grid-template-columns: 50px repeat(auto-fit, minmax(50px, 1fr));
    gap: 2px;
}

.dp-cell {
    background: var(--primary-color);
    padding: 10px;
    text-align: center;
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
}

.dp-cell.header {
    background: var(--dark-color);
    font-weight: bold;
}

.dp-cell.current {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--warning-color);
}

.dp-cell.updated {
    background: var(--success-color);
    transform: scale(1.05);
}

.dp-cell.zero {
    background: rgba(255, 255, 255, 0.1);
    opacity: 0.7;
}

.parenthesis-stack {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border-left: 4px solid var(--info-color);
}

.stack-item {
    background: var(--primary-color);
    color: white;
    padding: 10px;
    margin: 5px 0;
    border-radius: 5px;
    text-align: center;
    font-family: 'Courier New', monospace;
    transition: all 0.3s ease;
}

.stack-item.current {
    background: var(--warning-color);
    transform: scale(1.05);
    box-shadow: 0 0 15px var(--warning-color);
}

.stack-item.sentinel {
    background: var(--secondary-color);
    opacity: 0.8;
}
/* Add these to the existing CSS */
.element-value.smaller-count-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: smallerCountPulse 0.5s ease-in-out;
}

.element-value.smaller-count-compared {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.smaller-count-smaller {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
}

.element-value.smaller-count-result {
    background: var(--primary-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--primary-color);
    border: 2px solid white;
}

@keyframes smallerCountPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.smaller-count-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    overflow: hidden;
}

.smaller-count-table th {
    background: var(--primary-color);
    color: white;
    padding: 12px;
    text-align: center;
    font-weight: bold;
}

.smaller-count-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    text-align: center;
}

.smaller-count-table tr:last-child td {
    border-bottom: none;
}

.smaller-count-table tr:hover {
    background: rgba(255, 255, 255, 0.1);
}

.smaller-count-results-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin-top: 20px;
    border: 1px solid var(--info-color);
}
/* Ugly Number Styles */
.ugly-number-highlight {
    background: var(--warning-color) !important;
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: uglyPulse 0.8s ease-in-out;
}

.ugly-number-prime-factor {
    background: var(--info-color) !important;
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.ugly-number-current {
    background: var(--success-color) !important;
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: uglyCurrentPulse 1s ease-in-out;
}

.ugly-number-candidate {
    background: var(--secondary-color) !important;
    transform: scale(1.1);
    box-shadow: 0 0 15px var(--secondary-color);
}

@keyframes uglyPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes uglyCurrentPulse {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

.ugly-number-sequence {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
    margin: 15px 0;
}

.ugly-sequence-item {
    background: var(--primary-color);
    color: white;
    padding: 8px 12px;
    border-radius: 5px;
    font-weight: bold;
    transition: all 0.3s ease;
}

.ugly-sequence-item.current {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 20px var(--success-color);
}
/* Add these to the existing CSS */
.element-value.perfect-number {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: perfectPulse 1s ease-in-out;
}

.element-value.armstrong-number {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--info-color);
    border: 3px solid white;
    animation: armstrongPulse 1s ease-in-out;
}

.element-value.checking-perfect {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
}

.element-value.checking-armstrong {
    background: var(--secondary-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--secondary-color);
}

@keyframes perfectPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes armstrongPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.perfect-explanation, .armstrong-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}
/* Add these to the existing CSS */
.pascal-triangle-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 20px 0;
}

.pascal-row {
    display: flex;
    justify-content: center;
    margin: 5px 0;
}

.pascal-element {
    background: var(--primary-color);
    color: white;
    width: 50px;
    height: 50px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 50%;
    font-weight: bold;
    margin: 0 5px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    transition: all 0.3s ease;
}

.pascal-element.highlight {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    animation: pascalHighlight 0.5s ease-in-out;
}

@keyframes pascalHighlight {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.pascal-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}
    .circle-visualization {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        margin: 20px 0;
    }

    .circle-container {
        position: relative;
        width: 300px;
        height: 300px;
        border: 2px solid var(--primary-color);
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.05);
        margin: 20px 0;
    }

    .circle-center {
        position: absolute;
        width: 10px;
        height: 10px;
        background: var(--success-color);
        border-radius: 50%;
        transform: translate(-50%, -50%);
    }

    .random-point {
        position: absolute;
        width: 8px;
        height: 8px;
        background: var(--warning-color);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        transition: all 0.5s ease;
    }

    .point-label {
        position: absolute;
        color: white;
        font-size: 0.8rem;
        background: rgba(0, 0, 0, 0.7);
        padding: 2px 6px;
        border-radius: 3px;
        transform: translate(10px, -10px);
    }

    .radius-line {
        position: absolute;
        background: var(--info-color);
        height: 2px;
        transform-origin: 0 0;
    }

    .circle-info {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        padding: 15px;
        margin-top: 15px;
        text-align: center;
    }

    .coordinate-display {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin: 10px 0;
    }

    .coordinate-item {
        background: var(--primary-color);
        padding: 8px 12px;
        border-radius: 5px;
        font-family: 'Courier New', monospace;
    }
/* Add these to the existing CSS */
.element-value.english-word {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
    animation: englishWordPulse 1s ease-in-out;
}

.element-value.contains-digit-one {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: digitOnePulse 1s ease-in-out;
}

.element-value.digit-one-count {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: digitOneHighlight 1s ease-in-out;
}

@keyframes englishWordPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

@keyframes digitOnePulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes digitOneHighlight {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.number-operation-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}

.english-word-display {
    background: var(--primary-color);
    color: white;
    padding: 15px;
    border-radius: 10px;
    margin: 10px 0;
    font-size: 1.2rem;
    font-weight: bold;
    text-align: center;
    animation: slideIn 0.5s ease;
}
/* Add these to the existing CSS */
.element-value.digital-root-current {
    background: var(--warning-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
    animation: digitalRootPulse 0.5s ease-in-out;
}

.element-value.digital-root-result {
    background: var(--success-color);
    transform: scale(1.3);
    box-shadow: 0 0 30px var(--success-color);
    border: 3px solid white;
    animation: digitalRootResult 1s ease-in-out;
}

.element-value.happy-number {
    background: var(--success-color);
    transform: scale(1.2);
    box-shadow: 0 0 25px var(--success-color);
    border: 3px solid white;
    animation: happyNumberPulse 1s ease-in-out;
}

.element-value.not-happy-number {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
    opacity: 0.7;
}

.element-value.happy-process {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

@keyframes digitalRootPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

@keyframes digitalRootResult {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.6); }
}

@keyframes happyNumberPulse {
    0%, 100% { transform: scale(1.2); }
    50% { transform: scale(1.4); }
}

.digital-root-explanation, .happy-number-explanation {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
    margin-top: 15px;
    text-align: center;
    border-left: 4px solid var(--info-color);
}
/* Add these to the existing CSS */
.element-value.excel-column {
    background: var(--info-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--info-color);
    border: 2px solid white;
}

.element-value.excel-number {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
    animation: excelPulse 0.8s ease-in-out;
}

.element-value.excel-error {
    background: var(--danger-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--danger-color);
    border: 2px solid white;
    animation: shake 0.5s ease;
}

@keyframes excelPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.excel-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    overflow: hidden;
}

.excel-table th {
    background: var(--primary-color);
    color: white;
    padding: 12px;
    text-align: left;
    font-weight: bold;
}

.excel-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.excel-table tr:last-child td {
    border-bottom: none;
}

.excel-table tr:hover {
    background: rgba(255, 255, 255, 0.1);
}

.excel-conversion-step {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 5px;
    padding: 8px;
    margin: 5px 0;
    border-left: 3px solid var(--info-color);
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
}

.excel-conversion-step.active {
    border-left: 3px solid var(--success-color);
    background: rgba(0, 184, 148, 0.1);
}
/* Add these to the existing CSS for Number to Column Title */
.element-value.number-to-column {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--warning-color);
    border: 2px solid white;
}

.element-value.column-title-result {
    background: var(--success-color);
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--success-color);
    border: 2px solid white;
    animation: columnTitlePulse 0.8s ease-in-out;
}

@keyframes columnTitlePulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.3); }
}

.number-to-column-step {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 5px;
    padding: 8px;
    margin: 5px 0;
    border-left: 3px solid var(--warning-color);
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
}

.number-to-column-step.active {
    border-left: 3px solid var(--success-color);
    background: rgba(0, 184, 148, 0.1);
}

.conversion-process {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid var(--info-color);
}

.process-step {
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 10px 0;
    padding: 10px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 5px;
}

.process-arrow {
    margin: 0 15px;
    color: var(--primary-color);
    font-size: 1.2rem;
}
/* Add these to the existing CSS */
.stack-container {
    display: flex;
    flex-direction: column-reverse;
    align-items: center;
    justify-content: flex-end;
    min-height: 400px;
    padding: 20px;
    margin: 20px 0;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 15px;
    border: 2px solid var(--primary-color);
}

.stack-element {
    width: 120px;
    height: 60px;
    background: var(--primary-color);
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 5px 0;
    border-radius: 8px;
    font-weight: bold;
    font-size: 1.1rem;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    transition: all 0.5s ease;
    position: relative;
}

.stack-element.top-element {
    background: var(--warning-color);
    transform: scale(1.1);
    box-shadow: 0 0 25px var(--warning-color);
    border: 3px solid white;
}

.stack-element.push-animation {
    animation: stackPush 0.8s ease-out;
}

.stack-element.pop-animation {
    animation: stackPop 0.8s ease-out;
}

.stack-element.peek-highlight {
    background: var(--info-color);
    transform: scale(1.2);
    box-shadow: 0 0 30px var(--info-color);
    border: 3px solid white;
    animation: peekPulse 1.5s ease-in-out infinite;
}

.stack-pointer {
    color: var(--warning-color);
    font-weight: bold;
    margin-top: 10px;
    font-size: 1.1rem;
}

.stack-operation-log {
    max-height: 200px;
    overflow-y: auto;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    padding: 10px;
    margin-top: 10px;
}

.stack-operation-step {
    padding: 8px 12px;
    margin: 5px 0;
    border-radius: 5px;
    background: rgba(255, 255, 255, 0.1);
    font-size: 0.9rem;
    border-left: 4px solid var(--info-color);
    animation: slideIn 0.3s ease;
}

.stack-operation-step.success {
    border-left: 4px solid var(--success-color);
    background: rgba(0, 184, 148, 0.1);
}

.stack-operation-step.warning {
    border-left: 4px solid var(--warning-color);
    background: rgba(253, 203, 110, 0.1);
}

.stack-operation-step.danger {
    border-left: 4px solid var(--danger-color);
    background: rgba(255, 118, 117, 0.1);
}

@keyframes stackPush {
    0% {
        transform: translateY(-100px);
        opacity: 0;
    }
    70% {
        transform: translateY(10px);
        opacity: 1;
    }
    100% {
        transform: translateY(0);
        opacity: 1;
    }
}

@keyframes stackPop {
    0% {
        transform: translateY(0);
        opacity: 1;
    }
    30% {
        transform: translateY(-10px);
        opacity: 0.8;
    }
    100% {
        transform: translateY(-100px);
        opacity: 0;
    }
}

@keyframes peekPulse {
    0%, 100% {
        transform: scale(1.2);
        box-shadow: 0 0 30px var(--info-color);
    }
    50% {
        transform: scale(1.3);
        box-shadow: 0 0 40px var(--info-color);
    }
}

.stack-comparison {
    display: flex;
    justify-content: space-around;
    margin: 20px 0;
    gap: 20px;
}

.comparison-section {
    flex: 1;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 15px;
}

.comparison-title {
    color: var(--secondary-color);
    font-size: 1.1rem;
    font-weight: bold;
    margin-bottom: 10px;
    text-align: center;
}

.stack-empty-state {
    text-align: center;
    padding: 40px;
    color: var(--secondary-color);
}

.stack-empty-state i {
    font-size: 3rem;
    margin-bottom: 15px;
    opacity: 0.5;
}


/* ===== MOBILE OPTIMIZATION ===== */
/* Ensure 100% visibility and usability on mobile devices */

@media (max-width: 768px) {
    /* General mobile adjustments */
    body {
        font-size: 14px;
        line-height: 1.4;
    }
    
    .container {
        padding-left: 10px;
        padding-right: 10px;
    }
    
    /* Header and title optimization */
    .display-4 {
        font-size: 1.8rem !important;
    }
    
    .lead {
        font-size: 1rem !important;
    }
    
    /* Main array container optimization */
    .array-container {
        min-height: 200px;
        padding: 10px;
        gap: 5px;
        margin: 10px 0;
    }
    
    /* Array elements optimization */
    .array-element {
        margin: 0 2px 8px 2px;
        min-width: 40px;
    }
    
    .element-value {
        width: 40px !important;
        height: 40px !important;
        font-size: 0.9rem !important;
        border-radius: 8px;
    }
    
    .element-index {
        font-size: 0.7rem;
        margin-top: 5px;
    }
    
    /* Stats cards optimization */
    .stats-card {
        padding: 10px;
        margin: 5px 0;
    }
    
    .stats-value {
        font-size: 1.1rem !important;
        max-height: 40px;
        overflow-y: auto;
    }
    
    /* Operation tabs optimization */
    .nav-tabs {
        flex-wrap: nowrap;
        overflow-x: auto;
        overflow-y: hidden;
        -webkit-overflow-scrolling: touch;
        white-space: nowrap;
    }
    
    .nav-tabs .nav-item {
        flex: 0 0 auto;
    }
    
    .nav-tabs .nav-link {
        font-size: 0.8rem;
        padding: 8px 12px;
        white-space: nowrap;
    }
    
    /* Form controls optimization */
    .form-control {
        font-size: 16px !important; /* Prevents zoom on iOS */
        padding: 10px;
    }
    
    .input-group {
        flex-wrap: wrap;
    }
    
    .input-group .form-control {
        flex: 1 1 100%;
        margin-bottom: 5px;
    }
    
    .input-group .btn {
        flex: 1 1 auto;
        margin: 2px;
    }
    
    /* Button optimization */
    .btn-glow {
        padding: 12px 16px;
        font-size: 0.9rem;
        margin: 3px 0;
        min-height: 44px; /* Minimum touch target size */
    }
    
    .btn {
        min-height: 44px; /* Apple's recommended minimum touch target */
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    /* Tab content optimization */
    .tab-content {
        padding: 10px 0;
        max-height: 60vh;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
    }
    
    /* Operation sections optimization */
    .mb-3 {
        margin-bottom: 15px !important;
    }
    
    /* Dual array containers optimization */
    .dual-array-container {
        gap: 15px;
    }
    
    .original-array-container,
    .transformed-array-container {
        padding: 10px;
        min-height: 120px;
    }
    
    /* Matrix optimization */
    .matrix-container {
        gap: 5px;
    }
    
    .matrix-row {
        gap: 5px;
    }
    
    .matrix-element {
        width: 35px !important;
        height: 35px !important;
        font-size: 0.8rem !important;
    }
    
    /* Stack containers optimization */
    .stack-container {
        min-height: 120px;
        padding: 8px;
    }
    
    .stack-element {
        padding: 6px 8px;
        min-width: 45px;
        font-size: 0.8rem;
    }
    
    /* Table optimization */
    .table-container {
        max-height: 200px;
    }
    
    .frequency-table,
    .dictionary-table,
    .leader-table,
    .jump-game-table,
    .memory-address-table {
        font-size: 0.7rem;
    }
    
    .frequency-table th,
    .dictionary-table th,
    .leader-table th,
    .jump-game-table th,
    .memory-address-table th {
        padding: 8px 6px;
    }
    
    .frequency-table td,
    .dictionary-table td,
    .leader-table td,
    .jump-game-table td,
    .memory-address-table td {
        padding: 6px 4px;
    }
    
    /* Explanation boxes optimization */
    .algorithm-explanation,
    .explanation,
    .merge-sort-explanation,
    .pancake-explanation,
    .wiggle-explanation,
    .stock-explanation,
    .set-operation-explanation,
    .conditional-explanation,
    .reshape-explanation,
    .shuffle-explanation {
        font-size: 0.8rem;
        padding: 10px;
        margin-top: 10px;
    }
    
    /* Code snippets optimization */
    .code-snippet {
        font-size: 0.7rem;
        padding: 8px;
        margin: 8px 0;
    }
    
    /* Results containers optimization */
    .search-results,
    .subarrays-container,
    .subarray-sum-results,
    .two-sum-results,
    .triplet-results,
    .quadruplet-results,
    .near-zero-results,
    .pairs-results,
    .swaps-results,
    .logical-results {
        padding: 10px;
        font-size: 0.8rem;
    }
    
    /* Special items optimization */
    .subarray-item,
    .subarray-sum-item,
    .triplet-item,
    .quadruplet-item,
    .two-sum-pair,
    .near-zero-item,
    .pair-item,
    .swap-operation,
    .logical-result-item,
    .prime-item {
        padding: 6px 8px;
        font-size: 0.7rem;
        margin: 3px;
    }
    
    /* Histogram optimization */
    .histogram-container {
        min-height: 250px;
        padding: 10px;
    }
    
    .histogram-bar-container {
        margin: 0 3px;
    }
    
    .element-value.histogram-bar {
        width: 30px !important;
    }
    
    .histogram-bar-label {
        font-size: 0.6rem;
        margin-top: 5px;
    }
    
    /* Water container optimization */
    .water-container {
        padding: 10px;
    }
    
    /* Equilibrium stats optimization */
    .equilibrium-stats {
        flex-direction: column;
        gap: 8px;
    }
    
    .equilibrium-stat {
        min-width: auto;
        padding: 8px;
    }
    
    /* Binary representation optimization */
    .binary-digit {
        width: 25px;
        height: 25px;
        line-height: 25px;
        font-size: 0.7rem;
    }
    
    /* Char array optimization */
    .char-array-container {
        padding: 10px;
        min-height: 80px;
    }
    
    .char-element-wrapper {
        margin: 0 3px 8px 3px;
    }
    
    .char-element {
        width: 35px !important;
        height: 35px !important;
        font-size: 0.9rem !important;
    }
    
    .char-index {
        font-size: 0.6rem;
        margin-top: 3px;
    }
    
    .string-display {
        padding: 10px;
        font-size: 1rem;
        min-height: 50px;
    }
    
    /* Statistical tables optimization */
    .covariance-table,
    .correlation-table,
    .abs-diff-table,
    .circular-table,
    .bin-table {
        font-size: 0.65rem;
    }
    
    .covariance-table th,
    .correlation-table th,
    .abs-diff-table th,
    .circular-table th,
    .bin-table th {
        padding: 8px 4px;
    }
    
    .covariance-table td,
    .correlation-table td,
    .abs-diff-table td,
    .circular-table td,
    .bin-table td {
        padding: 6px 3px;
    }
    
    /* Operation logs optimization */
    .operation-log {
        max-height: 150px;
        font-size: 0.8rem;
    }
    
    .log-entry {
        padding: 4px 8px;
        font-size: 0.75rem;
    }
    
    /* Empty state optimization */
    .array-empty-state {
        padding: 20px;
    }
    
    .array-empty-state i {
        font-size: 2rem;
    }
    
    .array-empty-state h4 {
        font-size: 1.2rem;
    }
    
    /* Grid system optimization */
    .row {
        margin-left: -5px;
        margin-right: -5px;
    }
    
    .col-md-3, .col-md-2, .col-md-4, .col-md-8 {
        padding-left: 5px;
        padding-right: 5px;
    }
    
    /* Glass card optimization */
    .glass-card {
        padding: 15px;
        margin-bottom: 15px;
    }
    
    /* Transformation arrows optimization */
    .transformation-arrow,
    .operation-arrow,
    .element-wise-arrow {
        font-size: 1.2rem;
        margin: 5px 0;
    }
    
    /* Stock span values optimization */
    .stock-span-value {
        font-size: 0.7rem;
        padding: 3px 6px;
    }
    
    /* Investment insights optimization */
    .investment-insight {
        padding: 10px;
        font-size: 0.9rem;
    }
    
    .performance-metric {
        padding: 8px;
        font-size: 0.8rem;
    }
    
    .financial-summary {
        padding: 10px;
        font-size: 0.8rem;
    }
    
    .business-insight {
        padding: 8px;
        font-size: 0.75rem;
    }
    
    /* Volatility indicators optimization */
    .volatility-indicator {
        padding: 3px 6px;
        font-size: 0.7rem;
    }
    
    /* Confirmation dialogs optimization */
    .confirmation-dialog {
        padding: 10px;
        font-size: 0.9rem;
    }
    
    /* Custom comparator optimization */
    .custom-comparator-container {
        padding: 10px;
    }
    
    .sort-configuration {
        padding: 10px;
        font-size: 0.8rem;
    }
    
    .sort-step {
        padding: 6px;
        font-size: 0.75rem;
    }
    
    /* Action buttons optimization */
    .action-buttons {
        flex-direction: column;
        gap: 3px;
    }
    
    .btn-sm {
        padding: 4px 6px;
        font-size: 0.7rem;
        min-height: 32px;
    }
    
    /* Editable fields optimization */
    .editable-field {
        padding: 1px 3px;
        font-size: 0.8rem;
    }
    
    /* Operations counter optimization */
    .operations-counter {
        padding: 8px 10px;
        font-size: 0.9rem;
    }
    
    /* Statistical formulas optimization */
    .statistical-formula,
    .progression-formula-display,
    .area-formula {
        padding: 8px;
        font-size: 0.7rem;
    }
    
    /* Calculation steps optimization */
    .calculation-steps {
        padding: 10px;
        font-size: 0.75rem;
    }
    
    /* Stats highlight optimization */
    .stats-highlight {
        padding: 8px;
        font-size: 0.9rem;
    }
    
    /* Progress bars optimization */
    .progress {
        height: 20px;
        margin: 8px 0;
    }
    
    .progress-bar {
        font-size: 0.7rem;
        line-height: 20px;
    }
}

/* Extra small devices (phones, less than 576px) */
@media (max-width: 575.98px) {
    .container {
        padding-left: 5px;
        padding-right: 5px;
    }
    
    .display-4 {
        font-size: 1.5rem !important;
    }
    
    .array-element {
        min-width: 35px;
    }
    
    .element-value {
        width: 35px !important;
        height: 35px !important;
        font-size: 0.8rem !important;
    }
    
    .stats-card {
        padding: 8px 5px;
    }
    
    .stats-value {
        font-size: 1rem !important;
    }
    
    .btn-glow {
        padding: 10px 12px;
        font-size: 0.85rem;
    }
    
    /* Stack items horizontally on very small screens for better space usage */
    .row .col-md-3, .row .col-md-2 {
        flex: 0 0 50%;
        max-width: 50%;
    }
}

/* Landscape orientation optimization */
@media (max-width: 768px) and (orientation: landscape) {
    .tab-content {
        max-height: 50vh;
    }
    
    .array-container {
        min-height: 150px;
    }
    
    .stats-card {
        padding: 5px;
    }
}

/* High-density displays optimization */
@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
    .element-value {
        border-width: 2px;
    }
}

/* Touch device specific optimizations */
@media (hover: none) and (pointer: coarse) {
    /* Improve touch interactions */
    .btn-glow:hover {
        transform: none; /* Remove hover effects on touch devices */
    }
    
    .element-value:hover {
        transform: none;
    }
    
    /* Increase tap target sizes */
    .nav-link {
        padding: 12px 16px;
    }
    
    /* Prevent double-tap zoom */
    button, .btn, .nav-link {
        touch-action: manipulation;
    }
}

/* Reduced motion preferences */
@media (prefers-reduced-motion: reduce) {
    * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
}

/* Dark mode support for mobile */
@media (max-width: 768px) and (prefers-color-scheme: dark) {
    .glass-card {
        background: rgba(30, 30, 30, 0.8);
    }
    
    .stats-card {
        background: rgba(30, 30, 30, 0.6);
    }
}

/* Print styles for mobile */
@media print {
    .btn, .nav-tabs, .operation-log {
        display: none !important;
    }
    
    .array-container {
        break-inside: avoid;
    }
}

/* Ensure no horizontal scrolling */
@media (max-width: 768px) {
    body {
        overflow-x: hidden;
    }
    
    .container {
        max-width: 100%;
        overflow-x: hidden;
    }
}

/* iOS specific fixes */
@supports (-webkit-touch-callout: none) {
    .btn-glow {
        -webkit-tap-highlight-color: transparent;
    }
    
    .element-value {
        -webkit-touch-callout: none;
    }
}

/* Android Chrome specific fixes */
@supports (-webkit-appearance:none) and (not (overflow:-webkit-marquee)) and (not (-ms-accelerator:true)) {
    .btn-glow {
        -webkit-appearance: none;
    }
}
</style>
</head>
<body>
<div class="container py-5">
        <div class="row mb-4">
            <div class="col-12 text-center">
                <h1 class="display-4 title-animation mb-3" >Advanced Array Visualizer</h1>
                <p class="lead">Create, Read, Update, Delete, and Search array elements with stunning animations</p>
            </div>
        </div>
         <!-- Add this after the title section and before the main content row -->
        <div class="row mb-4">
            <div class="col-12 text-center">
                <a href="Array_intro.html" class="btn btn-glow">
                    <i class="fas fa-home me-2"></i>Back to Home
                </a>
            </div>
        </div>
       
        <div class="row">
            <div class="col-md-8">
                <div class="glass-card">
                    <div class="array-container" id="arrayContainer">
                        <!-- Array elements will be dynamically inserted here -->
                        <div class="array-empty-state">
                            <i class="fas fa-layer-group"></i>
                            <h4>Array is Empty</h4>
                            <p>Add some elements to get started!</p>
                        </div>
                    </div>
                </div>
                
                <div class="row mt-4">
                    <div class="col-md-3">
                        <div class="stats-card">
                            <div>Array Length</div>
                            <div class="stats-value" id="arrayLength">0</div>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="stats-card">
                            <div>First Element</div>
                            <div class="stats-value" id="firstElement">-</div>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="stats-card">
                            <div>Last Element</div>
                            <div class="stats-value" id="lastElement">-</div>
                        </div>
                    </div>
                    <div class="col-md-2">
                        <div class="stats-card">
                            <div>Sum of Elements</div>
                            <div class="stats-value" id="sumElements">0</div>
                        </div>
                    </div>
                    <div class="col-md-2">
                        <div class="stats-card">
                            <div>Product of Elements</div>
                            <div class="stats-value" id="productElements">1</div>
                        </div>
                    </div>
<div class="col-md-3">
    <div class="stats-card">
        <div>Mode <small class="text-muted">(Most Frequent)</small></div>
        <div class="stats-value" id="modeElements">-</div>
        <small class="text-muted" id="modeFrequency" style="font-size: 0.7rem;"></small>
    </div>
</div>

                    <div class="col-md-3">
                        <div class="stats-card">
                            <div>Total Operations</div>
                            <div class="stats-value" id="totalOperations">0</div>
                        </div>
                    </div>
                    <div class="col-md-3">
    <div class="stats-card">
        <div>Memory Address</div>
        <div class="stats-value" id="memoryAddress">-</div>
    </div>
</div>
                </div>
            </div>
            
            <div class="col-md-4">
                <div class="glass-card">
                    <h4 class="mb-4">Array Operations</h4>
                    
                    <ul class="nav nav-tabs" id="operationTabs" role="tablist">
                        <li class="nav-item" role="presentation">
                            <button class="nav-link active" id="create-tab" data-bs-toggle="tab" data-bs-target="#create" type="button" role="tab">Create</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="read-tab" data-bs-toggle="tab" data-bs-target="#read" type="button" role="tab">Read</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="update-tab" data-bs-toggle="tab" data-bs-target="#update" type="button" role="tab">Update</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="delete-tab" data-bs-toggle="tab" data-bs-target="#delete" type="button" role="tab">Delete</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="search-tab" data-bs-toggle="tab" data-bs-target="#search" type="button" role="tab">Search</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="advanced-tab" data-bs-toggle="tab" data-bs-target="#advanced" type="button" role="tab">Advanced Basic Operations</button>
                        </li>
                        <li class="nav-item" role="presentation">
                              <button class="nav-link" id="stockmarket-tab" data-bs-toggle="tab" data-bs-target="#stockmarket" type="button" role="tab">Stock Market Operations</button>
                        </li>
                        <li class="nav-item" role="presentation">
                           <button class="nav-link" id="set-tab" data-bs-toggle="tab" data-bs-target="#set" type="button" role="tab">Set Operations</button>
                        </li>
                         <li class="nav-item" role="presentation">
                            <button class="nav-link" id="leetcode-tab" data-bs-toggle="tab" data-bs-target="#leetcode" type="button" role="tab">Leetcode Problems</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="leetcode2-tab" data-bs-toggle="tab" data-bs-target="#leetcode2" type="button" role="tab">LeetcodeProblems-II</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="advanced-sorting-tab" data-bs-toggle="tab" data-bs-target="#advanced-sorting" type="button" role="tab">Advanced Sorting</button>
                        </li>
                    </ul>
                    
                    <div class="tab-content" id="operationTabsContent">
                        <!-- Create Tab -->
                        <div class="tab-pane fade show active" id="create" role="tabpanel">
                            <div class="mb-3">
                                <label class="form-label">Create (Push)</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="createValue" placeholder="Enter value">
                                    <button class="btn btn-glow" id="createBtn">
                                        <i class="fas fa-plus-circle me-2"></i>Add
                                    </button>
                                </div>
                                <div class="d-grid gap-2">
                                    <button class="btn btn-outline-light" id="createRandomBtn">
                                        <i class="fas fa-dice me-2"></i>Add Random
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Create Array from Range</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="arraySize" placeholder="Size (n)" min="1" max="50">
                                    <button class="btn btn-glow" id="createArrayFromRangeBtn">
                                        <i class="fas fa-layer-group me-2"></i>Create Array 0 to n-1
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Resize Array</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="resizeSize" placeholder="New size" min="1" max="100">
                                    <button class="btn btn-glow" id="resizeArrayBtn">
                                        <i class="fas fa-expand-alt me-2"></i>Resize
                                    </button>
                                </div>
                                <small class="text-muted">Extends array while preserving existing elements</small>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Clone Array Operation</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="cloneIndex" placeholder="Index (0 to n-1)" min="0">
                                    <input type="text" class="form-control" id="cloneElementValue" placeholder="New element value">
                                    <button class="btn btn-glow" id="cloneArrayBtn">
                                        <i class="fas fa-copy me-2"></i>Clone & Modify
                                    </button>
                                </div>
                                <small class="text-muted">Demonstrates cloning by modifying a copy without affecting original</small>
                            </div>
 <!-- Add this in the Create Tab after Clone Array Operation section -->
<div class="mb-3">
    <label class="form-label">Shallow Copy Operation</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="shallowCopyCount" placeholder="Number of objects to modify (1 to n)" min="1">
        <button class="btn btn-glow" id="shallowCopyBtn">
            <i class="fas fa-copy me-2"></i>Shallow Copy & Modify
        </button>
    </div>
    <small class="text-muted">Demonstrates shallow copy by modifying objects that affect both arrays</small>
</div>

<!-- Shallow Copy Input Group (initially hidden) -->
<div class="mb-3" id="shallowCopyInputGroup" style="display: none;">
    <label class="form-label">Enter Modification Details</label>
    <div id="shallowCopyInputs" class="mt-2"></div>
    <div class="d-grid gap-2 mt-2">
        <button class="btn btn-glow" id="confirmShallowCopyBtn">
            <i class="fas fa-play me-2"></i>Perform Shallow Copy Operation
        </button>
        <button class="btn btn-outline-light" id="cancelShallowCopyBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>
<!-- Add this in the Create Tab after Clone Array Operation section -->
<div class="mb-3">
    <label class="form-label">Scalar Operations</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="scalarValue" placeholder="Enter scalar value">
        <button class="btn btn-glow" id="addScalarBtn">
            <i class="fas fa-plus me-2"></i>Add Scalar
        </button>
    </div>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="scalarValueSubtract" placeholder="Enter scalar value">
        <button class="btn btn-glow" id="subtractScalarBtn">
            <i class="fas fa-minus me-2"></i>Subtract Scalar
        </button>
    </div>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="scalarValueMultiply" placeholder="Enter scalar value">
        <button class="btn btn-glow" id="multiplyScalarBtn">
            <i class="fas fa-times me-2"></i>Multiply by Scalar
        </button>
    </div>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="scalarValueDivide" placeholder="Enter scalar value">
        <button class="btn btn-glow" id="divideScalarBtn">
            <i class="fas fa-divide me-2"></i>Divide by Scalar
        </button>
    </div>
    <small class="text-muted">Apply mathematical operations to every element in the array</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Element-wise Array Operations</label>
    <div class="d-grid gap-2">
        <button class="btn btn-glow" id="addArraysElementWiseBtn">
            <i class="fas fa-plus-circle me-2"></i>Add Two Arrays Element-wise
        </button>
        <button class="btn btn-glow" id="subtractArraysElementWiseBtn">
            <i class="fas fa-minus-circle me-2"></i>Subtract Two Arrays Element-wise
        </button>
        <button class="btn btn-glow" id="multiplyArraysElementWiseBtn">
            <i class="fas fa-times-circle me-2"></i>Multiply Arrays Element-wise (Hadamard)
        </button>
        <button class="btn btn-glow" id="divideArraysElementWiseBtn">
            <i class="fas fa-divide me-2"></i>Divide Arrays Element-wise
        </button>
        <button class="btn btn-glow" id="modulusArraysElementWiseBtn">
            <i class="fas fa-percentage me-2"></i>Calculate Modulus Element-wise
        </button>
    </div>
</div>

<!-- Element-wise Operation Input Group (initially hidden) -->
<div class="mb-3" id="elementWiseOperationGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">First Array Details</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="elementWiseFirstArraySize" placeholder="Size of first array" min="1" max="20">
            <button class="btn btn-glow" id="confirmElementWiseFirstArraySizeBtn">
                <i class="fas fa-check me-2"></i>Set First Array Size
            </button>
        </div>
        <div id="elementWiseFirstArrayInputs" class="mt-2"></div>
    </div>

    <div class="mb-3">
        <label class="form-label">Second Array Details</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="elementWiseSecondArraySize" placeholder="Size of second array" min="1" max="20">
            <button class="btn btn-glow" id="confirmElementWiseSecondArraySizeBtn">
                <i class="fas fa-check me-2"></i>Set Second Array Size
            </button>
        </div>
        <div id="elementWiseSecondArrayInputs" class="mt-2"></div>
    </div>

    <div class="d-grid gap-2">
        <button class="btn btn-glow" id="performElementWiseOperationBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Perform Operation
        </button>
        <button class="btn btn-outline-light" id="cancelElementWiseOperationBtn">
            <i class="fas fa-times me-2"></i>Cancel Operation
        </button>
    </div>
</div>
<!-- Add this in the Create Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Insert Sorted (Maintain Order)</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="insertSortedBtn">
            <i class="fas fa-sort-amount-up me-2"></i>Insert Sorted (Maintain Order)
        </button>
    </div>
</div>
<!-- Add this in the Create Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">String to Char Array Conversion</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="convertToCharArrayBtn">
            <i class="fas fa-text-width me-2"></i>Convert String to Char Array
        </button>
    </div>
</div>
<!-- Add this in the Create Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Array Reshaping</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="convertTo2DBtn">
            <i class="fas fa-th me-2"></i>Convert 1D to 2D Array
        </button>
    </div>
    <small class="text-muted">Automatically reshapes 1D array to optimal 2D matrix</small>
</div>
<!-- String Input Group (initially hidden) -->
<div class="mb-3" id="stringInputGroup" style="display: none;">
    <label class="form-label">Enter a String</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="inputString" placeholder="Enter any string (e.g., Hello World)">
        <button class="btn btn-glow" id="confirmStringBtn">
            <i class="fas fa-play me-2"></i>Convert to Char Array
        </button>
        <button class="btn btn-outline-light" id="cancelStringBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>

<!-- Add this in the Create Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Generate Random Array</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="randomArraySize" placeholder="Enter size ( 1)" min="1" max="100">
        <button class="btn btn-glow" id="generateRandomArrayBtn">
            <i class="fas fa-random me-2"></i>Generate Random Array
        </button>
    </div>
    <small class="text-muted">Creates array with random positive and negative numbers</small>
</div>
<!-- Insert Sorted Input Group (initially hidden) -->
<div class="mb-3" id="insertSortedGroup" style="display: none;">
    <label class="form-label">Insert Sorted Operation</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="insertSortedCount" 
               placeholder="How many elements to add?" min="1" max="10">
        <button class="btn btn-glow" id="confirmInsertSortedCountBtn">
            <i class="fas fa-check me-2"></i>Confirm Count
        </button>
    </div>
    <div id="insertSortedInputs" class="mt-2"></div>
    
    <div class="d-grid gap-2 mt-3">
        <button class="btn btn-glow" id="performInsertSortedBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Perform Insert Sorted Operation
        </button>
        <button class="btn btn-outline-light" id="cancelInsertSortedBtn">
            <i class="fas fa-times me-2"></i>Cancel Operation
        </button>
    </div>
</div>
                            <div class="mb-3">
                                <label class="form-label">Find Pivot in Rotated Array</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="findPivotBtn">
                                        <i class="fas fa-search me-2"></i>Find Pivot (Smallest in Rotated Array)
                                    </button>
                                </div>
                                <small class="text-muted">Automatically rotates array if needed, then finds smallest element</small>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Mathematical Progressions</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="createAPBtn">
                                        <i class="fas fa-calculator me-2"></i>Create Arithmetic Progression (A.P.)
                                    </button>
                                    <button class="btn btn-glow" id="createGPBtn">
                                        <i class="fas fa-chart-line me-2"></i>Create Geometric Progression (G.P.)
                                    </button>
                                </div>
                            </div>
                            
                            <!-- AP Input Group (initially hidden) -->
                            <div class="mb-3" id="apInputGroup" style="display: none;">
                                <label class="form-label">Arithmetic Progression Parameters</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="apFirstTerm" placeholder="First term (a)" min="0">
                                    <input type="number" class="form-control" id="apCommonDiff" placeholder="Common difference (d)">
                                    <input type="number" class="form-control" id="apNumTerms" placeholder="Number of terms (n)" min="1" max="50">
                                    <button class="btn btn-glow" id="confirmAPBtn">
                                        <i class="fas fa-play me-2"></i>Generate A.P.
                                    </button>
                                </div>
                                <small class="text-muted">Formula: a, a+d, a+2d, ..., a+(n-1)d</small>
                            </div>
                            
                            <!-- GP Input Group (initially hidden) -->
                            <div class="mb-3" id="gpInputGroup" style="display: none;">
                                <label class="form-label">Geometric Progression Parameters</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="gpFirstTerm" placeholder="First term (a)" min="1">
                                    <input type="number" class="form-control" id="gpCommonRatio" placeholder="Common ratio (r)">
                                    <input type="number" class="form-control" id="gpNumTerms" placeholder="Number of terms (n)" min="1" max="50">
                                    <button class="btn btn-glow" id="confirmGPBtn">
                                        <i class="fas fa-play me-2"></i>Generate G.P.
                                    </button>
                                </div>
                                <small class="text-muted">Formula: a, ar, ar, ..., ar</small>
                            </div>
                            
                            <!-- Cancel Button for Progressions -->
                            <div class="mb-3" id="cancelProgressionGroup" style="display: none;">
                                <button class="btn btn-outline-light w-100" id="cancelProgressionBtn">
                                    <i class="fas fa-times me-2"></i>Cancel Progression Operation
                                </button>
                            </div>
                           <!-- Add this after the existing rotation buttons -->
<div class="mb-3">
    <label class="form-label">Cyclic Shift Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="cyclicShiftLeftBtn">
            <i class="fas fa-undo-alt me-2"></i>Cyclic Shift Left
        </button>
        <button class="btn btn-glow" id="cyclicShiftRightBtn">
            <i class="fas fa-redo-alt me-2"></i>Cyclic Shift Right
        </button>
    </div>
    
    <div class="input-group mb-2" id="cyclicShiftInputGroup" style="display: none;">
        <input type="number" class="form-control" id="cyclicShiftPositions" placeholder="Enter positions (1 to n)" min="1">
        <button class="btn btn-glow" id="confirmCyclicShiftBtn">
            <i class="fas fa-play me-2"></i>Apply Cyclic Shift
        </button>
        <button class="btn btn-outline-light" id="cancelCyclicShiftBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>
                            <div class="mb-3">
                                <label class="form-label">Stable Sorting</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="stableSortBtn">
                                        <i class="fas fa-sort-amount-up-alt me-2"></i>Stable Sort (Bubble Sort)
                                    </button>
                                </div>
                            </div>
                            <div class="mb-3">
    <label class="form-label">In-Place Merge Sort</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="inPlaceMergeSortBtn">
            <i class="fas fa-sort-amount-up-alt me-2"></i>In-Place Merge Sort
        </button>
    </div>
    <small class="text-muted">Sorts the array using in-place merge sort algorithm with detailed visualization</small>
</div>
<!-- Add this after the Special Sorting Operations section -->
<div class="mb-3">
    <label class="form-label">Pancake Sorting (Prefix Flips)</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="pancakeSortBtn">
            <i class="fas fa-utensils me-2"></i>Pancake Sorting
        </button>
    </div>
    <small class="text-muted">Sort array using only prefix flips (reverse from index 0 to k)</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Wiggle Sort II</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="wiggleSortIIBtn">
            <i class="fas fa-random me-2"></i>Wiggle Sort II
        </button>
    </div>
    <small class="text-muted">Sort array such that nums[0] < nums[1] > nums[2] < nums[3]...</small>
</div>
                            <div class="mb-3">
                                <label class="form-label">Merge Two Sorted Arrays</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="mergeSortedArraysBtn">
                                        <i class="fas fa-object-group me-2"></i>Merge Two Sorted Arrays
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Merge Arrays Input Groups (initially hidden) -->
                            <div class="mb-3" id="mergeArraysGroup" style="display: none;">
                                <div class="mb-3">
                                    <label class="form-label">First Array Details</label>
                                    <div class="input-group mb-2">
                                        <input type="number" class="form-control" id="firstArraySize" placeholder="Size of first array" min="1" max="20">
                                        <button class="btn btn-glow" id="confirmFirstArraySizeBtn">
                                            <i class="fas fa-check me-2"></i>Set First Array Size
                                        </button>
                                    </div>
                                    <div id="firstArrayInputs" class="mt-2"></div>
                                </div>
                                
                                <div class="mb-3">
                                    <label class="form-label">Second Array Details</label>
                                    <div class="input-group mb-2">
                                        <input type="number" class="form-control" id="secondArraySize" placeholder="Size of second array" min="1" max="20">
                                        <button class="btn btn-glow" id="confirmSecondArraySizeBtn">
                                            <i class="fas fa-check me-2"></i>Set Second Array Size
                                        </button>
                                    </div>
                                    <div id="secondArrayInputs" class="mt-2"></div>
                                </div>
                                
                                <div class="d-grid gap-2">
                                    <button class="btn btn-glow" id="performMergeBtn" style="display: none;">
                                        <i class="fas fa-play me-2"></i>Perform Merge Operation
                                    </button>
                                    <button class="btn btn-outline-light" id="cancelMergeBtn">
                                        <i class="fas fa-times me-2"></i>Cancel Merge Operation
                                    </button>
                                </div>
                            </div>
                            <!-- Add this in the Create Tab after the Array Sorting section -->
<div class="mb-3">
    <label class="form-label">Special Sorting Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="sortEvenBeforeOddBtn">
            <i class="fas fa-sort-numeric-up-alt me-2"></i>Sort Even Before Odd
        </button>
        <button class="btn btn-glow" id="sortByAbsoluteValueBtn">
            <i class="fas fa-sort-amount-up me-2"></i>Sort by Absolute Value
        </button>
    </div>
</div>

                            <div class="mb-3">
                                <label class="form-label">Array Reversal & Rotation</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="reverseArrayBtn">
                                        <i class="fas fa-exchange-alt me-2"></i>Reverse Array
                                    </button>
                                    <button class="btn btn-glow" id="rotateLeftBtn">
                                        <i class="fas fa-undo me-2"></i>Rotate Left
                                    </button>
                                    <button class="btn btn-glow" id="rotateRightBtn">
                                        <i class="fas fa-redo me-2"></i>Rotate Right
                                    </button>
                                </div>
                                
                                <div class="input-group mb-2" id="rotateInputGroup" style="display: none;">
                                    <input type="number" class="form-control" id="rotatePositions" placeholder="Enter positions (1 to n)" min="1">
                                    <button class="btn btn-glow" id="confirmRotateBtn">
                                        <i class="fas fa-play me-2"></i>Apply Rotation
                                    </button>
                                    <button class="btn btn-outline-light" id="cancelRotateBtn">
                                        <i class="fas fa-times me-2"></i>Cancel
                                    </button>
                                </div>
                            </div>
                            <!-- Add this in the Create Tab after Array Reversal & Rotation section -->
<div class="mb-3">
    <label class="form-label">Array Shuffling</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="shuffleElementsBtn">
            <i class="fas fa-random me-2"></i>Shuffle Elements (Fisher-Yates)
        </button>
    </div>
</div>
                            <div class="mb-3">
                                <label class="form-label">Array Validation & Partial Sort</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="checkSortedBtn">
                                        <i class="fas fa-check-circle me-2"></i>Check if Array is Sorted
                                    </button>
                                    <button class="btn btn-glow" id="partialSortBtn">
                                        <i class="fas fa-sort-amount-up me-2"></i>Partial Sort (Top K)
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Add this input group for partial sort (initially hidden) -->
                            <div class="mb-3" id="partialSortInputGroup" style="display: none;">
                                <label class="form-label">Partial Sort - Enter Number of Elements</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="partialSortCount" 
                                           placeholder="Enter K (1 to array length)" min="1">
                                    <button class="btn btn-glow" id="confirmPartialSortBtn">
                                        <i class="fas fa-play me-2"></i>Sort First K Elements
                                    </button>
                                    <button class="btn btn-outline-light" id="cancelPartialSortBtn">
                                        <i class="fas fa-times me-2"></i>Cancel
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Array Sorting</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="sortAscBtn">
                                        <i class="fas fa-sort-amount-up me-2"></i>Sort Ascending
                                    </button>
                                    <button class="btn btn-glow" id="sortDescBtn">
                                        <i class="fas fa-sort-amount-down me-2"></i>Sort Descending
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Sort Subarray</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="sortSubarrayStart" placeholder="Start index" min="0">
                                    <input type="number" class="form-control" id="sortSubarrayEnd" placeholder="End index" min="0">
                                    <button class="btn btn-glow" id="sortSubarrayBtn">
                                        <i class="fas fa-sort me-2"></i>Sort Subarray
                                    </button>
                                </div>
                                <small class="text-muted">Sorts only the specified subarray range</small>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Fill Array Operations</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="fillValue" placeholder="Value to fill">
                                    <input type="number" class="form-control" id="fillStart" placeholder="Start index (optional)">
                                    <input type="number" class="form-control" id="fillEnd" placeholder="End index (optional)">
                                    <button class="btn btn-glow" id="fillArrayBtn">
                                        <i class="fas fa-fill me-2"></i>Fill Array
                                    </button>
                                </div>
                                <small class="text-muted">Leave indices empty to fill entire array</small>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Swap Elements</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="swapByValuesBtn">
                                        <i class="fas fa-exchange-alt me-2"></i>Swap by Values
                                    </button>
                                    <button class="btn btn-glow" id="swapByIndicesBtn">
                                        <i class="fas fa-sync-alt me-2"></i>Swap by Indices
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Swap Input Groups (initially hidden) -->
                            <div class="mb-3" id="swapByValuesGroup" style="display: none;">
                                <label class="form-label">Swap Elements by Values</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="swapCount" placeholder="Number of elements to swap" min="2">
                                    <button class="btn btn-glow" id="confirmSwapCountBtn">
                                        <i class="fas fa-check me-2"></i>Confirm
                                    </button>
                                </div>
                                <div id="swapValuesInputs" class="mt-2"></div>
                            </div>
                            
                            <div class="mb-3" id="swapByIndicesGroup" style="display: none;">
                                <label class="form-label">Swap Elements by Indices</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="swapIndicesCount" placeholder="Number of indices to swap" min="2">
                                    <button class="btn btn-glow" id="confirmSwapIndicesCountBtn">
                                        <i class="fas fa-check me-2"></i>Confirm
                                    </button>
                                </div>
                                <div id="swapIndicesInputs" class="mt-2"></div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Create Subarray (Slice)</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="sliceStart" placeholder="Start index" min="0">
                                    <input type="number" class="form-control" id="sliceEnd" placeholder="End index">
                                    <button class="btn btn-glow" id="sliceBtn">
                                        <i class="fas fa-cut me-2"></i>Create Subarray
                                    </button>
                                </div>
                                <button class="btn btn-outline-light w-100" id="resetArrayBtn">
                                    <i class="fas fa-undo me-2"></i>Reset to Original Array
                                </button>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Generate All Subarrays</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="subarrayInput" placeholder="e.g., 3,5,44,56">
                                    <button class="btn btn-glow" id="countSubarraysBtn">
                                        <i class="fas fa-calculator me-2"></i>Count Subarrays
                                    </button>
                                </div>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow w-100" id="generateSubarraysBtn">
                                        <i class="fas fa-list me-2"></i>Generate All Subarrays
                                    </button>
                                </div>
                            </div>
                            
                            <div class="subarrays-results" id="subarraysResults" style="display: none;">
                                <h6>Subarrays Results</h6>
                                <div class="stats-card">
                                    <div>Total Subarrays</div>
                                    <div class="stats-value" id="subarrayCount">0</div>
                                </div>
                                <div id="subarraysList" class="mt-3"></div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Insert At Index</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="insertIndex" placeholder="Index" min="0">
                                    <input type="text" class="form-control" id="insertValue" placeholder="Value">
                                    <button class="btn btn-glow" id="insertBtn">
                                        <i class="fas fa-plus me-2"></i>Insert
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Array Transformations</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="cumulativeSumBtn">
                                        <i class="fas fa-chart-line me-2"></i>Cumulative Sum Array
                                    </button>
                                    <button class="btn btn-glow" id="prefixSumBtn">
                                        <i class="fas fa-layer-group me-2"></i>Prefix Sum Array
                                    </button>
                                    <button class="btn btn-glow" id="prefixXorBtn">
                                <i class="fas fa-calculator me-2"></i>Prefix XOR Array
                                 </button>
                                </div>
                                <div class="input-group mb-2">
                                    <button class="btn btn-outline-light" id="resetTransformationBtn" style="display: none;">
                                        <i class="fas fa-undo me-2"></i>Reset to Original Array
                                    </button>
                                </div>
                            </div>
                            <!-- Add this in the Create Tab after Array Transformations section -->
<div class="mb-3">
    <label class="form-label">Mathematical Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="calculateExponentialBtn">
            <i class="fas fa-calculator me-2"></i>Calculate Exponential
        </button>
        <button class="btn btn-glow" id="calculateNaturalLogBtn">
            <i class="fas fa-function me-2"></i>Calculate Natural Log
        </button>
        <button class="btn btn-glow" id="calculateLog10Btn">
            <i class="fas fa-superscript me-2"></i>Calculate Base-10 Log
        </button>
    </div>
    <small class="text-muted">Apply mathematical functions to all array elements</small>
</div>
                            <div class="mb-3">
    <label class="form-label">Trigonometric Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="calcSinBtn">
            <i class="fas fa-wave-square me-2"></i>Calculate Sine of Elements
        </button>
        <button class="btn btn-glow" id="calcCosBtn">
            <i class="fas fa-wave-circle me-2"></i>Calculate Cosine of Elements
        </button>
        <button class="btn btn-glow" id="calcTanBtn">
            <i class="fas fa-chart-line me-2"></i>Calculate Tangent of Elements
        </button>
    </div>
    <small class="text-muted">Calculates trigonometric functions for each element (in radians)</small>
</div>
                        </div>
                        <!-- Add this in the Create Tab after the Array Transformations section -->
                        <!-- Read Tab -->
                        <div class="tab-pane fade" id="read" role="tabpanel">
                            <div class="mb-3">
                                <label class="form-label">Read by Index</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="readIndex" placeholder="Enter index" min="0">
                                    <button class="btn btn-glow" id="readBtn">
                                        <i class="fas fa-eye me-2"></i>Read
                                    </button>
                                </div>
                            </div>
                            <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Data Type Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="getDataTypeBtn">
            <i class="fas fa-code me-2"></i>Get Data Type of Array
        </button>
        <button class="btn btn-glow" id="createTypedArrayBtn">
            <i class="fas fa-layer-group me-2"></i>Create Array with Specific Data Type
        </button>
        <button class="btn btn-glow" id="convertToListBtn">
            <i class="fas fa-list me-2"></i>Convert Array to List
        </button>
    </div>
</div>

<!-- Data Type Input Group (initially hidden) -->
<div class="mb-3" id="dataTypeInputGroup" style="display: none;">
    <label class="form-label">Create Array with Specific Data Type</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="typedArraySize" placeholder="Enter array size" min="1" max="50">
        <select class="form-control" id="dataTypeSelect">
            <option value="">Choose Data Type</option>
            <option value="integer">Integer</option>
            <option value="float">Float</option>
            <option value="string">String</option>
            <option value="char">Character</option>
            <option value="boolean">Boolean</option>
        </select>
        <button class="btn btn-glow" id="confirmDataTypeBtn">
            <i class="fas fa-check me-2"></i>Create Array
        </button>
        <button class="btn btn-outline-light" id="cancelDataTypeBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>
                            <div class="mb-3">
                                <label class="form-label">Array Traversal</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="traverseForwardBtn">
                                        <i class="fas fa-forward me-2"></i>Traverse Array (Forward)
                                    </button>
                                    <button class="btn btn-glow" id="traverseBackwardBtn">
                                        <i class="fas fa-backward me-2"></i>Traverse Array (Backward)
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Two-Pointer Traversal</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="twoPointerTraverseBtn">
                                        <i class="fas fa-arrows-alt-h me-2"></i>Two-Pointer Traversal
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Update Tab -->
                        <div class="tab-pane fade" id="update" role="tabpanel">
                            <div class="mb-3">
                                <label class="form-label">Update by Index</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="updateIndex" placeholder="Index" min="0">
                                    <input type="text" class="form-control" id="updateValue" placeholder="New value">
                                    <button class="btn btn-glow" id="updateBtn">
                                        <i class="fas fa-edit me-2"></i>Update
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Update by Element</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="updateElement" placeholder="Element to update">
                                    <input type="text" class="form-control" id="updateNewValue" placeholder="New value">
                                    <button class="btn btn-glow" id="updateByElementBtn">
                                        <i class="fas fa-edit me-2"></i>Update
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Delete Tab -->
                        <div class="tab-pane fade" id="delete" role="tabpanel">
                            <div class="mb-3">
                                <label class="form-label">Delete by Index</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="deleteIndex" placeholder="Enter index" min="0">
                                    <button class="btn btn-glow" id="deleteBtn">
                                        <i class="fas fa-trash me-2"></i>Delete
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Delete by Element</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="deleteElement" placeholder="Element to delete">
                                    <button class="btn btn-glow" id="deleteByElementBtn">
                                        <i class="fas fa-trash me-2"></i>Delete
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Advanced Delete Operations</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="deleteFirstOccurrence" placeholder="Element to delete first occurrence">
                                    <button class="btn btn-glow" id="deleteFirstOccurrenceBtn">
                                        <i class="fas fa-backspace me-2"></i>Delete First Occurrence
                                    </button>
                                </div>
                                
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="deleteAllOccurrences" placeholder="Element to delete all occurrences">
                                    <button class="btn btn-glow" id="deleteAllOccurrencesBtn">
                                        <i class="fas fa-eraser me-2"></i>Delete All Occurrences
                                    </button>
                                </div>
                                
                                <div class="d-grid gap-2">
                                    <button class="btn btn-glow" id="removeDuplicatesInPlaceBtn">
                                        <i class="fas fa-filter me-2"></i>Remove Duplicates (In-Place)
                                    </button>
                                    <button class="btn btn-glow" id="removeDuplicatesKeepOneBtn">
                                        <i class="fas fa-copy me-2"></i>Remove Duplicates (Keep One)
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Shift Left After Deletion</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="shiftDeleteIndex" placeholder="Index to delete" min="0">
                                    <button class="btn btn-glow" id="shiftLeftAfterDeleteBtn">
                                        <i class="fas fa-trash-arrow-left me-2"></i>Delete & Shift Left
                                    </button>
                                </div>
                                <small class="text-muted">Delete element and shift all subsequent elements left</small>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Shift Operations</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="shiftLeftBtn">
                                        <i class="fas fa-arrow-left me-2"></i>Shift Left
                                    </button>
                                    <button class="btn btn-glow" id="shiftRightBtn">
                                        <i class="fas fa-arrow-right me-2"></i>Shift Right
                                    </button>
                                    <button class="btn btn-outline-light" id="resetShiftBtn">
                                        <i class="fas fa-undo me-2"></i>Reset Shift
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Pop Operation</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="popLastBtn">
                                        <i class="fas fa-minus-circle me-2"></i>Pop Last Element
                                    </button>
                                </div>
                            </div>
                            <!-- Add this in the Delete Tab after the Pop Last Element section -->
<div class="mb-3">
    <label class="form-label">Advanced Pop Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="popFirstBtn">
            <i class="fas fa-minus-circle me-2"></i>Pop First Element
        </button>
        <button class="btn btn-glow" id="shiftRightInsertBtn">
            <i class="fas fa-arrow-right me-2"></i>Shift Right for Insertion
        </button>
    </div>
</div>

<!-- Add this input group for shift right insertion (initially hidden) -->
<div class="mb-3" id="shiftRightInsertGroup" style="display: none;">
    <label class="form-label">Shift Right for Insertion</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="insertShiftIndex" placeholder="Index to insert at" min="0">
        <input type="text" class="form-control" id="insertShiftValue" placeholder="Value to insert">
        <button class="btn btn-glow" id="confirmShiftInsertBtn">
            <i class="fas fa-play me-2"></i>Perform Insertion
        </button>
        <button class="btn btn-glow" id="cancelShiftInsertBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>
                            <div class="d-grid gap-2">
                                <button class="btn btn-glow" id="clearArrayBtn">
                                    <i class="fas fa-broom me-2"></i>Clear Array
                                </button>
                            </div>
                        </div>
                        
                        <!-- Search Tab -->
                        <div class="tab-pane fade" id="search" role="tabpanel">
                            <div class="mb-3">
                                <label class="form-label">Search by Element</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="searchElement" placeholder="Element to search">
                                    <button class="btn btn-glow" id="searchBtn">
                                        <i class="fas fa-search me-2"></i>Search
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Search by Index</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="searchIndex" placeholder="Index to search" min="0">
                                    <button class="btn btn-glow" id="searchByIndexBtn">
                                        <i class="fas fa-search me-2"></i>Search
                                    </button>
                                </div>
                            </div>
                             <!-- Add this in the Search Tab after the Element Analysis section -->
<div class="mb-3">
    <label class="form-label">Find Elements by Comparison</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="comparisonValue" placeholder="Enter x value">
        <button class="btn btn-glow" id="findFirstGreaterBtn">
            <i class="fas fa-arrow-right me-2"></i>Find First Element > x
        </button>
    </div>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="comparisonValueLess" placeholder="Enter x value">
        <button class="btn btn-glow" id="findLastLessBtn">
            <i class="fas fa-arrow-left me-2"></i>Find Last Element < x
        </button>
    </div>
</div>
<!-- Add this in the Search Tab after the Element Analysis section -->
<div class="mb-3">
    <label class="form-label">Range Analysis</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="findRangeBtn">
            <i class="fas fa-ruler me-2"></i>Find Range (Max - Min)
        </button>
    </div>
</div>
<!-- Add this in the Search Tab after Element Analysis section -->
<div class="mb-3">
    <label class="form-label">Statistical Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="findMeanBtn">
            <i class="fas fa-calculator me-2"></i>Find Mean (Average)
        </button>
        <button class="btn btn-glow" id="findMedianBtn">
            <i class="fas fa-sort-amount-up me-2"></i>Find Median
        </button>
    </div>
</div>
                            <div class="mb-3">
                                <label class="form-label">Kth Element Operations</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="kthElementInput" placeholder="Enter k (1 to n)" min="1">
                                    <button class="btn btn-glow" id="kthSmallestBtn">
                                        <i class="fas fa-sort-amount-down me-2"></i>Kth Smallest (Sorted)
                                    </button>
                                    <button class="btn btn-glow" id="kthLargestBtn">
                                        <i class="fas fa-sort-amount-up me-2"></i>Kth Largest (Unsorted)
                                    </button>
                                </div>
                                <small class="text-muted">Find kth smallest element in sorted array or kth largest in unsorted array</small>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Find Subarrays with Given Sum</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="subarraySumInput" placeholder="Enter target sum">
                                    <button class="btn btn-glow" id="findSubarraySumBtn">
                                        <i class="fas fa-calculator me-2"></i>Find Subarrays
                                    </button>
                                </div>
                                <div class="input-group mb-2">
                                    <button class="btn btn-outline-light w-100" id="generateAllSubarraysWithSumBtn">
                                        <i class="fas fa-list me-2"></i>Generate All Subarrays with Sum
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Linear Search (Step-by-Step)</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="linearSearchElement" placeholder="Element to search">
                                    <button class="btn btn-glow" id="linearSearchBtn">
                                        <i class="fas fa-search me-2"></i>Linear Search
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Binary Search (Sorted Array Required)</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="binarySearchElement" placeholder="Element to search">
                                    <button class="btn btn-glow" id="binarySearchBtn">
                                        <i class="fas fa-search me-2"></i>Binary Search
                                    </button>
                                </div>
                                <small class="text-muted">Array will be automatically sorted if needed</small>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Search in Rotated Sorted Array</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="rotatedSearchElement" placeholder="Element to search">
                                    <button class="btn btn-glow" id="rotatedSearchBtn">
                                        <i class="fas fa-search me-2"></i>Search in Rotated Array
                                    </button>
                                </div>
                                <small class="text-muted">Array will be automatically rotated and sorted if needed</small>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Find Occurrences</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="occurrenceElement" placeholder="Element to find">
                                    <button class="btn btn-glow" id="findFirstOccurrenceBtn">
                                        <i class="fas fa-search me-2"></i>First Occurrence
                                    </button>
                                </div>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="occurrenceElementLast" placeholder="Element to find" value="">
                                    <button class="btn btn-glow" id="findLastOccurrenceBtn">
                                        <i class="fas fa-search me-2"></i>Last Occurrence
                                    </button>
                                </div>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="occurrenceElementAll" placeholder="Element to find" value="">
                                    <button class="btn btn-glow" id="findAllOccurrencesBtn">
                                        <i class="fas fa-list me-2"></i>All Occurrences
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Element Analysis</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="checkElement" placeholder="Element to check">
                                    <button class="btn btn-glow" id="checkElementBtn">
                                        <i class="fas fa-check-circle me-2"></i>Check Existence
                                    </button>
                                </div>
                                <div class="d-grid gap-2">
                                    <button class="btn btn-glow" id="findMinElementBtn">
                                        <i class="fas fa-arrow-down me-2"></i>Find Minimum Element
                                    </button>
                                    <button class="btn btn-glow" id="findMaxElementBtn">
                                        <i class="fas fa-arrow-up me-2"></i>Find Maximum Element
                                    </button>
                                </div>
                            </div>
                            <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Statistical Analysis Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="findMinIndexBtn">
            <i class="fas fa-arrow-down me-2"></i>Find Index of Minimum Value
        </button>
        <button class="btn btn-glow" id="findMaxIndexBtn">
            <i class="fas fa-arrow-up me-2"></i>Find Index of Maximum Value
        </button>
    </div>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="findNSmallestBtn">
            <i class="fas fa-sort-amount-down me-2"></i>Find N Smallest Values
        </button>
        <button class="btn btn-glow" id="findNLargestBtn">
            <i class="fas fa-sort-amount-up me-2"></i>Find N Largest Values
        </button>
    </div>
    
    <!-- Input group for N value (initially hidden) -->
    <div class="mb-3" id="nValueInputGroup" style="display: none;">
        <label class="form-label">Enter N Value</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="nValueInput" 
                   placeholder="Enter N (1 to array length)" min="1">
            <button class="btn btn-glow" id="confirmNValueBtn">
                <i class="fas fa-check me-2"></i>Confirm N Value
            </button>
            <button class="btn btn-outline-light" id="cancelNValueBtn">
                <i class="fas fa-times me-2"></i>Cancel
            </button>
        </div>
    </div>
</div>
                            <!-- Add this in the Search Tab after the Element Analysis section -->
<div class="mb-3">
    <label class="form-label">Find Elements by Predicate Function</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="predicateCondition" placeholder="e.g., arr%2==0, arr!=0, arr<5">
        <button class="btn btn-glow" id="findByPredicateBtn">
            <i class="fas fa-filter me-2"></i>Filter by Condition
        </button>
    </div>
    <small class="text-muted">Use 'arr' to represent array elements. Examples: arr%2==0 (even), arr!=0 (non-zero), arr<5 (less than 5)</small>
</div>
                            <!-- Add this in the Search Tab after the Element Analysis section -->
<div class="mb-3">
    <label class="form-label">Find Missing & Repeating Number</label>
    <div class="input-group mb-2">
        <select class="form-control" id="missingRepeatingMethod">
            <option value="math">Using Math (Sum & Sum of Squares)</option>
            <option value="xor">Using XOR (Bit Manipulation)</option>
        </select>
        <button class="btn btn-glow" id="findMissingRepeatingBtn">
            <i class="fas fa-search me-2"></i>Find Missing & Repeating
        </button>
    </div>
    <small class="text-muted">Array should contain numbers from 1 to n with one missing and one repeated</small>
</div>
                            <!-- Add this in the Search Tab after Element Analysis section -->
<div class="mb-3">
    <label class="form-label">Maximum Absolute Difference</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="findMaxAbsDiffBtn">
            <i class="fas fa-calculator me-2"></i>Find Maximum Absolute Difference
        </button>
    </div>
    <small class="text-muted">Calculate max(|A[i] - A[j]| + |i - j|) for all i, j</small>
</div>
<div class="mb-3">
    <label class="form-label">Count Pairs with Difference K</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="pairDifferenceK" placeholder="Enter K value">
        <button class="btn btn-glow" id="countPairsWithDifferenceBtn">
            <i class="fas fa-calculator me-2"></i>Count Pairs with Difference K
        </button>
    </div>
    <small class="text-muted">Count unique pairs (i,j) where |arr[i]-arr[j]| = K</small>
</div>
<!-- Add this in the AdvancedBasicOperations Tab after the Element Analysis section -->
<div class="mb-3">
    <label class="form-label">Statistical Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="calculateStdDevBtn">
            <i class="fas fa-chart-line me-2"></i>Calculate Standard Deviation
        </button>
        <button class="btn btn-glow" id="calculateVarianceBtn">
            <i class="fas fa-calculator me-2"></i>Calculate Variance
        </button>
    </div>
</div>
                            
                            <div class="search-results" id="searchResults">
                                <p class="text-center mb-0">Search results will appear here</p>
                            </div>
                            
                            <div class="algorithm-explanation" id="algorithmExplanation">
                                <h6>Linear Search Algorithm</h6>
                                <p>Linear search checks each element in the array sequentially until the target is found or the end is reached.</p>
                                
                                <div class="code-snippet">
                                    function linearSearch(arr, target) {<br>
                                    &nbsp;&nbsp;for (let i = 0; i < arr.length; i++) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;if (arr[i] === target) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return i; // Found at index i<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                                    &nbsp;&nbsp;}<br>
                                    &nbsp;&nbsp;return -1; // Not found<br>
                                    }
                                </div>
                                
                                <div id="algorithmSteps">
                                    <div class="algorithm-step">
                                        <strong>Step 1:</strong> Start from the first element (index 0)
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 2:</strong> Compare current element with target
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 3:</strong> If match found, return current index
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 4:</strong> Move to next element and repeat Step 2
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 5:</strong> If end of array reached, element not found
                                    </div>
                                </div>
                            </div>
                            
                            <div class="algorithm-explanation mt-3" id="binarySearchExplanation">
                                <h6>Binary Search Algorithm</h6>
                                <p>Binary search works on sorted arrays by repeatedly dividing the search interval in half.</p>
                                
                                <div class="code-snippet">
                                    function binarySearch(arr, target) {<br>
                                    &nbsp;&nbsp;let left = 0, right = arr.length - 1;<br>
                                    &nbsp;&nbsp;while (left <= right) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;let mid = Math.floor((left + right) / 2);<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;if (arr[mid] === target) return mid;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;else if (arr[mid] < target) left = mid + 1;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;else right = mid - 1;<br>
                                    &nbsp;&nbsp;}<br>
                                    &nbsp;&nbsp;return -1;<br>
                                    }
                                </div>
                                
                                <div id="binarySearchSteps">
                                    <div class="algorithm-step">
                                        <strong>Step 1:</strong> Ensure array is sorted (sort if needed)
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 2:</strong> Set left=0, right=array.length-1
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 3:</strong> Calculate mid = (left + right) / 2
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 4:</strong> Compare element at mid with target
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 5:</strong> If match found, return mid index
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 6:</strong> If target > mid, search right half (left = mid+1)
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 7:</strong> If target < mid, search left half (right = mid-1)
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 8:</strong> Repeat until found or search space exhausted
                                    </div>
                                </div>
                            </div>
                            <!-- Add this in the Search Tab after Binary Search algorithm explanation -->
<div class="algorithm-explanation mt-3" id="countPairsExplanation">
    <h6>Count Pairs with Difference K Algorithm</h6>
    <p>This algorithm counts all unique pairs (i,j) where i < j and |arr[i]-arr[j]| = K.</p>
    
    <div class="code-snippet">
        function countPairsWithDifferenceK(arr, k) {<br>
        &nbsp;&nbsp;let count = 0;<br>
        &nbsp;&nbsp;for (let i = 0; i < arr.length; i++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;for (let j = i + 1; j < arr.length; j++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Math.abs(arr[i] - arr[j]) === k) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;}<br>
        &nbsp;&nbsp;return count;<br>
        }
    </div>
    
    <div id="countPairsSteps">
        <div class="algorithm-step">
            <strong>Step 1:</strong> Start with i=0, j=i+1
        </div>
        <div class="algorithm-step">
            <strong>Step 2:</strong> Calculate |arr[i]-arr[j]|
        </div>
        <div class="algorithm-step">
            <strong>Step 3:</strong> If difference equals K, count as valid pair
        </div>
        <div class="algorithm-step">
            <strong>Step 4:</strong> Increment j until end of array
        </div>
        <div class="algorithm-step">
            <strong>Step 5:</strong> Increment i and repeat from Step 2
        </div>
        <div class="algorithm-step">
            <strong>Step 6:</strong> Return total count of valid pairs
        </div>
    </div>
</div>
                            <div class="algorithm-explanation mt-3" id="rotatedSearchExplanation">
                                <h6>Search in Rotated Sorted Array Algorithm</h6>
                                <p>This algorithm searches for an element in a sorted array that has been rotated at some pivot point.</p>
                                
                                <div class="code-snippet">
                                    function searchRotatedSorted(arr, target) {<br>
                                    &nbsp;&nbsp;let left = 0, right = arr.length - 1;<br>
                                    &nbsp;&nbsp;while (left <= right) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;let mid = Math.floor((left + right) / 2);<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;if (arr[mid] === target) return mid;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Check which half is sorted<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;if (arr[left] <= arr[mid]) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Left half is sorted<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (arr[left] <= target && target < arr[mid]) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right = mid - 1;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left = mid + 1;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Right half is sorted<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (arr[mid] < target && target <= arr[right]) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left = mid + 1;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right = mid - 1;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                                    &nbsp;&nbsp;}<br>
                                    &nbsp;&nbsp;return -1;<br>
                                    }
                                </div>
                                
                                <div id="rotatedSearchSteps">
                                    <div class="algorithm-step">
                                        <strong>Step 1:</strong> Find mid index of current search space
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 2:</strong> Check if mid element equals target
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 3:</strong> Determine which half is properly sorted
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 4:</strong> Check if target lies within the sorted half
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 5:</strong> Adjust search boundaries based on sorted half analysis
                                    </div>
                                    <div class="algorithm-step">
                                        <strong>Step 6:</strong> Repeat until found or search space exhausted
                                    </div>
                                </div>
                            </div>
                            <!-- Add this after Binary Search algorithm explanation -->
<div class="algorithm-explanation mt-3" id="comparisonSearchExplanation">
    <h6>Comparison Search Algorithms</h6>
    
    <div class="mb-3">
        <strong>Find First Element > x:</strong>
        <div class="code-snippet">
            function findFirstGreater(arr, x) {<br>
            &nbsp;&nbsp;for (let i = 0; i < arr.length; i++) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (arr[i] > x) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return i; // Found at index i<br>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
            &nbsp;&nbsp;}<br>
            &nbsp;&nbsp;return -1; // Not found<br>
            }
        </div>
    </div>
    
    <div class="mb-3">
        <strong>Find Last Element < x:</strong>
        <div class="code-snippet">
            function findLastLess(arr, x) {<br>
            &nbsp;&nbsp;for (let i = arr.length - 1; i >= 0; i--) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (arr[i] < x) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return i; // Found at index i<br>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
            &nbsp;&nbsp;}<br>
            &nbsp;&nbsp;return -1; // Not found<br>
            }
        </div>
    </div>
    <!-- Add this in the Search Tab after Binary Search explanation -->
<div class="algorithm-explanation mt-3" id="rangeAlgorithmExplanation">
    <h6>Range Calculation Algorithm (Linear Scan)</h6>
    <p>This algorithm finds the minimum and maximum elements in an array using a single pass, then calculates the range as max - min.</p>
    
    <div class="code-snippet">
        function findRange(arr) {<br>
        &nbsp;&nbsp;if (arr.length === 0) return 0;<br>
        &nbsp;&nbsp;let min = arr[0];<br>
        &nbsp;&nbsp;let max = arr[0];<br>
        &nbsp;&nbsp;for (let i = 1; i < arr.length; i++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (arr[i] < min) min = arr[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (arr[i] > max) max = arr[i];<br>
        &nbsp;&nbsp;}<br>
        &nbsp;&nbsp;return max - min;<br>
        }
    </div>
    
    <div id="rangeAlgorithmSteps">
        <div class="algorithm-step">
            <strong>Step 1:</strong> Initialize min and max with first element
        </div>
        <div class="algorithm-step">
            <strong>Step 2:</strong> Iterate through remaining elements
        </div>
        <div class="algorithm-step">
            <strong>Step 3:</strong> Update min if current element is smaller
        </div>
        <div class="algorithm-step">
            <strong>Step 4:</strong> Update max if current element is larger
        </div>
        <div class="algorithm-step">
            <strong>Step 5:</strong> Calculate range = max - min
        </div>
        <div class="algorithm-step">
            <strong>Complexity:</strong> Time: O(n), Space: O(1)
        </div>
    </div>
</div>
</div>

                        </div>
                        <!-- Advanced Basic Operations Tab -->
                        <div class="tab-pane fade" id="advanced" role="tabpanel">
                            <div class="mb-3">
                                <label class="form-label">Fixed-size Sliding Window</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="fixedWindowSize" placeholder="Enter k (window size)" min="1">
                                    <button class="btn btn-glow" id="fixedWindowBtn">
                                        <i class="fas fa-window-maximize me-2"></i>Find Max Sum
                                    </button>
                                </div>
                                <small class="text-muted">Find maximum sum of any contiguous subarray of length k</small>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Variable-size Sliding Window</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="variableWindowSum" placeholder="Enter target sum">
                                    <button class="btn btn-glow" id="variableWindowBtn">
                                        <i class="fas fa-arrows-alt-h me-2"></i>Find Longest Subarray
                                    </button>
                                </div>
                                <small class="text-muted">Find longest subarray with sum  target</small>
                            </div>
                            <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Element-wise Logical Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="logicalAndBtn">
            <i class="fas fa-code me-2"></i>Perform Element-wise Logical AND
        </button>
        <button class="btn btn-glow" id="logicalOrBtn">
            <i class="fas fa-code me-2"></i>Perform Element-wise Logical OR
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Logical Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="logicalNotBtn">
            <i class="fas fa-exchange-alt me-2"></i>Perform Element-wise Logical NOT
        </button>
        <button class="btn btn-glow" id="logicalXorBtn">
            <i class="fas fa-not-equal me-2"></i>Perform Element-wise Logical XOR
        </button>
    </div>
</div>
<!-- Logical NOT Input Group (initially hidden) -->
<div class="mb-3" id="logicalNotGroup" style="display: none;">
    <label class="form-label">Logical NOT Operation</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="logicalNotSize" placeholder="Enter array size" min="1" max="20">
        <button class="btn btn-glow" id="confirmLogicalNotSizeBtn">
            <i class="fas fa-check me-2"></i>Set Array Size
        </button>
    </div>
    <div id="logicalNotInputs" class="mt-2"></div>
    <button class="btn btn-outline-light mt-2" id="cancelLogicalNotBtn">
        <i class="fas fa-times me-2"></i>Cancel NOT Operation
    </button>
</div>

<!-- Logical XOR Input Group (initially hidden) -->
<div class="mb-3" id="logicalXorGroup" style="display: none;">
    <label class="form-label">Logical XOR Operation</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="logicalXorArrayCount" placeholder="Number of arrays" min="2" max="5">
        <button class="btn btn-glow" id="confirmLogicalXorArrayCountBtn">
            <i class="fas fa-check me-2"></i>Set Array Count
        </button>
    </div>
    <div id="logicalXorSizeInputs" class="mt-2"></div>
    <div id="logicalXorElementInputs" class="mt-2"></div>
    <button class="btn btn-outline-light mt-2" id="cancelLogicalXorBtn">
        <i class="fas fa-times me-2"></i>Cancel XOR Operation
    </button>
</div>
<!-- Logical Operations Input Group (initially hidden) -->
<div class="mb-3" id="logicalOperationsGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">Logical Operation Configuration</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="logicalArraysCount" placeholder="Number of arrays (2-5)" min="2" max="5">
            <button class="btn btn-glow" id="confirmArraysCountBtn">
                <i class="fas fa-check me-2"></i>Confirm Number of Arrays
            </button>
        </div>
    </div>

    <div id="arraysSizeInputs" class="mt-2"></div>
    <div id="arraysElementsInputs" class="mt-2"></div>

    <div class="d-grid gap-2">
        <button class="btn btn-glow" id="performLogicalOperationBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Perform Logical Operation
        </button>
        <button class="btn btn-outline-light" id="cancelLogicalOperationBtn">
            <i class="fas fa-times me-2"></i>Cancel Logical Operation
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Data Binning Operations</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="binCount" placeholder="Number of bins" min="2" max="20">
        <button class="btn btn-glow" id="binIntervalsBtn">
            <i class="fas fa-chart-bar me-2"></i>Create Bin Intervals
        </button>
    </div>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="binWidth" placeholder="Bin width" min="1">
        <button class="btn btn-glow" id="binByWidthBtn">
            <i class="fas fa-ruler me-2"></i>Bin by Width
        </button>
    </div>
    <small class="text-muted">Group array elements into intervals for histogram analysis</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">NumPy-style Conditional Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="conditionalWhereBtn">
            <i class="fas fa-question-circle me-2"></i>Conditional Select (Where)
        </button>
        <button class="btn btn-glow" id="multiConditionSelectBtn">
            <i class="fas fa-list-alt me-2"></i>Multi-Condition Select
        </button>
        <button class="btn btn-glow" id="piecewiseEvaluateBtn">
            <i class="fas fa-puzzle-piece me-2"></i>Piecewise Evaluate
        </button>
    </div>
</div>

<!-- Conditional Operations Input Groups (initially hidden) -->
<div class="mb-3" id="conditionalOperationsGroup" style="display: none;">
    <div class="mb-3" id="arraySizesGroup">
        <label class="form-label">Array Configuration</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="arraySize1" placeholder="Size of Array 1" min="1" max="20">
            <input type="number" class="form-control" id="arraySize2" placeholder="Size of Array 2" min="1" max="20">
            <button class="btn btn-glow" id="confirmArraySizesBtn">
                <i class="fas fa-check me-2"></i>Set Array Sizes
            </button>
        </div>
    </div>

    <div class="mb-3" id="arrayElementsGroup" style="display: none;">
        <div class="mb-3">
            <label class="form-label">Array 1 Elements</label>
            <div id="array1Inputs" class="mt-2"></div>
        </div>

        <div class="mb-3">
            <label class="form-label">Array 2 Elements</label>
            <div id="array2Inputs" class="mt-2"></div>
        </div>
    </div>

    <div class="mb-3" id="conditionGroup" style="display: none;">
        <label class="form-label">Condition Configuration</label>
        <div class="input-group mb-2">
            <select class="form-control" id="conditionOperator">
                <option value="<">Less than (<)</option>
                <option value=">">Greater than (>)</option>
                <option value="<=">Less than or equal ()</option>
                <option value=">=">Greater than or equal ()</option>
                <option value="==">Equal (==)</option>
                <option value="!=">Not equal (!=)</option>
            </select>
            <input type="number" class="form-control" id="conditionValue" placeholder="Condition value">
            <button class="btn btn-glow" id="confirmConditionBtn">
                <i class="fas fa-play me-2"></i>Apply Condition
            </button>
        </div>
    </div>

    <div class="d-grid gap-2">
        <button class="btn btn-outline-light" id="cancelConditionalBtn">
            <i class="fas fa-times me-2"></i>Cancel Operation
        </button>
    </div>
</div>
                            <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
                           <div class="mb-3">
                          <label class="form-label">Consecutive Sequence Operations</label>
                           <div class="input-group mb-2">
                             <button class="btn btn-glow" id="longestConsecutiveSequenceBtn">
                            <i class="fas fa-link me-2"></i>Find Longest Consecutive Sequence
                              </button>
                             <button class="btn btn-glow" id="maxConsecutiveOnesBtn">
                            <i class="fas fa-binary me-2"></i>Maximum Consecutive 1s (Binary Array)
                             </button>
                             </div>
                             </div>
                            <!-- NEW: Max and Min Sum of K Consecutive Elements -->
                             <div class="mb-3">
                           <label class="form-label">K Consecutive Elements Sum</label>
                            <div class="input-group mb-2">
                           <input type="number" class="form-control" id="kConsecutiveSize" placeholder="Enter k value" min="1">
                            <button class="btn btn-glow" id="maxKConsecutiveBtn">
                            <i class="fas fa-arrow-up me-2"></i>Find Max Sum of K Consecutive
                             </button>
                              <button class="btn btn-glow" id="minKConsecutiveBtn">
                            <i class="fas fa-arrow-down me-2"></i>Find Min Sum of K Consecutive
                            </button>
                           </div>
                            <small class="text-muted">Find maximum/minimum sum of k consecutive elements</small>
                           </div>
                        <!-- Add these buttons in the Advanced Basic Operations Tab -->
<div class="mb-3">
    <label class="form-label">Previous Greater/Smaller Element</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="previousGreaterBtn">
            <i class="fas fa-arrow-up me-2"></i>Previous Greater Element
        </button>
        <button class="btn btn-glow" id="previousSmallerBtn">
            <i class="fas fa-arrow-down me-2"></i>Previous Smaller Element
        </button>
    </div>
</div>   
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Custom UFunc (Universal Function)</label>
    <div class="input-group mb-2">
        <select class="form-control" id="ufuncSelect">
            <option value="">Select a Universal Function</option>
            <option value="c2f">Celsius to Fahrenheit</option>
            <option value="f2c">Fahrenheit to Celsius</option>
            <option value="square">Square (x)</option>
            <option value="cube">Cube (x)</option>
            <option value="reciprocal">Reciprocal (1/x)</option>
            <option value="relu">ReLU Activation</option>
            <option value="sigmoid">Sigmoid Activation</option>
            <option value="is_even">Is Even</option>
            <option value="is_odd">Is Odd</option>
            <option value="clamp">Clamp Values</option>
            <!-- NEW FUNCTIONS -->
            <option value="zscore_elem">Z-Score Element</option>
            <option value="percentile_rank">Percentile Rank</option>
            <option value="to_grade">Convert to Grade</option>
            <option value="euclid_1d">Euclidean Distance 1D</option>
            <option value="inc">Increment</option>
            <option value="dec">Decrement</option>
            <option value="double">Double</option>
            <option value="half">Half</option>
            <option value="neg">Negate</option>
            <option value="is_positive">Is Positive</option>
            <option value="is_negative">Is Negative</option>
            <option value="is_zero">Is Zero</option>
            <option value="sqroot">Square Root</option>
            <option value="cbrt">Cube Root</option>
            <option value="sin_deg">Sine (Degrees)</option>
            <option value="cos_deg">Cosine (Degrees)</option>
            <option value="tan_deg">Tangent (Degrees)</option>
            <!-- NEWLY ADDED FUNCTIONS -->
            <option value="bit_flip">Bit Flip</option>
            <option value="bit_and">Bitwise AND</option>
            <option value="bit_or">Bitwise OR</option>
            <option value="bit_xor">Bitwise XOR</option>
            <option value="asin_deg">Arcsine (Degrees)</option>
            <option value="acos_deg">Arccosine (Degrees)</option>
            <option value="atan_deg">Arctangent (Degrees)</option>
            <option value="factorial_approx">Factorial (Approximation)</option>
            <option value="leaky_relu">Leaky ReLU</option>
            <option value="bin_0_100">Bin to 0-100</option>
        </select>
        <button class="btn btn-glow" id="applyUfuncBtn">
            <i class="fas fa-calculator me-2"></i>Apply UFunc
        </button>
    </div>
    
    <!-- Additional inputs for functions that need parameters -->
    <div id="ufuncParams" style="display: none;">
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="clampLow" placeholder="Lower bound" style="display: none;">
            <input type="number" class="form-control" id="clampHigh" placeholder="Upper bound" style="display: none;">
            <input type="number" class="form-control" id="euclidRef" placeholder="Reference point" style="display: none;">
            <input type="number" class="form-control" id="bitwiseOperand" placeholder="Operand value" style="display: none;">
            <input type="number" class="form-control" id="leakyReluAlpha" placeholder="Alpha value" style="display: none;">
        </div>
    </div>
</div>     
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">apply_along_axis() for 1D Slices</label>
    <div class="input-group mb-2">
        <select class="form-control" id="axisFunctionSelect">
            <option value="">Select an operation...</option>
            <option value="rowSum">Row-wise Sum</option>
            <option value="colMean">Column-wise Mean</option>
            <option value="rowStd">Row-wise Standard Deviation</option>
            <option value="colMedian">Column-wise Median</option>
            <option value="rowMax">Row-wise Max</option>
            <option value="rowMin">Row-wise Min</option>
            <option value="colVariance">Column-wise Variance</option>
            <option value="rowRange">Row-wise Range</option>
            <option value="rowNormalize">Row-wise Normalization (Min-Max)</option>
            <option value="colZScore">Column-wise Z-Score</option>
            <option value="custom">Custom Function</option>
        </select>
        <button class="btn btn-glow" id="applyAxisBtn">
            <i class="fas fa-play me-2"></i>Apply Operation
        </button>
    </div>
    
    <!-- Custom function input (initially hidden) -->
    <div id="customFunctionGroup" style="display: none;">
        <label class="form-label">Custom Function (JavaScript)</label>
        <textarea class="form-control" id="customFunction" rows="3" 
                  placeholder="Enter function body. Use 'arr' as parameter. Example: return arr.reduce((a, b) => a + b, 0);"></textarea>
        <small class="text-muted">Function should take an array and return a single value</small>
    </div>
    
    <!-- Matrix dimensions input -->
    <div class="mt-2" id="matrixDimensionsGroup" style="display: none;">
        <label class="form-label">Matrix Dimensions</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="matrixRows" placeholder="Rows" min="1" max="10">
            <input type="number" class="form-control" id="matrixCols" placeholder="Columns" min="1" max="10">
            <button class="btn btn-glow" id="createMatrixBtn">
                <i class="fas fa-table me-2"></i>Create Matrix
            </button>
        </div>
    </div>
</div>       
<!-- Add these buttons in the Advanced Basic Operations Tab -->
<!-- Add these buttons in the Advanced Basic Operations Tab -->
<div class="mb-3">
    <label class="form-label">Statistical Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="findCovarianceBtn">
            <i class="fas fa-chart-line me-2"></i>Find Covariance
        </button>
        <button class="btn btn-glow" id="findCorrelationBtn">
            <i class="fas fa-link me-2"></i>Find Correlation Coefficient
        </button>
    </div>
</div>

<!-- Add this section for covariance/correlation input (initially hidden) -->
<div class="mb-3" id="covarianceCorrelationGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label" id="operationTitle">Covariance Operation</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="arrayCountInput" placeholder="Number of arrays (2)" min="2" max="5" value="2">
            <button class="btn btn-glow" id="confirmArrayCountBtn">
                <i class="fas fa-check me-2"></i>Confirm Array Count
            </button>
        </div>
    </div>

    <div id="arrayDetailsContainer" class="mt-3"></div>

    <div class="d-grid gap-2 mt-3">
        <button class="btn btn-glow" id="performStatisticalOperationBtn" style="display: none;">
            <i class="fas fa-calculator me-2"></i>Calculate
        </button>
        <button class="btn btn-outline-light" id="cancelStatisticalOperationBtn">
            <i class="fas fa-times me-2"></i>Cancel Operation
        </button>
    </div>
</div>
                            <div class="mb-3">
                                <label class="form-label">Dutch National Flag Problem</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="sortDutchNationalFlagBtn">
                                        <i class="fas fa-flag me-2"></i>Sort 0s, 1s, 2s (Dutch National Flag)
                                    </button>
                                </div>
                                <small class="text-muted">Sort array containing only 0s, 1s, and 2s using three-pointer technique</small>
                            </div>
                            <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
                             <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
                                      <div class="mb-3">
                           <label class="form-label">Rearrange Array Alternately</label>
                          <div class="input-group mb-2">
                          <button class="btn btn-glow" id="rearrangeMinMaxBtn">
                          <i class="fas fa-random me-2"></i>Rearrange Array (Min, Max) Alternately
                         </button>
                         </div>
                           <small class="text-muted">Rearranges sorted array as: max, min, 2nd max, 2nd min, ...</small>
                           </div>
                         <div class="mb-3">
                         <label class="form-label">Subarray Product Operations</label>
                             <div class="input-group mb-2">
                        <input type="number" class="form-control" id="subarrayProductK" placeholder="Enter k value" min="1">
                        <button class="btn btn-glow" id="subarrayProductBtn">
                       <i class="fas fa-calculator me-2"></i>Subarray Product < k
                        </button>
                        </div>
                         <small class="text-muted">Find all contiguous subarrays with product less than k</small>
                         </div>
                         <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Minimum Swaps to Bring Elements  K Together</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="minSwapsK" placeholder="Enter K value">
        <button class="btn btn-glow" id="minSwapsBtn">
            <i class="fas fa-exchange-alt me-2"></i>Find Minimum Swaps
        </button>
    </div>
    <small class="text-muted">Find minimum swaps to group all elements  K together</small>
</div>
                        
 <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
  <div class="mb-3">
    <label class="form-label">Leader in Array</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="leaderInArrayBtn">
            <i class="fas fa-crown me-2"></i>Find Leaders in Array
        </button>
    </div>
    <small class="text-muted">Find elements that are greater than all elements to their right</small>
    </div>
                            <div class="mb-3">
                                <label class="form-label">Find Majority Element (Boyer-Moore Algorithm)</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="findMajorityElementBtn">
                                        <i class="fas fa-chart-pie me-2"></i>Find Majority Element
                                    </button>
                                </div>
                                <small class="text-muted">Find element that appears more than n/2 times</small>
                            </div>
                            <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
                             <!-- Add this in the Search Tab after the existing search sections -->
               <div class="mb-3">
            <label class="form-label">Equilibrium Point</label>
           <div class="input-group mb-2">
          <button class="btn btn-glow" id="equilibriumPointBtn">
            <i class="fas fa-balance-scale me-2"></i>Find Equilibrium Point
        </button>
      </div>
    <small class="text-muted">Find index where sum of left elements equals sum of right elements</small>
     </div>
     <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
     <div class="mb-3">
    <label class="form-label">Mathematical Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="findGcdBtn">
            <i class="fas fa-calculator me-2"></i>Find GCD of Array
        </button>
        <button class="btn btn-glow" id="findLcmBtn">
            <i class="fas fa-calculator me-2"></i>Find LCM of Array
        </button>
    </div>
    <small class="text-muted">Calculate Greatest Common Divisor and Least Common Multiple</small>
 </div>
 <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
 <div class="mb-3">
    <label class="form-label">Prime Number Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="primeSieveBtn">
            <i class="fas fa-filter me-2"></i>Prime Sieve (Identify Primes)
        </button>
    </div>
    <small class="text-muted">Identify prime numbers (green) and composite numbers (red) in the array</small>
  </div>
  <!-- Add this after Binary Search algorithm explanation -->
  <div class="algorithm-explanation mt-3" id="equilibriumExplanationSection">
    <h6>Equilibrium Point Algorithm</h6>
    <p>An equilibrium point is an index in the array where the sum of elements on the left equals the sum of elements on the right.</p>
    
    <div class="code-snippet">
        function findEquilibrium(arr) {<br>
        &nbsp;&nbsp;let totalSum = arr.reduce((a, b) => a + b, 0);<br>
        &nbsp;&nbsp;let leftSum = 0;<br>
        &nbsp;&nbsp;for (let i = 0; i < arr.length; i++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;let rightSum = totalSum - leftSum - arr[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (leftSum === rightSum) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return i; // Equilibrium found<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;&nbsp;&nbsp;leftSum += arr[i];<br>
        &nbsp;&nbsp;}<br>
        &nbsp;&nbsp;return -1; // No equilibrium point<br>
        }
    </div>
    
    <div id="equilibriumAlgorithmSteps">
        <div class="algorithm-step">
            <strong>Step 1:</strong> Calculate total sum of all elements
        </div>
        <div class="algorithm-step">
            <strong>Step 2:</strong> Initialize left sum to 0
        </div>
        <div class="algorithm-step">
            <strong>Step 3:</strong> For each index i, calculate right sum = total sum - left sum - arr[i]
        </div>
        <div class="algorithm-step">
            <strong>Step 4:</strong> If left sum equals right sum, return current index
        </div>
        <div class="algorithm-step">
            <strong>Step 5:</strong> Otherwise, add current element to left sum and continue
        </div>
        <div class="algorithm-step">
            <strong>Step 6:</strong> If no equilibrium found, return -1
        </div>
    </div>
 </div>
 <!-- Add this in the Advanced Basic Operations Tab after the Data Binning Operations section -->
<div class="algorithm-explanation mt-3">
    <h6>Data Binning Algorithms</h6>
    
    <div class="mb-3">
        <strong>Binning by Number of Intervals:</strong>
        <div class="code-snippet">
            function binByCount(arr, numBins) {<br>
            &nbsp;&nbsp;const minVal = Math.min(...arr);<br>
            &nbsp;&nbsp;const maxVal = Math.max(...arr);<br>
            &nbsp;&nbsp;const range = maxVal - minVal;<br>
            &nbsp;&nbsp;const binSize = range / numBins;<br>
            &nbsp;&nbsp;const bins = Array(numBins).fill(0).map(() => []);<br>
            &nbsp;&nbsp;<br>
            &nbsp;&nbsp;for (let value of arr) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;const binIndex = Math.min(<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Math.floor((value - minVal) / binSize), <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numBins - 1<br>
            &nbsp;&nbsp;&nbsp;&nbsp;);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;bins[binIndex].push(value);<br>
            &nbsp;&nbsp;}<br>
            &nbsp;&nbsp;return bins;<br>
            }
        </div>
    </div>
    
    <div class="mb-3">
        <strong>Binning by Fixed Width:</strong>
        <div class="code-snippet">
            function binByWidth(arr, width) {<br>
            &nbsp;&nbsp;const minVal = Math.min(...arr);<br>
            &nbsp;&nbsp;const maxVal = Math.max(...arr);<br>
            &nbsp;&nbsp;const numBins = Math.ceil((maxVal - minVal) / width);<br>
            &nbsp;&nbsp;const bins = Array(numBins).fill(0).map(() => []);<br>
            &nbsp;&nbsp;<br>
            &nbsp;&nbsp;for (let value of arr) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;const binIndex = Math.min(<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Math.floor((value - minVal) / width), <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numBins - 1<br>
            &nbsp;&nbsp;&nbsp;&nbsp;);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;bins[binIndex].push(value);<br>
            &nbsp;&nbsp;}<br>
            &nbsp;&nbsp;return bins;<br>
            }
        </div>
    </div>
    
    <div class="algorithm-step">
        <strong>Step 1:</strong> Calculate data range (min, max values)
    </div>
    <div class="algorithm-step">
        <strong>Step 2:</strong> Determine bin intervals based on method
    </div>
    <div class="algorithm-step">
        <strong>Step 3:</strong> Assign each element to appropriate bin
    </div>
    <div class="algorithm-step">
        <strong>Step 4:</strong> Count elements in each bin and display distribution
    </div>
</div>
  <div class="mb-3">
    <label class="form-label">Triplet & Quadruplet Sum Operations</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="tripletSumInput" placeholder="Enter target sum for triplets">
        <button class="btn btn-glow" id="findTripletsBtn">
            <i class="fas fa-cube me-2"></i>Find Triplets
        </button>
    </div>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="quadrupletSumInput" placeholder="Enter target sum for quadruplets">
        <button class="btn btn-glow" id="findQuadrupletsBtn">
            <i class="fas fa-cubes me-2"></i>Find Quadruplets
        </button>
    </div>
    </div>
                            <!-- Add these buttons to the Advanced Basic Operations tab, after the existing buttons -->
                   <div class="mb-3">
                <label class="form-label">Advanced Array Algorithms</label>
                 <div class="input-group mb-2">
              <button class="btn btn-glow" id="findNBy3ElementsBtn">
              <i class="fas fa-chart-pie me-2"></i>Find Elements > n/3 Times
              </button>
           <button class="btn btn-glow" id="nextGreaterElementBtn">
            <i class="fas fa-arrow-right me-2"></i>Find Next Greater Element
           </button>
          </div>
          </div>

                            <div class="mb-3">
                                <label class="form-label">Advanced Algorithms</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="twoPointerSortBtn">
                                        <i class="fas fa-arrows-alt-h me-2"></i>Two-Pointer (Sort Array)
                                    </button>
                                    <button class="btn btn-glow" id="kadaneAlgorithmBtn">
                                        <i class="fas fa-chart-line me-2"></i>Kadane's Algorithm (Max Subarray Sum)
                                    </button>
                                            <button class="btn btn-glow" id="maxCircularSubarrayBtn">
                                      <i class="fas fa-sync-alt me-2"></i>Maximum Sum Circular Subarray
                                    </button>

                                </div>
                            </div>
                            <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Maximum Distance Between Same Elements</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="maxDistanceSameElementsBtn">
            <i class="fas fa-arrows-alt-h me-2"></i>Find Max Distance Between Same Elements
        </button>
    </div>
    <small class="text-muted">Find maximum distance (j-i) where arr[i] == arr[j] and i < j</small>
</div>
                     <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Element-wise Array Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="elementWiseMaxBtn">
            <i class="fas fa-arrow-up me-2"></i>Element-wise Maximum of Two Arrays
        </button>
        <button class="btn btn-glow" id="elementWiseMinBtn">
            <i class="fas fa-arrow-down me-2"></i>Element-wise Minimum of Two Arrays
        </button>
    </div>
</div>

<!-- Element-wise Operations Input Group (initially hidden) -->
<div class="mb-3" id="elementWiseGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">First Array Details</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="firstArraySizeElementWise" placeholder="Size of first array" min="1" max="20">
            <button class="btn btn-glow" id="confirmFirstArraySizeElementWiseBtn">
                <i class="fas fa-check me-2"></i>Set First Array Size
            </button>
        </div>
        <div id="firstArrayInputsElementWise" class="mt-2"></div>
    </div>

    <div class="mb-3">
        <label class="form-label">Second Array Details</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="secondArraySizeElementWise" placeholder="Size of second array" min="1" max="20">
            <button class="btn btn-glow" id="confirmSecondArraySizeElementWiseBtn">
                <i class="fas fa-check me-2"></i>Set Second Array Size
            </button>
        </div>
        <div id="secondArrayInputsElementWise" class="mt-2"></div>
    </div>

    <div class="d-grid gap-2">
        <button class="btn btn-glow" id="performElementWiseBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Perform Element-wise Operation
        </button>
        <button class="btn btn-outline-light" id="cancelElementWiseBtn">
            <i class="fas fa-times me-2"></i>Cancel Operation
        </button>

    </div>
</div>       
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Logical Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="maxPairAndOrBtn">
            <i class="fas fa-code me-2"></i>Max Pair AND/OR
        </button>
    </div>
    <small class="text-muted">Find maximum AND and OR pairs in the array</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Minimum Flips Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="minFlipsOrBtn">
            <i class="fas fa-exchange-alt me-2"></i>Minimum Flips OR
        </button>
        <button class="btn btn-glow" id="minFlipsAndBtn">
            <i class="fas fa-exchange-alt me-2"></i>Minimum Flips AND
        </button>
    </div>
</div>

<!-- Minimum Flips Input Group (initially hidden) -->
<div class="mb-3" id="minFlipsInputGroup" style="display: none;">
    <h6 id="minFlipsTitle" class="text-center mb-3">Minimum Flips Operation</h6>
    
    <div class="mb-3">
        <label class="form-label">Number of Arrays</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="numArraysInput" placeholder="Enter number of arrays" min="2" max="5">
            <button class="btn btn-glow" id="confirmNumArraysBtn">
                <i class="fas fa-check me-2"></i>Confirm
            </button>
        </div>
    </div>

    <div id="arraySizeInputs" class="mb-3"></div>
    <div id="arrayElementsInputs" class="mb-3"></div>

    <div class="d-grid gap-2">
        <button class="btn btn-glow" id="performMinFlipsBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Find Minimum Flips
        </button>
        <button class="btn btn-outline-light" id="cancelMinFlipsBtn">
            <i class="fas fa-times me-2"></i>Cancel Operation
        </button>
    </div>
</div>

                            <div class="mb-3">
                                <label class="form-label">Zero Movement Operations</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="moveZerosToFrontBtn">
                                        <i class="fas fa-arrow-left me-2"></i>Move Zeros to Front
                                    </button>
                                    <button class="btn btn-glow" id="moveZerosToEndBtn">
                                        <i class="fas fa-arrow-right me-2"></i>Move Zeros to End
                                    </button>
                                </div>
                                <small class="text-muted">Move all zero elements to front or end while maintaining relative order of non-zero elements</small>
                            </div>
                            <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
  <div class="mb-3">
    <label class="form-label">Find Subarray with Sum Closest to Zero</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="findSubarrayNearZeroBtn">
            <i class="fas fa-bullseye me-2"></i>Find Subarray with Sum Near Zero
        </button>
    </div>
    <small class="text-muted">Find subarray whose sum is closest to zero</small>
   </div>
                            <div class="mb-3">
                                <label class="form-label">Element Analysis</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="countElementFrequencyBtn">
                                        <i class="fas fa-chart-bar me-2"></i>Count Element Frequency
                                    </button>
                                    <button class="btn btn-glow" id="findDuplicatesBtn">
                                        <i class="fas fa-clone me-2"></i>Find Duplicate Elements
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Element Uniqueness Operations</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="firstNonRepeatingBtn">
                                        <i class="fas fa-search me-2"></i>Find First Non-Repeating Element
                                    </button>
                                    <button class="btn btn-glow" id="findUniqueElementsBtn">
                                        <i class="fas fa-star me-2"></i>Find All Unique Elements
                                    </button>
                                </div>
                            </div>
                            <!-- Add this in the Search Tab after Element Uniqueness Operations -->
                    <div class="mb-3">
                     <label class="form-label">Find Repeating Elements</label>
                     <div class="input-group mb-2">
                     <button class="btn btn-glow" id="findFirstRepeatingBtn">
                       <i class="fas fa-redo me-2"></i>Find First Repeating Element
                        </button>
                     </div>
                   </div>
                            <div class="mb-3">
                                <label class="form-label">Rearrange Positive & Negative Values</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="rearrangePositiveNegativeBtn">
                                        <i class="fas fa-sort-amount-up me-2"></i>Rearrange Positive & Negative Values
                                    </button>
                                </div>
                                <small class="text-muted">Move all negative values to the front while maintaining relative order</small>
                            </div>
                            
                            <div class="mb-3">
                                <label class="form-label">Segregate Even & Odd Numbers</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="segregateEvenOddBtn">
                                        <i class="fas fa-sort-numeric-up-alt me-2"></i>Segregate Even & Odd Numbers
                                    </button>
                                </div>
                                <small class="text-muted">Move all even numbers to the front while maintaining relative order</small>
                            </div>
                                   <!-- Add this in the Advanced Basic Operations section after the existing buttons -->
                                      <div class="mb-3">
                                       <label class="form-label">In-place Negation</label>
                                       <div class="input-group mb-2">
                                          <button class="btn btn-glow" id="inPlaceNegationBtn">
                                        <i class="fas fa-exchange-alt me-2"></i>In-place Negation
                                              </button>
                                          </div>
                                          <small class="text-muted">Negate every element of a mutable numeric sequence</small>
                                       </div>
                            <div class="algorithm-explanation mt-3">
                                <h6>Sliding Window Algorithms</h6>
                                
                                <div class="mb-3">
                                    <strong>Fixed-size Window:</strong>
                                    <div class="code-snippet">
                                        function maxSumFixedWindow(arr, k) {<br>
                                        &nbsp;&nbsp;let maxSum = 0, currentSum = 0;<br>
                                        &nbsp;&nbsp;// Calculate first window<br>
                                        &nbsp;&nbsp;for (let i = 0; i < k; i++) {<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;currentSum += arr[i];<br>
                                        &nbsp;&nbsp;}<br>
                                        &nbsp;&nbsp;maxSum = currentSum;<br>
                                        &nbsp;&nbsp;// Slide the window<br>
                                        &nbsp;&nbsp;for (let i = k; i < arr.length; i++) {<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;currentSum += arr[i] - arr[i - k];<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;maxSum = Math.max(maxSum, currentSum);<br>
                                        &nbsp;&nbsp;}<br>
                                        &nbsp;&nbsp;return maxSum;<br>
                                        }
                                    </div>
                                </div>
                                
                                <div class="mb-3">
                                    <strong>Variable-size Window:</strong>
                                    <div class="code-snippet">
                                        function longestSubarraySumLeq(arr, target) {<br>
                                        &nbsp;&nbsp;let left = 0, currentSum = 0, maxLength = 0;<br>
                                        &nbsp;&nbsp;for (let right = 0; right < arr.length; right++) {<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;currentSum += arr[right];<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;while (currentSum > target && left <= right) {<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentSum -= arr[left];<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left++;<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;maxLength = Math.max(maxLength, right - left + 1);<br>
                                        &nbsp;&nbsp;}<br>
                                        &nbsp;&nbsp;return maxLength;<br>
                                        }
                                    </div>
                                </div>
                            </div>
                            
                            <div class="algorithm-explanation mt-3">
                                <h6>Dutch National Flag Algorithm (Three-Pointer Technique)</h6>
                                <p>Sorts an array containing only 0s, 1s, and 2s in a single pass using three pointers:</p>
                                
                                <div class="code-snippet">
                                    function dutchNationalFlagSort(arr) {<br>
                                    &nbsp;&nbsp;let low = 0, mid = 0, high = arr.length - 1;<br>
                                    &nbsp;&nbsp;while (mid <= high) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;switch (arr[mid]) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 0: // Found 0<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[arr[low], arr[mid]] = [arr[mid], arr[low]];<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;low++; mid++;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1: // Found 1<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid++;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 2: // Found 2<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[arr[mid], arr[high]] = [arr[high], arr[mid]];<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;high--;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                                    &nbsp;&nbsp;}<br>
                                    &nbsp;&nbsp;return arr;<br>
                                    }
                                </div>
                                
                                <div class="algorithm-step">
                                    <strong>Pointer Roles:</strong>
                                </div>
                                <div class="algorithm-step">
                                     <strong>Low:</strong> Tracks the boundary for 0s (everything before low is 0)
                                </div>
                                <div class="algorithm-step">
                                     <strong>Mid:</strong> Current element being processed (everything between low and mid-1 is 1)
                                </div>
                                <div class="algorithm-step">
                                     <strong>High:</strong> Tracks the boundary for 2s (everything after high is 2)
                                </div>
                                <div class="algorithm-step">
                                    <strong>Time Complexity:</strong> O(n) - Single pass through the array
                                </div>
                                <div class="algorithm-step">
                                    <strong>Space Complexity:</strong> O(1) - In-place sorting
                                </div>
                            </div>
                        </div>  
<!-- Add this tab content after the Advanced Basic Operations tab -->
<div class="tab-pane fade" id="leetcode2" role="tabpanel">
    <div class="mb-3">
        <h5 class="mb-3">Ugly Number Problems</h5>
        
        <!-- Ugly Number Check -->
        <div class="mb-3">
            <label class="form-label">Check Ugly Number</label>
            <div class="input-group mb-2">
                <input type="number" class="form-control" id="uglyNumberInput" placeholder="Enter number to check" min="1">
                <button class="btn btn-glow" id="checkUglyNumberBtn">
                    <i class="fas fa-check-circle me-2"></i>Check Ugly Number
                </button>
            </div>
            <small class="text-muted">An ugly number is a positive number whose prime factors are only 2, 3, and 5</small>
        </div>

        <!-- Nth Ugly Number -->
        <div class="mb-3">
            <label class="form-label">Find Nth Ugly Number</label>
            <div class="input-group mb-2">
                <input type="number" class="form-control" id="nthUglyNumberInput" placeholder="Enter n (1-100)" min="1" max="100">
                <button class="btn btn-glow" id="findNthUglyNumberBtn">
                    <i class="fas fa-sort-numeric-up me-2"></i>Find Nth Ugly Number
                </button>
            </div>
            <small class="text-muted">Find the n-th number whose prime factors are only 2, 3, and 5</small>
        </div>

        <!-- Super Ugly Number -->
        <div class="mb-3">
            <label class="form-label">Find Super Ugly Number</label>
            <div class="input-group mb-2">
                <input type="number" class="form-control" id="superUglyNInput" placeholder="Enter n (1-50)" min="1" max="50">
                <input type="text" class="form-control" id="superUglyPrimesInput" placeholder="Primes (e.g., 2,3,5,7)">
                <button class="btn btn-glow" id="findSuperUglyNumberBtn">
                    <i class="fas fa-star me-2"></i>Find Super Ugly Number
                </button>
            </div>
            <small class="text-muted">Find the n-th number whose prime factors are from given prime list</small>
        </div>

        <!-- Results Display -->
        <div class="algorithm-explanation mt-3" id="uglyNumberResults">
            <h6>Ugly Number Results</h6>
            <div id="uglyNumberOutput" class="mt-2">
                <p class="text-center mb-0">Results will appear here</p>
            </div>
        </div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Special Number Detection</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="findPerfectNumbersBtn">
            <i class="fas fa-calculator me-2"></i>Find Perfect Numbers
        </button>
        <button class="btn btn-glow" id="findArmstrongNumbersBtn">
            <i class="fas fa-square-root-alt me-2"></i>Find Armstrong Numbers
        </button>
    </div>
    <small class="text-muted">Detect special mathematical numbers in the array</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Number Operations</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="numberInput" placeholder="Enter number (0-999999999)" min="0" max="999999999">
        <button class="btn btn-glow" id="convertToEnglishBtn">
            <i class="fas fa-language me-2"></i>Convert to English Words
        </button>
    </div>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="findDigitOneBtn">
            <i class="fas fa-search me-2"></i>Find Digit One in Array
        </button>
    </div>
</div>
<!-- Add this in the Create Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Excel Sheet Column Number</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="excelColumnNumberBtn">
            <i class="fas fa-file-excel me-2"></i>Convert Excel Columns to Numbers
        </button>
    </div>
    <small class="text-muted">Convert Excel column titles (A, AB, ZY) to column numbers</small>
</div>
<!-- Add this in the Create Tab after the Excel Column Number button -->
<div class="mb-3">
    <label class="form-label">Number to Column Title</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="numberToColumnTitleBtn">
            <i class="fas fa-file-excel me-2"></i>Convert Numbers to Excel Columns
        </button>
    </div>
    <small class="text-muted">Convert column numbers to Excel column titles (1A, 28AB, 701ZY)</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Number Theory Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="addDigitsBtn">
            <i class="fas fa-calculator me-2"></i>Add Digits (Digital Root)
        </button>
        <button class="btn btn-glow" id="happyNumberBtn">
            <i class="fas fa-smile me-2"></i>Happy Number Check
        </button>
    </div>
</div>
<!-- Add this in the Create Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Stack Implementation</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="implementStackBtn">
            <i class="fas fa-layer-group me-2"></i>Implement Stack using Arrays
        </button>
    </div>
</div>

<!-- Stack Implementation Interface (initially hidden) -->
<div class="mb-3" id="stackImplementationGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">Stack Size</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="stackSize" placeholder="Enter stack size" min="1" max="50">
            <button class="btn btn-glow" id="createStackBtn">
                <i class="fas fa-plus-circle me-2"></i>Create Stack
            </button>
        </div>
    </div>

    <div class="mb-3" id="stackOperations" style="display: none;">
        <label class="form-label">Stack Operations</label>
        <div class="input-group mb-2">
            <input type="text" class="form-control" id="pushValue" placeholder="Enter value to push">
            <button class="btn btn-glow" id="pushBtn">
                <i class="fas fa-arrow-up me-2"></i>Push
            </button>
        </div>
        
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="popCount" placeholder="Number of pops" min="1" value="1">
            <button class="btn btn-glow" id="popBtn">
                <i class="fas fa-arrow-down me-2"></i>Pop
            </button>
        </div>
        
        <div class="d-grid gap-2">
            <button class="btn btn-glow" id="peekBtn">
                <i class="fas fa-eye me-2"></i>Peek (Top Element)
            </button>
            <button class="btn btn-glow" id="isFullBtn">
                <i class="fas fa-check-circle me-2"></i>Check if Full
            </button>
            <button class="btn btn-glow" id="isEmptyBtn">
                <i class="fas fa-question-circle me-2"></i>Check if Empty
            </button>
        </div>
        
        <div class="d-grid gap-2 mt-2">
            <button class="btn btn-outline-light" id="resetStackBtn">
                <i class="fas fa-undo me-2"></i>Reset Stack
            </button>
        </div>
    </div>


    <div class="stack-info mt-3" id="stackInfo" style="display: none;">
        <div class="stats-card">
            <div>Stack Size</div>
            <div class="stats-value" id="stackSizeValue">0</div>
        </div>
        <div class="stats-card">
            <div>Current Top</div>
            <div class="stats-value" id="stackTopValue">-1</div>
        </div>
        <div class="stats-card">
            <div>Stack Status</div>
            <div class="stats-value" id="stackStatus">Empty</div>
        </div>
    </div>

    <div class="stack-explanation mt-3" id="stackExplanation" style="display: none;">
        <h6>Stack Implementation using Array</h6>
        <p>A stack is a linear data structure that follows the LIFO (Last-In-First-Out) principle.</p>
        
        <div class="code-snippet">
            class Stack {<br>
            &nbsp;&nbsp;constructor(size) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;this.arr = new Array(size);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;this.top = -1;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;this.capacity = size;<br>
            &nbsp;&nbsp;}<br><br>
            
            &nbsp;&nbsp;push(x) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (this.isFull()) throw "Stack Overflow";<br>
            &nbsp;&nbsp;&nbsp;&nbsp;this.arr[++this.top] = x;<br>
            &nbsp;&nbsp;}<br><br>
            
            &nbsp;&nbsp;pop() {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (this.isEmpty()) throw "Stack Underflow";<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return this.arr[this.top--];<br>
            &nbsp;&nbsp;}<br><br>
            
            &nbsp;&nbsp;peek() {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (this.isEmpty()) throw "Stack is Empty";<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return this.arr[this.top];<br>
            &nbsp;&nbsp;}<br>
            }
        </div>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Find Consecutive Number Sequences</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="consecutiveTargetSum" placeholder="Enter target sum">
        <button class="btn btn-glow" id="findConsecutiveSequencesBtn">
            <i class="fas fa-search me-2"></i>Find Consecutive Sequences
        </button>
    </div>
    <small class="text-muted">Find all sequences of consecutive numbers that sum to target</small>
</div>
<!-- Add this in the Create Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Pascal's Triangle</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="pascalRowNumber" placeholder="Row number (0-indexed)" min="0" max="20">
        <button class="btn btn-glow" id="pascalSpecificRowBtn">
            <i class="fas fa-triangle me-2"></i>Pascal's Triangle with Specific Row
        </button>
    </div>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="pascalNumRows" placeholder="Number of rows" min="1" max="10">
        <button class="btn btn-glow" id="pascalMultipleRowsBtn">
            <i class="fas fa-layer-group me-2"></i>Pascal's Triangle with No of Rows
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Random Pick with Weight</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="randomPickWithWeightBtn">
            <i class="fas fa-dice me-2"></i>Random Pick with Weight
        </button>
    </div>
    <small class="text-muted">Randomly select an element based on weights using Cumulative Weights method</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Generate Random Point in Circle</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="generateRandomPointBtn">
            <i class="fas fa-bullseye me-2"></i>Generate Random Point in Circle
        </button>
    </div>
    <small class="text-muted">Uses array elements as center coordinates and radius</small>
</div>

        <!-- Algorithm Explanation -->
        <div class="algorithm-explanation mt-3" id="uglyNumberExplanation">
            <h6>Ugly Number Algorithms</h6>
            
            <div class="mb-3">
                <strong>Ugly Number Check:</strong>
                <div class="code-snippet">
                    function isUgly(num) {<br>
                    &nbsp;&nbsp;if (num <= 0) return false;<br>
                    &nbsp;&nbsp;while (num % 2 === 0) num /= 2;<br>
                    &nbsp;&nbsp;while (num % 3 === 0) num /= 3;<br>
                    &nbsp;&nbsp;while (num % 5 === 0) num /= 5;<br>
                    &nbsp;&nbsp;return num === 1;<br>
                    }
                </div>
            </div>
            
            <div class="mb-3">
                <strong>Nth Ugly Number (Dynamic Programming):</strong>
                <div class="code-snippet">
                    function nthUglyNumber(n) {<br>
                    &nbsp;&nbsp;let ugly = [1];<br>
                    &nbsp;&nbsp;let i2 = 0, i3 = 0, i5 = 0;<br>
                    &nbsp;&nbsp;for (let i = 1; i < n; i++) {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;let next = Math.min(ugly[i2]*2, ugly[i3]*3, ugly[i5]*5);<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;ugly.push(next);<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;if (next === ugly[i2]*2) i2++;<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;if (next === ugly[i3]*3) i3++;<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;if (next === ugly[i5]*5) i5++;<br>
                    &nbsp;&nbsp;}<br>
                    &nbsp;&nbsp;return ugly[n-1];<br>
                    }
                </div>
            </div>
            
            <div class="mb-3">
                <strong>Super Ugly Number:</strong>
                <div class="code-snippet">
                    function superUglyNumber(n, primes) {<br>
                    &nbsp;&nbsp;let ugly = [1];<br>
                    &nbsp;&nbsp;let indices = Array(primes.length).fill(0);<br>
                    &nbsp;&nbsp;for (let i = 1; i < n; i++) {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;let next = Math.min(...primes.map((p, j) => ugly[indices[j]] * p));<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;ugly.push(next);<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;primes.forEach((p, j) => {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (next === ugly[indices[j]] * p) indices[j]++;<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;});<br>
                    &nbsp;&nbsp;}<br>
                    &nbsp;&nbsp;return ugly[n-1];<br>
                    }
                </div>
            </div>
        </div>
    </div>
</div>
<!-- Stock Market Operations Tab -->
<div class="tab-pane fade" id="stockmarket" role="tabpanel">
    <div class="investment-insight">
        <h6><i class="fas fa-chart-line me-2"></i>Investment Analysis Toolkit</h6>
        <p class="mb-0">Professional financial metrics for informed investment decisions</p>
    </div>
    
    <div class="mb-3">
        <label class="form-label">Stock Price Data Input</label>
        <div class="input-group mb-2">
            <input type="text" class="form-control" id="stockPricesInput" placeholder="Enter daily stock prices (e.g., 100, 102, 105, 103, 107)">
            <button class="btn btn-glow" id="loadStockPricesBtn">
                <i class="fas fa-database me-2"></i>Load Price Data
            </button>
        </div>
        <div class="business-insight">
            <strong> Business Context:</strong> Enter historical stock prices to analyze investment performance, volatility, and returns.
        </div>
    </div>
    
    <div class="mb-3">
        <label class="form-label">Financial Analysis Operations</label>
        <div class="row">
            <div class="col-md-6 mb-2">
                <button class="btn btn-glow w-100" id="dailyReturnsBtn">
                    <i class="fas fa-percentage me-2"></i>Daily Returns
                </button>
                <small class="text-muted">Day-to-day percentage changes</small>
            </div>
            <div class="col-md-6 mb-2">
                <button class="btn btn-glow w-100" id="logReturnsBtn">
                    <i class="fas fa-calculator me-2"></i>Log Returns
                </button>
                <small class="text-muted">Continuous compounding returns</small>
            </div>
            <div class="col-md-6 mb-2">
                <button class="btn btn-glow w-100" id="cumulativeReturnsBtn">
                    <i class="fas fa-chart-bar me-2"></i>Cumulative Returns
                </button>
                <small class="text-muted">Total return from start to each point</small>
            </div>
            <div class="col-md-6 mb-2">
                <button class="btn btn-glow w-100" id="totalReturnBtn">
                    <i class="fas fa-chart-pie me-2"></i>Total Return
                </button>
                <small class="text-muted">Overall investment performance</small>
            </div>
            <div class="col-md-12 mb-2">
                <button class="btn btn-glow w-100" id="priceDifferenceBtn">
                    <i class="fas fa-exchange-alt me-2"></i>Price Differences
                </button>
                <small class="text-muted">Daily price movements & volatility</small>
            </div>
                <!-- NEW: Add these 4 new buttons -->
    <div class="col-md-6 mb-2">
        <button class="btn btn-glow w-100" id="priceMomentumBtn">
            <i class="fas fa-rocket me-2"></i>Price Momentum
        </button>
        <small class="text-muted">N-day price momentum</small>
    </div>
    <div class="col-md-6 mb-2">
        <button class="btn btn-glow w-100" id="rateOfChangeBtn">
            <i class="fas fa-tachometer-alt me-2"></i>Rate of Change
        </button>
        <small class="text-muted">ROC percentage indicator</small>
    </div>
    <div class="col-md-6 mb-2">
        <button class="btn btn-glow w-100" id="gapAnalysisBtn">
            <i class="fas fa-arrows-alt-v me-2"></i>Gap Analysis
        </button>
        <small class="text-muted">Opening gap calculations</small>
    </div>
    <div class="col-md-6 mb-2">
        <button class="btn btn-glow w-100" id="intradayGainBtn">
            <i class="fas fa-chart-area me-2"></i>Intraday Gain/Loss
        </button>
        <small class="text-muted">Daily trading performance</small>
    </div>
    <!-- NEW: Technical Indicators -->
    <div class="col-md-6 mb-2">
        <button class="btn btn-glow w-100" id="smaBtn">
            <i class="fas fa-chart-line me-2"></i>Simple Moving Average
        </button>
        <small class="text-muted">SMA - Average price over period</small>
    </div>
    <div class="col-md-6 mb-2">
        <button class="btn btn-glow w-100" id="emaBtn">
            <i class="fas fa-bolt me-2"></i>Exponential Moving Average
        </button>
        <small class="text-muted">EMA - Weighted average</small>
    </div>
    <div class="col-md-6 mb-2">
        <button class="btn btn-glow w-100" id="macdBtn">
            <i class="fas fa-wave-square me-2"></i>MACD Line
        </button>
        <small class="text-muted">MACD - Trend momentum</small>
    </div>
    <div class="col-md-6 mb-2">
        <button class="btn btn-glow w-100" id="macdSignalBtn">
            <i class="fas fa-signal me-2"></i>MACD Signal Line
        </button>
        <small class="text-muted">Signal line for MACD</small>
    </div>
    <div class="col-md-6 mb-2">
        <button class="btn btn-glow w-100" id="bollingerMiddleBtn">
            <i class="fas fa-arrows-alt-h me-2"></i>Bollinger Middle
        </button>
        <small class="text-muted">Bollinger Middle Band</small>
    </div>
    <div class="col-md-6 mb-2">
        <button class="btn btn-glow w-100" id="bollingerUpperBtn">
            <i class="fas fa-arrow-up me-2"></i>Bollinger Upper
        </button>
        <small class="text-muted">Bollinger Upper Band</small>
    </div>
        </div>
    </div>
    
    <div class="financial-summary">
        <h6><i class="fas fa-lightbulb me-2"></i>Key Metrics Explained</h6>
        <div class="performance-metric metric-positive">
            <strong>Daily Returns:</strong> Essential for understanding short-term volatility and daily performance
        </div>
        <div class="performance-metric">
            <strong>Log Returns:</strong> Used in financial modeling for time-series analysis and risk management
        </div>
        <div class="performance-metric metric-positive">
            <strong>Cumulative Returns:</strong> Shows investment growth trajectory over time
        </div>
        <div class="performance-metric">
            <strong>Total Return:</strong> Overall investment performance measurement
        </div>
        <div class="performance-metric">
            <strong>Price Differences:</strong> Reveals daily price movements and market volatility patterns
        </div>
    </div>
</div>
                    <!-- Set Operations Tab -->
                    <div class="tab-pane fade" id="set" role="tabpanel">
                        <div class="mb-3">
                            <label class="form-label">Set Operations</label>
                            <div class="input-group mb-2">
                                <button class="btn btn-glow" id="unionArraysBtn">
                                    <i class="fas fa-object-group me-2"></i>Union of Arrays
                                </button>
                                <button class="btn btn-glow" id="intersectionArraysBtn">
                                    <i class="fas fa-bezier-curve me-2"></i>Intersection of Arrays
                                </button>
                            </div>
                        </div>

                        <!-- Set Operations Input Group (initially hidden) -->
                        <div class="mb-3" id="setOperationsGroup" style="display: none;">
                            <div class="mb-3">
                                <label class="form-label">Number of Arrays</label>
                                <div class="input-group mb-2">
                                    <input type="number" class="form-control" id="numArrays" placeholder="Enter number of arrays (1-3)" min="1" max="3">
                                    <button class="btn btn-glow" id="confirmNumArraysBtn">
                                        <i class="fas fa-check me-2"></i>Confirm Number of Arrays
                                    </button>
                                </div>
                            </div>

                            <!-- Dynamic array inputs will be inserted here -->
                            <div id="setArraysInputs" class="mt-2"></div>

                            <div class="d-grid gap-2">
                                <button class="btn btn-glow" id="performSetOperationBtn" style="display: none;">
                                    <i class="fas fa-play me-2"></i>Perform Set Operation
                                </button>
                                <button class="btn btn-outline-light" id="cancelSetOperationBtn">
                                    <i class="fas fa-times me-2"></i>Cancel Set Operation
                                </button>
                            </div>
                        </div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Set Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="setDifferenceBtn">
            <i class="fas fa-minus-circle me-2"></i>Set Difference (A - B)
        </button>
        <button class="btn btn-glow" id="symmetricDifferenceBtn">
            <i class="fas fa-exchange-alt me-2"></i>Symmetric Difference
        </button>
    </div>
</div>

<!-- Set Operations Input Group (initially hidden) -->
<div class="mb-3" id="setOperationsGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">Set Operation Details</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="numArrays" placeholder="Number of arrays (2)" min="2" max="2" value="2">
            <button class="btn btn-glow" id="confirmNumArraysBtn">
                <i class="fas fa-check me-2"></i>Confirm Number of Arrays
            </button>
        </div>
        <small class="text-muted">Set operations work with exactly 2 arrays</small>
    </div>

    <div id="setArraysInputs" class="mt-2"></div>

    <div class="d-grid gap-2 mt-3">
        <button class="btn btn-glow" id="performSetOperationBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Perform Set Operation
        </button>
        <button class="btn btn-outline-light" id="cancelSetOperationBtn">
            <i class="fas fa-times me-2"></i>Cancel Set Operation
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Set Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="checkSubsetCompBtn">
            <i class="fas fa-subscript me-2"></i>Check if Array is Subset
        </button>
        <button class="btn btn-glow" id="checkSupersetCompBtn">
            <i class="fas fa-superscript me-2"></i>Check if Array is Superset
        </button>
    </div>
</div>

<!-- Subset Comparison Input Group -->
<div class="mb-3" id="subsetCompInputGroup" style="display: none;">
    <label class="form-label">Subset Comparison - Enter Number of Arrays</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="numArraysSubsetComp" placeholder="Number of arrays (2)" min="2" max="5" value="2">
        <button class="btn btn-glow" id="confirmNumArraysSubsetCompBtn">
            <i class="fas fa-check me-2"></i>Confirm Number of Arrays
        </button>
    </div>
    
    <div id="subsetCompArraysInputs" class="mt-3"></div>
    
    <div class="d-grid gap-2 mt-3">
        <button class="btn btn-glow" id="performSubsetCompBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Perform Subset Check
        </button>
        <button class="btn btn-outline-light" id="cancelSubsetCompBtn">
            <i class="fas fa-times me-2"></i>Cancel Subset Check
        </button>
    </div>
</div>

<!-- Superset Comparison Input Group -->
<div class="mb-3" id="supersetCompInputGroup" style="display: none;">
    <label class="form-label">Superset Comparison - Enter Number of Arrays</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="numArraysSupersetComp" placeholder="Number of arrays (2)" min="2" max="5" value="2">
        <button class="btn btn-glow" id="confirmNumArraysSupersetCompBtn">
            <i class="fas fa-check me-2"></i>Confirm Number of Arrays
        </button>
    </div>
    
    <div id="supersetCompArraysInputs" class="mt-3"></div>
    
    <div class="d-grid gap-2 mt-3">
        <button class="btn btn-glow" id="performSupersetCompBtn" style="display: none;">
            <i class="fas fa-play me-2"></i>Perform Superset Check
        </button>
        <button class="btn btn-outline-light" id="cancelSupersetCompBtn">
            <i class="fas fa-times me-2"></i>Cancel Superset Check
        </button>
    </div>
</div>
                        <div class="algorithm-explanation mt-3">
                            <h6>Set Operations Algorithms</h6>
                            
                            <div class="mb-3">
                                <strong>Union of Arrays:</strong>
                                <div class="code-snippet">
                                    function unionArrays(arrays) {<br>
                                    &nbsp;&nbsp;let unionSet = new Set();<br>
                                    &nbsp;&nbsp;for (let arr of arrays) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;for (let element of arr) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unionSet.add(element);<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                                    &nbsp;&nbsp;}<br>
                                    &nbsp;&nbsp;return Array.from(unionSet);<br>
                                    }
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <strong>Intersection of Arrays:</strong>
                                <div class="code-snippet">
                                    function intersectionArrays(arrays) {<br>
                                    &nbsp;&nbsp;if (arrays.length === 0) return [];<br>
                                    &nbsp;&nbsp;let intersection = arrays[0];<br>
                                    &nbsp;&nbsp;for (let i = 1; i < arrays.length; i++) {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;intersection = intersection.filter(<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element => arrays[i].includes(element)<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;);<br>
                                    &nbsp;&nbsp;}<br>
                                    &nbsp;&nbsp;return [...new Set(intersection)];<br>
                                    }
                                </div>
                            </div>
                        </div>
                    </div>
                        <!-- Leetcode Problems Tab -->
         <div class="tab-pane fade" id="leetcode" role="tabpanel">
          <div class="mb-3">
          <label class="form-label">Leetcode Array Problems</label>
         <div class="input-group mb-2">
            <button class="btn btn-glow" id="containerWithMostWaterBtn">
                <i class="fas fa-tint me-2"></i>Container With Most Water
            </button>
            <button class="btn btn-glow" id="trappingRainWaterBtn">
                <i class="fas fa-cloud-rain me-2"></i>Trapping Rain Water
            </button>
          </div>
           <small class="text-muted">Solve famous Leetcode array problems with visualizations</small>
         </div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Valid Parentheses Check</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="parenthesesInput" placeholder="Enter string with only {} parentheses">
        <button class="btn btn-glow" id="validParenthesesBtn">
            <i class="fas fa-check-circle me-2"></i>Valid Parentheses
        </button>
    </div>
    <small class="text-muted">Enter a string containing only curly braces {} to validate parentheses</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Substring with Concatenation of All Words</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="findWordConcatenationBtn">
            <i class="fas fa-link me-2"></i>Find Word Concatenation Substrings
        </button>
    </div>
</div>

<!-- Word Concatenation Input Group (initially hidden) -->
<div class="mb-3" id="wordConcatInputSection" style="display: none;">
    <div class="mb-3">
        <label class="form-label">Enter Text String</label>
        <input type="text" class="form-control" id="textStringInputField" placeholder="e.g., barfoothefoobarman">
    </div>
    
    <div class="mb-3">
        <label class="form-label">Enter Search Words (comma-separated)</label>
        <input type="text" class="form-control" id="searchWordsInputField" placeholder="e.g., foo,bar">
    </div>
    
    <div class="d-grid gap-2">
        <button class="btn btn-glow" id="runWordConcatSearchBtn">
            <i class="fas fa-play me-2"></i>Find Concatenated Substrings
        </button>
        <button class="btn btn-outline-light" id="stopWordConcatSearchBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>
<!-- Add this in the Search Tab after the existing search sections -->
<div class="mb-3">
    <label class="form-label">Find First & Last Position in Sorted Array</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="firstLastTarget" placeholder="Enter target element">
        <button class="btn btn-glow" id="findFirstLastBtn">
            <i class="fas fa-search me-2"></i>Find First & Last Position
        </button>
    </div>
    <small class="text-muted">Uses binary search to find first and last occurrence in sorted array</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">String Algorithms</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="longestValidParenthesesBtn">
            <i class="fas fa-parentheses me-2"></i>Find Longest Valid Parentheses
        </button>
        <button class="btn btn-glow" id="distinctSubsequencesBtn">
            <i class="fas fa-code-branch me-2"></i>Find Distinct Subsequences
        </button>
    </div>
</div>

<!-- Longest Valid Parentheses Input Group -->
<div class="mb-3" id="parenthesesInputGroup" style="display: none;">
    <label class="form-label">Enter Parentheses String</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="lvpInput" 
               placeholder="e.g., (( ) ) ( ( ) )" maxlength="50">
        <button class="btn btn-glow" id="confirmParenthesesBtn">
            <i class="fas fa-play me-2"></i>Find Longest Valid
        </button>
        <button class="btn btn-outline-light" id="cancelParenthesesBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
    <small class="text-muted">Enter string containing only '(' and ')' characters</small>
</div>

<!-- Distinct Subsequences Input Group -->
<div class="mb-3" id="subsequencesInputGroup" style="display: none;">
    <label class="form-label">Enter Strings for Distinct Subsequences</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="dsMainStringInput" 
               placeholder="Main string (s)" maxlength="30">
        <input type="text" class="form-control" id="dsTargetStringInput" 
               placeholder="Target string (t)" maxlength="20">
    </div>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="confirmSubsequencesBtn">
            <i class="fas fa-play me-2"></i>Find Distinct Subsequences
        </button>
        <button class="btn btn-outline-light" id="cancelSubsequencesBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
    <small class="text-muted">Count how many times target string appears as subsequence in main string</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">String Operations</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="checkPalindromeBtn">
            <i class="fas fa-check-circle me-2"></i>Check Valid Palindrome
        </button>
        <button class="btn btn-glow" id="findAnagramsBtn">
            <i class="fas fa-search me-2"></i>Find All Anagrams
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after Kadane's Algorithm -->
<div class="mb-3">
    <label class="form-label">Palindrome Operations</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="palindromeInput" placeholder="Enter a string">
        <button class="btn btn-glow" id="findPalindromicSubstringsBtn">
            <i class="fas fa-palindrome me-2"></i>Find Palindromic Substrings
        </button>
    </div>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="longestPalindromeInput" placeholder="Enter a string" value="">
        <button class="btn btn-glow" id="findLongestPalindromicSubstringBtn">
            <i class="fas fa-search-plus me-2"></i>Find Longest Palindromic Substring
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Backtracking Algorithms</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="combinationSumBtn">
            <i class="fas fa-calculator me-2"></i>Find Combination Sum
        </button>
        <button class="btn btn-glow" id="subsetsBtn">
            <i class="fas fa-layer-group me-2"></i>Find Subsets
        </button>
    </div>
</div>
<!-- Combination Sum Input Group -->
<div class="mb-3" id="combinationSumGroup" style="display: none;">
    <label class="form-label">Combination Sum Target</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="combinationSumTarget" placeholder="Enter target sum">
        <button class="btn btn-glow" id="confirmCombinationSumBtn">
            <i class="fas fa-play me-2"></i>Find Combinations
        </button>
        <button class="btn btn-outline-light" id="cancelCombinationSumBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>
<!-- Add these buttons in the Advanced Basic Operations Tab -->
<div class="mb-3">
    <label class="form-label">Pattern Matching Algorithms</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="wildcardMatchingBtn">
            <i class="fas fa-asterisk me-2"></i>Wildcard Matching
        </button>
        <button class="btn btn-glow" id="regexMatchingBtn">
            <i class="fas fa-code me-2"></i>Regular Expression Matching
        </button>
    </div>
</div>

<!-- Add this input group for pattern matching (initially hidden) -->
<div class="mb-3" id="patternMatchingGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label" id="patternMatchingLabel">Pattern Matching Details</label>
        <div class="input-group mb-2">
            <input type="text" class="form-control" id="patternString" placeholder="Enter string (e.g., abcc)">
            <input type="text" class="form-control" id="patternPattern" placeholder="Enter pattern (e.g., a*b*)">
            <button class="btn btn-glow" id="confirmPatternMatchingBtn">
                <i class="fas fa-play me-2"></i>Start Pattern Matching
            </button>
        </div>
    </div>
    
    <div class="d-grid gap-2">
        <button class="btn btn-outline-light" id="cancelPatternMatchingBtn">
            <i class="fas fa-times me-2"></i>Cancel Pattern Matching
        </button>
    </div>
</div>
   <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
   <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
    <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
        <div class="mb-3">
        <label class="form-label">LeetCode Problems</label>
        <div class="input-group mb-2">
        <button class="btn btn-glow" id="jumpGameBtn">
            <i class="fas fa-gamepad me-2"></i>Jump Game (Can Reach End?)
        </button>
      </div>
      <small class="text-muted">Determine if you can reach the last index starting from first index</small>
      </div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Stock Buy/Sell Problem</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="bestTimeStockBtn">
            <i class="fas fa-chart-line me-2"></i>Best Time to Buy & Sell Stock
        </button>
    </div>
    <small class="text-muted">Find maximum profit from daily stock prices (LeetCode #121)</small>
</div>
// Add this in the algorithm explanation section
<div class="algorithm-explanation mt-3" id="stockAlgorithmExplanation">
    <h6>Best Time to Buy and Sell Stock Algorithm</h6>
    <p>Find the maximum profit by buying low and selling high. You can only make one transaction.</p>
    
    <div class="code-snippet">
        function maxProfit(prices) {<br>
        &nbsp;&nbsp;let minPrice = Infinity;<br>
        &nbsp;&nbsp;let maxProfit = 0;<br>
        &nbsp;&nbsp;for (let i = 0; i < prices.length; i++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (prices[i] < minPrice) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minPrice = prices[i];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;} else if (prices[i] - minPrice > maxProfit) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxProfit = prices[i] - minPrice;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;}<br>
        &nbsp;&nbsp;return maxProfit;<br>
        }
    </div>
    
    <div id="stockAlgorithmSteps">
        <div class="algorithm-step">
            <strong>Step 1:</strong> Initialize minPrice to infinity and maxProfit to 0
        </div>
        <div class="algorithm-step">
            <strong>Step 2:</strong> Iterate through each day's price
        </div>
        <div class="algorithm-step">
            <strong>Step 3:</strong> Update minPrice if current price is lower
        </div>
        <div class="algorithm-step">
            <strong>Step 4:</strong> Calculate potential profit and update maxProfit if higher
        </div>
        <div class="algorithm-step">
            <strong>Step 5:</strong> Return the maximum profit found
        </div>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Minimum Window Substring</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="minWindowSubstringBtn">
            <i class="fas fa-window-restore me-2"></i>Find Minimum Window Substring
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Daily Temperatures Algorithm</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="dailyTemperaturesBtn">
            <i class="fas fa-thermometer-half me-2"></i>Daily Temperatures
        </button>
    </div>
    <small class="text-muted">Find days until warmer temperature for each day</small>
</div>
<!-- Add this in the Create Tab after Clone Array Operation section -->
<div class="mb-3">
    <label class="form-label">Range Sum Query</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="rangeSumStart" placeholder="Start index" min="0">
        <input type="number" class="form-control" id="rangeSumEnd" placeholder="End index" min="0">
        <button class="btn btn-glow" id="rangeSumQueryBtn">
            <i class="fas fa-calculator me-2"></i>Calculate Range Sum
        </button>
    </div>
    <small class="text-muted">Calculate sum of elements from start to end index (inclusive)</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Maximum Subarray Problems</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="maxSubarraySumBtn">
            <i class="fas fa-chart-line me-2"></i>Maximum Subarray (Kadane's Algorithm)
        </button>
        <button class="btn btn-glow" id="maxProductSubarrayBtn">
            <i class="fas fa-times-circle me-2"></i>Maximum Product Subarray
        </button>
    </div>
</div>
<!-- Input Groups for Minimum Window Substring (initially hidden) -->
<div class="mb-3" id="minWindowGroup" style="display: none;">
    <div class="mb-3">
        <label class="form-label">Enter Strings</label>
        <div class="input-group mb-2">
            <input type="text" class="form-control" id="mainStringInput" placeholder="Main string (s)">
        </div>
        <div class="input-group mb-2">
            <input type="text" class="form-control" id="targetStringInput" placeholder="Target string (t)">
        </div>
    </div>

    <div class="d-grid gap-2">
        <button class="btn btn-glow" id="performMinWindowBtn">
            <i class="fas fa-play me-2"></i>Find Minimum Window
        </button>
        <button class="btn btn-outline-light" id="cancelMinWindowBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Leetcode Problems - Merge Intervals</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="mergeIntervalsBtn">
            <i class="fas fa-object-group me-2"></i>Merge Intervals
        </button>
    </div>
    <small class="text-muted">Given a collection of intervals, merge all overlapping intervals</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Count of Smaller Numbers After Self</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="countSmallerAfterSelfBtn">
            <i class="fas fa-sort-numeric-down me-2"></i>Find Count of Smaller Numbers After Self
        </button>
    </div>
    <small class="text-muted">For each element, count how many elements to the right are smaller</small>
</div>
<div class="mb-3">
    <label class="form-label">Longest Substring Without Repeating Characters</label>
    <div class="input-group mb-2">
        <input type="text" class="form-control" id="substringInput" placeholder="Enter string (e.g., abcabcbb)">
        <button class="btn btn-glow" id="findLongestSubstringBtn">
            <i class="fas fa-search me-2"></i>Find Longest Substring
        </button>
    </div>
    <small class="text-muted">Find the length of the longest substring without repeating characters</small>
</div>
<!-- Longest Substring Results (initially hidden) -->
<div class="subarrays-results" id="longestSubstringResults" style="display: none;">
    <h6>Longest Substring Results</h6>
    <div class="stats-card">
        <div>Longest Substring Length</div>
        <div class="stats-value" id="longestSubstringLength">0</div>
    </div>
    <div class="stats-card mt-2">
        <div>Longest Substring Found</div>
        <div class="stats-value" id="longestSubstringValue">-</div>
    </div>
    <div id="longestSubstringSteps" class="mt-3"></div>
</div>
<!-- Longest Substring Results (initially hidden) -->
<div class="subarrays-results" id="longestSubstringResults" style="display: none;">
    <h6>Longest Substring Results</h6>
    <div class="stats-card">
        <div>Longest Substring Length</div>
        <div class="stats-value" id="longestSubstringLength">0</div>
    </div>
    <div class="stats-card mt-2">
        <div>Longest Substring Found</div>
        <div class="stats-value" id="longestSubstringValue">-</div>
    </div>
    <div id="longestSubstringSteps" class="mt-3"></div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the algorithm explanations -->
<div class="algorithm-explanation mt-3">
    <h6>Longest Substring Without Repeating Characters Algorithm</h6>
    
    <div class="code-snippet">
        function lengthOfLongestSubstring(s) {<br>
        &nbsp;&nbsp;let maxLength = 0;<br>
        &nbsp;&nbsp;let start = 0;<br>
        &nbsp;&nbsp;let charMap = new Map();<br>
        &nbsp;&nbsp;<br>
        &nbsp;&nbsp;for (let end = 0; end < s.length; end++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (charMap.has(s[end]) && charMap.get(s[end]) >= start) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start = charMap.get(s[end]) + 1;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;&nbsp;&nbsp;charMap.set(s[end], end);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;maxLength = Math.max(maxLength, end - start + 1);<br>
        &nbsp;&nbsp;}<br>
        &nbsp;&nbsp;return maxLength;<br>
        }
    </div>
    
    <div class="mt-3">
        <strong>Algorithm Steps:</strong>
        <div class="algorithm-step">
            <strong>Step 1:</strong> Initialize start pointer, maxLength, and character map
        </div>
        <div class="algorithm-step">
            <strong>Step 2:</strong> Iterate through string with end pointer
        </div>
        <div class="algorithm-step">
            <strong>Step 3:</strong> If duplicate found within current window, move start pointer
        </div>
        <div class="algorithm-step">
            <strong>Step 4:</strong> Update character's last seen position
        </div>
        <div class="algorithm-step">
            <strong>Step 5:</strong> Update maxLength if current window is longer
        </div>
        <div class="algorithm-step">
            <strong>Step 6:</strong> Return maxLength when iteration completes
        </div>
    </div>
</div>
<div class="mb-3">
    <label class="form-label">LeetCode Problems - Two Sum</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="twoSumBtn">
            <i class="fas fa-bullseye me-2"></i>Two Sum Problem
        </button>
    </div>
</div>
<!-- Two Sum Input Group (initially hidden) -->
<div class="mb-3" id="twoSumInputGroup" style="display: none;">
    <label class="form-label">Enter Target Sum for Two Sum</label>
    <div class="input-group mb-2">
        <input type="number" class="form-control" id="twoSumTarget" placeholder="Enter target sum">
        <button class="btn btn-glow" id="confirmTwoSumBtn">
            <i class="fas fa-play me-2"></i>Find Two Sum
        </button>
        <button class="btn btn-outline-light" id="cancelTwoSumBtn">
            <i class="fas fa-times me-2"></i>Cancel
        </button>
    </div>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Fruit Into Baskets Problem</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="fruitIntoBasketsBtn">
            <i class="fas fa-apple-alt me-2"></i>Fruit Into Baskets
        </button>
    </div>
    <small class="text-muted">Find maximum fruits you can pick with two baskets</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Array Transformation</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="transformNonDecreasingBtn">
            <i class="fas fa-sort-amount-up me-2"></i>Transform to Non-Decreasing Array
        </button>
    </div>
    <small class="text-muted">Convert array to non-decreasing using Greedy + Prefix Sum approach</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Stock Span Problem</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="stockSpanBtn">
            <i class="fas fa-chart-line me-2"></i>Calculate Stock Span
        </button>
    </div>
    <small class="text-muted">Calculate span values using monotonic stack approach</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Histogram Problems</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="largestRectangleHistogramBtn">
            <i class="fas fa-chart-bar me-2"></i>Find Largest Rectangle in Histogram
        </button>
    </div>
    <small class="text-muted">Calculate maximum rectangular area in histogram using stack</small>
</div>
<!-- Add this in the Advanced Basic Operations Tab after the existing content -->
<div class="mb-3">
    <label class="form-label">Next Permutation</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="nextPermutationBtn">
            <i class="fas fa-sort-amount-up me-2"></i>Find Next Permutation
        </button>
    </div>
    <small class="text-muted">Rearranges array into lexicographically next greater permutation</small>
</div>
<!-- Add this in the algorithm explanation section if desired -->
<div class="algorithm-explanation mt-3" id="twoSumAlgorithmExplanation">
    <h6>Two Sum Algorithm</h6>
    <p>Find all pairs of indices where the sum of elements equals the target.</p>
    
    <div class="code-snippet">
        function twoSum(arr, target) {<br>
        &nbsp;&nbsp;let pairs = [];<br>
        &nbsp;&nbsp;for (let i = 0; i < arr.length; i++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;for (let j = i + 1; j < arr.length; j++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (arr[i] + arr[j] === target) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pairs.push([i, j]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;}<br>
        &nbsp;&nbsp;return pairs;<br>
        }
    </div>
</div>        
        <div class="mb-3">
            <strong>Trapping Rain Water:</strong>
            <p class="mb-2">Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.</p>
            <div class="code-snippet">
                function trap(height) {<br>
                &nbsp;&nbsp;let left = 0, right = height.length - 1;<br>
                &nbsp;&nbsp;let leftMax = 0, rightMax = 0;<br>
                &nbsp;&nbsp;let water = 0;<br>
                &nbsp;&nbsp;while (left < right) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;if (height[left] < height[right]) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftMax = Math.max(leftMax, height[left]);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;water += leftMax - height[left];<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left++;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rightMax = Math.max(rightMax, height[right]);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;water += rightMax - height[right];<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right--;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                &nbsp;&nbsp;}<br>
                &nbsp;&nbsp;return water;<br>
                }
            </div>
        </div>
        <div class="algorithm-explanation mt-3">
    <h6>Stock Span Problem Algorithm</h6>
    <p>The stock span problem calculates for each day, the number of consecutive days (including current day) 
    for which the stock price was less than or equal to the current day's price.</p>
    
    <div class="code-snippet">
        function calculateStockSpan(prices) {<br>
        &nbsp;&nbsp;let spans = new Array(prices.length);<br>
        &nbsp;&nbsp;let stack = []; // monotonic stack (decreasing order)<br>
        &nbsp;&nbsp;<br>
        &nbsp;&nbsp;for (let i = 0; i < prices.length; i++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;// Pop while stack is not empty and top <= current<br>
        &nbsp;&nbsp;&nbsp;&nbsp;while (stack.length > 0 && prices[stack[stack.length-1]] <= prices[i]) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.pop();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;&nbsp;&nbsp;// Calculate span<br>
        &nbsp;&nbsp;&nbsp;&nbsp;spans[i] = stack.length === 0 ? i + 1 : i - stack[stack.length-1];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;// Push current index to stack<br>
        &nbsp;&nbsp;&nbsp;&nbsp;stack.push(i);<br>
        &nbsp;&nbsp;}<br>
        &nbsp;&nbsp;return spans;<br>
        }
    </div>
    
    <div class="algorithm-step active">
        <strong>Key Points:</strong>
    </div>
    <div class="algorithm-step">
         Uses a monotonic stack (decreasing order of prices)
    </div>
    <div class="algorithm-step">
         Time Complexity: O(n) - each element pushed and popped once
    </div>
    <div class="algorithm-step">
         Space Complexity: O(n) for the stack
    </div>
</div>
    </div>
</div>

                        <!-- Advanced Sorting Tab -->
                        <div class="tab-pane fade" id="advanced-sorting" role="tabpanel">
                            <div class="mb-3">
                                <label class="form-label">Advanced Sorting Algorithms</label>
                                <div class="input-group mb-2">
                                    <button class="btn btn-glow" id="selectionSortBtn">
                                        <i class="fas fa-sort-amount-down me-2"></i>Selection Sort
                                    </button>
                                    <button class="btn btn-glow" id="insertionSortBtn">
                                        <i class="fas fa-sort-numeric-up me-2"></i>Insertion Sort
                                    </button>
                                </div>
                                <small class="text-muted">Visualize advanced sorting algorithms with step-by-step animations</small>
                            </div>
                            
                            <div class="algorithm-explanation mt-3" id="advancedSortingExplanation">
                                <h6>Advanced Sorting Algorithms</h6>
                                
                                <div class="mb-3">
                                    <strong>Selection Sort:</strong>
                                    <div class="code-snippet">
                                        function selectionSort(arr) {<br>
                                        &nbsp;&nbsp;let n = arr.length;<br>
                                        &nbsp;&nbsp;for (let i = 0; i < n-1; i++) {<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;let minIdx = i;<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;for (let j = i+1; j < n; j++) {<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (arr[j] < arr[minIdx]) {<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minIdx = j;<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;[arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];<br>
                                        &nbsp;&nbsp;}<br>
                                        &nbsp;&nbsp;return arr;<br>
                                        }
                                    </div>
                                </div>
                                <!-- Add this in the Advanced Basic Operations Tab after the existing content -->
                                <!-- Add this in the Create Tab after the existing sorting buttons -->
<div class="mb-3">
    <label class="form-label">Ultra Advanced Sorting Algorithms </label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="quickSortBtn">
            <i class="fas fa-bolt me-2"></i>Quick Sort
        </button>
        <button class="btn btn-glow" id="heapSortBtn">
            <i class="fas fa-layer-group me-2"></i>Heap Sort
        </button>
    </div>
</div>

<div class="mb-3">
    <label class="form-label">Custom Comparator Sort</label>
    <div class="input-group mb-2">
        <button class="btn btn-glow" id="customComparatorSortBtn">
            <i class="fas fa-sort-alpha-down me-2"></i>Custom Comparator Sort
        </button>
    </div>
</div>

<!-- Custom Comparator Sort Container (initially hidden) -->
<div class="custom-comparator-container" id="customComparatorContainer" style="display: none;">
    <h5 class="text-center mb-3">Custom Comparator Sort</h5>
    
    <!-- Dictionary Creation Section -->
    <div class="mb-3" id="dictionaryCreationSection">
        <label class="form-label">Create Dictionary</label>
        <div class="input-group mb-2">
            <input type="text" class="form-control" id="dictionaryName" placeholder="Enter dictionary name">
            <button class="btn btn-glow" id="createDictionaryBtn">
                <i class="fas fa-plus me-2"></i>Create Dictionary
            </button>
        </div>
    </div>

    <!-- Dictionary Structure Section (initially hidden) -->
    <div class="mb-3" id="dictionaryStructureSection" style="display: none;">
        <label class="form-label">Define Dictionary Structure</label>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="fieldCount" placeholder="Number of fields" min="1" max="10">
            <button class="btn btn-glow" id="confirmFieldCountBtn">
                <i class="fas fa-check me-2"></i>Confirm Field Count
            </button>
        </div>
        <div id="fieldDefinitions" class="mt-3"></div>
    </div>

    <!-- Data Entry Section (initially hidden) -->
    <div class="mb-3" id="dataEntrySection" style="display: none;">
        <label class="form-label">Add Data Records</label>
        <div id="dataEntryForm" class="mb-3"></div>
        <button class="btn btn-glow" id="addRecordBtn">
            <i class="fas fa-plus-circle me-2"></i>Add Record
        </button>
        <button class="btn btn-glow" id="finishDataEntryBtn">
            <i class="fas fa-check-double me-2"></i>Finish Data Entry
        </button>
    </div>

    <!-- Dictionary Operations Section (initially hidden) -->
    <div class="mb-3" id="dictionaryOperationsSection" style="display: none;">
        <label class="form-label">Dictionary Operations</label>
        <div class="d-flex gap-2 mb-3">
            <button class="btn btn-glow" id="updateDictionaryBtn">
                <i class="fas fa-edit me-2"></i>Update Dictionary
            </button>
            <button class="btn btn-glow" id="dropDictionaryBtn">
                <i class="fas fa-trash me-2"></i>Drop Dictionary
            </button>
        </div>
        
        <!-- Sort Configuration -->
        <div class="sort-configuration">
            <h6>Sort Configuration</h6>
            <div class="row mb-3">
                <div class="col-md-5">
                    <label class="form-label">Sort By Field</label>
                    <select class="form-control" id="sortFieldSelect"></select>
                </div>
                <div class="col-md-5">
                    <label class="form-label">Order By</label>
                    <select class="form-control" id="sortOrderSelect">
                        <option value="asc">Ascending</option>
                        <option value="desc">Descending</option>
                    </select>
                </div>
                <div class="col-md-2">
                    <label class="form-label">&nbsp;</label>
                    <button class="btn btn-glow w-100" id="performSortBtn">
                        <i class="fas fa-play me-1"></i>Sort
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Dictionary Display Section -->
    <div id="dictionaryDisplaySection" style="display: none;">
        <h6>Dictionary Data</h6>
        <div class="table-container" id="dictionaryTableContainer">
            <table class="dictionary-table" id="dictionaryTable">
                <thead>
                    <tr id="dictionaryTableHeader"></tr>
                </thead>
                <tbody id="dictionaryTableBody"></tbody>
            </table>
        </div>
    </div>

    <!-- Sort Visualization Section -->
    <div id="sortVisualizationSection" style="display: none;">
        <h6 class="text-center">Sorting Process Visualization</h6>
        <div class="algorithm-explanation" id="sortAlgorithmExplanation">
            <p id="sortExplanationText">Starting custom comparator sort...</p>
            <div id="sortStepsContainer" class="mt-3"></div>
        </div>
        <button class="btn btn-sm btn-outline-light mt-3" id="resetAfterSortBtn">
            <i class="fas fa-undo me-1"></i>Return to Original Order
        </button>
    </div>

    <!-- Cancel Button -->
    <div class="text-center mt-3">
        <button class="btn btn-outline-light" id="cancelCustomSortBtn">
            <i class="fas fa-times me-2"></i>Cancel Custom Sort
        </button>
    </div>
</div>
                                <div class="mb-3">
                                    <strong>Insertion Sort:</strong>
                                    <div class="code-snippet">
                                        function insertionSort(arr) {<br>
                                        &nbsp;&nbsp;let n = arr.length;<br>
                                        &nbsp;&nbsp;for (let i = 1; i < n; i++) {<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;let key = arr[i];<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;let j = i - 1;<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;while (j >= 0 && arr[j] > key) {<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j+1] = arr[j];<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j--;<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;arr[j+1] = key;<br>
                                        &nbsp;&nbsp;}<br>
                                        &nbsp;&nbsp;return arr;<br>
                                        }
                                    </div>
                                </div>
                                
                                <div id="advancedSortingSteps">
                                    <div class="algorithm-step">
                                        <strong>Selection Sort Steps:</strong>
                                    </div>
                                    <div class="algorithm-step">
                                         Find the minimum element in the unsorted portion
                                    </div>
                                    <div class="algorithm-step">
                                         Swap it with the first element of the unsorted portion
                                    </div>
                                    <div class="algorithm-step">
                                         Move the boundary between sorted and unsorted portions one element to the right
                                    </div>
                                    <div class="algorithm-step">
                                         Repeat until the entire array is sorted
                                    </div>
                                    
                                    <div class="algorithm-step mt-2">
                                        <strong>Insertion Sort Steps:</strong>
                                    </div>
                                    <div class="algorithm-step">
                                         Start with the second element as the key
                                    </div>
                                    <div class="algorithm-step">
                                         Compare the key with elements in the sorted portion to its left
                                    </div>
                                    <div class="algorithm-step">
                                         Shift elements greater than the key one position to the right
                                    </div>
                                    <div class="algorithm-step">
                                         Insert the key in its correct position
                                    </div>
                                    <div class="algorithm-step">
                                         Repeat for all elements
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="glass-card mt-4">
                    <h5 class="mb-3">Operation Log</h5>
                    <div class="operation-log" id="operationLog">
                        <!-- Operation logs will appear here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Array to store our data
        let myArray = [];
        let operationCount = 0;
        let isLinearSearchRunning = false;
        
        // DOM Elements
        const arrayContainer = document.getElementById('arrayContainer');
        const arrayLength = document.getElementById('arrayLength');
        const firstElement = document.getElementById('firstElement');
        const lastElement = document.getElementById('lastElement');
        const totalOperations = document.getElementById('totalOperations');
        const operationLog = document.getElementById('operationLog');
        const searchResults = document.getElementById('searchResults');
        const algorithmSteps = document.getElementById('algorithmSteps');
        // Add these with other input elements
const arraySize = document.getElementById('arraySize');
const resizeSize = document.getElementById('resizeSize');

// Add these with other button elements
const createArrayFromRangeBtn = document.getElementById('createArrayFromRangeBtn');
const resizeArrayBtn = document.getElementById('resizeArrayBtn');
// Add these with other input elements
const sliceStart = document.getElementById('sliceStart');
const sliceEnd = document.getElementById('sliceEnd');
const sumElements = document.getElementById('sumElements');
const productElements = document.getElementById('productElements');
// Add these with other button elements
const sliceBtn = document.getElementById('sliceBtn');
const resetArrayBtn = document.getElementById('resetArrayBtn');
// Add with other button elements
const shiftLeftBtn = document.getElementById('shiftLeftBtn');
const shiftRightBtn = document.getElementById('shiftRightBtn');
const resetShiftBtn = document.getElementById('resetShiftBtn');
const popLastBtn = document.getElementById('popLastBtn');
// Add with other input elements
const cloneIndex = document.getElementById('cloneIndex');
const cloneElementValue = document.getElementById('cloneElementValue');
const cloneArrayBtn = document.getElementById('cloneArrayBtn');

// Add these with other data variables
let originalArray = []; // To store the original array
let isSubarray = false; // To track if we're viewing a subarray

// Add with other variables
let isBinarySearchRunning = false;
let sortedArrayBackup = []; // To store original array during binary search
let isCurrentlySorted = false; // Track if array is currently sorted
// Add with other data variables
let originalArrayForShift = []; // To store original array for shift operations
let isShifted = false; // Track if array is currently shifted
// Add with other data variables
let isTraversalRunning = false;
let traversalDirection = null;
// Add with other data variables
let originalArrayForTransformation = [];
let currentTransformationType = null; // 'cumulative' or 'prefix'
// Add with other data variables
let originalArrayForOperations = [];
let currentOperation = null;
let rotatePositions = 0;
// Add with other data variables
let originalArrayForFill = [];
let originalArrayForSwap = [];
let isFillOperation = false;
let isSwapOperation = false;
// Add with other data variables
let subarraySumResults = [];
// Add with other data variables
let isTwoPointerRunning = false;
let twoPointerLeft = 0;
let twoPointerRight = 0;
// Add with other data variables
let isSortingRunning = false;
let originalArrayForSort = [];
// Add with other data variables
let isValidationRunning = false;
let isPartialSortRunning = false;
let originalArrayForPartialSort = [];
let isStableSortRunning = false;
let originalArrayForStableSort = [];
// Add with other data variables
let isSubarraySortRunning = false;
let originalArrayForSubarraySort = [];
let subarraySortStart = 0;
let subarraySortEnd = 0;
// Add with other data variables
let isMergeOperationRunning = false;
let firstArray = [];
let secondArray = [];
let firstArraySize = 0;
let secondArraySize = 0;
let originalArrayBeforeMerge = [];
// Add with other data variables
let isWindowOperationRunning = false;
let originalArrayForWindow = [];
// Add with other data variables
let isTwoPointerSortRunning = false;
let isKadaneAlgorithmRunning = false;
let originalArrayForTwoPointerSort = [];
let originalArrayForKadane = [];
let isZeroMovementRunning = false;
let originalArrayForZeroMovement = [];
// Add with other data variables
let isRearrangeRunning = false;
let originalArrayForRearrange = [];
// Add with other data variables
let isSegregateRunning = false;
let originalArrayForSegregate = [];
// Add with other data variables
let isFrequencyCountRunning = false;
let isFindDuplicatesRunning = false;
let originalArrayForFrequency = [];
let originalArrayForDuplicates = [];
// Add with other data variables
let isNonRepeatingRunning = false;
let isUniqueElementsRunning = false;
let originalArrayForUniqueness = [];
// Add with other data variables
let isMajoritySearchRunning = false;
let originalArrayForMajority = [];
// Add with other data variables
let isDutchSortRunning = false;
let originalArrayForDutch = [];
// Add with other data variables
let originalArrayBeforeShiftDelete = [];
let isShiftDeleteRunning = false;
// Add with other data variables
let isPivotSearchRunning = false;
let originalArrayForPivot = [];
// Add with other data variables
let isRotatedSearchRunning = false;
let originalArrayForRotatedSearch = [];
let rotatedArray = [];
// Add with other data variables
let originalArrayBeforeProgression = [];
let isProgressionOperation = false;
let currentProgressionType = null;
// Add these variables with other data variables
let isKthOperationRunning = false;
let originalArrayForKth = [];
let kthOperationType = null;
let kthValue = 1;
// Add these variables with other data variables
let isSelectionSortRunning = false;
let isInsertionSortRunning = false;
let originalArrayForSelectionSort = [];
let originalArrayForInsertionSort = [];
// Add with other data variables
let isCyclicShiftRunning = false;
let originalArrayForCyclicShift = [];
let currentCyclicShiftType = null; // 'left' or 'right'
let cyclicShiftPositions = 0;
// Add with other data variables
let isNegationRunning = false;
let originalArrayForNegation = [];
// Add these variables with other data variables
let isNBy3OperationRunning = false;
let isNextGreaterElementRunning = false;
let originalArrayForNBy3 = [];
let originalArrayForNGE = [];
// Add with other data variables
let isShallowCopyRunning = false;
let originalArrayForShallowCopy = [];
let shallowCopyModifications = [];
// Add with other data variables
let isInPlaceMergeSortRunning = false;
let originalArrayForInPlaceMergeSort = [];
// Add with other data variables
let isInsertSortedRunning = false;
let insertSortedElements = [];
let originalArrayForInsertSorted = [];
let insertSortedCount = 0;
// Add with other data variables
let isRandomArrayGenerationRunning = false;
let originalArrayBeforeRandom = [];
// Add with other data variables
let isCharArrayConversionRunning = false;
let originalArrayForCharConversion = [];
// Global variables
let isCustomSortRunning = false;
let currentDictionary = {
    name: '',
    fields: [],
    data: [],
    originalData: []
};
let isEditingRecord = false;
let editingRecordIndex = -1;
// Add with other data variables
let isQuickSortRunning = false;
let isHeapSortRunning = false;
let originalArrayForQuickSort = [];
let originalArrayForHeapSort = [];
// Add with other data variables
let isEvenOddSortRunning = false;
let isAbsoluteSortRunning = false;
let originalArrayForSpecialSort = [];
// Add with other data variables
let originalArrayForShiftInsert = [];
let isShiftInsertRunning = false;
// Add with other data variables
let isTripletOperationRunning = false;
let isQuadrupletOperationRunning = false;
let originalArrayForTriplet = [];
let originalArrayForQuadruplet = [];
// Add with other data variables
let isEquilibriumRunning = false;
let originalArrayForEquilibrium = [];
// Add with other data variables
let isWaterProblemRunning = false;
let originalArrayForWater = [];
// Add with other data variables
let isTwoSumRunning = false;
let originalArrayForTwoSum = [];
let twoSumTarget = 0;
// Add with other data variables
let isGcdOperationRunning = false;
let isLcmOperationRunning = false;
let originalArrayForGcdLcm = [];
// Add with other data variables
let isPrimeSieveRunning = false;
let originalArrayForPrimeSieve = [];
// Add with other data variables
let isLongestSubstringRunning = false;
let originalArrayForSubstring = [];
// Add with other data variables
let isSubarrayProductRunning = false;
let originalArrayForProduct = [];
// Add with other data variables
let isLeaderOperationRunning = false;
let originalArrayForLeader = [];
// Add with other data variables
let isJumpGameRunning = false;
let originalArrayForJumpGame = [];
// Add with other data variables
let isNearZeroRunning = false;
let originalArrayForNearZero = [];
// Add with other data variables
let isMinWindowRunning = false;
let originalArrayForMinWindow = [];
let mainString = "";
let targetString = "";
// Add with other data variables
let isKConsecutiveRunning = false;
let originalArrayForKConsecutive = [];
// Add with other data variables
let isRearrangeMinMaxRunning = false;
let originalArrayForMinMax = [];
// Add with other data variables
let isNextPermutationRunning = false;
let originalArrayForPermutation = [];
// Add with other data variables
let isConsecutiveOperationRunning = false;
let originalArrayForConsecutive = [];
// Add with other data variables
let isMergeIntervalsRunning = false;
let originalArrayForMergeIntervals = [];
// Add with other data variables
let isSetOperationRunning = false;
let currentSetOperation = null;
let setArrays = [];
let originalArrayBeforeSetOperation = [];
// Add with other data variables
let isSetOpRunning = false;
let currentSetOpType = null;
let setOpArrays = [];
let originalArrayBeforeSetOp = [];
// Add with other data variables
let isSubsetSupersetRunning = false;
let currentSubsetSupersetOperation = null; // 'subset' or 'superset'
let comparisonArrays = [];
let originalArrayBeforeComparison = [];
let numArraysComp = 0;
let arraySizesComp = [];
let arrayElementsComp = [];
// Add these with other data variables
let isSubsetCompRunning = false;
let isSupersetCompRunning = false;
let originalArrayForSubsetComp = [];
let originalArrayForSupersetComp = [];
let subsetCompArrays = [];
let supersetCompArrays = [];
// Add with other data variables
let memoryAddresses = new Map(); // Store memory addresses for each array
let currentMemoryAddress = '';
// Add with other data variables
let isComparisonRunning = false;
let originalArrayForComparison = [];
// Add with other data variables
let isStatisticalOperationRunning = false;
let currentStatisticalOperation = null; // 'covariance' or 'correlation'
let statisticalArrays = [];
let statisticalArrayNames = [];
let originalArrayForStatistical = [];
// Add with other data variables
let isStatisticalCalculationRunning = false; // Note: Different name to avoid duplication
let originalArrayForStats = [];
// Add with other data variables
let isElementWiseOperationRunning = false;
let elementWiseFirstArray = [];
let elementWiseSecondArray = [];
let elementWiseFirstArraySize = 0;
let elementWiseSecondArraySize = 0;
let originalArrayBeforeElementWise = [];
let currentElementWiseOperation = null; // 'max' or 'min'
// Add with other data variables
let isLogicalOperationRunning = false;
let logicalArrays = [];
let logicalOperationType = '';
let originalArrayForLogical = [];
let logicalArraysCount = 0;
let logicalArraysSizes = [];
// Add with other data variables - ONLY ONCE
let isStatsCalcRunning = false; // Different name to avoid duplicates
let statsOriginalArray = []; // Renamed from originalArrayForStats
// Add with other data variables
let originalArrayForScalar = [];
let isScalarOperationRunning = false;
// Add with other data variables
let isTrigOperationRunning = false;
let originalArrayForTrig = [];
let currentTrigOperation = null;
// Add with other data variables
let isRangeOperationRunning = false;
let originalArrayForRange = [];
// Add with other data variables
let isMathOperationRunning = false;
let originalArrayForMath = [];
let currentMathOperation = null;
// Add with other data variables
let isPancakeSortRunning = false;
let originalArrayForPancakeSort = [];
let pancakeSortSteps = [];
let currentPancakeStep = 0;
// Add with other data variables
let isStockSpanRunning = false;
let originalArrayForStockSpan = [];
// Add with other data variables
let isMaxPairAndOrRunning = false;
let originalArrayForMaxPair = [];
// Add with other data variables
let isHistogramRunning = false;
let originalArrayForHistogram = [];
// Add with other data variables
let isFruitBasketRunning = false;
let originalArrayForFruitBasket = [];
// Add with other data variables
let isElementWiseOpRunning = false;
let elemWiseFirstArray = [];
let elemWiseSecondArray = [];
let elemWiseFirstSize = 0;
let elemWiseSecondSize = 0;
let currentElementWiseOp = null;
let originalArrayBeforeElemWise = [];
// Add with other data variables (replace the conflicting ones)
let isLogicalOpRunning = false;
let originalArrayForLogicalOps = [];
let logicalOpType = null;
let logicalOpArrays = [];
let logicalOpResultArray = [];
// Add with other data variables
let isTransformRunning = false;
let originalArrayForTransform = [];
let transformSteps = [];
let currentTransformStep = 0;
// Add with other data variables
let isMinFlipsRunning = false;
let minFlipsOperationType = null; // 'or' or 'and'
let minFlipsArrays = [];
let minFlipsOriginalArrays = [];
let minFlipsNumArraysCount = 0; // Changed from minFlipsNumArrays
let minFlipsArraySizes = [];
// Add with other data variables
let isPrefixXorRunning = false;
let originalArrayForXor = [];
// Add with other data variables
let isMaxAbsDiffRunning = false;
let originalArrayForAbsDiff = [];
// Add with other data variables
let isCircularSubarrayRunning = false;
let originalArrayForCircular = [];
// Add with other data variables
let isWiggleSortRunning = false;
let originalArrayForWiggle = [];
// Add with other data variables
let isMaxDistanceRunning = false;
let originalArrayForMaxDistance = [];
// Add with other data variables
let isCountPairsRunning = false;
let originalArrayForPairs = [];
// Add with other data variables
let isMinSwapsRunning = false;
let originalArrayForMinSwaps = [];
// Add with other data variables
let isMissingRepeatingRunning = false;
let originalArrayForMissingRepeating = [];
// Add with other data variables
let isFirstRepeatingRunning = false;
let originalArrayForRepeating = [];
// Add with other data variables
let isConditionalOperationRunning = false;
let currentConditionalOperation = null;
let array1 = [];
let array2 = [];
let array1Size = 0;
let array2Size = 0;
let originalArrayForConditional = [];
// Add these with other data variables
let isPreviousElementRunning = false;
let originalArrayForPreviousElement = [];
// Add with other data variables
let isPredicateFilterRunning = false;
let originalArrayForPredicate = [];
// Add with other data variables
let isReshapeOperationRunning = false;
let originalArrayForReshape = [];
let autoRevertTimer = null;
// Add with other data variables
let isDataTypeOperationRunning = false;
let originalArrayForDataType = [];
// Add with other data variables
let isShuffleRunning = false;
let originalArrayForShuffle = [];
// Add with other data variables
let isBinningRunning = false;
let originalArrayForBinning = [];
// Add with other data variables
let isUfuncRunning = false;
let originalArrayForUfunc = [];
// Stock Market Data Variables
let originalStockPrices = [];
let isStockOperationRunning = false;
// Add these with your existing stock market variables
let openPrices = [];
let closePrices = [];
// Add with other data variables
let isAxisOperationRunning = false;
let originalArrayForAxis = [];
let currentMatrix = [];
let matrixRows = 0;
let matrixCols = 0;
// Add with other data variables - using unique names
let isStatisticalAnalysisRunning = false;
let originalArrayForStatisticalOps = [];
let currentStatOperation = null; // Renamed from currentStatisticalOperation
let nValueForStatisticalAnalysis = 0;
// Add with other data variables (using unique names)
let isParenthesesCheckActive = false;
let originalArrayState = [];
// Add with other data variables
let isPalindromeOperationRunning = false;
let isAnagramOperationRunning = false;
// Add with other data variables
let isRangeSumRunning = false;
let originalArrayForRangeSum = [];
// Add with other data variables
let isDailyTemperaturesRunning = false;
let originalArrayForDailyTemperatures = [];
// Add with other data variables
let isFirstLastSearchRunning = false;
let originalArrayForFirstLast = [];
// Add with other data variables - PALINDROME OPERATIONS
let isPalindromicOperationRunning = false;
let originalArrayBeforePalindrome = [];
let originalStringBeforePalindrome = "";
// Add these with other data variables
let isPatternMatchingRunning = false;
let currentPatternMatchingType = null;
let originalArrayForPatternMatching = [];
// Add with other data variables
let isCombinationSumRunning = false;
let isSubsetsRunning = false;
let originalArrayForBacktrack = [];
// Add with other data variables
let isParenthesesOperationRunning = false;
let isSubsequencesOperationRunning = false;
let originalArrayForParentheses = [];
let originalArrayForSubsequences = [];
// Add with other data variables
let isWordConcatSearchActive = false;
let originalArrayBeforeWordConcat = [];
let wordConcatSearchResults = [];
// Add with other data variables
let isSmallerCountRunning = false;
let originalArrayForSmallerCount = [];
// Add these with other data variables
let isUglyNumberOperationRunning = false;
// Add with other data variables
let isPerfectNumberRunning = false;
let isArmstrongNumberRunning = false;
let originalArrayForSpecialNumbers = [];
// Add with other data variables
let isPascalOperationRunning = false;
let originalArrayForPascal = [];
// Add with other data variables
let isRandomPickRunning = false;
let originalArrayForRandomPick = [];
// Add with other data variables
let isRandomPointRunning = false;
let originalArrayForRandomPoint = [];
// Add with other data variables - using unique names
let isConsecutiveSequenceSearchRunning = false;
let originalArrayForConsecutiveSearch = [];
// Add with other data variables
let isNumberOperationRunning = false;
let originalArrayForNumberOps = [];
// Add with other data variables
let isDigitalRootRunning = false;
let isHappyNumberRunning = false;
let originalArrayForDigitalRoot = [];
let originalArrayForHappyNumber = [];
// Add with other data variables
let isExcelConversionRunning = false;
let originalArrayForExcel = [];
// Add with other data variables
let isNumberToColumnRunning = false;
let originalArrayForNumberToColumn = [];
// Add these with other data variables
let stack = null;
let originalArrayForStack = [];
let isStackOperationRunning = false;
let stackAnimationTimeout = null;

        // Input elements
        const createValue = document.getElementById('createValue');
        const insertIndex = document.getElementById('insertIndex');
        const insertValue = document.getElementById('insertValue');
        const readIndex = document.getElementById('readIndex');
        const updateIndex = document.getElementById('updateIndex');
        const updateValue = document.getElementById('updateValue');
        const updateElement = document.getElementById('updateElement');
        const updateNewValue = document.getElementById('updateNewValue');
        const deleteIndex = document.getElementById('deleteIndex');
        const deleteElement = document.getElementById('deleteElement');
        const searchElement = document.getElementById('searchElement');
        const searchIndex = document.getElementById('searchIndex');
        const linearSearchElement = document.getElementById('linearSearchElement'); // NEW
        
        // Button elements
        const createBtn = document.getElementById('createBtn');
        const createRandomBtn = document.getElementById('createRandomBtn');
        const insertBtn = document.getElementById('insertBtn');
        const readBtn = document.getElementById('readBtn');
        const updateBtn = document.getElementById('updateBtn');
        const updateByElementBtn = document.getElementById('updateByElementBtn');
        const deleteBtn = document.getElementById('deleteBtn');
        const deleteByElementBtn = document.getElementById('deleteByElementBtn');
        const clearArrayBtn = document.getElementById('clearArrayBtn');
        const searchBtn = document.getElementById('searchBtn');
        const searchByIndexBtn = document.getElementById('searchByIndexBtn');
        const linearSearchBtn = document.getElementById('linearSearchBtn'); // NEW
        // Add with other DOM elements
const binarySearchElement = document.getElementById('binarySearchElement');
const binarySearchBtn = document.getElementById('binarySearchBtn');
const binarySearchSteps = document.getElementById('binarySearchSteps');
const checkElement = document.getElementById('checkElement');

// Add with other button elements
const checkElementBtn = document.getElementById('checkElementBtn');
const findMinElementBtn = document.getElementById('findMinElementBtn');
const findMaxElementBtn = document.getElementById('findMaxElementBtn');
// Add with other button elements
const traverseForwardBtn = document.getElementById('traverseForwardBtn');
const traverseBackwardBtn = document.getElementById('traverseBackwardBtn');
// Add with other DOM elements
const reverseArrayBtn = document.getElementById('reverseArrayBtn');
const rotateLeftBtn = document.getElementById('rotateLeftBtn');
const rotateRightBtn = document.getElementById('rotateRightBtn');
const rotateInputGroup = document.getElementById('rotateInputGroup');
const rotatePositionsInput = document.getElementById('rotatePositions');
const confirmRotateBtn = document.getElementById('confirmRotateBtn');
const cancelRotateBtn = document.getElementById('cancelRotateBtn');
// Add with other DOM elements
const fillValue = document.getElementById('fillValue');
const fillStart = document.getElementById('fillStart');
const fillEnd = document.getElementById('fillEnd');
const fillArrayBtn = document.getElementById('fillArrayBtn');
const swapByValuesBtn = document.getElementById('swapByValuesBtn');
const swapByIndicesBtn = document.getElementById('swapByIndicesBtn');
const swapByValuesGroup = document.getElementById('swapByValuesGroup');
const swapByIndicesGroup = document.getElementById('swapByIndicesGroup');
const swapCount = document.getElementById('swapCount');
const confirmSwapCountBtn = document.getElementById('confirmSwapCountBtn');
const swapValuesInputs = document.getElementById('swapValuesInputs');
const swapIndicesCount = document.getElementById('swapIndicesCount');
const confirmSwapIndicesCountBtn = document.getElementById('confirmSwapIndicesCountBtn');
const swapIndicesInputs = document.getElementById('swapIndicesInputs');
const stableSortBtn = document.getElementById('stableSortBtn');
// Add with other DOM elements
const subarraySumInput = document.getElementById('subarraySumInput');
const findSubarraySumBtn = document.getElementById('findSubarraySumBtn');
const generateAllSubarraysWithSumBtn = document.getElementById('generateAllSubarraysWithSumBtn');
// Add with other DOM elements
const twoPointerTraverseBtn = document.getElementById('twoPointerTraverseBtn');
// Add with other DOM elements
const sortAscBtn = document.getElementById('sortAscBtn');
const sortDescBtn = document.getElementById('sortDescBtn');
    // Add with other input elements
const occurrenceElement = document.getElementById('occurrenceElement');
const occurrenceElementLast = document.getElementById('occurrenceElementLast');
const occurrenceElementAll = document.getElementById('occurrenceElementAll');
// Add with other button elements
const findFirstOccurrenceBtn = document.getElementById('findFirstOccurrenceBtn');
const findLastOccurrenceBtn = document.getElementById('findLastOccurrenceBtn');
const findAllOccurrencesBtn = document.getElementById('findAllOccurrencesBtn');
// Add with other input elements
const deleteFirstOccurrence = document.getElementById('deleteFirstOccurrence');
const deleteAllOccurrences = document.getElementById('deleteAllOccurrences');
// Add with other button elements
const deleteFirstOccurrenceBtn = document.getElementById('deleteFirstOccurrenceBtn');
const deleteAllOccurrencesBtn = document.getElementById('deleteAllOccurrencesBtn');
const removeDuplicatesInPlaceBtn = document.getElementById('removeDuplicatesInPlaceBtn');
const removeDuplicatesKeepOneBtn = document.getElementById('removeDuplicatesKeepOneBtn');
// Add with other DOM elements
const checkSortedBtn = document.getElementById('checkSortedBtn');
const partialSortBtn = document.getElementById('partialSortBtn');
const partialSortInputGroup = document.getElementById('partialSortInputGroup');
const partialSortCount = document.getElementById('partialSortCount');
const confirmPartialSortBtn = document.getElementById('confirmPartialSortBtn');
const cancelPartialSortBtn = document.getElementById('cancelPartialSortBtn');
// Add with other DOM elements
const sortSubarrayStart = document.getElementById('sortSubarrayStart');
const sortSubarrayEnd = document.getElementById('sortSubarrayEnd');
const sortSubarrayBtn = document.getElementById('sortSubarrayBtn');
// Add with other DOM elements
const mergeSortedArraysBtn = document.getElementById('mergeSortedArraysBtn');
const mergeArraysGroup = document.getElementById('mergeArraysGroup');
const firstArraySizeInput = document.getElementById('firstArraySize');
const secondArraySizeInput = document.getElementById('secondArraySize');
const confirmFirstArraySizeBtn = document.getElementById('confirmFirstArraySizeBtn');
const confirmSecondArraySizeBtn = document.getElementById('confirmSecondArraySizeBtn');
const firstArrayInputs = document.getElementById('firstArrayInputs');
const secondArrayInputs = document.getElementById('secondArrayInputs');
const performMergeBtn = document.getElementById('performMergeBtn');
const cancelMergeBtn = document.getElementById('cancelMergeBtn');
// Add with other DOM elements
const fixedWindowSize = document.getElementById('fixedWindowSize');
const fixedWindowBtn = document.getElementById('fixedWindowBtn');
const variableWindowSum = document.getElementById('variableWindowSum');
const variableWindowBtn = document.getElementById('variableWindowBtn');
// Add with other DOM elements
const twoPointerSortBtn = document.getElementById('twoPointerSortBtn');
const kadaneAlgorithmBtn = document.getElementById('kadaneAlgorithmBtn');
const subarrayInput = document.getElementById('subarrayInput');
const countSubarraysBtn = document.getElementById('countSubarraysBtn');
const generateSubarraysBtn = document.getElementById('generateSubarraysBtn');
const subarraysResults = document.getElementById('subarraysResults');
const subarrayCount = document.getElementById('subarrayCount');
const subarraysList = document.getElementById('subarraysList');
// Add with other DOM elements
const rearrangePositiveNegativeBtn = document.getElementById('rearrangePositiveNegativeBtn');
// Add with other DOM elements
const segregateEvenOddBtn = document.getElementById('segregateEvenOddBtn');
// Add with other button elements
const firstNonRepeatingBtn = document.getElementById('firstNonRepeatingBtn');
const findUniqueElementsBtn = document.getElementById('findUniqueElementsBtn');
// Add with other DOM elements
const findMajorityElementBtn = document.getElementById('findMajorityElementBtn');
// Add with other DOM elements
const sortDutchNationalFlagBtn = document.getElementById('sortDutchNationalFlagBtn');
// Add with other DOM elements
const shiftDeleteIndex = document.getElementById('shiftDeleteIndex');
const shiftLeftAfterDeleteBtn = document.getElementById('shiftLeftAfterDeleteBtn');
// Add with other DOM elements
const findPivotBtn = document.getElementById('findPivotBtn');
// Add with other DOM elements
const rotatedSearchElement = document.getElementById('rotatedSearchElement');
const rotatedSearchBtn = document.getElementById('rotatedSearchBtn');
// Add with other DOM elements
// Add with other DOM elements
const apFirstTerm = document.getElementById('apFirstTerm');
const apCommonDiff = document.getElementById('apCommonDiff');
const apNumTerms = document.getElementById('apNumTerms');
const gpFirstTerm = document.getElementById('gpFirstTerm');
const gpCommonRatio = document.getElementById('gpCommonRatio');
const gpNumTerms = document.getElementById('gpNumTerms');
const createAPBtn = document.getElementById('createAPBtn');
const createGPBtn = document.getElementById('createGPBtn');
// Add these DOM elements with other elements
const kthElementInput = document.getElementById('kthElementInput');
const kthSmallestBtn = document.getElementById('kthSmallestBtn');
const kthLargestBtn = document.getElementById('kthLargestBtn');
// Add these DOM elements with other elements
const selectionSortBtn = document.getElementById('selectionSortBtn');
const insertionSortBtn = document.getElementById('insertionSortBtn');
// Add with other DOM elements
const cyclicShiftLeftBtn = document.getElementById('cyclicShiftLeftBtn');
const cyclicShiftRightBtn = document.getElementById('cyclicShiftRightBtn');
const cyclicShiftInputGroup = document.getElementById('cyclicShiftInputGroup');
const cyclicShiftPositionsInput = document.getElementById('cyclicShiftPositions');
const confirmCyclicShiftBtn = document.getElementById('confirmCyclicShiftBtn');
const cancelCyclicShiftBtn = document.getElementById('cancelCyclicShiftBtn');
// Add this with other DOM elements
const inPlaceNegationBtn = document.getElementById('inPlaceNegationBtn');
// Add these DOM elements with other elements
const findNBy3ElementsBtn = document.getElementById('findNBy3ElementsBtn');
const nextGreaterElementBtn = document.getElementById('nextGreaterElementBtn');
// Add with other event listeners
const shallowCopyBtn = document.getElementById('shallowCopyBtn');
const shallowCopyCount = document.getElementById('shallowCopyCount');
const shallowCopyInputGroup = document.getElementById('shallowCopyInputGroup');
const shallowCopyInputs = document.getElementById('shallowCopyInputs');
const confirmShallowCopyBtn = document.getElementById('confirmShallowCopyBtn');
const cancelShallowCopyBtn = document.getElementById('cancelShallowCopyBtn');
// Add with other DOM elements
const inPlaceMergeSortBtn = document.getElementById('inPlaceMergeSortBtn');
// Add with other DOM elements
const insertSortedBtn = document.getElementById('insertSortedBtn');
const insertSortedGroup = document.getElementById('insertSortedGroup');
const insertSortedCountInput = document.getElementById('insertSortedCount');
const confirmInsertSortedCountBtn = document.getElementById('confirmInsertSortedCountBtn');
const insertSortedInputs = document.getElementById('insertSortedInputs');
const performInsertSortedBtn = document.getElementById('performInsertSortedBtn');
const cancelInsertSortedBtn = document.getElementById('cancelInsertSortedBtn');
// Add with other DOM elements
const randomArraySize = document.getElementById('randomArraySize');
const generateRandomArrayBtn = document.getElementById('generateRandomArrayBtn');
// DOM Elements
const customComparatorSortBtn = document.getElementById('customComparatorSortBtn');
const customComparatorContainer = document.getElementById('customComparatorContainer');
const dictionaryName = document.getElementById('dictionaryName');
const createDictionaryBtn = document.getElementById('createDictionaryBtn');
const dictionaryStructureSection = document.getElementById('dictionaryStructureSection');
const fieldCount = document.getElementById('fieldCount');
const confirmFieldCountBtn = document.getElementById('confirmFieldCountBtn');
const fieldDefinitions = document.getElementById('fieldDefinitions');
const dataEntrySection = document.getElementById('dataEntrySection');
const dataEntryForm = document.getElementById('dataEntryForm');
const addRecordBtn = document.getElementById('addRecordBtn');
const finishDataEntryBtn = document.getElementById('finishDataEntryBtn');
const dictionaryOperationsSection = document.getElementById('dictionaryOperationsSection');
const updateDictionaryBtn = document.getElementById('updateDictionaryBtn');
const dropDictionaryBtn = document.getElementById('dropDictionaryBtn');
const sortFieldSelect = document.getElementById('sortFieldSelect');
const sortOrderSelect = document.getElementById('sortOrderSelect');
const performSortBtn = document.getElementById('performSortBtn');
const dictionaryDisplaySection = document.getElementById('dictionaryDisplaySection');
const dictionaryTableContainer = document.getElementById('dictionaryTableContainer');
const dictionaryTableHeader = document.getElementById('dictionaryTableHeader');
const dictionaryTableBody = document.getElementById('dictionaryTableBody');
const sortVisualizationSection = document.getElementById('sortVisualizationSection');
const sortAlgorithmExplanation = document.getElementById('sortAlgorithmExplanation');
const sortExplanationText = document.getElementById('sortExplanationText');
const sortStepsContainer = document.getElementById('sortStepsContainer');
const resetAfterSortBtn = document.getElementById('resetAfterSortBtn');
const cancelCustomSortBtn = document.getElementById('cancelCustomSortBtn');
// Add with other event listeners
const sortEvenBeforeOddBtn = document.getElementById('sortEvenBeforeOddBtn');
const sortByAbsoluteValueBtn = document.getElementById('sortByAbsoluteValueBtn');
// Add with other DOM elements
const popFirstBtn = document.getElementById('popFirstBtn');
const shiftRightInsertBtn = document.getElementById('shiftRightInsertBtn');
const shiftRightInsertGroup = document.getElementById('shiftRightInsertGroup');
const insertShiftIndex = document.getElementById('insertShiftIndex');
const insertShiftValue = document.getElementById('insertShiftValue');
const confirmShiftInsertBtn = document.getElementById('confirmShiftInsertBtn');
const cancelShiftInsertBtn = document.getElementById('cancelShiftInsertBtn');
// Add with other DOM elements
const tripletSumInput = document.getElementById('tripletSumInput');
const quadrupletSumInput = document.getElementById('quadrupletSumInput');
const findTripletsBtn = document.getElementById('findTripletsBtn');
const findQuadrupletsBtn = document.getElementById('findQuadrupletsBtn');
// Add with other DOM elements
const equilibriumPointBtn = document.getElementById('equilibriumPointBtn');
// Add with other DOM elements
const containerWithMostWaterBtn = document.getElementById('containerWithMostWaterBtn');
const trappingRainWaterBtn = document.getElementById('trappingRainWaterBtn');
// Add with other DOM elements
const twoSumBtn = document.getElementById('twoSumBtn');
const twoSumInputGroup = document.getElementById('twoSumInputGroup');
const twoSumTargetInput = document.getElementById('twoSumTarget');
const confirmTwoSumBtn = document.getElementById('confirmTwoSumBtn');
const cancelTwoSumBtn = document.getElementById('cancelTwoSumBtn');
// Add with other DOM elements
const findGcdBtn = document.getElementById('findGcdBtn');
const findLcmBtn = document.getElementById('findLcmBtn');
// Add with other DOM elements
const primeSieveBtn = document.getElementById('primeSieveBtn');
// Add with other DOM elements
const substringInput = document.getElementById('substringInput');
const findLongestSubstringBtn = document.getElementById('findLongestSubstringBtn');
const longestSubstringResults = document.getElementById('longestSubstringResults');
const longestSubstringLength = document.getElementById('longestSubstringLength');
const longestSubstringValue = document.getElementById('longestSubstringValue');
const longestSubstringSteps = document.getElementById('longestSubstringSteps');
// Add with other DOM elements
const subarrayProductK = document.getElementById('subarrayProductK');
const subarrayProductBtn = document.getElementById('subarrayProductBtn');
// Add with other DOM elements
const leaderInArrayBtn = document.getElementById('leaderInArrayBtn');
// Add with other DOM elements
const jumpGameBtn = document.getElementById('jumpGameBtn');
// Add with other DOM elements
const bestTimeStockBtn = document.getElementById('bestTimeStockBtn');
// Add with other DOM elements
const findSubarrayNearZeroBtn = document.getElementById('findSubarrayNearZeroBtn');
// Add with other DOM elements
const minWindowSubstringBtn = document.getElementById('minWindowSubstringBtn');
const minWindowGroup = document.getElementById('minWindowGroup');
const mainStringInput = document.getElementById('mainStringInput');
const targetStringInput = document.getElementById('targetStringInput');
const performMinWindowBtn = document.getElementById('performMinWindowBtn');
const cancelMinWindowBtn = document.getElementById('cancelMinWindowBtn');
// Add with other DOM elements
const kConsecutiveSize = document.getElementById('kConsecutiveSize');
const maxKConsecutiveBtn = document.getElementById('maxKConsecutiveBtn');
const minKConsecutiveBtn = document.getElementById('minKConsecutiveBtn');
// Add with other DOM elements
const rearrangeMinMaxBtn = document.getElementById('rearrangeMinMaxBtn');
// Add with other DOM elements
const nextPermutationBtn = document.getElementById('nextPermutationBtn');
// Add with other DOM elements
const longestConsecutiveSequenceBtn = document.getElementById('longestConsecutiveSequenceBtn');
const maxConsecutiveOnesBtn = document.getElementById('maxConsecutiveOnesBtn');
// Add with other DOM elements
const mergeIntervalsBtn = document.getElementById('mergeIntervalsBtn');
// Add with other DOM elements
const setOperationsGroup = document.getElementById('setOperationsGroup');
const numArrays = document.getElementById('numArrays');
const confirmNumArraysBtn = document.getElementById('confirmNumArraysBtn');
const setArraysInputs = document.getElementById('setArraysInputs');
const performSetOperationBtn = document.getElementById('performSetOperationBtn');
const cancelSetOperationBtn = document.getElementById('cancelSetOperationBtn');
const unionArraysBtn = document.getElementById('unionArraysBtn');
const intersectionArraysBtn = document.getElementById('intersectionArraysBtn');
// Add with other DOM elements
const setDifferenceBtn = document.getElementById('setDifferenceBtn');
const symmetricDifferenceBtn = document.getElementById('symmetricDifferenceBtn');
// Add with other DOM elements for subset/superset
const checkSubsetBtn = document.getElementById('checkSubsetBtn');
const checkSupersetBtn = document.getElementById('checkSupersetBtn');
const subsetSupersetGroup = document.getElementById('subsetSupersetGroup');
const subsetSupersetTitle = document.getElementById('subsetSupersetTitle');
const numArraysCompInput = document.getElementById('numArraysComp');
const confirmNumArraysCompBtn = document.getElementById('confirmNumArraysBtn'); // Renamed
const arraySizeInputsComp = document.getElementById('arraySizeInputsComp');
const arrayElementsInputsComp = document.getElementById('arrayElementsInputsComp');
const performSubsetSupersetBtn = document.getElementById('performSubsetSupersetBtn');
const cancelSubsetSupersetBtn = document.getElementById('cancelSubsetSupersetBtn');
// Add these with other DOM elements
const checkSubsetCompBtn = document.getElementById('checkSubsetCompBtn');
const checkSupersetCompBtn = document.getElementById('checkSupersetCompBtn');
const subsetCompInputGroup = document.getElementById('subsetCompInputGroup');
const supersetCompInputGroup = document.getElementById('supersetCompInputGroup');
const numArraysSubsetComp = document.getElementById('numArraysSubsetComp');
const numArraysSupersetComp = document.getElementById('numArraysSupersetComp');
const confirmNumArraysSubsetCompBtn = document.getElementById('confirmNumArraysSubsetCompBtn');
const confirmNumArraysSupersetCompBtn = document.getElementById('confirmNumArraysSupersetCompBtn');
const subsetCompArraysInputs = document.getElementById('subsetCompArraysInputs');
const supersetCompArraysInputs = document.getElementById('supersetCompArraysInputs');
const performSubsetCompBtn = document.getElementById('performSubsetCompBtn');
const performSupersetCompBtn = document.getElementById('performSupersetCompBtn');
const cancelSubsetCompBtn = document.getElementById('cancelSubsetCompBtn');
const cancelSupersetCompBtn = document.getElementById('cancelSupersetCompBtn');
// Add with other DOM elements
const memoryAddress = document.getElementById('memoryAddress');
// Add with other DOM elements
const comparisonValue = document.getElementById('comparisonValue');
const comparisonValueLess = document.getElementById('comparisonValueLess');
const findFirstGreaterBtn = document.getElementById('findFirstGreaterBtn');
const findLastLessBtn = document.getElementById('findLastLessBtn');
// Add with other DOM elements
const findCovarianceBtn = document.getElementById('findCovarianceBtn');
const findCorrelationBtn = document.getElementById('findCorrelationBtn');
const covarianceCorrelationGroup = document.getElementById('covarianceCorrelationGroup');
const arrayCountInput = document.getElementById('arrayCountInput');
const confirmArrayCountBtn = document.getElementById('confirmArrayCountBtn');
const arrayDetailsContainer = document.getElementById('arrayDetailsContainer');
const performStatisticalOperationBtn = document.getElementById('performStatisticalOperationBtn');
const cancelStatisticalOperationBtn = document.getElementById('cancelStatisticalOperationBtn');
const operationTitle = document.getElementById('operationTitle');
// Add with other DOM elements
const elementWiseMaxBtn = document.getElementById('elementWiseMaxBtn');
const elementWiseMinBtn = document.getElementById('elementWiseMinBtn');
const elementWiseGroup = document.getElementById('elementWiseGroup');
const firstArraySizeElementWise = document.getElementById('firstArraySizeElementWise');
const secondArraySizeElementWise = document.getElementById('secondArraySizeElementWise');
const confirmFirstArraySizeElementWiseBtn = document.getElementById('confirmFirstArraySizeElementWiseBtn');
const confirmSecondArraySizeElementWiseBtn = document.getElementById('confirmSecondArraySizeElementWiseBtn');
const firstArrayInputsElementWise = document.getElementById('firstArrayInputsElementWise');
const secondArrayInputsElementWise = document.getElementById('secondArrayInputsElementWise');
const performElementWiseBtn = document.getElementById('performElementWiseBtn');
const cancelElementWiseBtn = document.getElementById('cancelElementWiseBtn');
// Add with other DOM elements
const logicalAndBtn = document.getElementById('logicalAndBtn');
const logicalOrBtn = document.getElementById('logicalOrBtn');
const logicalOperationsGroup = document.getElementById('logicalOperationsGroup');
const logicalArraysCountInput = document.getElementById('logicalArraysCount');
const confirmArraysCountBtn = document.getElementById('confirmArraysCountBtn');
const arraysSizeInputs = document.getElementById('arraysSizeInputs');
const arraysElementsInputs = document.getElementById('arraysElementsInputs');
const performLogicalOperationBtn = document.getElementById('performLogicalOperationBtn');
const cancelLogicalOperationBtn = document.getElementById('cancelLogicalOperationBtn');
// Add with other DOM elements
const calculateStdDevBtn = document.getElementById('calculateStdDevBtn');
const calculateVarianceBtn = document.getElementById('calculateVarianceBtn');
// Add with other DOM elements
const scalarValue = document.getElementById('scalarValue');
const scalarValueSubtract = document.getElementById('scalarValueSubtract');
const scalarValueMultiply = document.getElementById('scalarValueMultiply');
const scalarValueDivide = document.getElementById('scalarValueDivide');
const addScalarBtn = document.getElementById('addScalarBtn');
const subtractScalarBtn = document.getElementById('subtractScalarBtn');
const multiplyScalarBtn = document.getElementById('multiplyScalarBtn');
const divideScalarBtn = document.getElementById('divideScalarBtn');
// Add with other button elements
const calcSinBtn = document.getElementById('calcSinBtn');
const calcCosBtn = document.getElementById('calcCosBtn');
const calcTanBtn = document.getElementById('calcTanBtn');
// Add with other DOM elements
const modeElements = document.getElementById('modeElements');
// Add with other DOM elements
const findRangeBtn = document.getElementById('findRangeBtn');
// Add with other button elements
const calculateExponentialBtn = document.getElementById('calculateExponentialBtn');
const calculateNaturalLogBtn = document.getElementById('calculateNaturalLogBtn');
const calculateLog10Btn = document.getElementById('calculateLog10Btn');
// Add with other DOM elements
const stockSpanBtn = document.getElementById('stockSpanBtn');
// Add with other DOM elements
const maxPairAndOrBtn = document.getElementById('maxPairAndOrBtn');
// Add with other DOM elements
const largestRectangleHistogramBtn = document.getElementById('largestRectangleHistogramBtn');
// Add with other DOM elements
const fruitIntoBasketsBtn = document.getElementById('fruitIntoBasketsBtn');
// Add with other DOM elements
const addArraysElementWiseBtn = document.getElementById('addArraysElementWiseBtn');
const subtractArraysElementWiseBtn = document.getElementById('subtractArraysElementWiseBtn');
const multiplyArraysElementWiseBtn = document.getElementById('multiplyArraysElementWiseBtn');
const divideArraysElementWiseBtn = document.getElementById('divideArraysElementWiseBtn');
const modulusArraysElementWiseBtn = document.getElementById('modulusArraysElementWiseBtn');
const elementWiseOperationGroup = document.getElementById('elementWiseOperationGroup');
const elementWiseFirstArraySizeInput = document.getElementById('elementWiseFirstArraySize');
const elementWiseSecondArraySizeInput = document.getElementById('elementWiseSecondArraySize');
const confirmElementWiseFirstArraySizeBtn = document.getElementById('confirmElementWiseFirstArraySizeBtn');
const confirmElementWiseSecondArraySizeBtn = document.getElementById('confirmElementWiseSecondArraySizeBtn');
const elementWiseFirstArrayInputs = document.getElementById('elementWiseFirstArrayInputs');
const elementWiseSecondArrayInputs = document.getElementById('elementWiseSecondArrayInputs');
const performElementWiseOperationBtn = document.getElementById('performElementWiseOperationBtn');
const cancelElementWiseOperationBtn = document.getElementById('cancelElementWiseOperationBtn');
// Add with other DOM elements
const logicalNotBtn = document.getElementById('logicalNotBtn');
const logicalXorBtn = document.getElementById('logicalXorBtn');
const logicalNotGroup = document.getElementById('logicalNotGroup');
const logicalXorGroup = document.getElementById('logicalXorGroup');
const logicalNotSize = document.getElementById('logicalNotSize');
const confirmLogicalNotSizeBtn = document.getElementById('confirmLogicalNotSizeBtn');
const logicalNotInputs = document.getElementById('logicalNotInputs');
const cancelLogicalNotBtn = document.getElementById('cancelLogicalNotBtn');
const logicalXorArrayCount = document.getElementById('logicalXorArrayCount');
const confirmLogicalXorArrayCountBtn = document.getElementById('confirmLogicalXorArrayCountBtn');
const logicalXorSizeInputs = document.getElementById('logicalXorSizeInputs');
const logicalXorElementInputs = document.getElementById('logicalXorElementInputs');
const cancelLogicalXorBtn = document.getElementById('cancelLogicalXorBtn');
// Add with other DOM elements
const transformNonDecreasingBtn = document.getElementById('transformNonDecreasingBtn');
// Add with other DOM elements - USING UNIQUE NAMES
const minFlipsOrBtn = document.getElementById('minFlipsOrBtn');
const minFlipsAndBtn = document.getElementById('minFlipsAndBtn');
const minFlipsInputGroup = document.getElementById('minFlipsInputGroup');
const minFlipsTitle = document.getElementById('minFlipsTitle');
const numArraysInputField = document.getElementById('numArraysInput'); // Changed from numArraysInput
const confirmNumArraysButton = document.getElementById('confirmNumArraysBtn'); // Changed from confirmNumArraysBtn
const arraySizeInputsContainer = document.getElementById('arraySizeInputs'); // Changed from arraySizeInputs
const arrayElementsInputsContainer = document.getElementById('arrayElementsInputs'); // Changed from arrayElementsInputs
const performMinFlipsOperationBtn = document.getElementById('performMinFlipsBtn'); // Changed from performMinFlipsBtn
const cancelMinFlipsOperationBtn = document.getElementById('cancelMinFlipsBtn'); // Changed from cancelMinFlipsBtn
// Add with other DOM elements
const findMaxAbsDiffBtn = document.getElementById('findMaxAbsDiffBtn');
// Add with other DOM elements
const maxCircularSubarrayBtn = document.getElementById('maxCircularSubarrayBtn');
// Add with other DOM elements
const wiggleSortIIBtn = document.getElementById('wiggleSortIIBtn');
// Add with other DOM elements
const maxDistanceSameElementsBtn = document.getElementById('maxDistanceSameElementsBtn');
// Add with other DOM elements
const pairDifferenceK = document.getElementById('pairDifferenceK');
const countPairsWithDifferenceBtn = document.getElementById('countPairsWithDifferenceBtn');
// Add with other DOM elements
const minSwapsK = document.getElementById('minSwapsK');
const minSwapsBtn = document.getElementById('minSwapsBtn');
// Add with other DOM elements
const missingRepeatingMethod = document.getElementById('missingRepeatingMethod');
const findMissingRepeatingBtn = document.getElementById('findMissingRepeatingBtn');
// Add with other DOM elements
const findFirstRepeatingBtn = document.getElementById('findFirstRepeatingBtn');
// Add with other DOM elements
const conditionalWhereBtn = document.getElementById('conditionalWhereBtn');
const multiConditionSelectBtn = document.getElementById('multiConditionSelectBtn');
const piecewiseEvaluateBtn = document.getElementById('piecewiseEvaluateBtn');
const conditionalOperationsGroup = document.getElementById('conditionalOperationsGroup');
const arraySizesGroup = document.getElementById('arraySizesGroup');
const arrayElementsGroup = document.getElementById('arrayElementsGroup');
const conditionGroup = document.getElementById('conditionGroup');
const arraySize1 = document.getElementById('arraySize1');
const arraySize2 = document.getElementById('arraySize2');
const confirmArraySizesBtn = document.getElementById('confirmArraySizesBtn');
const array1Inputs = document.getElementById('array1Inputs');
const array2Inputs = document.getElementById('array2Inputs');
const conditionOperator = document.getElementById('conditionOperator');
const conditionValue = document.getElementById('conditionValue');
const confirmConditionBtn = document.getElementById('confirmConditionBtn');
const cancelConditionalBtn = document.getElementById('cancelConditionalBtn');
// Add these with other DOM elements
const previousGreaterBtn = document.getElementById('previousGreaterBtn');
const previousSmallerBtn = document.getElementById('previousSmallerBtn');
// Add with other DOM elements
const predicateCondition = document.getElementById('predicateCondition');
const findByPredicateBtn = document.getElementById('findByPredicateBtn');
// Add with other DOM elements
const convertTo2DBtn = document.getElementById('convertTo2DBtn');
// Add with other DOM elements
const getDataTypeBtn = document.getElementById('getDataTypeBtn');
const createTypedArrayBtn = document.getElementById('createTypedArrayBtn');
const convertToListBtn = document.getElementById('convertToListBtn');
const dataTypeInputGroup = document.getElementById('dataTypeInputGroup');
const typedArraySize = document.getElementById('typedArraySize');
const dataTypeSelect = document.getElementById('dataTypeSelect');
const confirmDataTypeBtn = document.getElementById('confirmDataTypeBtn');
const cancelDataTypeBtn = document.getElementById('cancelDataTypeBtn');
// Add with other DOM elements
const shuffleElementsBtn = document.getElementById('shuffleElementsBtn');
// Add with other DOM elements
const binCount = document.getElementById('binCount');
const binWidth = document.getElementById('binWidth');
const binIntervalsBtn = document.getElementById('binIntervalsBtn');
const binByWidthBtn = document.getElementById('binByWidthBtn');
// Add with other DOM elements
const ufuncSelect = document.getElementById('ufuncSelect');
const applyUfuncBtn = document.getElementById('applyUfuncBtn');
const ufuncParams = document.getElementById('ufuncParams');
const clampLow = document.getElementById('clampLow');
const clampHigh = document.getElementById('clampHigh');
const euclidRef = document.getElementById('euclidRef');
const bitwiseOperand = document.getElementById('bitwiseOperand');
const leakyReluAlpha = document.getElementById('leakyReluAlpha');
// Stock Market Operations DOM Elements
const stockPricesInput = document.getElementById('stockPricesInput');
const loadStockPricesBtn = document.getElementById('loadStockPricesBtn');
const dailyReturnsBtn = document.getElementById('dailyReturnsBtn');
const logReturnsBtn = document.getElementById('logReturnsBtn');
const cumulativeReturnsBtn = document.getElementById('cumulativeReturnsBtn');
const totalReturnBtn = document.getElementById('totalReturnBtn');
const priceDifferenceBtn = document.getElementById('priceDifferenceBtn');
const priceMomentumBtn = document.getElementById('priceMomentumBtn');
const rateOfChangeBtn = document.getElementById('rateOfChangeBtn');
const gapAnalysisBtn = document.getElementById('gapAnalysisBtn');
const intradayGainBtn = document.getElementById('intradayGainBtn');
// Add these with your existing stock market variables
const smaBtn = document.getElementById('smaBtn');
const emaBtn = document.getElementById('emaBtn');
const macdBtn = document.getElementById('macdBtn');
const macdSignalBtn = document.getElementById('macdSignalBtn');
const bollingerMiddleBtn = document.getElementById('bollingerMiddleBtn');
const bollingerUpperBtn = document.getElementById('bollingerUpperBtn');
// Add with other DOM elements
const axisFunctionSelect = document.getElementById('axisFunctionSelect');
const applyAxisBtn = document.getElementById('applyAxisBtn');
const customFunctionGroup = document.getElementById('customFunctionGroup');
const customFunction = document.getElementById('customFunction');
const matrixDimensionsGroup = document.getElementById('matrixDimensionsGroup');
const matrixRowsInput = document.getElementById('matrixRows');
const matrixColsInput = document.getElementById('matrixCols');
const createMatrixBtn = document.getElementById('createMatrixBtn');
// Add with other DOM elements
const findMinIndexBtn = document.getElementById('findMinIndexBtn');
const findMaxIndexBtn = document.getElementById('findMaxIndexBtn');
const findNSmallestBtn = document.getElementById('findNSmallestBtn');
const findNLargestBtn = document.getElementById('findNLargestBtn');
const nValueInputGroup = document.getElementById('nValueInputGroup');
const nValueInput = document.getElementById('nValueInput');
const confirmNValueBtn = document.getElementById('confirmNValueBtn');
const cancelNValueBtn = document.getElementById('cancelNValueBtn');
// Add with other DOM elements
const parenthesesInput = document.getElementById('parenthesesInput');
const validParenthesesBtn = document.getElementById('validParenthesesBtn');
// Add with other DOM elements
const checkPalindromeBtn = document.getElementById('checkPalindromeBtn');
const findAnagramsBtn = document.getElementById('findAnagramsBtn');
// Add with other DOM elements
const rangeSumStart = document.getElementById('rangeSumStart');
const rangeSumEnd = document.getElementById('rangeSumEnd');
const rangeSumQueryBtn = document.getElementById('rangeSumQueryBtn');
// Add with other DOM elements
const dailyTemperaturesBtn = document.getElementById('dailyTemperaturesBtn');
// Add with other DOM elements
const firstLastTarget = document.getElementById('firstLastTarget');
const findFirstLastBtn = document.getElementById('findFirstLastBtn');
// Add with other DOM elements
const palindromeInput = document.getElementById('palindromeInput');
const longestPalindromeInput = document.getElementById('longestPalindromeInput');
const findPalindromicSubstringsBtn = document.getElementById('findPalindromicSubstringsBtn');
const findLongestPalindromicSubstringBtn = document.getElementById('findLongestPalindromicSubstringBtn');
// Add these with other DOM elements
const wildcardMatchingBtn = document.getElementById('wildcardMatchingBtn');
const regexMatchingBtn = document.getElementById('regexMatchingBtn');
const patternMatchingGroup = document.getElementById('patternMatchingGroup');
const patternString = document.getElementById('patternString');
const patternPattern = document.getElementById('patternPattern');
const confirmPatternMatchingBtn = document.getElementById('confirmPatternMatchingBtn');
const cancelPatternMatchingBtn = document.getElementById('cancelPatternMatchingBtn');
const patternMatchingLabel = document.getElementById('patternMatchingLabel');
// Add with other DOM elements
const combinationSumBtn = document.getElementById('combinationSumBtn');
const subsetsBtn = document.getElementById('subsetsBtn');
const combinationSumGroup = document.getElementById('combinationSumGroup');
const combinationSumTarget = document.getElementById('combinationSumTarget');
const confirmCombinationSumBtn = document.getElementById('confirmCombinationSumBtn');
const cancelCombinationSumBtn = document.getElementById('cancelCombinationSumBtn');
// Add with other DOM elements
const longestValidParenthesesBtn = document.getElementById('longestValidParenthesesBtn');
const distinctSubsequencesBtn = document.getElementById('distinctSubsequencesBtn');
const parenthesesInputGroup = document.getElementById('parenthesesInputGroup');
const subsequencesInputGroup = document.getElementById('subsequencesInputGroup');
const lvpInput = document.getElementById('lvpInput');
const dsMainStringInput = document.getElementById('dsMainStringInput');
const dsTargetStringInput = document.getElementById('dsTargetStringInput');
const confirmParenthesesBtn = document.getElementById('confirmParenthesesBtn');
const cancelParenthesesBtn = document.getElementById('cancelParenthesesBtn');
const confirmSubsequencesBtn = document.getElementById('confirmSubsequencesBtn');
const cancelSubsequencesBtn = document.getElementById('cancelSubsequencesBtn');
// Add with other DOM elements
const findWordConcatenationBtn = document.getElementById('findWordConcatenationBtn');
const wordConcatInputSection = document.getElementById('wordConcatInputSection');
const textStringInputField = document.getElementById('textStringInputField');
const searchWordsInputField = document.getElementById('searchWordsInputField');
const runWordConcatSearchBtn = document.getElementById('runWordConcatSearchBtn');
const stopWordConcatSearchBtn = document.getElementById('stopWordConcatSearchBtn');
// Add with other DOM elements
const countSmallerAfterSelfBtn = document.getElementById('countSmallerAfterSelfBtn');
// Add these with other DOM elements
const uglyNumberInput = document.getElementById('uglyNumberInput');
const checkUglyNumberBtn = document.getElementById('checkUglyNumberBtn');
const nthUglyNumberInput = document.getElementById('nthUglyNumberInput');
const findNthUglyNumberBtn = document.getElementById('findNthUglyNumberBtn');
const superUglyNInput = document.getElementById('superUglyNInput');
const superUglyPrimesInput = document.getElementById('superUglyPrimesInput');
const findSuperUglyNumberBtn = document.getElementById('findSuperUglyNumberBtn');
const uglyNumberOutput = document.getElementById('uglyNumberOutput');
// Add with other DOM elements
const findPerfectNumbersBtn = document.getElementById('findPerfectNumbersBtn');
const findArmstrongNumbersBtn = document.getElementById('findArmstrongNumbersBtn');
// Add with other DOM elements
const pascalRowNumber = document.getElementById('pascalRowNumber');
const pascalNumRows = document.getElementById('pascalNumRows');
const pascalSpecificRowBtn = document.getElementById('pascalSpecificRowBtn');
const pascalMultipleRowsBtn = document.getElementById('pascalMultipleRowsBtn');
// Add with other DOM elements
const randomPickWithWeightBtn = document.getElementById('randomPickWithWeightBtn');
// Add with other DOM elements
const generateRandomPointBtn = document.getElementById('generateRandomPointBtn');
// Add with other DOM elements
const consecutiveTargetSum = document.getElementById('consecutiveTargetSum');
const findConsecutiveSequencesBtn = document.getElementById('findConsecutiveSequencesBtn');
// Add with other DOM elements
const numberInput = document.getElementById('numberInput');
const convertToEnglishBtn = document.getElementById('convertToEnglishBtn');
const findDigitOneBtn = document.getElementById('findDigitOneBtn');
// Add with other button elements
const addDigitsBtn = document.getElementById('addDigitsBtn');
const happyNumberBtn = document.getElementById('happyNumberBtn');
// Add with other DOM elements
const excelColumnNumberBtn = document.getElementById('excelColumnNumberBtn');
// Add with other DOM elements
const numberToColumnTitleBtn = document.getElementById('numberToColumnTitleBtn');
// Add these with other DOM elements
const implementStackBtn = document.getElementById('implementStackBtn');
const stackImplementationGroup = document.getElementById('stackImplementationGroup');
const stackSizeInput = document.getElementById('stackSize');
const createStackBtn = document.getElementById('createStackBtn');
const stackOperations = document.getElementById('stackOperations');
const pushValue = document.getElementById('pushValue');
const pushBtn = document.getElementById('pushBtn');
const popCount = document.getElementById('popCount');
const popBtn = document.getElementById('popBtn');
const peekBtn = document.getElementById('peekBtn');
const isFullBtn = document.getElementById('isFullBtn');
const isEmptyBtn = document.getElementById('isEmptyBtn');
const resetStackBtn = document.getElementById('resetStackBtn');
const stackInfo = document.getElementById('stackInfo');
const stackExplanation = document.getElementById('stackExplanation');
const stackSizeValue = document.getElementById('stackSizeValue');
const stackTopValue = document.getElementById('stackTopValue');
const stackStatus = document.getElementById('stackStatus');

        // Initialize
        updateStats();
        
        // Event Listeners
        createBtn.addEventListener('click', handleCreate);
        createRandomBtn.addEventListener('click', handleCreateRandom);
        insertBtn.addEventListener('click', handleInsert);
        readBtn.addEventListener('click', handleRead);
        updateBtn.addEventListener('click', handleUpdate);
        updateByElementBtn.addEventListener('click', handleUpdateByElement);
        deleteBtn.addEventListener('click', handleDelete);
        deleteByElementBtn.addEventListener('click', handleDeleteByElement);
        clearArrayBtn.addEventListener('click', handleClearArray);
        searchBtn.addEventListener('click', handleSearch);
        searchByIndexBtn.addEventListener('click', handleSearchByIndex);
        linearSearchBtn.addEventListener('click', handleLinearSearch); // NEW
        binarySearchBtn.addEventListener('click', handleBinarySearch);
        checkElementBtn.addEventListener('click', handleCheckElement);
findMinElementBtn.addEventListener('click', handleFindMinElement);
findMaxElementBtn.addEventListener('click', handleFindMaxElement);
// Add with other event listeners
shiftLeftBtn.addEventListener('click', handleShiftLeft);
shiftRightBtn.addEventListener('click', handleShiftRight);
resetShiftBtn.addEventListener('click', handleResetShift);
popLastBtn.addEventListener('click', handlePopLast);
// Add with other event listeners
traverseForwardBtn.addEventListener('click', handleTraverseForward);
traverseBackwardBtn.addEventListener('click', handleTraverseBackward);
cumulativeSumBtn.addEventListener('click', handleCumulativeSum);
prefixSumBtn.addEventListener('click', handlePrefixSum);
reverseArrayBtn.addEventListener('click', handleReverseArray);
rotateLeftBtn.addEventListener('click', () => handleRotateOperation('left'));
rotateRightBtn.addEventListener('click', () => handleRotateOperation('right'));
confirmRotateBtn.addEventListener('click', handleConfirmRotate);
cancelRotateBtn.addEventListener('click', handleCancelRotate);
fillArrayBtn.addEventListener('click', handleFillArray);
swapByValuesBtn.addEventListener('click', () => showSwapInputGroup('values'));
swapByIndicesBtn.addEventListener('click', () => showSwapInputGroup('indices'));
confirmSwapCountBtn.addEventListener('click', handleConfirmSwapCount);
confirmSwapIndicesCountBtn.addEventListener('click', handleConfirmSwapIndicesCount);
findSubarraySumBtn.addEventListener('click', handleFindSubarraySum);
generateAllSubarraysWithSumBtn.addEventListener('click', handleGenerateAllSubarraysWithSum);
// Add with other event listeners
twoPointerTraverseBtn.addEventListener('click', handleTwoPointerTraversal);
// Add with other event listeners
sortAscBtn.addEventListener('click', () => handleSort('asc'));
sortDescBtn.addEventListener('click', () => handleSort('desc'));
// Add with other event listeners
checkSortedBtn.addEventListener('click', handleCheckSorted);
partialSortBtn.addEventListener('click', handlePartialSort);
confirmPartialSortBtn.addEventListener('click', handleConfirmPartialSort);
cancelPartialSortBtn.addEventListener('click', handleCancelPartialSort);
findFirstOccurrenceBtn.addEventListener('click', handleFindFirstOccurrence);
findLastOccurrenceBtn.addEventListener('click', handleFindLastOccurrence);
findAllOccurrencesBtn.addEventListener('click', handleFindAllOccurrences);
deleteFirstOccurrenceBtn.addEventListener('click', handleDeleteFirstOccurrence);
deleteAllOccurrencesBtn.addEventListener('click', handleDeleteAllOccurrences);
removeDuplicatesInPlaceBtn.addEventListener('click', handleRemoveDuplicatesInPlace);
removeDuplicatesKeepOneBtn.addEventListener('click', handleRemoveDuplicatesKeepOne);
cloneArrayBtn.addEventListener('click', handleCloneArray);
stableSortBtn.addEventListener('click', handleStableSort);
// Add with other event listeners
sortSubarrayBtn.addEventListener('click', handleSortSubarray);
// Add with other event listeners
mergeSortedArraysBtn.addEventListener('click', handleMergeSortedArrays);
confirmFirstArraySizeBtn.addEventListener('click', handleConfirmFirstArraySize);
confirmSecondArraySizeBtn.addEventListener('click', handleConfirmSecondArraySize);
performMergeBtn.addEventListener('click', handlePerformMerge);
cancelMergeBtn.addEventListener('click', handleCancelMerge);
// Add with other event listeners
twoPointerSortBtn.addEventListener('click', handleTwoPointerSort);
kadaneAlgorithmBtn.addEventListener('click', handleKadaneAlgorithm);
moveZerosToFrontBtn.addEventListener('click', () => handleMoveZeros('front'));
moveZerosToEndBtn.addEventListener('click', () => handleMoveZeros('end'));
countSubarraysBtn.addEventListener('click', handleCountSubarrays);
generateSubarraysBtn.addEventListener('click', handleGenerateSubarrays);
// Add with other event listeners
rearrangePositiveNegativeBtn.addEventListener('click', handleRearrangePositiveNegative);
// Add with other event listeners
segregateEvenOddBtn.addEventListener('click', handleSegregateEvenOdd);
// Add with other event listeners
countElementFrequencyBtn.addEventListener('click', handleCountElementFrequency);
findDuplicatesBtn.addEventListener('click', handleFindDuplicates);
// Add with other event listeners
firstNonRepeatingBtn.addEventListener('click', handleFirstNonRepeating);
findUniqueElementsBtn.addEventListener('click', handleFindUniqueElements);
// Add with other event listeners
findMajorityElementBtn.addEventListener('click', handleFindMajorityElement);
// Add with other event listeners
sortDutchNationalFlagBtn.addEventListener('click', handleDutchNationalFlagSort);
shiftLeftAfterDeleteBtn.addEventListener('click', handleShiftLeftAfterDelete);
// Add with other event listeners
findPivotBtn.addEventListener('click', handleFindPivot);
rotatedSearchBtn.addEventListener('click', handleRotatedSearch);
// Add with other event listeners
// Add with other event listeners
createAPBtn.addEventListener('click', () => showProgressionInput('ap'));
createGPBtn.addEventListener('click', () => showProgressionInput('gp'));
confirmAPBtn.addEventListener('click', handleCreateAP);
confirmGPBtn.addEventListener('click', handleCreateGP);
cancelProgressionBtn.addEventListener('click', handleCancelProgression);
// Add these event listeners with other listeners
kthSmallestBtn.addEventListener('click', () => handleKthOperation('smallest'));
kthLargestBtn.addEventListener('click', () => handleKthOperation('largest'));
// Add these event listeners with other listeners
selectionSortBtn.addEventListener('click', handleSelectionSort);
insertionSortBtn.addEventListener('click', handleInsertionSort);
// Add with other event listeners
cyclicShiftLeftBtn.addEventListener('click', () => handleCyclicShiftOperation('left'));
cyclicShiftRightBtn.addEventListener('click', () => handleCyclicShiftOperation('right'));
confirmCyclicShiftBtn.addEventListener('click', handleConfirmCyclicShift);
cancelCyclicShiftBtn.addEventListener('click', handleCancelCyclicShift);
// Add with other event listeners
inPlaceNegationBtn.addEventListener('click', handleInPlaceNegation);
// Add these event listeners with other listeners
findNBy3ElementsBtn.addEventListener('click', handleFindNBy3Elements);
nextGreaterElementBtn.addEventListener('click', handleNextGreaterElement);
// Add event listeners
shallowCopyBtn.addEventListener('click', handleShallowCopy);
confirmShallowCopyBtn.addEventListener('click', handleConfirmShallowCopy);
cancelShallowCopyBtn.addEventListener('click', handleCancelShallowCopy);
// Add with other event listeners
inPlaceMergeSortBtn.addEventListener('click', handleInPlaceMergeSort);
// Add with other event listeners
insertSortedBtn.addEventListener('click', handleInsertSorted);
confirmInsertSortedCountBtn.addEventListener('click', handleConfirmInsertSortedCount);
performInsertSortedBtn.addEventListener('click', handlePerformInsertSorted);
cancelInsertSortedBtn.addEventListener('click', handleCancelInsertSorted);
// Add with other event listeners
generateRandomArrayBtn.addEventListener('click', handleGenerateRandomArray);
// Add with other event listeners
convertToCharArrayBtn.addEventListener('click', handleConvertToCharArray);
confirmStringBtn.addEventListener('click', handleConfirmString);
cancelStringBtn.addEventListener('click', handleCancelString);
// Event Listeners
customComparatorSortBtn.addEventListener('click', handleCustomComparatorSort);
createDictionaryBtn.addEventListener('click', handleCreateDictionary);
confirmFieldCountBtn.addEventListener('click', handleConfirmFieldCount);
addRecordBtn.addEventListener('click', handleAddRecord);
finishDataEntryBtn.addEventListener('click', handleFinishDataEntry);
updateDictionaryBtn.addEventListener('click', handleUpdateDictionary);
dropDictionaryBtn.addEventListener('click', handleDropDictionary);
performSortBtn.addEventListener('click', handlePerformSort);
resetAfterSortBtn.addEventListener('click', handleResetAfterSort);
cancelCustomSortBtn.addEventListener('click', handleCancelCustomSort);
// Add with other event listeners
quickSortBtn.addEventListener('click', handleQuickSort);
heapSortBtn.addEventListener('click', handleHeapSort);
// Add with other event listeners
sortEvenBeforeOddBtn.addEventListener('click', handleSortEvenBeforeOdd);
sortByAbsoluteValueBtn.addEventListener('click', handleSortByAbsoluteValue);
// Add with other event listeners
popFirstBtn.addEventListener('click', handlePopFirst);
shiftRightInsertBtn.addEventListener('click', handleShiftRightInsert);
confirmShiftInsertBtn.addEventListener('click', handleConfirmShiftInsert);
cancelShiftInsertBtn.addEventListener('click', handleCancelShiftInsert);
// Add with other event listeners
findTripletsBtn.addEventListener('click', handleFindTriplets);
findQuadrupletsBtn.addEventListener('click', handleFindQuadruplets);
// Add with other event listeners
equilibriumPointBtn.addEventListener('click', handleEquilibriumPoint);
// Add with other event listeners
containerWithMostWaterBtn.addEventListener('click', handleContainerWithMostWater);
trappingRainWaterBtn.addEventListener('click', handleTrappingRainWater);
// Add with other event listeners
twoSumBtn.addEventListener('click', handleTwoSum);
confirmTwoSumBtn.addEventListener('click', handleConfirmTwoSum);
cancelTwoSumBtn.addEventListener('click', handleCancelTwoSum);
// Add with other event listeners
findGcdBtn.addEventListener('click', handleFindGCD);
findLcmBtn.addEventListener('click', handleFindLCM);
// Add with other event listeners
primeSieveBtn.addEventListener('click', handlePrimeSieve);
// Add with other event listeners
findLongestSubstringBtn.addEventListener('click', handleFindLongestSubstring);
// Add with other event listeners
subarrayProductBtn.addEventListener('click', handleSubarrayProduct);
// Add with other event listeners
leaderInArrayBtn.addEventListener('click', handleLeaderInArray);
// Add with other event listeners
jumpGameBtn.addEventListener('click', handleJumpGame);
// Add with other event listeners
bestTimeStockBtn.addEventListener('click', handleBestTimeStock);
// Add with other event listeners
findSubarrayNearZeroBtn.addEventListener('click', handleFindSubarrayNearZero);
// Add with other event listeners
minWindowSubstringBtn.addEventListener('click', handleMinWindowSubstring);
performMinWindowBtn.addEventListener('click', handlePerformMinWindow);
cancelMinWindowBtn.addEventListener('click', handleCancelMinWindow);
// Add with other event listeners
maxKConsecutiveBtn.addEventListener('click', () => handleKConsecutive('max'));
minKConsecutiveBtn.addEventListener('click', () => handleKConsecutive('min'));
// Add with other event listeners
rearrangeMinMaxBtn.addEventListener('click', handleRearrangeMinMax);
// Add with other event listeners
nextPermutationBtn.addEventListener('click', handleNextPermutation);
// Add with other event listeners
longestConsecutiveSequenceBtn.addEventListener('click', handleLongestConsecutiveSequence);
maxConsecutiveOnesBtn.addEventListener('click', handleMaxConsecutiveOnes);
// Add with other event listeners
mergeIntervalsBtn.addEventListener('click', handleMergeIntervals);
// Add with other event listeners
unionArraysBtn.addEventListener('click', () => handleSetOperation('union'));
intersectionArraysBtn.addEventListener('click', () => handleSetOperation('intersection'));
confirmNumArraysBtn.addEventListener('click', handleConfirmNumArrays);
performSetOperationBtn.addEventListener('click', handlePerformSetOperation);
cancelSetOperationBtn.addEventListener('click', handleCancelSetOperation);
// Add with other event listeners
setDifferenceBtn.addEventListener('click', () => handleSetOperation('difference'));
symmetricDifferenceBtn.addEventListener('click', () => handleSetOperation('symmetric'));
confirmNumArraysBtn.addEventListener('click', handleConfirmNumArrays);
performSetOperationBtn.addEventListener('click', handlePerformSetOperation);
cancelSetOperationBtn.addEventListener('click', handleCancelSetOperation);
// Add these with other event listeners
checkSubsetCompBtn.addEventListener('click', handleCheckSubsetComp);
checkSupersetCompBtn.addEventListener('click', handleCheckSupersetComp);
confirmNumArraysSubsetCompBtn.addEventListener('click', handleConfirmNumArraysSubsetComp);
confirmNumArraysSupersetCompBtn.addEventListener('click', handleConfirmNumArraysSupersetComp);
performSubsetCompBtn.addEventListener('click', handlePerformSubsetComp);
performSupersetCompBtn.addEventListener('click', handlePerformSupersetComp);
cancelSubsetCompBtn.addEventListener('click', handleCancelSubsetComp);
cancelSupersetCompBtn.addEventListener('click', handleCancelSupersetComp);
// Add with other event listeners
findFirstGreaterBtn.addEventListener('click', () => handleFindComparison('greater'));
findLastLessBtn.addEventListener('click', () => handleFindComparison('less'));
// Add with other event listeners
findCovarianceBtn.addEventListener('click', () => handleStatisticalOperation('covariance'));
findCorrelationBtn.addEventListener('click', () => handleStatisticalOperation('correlation'));
confirmArrayCountBtn.addEventListener('click', handleConfirmArrayCount);
performStatisticalOperationBtn.addEventListener('click', handlePerformStatisticalOperation);
cancelStatisticalOperationBtn.addEventListener('click', handleCancelStatisticalOperation);
// Add with other event listeners
findMeanBtn.addEventListener('click', handleFindMean);
findMedianBtn.addEventListener('click', handleFindMedian);
// Add with other event listeners
elementWiseMaxBtn.addEventListener('click', () => handleElementWiseOperation('max'));
elementWiseMinBtn.addEventListener('click', () => handleElementWiseOperation('min'));
confirmFirstArraySizeElementWiseBtn.addEventListener('click', handleConfirmFirstArraySizeElementWise);
confirmSecondArraySizeElementWiseBtn.addEventListener('click', handleConfirmSecondArraySizeElementWise);
performElementWiseBtn.addEventListener('click', handlePerformElementWise);
cancelElementWiseBtn.addEventListener('click', handleCancelElementWise);
// Add with other event listeners
logicalAndBtn.addEventListener('click', () => handleLogicalOperation('AND'));
logicalOrBtn.addEventListener('click', () => handleLogicalOperation('OR'));
confirmArraysCountBtn.addEventListener('click', handleConfirmArraysCount);
performLogicalOperationBtn.addEventListener('click', handlePerformLogicalOperation);
cancelLogicalOperationBtn.addEventListener('click', handleCancelLogicalOperation);
// Add with other event listeners
calculateStdDevBtn.addEventListener('click', handleCalculateStdDev);
calculateVarianceBtn.addEventListener('click', handleCalculateVariance);
// Add with other event listeners
addScalarBtn.addEventListener('click', () => handleScalarOperation('add'));
subtractScalarBtn.addEventListener('click', () => handleScalarOperation('subtract'));
multiplyScalarBtn.addEventListener('click', () => handleScalarOperation('multiply'));
divideScalarBtn.addEventListener('click', () => handleScalarOperation('divide'));
// Add with other event listeners
calcSinBtn.addEventListener('click', () => handleTrigOperation('sin'));
calcCosBtn.addEventListener('click', () => handleTrigOperation('cos'));
calcTanBtn.addEventListener('click', () => handleTrigOperation('tan'));
// Add with other event listeners
findRangeBtn.addEventListener('click', handleFindRange);
// Add with other event listeners
calculateExponentialBtn.addEventListener('click', () => handleMathOperation('exponential'));
calculateNaturalLogBtn.addEventListener('click', () => handleMathOperation('naturalLog'));
calculateLog10Btn.addEventListener('click', () => handleMathOperation('log10'));
// Add with other event listeners
document.getElementById('pancakeSortBtn').addEventListener('click', handlePancakeSort);
// Add with other event listeners
stockSpanBtn.addEventListener('click', handleStockSpan);
// Add Enter key support if needed
// Add with other event listeners
maxPairAndOrBtn.addEventListener('click', handleMaxPairAndOr);
// Add with other event listeners
largestRectangleHistogramBtn.addEventListener('click', handleLargestRectangleHistogram);
// Add with other event listeners
fruitIntoBasketsBtn.addEventListener('click', handleFruitIntoBaskets);
// Add with other event listeners
addArraysElementWiseBtn.addEventListener('click', () => handleElementWiseOperation('add'));
subtractArraysElementWiseBtn.addEventListener('click', () => handleElementWiseOperation('subtract'));
multiplyArraysElementWiseBtn.addEventListener('click', () => handleElementWiseOperation('multiply'));
divideArraysElementWiseBtn.addEventListener('click', () => handleElementWiseOperation('divide'));
modulusArraysElementWiseBtn.addEventListener('click', () => handleElementWiseOperation('modulus'));
confirmElementWiseFirstArraySizeBtn.addEventListener('click', handleConfirmElementWiseFirstArraySize);
confirmElementWiseSecondArraySizeBtn.addEventListener('click', handleConfirmElementWiseSecondArraySize);
performElementWiseOperationBtn.addEventListener('click', handlePerformElementWiseOperation);
cancelElementWiseOperationBtn.addEventListener('click', handleCancelElementWiseOperation);
// Add with other event listeners
logicalNotBtn.addEventListener('click', handleLogicalNot);
logicalXorBtn.addEventListener('click', handleLogicalXor);
confirmLogicalNotSizeBtn.addEventListener('click', handleConfirmLogicalNotSize);
cancelLogicalNotBtn.addEventListener('click', handleCancelLogicalNot);
confirmLogicalXorArrayCountBtn.addEventListener('click', handleConfirmLogicalXorArrayCount);
cancelLogicalXorBtn.addEventListener('click', handleCancelLogicalXor);
// Add with other event listeners
transformNonDecreasingBtn.addEventListener('click', handleTransformNonDecreasing);
// Add with other event listeners - USING UPDATED VARIABLE NAMES
minFlipsOrBtn.addEventListener('click', () => handleMinFlipsOperation('or'));
minFlipsAndBtn.addEventListener('click', () => handleMinFlipsOperation('and'));
confirmNumArraysButton.addEventListener('click', handleConfirmNumArrays); // Updated variable name
performMinFlipsOperationBtn.addEventListener('click', handlePerformMinFlips); // Updated variable name
cancelMinFlipsOperationBtn.addEventListener('click', handleCancelMinFlips); // Updated variable name
// Add with other event listeners
prefixXorBtn.addEventListener('click', handlePrefixXor);
// Add with other event listeners
findMaxAbsDiffBtn.addEventListener('click', handleFindMaxAbsDiff);
// Add with other event listeners
maxCircularSubarrayBtn.addEventListener('click', handleMaxCircularSubarray);
// Add with other event listeners
wiggleSortIIBtn.addEventListener('click', handleWiggleSortII);
// Add with other event listeners
maxDistanceSameElementsBtn.addEventListener('click', handleMaxDistanceSameElements);
// Add with other event listeners
countPairsWithDifferenceBtn.addEventListener('click', handleCountPairsWithDifference);
// Add with other event listeners
minSwapsBtn.addEventListener('click', handleMinSwaps);
// Add with other event listeners
findMissingRepeatingBtn.addEventListener('click', handleFindMissingRepeating);
// Add with other event listeners
findFirstRepeatingBtn.addEventListener('click', handleFindFirstRepeating);
// Add with other event listeners
conditionalWhereBtn.addEventListener('click', () => handleConditionalOperation('where'));
multiConditionSelectBtn.addEventListener('click', () => handleConditionalOperation('select'));
piecewiseEvaluateBtn.addEventListener('click', () => handleConditionalOperation('piecewise'));
confirmArraySizesBtn.addEventListener('click', handleConfirmArraySizes);
confirmConditionBtn.addEventListener('click', handleConfirmCondition);
cancelConditionalBtn.addEventListener('click', handleCancelConditional);
// Add these with other event listeners
previousGreaterBtn.addEventListener('click', () => handlePreviousElement('greater'));
previousSmallerBtn.addEventListener('click', () => handlePreviousElement('smaller'));
// Add with other event listeners
findByPredicateBtn.addEventListener('click', handleFindByPredicate);
// Add with other event listeners
convertTo2DBtn.addEventListener('click', handleConvertTo2D);
// Add with other event listeners
getDataTypeBtn.addEventListener('click', handleGetDataType);
createTypedArrayBtn.addEventListener('click', handleCreateTypedArray);
convertToListBtn.addEventListener('click', handleConvertToList);
confirmDataTypeBtn.addEventListener('click', handleConfirmDataType);
cancelDataTypeBtn.addEventListener('click', handleCancelDataType);
// Add with other event listeners
shuffleElementsBtn.addEventListener('click', handleShuffleElements);
// Add with other event listeners
binIntervalsBtn.addEventListener('click', handleBinIntervals);
binByWidthBtn.addEventListener('click', handleBinByWidth);
// Add with other event listeners
applyUfuncBtn.addEventListener('click', handleApplyUfunc);
ufuncSelect.addEventListener('change', handleUfuncSelection);
// Stock Market Event Listeners
loadStockPricesBtn.addEventListener('click', handleLoadStockPrices);
dailyReturnsBtn.addEventListener('click', () => handleStockOperation('dailyReturns'));
logReturnsBtn.addEventListener('click', () => handleStockOperation('logReturns'));
cumulativeReturnsBtn.addEventListener('click', () => handleStockOperation('cumulativeReturns'));
totalReturnBtn.addEventListener('click', () => handleStockOperation('totalReturn'));
priceDifferenceBtn.addEventListener('click', () => handleStockOperation('priceDifference'));
// Add these with your existing event listeners
priceMomentumBtn.addEventListener('click', () => handleStockOperation('priceMomentum'));
rateOfChangeBtn.addEventListener('click', () => handleStockOperation('rateOfChange'));
gapAnalysisBtn.addEventListener('click', () => handleStockOperation('gapAnalysis'));
intradayGainBtn.addEventListener('click', () => handleStockOperation('intradayGain'));
// Add these with your existing event listeners
smaBtn.addEventListener('click', () => handleStockOperation('sma'));
emaBtn.addEventListener('click', () => handleStockOperation('ema'));
macdBtn.addEventListener('click', () => handleStockOperation('macd'));
macdSignalBtn.addEventListener('click', () => handleStockOperation('macdSignal'));
bollingerMiddleBtn.addEventListener('click', () => handleStockOperation('bollingerMiddle'));
bollingerUpperBtn.addEventListener('click', () => handleStockOperation('bollingerUpper'));
// Add with other event listeners
applyAxisBtn.addEventListener('click', handleApplyAxis);
axisFunctionSelect.addEventListener('change', handleAxisFunctionChange);
createMatrixBtn.addEventListener('click', handleCreateMatrix);
// Add event listeners for statistical operations
findMinIndexBtn.addEventListener('click', () => handleStatisticalOperation('minIndex'));
findMaxIndexBtn.addEventListener('click', () => handleStatisticalOperation('maxIndex'));
findNSmallestBtn.addEventListener('click', () => handleStatisticalOperation('nSmallest'));
findNLargestBtn.addEventListener('click', () => handleStatisticalOperation('nLargest'));
confirmNValueBtn.addEventListener('click', handleConfirmNValue);
cancelNValueBtn.addEventListener('click', handleCancelNValue);
// Add with other event listeners
validParenthesesBtn.addEventListener('click', handleValidParentheses);
// Add with other event listeners
maxSubarraySumBtn.addEventListener('click', handleMaxSubarraySum);
maxProductSubarrayBtn.addEventListener('click', handleMaxProductSubarray);
// Add with other event listeners
checkPalindromeBtn.addEventListener('click', handleCheckPalindrome);
findAnagramsBtn.addEventListener('click', handleFindAnagrams);
// Add with other event listeners
rangeSumQueryBtn.addEventListener('click', handleRangeSumQuery);
// Add with other event listeners
dailyTemperaturesBtn.addEventListener('click', handleDailyTemperatures);
// Add with other event listeners
findFirstLastBtn.addEventListener('click', handleFindFirstLast);
// Add with other event listeners
findPalindromicSubstringsBtn.addEventListener('click', handleFindPalindromicSubstrings);
findLongestPalindromicSubstringBtn.addEventListener('click', handleFindLongestPalindromicSubstring);
// Add these with other event listeners
wildcardMatchingBtn.addEventListener('click', () => handlePatternMatching('wildcard'));
regexMatchingBtn.addEventListener('click', () => handlePatternMatching('regex'));
confirmPatternMatchingBtn.addEventListener('click', handleConfirmPatternMatching);
cancelPatternMatchingBtn.addEventListener('click', handleCancelPatternMatching);
// Add with other event listeners
combinationSumBtn.addEventListener('click', handleCombinationSum);
subsetsBtn.addEventListener('click', handleSubsets);
confirmCombinationSumBtn.addEventListener('click', handleConfirmCombinationSum);
cancelCombinationSumBtn.addEventListener('click', handleCancelCombinationSum);
// Add with other event listeners
longestValidParenthesesBtn.addEventListener('click', handleLongestValidParentheses);
distinctSubsequencesBtn.addEventListener('click', handleDistinctSubsequences);
confirmParenthesesBtn.addEventListener('click', handleConfirmParentheses);
cancelParenthesesBtn.addEventListener('click', handleCancelParentheses);
confirmSubsequencesBtn.addEventListener('click', handleConfirmSubsequences);
cancelSubsequencesBtn.addEventListener('click', handleCancelSubsequences);
// Add with other event listeners
findWordConcatenationBtn.addEventListener('click', handleStartWordConcatSearch);
runWordConcatSearchBtn.addEventListener('click', handleRunWordConcatSearch);
stopWordConcatSearchBtn.addEventListener('click', handleStopWordConcatSearch);
// Add with other event listeners
countSmallerAfterSelfBtn.addEventListener('click', handleCountSmallerAfterSelf);
// Add these with other event listeners
checkUglyNumberBtn.addEventListener('click', handleCheckUglyNumber);
findNthUglyNumberBtn.addEventListener('click', handleFindNthUglyNumber);
findSuperUglyNumberBtn.addEventListener('click', handleFindSuperUglyNumber);
// Add with other event listeners
findPerfectNumbersBtn.addEventListener('click', handleFindPerfectNumbers);
findArmstrongNumbersBtn.addEventListener('click', handleFindArmstrongNumbers);
// Add with other event listeners
pascalSpecificRowBtn.addEventListener('click', handlePascalSpecificRow);
pascalMultipleRowsBtn.addEventListener('click', handlePascalMultipleRows);
// Add with other event listeners
randomPickWithWeightBtn.addEventListener('click', handleRandomPickWithWeight);
// Add with other event listeners
generateRandomPointBtn.addEventListener('click', handleGenerateRandomPoint);
// Add with other event listeners
findConsecutiveSequencesBtn.addEventListener('click', handleFindConsecutiveSequences);
// Add with other event listeners
convertToEnglishBtn.addEventListener('click', handleConvertToEnglish);
findDigitOneBtn.addEventListener('click', handleFindDigitOne);
// Add with other event listeners
addDigitsBtn.addEventListener('click', handleAddDigits);
happyNumberBtn.addEventListener('click', handleHappyNumber);
// Add with other event listeners
excelColumnNumberBtn.addEventListener('click', handleExcelColumnNumber);
// Add with other event listeners
numberToColumnTitleBtn.addEventListener('click', handleNumberToColumnTitle);
// Add these with other event listeners
implementStackBtn.addEventListener('click', handleImplementStack);
createStackBtn.addEventListener('click', handleCreateStack);
pushBtn.addEventListener('click', handlePush);
popBtn.addEventListener('click', handlePop);
peekBtn.addEventListener('click', handlePeek);
isFullBtn.addEventListener('click', handleIsFull);
isEmptyBtn.addEventListener('click', handleIsEmpty);
resetStackBtn.addEventListener('click', handleResetStack);

        // Allow Enter key to trigger operations
        createValue.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleCreate();
        });
        
        insertValue.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleInsert();
        });
        
        readIndex.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleRead();
        });
        
        updateValue.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleUpdate();
        });
        
        updateNewValue.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleUpdateByElement();
        });
        
        deleteIndex.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleDelete();
        });
        
        deleteElement.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleDeleteByElement();
        });
        // Add Enter key support
deleteFirstOccurrence.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleDeleteFirstOccurrence();
});
deleteAllOccurrences.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleDeleteAllOccurrences();
});
        searchElement.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleSearch();
        });
        
        searchIndex.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleSearchByIndex();
        });
        
        linearSearchElement.addEventListener('keypress', (e) => { // NEW
            if (e.key === 'Enter') handleLinearSearch();
        });
        // Add Enter key support
binarySearchElement.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleBinarySearch();
});
checkElement.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCheckElement();
});
        // Add these with other event listeners
createArrayFromRangeBtn.addEventListener('click', handleCreateArrayFromRange);
resizeArrayBtn.addEventListener('click', handleResizeArray);

// Add Enter key support
arraySize.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCreateArrayFromRange();
});

resizeSize.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleResizeArray();
});
// Add Enter key support
cloneIndex.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCloneArray();
});
cloneElementValue.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCloneArray();
});
// Add Enter key support
substringInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindLongestSubstring();
});
// Add Enter key support
elementWiseFirstArraySizeInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmElementWiseFirstArraySize();
});
elementWiseSecondArraySizeInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmElementWiseSecondArraySize();
});

// Add these with other event listeners
sliceBtn.addEventListener('click', handleSlice);
resetArrayBtn.addEventListener('click', handleResetArray);
document.getElementById('resetTransformationBtn').addEventListener('click', resetTransformation);
// Add with other event listeners
fixedWindowBtn.addEventListener('click', handleFixedWindow);
variableWindowBtn.addEventListener('click', handleVariableWindow);


// Add Enter key support
sliceStart.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleSlice();
});
sliceEnd.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleSlice();
});
// Add Enter key support
rotatePositionsInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmRotate();
});
// Add Enter key support
fillValue.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFillArray();
});
fillStart.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFillArray();
});
fillEnd.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFillArray();
});
swapCount.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmSwapCount();
});
swapIndicesCount.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmSwapIndicesCount();
});
// Add Enter key support
subarraySumInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindSubarraySum();
});
// Add Enter key support
partialSortCount.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmPartialSort();
});
// Add Enter key support
occurrenceElement.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindFirstOccurrence();
});
occurrenceElementLast.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindLastOccurrence();
});
occurrenceElementAll.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindAllOccurrences();
});
// Add Enter key support
sortSubarrayStart.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleSortSubarray();
});
sortSubarrayEnd.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleSortSubarray();
});

// Add Enter key support
firstArraySizeInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmFirstArraySize();
});
secondArraySizeInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmSecondArraySize();
});
// Add Enter key support
fixedWindowSize.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFixedWindow();
});
variableWindowSum.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleVariableWindow();
});
// Add Enter key support
subarrayInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCountSubarrays();
});
// Add Enter key support
shiftDeleteIndex.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleShiftLeftAfterDelete();
});
// Add Enter key support
rotatedSearchElement.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleRotatedSearch();
});
// Add Enter key support
apFirstTerm.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCreateAP();
});
apCommonDiff.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCreateAP();
});
apNumTerms.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCreateAP();
});
gpFirstTerm.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCreateGP();
});
gpCommonRatio.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCreateGP();
});
gpNumTerms.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCreateGP();
});
kthElementInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        // Default to kth smallest if Enter is pressed
        handleKthOperation('smallest');
    }
});
// Add Enter key support
cyclicShiftPositionsInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmCyclicShift();
});
// Add Enter key support
shallowCopyCount.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleShallowCopy();
});
// Add Enter key support
insertSortedCountInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmInsertSortedCount();
});
// Add Enter key support
randomArraySize.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleGenerateRandomArray();
});
// Add Enter key support
inputString.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmString();
});
// Enter key support
dictionaryName.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCreateDictionary();
});

fieldCount.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmFieldCount();
});
// Add Enter key support
insertShiftIndex.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmShiftInsert();
});
insertShiftValue.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmShiftInsert();
});
// Add Enter key support
tripletSumInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindTriplets();
});

quadrupletSumInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindQuadruplets();
});
// Add Enter key support
twoSumTargetInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmTwoSum();
});
// Add Enter key support
subarrayProductK.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleSubarrayProduct();
});
// Add Enter key support
mainStringInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') targetStringInput.focus();
});

targetStringInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handlePerformMinWindow();
});
// Add Enter key support
kConsecutiveSize.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        // Default to max if Enter is pressed without clicking a specific button
        handleKConsecutive('max');
    }
});
// Add Enter key support
numArrays.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmNumArrays();
});
// Add Enter key support
numArraysSubsetComp.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmNumArraysSubsetComp();
});
numArraysSupersetComp.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmNumArraysSupersetComp();
});
// Use event delegation for dynamically created buttons
document.addEventListener('click', function(e) {
    // Handle edit record button clicks
    if (e.target.closest('.edit-record')) {
        const button = e.target.closest('.edit-record');
        const index = parseInt(button.getAttribute('data-index'));
        handleEditRecord(index);
    }
    
    // Handle delete record button clicks
    if (e.target.closest('.delete-record')) {
        const button = e.target.closest('.delete-record');
        const index = parseInt(button.getAttribute('data-index'));
        handleDeleteRecord(index);
    }
    
    // Handle inline edit field clicks
    if (e.target.classList.contains('editable-field')) {
        const td = e.target;
        const fieldName = td.getAttribute('data-field');
        const recordIndex = parseInt(td.getAttribute('data-index'));
        startEditField(td, fieldName, recordIndex);
    }
});
// Add Enter key support
comparisonValue.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindComparison('greater');
});

comparisonValueLess.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindComparison('less');
});
// Add Enter key support
arrayCountInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmArrayCount();
});
// Add Enter key support
firstArraySizeElementWise.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmFirstArraySizeElementWise();
});
secondArraySizeElementWise.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmSecondArraySizeElementWise();
});
// Add Enter key support
logicalArraysCountInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmArraysCount();
});
// Add Enter key support
scalarValue.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleScalarOperation('add');
});
scalarValueSubtract.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleScalarOperation('subtract');
});
scalarValueMultiply.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleScalarOperation('multiply');
});
scalarValueDivide.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleScalarOperation('divide');
});
// Add Enter key support
logicalNotSize.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmLogicalNotSize();
});
logicalXorArrayCount.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmLogicalXorArrayCount();
});
// Add Enter key support - USING UPDATED VARIABLE NAME
numArraysInputField.addEventListener('keypress', (e) => { // Updated variable name
    if (e.key === 'Enter') handleConfirmNumArrays();
});
// Add Enter key support
pairDifferenceK.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCountPairsWithDifference();
});
// Add Enter key support
minSwapsK.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleMinSwaps();
});
// Add Enter key support for the method selection (optional)
missingRepeatingMethod.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindMissingRepeating();
});
// Add Enter key support
arraySize1.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmArraySizes();
});
arraySize2.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmArraySizes();
});
conditionValue.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmCondition();
});
// Add Enter key support
predicateCondition.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindByPredicate();
});
// Add Enter key support
typedArraySize.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmDataType();
});
// Add Enter key support
binCount.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleBinIntervals();
});
binWidth.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleBinByWidth();
});
// Add Enter key support for parameters
clampLow.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleApplyUfunc();
});
clampHigh.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleApplyUfunc();
});
euclidRef.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleApplyUfunc();
});
bitwiseOperand.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleApplyUfunc();
});
leakyReluAlpha.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleApplyUfunc();
});
// Enter key support for stock prices input
stockPricesInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleLoadStockPrices();
});
// Add Enter key support
matrixRowsInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCreateMatrix();
});
matrixColsInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCreateMatrix();
});
// Add Enter key support
parenthesesInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleValidParentheses();
});
// Add Enter key support
rangeSumStart.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleRangeSumQuery();
});
rangeSumEnd.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleRangeSumQuery();
});
// Add Enter key support
firstLastTarget.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindFirstLast();
});
// Add Enter key support
palindromeInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindPalindromicSubstrings();
});

longestPalindromeInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindLongestPalindromicSubstring();
});
// Add Enter key support
patternString.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmPatternMatching();
});
patternPattern.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmPatternMatching();
});
// Add Enter key support
combinationSumTarget.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmCombinationSum();
});
// Add Enter key support
lvpInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmParentheses();
});
dsMainStringInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmSubsequences();
});
dsTargetStringInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConfirmSubsequences();
});
// Add Enter key support
textStringInputField.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleRunWordConcatSearch();
});
searchWordsInputField.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleRunWordConcatSearch();
});
nthUglyNumberInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindNthUglyNumber();
});
superUglyNInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindSuperUglyNumber();
});
superUglyPrimesInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindSuperUglyNumber();
});
uglyNumberInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCheckUglyNumber();
});
// Add Enter key support
pascalRowNumber.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handlePascalSpecificRow();
});
pascalNumRows.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handlePascalMultipleRows();
});
// Add Enter key support
consecutiveTargetSum.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleFindConsecutiveSequences();
});
// Add Enter key support
numberInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleConvertToEnglish();
});
// Add Enter key support
stackSizeInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleCreateStack();
});

pushValue.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handlePush();
});

popCount.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handlePop();
});

document.addEventListener('keydown', (e) => {
    // Left Shift + X: Stop current animation
    if (e.shiftKey && e.key === 'X') {
        if (isStackOperationRunning) {
            stopStackAnimation();
        }
    }
    
    // Left Shift + R: Reset to original position
    if (e.shiftKey && e.key === 'R') {
        if (stack) {
            handleResetStack();
            showNotification('Reset to original position (Shift+R)', 'info');
        } else if (isStackOperationRunning) {
            stopStackAnimation();
            setTimeout(() => {
                if (stack) {
                    handleResetStack();
                    showNotification('Reset to original position (Shift+R)', 'info');
                }
            }, 500);
        }
    }
});

     // Operation Handlers
        function handleCreate() {
            const value = createValue.value.trim();
            if (value === '') {
                showNotification('Please enter a value to add', 'warning');
                createValue.focus();
                return;
            }
            
            myArray.push(value);
            createValue.value = '';
            renderArray();
            highlightElement(myArray.length - 1, 'create');
            updateStats();
            logOperation(`Added "${value}" to the array`, 'success');
        }
        
        function handleCreateRandom() {
            const randomValues = ['Apple', 'Banana', 'Cherry', 'Date', 'Elderberry', 'Fig', 'Grape', 'Honeydew'];
            const randomValue = randomValues[Math.floor(Math.random() * randomValues.length)];
            myArray.push(randomValue);
            renderArray();
            highlightElement(myArray.length - 1, 'create');
            updateStats();
            logOperation(`Added random value "${randomValue}" to the array`, 'success');
        }
        // NEW: Create Array from Range (0 to n-1)
function handleCreateArrayFromRange() {
    const size = parseInt(arraySize.value);
    
    if (isNaN(size) || size < 1 || size > 50) {
        showNotification('Please enter a valid size between 1 and 50', 'danger');
        arraySize.focus();
        return;
    }
    
    // Create array from 0 to size-1
    myArray = Array.from({length: size}, (_, i) => i.toString());
    
    renderArray();
    updateStats();
    arraySize.value = '';
    
    // Animate all elements
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation(`Created new array with ${size} elements (0 to ${size-1})`, 'success');
}

// NEW: Resize Array (Dynamic resizing)
function handleResizeArray() {
    const newSize = parseInt(resizeSize.value);
    
    if (isNaN(newSize) || newSize < 1 || newSize > 100) {
        showNotification('Please enter a valid size between 1 and 100', 'danger');
        resizeSize.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please create an array first.', 'warning');
        return;
    }
    
    const oldSize = myArray.length;
    
    if (newSize === oldSize) {
        showNotification(`Array is already size ${newSize}`, 'info');
        return;
    }
    
    if (newSize > oldSize) {
        // Extend the array - preserve existing elements and add new ones
        const currentLength = myArray.length;
        for (let i = currentLength; i < newSize; i++) {
            myArray.push(i.toString()); // Add sequential numbers for new elements
        }
        
        renderArray();
        updateStats();
        
        // Animate only the new elements
        setTimeout(() => {
            for (let i = oldSize; i < newSize; i++) {
                highlightElement(i, 'create');
            }
        }, 100);
        
        logOperation(`Resized array from ${oldSize} to ${newSize} (extended by ${newSize - oldSize} elements)`, 'success');
        
    } else {
        // Shrink the array - remove elements from the end
        const removedElements = myArray.slice(newSize);
        myArray.length = newSize;
        
        renderArray();
        updateStats();
        
        logOperation(`Resized array from ${oldSize} to ${newSize} (removed ${oldSize - newSize} elements: ${removedElements.join(', ')})`, 'warning');
    }
    
    resizeSize.value = '';
}
// NEW: Create Subarray (Slice) Handler
function handleSlice() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    const start = sliceStart.value === '' ? 0 : parseInt(sliceStart.value);
    const end = sliceEnd.value === '' ? myArray.length : parseInt(sliceEnd.value);
    
    if (isNaN(start) || start < 0 || start >= myArray.length) {
        showNotification('Please enter a valid start index', 'danger');
        sliceStart.focus();
        return;
    }
    
    if (end !== '' && (isNaN(end) || end < start || end > myArray.length)) {
        showNotification('Please enter a valid end index', 'danger');
        sliceEnd.focus();
        return;
    }
    
    // Store original array if this is the first slice operation
    if (!isSubarray) {
        originalArray = [...myArray];
    }
    
    // Create subarray
    const subarray = myArray.slice(start, end);
    
    if (subarray.length === 0) {
        showNotification('The subarray is empty. Please select different indices.', 'warning');
        return;
    }
    
    // Update the array and render
    myArray = subarray;
    isSubarray = true;
    renderArray();
    updateStats();
    
    // Clear inputs
    sliceStart.value = '';
    sliceEnd.value = '';
    
    // Highlight all elements in the subarray
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'search');
        });
    }, 100);
    
    logOperation(`Created subarray from index ${start} to ${end === '' ? myArray.length : end}`, 'success');
}

// NEW: Reset to Original Array Handler
// Update the existing handleResetArray function
function handleResetArray() {
    if ((!isSubarray && !isCurrentlySorted) || (originalArray.length === 0 && sortedArrayBackup.length === 0)) {
        showNotification('No original array to reset to', 'info');
        return;
    }
    
    // Reset from subarray OR from sorted state (binary search)
    if (isSubarray && originalArray.length > 0) {
        myArray = [...originalArray];
        isSubarray = false;
        originalArray = [];
    } else if (isCurrentlySorted && sortedArrayBackup.length > 0) {
        myArray = [...sortedArrayBackup];
        isCurrentlySorted = false;
        sortedArrayBackup = [];
    }
    
    renderArray();
    updateStats();
    
    // Highlight all elements
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation('Reset to original array', 'info');
}

        function handleInsert() {
            const index = parseInt(insertIndex.value);
            const value = insertValue.value.trim();
            
            if (isNaN(index) || index < 0 || index > myArray.length) {
                showNotification('Please enter a valid index', 'danger');
                insertIndex.focus();
                return;
            }
            
            if (value === '') {
                showNotification('Please enter a value to insert', 'warning');
                insertValue.focus();
                return;
            }
            
            myArray.splice(index, 0, value);
            renderArray();
            highlightElement(index, 'create');
            updateStats();
            insertIndex.value = '';
            insertValue.value = '';
            logOperation(`Inserted "${value}" at index ${index}`, 'success');
        }
        
        function handleRead() {
            const index = parseInt(readIndex.value);
            if (isNaN(index) || index < 0 || index >= myArray.length) {
                showNotification('Please enter a valid index', 'danger');
                readIndex.focus();
                return;
            }
            
            highlightElement(index, 'read');
            readIndex.value = '';
            logOperation(`Read value at index ${index}: "${myArray[index]}"`, 'info');
        }
        
        function handleUpdate() {
            const index = parseInt(updateIndex.value);
            const value = updateValue.value.trim();
            
            if (isNaN(index) || index < 0 || index >= myArray.length) {
                showNotification('Please enter a valid index', 'danger');
                updateIndex.focus();
                return;
            }
            
            if (value === '') {
                showNotification('Please enter a new value', 'warning');
                updateValue.focus();
                return;
            }
            
            const oldValue = myArray[index];
            myArray[index] = value;
            renderArray();
            highlightElement(index, 'update');
            updateStats();
            updateIndex.value = '';
            updateValue.value = '';
            logOperation(`Updated index ${index} from "${oldValue}" to "${value}"`, 'warning');
        }
        
        function handleUpdateByElement() {
            const element = updateElement.value.trim();
            const newValue = updateNewValue.value.trim();
            
            if (element === '') {
                showNotification('Please enter an element to update', 'warning');
                updateElement.focus();
                return;
            }
            
            if (newValue === '') {
                showNotification('Please enter a new value', 'warning');
                updateNewValue.focus();
                return;
            }
            
            const indices = [];
            for (let i = 0; i < myArray.length; i++) {
                if (myArray[i] === element) {
                    indices.push(i);
                    myArray[i] = newValue;
                }
            }
            
            if (indices.length === 0) {
                showNotification(`Element "${element}" not found in the array`, 'danger');
                return;
            }
            
            renderArray();
            indices.forEach(index => highlightElement(index, 'update'));
            updateStats();
            updateElement.value = '';
            updateNewValue.value = '';
            logOperation(`Updated ${indices.length} occurrence(s) of "${element}" to "${newValue}"`, 'warning');
        }
        
        function handleDelete() {
            const index = parseInt(deleteIndex.value);
            if (isNaN(index) || index < 0 || index >= myArray.length) {
                showNotification('Please enter a valid index', 'danger');
                deleteIndex.focus();
                return;
            }
            
            const deletedValue = myArray[index];
            highlightElement(index, 'delete', () => {
                myArray.splice(index, 1);
                renderArray();
                updateStats();
                deleteIndex.value = '';
                logOperation(`Deleted value "${deletedValue}" at index ${index}`, 'danger');
            });
        }
        
        function handleDeleteByElement() {
            const element = deleteElement.value.trim();
            if (element === '') {
                showNotification('Please enter an element to delete', 'warning');
                deleteElement.focus();
                return;
            }
            
            const indices = [];
            for (let i = myArray.length - 1; i >= 0; i--) {
                if (myArray[i] === element) {
                    indices.push(i);
                }
            }
            
            if (indices.length === 0) {
                showNotification(`Element "${element}" not found in the array`, 'danger');
                return;
            }
            
            // Animate deletion of all matching elements
            let deletedCount = 0;
            indices.forEach((index, i) => {
                setTimeout(() => {
                    highlightElement(index, 'delete', () => {
                        myArray.splice(index, 1);
                        deletedCount++;
                        
                        if (deletedCount === indices.length) {
                            renderArray();
                            updateStats();
                            deleteElement.value = '';
                            logOperation(`Deleted ${indices.length} occurrence(s) of "${element}"`, 'danger');
                        }
                    });
                }, i * 300);
            });
        }
        
function handleClearArray() {
    if (myArray.length === 0) {
        showNotification('Array is already empty', 'info');
        return;
    }
    
    // Animate removal of all elements
    const elements = document.querySelectorAll('.array-element');
    elements.forEach((element, index) => {
        setTimeout(() => {
            element.classList.add('slide-out');
        }, index * 100);
    });
    
    setTimeout(() => {
        myArray = [];
        originalArray = []; // Reset original array
        originalArrayForShift = []; // Reset shift array
        isSubarray = false; // Reset subarray flag
        isShifted = false; // Reset shift flag
        renderArray();
        updateStats();
        logOperation('Cleared the entire array', 'danger');
    }, elements.length * 100 + 500);
}
        function handleSearch() {
            const element = searchElement.value.trim();
            if (element === '') {
                showNotification('Please enter an element to search', 'warning');
                searchElement.focus();
                return;
            }
            
            const indices = [];
            for (let i = 0; i < myArray.length; i++) {
                if (myArray[i] === element) {
                    indices.push(i);
                }
            }
            
            if (indices.length === 0) {
                searchResults.innerHTML = `<p class="text-center mb-0">Element "${element}" not found in the array</p>`;
                showNotification(`Element "${element}" not found`, 'info');
                return;
            }
            
            // Highlight found elements
            indices.forEach(index => highlightElement(index, 'search'));
            
            // Display results
            searchResults.innerHTML = `
                <p class="mb-2">Found "${element}" at ${indices.length} position(s):</p>
                <p class="mb-0">${indices.map(i => `[${i}]`).join(', ')}</p>
            `;
            
            searchElement.value = '';
            logOperation(`Searched for "${element}" - found at indices: ${indices.join(', ')}`, 'info');
        }
        
        function handleSearchByIndex() {
            const index = parseInt(searchIndex.value);
            if (isNaN(index) || index < 0 || index >= myArray.length) {
                showNotification('Please enter a valid index', 'danger');
                searchIndex.focus();
                return;
            }
            
            const value = myArray[index];
            highlightElement(index, 'search');
            
            // Display results
            searchResults.innerHTML = `
                <p class="mb-0">Value at index ${index} is: "${value}"</p>
            `;
            
            searchIndex.value = '';
            logOperation(`Searched index ${index} - found: "${value}"`, 'info');
        }
        
        // NEW: Linear Search Handler
        function handleLinearSearch() {
            if (isLinearSearchRunning) {
                showNotification('A linear search is already in progress', 'warning');
                return;
            }
            
            const element = linearSearchElement.value.trim();
            if (element === '') {
                showNotification('Please enter an element to search', 'warning');
                linearSearchElement.focus();
                return;
            }
            
            if (myArray.length === 0) {
                showNotification('Array is empty. Please add elements first.', 'warning');
                return;
            }
            
            isLinearSearchRunning = true;
            linearSearchBtn.disabled = true;
            
            // Reset algorithm steps highlighting
            const steps = algorithmSteps.querySelectorAll('.algorithm-step');
            steps.forEach(step => step.classList.remove('active'));
            
            // Reset all elements to normal state
            const elements = document.querySelectorAll('.array-element');
            elements.forEach(el => {
                const valueDiv = el.querySelector('.element-value');
                valueDiv.classList.remove('linear-search-current', 'linear-search-checked', 'linear-search-found');
            });
            
            searchResults.innerHTML = '<p class="text-center mb-0">Starting linear search...</p>';
            
            // Perform linear search with visualization
            performLinearSearch(element, 0);
        }
        
// NEW: Perform Linear Search with Step-by-Step Visualization
function performLinearSearch(target, currentIndex) {
    if (currentIndex >= myArray.length) {
        // Element not found
        searchResults.innerHTML = `<p class="text-center mb-0">Element "${target}" not found in the array</p>`;
        logOperation(`Linear search for "${target}" - not found`, 'info');
        
        // Reset all elements to normal state
        const elements = document.querySelectorAll('.array-element');
        elements.forEach(el => {
            const valueDiv = el.querySelector('.element-value');
            valueDiv.classList.remove('linear-search-current', 'linear-search-checked', 'linear-search-found');
        });
        
        isLinearSearchRunning = false;
        linearSearchBtn.disabled = false;
        return;
    }
    
    // Update algorithm steps
    const steps = algorithmSteps.querySelectorAll('.algorithm-step');
    steps.forEach(step => step.classList.remove('active'));
    
    if (currentIndex === 0) {
        steps[0].classList.add('active'); // Step 1: Start from first element
    } else {
        steps[3].classList.add('active'); // Step 4: Move to next element
    }
    
    // Highlight current element being checked
    const elements = document.querySelectorAll('.array-element');
    const currentElement = elements[currentIndex];
    const valueDiv = currentElement.querySelector('.element-value');
    
    // Mark previous elements as checked
    for (let i = 0; i < currentIndex; i++) {
        const prevElement = elements[i];
        const prevValueDiv = prevElement.querySelector('.element-value');
        prevValueDiv.classList.remove('linear-search-current');
        prevValueDiv.classList.add('linear-search-checked');
    }
    
    // Highlight current element
    valueDiv.classList.remove('linear-search-checked');
    valueDiv.classList.add('linear-search-current');
    
    // Update search results
    searchResults.innerHTML = `
        <p class="mb-1">Searching for "${target}"...</p>
        <p class="mb-1">Checking index ${currentIndex}: "${myArray[currentIndex]}"</p>
        <p class="mb-0">Comparisons made: ${currentIndex + 1}</p>
    `;
    
    steps[1].classList.add('active'); // Step 2: Compare current element with target
    
    // Check if current element matches target
    if (myArray[currentIndex] === target) {
        // Element found
        setTimeout(() => {
            valueDiv.classList.remove('linear-search-current');
            valueDiv.classList.add('linear-search-found');
            
            steps[2].classList.add('active'); // Step 3: Match found
            
            searchResults.innerHTML = `
                <p class="mb-1">Element "${target}" found at index ${currentIndex}!</p>
                <p class="mb-1">Total comparisons: ${currentIndex + 1}</p>
                <p class="mb-0">Time complexity: O(n) - linear time</p>
            `;
            
            logOperation(`Linear search found "${target}" at index ${currentIndex} after ${currentIndex + 1} comparisons`, 'success');
            
            // Remove the found highlight after 3 seconds
            setTimeout(() => {
                valueDiv.classList.remove('linear-search-found');
                isLinearSearchRunning = false;
                linearSearchBtn.disabled = false;
                linearSearchElement.value = '';
            }, 3000);
            
        }, 1000);
    } else {
        // Move to next element
        setTimeout(() => {
            performLinearSearch(target, currentIndex + 1);
        }, 1500);
    }
}
 // NEW: Binary Search Handler
// NEW: Binary Search Handler
function handleBinarySearch() {
    if (isBinarySearchRunning) {
        showNotification('A binary search is already in progress', 'warning');
        return;
    }
    
    const element = binarySearchElement.value.trim();
    if (element === '') {
        showNotification('Please enter an element to search', 'warning');
        binarySearchElement.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    isBinarySearchRunning = true;
    binarySearchBtn.disabled = true;
    
    // Reset algorithm steps highlighting
    const steps = binarySearchSteps.querySelectorAll('.algorithm-step');
    steps.forEach(step => step.classList.remove('active'));
    
    // Check if array needs sorting
    if (!isArraySorted(myArray)) {
        showNotification('Array is not sorted. Auto-sorting for binary search...', 'warning');
        
        // Backup original array
        sortedArrayBackup = [...myArray];
        
        // Sort the array (numerically if possible, otherwise lexicographically)
        myArray.sort((a, b) => {
            const numA = parseFloat(a);
            const numB = parseFloat(b);
            if (!isNaN(numA) && !isNaN(numB)) {
                return numA - numB;
            }
            return a.toString().localeCompare(b.toString());
        });
        
        isCurrentlySorted = true;
        renderArray();
        
        // Highlight that array was sorted
        setTimeout(() => {
            myArray.forEach((_, index) => {
                highlightElement(index, 'update');
            });
            
            // Start binary search after sorting animation
            setTimeout(() => {
                performBinarySearch(element, 0, myArray.length - 1);
            }, 1000);
        }, 500);
        
    } else {
        // Array is already sorted, proceed with binary search
        performBinarySearch(element, 0, myArray.length - 1);
    }
}        
// NEW: Check if array is sorted
function isArraySorted(arr) {
    for (let i = 1; i < arr.length; i++) {
        const current = parseFloat(arr[i]);
        const prev = parseFloat(arr[i-1]);
        
        if (!isNaN(current) && !isNaN(prev)) {
            // Numeric comparison
            if (current < prev) return false;
        } else {
            // String comparison
            if (arr[i] < arr[i-1]) return false;
        }
    }
    return true;
}
// NEW: Perform Binary Search with Visualization
function performBinarySearch(target, left, right) {
    if (left > right) {
        // Element not found
        searchResults.innerHTML = `<p class="text-center mb-0">Element "${target}" not found in the array</p>`;
        logOperation(`Binary search for "${target}" - not found`, 'info');
        
        // Reset search state
        resetBinarySearchState();
        return;
    }
    
    const mid = Math.floor((left + right) / 2);
    const steps = binarySearchSteps.querySelectorAll('.algorithm-step');
    
    // Reset all steps
    steps.forEach(step => step.classList.remove('active'));
    
    // Update current step
    if (left === 0 && right === myArray.length - 1) {
        steps[1].classList.add('active'); // Step 2: Set left and right bounds
    } else {
        steps[2].classList.add('active'); // Step 3: Calculate mid
    }
    
    // Highlight current search space
    highlightBinarySearchSpace(left, right, mid);
    
    // Update search results
    searchResults.innerHTML = `
        <p class="mb-1">Searching for "${target}"...</p>
        <p class="mb-1">Search space: indices ${left} to ${right}</p>
        <p class="mb-1">Checking mid index ${mid}: "${myArray[mid]}"</p>
        <p class="mb-0">Comparisons made: ${getBinarySearchComparisons(left, right)}</p>
    `;
    
    steps[3].classList.add('active'); // Step 4: Compare element at mid with target
    
    setTimeout(() => {
        if (myArray[mid] === target) {
            // Element found
            highlightBinarySearchFound(mid);
            
            steps[4].classList.add('active'); // Step 5: Match found
            
            searchResults.innerHTML = `
                <p class="mb-1">Element "${target}" found at index ${mid}!</p>
                <p class="mb-1">Total comparisons: ${getBinarySearchComparisons(left, right)}</p>
                <p class="mb-0">Time complexity: O(log n) - logarithmic time</p>
            `;
            
            logOperation(`Binary search found "${target}" at index ${mid}`, 'success');
            
            // Reset after delay
            setTimeout(() => {
                resetBinarySearchState();
            }, 3000);
            
        } else {
            // Continue search
            const currentValue = myArray[mid];
            const numTarget = parseFloat(target);
            const numCurrent = parseFloat(currentValue);
            
            let newLeft = left, newRight = right;
            
            if (!isNaN(numTarget) && !isNaN(numCurrent)) {
                // Numeric comparison
                if (numTarget > numCurrent) {
                    steps[5].classList.add('active'); // Step 6: Search right half
                    newLeft = mid + 1;
                } else {
                    steps[6].classList.add('active'); // Step 7: Search left half
                    newRight = mid - 1;
                }
            } else {
                // String comparison
                if (target > currentValue) {
                    steps[5].classList.add('active');
                    newLeft = mid + 1;
                } else {
                    steps[6].classList.add('active');
                    newRight = mid - 1;
                }
            }
            
            steps[7].classList.add('active'); // Step 8: Repeat
            
            // Continue search with new bounds
            setTimeout(() => {
                performBinarySearch(target, newLeft, newRight);
            }, 1500);
        }
    }, 1000);
}
// NEW: Helper function to highlight binary search space
function highlightBinarySearchSpace(left, right, mid) {
    const elements = document.querySelectorAll('.array-element');
    
    // Reset all elements
    elements.forEach((el, index) => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('binary-search-left', 'binary-search-right', 'binary-search-mid', 'binary-search-found');
        
        if (index >= left && index <= right) {
            // In current search space
            if (index === mid) {
                valueDiv.classList.add('binary-search-mid');
            } else if (index < mid) {
                valueDiv.classList.add('binary-search-left');
            } else {
                valueDiv.classList.add('binary-search-right');
            }
        }
    });
}

// NEW: Helper function to highlight found element
function highlightBinarySearchFound(index) {
    const elements = document.querySelectorAll('.array-element');
    const valueDiv = elements[index].querySelector('.element-value');
    valueDiv.classList.remove('binary-search-mid', 'binary-search-left', 'binary-search-right');
    valueDiv.classList.add('binary-search-found');
}

// NEW: Calculate binary search comparisons
function getBinarySearchComparisons(left, right) {
    // This is a simplified calculation for demonstration
    return Math.floor(Math.log2(right - left + 1)) + 1;
}

// NEW: Reset binary search state
function resetBinarySearchState() {
    isBinarySearchRunning = false;
    binarySearchBtn.disabled = false;
    binarySearchElement.value = '';
    
    // Reset all binary search highlights
    const elements = document.querySelectorAll('.array-element');
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('binary-search-left', 'binary-search-right', 'binary-search-mid', 'binary-search-found');
    });
}
// NEW: Check Element Existence Handler
function handleCheckElement() {
    const element = checkElement.value.trim();
    if (element === '') {
        showNotification('Please enter an element to check', 'warning');
        checkElement.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if element exists
    let exists = false;
    let foundIndex = -1;
    
    for (let i = 0; i < myArray.length; i++) {
        if (myArray[i] === element) {
            exists = true;
            foundIndex = i;
            break;
        }
    }
    
    if (exists) {
        // Element exists - highlight it
        highlightElementExistence(foundIndex, element, true);
    } else {
        // Element doesn't exist
        searchResults.innerHTML = `
            <p class="mb-1"><strong>Element Not Found</strong></p>
            <p class="mb-1">Element: "${element}"</p>
            <p class="mb-0 text-danger">"${element}" does not exist in the array</p>
        `;
        
        logOperation(`Checked existence of "${element}" - not found`, 'danger');
        showNotification(`"${element}" does not exist in the array`, 'danger');
    }
    
    checkElement.value = '';
}

// NEW: Find Minimum Element Handler
function handleFindMinElement() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Find minimum element
    let minIndex = 0;
    let minValue = myArray[0];
    
    // Try numeric comparison first, then fall back to string comparison
    let isNumeric = !isNaN(parseFloat(myArray[0]));
    
    for (let i = 1; i < myArray.length; i++) {
        const currentValue = myArray[i];
        
        if (isNumeric) {
            // Numeric comparison
            if (parseFloat(currentValue) < parseFloat(minValue)) {
                minValue = currentValue;
                minIndex = i;
            }
        } else {
            // String comparison
            if (currentValue < minValue) {
                minValue = currentValue;
                minIndex = i;
            }
        }
    }
    
    // Highlight the minimum element
    highlightMinMaxElement(minIndex, minValue, 'min');
}

// NEW: Find Maximum Element Handler
function handleFindMaxElement() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Find maximum element
    let maxIndex = 0;
    let maxValue = myArray[0];
    
    // Try numeric comparison first, then fall back to string comparison
    let isNumeric = !isNaN(parseFloat(myArray[0]));
    
    for (let i = 1; i < myArray.length; i++) {
        const currentValue = myArray[i];
        
        if (isNumeric) {
            // Numeric comparison
            if (parseFloat(currentValue) > parseFloat(maxValue)) {
                maxValue = currentValue;
                maxIndex = i;
            }
        } else {
            // String comparison
            if (currentValue > maxValue) {
                maxValue = currentValue;
                maxIndex = i;
            }
        }
    }
    
    // Highlight the maximum element
    highlightMinMaxElement(maxIndex, maxValue, 'max');
}

// NEW: Highlight Element Existence
function highlightElementExistence(index, element, exists) {
    const elements = document.querySelectorAll('.array-element');
    
    if (exists) {
        // Reset all elements first
        elements.forEach(el => {
            const valueDiv = el.querySelector('.element-value');
            valueDiv.classList.remove('element-exists', 'search-highlight');
        });
        
        // Highlight the found element
        const targetElement = elements[index];
        const valueDiv = targetElement.querySelector('.element-value');
        
        valueDiv.classList.add('element-exists', 'search-highlight');
        
        // Display results
        searchResults.innerHTML = `
            <p class="mb-1"><strong>Element Found!</strong></p>
            <p class="mb-1">Element: "${element}"</p>
            <p class="mb-1">Index: [${index}]</p>
            <p class="mb-0 text-success">"${element}" exists in the array</p>
        `;
        
        logOperation(`Checked existence of "${element}" - found at index ${index}`, 'success');
        
        // Auto-reset highlight after 3 seconds
        setTimeout(() => {
            valueDiv.classList.remove('element-exists', 'search-highlight');
        }, 3000);
    }
}

// NEW: Highlight Minimum/Maximum Element
function highlightMinMaxElement(index, value, type) {
    const elements = document.querySelectorAll('.array-element');
    
    // Reset all elements first
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('min-element', 'max-element', 'search-highlight');
    });
    
    // Highlight the min/max element
    const targetElement = elements[index];
    const valueDiv = targetElement.querySelector('.element-value');
    
    if (type === 'min') {
        valueDiv.classList.add('min-element', 'search-highlight');
        
        // Display results
        searchResults.innerHTML = `
            <p class="mb-1"><strong>Minimum Element Found!</strong></p>
            <p class="mb-1">Minimum Value: "${value}"</p>
            <p class="mb-1">Index: [${index}]</p>
            <p class="mb-0">Type: ${!isNaN(parseFloat(value)) ? 'Numeric' : 'String'} comparison</p>
        `;
        
        logOperation(`Found minimum element "${value}" at index ${index}`, 'info');
    } else {
        valueDiv.classList.add('max-element', 'search-highlight');
        
        // Display results
        searchResults.innerHTML = `
            <p class="mb-1"><strong>Maximum Element Found!</strong></p>
            <p class="mb-1">Maximum Value: "${value}"</p>
            <p class="mb-1">Index: [${index}]</p>
            <p class="mb-0">Type: ${!isNaN(parseFloat(value)) ? 'Numeric' : 'String'} comparison</p>
        `;
        
        logOperation(`Found maximum element "${value}" at index ${index}`, 'info');
    }
    
    // Auto-reset highlight after 4 seconds
    setTimeout(() => {
        valueDiv.classList.remove('min-element', 'max-element', 'search-highlight');
    }, 4000);
}

// Update the existing handleResetArray function
function handleResetArray() {
    if ((!isSubarray && !isCurrentlySorted) || (originalArray.length === 0 && sortedArrayBackup.length === 0)) {
        showNotification('No original array to reset to', 'info');
        return;
    }
    
    // Reset from subarray OR from sorted state (binary search)
    if (isSubarray && originalArray.length > 0) {
        myArray = [...originalArray];
        isSubarray = false;
        originalArray = [];
    } else if (isCurrentlySorted && sortedArrayBackup.length > 0) {
        myArray = [...sortedArrayBackup];
        isCurrentlySorted = false;
        sortedArrayBackup = [];
    }
    
    renderArray();
    updateStats();
    
    // Highlight all elements
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation('Reset to original array', 'info');
}  
// NEW: Shift Left Handler
function handleShiftLeft() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - cannot shift', 'info');
        return;
    }
    
    // Store original array if this is the first shift operation
    if (!isShifted) {
        originalArrayForShift = [...myArray];
    }
    
    // Perform left shift
    const firstElement = myArray.shift(); // Remove first element
    myArray.push(firstElement); // Add it to the end
    
    renderArray();
    updateStats();
    isShifted = true;
    
    // Animate the shift
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'update');
        });
    }, 100);
    
    logOperation(`Shifted array left. First element "${firstElement}" moved to end`, 'warning');
    showNotification('Array shifted left successfully', 'success');
}

// NEW: Shift Right Handler
function handleShiftRight() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - cannot shift', 'info');
        return;
    }
    
    // Store original array if this is the first shift operation
    if (!isShifted) {
        originalArrayForShift = [...myArray];
    }
    
    // Perform right shift
    const lastElement = myArray.pop(); // Remove last element
    myArray.unshift(lastElement); // Add it to the beginning
    
    renderArray();
    updateStats();
    isShifted = true;
    
    // Animate the shift
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'update');
        });
    }, 100);
    
    logOperation(`Shifted array right. Last element "${lastElement}" moved to beginning`, 'warning');
    showNotification('Array shifted right successfully', 'success');
}

// NEW: Reset Shift Handler
function handleResetShift() {
    if (!isShifted || originalArrayForShift.length === 0) {
        showNotification('No shift operation to reset', 'info');
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayForShift];
    originalArrayForShift = [];
    isShifted = false;
    
    renderArray();
    updateStats();
    
    // Highlight all elements
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation('Reset array to original state after shift operations', 'info');
    showNotification('Array reset to original state', 'success');
}

// NEW: Pop Last Element Handler
function handlePopLast() {
    if (myArray.length === 0) {
        // Show error message in red color
        searchResults.innerHTML = `
            <p class="mb-1 text-danger"><strong>Error: No elements in array</strong></p>
            <p class="mb-0 text-danger">Array is empty. Please add elements first.</p>
        `;
        showNotification('Array is empty. Cannot pop last element.', 'danger');
        logOperation('Attempted to pop from empty array - failed', 'danger');
        return;
    }
    
    const lastElement = myArray[myArray.length - 1];
    const lastIndex = myArray.length - 1;
    
    // Highlight the last element before popping
    highlightElement(lastIndex, 'delete', () => {
        myArray.pop(); // Remove last element
        renderArray();
        updateStats();
        
        // Show success message in green color
        searchResults.innerHTML = `
            <p class="mb-1 text-success"><strong>Success: Last Element Popped</strong></p>
            <p class="mb-1">Popped Element: "${lastElement}"</p>
            <p class="mb-0">New array length: ${myArray.length}</p>
        `;
        
        logOperation(`Popped last element: "${lastElement}"`, 'success');
        showNotification(`Last element "${lastElement}" popped successfully`, 'success');
    });
}    
// NEW: Traverse Forward Handler
function handleTraverseForward() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isTraversalRunning) {
        showNotification('A traversal operation is already in progress', 'warning');
        return;
    }
    
    isTraversalRunning = true;
    traversalDirection = 'forward';
    traverseForwardBtn.disabled = true;
    traverseBackwardBtn.disabled = true;
    
    // Reset all elements first
    const elements = document.querySelectorAll('.array-element');
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('traverse-current', 'traverse-completed');
    });
    
    // Start traversal from index 0
    performTraverseForward(0);
}

// NEW: Traverse Backward Handler
function handleTraverseBackward() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isTraversalRunning) {
        showNotification('A traversal operation is already in progress', 'warning');
        return;
    }
    
    isTraversalRunning = true;
    traversalDirection = 'backward';
    traverseForwardBtn.disabled = true;
    traverseBackwardBtn.disabled = true;
    
    // Reset all elements first
    const elements = document.querySelectorAll('.array-element');
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('traverse-current', 'traverse-completed');
    });
    
    // Start traversal from last index
    performTraverseBackward(myArray.length - 1);
}

// NEW: Perform Forward Traversal
function performTraverseForward(currentIndex) {
    if (currentIndex >= myArray.length || traversalDirection !== 'forward') {
        // Traversal completed
        resetTraversalState();
        logOperation('Forward traversal completed', 'success');
        showNotification('Forward traversal completed', 'success');
        return;
    }
    
    const elements = document.querySelectorAll('.array-element');
    
    // Mark previous elements as completed
    for (let i = 0; i < currentIndex; i++) {
        const prevElement = elements[i];
        const prevValueDiv = prevElement.querySelector('.element-value');
        prevValueDiv.classList.remove('traverse-current');
        prevValueDiv.classList.add('traverse-completed');
    }
    
    // Highlight current element
    const currentElement = elements[currentIndex];
    const valueDiv = currentElement.querySelector('.element-value');
    valueDiv.classList.remove('traverse-completed');
    valueDiv.classList.add('traverse-current');
    
    // Update search results to show current traversal status
    searchResults.innerHTML = `
        <p class="mb-1"><strong>Forward Traversal in Progress</strong></p>
        <p class="mb-1">Current Index: [${currentIndex}]</p>
        <p class="mb-1">Current Value: "${myArray[currentIndex]}"</p>
        <p class="mb-0">Progress: ${currentIndex + 1}/${myArray.length}</p>
    `;
    
    // Move to next element after delay
    setTimeout(() => {
        performTraverseForward(currentIndex + 1);
    }, 800);
}

// NEW: Perform Backward Traversal
function performTraverseBackward(currentIndex) {
    if (currentIndex < 0 || traversalDirection !== 'backward') {
        // Traversal completed
        resetTraversalState();
        logOperation('Backward traversal completed', 'success');
        showNotification('Backward traversal completed', 'success');
        return;
    }
    
    const elements = document.querySelectorAll('.array-element');
    
    // Mark elements after current as completed
    for (let i = myArray.length - 1; i > currentIndex; i--) {
        const nextElement = elements[i];
        const nextValueDiv = nextElement.querySelector('.element-value');
        nextValueDiv.classList.remove('traverse-current');
        nextValueDiv.classList.add('traverse-completed');
    }
    
    // Highlight current element
    const currentElement = elements[currentIndex];
    const valueDiv = currentElement.querySelector('.element-value');
    valueDiv.classList.remove('traverse-completed');
    valueDiv.classList.add('traverse-current');
    
    // Update search results to show current traversal status
    searchResults.innerHTML = `
        <p class="mb-1"><strong>Backward Traversal in Progress</strong></p>
        <p class="mb-1">Current Index: [${currentIndex}]</p>
        <p class="mb-1">Current Value: "${myArray[currentIndex]}"</p>
        <p class="mb-0">Progress: ${myArray.length - currentIndex}/${myArray.length}</p>
    `;
    
    // Move to previous element after delay
    setTimeout(() => {
        performTraverseBackward(currentIndex - 1);
    }, 800);
}

// NEW: Reset Traversal State
function resetTraversalState() {
    isTraversalRunning = false;
    traversalDirection = null;
    traverseForwardBtn.disabled = false;
    traverseBackwardBtn.disabled = false;
    
    // Reset all traversal highlights
    const elements = document.querySelectorAll('.array-element');
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('traverse-current', 'traverse-completed');
    });
    
    // Clear search results after a short delay
    setTimeout(() => {
        searchResults.innerHTML = '<p class="text-center mb-0">Traversal operation completed</p>';
    }, 2000);
}
// Calculate sum of all elements
function calculateSum() {
    if (myArray.length === 0) return 0;
    
    let sum = 0;
    for (let i = 0; i < myArray.length; i++) {
        const num = parseFloat(myArray[i]);
        if (!isNaN(num)) {
            sum += num;
        }
    }
    return sum;
}

// Calculate product of all elements
function calculateProduct() {
    if (myArray.length === 0) return 1;
    
    let product = 1;
    let hasValidNumbers = false;
    
    for (let i = 0; i < myArray.length; i++) {
        const num = parseFloat(myArray[i]);
        if (!isNaN(num)) {
            product *= num;
            hasValidNumbers = true;
        }
    }
    
    return hasValidNumbers ? product : 0;
}
// NEW: Cumulative Sum Array Handler (Updated)
// UPDATED: Cumulative Sum Array Handler with Dual Display
function handleCumulativeSum() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if all elements are numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Cumulative sum requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array BEFORE transformation
    if (!isSubarray) {
        originalArray = [...myArray];
    }
    
    // Create cumulative sum array
    const cumulativeArray = [];
    let runningSum = 0;
    
    for (let i = 0; i < myArray.length; i++) {
        runningSum += parseFloat(myArray[i]);
        cumulativeArray.push(runningSum.toString());
    }
    
    // Show dual array visualization with step-by-step calculation
    showDualArrayVisualizationWithCalculation(
        originalArray, 
        cumulativeArray, 
        'Cumulative Sum Transformation',
        'Each element contains the sum of all previous elements including current',
        'cumulative'
    );
}

// UPDATED: Prefix Sum Array Handler with Step-by-Step Calculation Animation
function handlePrefixSum() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if all elements are numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Prefix sum requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array BEFORE transformation
    if (!isSubarray) {
        originalArray = [...myArray];
    }
    
    // Create prefix sum array
    const prefixArray = [];
    let runningSum = 0;
    
    for (let i = 0; i < myArray.length; i++) {
        runningSum += parseFloat(myArray[i]);
        prefixArray.push(runningSum.toString());
    }
    
    // Show dual array visualization with step-by-step calculation
    showDualArrayVisualizationWithCalculation(
        originalArray, 
        prefixArray, 
        'Prefix Sum Transformation',
        'Each element contains the sum of all elements from index 0 to current index',
        'prefix'
    );
}

// NEW: Show Dual Array Visualization with Step-by-Step Calculation
function showDualArrayVisualizationWithCalculation(originalArray, transformedArray, title, explanation, type) {
    // Create dual array container
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-array-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">${title}</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalArrayVis"></div>
        </div>
        
        <div class="transformation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">${type === 'cumulative' ? 'Cumulative Sum Array' : 'Prefix Sum Array'}</div>
            <div class="transformed-array-container" id="transformedArrayVis"></div>
        </div>
        
        <div class="transformation-explanation">
            <p class="mb-0">${explanation}</p>
        </div>
        
        <div class="calculation-steps mt-3" id="calculationSteps">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="stepsContainer"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterVisualization" style="display: none;">
            <i class="fas fa-play me-1"></i>Continue with Transformed Array
        </button>
    `;
    
    // Replace the main array container with dual visualization
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Render original array
    renderArrayInContainer(originalArray, 'originalArrayVis');
    
    // Render empty transformed array
    renderArrayInContainer(new Array(originalArray.length).fill('?'), 'transformedArrayVis');
    
    // Start step-by-step calculation animation
    performStepByStepCalculation(originalArray, transformedArray, type);
}

// NEW: Perform Step-by-Step Calculation Animation
// NEW: Modified function to automatically handle transformation
function performStepByStepCalculation(originalArray, transformedArray, type) {
    const stepsContainer = document.getElementById('stepsContainer');
    const transformedContainer = document.getElementById('transformedArrayVis');
    const originalContainer = document.getElementById('originalArrayVis');
    const continueButton = document.getElementById('continueAfterVisualization');
    
    let runningSum = 0;
    let currentStep = 0;
    
    // Function to perform one calculation step
    function performStep(index) {
        if (index >= originalArray.length) {
            // All steps completed
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${currentStep}:</strong> Calculation Complete!
                </div>
            `;
            
            // Show continue button
            continueButton.style.display = 'block';
            
            // Auto-proceed after 3 seconds if user doesn't click the button
            const autoProceedTimer = setTimeout(() => {
                proceedWithTransformation();
            }, 3000);
            
            // Manual click handler
            continueButton.addEventListener('click', () => {
                clearTimeout(autoProceedTimer);
                proceedWithTransformation();
            });
            
            return;
        }
        
        // Highlight current original element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const originalValueDiv = originalElements[index].querySelector('.element-value');
        originalValueDiv.classList.add('traverse-current');
        
        // Calculate new value
        const currentValue = parseFloat(originalArray[index]);
        runningSum += currentValue;
        
        // Update step explanation
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentStep}:</strong> 
                ${type === 'cumulative' ? 'Cumulative' : 'Prefix'} Sum [${index}] = 
                ${index > 0 ? `${runningSum - currentValue} + ${currentValue}` : currentValue} 
                = ${runningSum}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // After a delay, update the transformed array
        setTimeout(() => {
            // Update transformed array element
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const transformedValueDiv = transformedElements[index].querySelector('.element-value');
            transformedValueDiv.textContent = runningSum;
            transformedValueDiv.classList.add('cumulative-highlight', 'transform-animation');
            
            // Remove highlight from original element
            originalValueDiv.classList.remove('traverse-current');
            
            // Move to next step
            currentStep++;
            performStep(index + 1);
        }, 1500);
    }
    
    // Function to proceed with transformation
    function proceedWithTransformation() {
        // Update the actual array
        myArray = [...transformedArray];
        isSubarray = true;
        
        // Remove dual visualization and return to normal view
        const mainContainer = document.getElementById('arrayContainer');
        mainContainer.innerHTML = '';
        renderArray();
        updateStats();
        
        logOperation(`Transformed array to ${type === 'cumulative' ? 'cumulative sum' : 'prefix sum'}`, 'success');
        showNotification(`Array transformed to ${type === 'cumulative' ? 'cumulative sum' : 'prefix sum'} successfully`, 'success');
        
        // Auto-reset after 10 seconds
        setTimeout(() => {
            if (isSubarray && originalArray.length > 0) {
                resetAfterTransformation();
                showNotification(`Automatically reset to original array after ${type === 'cumulative' ? 'cumulative sum' : 'prefix sum'}`, 'info');
            }
        }, 10000);
    }
    
    // Start the step-by-step calculation
    performStep(0);
}

// NEW: Reset after transformation
function resetAfterTransformation() {
    if (!isSubarray || originalArray.length === 0) {
        showNotification('No transformation to reset', 'info');
        return;
    }
    
    // Reset to original array
    myArray = [...originalArray];
    originalArray = [];
    isSubarray = false;
    
    renderArray();
    updateStats();
    
    // Clear search results
    searchResults.innerHTML = '<p class="text-center mb-0">Reset to original array</p>';
    
    // Highlight all elements
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation('Reset to original array after transformation', 'info');
    showNotification('Reset to original array successfully', 'success');
}
// NEW: Find Subarray with Given Sum Handler
function handleFindSubarraySum() {
    const targetSum = parseFloat(subarraySumInput.value);
    
    if (isNaN(targetSum)) {
        showNotification('Please enter a valid target sum', 'warning');
        subarraySumInput.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Subarray sum calculation requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Find subarrays with given sum
    subarraySumResults = findSubarraysWithSum(targetSum);
    
    if (subarraySumResults.length === 0) {
        searchResults.innerHTML = `
            <div class="subarray-sum-results">
                <p class="mb-1"><strong>No Subarrays Found</strong></p>
                <p class="mb-1">Target Sum: ${targetSum}</p>
                <p class="mb-0 text-danger">No subarrays found with the given sum</p>
            </div>
        `;
        logOperation(`No subarrays found with sum ${targetSum}`, 'warning');
        return;
    }
    
    // Display results
    displaySubarraySumResults(targetSum);
    
    // Animate the found subarrays
    animateSubarraySumResults();
}

// NEW: Generate All Subarrays with Sum Handler
function handleGenerateAllSubarraysWithSum() {
    const targetSum = parseFloat(subarraySumInput.value);
    
    if (isNaN(targetSum)) {
        showNotification('Please enter a valid target sum', 'warning');
        subarraySumInput.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Subarray sum calculation requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Find all subarrays with given sum
    subarraySumResults = findSubarraysWithSum(targetSum);
    
    if (subarraySumResults.length === 0) {
        searchResults.innerHTML = `
            <div class="subarray-sum-results">
                <p class="mb-1"><strong>No Subarrays Found</strong></p>
                <p class="mb-1">Target Sum: ${targetSum}</p>
                <p class="mb-0 text-danger">No subarrays found with the given sum</p>
            </div>
        `;
        logOperation(`No subarrays found with sum ${targetSum}`, 'warning');
        return;
    }
    
    // Generate and display all subarrays with the sum
    generateAllSubarraysWithSum(targetSum);
}

// NEW: Find Subarrays with Given Sum Algorithm
function findSubarraysWithSum(targetSum) {
    const results = [];
    const n = myArray.length;
    
    // Convert array to numbers
    const numArray = myArray.map(val => parseFloat(val));
    
    // Find all subarrays with sum equal to target
    for (let start = 0; start < n; start++) {
        let currentSum = 0;
        for (let end = start; end < n; end++) {
            currentSum += numArray[end];
            
            if (currentSum === targetSum) {
                results.push({
                    start: start,
                    end: end,
                    sum: currentSum,
                    elements: myArray.slice(start, end + 1)
                });
            }
            
            // If we exceed the target sum, break inner loop (for positive numbers)
            // if (currentSum > targetSum && numArray[start] > 0) {
            //     break;
            // }
        }
    }
    
    return results;
}

// NEW: Display Subarray Sum Results
function displaySubarraySumResults(targetSum) {
    const totalSubarrays = subarraySumResults.length;
    
    searchResults.innerHTML = `
        <div class="subarray-sum-results">
            <p class="mb-1"><strong>Subarrays with Sum ${targetSum}</strong></p>
            <p class="mb-1">Total Subarrays Found: ${totalSubarrays}</p>
            <p class="mb-1">Array: [${myArray.join(', ')}]</p>
            <div class="mt-3">
                <h6>Found Subarrays:</h6>
                <div class="d-flex flex-wrap gap-2" id="subarraySumList"></div>
            </div>
        </div>
    `;
    
    const subarraySumList = document.getElementById('subarraySumList');
    
    // Display first few subarrays (limit to 10 for performance)
    const displayLimit = Math.min(totalSubarrays, 10);
    for (let i = 0; i < displayLimit; i++) {
        const subarray = subarraySumResults[i];
        const subarrayElement = document.createElement('div');
        subarrayElement.className = 'subarray-sum-item';
        subarrayElement.innerHTML = `
            [${subarray.elements.join(', ')}]<br>
            <small>Indices: ${subarray.start} to ${subarray.end}</small>
        `;
        subarraySumList.appendChild(subarrayElement);
    }
    
    if (totalSubarrays > displayLimit) {
        const moreElement = document.createElement('div');
        moreElement.className = 'text-info mt-2';
        moreElement.textContent = `... and ${totalSubarrays - displayLimit} more subarrays`;
        subarraySumList.appendChild(moreElement);
    }
    
    logOperation(`Found ${totalSubarrays} subarray(s) with sum ${targetSum}`, 'success');
    showNotification(`Found ${totalSubarrays} subarray(s) with sum ${targetSum}`, 'success');
}

// NEW: Animate Subarray Sum Results
function animateSubarraySumResults() {
    let currentSubarrayIndex = 0;
    
    function animateNextSubarray() {
        if (currentSubarrayIndex >= subarraySumResults.length) {
            // All subarrays animated
            setTimeout(() => {
                // Reset all highlights
                const elements = document.querySelectorAll('.array-element');
                elements.forEach(el => {
                    const valueDiv = el.querySelector('.element-value');
                    valueDiv.classList.remove('subarray-sum-match');
                });
            }, 2000);
            return;
        }
        
        const subarray = subarraySumResults[currentSubarrayIndex];
        
        // Highlight elements in current subarray
        for (let i = subarray.start; i <= subarray.end; i++) {
            setTimeout(() => {
                const elements = document.querySelectorAll('.array-element');
                const valueDiv = elements[i].querySelector('.element-value');
                valueDiv.classList.add('subarray-sum-match');
                
                // Remove highlight after animation
                setTimeout(() => {
                    valueDiv.classList.remove('subarray-sum-match');
                }, 1500);
            }, (i - subarray.start) * 200);
        }
        
        // Move to next subarray after delay
        setTimeout(() => {
            currentSubarrayIndex++;
            animateNextSubarray();
        }, (subarray.end - subarray.start + 2) * 200);
    }
    
    // Start animation
    animateNextSubarray();
}

// NEW: Generate All Subarrays with Sum
function generateAllSubarraysWithSum(targetSum) {
    const totalSubarrays = subarraySumResults.length;
    
    searchResults.innerHTML = `
        <div class="subarray-sum-results">
            <p class="mb-1"><strong>All Subarrays with Sum ${targetSum}</strong></p>
            <p class="mb-1">Total Subarrays Found: ${totalSubarrays}</p>
            <p class="mb-1">Array: [${myArray.join(', ')}]</p>
            <div class="mt-3">
                <h6>All Subarrays with Sum ${targetSum}:</h6>
                <div class="subarrays-container" style="max-height: 400px; overflow-y: auto;">
                    <div class="d-flex flex-wrap gap-2" id="allSubarraysSumList"></div>
                </div>
            </div>
        </div>
    `;
    
    const allSubarraysSumList = document.getElementById('allSubarraysSumList');
    
    // Display all subarrays
    subarraySumResults.forEach((subarray, index) => {
        const subarrayElement = document.createElement('div');
        subarrayElement.className = 'subarray-sum-item';
        subarrayElement.innerHTML = `
            <strong>Subarray ${index + 1}:</strong> [${subarray.elements.join(', ')}]<br>
            <small>Indices: ${subarray.start} to ${subarray.end} | Sum: ${subarray.sum}</small>
        `;
        allSubarraysSumList.appendChild(subarrayElement);
    });
    
    logOperation(`Generated all ${totalSubarrays} subarrays with sum ${targetSum}`, 'success');
    showNotification(`Generated all ${totalSubarrays} subarrays with sum ${targetSum}`, 'success');
    
    // Auto-animate after displaying all
    setTimeout(() => {
        animateSubarraySumResults();
    }, 1000);
}

// NEW: Helper function to render array in specific container
function renderArrayInContainer(array, containerId, animate = false, type = '') {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    array.forEach((value, index) => {
        const element = document.createElement('div');
        element.className = 'array-element';
        
        const valueDiv = document.createElement('div');
        valueDiv.className = 'element-value';
        valueDiv.textContent = value;
        
        const indexDiv = document.createElement('div');
        indexDiv.className = 'element-index';
        indexDiv.textContent = `[${index}]`;
        
        element.appendChild(valueDiv);
        element.appendChild(indexDiv);
        container.appendChild(element);
          if (animate) {
            setTimeout(() => {
                valueDiv.classList.add('slide-in');
                setTimeout(() => {
                    valueDiv.classList.remove('slide-in');
                }, 1000);
            }, index * 100);
        }
        // Add animation if requested
        if (animate) {
            setTimeout(() => {
                valueDiv.classList.add('slide-in');
                if (type === 'cumulative') {
                    valueDiv.classList.add('cumulative-highlight');
                } else if (type === 'prefix') {
                    valueDiv.classList.add('prefix-highlight');
                }
                if (type === 'ap') {
    valueDiv.classList.add('ap-term');
} else if (type === 'gp') {
    valueDiv.classList.add('gp-term');
}

                // Remove highlight after animation
                setTimeout(() => {
                    valueDiv.classList.remove('cumulative-highlight', 'prefix-highlight');
                }, 2000);
            }, index * 200);
        }
    });
}
// NEW: Stable Sort Handler
function handleStableSort() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - already sorted', 'info');
        return;
    }
    
    if (isStableSortRunning) {
        showNotification('A stable sort operation is already in progress', 'warning');
        return;
    }
    
    isStableSortRunning = true;
    stableSortBtn.disabled = true;
    
    // Store original array
    originalArrayForStableSort = [...myArray];
    
    // Show stable sort visualization
    showStableSortVisualization();
}
// NEW: Show Stable Sort Visualization
function showStableSortVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Stable Sort - Bubble Sort Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalStableArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Stable Sorted Array</div>
            <div class="transformed-array-container" id="transformedStableArray"></div>
        </div>
        
        <div class="stable-sort-explanation">
            <p class="mb-2"><strong>Stable Sort Property:</strong> Equal elements maintain their original relative order</p>
            <p class="mb-0" id="stableSortExplanation">Starting stable bubble sort...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="stableSortStepsContainer">
            <h6 class="text-center">Stable Sort Steps</h6>
            <div class="steps-container" id="stableSortSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterStableSort" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForStableSort, 'originalStableArray');
    renderArrayInContainer([...originalArrayForStableSort], 'transformedStableArray');
    
    performStableSortAnimation();
}
// NEW: Perform Stable Sort Animation
function performStableSortAnimation() {
    const originalContainer = document.getElementById('originalStableArray');
    const transformedContainer = document.getElementById('transformedStableArray');
    const explanation = document.getElementById('stableSortExplanation');
    const stepsContainer = document.getElementById('stableSortSteps');
    const continueButton = document.getElementById('continueAfterStableSort');
    
    const array = [...originalArrayForStableSort];
    const n = array.length;
    let sortedArray = [...array];
    let currentPass = 1;
    let currentComparison = 0;
    let totalSwaps = 0;
    
    // Create array with original indices to track stability
    const elementsWithIndices = array.map((value, index) => ({
        value: value,
        originalIndex: index,
        displayValue: `${value}(${index})` // Show original index for demonstration
    }));
    
    let sortedElements = [...elementsWithIndices];
    
    function performStableSortStep() {
        if (currentPass > n - 1) {
            // Sorting completed
            explanation.innerHTML = `<strong>Stable Sort Completed!</strong> Array sorted with stability maintained. Total passes: ${n-1}, Total swaps: ${totalSwaps}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Stable sort completed! Equal elements maintained their original order.
                </div>
            `;
            
            // Highlight all elements as stable sorted
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                const valueDiv = el.querySelector('.element-value');
                setTimeout(() => {
                    valueDiv.classList.add('stable-sort-stable');
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return to original after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterStableSort();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterStableSort);
            
            return;
        }
        
        if (currentComparison >= n - currentPass) {
            // Pass completed
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Pass ${currentPass} Complete:</strong> Largest element bubbled to position ${n - currentPass}
                </div>
            `;
            
            // Highlight the last sorted element
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const sortedElement = transformedElements[n - currentPass].querySelector('.element-value');
            sortedElement.classList.add('stable-sort-stable');
            
            currentPass++;
            currentComparison = 0;
            performStableSortStep();
            return;
        }
        
        const i = currentComparison;
        const j = i + 1;
        
        // Update explanation with stability information
        explanation.innerHTML = `Pass ${currentPass}: Comparing elements at indices ${i} and ${j}. Checking stability...`;
        
        // Highlight elements being compared
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const elementI = originalElements[i].querySelector('.element-value');
        const elementJ = originalElements[j].querySelector('.element-value');
        
        elementI.classList.add('stable-sort-current');
        elementJ.classList.add('stable-sort-compared');
        
        // Compare values
        const valI = parseFloat(sortedElements[i].value);
        const valJ = parseFloat(sortedElements[j].value);
        
        let shouldSwap = false;
        let stabilityNote = '';
        
        if (!isNaN(valI) && !isNaN(valJ)) {
            shouldSwap = valI > valJ;
            if (valI === valJ) {
                stabilityNote = ' - Equal values, maintaining original order (STABILITY)';
            }
        } else {
            shouldSwap = sortedElements[i].value > sortedElements[j].value;
            if (sortedElements[i].value === sortedElements[j].value) {
                stabilityNote = ' - Equal values, maintaining original order (STABILITY)';
            }
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${shouldSwap ? 'active' : ''}">
                <strong>Step:</strong> Compare [${i}]="${sortedElements[i].displayValue}" and [${j}]="${sortedElements[j].displayValue}" - 
                ${shouldSwap ? 'SWAP needed' : 'No swap needed'}${stabilityNote}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            if (shouldSwap) {
                // Perform swap
                explanation.innerHTML = `Pass ${currentPass}: Swapping elements at indices ${i} and ${j} - Maintaining stability`;
                
                elementI.classList.remove('stable-sort-current');
                elementJ.classList.remove('stable-sort-compared');
                elementI.classList.add('stable-sort-swapped');
                elementJ.classList.add('stable-sort-swapped');
                
                // Calculate swap distance for animation
                const rectI = originalElements[i].getBoundingClientRect();
                const rectJ = originalElements[j].getBoundingClientRect();
                const swapDistance = rectJ.left - rectI.left;
                
                elementI.style.setProperty('--swap-distance', `${swapDistance}px`);
                elementJ.style.setProperty('--swap-distance', `-${swapDistance}px`);
                
                setTimeout(() => {
                    elementI.classList.add('swap-animation');
                    elementJ.classList.add('swap-animation');
                    
                    setTimeout(() => {
                        // Swap the elements
                        [sortedElements[i], sortedElements[j]] = [sortedElements[j], sortedElements[i]];
                        totalSwaps++;
                        
                        // Update transformed array display with original indices
                        const displayArray = sortedElements.map(item => item.displayValue);
                        renderArrayInContainer(displayArray, 'transformedStableArray');
                        
                        // Remove highlights
                        elementI.classList.remove('stable-sort-swapped', 'swap-animation');
                        elementJ.classList.remove('stable-sort-swapped', 'swap-animation');
                        
                        currentComparison++;
                        performStableSortStep();
                    }, 1000);
                }, 500);
            } else {
                // No swap needed - emphasize stability
                if (stabilityNote) {
                    explanation.innerHTML = `Pass ${currentPass}: Equal values detected - Maintaining original order (STABILITY PRESERVED)`;
                    
                    // Highlight both elements to show they're equal
                    elementI.classList.add('stable-sort-stable');
                    elementJ.classList.add('stable-sort-stable');
                    
                    setTimeout(() => {
                        elementI.classList.remove('stable-sort-stable');
                        elementJ.classList.remove('stable-sort-stable');
                    }, 1000);
                }
                
                elementI.classList.remove('stable-sort-current');
                elementJ.classList.remove('stable-sort-compared');
                
                currentComparison++;
                performStableSortStep();
            }
        }, 2000);
    }
    
    // Start stable sort process
    performStableSortStep();
}
// NEW: Return to Original after Stable Sort
function returnToOriginalAfterStableSort() {
    // Reset to original array
    myArray = [...originalArrayForStableSort];
    originalArrayForStableSort = [];
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isStableSortRunning = false;
    stableSortBtn.disabled = false;
    
    // Show original positions with animation
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'stable-sort-original-position');
        });
    }, 100);
    
    logOperation('Stable sort demonstration completed - returned to original array', 'info');
    showNotification('Returned to original array after stable sort demonstration', 'success');
}
// UPDATED: Reset after transformation
function resetAfterTransformation() {
    if (!isSubarray || originalArray.length === 0) {
        showNotification('No transformation to reset', 'info');
        return;
    }
    
    // Reset to original array
    myArray = [...originalArray];
    originalArray = [];
    isSubarray = false;
    
    renderArray();
    updateStats();
    
    // Clear search results
    searchResults.innerHTML = '<p class="text-center mb-0">Reset to original array</p>';
    
    // Highlight all elements
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation('Reset to original array after transformation', 'info');
    showNotification('Reset to original array successfully', 'success');
}
// NEW: Reset transformation
function resetTransformation() {
    if (originalArrayForTransformation.length === 0) {
        showNotification('No transformation to reset', 'info');
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayForTransformation];
    originalArrayForTransformation = [];
    currentTransformationType = null;
    
    renderArray();
    updateStats();
    
    // Hide the reset button
    document.getElementById('resetTransformationBtn').style.display = 'none';
    
    // Clear search results
    document.getElementById('searchResults').innerHTML = '<p class="text-center mb-0">Reset to original array</p>';
    
    // Highlight all elements to show reset
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation('Reset to original array after transformation', 'info');
    showNotification('Reset to original array successfully', 'success');
}
// NEW: Sort Subarray Handler
function handleSortSubarray() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isSubarraySortRunning) {
        showNotification('A subarray sort operation is already in progress', 'warning');
        return;
    }
    
    const start = parseInt(sortSubarrayStart.value);
    const end = parseInt(sortSubarrayEnd.value);
    
    // Validation
    if (isNaN(start) || start < 0 || start >= myArray.length) {
        showNotification('Please enter a valid start index', 'danger');
        sortSubarrayStart.focus();
        return;
    }
    
    if (isNaN(end) || end < 0 || end >= myArray.length) {
        showNotification('Please enter a valid end index', 'danger');
        sortSubarrayEnd.focus();
        return;
    }
    
    if (start === end) {
        showNotification('Start and end indices cannot be the same', 'danger');
        return;
    }
    
    if (start > end) {
        showNotification('Start index cannot be greater than end index', 'danger');
        return;
    }
    
    if (end - start < 1) {
        showNotification('Subarray must have at least 2 elements to sort', 'warning');
        return;
    }
    
    isSubarraySortRunning = true;
    subarraySortStart = start;
    subarraySortEnd = end;
    
    // Store original array
    originalArrayForSubarraySort = [...myArray];
    
    // Perform subarray sort visualization
    performSubarraySort(start, end);
}
// NEW: Perform Subarray Sort with Visualization
function performSubarraySort(start, end) {
    const subarrayLength = end - start + 1;
    
    // Create dual container for subarray sort
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Sort Subarray (Indices ${start} to ${end})</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalSubarraySort"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After Subarray Sort</div>
            <div class="transformed-array-container" id="transformedSubarraySort"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Subarray Sort:</strong> Sorting elements from index ${start} to ${end} only</p>
            <p class="mb-0" id="subarraySortExplanation">Starting subarray sort animation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="subarraySortStepsContainer">
            <h6 class="text-center">Sorting Steps (Bubble Sort on Subarray)</h6>
            <div class="steps-container" id="subarraySortSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSubarraySort" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSubarraySort, 'originalSubarraySort');
    renderArrayInContainer([...originalArrayForSubarraySort], 'transformedSubarraySort');
    
    performSubarraySortAnimation(start, end);
}
// NEW: Perform Subarray Sort Animation
function performSubarraySortAnimation(start, end) {
    const originalContainer = document.getElementById('originalSubarraySort');
    const transformedContainer = document.getElementById('transformedSubarraySort');
    const explanation = document.getElementById('subarraySortExplanation');
    const stepsContainer = document.getElementById('subarraySortSteps');
    const continueButton = document.getElementById('continueAfterSubarraySort');
    
    const array = [...originalArrayForSubarraySort];
    const subarrayLength = end - start + 1;
    let sortedArray = [...array];
    let currentPass = 1;
    let currentComparison = 0;
    let totalSwaps = 0;
    
    // Convert subarray to numbers for comparison if possible
    const isNumeric = !array.slice(start, end + 1).some(item => isNaN(parseFloat(item)));
    
    function performSubarraySortStep() {
        if (currentPass > subarrayLength - 1) {
            // Sorting completed
            explanation.innerHTML = `<strong>Subarray Sort Completed!</strong> Sorted indices ${start} to ${end}. Total passes: ${subarrayLength-1}, Total swaps: ${totalSwaps}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Subarray sort completed! Only the specified range was sorted.
                </div>
            `;
            
            // Highlight the sorted subarray
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            for (let i = start; i <= end; i++) {
                const valueDiv = transformedElements[i].querySelector('.element-value');
                setTimeout(() => {
                    valueDiv.classList.add('sorting-sorted');
                }, (i - start) * 100);
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return to original after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterSubarraySort();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSubarraySort);
            
            return;
        }
        
        if (currentComparison >= subarrayLength - currentPass) {
            // Pass completed
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Pass ${currentPass} Complete:</strong> Element bubbled to position ${end - currentPass + 1}
                </div>
            `;
            
            // Highlight the last sorted element in subarray
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const sortedElement = transformedElements[end - currentPass + 1].querySelector('.element-value');
            sortedElement.classList.add('sorting-sorted');
            
            currentPass++;
            currentComparison = 0;
            performSubarraySortStep();
            return;
        }
        
        const i = start + currentComparison;
        const j = i + 1;
        
        // Update explanation
        explanation.innerHTML = `Pass ${currentPass}: Comparing subarray elements at indices ${i} and ${j}`;
        
        // Highlight elements being compared
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const elementI = originalElements[i].querySelector('.element-value');
        const elementJ = originalElements[j].querySelector('.element-value');
        
        elementI.classList.add('sorting-current');
        elementJ.classList.add('sorting-compared');
        
        // Compare values
        let shouldSwap = false;
        if (isNumeric) {
            const valI = parseFloat(sortedArray[i]);
            const valJ = parseFloat(sortedArray[j]);
            shouldSwap = valI > valJ;
        } else {
            shouldSwap = sortedArray[i] > sortedArray[j];
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${shouldSwap ? 'active' : ''}">
                <strong>Step:</strong> Compare [${i}]="${sortedArray[i]}" and [${j}]="${sortedArray[j]}" - 
                ${shouldSwap ? 'SWAP needed' : 'No swap needed'}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            if (shouldSwap) {
                // Perform swap
                explanation.innerHTML = `Pass ${currentPass}: Swapping elements at indices ${i} and ${j}`;
                
                elementI.classList.remove('sorting-current');
                elementJ.classList.remove('sorting-compared');
                elementI.classList.add('sorting-swap');
                elementJ.classList.add('sorting-swap');
                
                // Calculate swap distance for animation
                const rectI = originalElements[i].getBoundingClientRect();
                const rectJ = originalElements[j].getBoundingClientRect();
                const swapDistance = rectJ.left - rectI.left;
                
                elementI.style.setProperty('--swap-distance', `${swapDistance}px`);
                elementJ.style.setProperty('--swap-distance', `-${swapDistance}px`);
                
                setTimeout(() => {
                    elementI.classList.add('swap-animation');
                    elementJ.classList.add('swap-animation');
                    
                    setTimeout(() => {
                        // Swap the elements
                        [sortedArray[i], sortedArray[j]] = [sortedArray[j], sortedArray[i]];
                        totalSwaps++;
                        
                        // Update transformed array display
                        renderArrayInContainer(sortedArray, 'transformedSubarraySort');
                        
                        // Remove highlights
                        elementI.classList.remove('sorting-swap', 'swap-animation');
                        elementJ.classList.remove('sorting-swap', 'swap-animation');
                        
                        currentComparison++;
                        performSubarraySortStep();
                    }, 1000);
                }, 500);
            } else {
                // No swap needed
                elementI.classList.remove('sorting-current');
                elementJ.classList.remove('sorting-compared');
                
                currentComparison++;
                performSubarraySortStep();
            }
        }, 1500);
    }
    
    // Start subarray sort process
    performSubarraySortStep();
}
// NEW: Return to Original after Subarray Sort
function returnToOriginalAfterSubarraySort() {
    // Reset to original array
    myArray = [...originalArrayForSubarraySort];
    originalArrayForSubarraySort = [];
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isSubarraySortRunning = false;
    
    // Clear inputs
    sortSubarrayStart.value = '';
    sortSubarrayEnd.value = '';
    
    // Show original positions with animation
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation('Subarray sort demonstration completed - returned to original array', 'info');
    showNotification('Returned to original array after subarray sort demonstration', 'success');
}
// NEW: Find First Occurrence Handler
function handleFindFirstOccurrence() {
    const element = occurrenceElement.value.trim();
    if (element === '') {
        showNotification('Please enter an element to find', 'warning');
        occurrenceElement.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Find first occurrence
    let firstIndex = -1;
    for (let i = 0; i < myArray.length; i++) {
        if (myArray[i] === element) {
            firstIndex = i;
            break;
        }
    }
    
    if (firstIndex === -1) {
        searchResults.innerHTML = `<p class="text-center mb-0">Element "${element}" not found in the array</p>`;
        showNotification(`Element "${element}" not found`, 'info');
        return;
    }
    
    // Highlight the first occurrence with special animation
    highlightFirstOccurrence(firstIndex, element);
}

// NEW: Find Last Occurrence Handler
function handleFindLastOccurrence() {
    const element = occurrenceElementLast.value.trim();
    if (element === '') {
        showNotification('Please enter an element to find', 'warning');
        occurrenceElementLast.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Find last occurrence
    let lastIndex = -1;
    for (let i = myArray.length - 1; i >= 0; i--) {
        if (myArray[i] === element) {
            lastIndex = i;
            break;
        }
    }
    
    if (lastIndex === -1) {
        searchResults.innerHTML = `<p class="text-center mb-0">Element "${element}" not found in the array</p>`;
        showNotification(`Element "${element}" not found`, 'info');
        return;
    }
    
    // Highlight the last occurrence with special animation
    highlightLastOccurrence(lastIndex, element);
}

// NEW: Find All Occurrences Handler
function handleFindAllOccurrences() {
    const element = occurrenceElementAll.value.trim();
    if (element === '') {
        showNotification('Please enter an element to find', 'warning');
        occurrenceElementAll.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Find all occurrences
    const indices = [];
    for (let i = 0; i < myArray.length; i++) {
        if (myArray[i] === element) {
            indices.push(i);
        }
    }
    
    if (indices.length === 0) {
        searchResults.innerHTML = `<p class="text-center mb-0">Element "${element}" not found in the array</p>`;
        showNotification(`Element "${element}" not found`, 'info');
        return;
    }
    
    // Highlight all occurrences with special animation
    highlightAllOccurrences(indices, element);
}

// NEW: Highlight First Occurrence with Animation
function highlightFirstOccurrence(index, element) {
    const elements = document.querySelectorAll('.array-element');
    
    // Reset all elements first
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('first-occurrence', 'search-highlight');
    });
    
    // Highlight the first occurrence
    const targetElement = elements[index];
    const valueDiv = targetElement.querySelector('.element-value');
    
    valueDiv.classList.add('first-occurrence', 'search-highlight');
    
    // Display results
    searchResults.innerHTML = `
        <p class="mb-1"><strong>First Occurrence Found!</strong></p>
        <p class="mb-1">Element: "${element}"</p>
        <p class="mb-1">Index: [${index}]</p>
        <p class="mb-0">Value: "${myArray[index]}"</p>
    `;
    
    logOperation(`Found first occurrence of "${element}" at index ${index}`, 'success');
    
    // Auto-clear the input and reset highlight after 3 seconds
    setTimeout(() => {
        occurrenceElement.value = '';
        valueDiv.classList.remove('first-occurrence', 'search-highlight');
    }, 3000);
}

// NEW: Highlight Last Occurrence with Animation
function highlightLastOccurrence(index, element) {
    const elements = document.querySelectorAll('.array-element');
    
    // Reset all elements first
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('last-occurrence', 'search-highlight');
    });
    
    // Highlight the last occurrence
    const targetElement = elements[index];
    const valueDiv = targetElement.querySelector('.element-value');
    
    valueDiv.classList.add('last-occurrence', 'search-highlight');
    
    // Display results
    searchResults.innerHTML = `
        <p class="mb-1"><strong>Last Occurrence Found!</strong></p>
        <p class="mb-1">Element: "${element}"</p>
        <p class="mb-1">Index: [${index}]</p>
        <p class="mb-0">Value: "${myArray[index]}"</p>
    `;
    
    logOperation(`Found last occurrence of "${element}" at index ${index}`, 'success');
    
    // Auto-clear the input and reset highlight after 3 seconds
    setTimeout(() => {
        occurrenceElementLast.value = '';
        valueDiv.classList.remove('last-occurrence', 'search-highlight');
    }, 3000);
}

// NEW: Highlight All Occurrences with Animation
function highlightAllOccurrences(indices, element) {
    const elements = document.querySelectorAll('.array-element');
    
    // Reset all elements first
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('all-occurrence', 'search-highlight');
    });
    
    // Highlight all occurrences sequentially
    indices.forEach((index, i) => {
        setTimeout(() => {
            const targetElement = elements[index];
            const valueDiv = targetElement.querySelector('.element-value');
            valueDiv.classList.add('all-occurrence', 'search-highlight');
            
            // Pulse animation for each found element
            valueDiv.classList.add('pulse');
            setTimeout(() => {
                valueDiv.classList.remove('pulse');
            }, 600);
        }, i * 300);
    });
    
    // Display results
    searchResults.innerHTML = `
        <p class="mb-1"><strong>All Occurrences Found!</strong></p>
        <p class="mb-1">Element: "${element}"</p>
        <p class="mb-1">Total Occurrences: ${indices.length}</p>
        <p class="mb-1">Indices: ${indices.join(', ')}</p>
        <p class="mb-0">Values: "${indices.map(i => myArray[i]).join('", "')}"</p>
    `;
    
    logOperation(`Found ${indices.length} occurrence(s) of "${element}" at indices: ${indices.join(', ')}`, 'success');
    
    // Auto-clear the input and reset highlights after 5 seconds
    setTimeout(() => {
        occurrenceElementAll.value = '';
        indices.forEach(index => {
            const valueDiv = elements[index].querySelector('.element-value');
            valueDiv.classList.remove('all-occurrence', 'search-highlight');
        });
    }, 5000);
}
// NEW: Delete First Occurrence Handler
function handleDeleteFirstOccurrence() {
    const element = deleteFirstOccurrence.value.trim();
    if (element === '') {
        showNotification('Please enter an element to delete', 'warning');
        deleteFirstOccurrence.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Find first occurrence
    let firstIndex = -1;
    for (let i = 0; i < myArray.length; i++) {
        if (myArray[i] === element) {
            firstIndex = i;
            break;
        }
    }
    
    if (firstIndex === -1) {
        showNotification(`Element "${element}" not found in the array`, 'danger');
        return;
    }
    
    // Delete first occurrence with animation
    const deletedValue = myArray[firstIndex];
    highlightElement(firstIndex, 'delete', () => {
        myArray.splice(firstIndex, 1);
        renderArray();
        updateStats();
        deleteFirstOccurrence.value = '';
        logOperation(`Deleted first occurrence of "${deletedValue}" at index ${firstIndex}`, 'danger');
    });
}

// NEW: Delete All Occurrences Handler
function handleDeleteAllOccurrences() {
    const element = deleteAllOccurrences.value.trim();
    if (element === '') {
        showNotification('Please enter an element to delete', 'warning');
        deleteAllOccurrences.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Find all occurrences
    const indices = [];
    for (let i = myArray.length - 1; i >= 0; i--) {
        if (myArray[i] === element) {
            indices.push(i);
        }
    }
    
    if (indices.length === 0) {
        showNotification(`Element "${element}" not found in the array`, 'danger');
        return;
    }
    
    // Animate deletion of all matching elements
    let deletedCount = 0;
    indices.forEach((index, i) => {
        setTimeout(() => {
            highlightElement(index, 'delete', () => {
                myArray.splice(index, 1);
                deletedCount++;
                
                if (deletedCount === indices.length) {
                    renderArray();
                    updateStats();
                    deleteAllOccurrences.value = '';
                    logOperation(`Deleted all ${indices.length} occurrence(s) of "${element}"`, 'danger');
                }
            });
        }, i * 300);
    });
}


// NEW: Highlight transformed element
function highlightTransformedElement(index, type) {
    const elements = document.querySelectorAll('.array-element');
    if (index < elements.length) {
        const valueDiv = elements[index].querySelector('.element-value');
        valueDiv.classList.add('transformation-highlight');
        
        setTimeout(() => {
            valueDiv.classList.remove('transformation-highlight');
        }, 2000);
    }
}
// NEW: Remove Duplicates (In-Place) Handler
function handleRemoveDuplicatesInPlace() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - no duplicates to remove', 'info');
        return;
    }
    
    // Create a copy for comparison
    const originalArrayCopy = [...myArray];
    
    // In-place duplicate removal using two pointers
    let writeIndex = 0;
    const seen = new Set();
    const removedIndices = [];
    
    // First pass: identify duplicates and prepare for removal
    for (let readIndex = 0; readIndex < myArray.length; readIndex++) {
        if (!seen.has(myArray[readIndex])) {
            seen.add(myArray[readIndex]);
            if (writeIndex !== readIndex) {
                removedIndices.push(readIndex);
            }
            writeIndex++;
        } else {
            removedIndices.push(readIndex);
        }
    }
    
    if (removedIndices.length === 0) {
        showNotification('No duplicates found in the array', 'info');
        return;
    }
    
    // Animate removal of duplicates
    let removedCount = 0;
    removedIndices.forEach((index, i) => {
        setTimeout(() => {
            highlightElement(index, 'delete', () => {
                removedCount++;
                
                if (removedCount === removedIndices.length) {
                    // Actually perform the in-place removal
                    const newArray = [];
                    const uniqueSet = new Set();
                    
                    for (const item of originalArrayCopy) {
                        if (!uniqueSet.has(item)) {
                            uniqueSet.add(item);
                            newArray.push(item);
                        }
                    }
                    
                    myArray = newArray;
                    renderArray();
                    updateStats();
                    
                    logOperation(`Removed ${removedIndices.length} duplicate(s) in-place`, 'warning');
                    showNotification(`Removed ${removedIndices.length} duplicate element(s)`, 'success');
                }
            });
        }, i * 200);
    });
}

// NEW: Remove Duplicates (Keep One) Handler
function handleRemoveDuplicatesKeepOne() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - no duplicates to remove', 'info');
        return;
    }
    
    // Create a copy for comparison
    const originalArrayCopy = [...myArray];
    
    // Keep one occurrence of each element
    const uniqueArray = [];
    const seen = new Set();
    const removedIndices = [];
    
    // Identify which indices will be removed
    for (let i = 0; i < myArray.length; i++) {
        if (!seen.has(myArray[i])) {
            seen.add(myArray[i]);
            uniqueArray.push(myArray[i]);
        } else {
            removedIndices.push(i);
        }
    }
    
    if (removedIndices.length === 0) {
        showNotification('No duplicates found in the array', 'info');
        return;
    }
    
    // Animate removal of duplicates
    let removedCount = 0;
    removedIndices.forEach((index, i) => {
        setTimeout(() => {
            highlightElement(index, 'delete', () => {
                removedCount++;
                
                if (removedCount === removedIndices.length) {
                    // Update the array with unique elements only
                    myArray = uniqueArray;
                    renderArray();
                    updateStats();
                    
                    logOperation(`Removed duplicates, keeping one of each unique element (${removedIndices.length} removed)`, 'warning');
                    showNotification(`Kept one of each element, removed ${removedIndices.length} duplicate(s)`, 'success');
                }
            });
        }, i * 200);
    });
}     
// NEW: Clone Array Handler
function handleCloneArray() {
    const index = parseInt(cloneIndex.value);
    const newValue = cloneElementValue.value.trim();
    
    // Validation
    if (isNaN(index) || index < 0 || index >= myArray.length) {
        showNotification(`Please enter a valid index between 0 and ${myArray.length - 1}`, 'danger');
        cloneIndex.focus();
        return;
    }
    
    if (newValue === '') {
        showNotification('Please enter a new element value', 'warning');
        cloneElementValue.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Show clone operation visualization
    showCloneVisualization(index, newValue);
}
// NEW: Show Clone Visualization
function showCloneVisualization(index, newValue) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Array Cloning Demonstration</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array (Reference)</div>
            <div class="original-array-container" id="originalArrayClone"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-copy"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Cloned Array (Deep Copy)</div>
            <div class="transformed-array-container" id="clonedArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Cloning Process:</strong> Creating a true copy that can be modified independently</p>
            <p class="mb-0" id="cloneExplanation">Starting clone demonstration...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="cloneStepsContainer">
            <h6 class="text-center">Clone Operation Steps</h6>
            <div class="steps-container" id="cloneSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterClone" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Store original array reference
    const originalArray = myArray;
    
    // Render both arrays
    renderArrayInContainer(originalArray, 'originalArrayClone');
    renderArrayInContainer([...originalArray], 'clonedArray');
    
    // Perform clone demonstration
    performCloneDemonstration(index, newValue, originalArray);
}
// NEW: Perform Clone Demonstration
function performCloneDemonstration(index, newValue, originalArray) {
    const originalContainer = document.getElementById('originalArrayClone');
    const clonedContainer = document.getElementById('clonedArray');
    const explanation = document.getElementById('cloneExplanation');
    const stepsContainer = document.getElementById('cloneSteps');
    const continueButton = document.getElementById('continueAfterClone');
    
    // Create a true clone (deep copy)
    const clonedArray = [...originalArray];
    
    let currentStep = 0;
    
    function performCloneStep() {
        switch (currentStep) {
            case 0:
                // Step 1: Show original array
                explanation.innerHTML = 'Step 1: Original array created';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Original array created: [${originalArray.join(', ')}]
                    </div>
                `;
                break;
                
            case 1:
                // Step 2: Demonstrate reference assignment (wrong way)
                explanation.innerHTML = 'Step 2: Reference assignment (wrong way) - let copy = original';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step 2:</strong> Reference assignment: Both variables point to same array
                    </div>
                `;
                
                // Highlight both arrays as same
                const originalElements = originalContainer.querySelectorAll('.array-element');
                const clonedElements = clonedContainer.querySelectorAll('.array-element');
                
                originalElements.forEach(el => {
                    el.querySelector('.element-value').classList.add('warning-color');
                });
                clonedElements.forEach(el => {
                    el.querySelector('.element-value').classList.add('warning-color');
                });
                break;
                
            case 2:
                // Step 3: Show proper cloning
                explanation.innerHTML = 'Step 3: Proper cloning using spread operator - let clone = [...original]';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Proper cloning creates independent copy
                    </div>
                `;
                
                // Remove warning highlights and show success
                const allElements = document.querySelectorAll('.element-value');
                allElements.forEach(el => {
                    el.classList.remove('warning-color');
                    el.classList.add('info-color');
                });
                break;
                
            case 3:
                // Step 4: Modify cloned array
                explanation.innerHTML = `Step 4: Modifying cloned array at index ${index} with value "${newValue}"`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 4:</strong> Modifying clone[index ${index}] = "${newValue}"
                    </div>
                `;
                
                // Highlight the element being modified in cloned array
                const clonedElementsMod = clonedContainer.querySelectorAll('.array-element');
                const elementToModify = clonedElementsMod[index].querySelector('.element-value');
                elementToModify.classList.add('update', 'pulse');
                
                // After delay, update the cloned array
                setTimeout(() => {
                    clonedArray[index] = newValue;
                    renderArrayInContainer(clonedArray, 'clonedArray');
                    
                    // Highlight the modified element
                    const updatedElements = clonedContainer.querySelectorAll('.array-element');
                    const updatedElement = updatedElements[index].querySelector('.element-value');
                    updatedElement.classList.add('create', 'bounce');
                    
                    explanation.innerHTML = `Step 5: Cloned array modified! Original remains unchanged.`;
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 5:</strong> Clone modified successfully! Original array unchanged.
                        </div>
                    `;
                    
                    // Show comparison
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Result:</strong> 
                            Original: [${originalArray.join(', ')}] | 
                            Clone: [${clonedArray.join(', ')}]
                        </div>
                    `;
                    
                    currentStep++;
                    performCloneStep();
                }, 1500);
                return;
                
            case 4:
                // Step 5: Show that original is unchanged
                explanation.innerHTML = '<strong>Clone Demonstration Complete!</strong> Original array remains unchanged while clone is modified.';
                
                // Highlight the difference
                const originalElementsFinal = originalContainer.querySelectorAll('.array-element');
                const clonedElementsFinal = clonedContainer.querySelectorAll('.array-element');
                
                // Show original as unchanged (green)
                originalElementsFinal.forEach(el => {
                    el.querySelector('.element-value').classList.add('success-color');
                });
                
                // Show modified element in clone (yellow)
                clonedElementsFinal[index].querySelector('.element-value').classList.add('warning-color');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Clone operation successful! Arrays are independent.
                    </div>
                `;
                
                continueButton.style.display = 'block';
                continueButton.addEventListener('click', resetAfterClone);
                
                // Auto-reset after 5 seconds
                setTimeout(() => {
                    resetAfterClone();
                }, 5000);
                return;
        }
        
        currentStep++;
        setTimeout(performCloneStep, 2000);
    }
    
    // Start the demonstration
    performCloneStep();
}
// NEW: Reset after Clone Operation
function resetAfterClone() {
    // Clear inputs
    cloneIndex.value = '';
    cloneElementValue.value = '';
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    
    logOperation('Clone array demonstration completed', 'info');
    showNotification('Returned to original array view', 'success');
}  
// NEW: Merge Two Sorted Arrays Handler
function handleMergeSortedArrays() {
    if (isMergeOperationRunning) {
        showNotification('A merge operation is already in progress', 'warning');
        return;
    }

    // Reset arrays
    firstArray = [];
    secondArray = [];
    firstArraySize = 0;
    secondArraySize = 0;
    
    // Show input group
    mergeArraysGroup.style.display = 'block';
    firstArraySizeInput.focus();
    
    // Hide perform merge button initially
    performMergeBtn.style.display = 'none';
    
    logOperation('Started merge two sorted arrays operation', 'info');
}

// NEW: Confirm First Array Size Handler
function handleConfirmFirstArraySize() {
    const size = parseInt(firstArraySizeInput.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        firstArraySizeInput.focus();
        return;
    }
    
    firstArraySize = size;
    firstArray = [];
    
    // Create input fields for first array
    firstArrayInputs.innerHTML = '<label class="form-label">Enter elements for First Array:</label>';
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="text" class="form-control first-array-element" 
                   placeholder="Enter value" data-index="${i}">
        `;
        firstArrayInputs.appendChild(inputGroup);
    }
    
    // Add event listeners for first array inputs
    const firstArrayElements = firstArrayInputs.querySelectorAll('.first-array-element');
    firstArrayElements.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                // Auto-focus next input or move to second array
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('first-array-element')) {
                    nextInput.focus();
                } else {
                    secondArraySizeInput.focus();
                }
            }
        });
    });
    
    showNotification(`First array size set to ${size}. Please enter ${size} elements.`, 'success');
    logOperation(`First array size set to ${size}`, 'info');
}

// NEW: Confirm Second Array Size Handler
function handleConfirmSecondArraySize() {
    const size = parseInt(secondArraySizeInput.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        secondArraySizeInput.focus();
        return;
    }
    
    secondArraySize = size;
    secondArray = [];
    
    // Create input fields for second array
    secondArrayInputs.innerHTML = '<label class="form-label">Enter elements for Second Array:</label>';
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="text" class="form-control second-array-element" 
                   placeholder="Enter value" data-index="${i}">
        `;
        secondArrayInputs.appendChild(inputGroup);
    }
    
    // Add event listeners for second array inputs
    const secondArrayElements = secondArrayInputs.querySelectorAll('.second-array-element');
    secondArrayElements.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('second-array-element')) {
                    nextInput.focus();
                }
            }
        });
    });
    
    // Show perform merge button
    performMergeBtn.style.display = 'block';
    
    showNotification(`Second array size set to ${size}. Please enter ${size} elements.`, 'success');
    logOperation(`Second array size set to ${size}`, 'info');
}

// NEW: Perform Merge Handler
function handlePerformMerge() {
    // Collect first array elements
    const firstArrayInputs = document.querySelectorAll('.first-array-element');
    firstArray = [];
    
    for (let i = 0; i < firstArrayInputs.length; i++) {
        const value = firstArrayInputs[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all elements for first array. Missing element at position ${i}`, 'danger');
            firstArrayInputs[i].focus();
            return;
        }
        firstArray.push(value);
    }
    
    // Collect second array elements
    const secondArrayInputs = document.querySelectorAll('.second-array-element');
    secondArray = [];
    
    for (let i = 0; i < secondArrayInputs.length; i++) {
        const value = secondArrayInputs[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all elements for second array. Missing element at position ${i}`, 'danger');
            secondArrayInputs[i].focus();
            return;
        }
        secondArray.push(value);
    }
    
    // Store original array
    originalArrayBeforeMerge = [...myArray];
    
    // Hide input group
    mergeArraysGroup.style.display = 'none';
    
    // Start merge visualization
    showMergeVisualization();
}

// NEW: Cancel Merge Handler
function handleCancelMerge() {
    mergeArraysGroup.style.display = 'none';
    firstArraySizeInput.value = '';
    secondArraySizeInput.value = '';
    firstArrayInputs.innerHTML = '';
    secondArrayInputs.innerHTML = '';
    performMergeBtn.style.display = 'none';
    
    firstArray = [];
    secondArray = [];
    firstArraySize = 0;
    secondArraySize = 0;
    
    logOperation('Cancelled merge operation', 'info');
    showNotification('Merge operation cancelled', 'info');
}
// NEW: Show Merge Visualization
function showMergeVisualization() {
    isMergeOperationRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Merge Two Sorted Arrays</h5>
        
        <div class="array-group">
            <div class="array-label">First Array (Arr1)</div>
            <div class="original-array-container" id="firstArrayDisplay"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Second Array (Arr2)</div>
            <div class="original-array-container" id="secondArrayDisplay"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Merged Sorted Array</div>
            <div class="transformed-array-container" id="mergedArrayDisplay"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Merge Process:</strong> Merging two sorted arrays into one sorted array</p>
            <p class="mb-0" id="mergeExplanation">Starting merge operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="mergeStepsContainer">
            <h6 class="text-center">Merge Steps</h6>
            <div class="steps-container" id="mergeSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMerge" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display the input arrays
    renderArrayInContainer(firstArray, 'firstArrayDisplay');
    renderArrayInContainer(secondArray, 'secondArrayDisplay');
    renderArrayInContainer([], 'mergedArrayDisplay');
    
    // Start merge animation
    performMergeAnimation();
}

// NEW: Perform Merge Animation
function performMergeAnimation() {
    const firstContainer = document.getElementById('firstArrayDisplay');
    const secondContainer = document.getElementById('secondArrayDisplay');
    const mergedContainer = document.getElementById('mergedArrayDisplay');
    const explanation = document.getElementById('mergeExplanation');
    const stepsContainer = document.getElementById('mergeSteps');
    const continueButton = document.getElementById('continueAfterMerge');
    
    // Sort both arrays first (if not already sorted)
    const sortedFirstArray = [...firstArray].sort((a, b) => {
        const numA = parseFloat(a);
        const numB = parseFloat(b);
        if (!isNaN(numA) && !isNaN(numB)) {
            return numA - numB;
        }
        return a.toString().localeCompare(b.toString());
    });
    
    const sortedSecondArray = [...secondArray].sort((a, b) => {
        const numA = parseFloat(a);
        const numB = parseFloat(b);
        if (!isNaN(numA) && !isNaN(numB)) {
            return numA - numB;
        }
        return a.toString().localeCompare(b.toString());
    });
    
    let mergedArray = [];
    let i = 0, j = 0;
    let step = 0;
    
    function performMergeStep() {
        if (i >= sortedFirstArray.length && j >= sortedSecondArray.length) {
            // Merge completed
            explanation.innerHTML = `<strong>Merge Completed!</strong> Successfully merged two arrays into one sorted array.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Merge completed! Total elements: ${mergedArray.length}
                </div>
            `;
            
            // Highlight the merged array
            const mergedElements = mergedContainer.querySelectorAll('.array-element');
            mergedElements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('create', 'bounce');
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return to original after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterMerge();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterMerge);
            
            return;
        }
        
        step++;
        
        if (i < sortedFirstArray.length && j < sortedSecondArray.length) {
            // Compare elements from both arrays
            const val1 = sortedFirstArray[i];
            const val2 = sortedSecondArray[j];
            
            const num1 = parseFloat(val1);
            const num2 = parseFloat(val2);
            
            let shouldTakeFirst = false;
            
            if (!isNaN(num1) && !isNaN(num2)) {
                shouldTakeFirst = num1 <= num2;
            } else {
                shouldTakeFirst = val1 <= val2;
            }
            
            explanation.innerHTML = `Step ${step}: Comparing Arr1[${i}]="${val1}" and Arr2[${j}]="${val2}"`;
            
            // Highlight elements being compared
            const firstElements = firstContainer.querySelectorAll('.array-element');
            const secondElements = secondContainer.querySelectorAll('.array-element');
            
            if (i < firstElements.length) {
                firstElements[i].querySelector('.element-value').classList.add('sorting-current');
            }
            if (j < secondElements.length) {
                secondElements[j].querySelector('.element-value').classList.add('sorting-compared');
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Compare Arr1[${i}]="${val1}" and Arr2[${j}]="${val2}" - 
                    Taking ${shouldTakeFirst ? 'Arr1' : 'Arr2'} element
                </div>
            `;
            
            // Scroll steps container
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            setTimeout(() => {
                // Remove highlights
                if (i < firstElements.length) {
                    firstElements[i].querySelector('.element-value').classList.remove('sorting-current');
                }
                if (j < secondElements.length) {
                    secondElements[j].querySelector('.element-value').classList.remove('sorting-compared');
                }
                
                // Take the smaller element
                if (shouldTakeFirst) {
                    mergedArray.push(val1);
                    i++;
                } else {
                    mergedArray.push(val2);
                    j++;
                }
                
                // Update merged array display
                renderArrayInContainer(mergedArray, 'mergedArrayDisplay');
                
                // Continue to next step
                performMergeStep();
            }, 1500);
            
        } else if (i < sortedFirstArray.length) {
            // Take remaining elements from first array
            explanation.innerHTML = `Step ${step}: Taking remaining element from Arr1[${i}]="${sortedFirstArray[i]}"`;
            
            const firstElements = firstContainer.querySelectorAll('.array-element');
            if (i < firstElements.length) {
                firstElements[i].querySelector('.element-value').classList.add('create');
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}:</strong> Taking remaining element from Arr1[${i}]="${sortedFirstArray[i]}"
                </div>
            `;
            
            setTimeout(() => {
                if (i < firstElements.length) {
                    firstElements[i].querySelector('.element-value').classList.remove('create');
                }
                
                mergedArray.push(sortedFirstArray[i]);
                i++;
                
                renderArrayInContainer(mergedArray, 'mergedArrayDisplay');
                performMergeStep();
            }, 1000);
            
        } else {
            // Take remaining elements from second array
            explanation.innerHTML = `Step ${step}: Taking remaining element from Arr2[${j}]="${sortedSecondArray[j]}"`;
            
            const secondElements = secondContainer.querySelectorAll('.array-element');
            if (j < secondElements.length) {
                secondElements[j].querySelector('.element-value').classList.add('create');
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}:</strong> Taking remaining element from Arr2[${j}]="${sortedSecondArray[j]}"
                </div>
            `;
            
            setTimeout(() => {
                if (j < secondElements.length) {
                    secondElements[j].querySelector('.element-value').classList.remove('create');
                }
                
                mergedArray.push(sortedSecondArray[j]);
                j++;
                
                renderArrayInContainer(mergedArray, 'mergedArrayDisplay');
                performMergeStep();
            }, 1000);
        }
    }
    
    // Start merge process
    performMergeStep();
}

// NEW: Return to Original after Merge
function returnToOriginalAfterMerge() {
    // Reset to original array
    myArray = [...originalArrayBeforeMerge];
    originalArrayBeforeMerge = [];
    
    // Remove merge visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMergeOperationRunning = false;
    
    // Clear all merge-related data
    firstArray = [];
    secondArray = [];
    firstArraySize = 0;
    secondArraySize = 0;
    
    // Reset input groups
    mergeArraysGroup.style.display = 'none';
    firstArraySizeInput.value = '';
    secondArraySizeInput.value = '';
    firstArrayInputs.innerHTML = '';
    secondArrayInputs.innerHTML = '';
    performMergeBtn.style.display = 'none';
    
    logOperation('Merge operation completed - returned to original array', 'info');
    showNotification('Returned to original array after merge operation', 'success');
}

// NEW: Reverse Array Handler
function handleReverseArray() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - cannot reverse', 'info');
        return;
    }
    
    // Store original array
    originalArrayForOperations = [...myArray];
    currentOperation = 'reverse';
    
    // Show dual visualization for reversal
    showReverseVisualization();
}

// NEW: Handle Rotate Operation (Left/Right)
function handleRotateOperation(direction) {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - cannot rotate', 'info');
        return;
    }
    
    currentOperation = direction;
    
    // Show input for positions
    rotateInputGroup.style.display = 'flex';
    rotatePositionsInput.focus();
    rotatePositionsInput.placeholder = `Enter positions (1 to ${myArray.length})`;
    
    // Update button text based on direction
    confirmRotateBtn.innerHTML = 
        direction === 'left' 
            ? '<i class="fas fa-undo me-2"></i>Rotate Left' 
            : '<i class="fas fa-redo me-2"></i>Rotate Right';
}

// NEW: Confirm Rotate Handler
function handleConfirmRotate() {
    const positions = parseInt(rotatePositionsInput.value);
    const maxPositions = myArray.length;
    
    if (isNaN(positions) || positions < 1 || positions > maxPositions) {
        showNotification(`Please enter a valid number between 1 and ${maxPositions}`, 'danger');
        rotatePositionsInput.focus();
        return;
    }
    
    rotatePositions = positions;
    
    // Store original array
    originalArrayForOperations = [...myArray];
    
    // Hide input group
    rotateInputGroup.style.display = 'none';
    rotatePositionsInput.value = '';
    
    // Show rotation visualization
    if (currentOperation === 'left') {
        showRotateLeftVisualization();
    } else {
        showRotateRightVisualization();
    }
}

// NEW: Cancel Rotate Handler
function handleCancelRotate() {
    rotateInputGroup.style.display = 'none';
    rotatePositionsInput.value = '';
    currentOperation = null;
}

// NEW: Show Reverse Visualization
function showReverseVisualization() {
    // Create dual container for reverse operation
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Array Reversal Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalArrayOp"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrows-alt-h"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Reversed Array</div>
            <div class="transformed-array-container" id="transformedArrayOp"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Reversal Process:</strong> Swapping elements from both ends towards the center</p>
            <p class="mb-0" id="reverseExplanation">Starting reversal animation...</p>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterReverse" style="display: none;">
            <i class="fas fa-play me-1"></i>Continue with Reversed Array
        </button>
    `;
    
    // Replace the main array container
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Render original array
    renderArrayInContainer(originalArrayForOperations, 'originalArrayOp');
    
    // Render reversed array (initially same as original)
    renderArrayInContainer([...originalArrayForOperations], 'transformedArrayOp');
    
    // Start reversal animation
    performReverseAnimation();
}

// NEW: Perform Reverse Animation
function performReverseAnimation() {
    const originalContainer = document.getElementById('originalArrayOp');
    const transformedContainer = document.getElementById('transformedArrayOp');
    const explanation = document.getElementById('reverseExplanation');
    const continueButton = document.getElementById('continueAfterReverse');
    
    const array = [...originalArrayForOperations];
    const n = array.length;
    let step = 0;
    
    function performSwapStep(left, right) {
        if (left >= right) {
            // Reversal completed
            explanation.innerHTML = '<strong>Reversal Completed!</strong> Array has been successfully reversed.';
            
            // Show continue button
            continueButton.style.display = 'block';
            
            // Auto-proceed after 3 seconds
            const autoProceedTimer = setTimeout(() => {
                proceedWithReversedArray();
            }, 3000);
            
            continueButton.addEventListener('click', () => {
                clearTimeout(autoProceedTimer);
                proceedWithReversedArray();
            });
            
            return;
        }
        
        // Update explanation
        explanation.innerHTML = `Swapping elements at indices [${left}] and [${right}]: "${array[left]}"  "${array[right]}"`;
        
        // Highlight elements being swapped in original array
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const leftElement = originalElements[left].querySelector('.element-value');
        const rightElement = originalElements[right].querySelector('.element-value');
        
        leftElement.classList.add('reverse-highlight');
        rightElement.classList.add('reverse-highlight');
        
        // Calculate swap distance for animation
        const leftRect = originalElements[left].getBoundingClientRect();
        const rightRect = originalElements[right].getBoundingClientRect();
        const swapDistance = rightRect.left - leftRect.left;
        
        leftElement.style.setProperty('--swap-distance', `${swapDistance}px`);
        rightElement.style.setProperty('--swap-distance', `-${swapDistance}px`);
        
        // Perform swap animation
        setTimeout(() => {
            leftElement.classList.add('swap-animation');
            rightElement.classList.add('swap-animation');
            
            // After animation, update the transformed array
            setTimeout(() => {
                // Swap the elements
                [array[left], array[right]] = [array[right], array[left]];
                
                // Update transformed array display
                renderArrayInContainer(array, 'transformedArrayOp');
                
                // Remove highlights
                leftElement.classList.remove('reverse-highlight', 'swap-animation');
                rightElement.classList.remove('reverse-highlight', 'swap-animation');
                
                // Move to next pair
                step++;
                performSwapStep(left + 1, right - 1);
            }, 1000);
        }, 500);
    }
    
    // Start the reversal process
    performSwapStep(0, n - 1);
}

// NEW: Proceed with Reversed Array
function proceedWithReversedArray() {
    // Reverse the actual array
    myArray.reverse();
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    logOperation('Array reversed successfully', 'success');
    showNotification('Array reversed successfully', 'success');
    
    // Auto-reset after 8 seconds
    setTimeout(() => {
        resetAfterOperation();
    }, 8000);
}

// NEW: Show Rotate Left Visualization
function showRotateLeftVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Rotate Left by ${rotatePositions} Position(s)</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalArrayOp"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-left"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Rotated Array</div>
            <div class="transformed-array-container" id="transformedArrayOp"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Rotation Process:</strong> Moving first ${rotatePositions} element(s) to the end</p>
            <p class="mb-0" id="rotateExplanation">Starting rotation animation...</p>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterRotate" style="display: none;">
            <i class="fas fa-play me-1"></i>Continue with Rotated Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForOperations, 'originalArrayOp');
    renderArrayInContainer([...originalArrayForOperations], 'transformedArrayOp');
    
    performRotateLeftAnimation();
}

// NEW: Show Rotate Right Visualization
function showRotateRightVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Rotate Right by ${rotatePositions} Position(s)</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalArrayOp"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-right"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Rotated Array</div>
            <div class="transformed-array-container" id="transformedArrayOp"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Rotation Process:</strong> Moving last ${rotatePositions} element(s) to the beginning</p>
            <p class="mb-0" id="rotateExplanation">Starting rotation animation...</p>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterRotate" style="display: none;">
            <i class="fas fa-play me-1"></i>Continue with Rotated Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForOperations, 'originalArrayOp');
    renderArrayInContainer([...originalArrayForOperations], 'transformedArrayOp');
    
    performRotateRightAnimation();
}

// NEW: Perform Rotate Left Animation
function performRotateLeftAnimation() {
    const originalContainer = document.getElementById('originalArrayOp');
    const transformedContainer = document.getElementById('transformedArrayOp');
    const explanation = document.getElementById('rotateExplanation');
    const continueButton = document.getElementById('continueAfterRotate');
    
    const array = [...originalArrayForOperations];
    const k = rotatePositions;
    let currentStep = 0;
    
    function performRotationStep() {
        if (currentStep >= k) {
            // Rotation completed
            explanation.innerHTML = `<strong>Rotation Completed!</strong> Array rotated left by ${k} position(s).`;
            
            continueButton.style.display = 'block';
            const autoProceedTimer = setTimeout(() => {
                proceedWithRotatedArray();
            }, 3000);
            
            continueButton.addEventListener('click', () => {
                clearTimeout(autoProceedTimer);
                proceedWithRotatedArray();
            });
            
            return;
        }
        
        // Show current step
        explanation.innerHTML = `Moving element from position ${currentStep} to the end: "${array[currentStep]}"`;
        
        // Highlight current element being moved
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentStep].querySelector('.element-value');
        currentElement.classList.add('rotate-highlight');
        
        // Perform rotation animation
        setTimeout(() => {
            // Remove element from beginning and add to end
            const elementToMove = array.shift();
            array.push(elementToMove);
            
            // Update transformed array display
            renderArrayInContainer(array, 'transformedArrayOp');
            
            // Remove highlight
            currentElement.classList.remove('rotate-highlight');
            
            // Move to next step
            currentStep++;
            performRotationStep();
        }, 1500);
    }
    
    // Start rotation process
    performRotationStep();
}

// NEW: Perform Rotate Right Animation
function performRotateRightAnimation() {
    const originalContainer = document.getElementById('originalArrayOp');
    const transformedContainer = document.getElementById('transformedArrayOp');
    const explanation = document.getElementById('rotateExplanation');
    const continueButton = document.getElementById('continueAfterRotate');
    
    const array = [...originalArrayForOperations];
    const k = rotatePositions;
    let currentStep = 0;
    
    function performRotationStep() {
        if (currentStep >= k) {
            // Rotation completed
            explanation.innerHTML = `<strong>Rotation Completed!</strong> Array rotated right by ${k} position(s).`;
            
            continueButton.style.display = 'block';
            const autoProceedTimer = setTimeout(() => {
                proceedWithRotatedArray();
            }, 3000);
            
            continueButton.addEventListener('click', () => {
                clearTimeout(autoProceedTimer);
                proceedWithRotatedArray();
            });
            
            return;
        }
        
        // Show current step
        const moveIndex = array.length - 1;
        explanation.innerHTML = `Moving element from position ${moveIndex} to the beginning: "${array[moveIndex]}"`;
        
        // Highlight current element being moved
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[moveIndex].querySelector('.element-value');
        currentElement.classList.add('rotate-highlight');
        
        // Perform rotation animation
        setTimeout(() => {
            // Remove element from end and add to beginning
            const elementToMove = array.pop();
            array.unshift(elementToMove);
            
            // Update transformed array display
            renderArrayInContainer(array, 'transformedArrayOp');
            
            // Remove highlight
            currentElement.classList.remove('rotate-highlight');
            
            // Move to next step
            currentStep++;
            performRotationStep();
        }, 1500);
    }
    
    // Start rotation process
    performRotationStep();
}

// NEW: Proceed with Rotated Array
function proceedWithRotatedArray() {
    // Apply the rotation to the actual array
    if (currentOperation === 'left') {
        // Rotate left
        for (let i = 0; i < rotatePositions; i++) {
            myArray.push(myArray.shift());
        }
    } else {
        // Rotate right
        for (let i = 0; i < rotatePositions; i++) {
            myArray.unshift(myArray.pop());
        }
    }
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    const operationName = currentOperation === 'left' ? 'left rotation' : 'right rotation';
    logOperation(`Array ${operationName} by ${rotatePositions} position(s)`, 'success');
    showNotification(`Array ${operationName} by ${rotatePositions} position(s) successful`, 'success');
    
    // Auto-reset after 8 seconds
    setTimeout(() => {
        resetAfterOperation();
    }, 8000);
}

// NEW: Reset after operation
function resetAfterOperation() {
    if (originalArrayForOperations.length === 0) {
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayForOperations];
    originalArrayForOperations = [];
    currentOperation = null;
    rotatePositions = 0;
    
    renderArray();
    updateStats();
    
    logOperation('Reset to original array after operation', 'info');
    showNotification('Automatically reset to original array', 'info');
}
// NEW: Fill Array Handler
// NEW: Fill Array Handler
function handleFillArray() {
    const value = fillValue.value.trim();
    
    if (value === '') {
        showNotification('Please enter a value to fill', 'warning');
        fillValue.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    const startIndex = fillStart.value === '' ? 0 : parseInt(fillStart.value);
    const endIndex = fillEnd.value === '' ? myArray.length - 1 : parseInt(fillEnd.value);
    
    // Validate indices
    if (isNaN(startIndex) || startIndex < 0 || startIndex >= myArray.length) {
        showNotification(`Please enter a valid start index between 0 and ${myArray.length - 1}`, 'danger');
        fillStart.focus();
        return;
    }
    
    if (isNaN(endIndex) || endIndex < 0 || endIndex >= myArray.length) {
        showNotification(`Please enter a valid end index between 0 and ${myArray.length - 1}`, 'danger');
        fillEnd.focus();
        return;
    }
    
    // ADD THIS VALIDATION: Check if start index is greater than end index
    if (startIndex > endIndex) {
        showNotification('Start index cannot be greater than end index', 'danger');
        fillStart.focus();
        return;
    }
    
    // Store original array
    originalArrayForFill = [...myArray];
    isFillOperation = true;
    
    // Show fill operation visualization
    showFillVisualization(value, startIndex, endIndex);
}
// NEW: Show Fill Visualization
function showFillVisualization(value, startIndex, endIndex) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Fill Array Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalArrayOp"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After Fill Operation</div>
            <div class="transformed-array-container" id="transformedArrayOp"></div>
        </div>
        
        <div class="operation-explanation">
           <p class="mb-2"><strong>Fill Operation:</strong> Setting elements from index ${startIndex} to ${endIndex} to value "${value}"</p>
            <p class="mb-0" id="fillExplanation">Starting fill operation...</p>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterFill" style="display: none;">
            <i class="fas fa-play me-1"></i>Continue with Filled Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForFill, 'originalArrayOp');
    renderArrayInContainer([...originalArrayForFill], 'transformedArrayOp');
    
    performFillAnimation(value, startIndex, endIndex);
}

// NEW: Perform Fill Animation
function performFillAnimation(value, startIndex, endIndex) {
    const originalContainer = document.getElementById('originalArrayOp');
    const transformedContainer = document.getElementById('transformedArrayOp');
    const explanation = document.getElementById('fillExplanation');
    const continueButton = document.getElementById('continueAfterFill');
    
    const array = [...originalArrayForFill];
    let currentIndex = startIndex;
    
    function performFillStep() {
        if (currentIndex > endIndex) {
            // Fill operation completed
            explanation.innerHTML = `<strong>Fill Operation Completed!</strong> Filled ${endIndex - startIndex + 1} elements with value "${value}"`;
            
            continueButton.style.display = 'block';
            const autoProceedTimer = setTimeout(() => {
                proceedWithFilledArray(value, startIndex, endIndex);
            }, 3000);
            
            continueButton.addEventListener('click', () => {
                clearTimeout(autoProceedTimer);
                proceedWithFilledArray(value, startIndex, endIndex);
            });
            
            return;
        }
        
        // Update explanation
        explanation.innerHTML = `Filling index ${currentIndex} with value "${value}"`;
        
        // Highlight current element being filled
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentIndex].querySelector('.element-value');
        currentElement.classList.add('update');
        
        // Perform fill animation
        setTimeout(() => {
            // Update the array
            array[currentIndex] = value;
            
            // Update transformed array display
            renderArrayInContainer(array, 'transformedArrayOp');
            
            // Highlight the filled element in transformed array
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const transformedElement = transformedElements[currentIndex].querySelector('.element-value');
            transformedElement.classList.add('create', 'pulse');
            
            // Remove highlight from original element
            currentElement.classList.remove('update');
            
            // Move to next index
            currentIndex++;
            performFillStep();
        }, 800);
    }
    
    // Start fill operation
    performFillStep();
}

// NEW: Proceed with Filled Array
function proceedWithFilledArray(value, startIndex, endIndex) {
    // Apply the fill operation to the actual array
    for (let i = startIndex; i <= endIndex; i++) {
        myArray[i] = value;
    }
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Clear inputs
    fillValue.value = '';
    fillStart.value = '';
    fillEnd.value = '';
    
    logOperation(`Filled array from index ${startIndex} to ${endIndex} with value "${value}"`, 'warning');
    showNotification(`Array filled successfully with "${value}"`, 'success');
    
    // Auto-reset after 8 seconds
    setTimeout(() => {
        resetAfterFillOperation();
    }, 8000);
}

// NEW: Reset after Fill Operation
function resetAfterFillOperation() {
    if (!isFillOperation || originalArrayForFill.length === 0) {
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayForFill];
    originalArrayForFill = [];
    isFillOperation = false;
    
    renderArray();
    updateStats();
    
    logOperation('Reset to original array after fill operation', 'info');
    showNotification('Automatically reset to original array', 'info');
}

// NEW: Show Swap Input Group
function showSwapInputGroup(type) {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Hide all swap groups first
    swapByValuesGroup.style.display = 'none';
    swapByIndicesGroup.style.display = 'none';
    
    // Show the selected group
    if (type === 'values') {
        swapByValuesGroup.style.display = 'block';
        swapCount.focus();
    } else {
        swapByIndicesGroup.style.display = 'block';
        swapIndicesCount.focus();
    }
}

// NEW: Confirm Swap Count Handler (for values)
function handleConfirmSwapCount() {
    const count = parseInt(swapCount.value);
    
    if (isNaN(count) || count < 2) {
        showNotification('Please enter a valid number (minimum 2)', 'danger');
        swapCount.focus();
        return;
    }
    
    if (count > myArray.length) {
        showNotification(`Cannot swap more elements than array size (${myArray.length})`, 'danger');
        swapCount.focus();
        return;
    }
    
    // Create input fields for values
    swapValuesInputs.innerHTML = '';
    for (let i = 0; i < count; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Value ${i + 1}</span>
            <input type="text" class="form-control swap-value-input" placeholder="Enter element value">
        `;
        swapValuesInputs.appendChild(inputGroup);
    }
    
    const confirmButton = document.createElement('button');
    confirmButton.className = 'btn btn-glow w-100';
    confirmButton.innerHTML = '<i class="fas fa-exchange-alt me-2"></i>Perform Swap';
    confirmButton.addEventListener('click', handleSwapByValues);
    swapValuesInputs.appendChild(confirmButton);
}

// NEW: Confirm Swap Count Handler (for indices)
// NEW: Confirm Swap Count Handler (for indices)
function handleConfirmSwapIndicesCount() {
    const count = parseInt(swapIndicesCount.value);
    
    if (isNaN(count) || count < 2) {  // This line already ensures minimum 2
        showNotification('Please enter a valid number (minimum 2)', 'danger');
        swapIndicesCount.focus();
        return;
    }
    
    if (count > myArray.length) {
        showNotification(`Cannot swap more indices than array size (${myArray.length})`, 'danger');
        swapIndicesCount.focus();
        return;
    }
    
    // ADD THIS VALIDATION: Ensure we have enough unique indices available
    if (count > myArray.length) {
        showNotification(`Cannot select more than ${myArray.length} unique indices`, 'danger');
        swapIndicesCount.focus();
        return;
    }
    
    // Create input fields for indices
    swapIndicesInputs.innerHTML = '';
    for (let i = 0; i < count; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Index ${i + 1}</span>
            <input type="number" class="form-control swap-index-input" placeholder="Enter index (0 to ${myArray.length - 1})" min="0" max="${myArray.length - 1}">
        `;
        swapIndicesInputs.appendChild(inputGroup);
    }
    
    const confirmButton = document.createElement('button');
    confirmButton.className = 'btn btn-glow w-100';
    confirmButton.innerHTML = '<i class="fas fa-sync-alt me-2"></i>Perform Swap';
    confirmButton.addEventListener('click', handleSwapByIndices);
    swapIndicesInputs.appendChild(confirmButton);
}

// NEW: Swap by Values Handler
function handleSwapByValues() {
    const valueInputs = document.querySelectorAll('.swap-value-input');
    const values = [];
    
    // Collect values
    for (let input of valueInputs) {
        const value = input.value.trim();
        if (value === '') {
            showNotification('Please fill all value fields', 'warning');
            input.focus();
            return;
        }
        values.push(value);
    }
    
    // Check if all values exist in array
    const indices = [];
    for (let value of values) {
        let found = false;
        for (let i = 0; i < myArray.length; i++) {
            if (myArray[i] === value) {
                indices.push(i);
                found = true;
                break;
            }
        }
        if (!found) {
            showNotification(`Value "${value}" not found in array`, 'danger');
            return;
        }
    }
    
    // Check for duplicate indices (same value multiple times)
    if (new Set(indices).size !== indices.length) {
        showNotification('Cannot swap the same element multiple times', 'warning');
        return;
    }
    
    // Store original array
    originalArrayForSwap = [...myArray];
    isSwapOperation = true;
    
    // Perform swap visualization
    showSwapVisualization(indices, 'values');
}

// NEW: Swap by Indices Handler
// NEW: Swap by Indices Handler
function handleSwapByIndices() {
    const indexInputs = document.querySelectorAll('.swap-index-input');
    const indices = [];
    
    // Collect indices
    for (let input of indexInputs) {
        const index = parseInt(input.value);
        if (isNaN(index) || index < 0 || index >= myArray.length) {
            showNotification(`Please enter valid indices between 0 and ${myArray.length - 1}`, 'danger');
            input.focus();
            return;
        }
        indices.push(index);
    }
    
    // Check for duplicate indices
    if (new Set(indices).size !== indices.length) {
        showNotification('Cannot swap the same index multiple times', 'warning');
        return;
    }
    
    // ADD THIS VALIDATION: Check if there are at least 2 unique indices to swap
    if (indices.length < 2) {
        showNotification('At least 2 different indices are required for swapping', 'warning');
        return;
    }
    
    // Store original array
    originalArrayForSwap = [...myArray];
    isSwapOperation = true;
    
    // Perform swap visualization
    showSwapVisualization(indices, 'indices');
}

// NEW: Show Swap Visualization
function showSwapVisualization(indices, type) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Swap Elements Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalArrayOp"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrows-alt-h"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After Swap Operation</div>
            <div class="transformed-array-container" id="transformedArrayOp"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Swap Operation:</strong> Swapping ${indices.length} elements</p>
            <p class="mb-0" id="swapExplanation">Starting swap operation...</p>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSwap" style="display: none;">
            <i class="fas fa-play me-1"></i>Continue with Swapped Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSwap, 'originalArrayOp');
    renderArrayInContainer([...originalArrayForSwap], 'transformedArrayOp');
    
    performSwapAnimation(indices);
}

// NEW: Perform Swap Animation
function performSwapAnimation(indices) {
    const originalContainer = document.getElementById('originalArrayOp');
    const transformedContainer = document.getElementById('transformedArrayOp');
    const explanation = document.getElementById('swapExplanation');
    const continueButton = document.getElementById('continueAfterSwap');
    
    const array = [...originalArrayForSwap];
    const n = indices.length;
    
    // Perform circular swap
    function performSwapStep(step) {
        if (step >= n) {
            // Swap operation completed
            explanation.innerHTML = `<strong>Swap Operation Completed!</strong> Successfully swapped ${n} elements`;
            
            continueButton.style.display = 'block';
            const autoProceedTimer = setTimeout(() => {
                proceedWithSwappedArray(indices);
            }, 3000);
            
            continueButton.addEventListener('click', () => {
                clearTimeout(autoProceedTimer);
                proceedWithSwappedArray(indices);
            });
            
            return;
        }
        
        const currentIndex = indices[step];
        const nextIndex = indices[(step + 1) % n];
        
        // Update explanation
        explanation.innerHTML = `Swapping index ${currentIndex} ("${array[currentIndex]}") with index ${nextIndex} ("${array[nextIndex]}")`;
        
        // Highlight elements being swapped
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentIndex].querySelector('.element-value');
        const nextElement = originalElements[nextIndex].querySelector('.element-value');
        
        currentElement.classList.add('reverse-highlight');
        nextElement.classList.add('reverse-highlight');
        
        // Calculate swap distance for animation
        const currentRect = originalElements[currentIndex].getBoundingClientRect();
        const nextRect = originalElements[nextIndex].getBoundingClientRect();
        const swapDistance = nextRect.left - currentRect.left;
        
        currentElement.style.setProperty('--swap-distance', `${swapDistance}px`);
        nextElement.style.setProperty('--swap-distance', `-${swapDistance}px`);
        
        // Perform swap animation
        setTimeout(() => {
            currentElement.classList.add('swap-animation');
            nextElement.classList.add('swap-animation');
            
            // After animation, update the array
            setTimeout(() => {
                // Swap the elements
                [array[currentIndex], array[nextIndex]] = [array[nextIndex], array[currentIndex]];
                
                // Update transformed array display
                renderArrayInContainer(array, 'transformedArrayOp');
                
                // Remove highlights
                currentElement.classList.remove('reverse-highlight', 'swap-animation');
                nextElement.classList.remove('reverse-highlight', 'swap-animation');
                
                // Move to next step
                performSwapStep(step + 1);
            }, 1000);
        }, 500);
    }
    
    // Start swap operation
    performSwapStep(0);
}

// NEW: Proceed with Swapped Array
function proceedWithSwappedArray(indices) {
    // Apply the swap operation to the actual array
    const n = indices.length;
    const tempArray = [...myArray];
    
    // Perform circular swap
    for (let i = 0; i < n - 1; i++) {
        [tempArray[indices[i]], tempArray[indices[i + 1]]] = [tempArray[indices[i + 1]], tempArray[indices[i]]];
    }
    
    myArray = tempArray;
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Clear swap inputs
    swapCount.value = '';
    swapIndicesCount.value = '';
    swapValuesInputs.innerHTML = '';
    swapIndicesInputs.innerHTML = '';
    swapByValuesGroup.style.display = 'none';
    swapByIndicesGroup.style.display = 'none';
    
    logOperation(`Swapped ${indices.length} elements at indices: ${indices.join(', ')}`, 'warning');
    showNotification('Elements swapped successfully', 'success');
    
    // Auto-reset after 8 seconds
    setTimeout(() => {
        resetAfterSwapOperation();
    }, 8000);
}

// NEW: Reset after Swap Operation
function resetAfterSwapOperation() {
    if (!isSwapOperation || originalArrayForSwap.length === 0) {
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayForSwap];
    originalArrayForSwap = [];
    isSwapOperation = false;
    
    renderArray();
    updateStats();
    
    logOperation('Reset to original array after swap operation', 'info');
    showNotification('Automatically reset to original array', 'info');
}
// NEW: Two-Pointer Traversal Handler
function handleTwoPointerTraversal() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isTwoPointerRunning) {
        showNotification('Two-pointer traversal is already in progress', 'warning');
        return;
    }
    
    if (myArray.length < 2) {
        showNotification('Array must have at least 2 elements for two-pointer traversal', 'warning');
        return;
    }
    
    isTwoPointerRunning = true;
    twoPointerTraverseBtn.disabled = true;
    
    // Reset all elements first
    const elements = document.querySelectorAll('.array-element');
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('two-pointer-left', 'two-pointer-right', 'two-pointer-meet');
    });
    
    // Initialize pointers
    twoPointerLeft = 0;
    twoPointerRight = myArray.length - 1;
    
    // Update search results
    searchResults.innerHTML = `
        <div class="two-pointer-explanation">
            <p class="mb-1"><strong>Two-Pointer Traversal Started</strong></p>
            <p class="mb-1">Left Pointer: Index ${twoPointerLeft} | Right Pointer: Index ${twoPointerRight}</p>
            <p class="mb-0">Algorithm: Move pointers towards center until they meet</p>
        </div>
    `;
    
    // Start two-pointer traversal
    performTwoPointerTraversal();
}

// NEW: Perform Two-Pointer Traversal
function performTwoPointerTraversal() {
    if (twoPointerLeft > twoPointerRight || !isTwoPointerRunning) {
        // Traversal completed
        resetTwoPointerState();
        logOperation('Two-pointer traversal completed', 'success');
        showNotification('Two-pointer traversal completed', 'success');
        return;
    }
    
    const elements = document.querySelectorAll('.array-element');
    
    // Reset previous highlights
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('two-pointer-left', 'two-pointer-right', 'two-pointer-meet');
    });
    
    // Check if pointers meet
    if (twoPointerLeft === twoPointerRight) {
        // Pointers meet at center
        const centerElement = elements[twoPointerLeft];
        const centerValueDiv = centerElement.querySelector('.element-value');
        centerValueDiv.classList.add('two-pointer-meet');
        
        searchResults.innerHTML = `
            <div class="two-pointer-explanation">
                <p class="mb-1"><strong>Pointers Met at Center!</strong></p>
                <p class="mb-1">Meeting Point: Index ${twoPointerLeft}</p>
                <p class="mb-1">Value: "${myArray[twoPointerLeft]}"</p>
                <p class="mb-0">Traversal completed successfully</p>
            </div>
        `;
        
        // Move to next step after delay
        setTimeout(() => {
            twoPointerLeft++;
            twoPointerRight--;
            performTwoPointerTraversal();
        }, 1500);
        
        return;
    }
    
    // Highlight current pointers
    const leftElement = elements[twoPointerLeft];
    const rightElement = elements[twoPointerRight];
    const leftValueDiv = leftElement.querySelector('.element-value');
    const rightValueDiv = rightElement.querySelector('.element-value');
    
    leftValueDiv.classList.add('two-pointer-left');
    rightValueDiv.classList.add('two-pointer-right');
    
    // Update search results
    searchResults.innerHTML = `
        <div class="two-pointer-explanation">
            <p class="mb-1"><strong>Two-Pointer Traversal in Progress</strong></p>
            <p class="mb-1">Left Pointer: Index ${twoPointerLeft} | Value: "${myArray[twoPointerLeft]}"</p>
            <p class="mb-1">Right Pointer: Index ${twoPointerRight} | Value: "${myArray[twoPointerRight]}"</p>
            <p class="mb-0">Distance between pointers: ${twoPointerRight - twoPointerLeft}</p>
        </div>
    `;
    
    // Move pointers after delay
    setTimeout(() => {
        twoPointerLeft++;
        twoPointerRight--;
        performTwoPointerTraversal();
    }, 1000);
}

// NEW: Reset Two-Pointer State
function resetTwoPointerState() {
    isTwoPointerRunning = false;
    twoPointerTraverseBtn.disabled = false;
    twoPointerLeft = 0;
    twoPointerRight = 0;
    
    // Reset all two-pointer highlights
    const elements = document.querySelectorAll('.array-element');
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('two-pointer-left', 'two-pointer-right', 'two-pointer-meet');
    });
    
    // Clear search results after a short delay
    setTimeout(() => {
        searchResults.innerHTML = '<p class="text-center mb-0">Two-pointer traversal completed</p>';
    }, 3000);
}
// NEW: Sort Array Handler
function handleSort(order) {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - already sorted', 'info');
        return;
    }
    
    if (isSortingRunning) {
        showNotification('A sorting operation is already in progress', 'warning');
        return;
    }
    
    isSortingRunning = true;
    sortAscBtn.disabled = true;
    sortDescBtn.disabled = true;
    
    // Store original array
    originalArrayForSort = [...myArray];
    
    // Show sorting visualization
    showSortingVisualization(order);
}
// NEW: Show Sorting Visualization
function showSortingVisualization(order) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Sort Array ${order === 'asc' ? 'Ascending' : 'Descending'}</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalArrayOp"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Sorted Array</div>
            <div class="transformed-array-container" id="transformedArrayOp"></div>
        </div>
        
        <div class="sorting-explanation">
            <p class="mb-2"><strong>Sorting Algorithm:</strong> Bubble Sort (Step-by-Step)</p>
            <p class="mb-0" id="sortExplanation">Starting ${order === 'asc' ? 'ascending' : 'descending'} sort...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="algorithmStepsContainer">
            <h6 class="text-center">Sorting Steps</h6>
            <div class="steps-container" id="sortStepsContainer"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSort" style="display: none;">
            <i class="fas fa-play me-1"></i>Continue with Sorted Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSort, 'originalArrayOp');
    renderArrayInContainer([...originalArrayForSort], 'transformedArrayOp');
    
    performSortingAnimation(order);
}
// NEW: Perform Sorting Animation (Bubble Sort)
function performSortingAnimation(order) {
    const originalContainer = document.getElementById('originalArrayOp');
    const transformedContainer = document.getElementById('transformedArrayOp');
    const explanation = document.getElementById('sortExplanation');
    const stepsContainer = document.getElementById('sortStepsContainer');
    const continueButton = document.getElementById('continueAfterSort');
    
    const array = [...originalArrayForSort];
    const n = array.length;
    let sortedArray = [...array];
    let currentPass = 1;
    let currentComparison = 0;
    let totalSwaps = 0;
    
    // Convert to numbers for comparison if possible
    const isNumeric = !array.some(item => isNaN(parseFloat(item)));
    
    function performSortStep() {
        if (currentPass > n - 1) {
            // Sorting completed
            explanation.innerHTML = `<strong>Sorting Completed!</strong> Array sorted in ${order === 'asc' ? 'ascending' : 'descending'} order. Total passes: ${n-1}, Total swaps: ${totalSwaps}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Sorting completed! Array is now sorted.
                </div>
            `;
            
            // Highlight all elements as sorted
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                const valueDiv = el.querySelector('.element-value');
                setTimeout(() => {
                    valueDiv.classList.add('sorting-sorted');
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            const autoProceedTimer = setTimeout(() => {
                proceedWithSortedArray(order, sortedArray);
            }, 3000);
            
            continueButton.addEventListener('click', () => {
                clearTimeout(autoProceedTimer);
                proceedWithSortedArray(order, sortedArray);
            });
            
            return;
        }
        
        if (currentComparison >= n - currentPass) {
            // Pass completed
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Pass ${currentPass} Complete:</strong> Largest ${order === 'asc' ? '' : 'smallest'} element bubbled to position ${n - currentPass}
                </div>
            `;
            
            // Highlight the last sorted element
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const sortedElement = transformedElements[n - currentPass].querySelector('.element-value');
            sortedElement.classList.add('sorting-sorted');
            
            currentPass++;
            currentComparison = 0;
            performSortStep();
            return;
        }
        
        const i = currentComparison;
        const j = i + 1;
        
        // Update explanation
        explanation.innerHTML = `Pass ${currentPass}: Comparing elements at indices ${i} and ${j}`;
        
        // Highlight elements being compared
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const elementI = originalElements[i].querySelector('.element-value');
        const elementJ = originalElements[j].querySelector('.element-value');
        
        elementI.classList.add('sorting-current');
        elementJ.classList.add('sorting-compared');
        
        // Compare values
        let shouldSwap = false;
        if (isNumeric) {
            const valI = parseFloat(sortedArray[i]);
            const valJ = parseFloat(sortedArray[j]);
            shouldSwap = order === 'asc' ? valI > valJ : valI < valJ;
        } else {
            shouldSwap = order === 'asc' ? sortedArray[i] > sortedArray[j] : sortedArray[i] < sortedArray[j];
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${shouldSwap ? 'active' : ''}">
                <strong>Step:</strong> Compare [${i}]="${sortedArray[i]}" and [${j}]="${sortedArray[j]}" - 
                ${shouldSwap ? 'SWAP needed' : 'No swap needed'}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            if (shouldSwap) {
                // Perform swap
                explanation.innerHTML = `Pass ${currentPass}: Swapping elements at indices ${i} and ${j}`;
                
                elementI.classList.remove('sorting-current');
                elementJ.classList.remove('sorting-compared');
                elementI.classList.add('sorting-swap');
                elementJ.classList.add('sorting-swap');
                
                // Calculate swap distance for animation
                const rectI = originalElements[i].getBoundingClientRect();
                const rectJ = originalElements[j].getBoundingClientRect();
                const swapDistance = rectJ.left - rectI.left;
                
                elementI.style.setProperty('--swap-distance', `${swapDistance}px`);
                elementJ.style.setProperty('--swap-distance', `-${swapDistance}px`);
                
                setTimeout(() => {
                    elementI.classList.add('swap-animation');
                    elementJ.classList.add('swap-animation');
                    
                    setTimeout(() => {
                        // Swap the elements
                        [sortedArray[i], sortedArray[j]] = [sortedArray[j], sortedArray[i]];
                        totalSwaps++;
                        
                        // Update transformed array display
                        renderArrayInContainer(sortedArray, 'transformedArrayOp');
                        
                        // Remove highlights
                        elementI.classList.remove('sorting-swap', 'swap-animation');
                        elementJ.classList.remove('sorting-swap', 'swap-animation');
                        
                        currentComparison++;
                        performSortStep();
                    }, 1000);
                }, 500);
            } else {
                // No swap needed
                elementI.classList.remove('sorting-current');
                elementJ.classList.remove('sorting-compared');
                
                currentComparison++;
                performSortStep();
            }
        }, 1500);
    }
    
    // Start sorting process
    performSortStep();
}
// NEW: Proceed with Sorted Array
function proceedWithSortedArray(order, sortedArray) {
    // Apply the sorted array
    myArray = sortedArray;
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    logOperation(`Array sorted in ${order === 'asc' ? 'ascending' : 'descending'} order`, 'success');
    showNotification(`Array sorted in ${order === 'asc' ? 'ascending' : 'descending'} order successfully`, 'success');
    
    // Reset sorting state
    isSortingRunning = false;
    sortAscBtn.disabled = false;
    sortDescBtn.disabled = false;
    
    // Auto-reset after 10 seconds
    setTimeout(() => {
        resetAfterSortOperation();
    }, 10000);
}

// NEW: Reset after Sort Operation
function resetAfterSortOperation() {
    if (originalArrayForSort.length === 0) {
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayForSort];
    originalArrayForSort = [];
    
    renderArray();
    updateStats();
    
    logOperation('Reset to original array after sorting', 'info');
    showNotification('Automatically reset to original array', 'info');
}
// NEW: Check if Array is Sorted Handler
function handleCheckSorted() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isValidationRunning) {
        showNotification('A validation operation is already in progress', 'warning');
        return;
    }
    
    isValidationRunning = true;
    checkSortedBtn.disabled = true;
    
    // Reset all elements first
    const elements = document.querySelectorAll('.array-element');
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('sorted-correct', 'sorted-incorrect');
    });
    
    // Check if array is sorted and show visualization
    checkArraySorted();
}

// NEW: Partial Sort Handler
function handlePartialSort() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isPartialSortRunning) {
        showNotification('A partial sort operation is already in progress', 'warning');
        return;
    }
    
    // Show input for number of elements
    partialSortInputGroup.style.display = 'flex';
    partialSortCount.placeholder = `Enter K (1 to ${myArray.length})`;
    partialSortCount.max = myArray.length;
    partialSortCount.focus();
}

// NEW: Confirm Partial Sort Handler
function handleConfirmPartialSort() {
    const k = parseInt(partialSortCount.value);
    
    if (isNaN(k) || k < 1 || k > myArray.length) {
        showNotification(`Please enter a valid number between 1 and ${myArray.length}`, 'danger');
        partialSortCount.focus();
        return;
    }
    
    // Hide input group
    partialSortInputGroup.style.display = 'none';
    partialSortCount.value = '';
    
    // Store original array
    originalArrayForPartialSort = [...myArray];
    
    // Perform partial sort visualization
    performPartialSort(k);
}

// NEW: Cancel Partial Sort Handler
function handleCancelPartialSort() {
    partialSortInputGroup.style.display = 'none';
    partialSortCount.value = '';
}
// NEW: Check Array Sorted with Visualization
function checkArraySorted() {
    const elements = document.querySelectorAll('.array-element');
    let isAscending = true;
    let isDescending = true;
    const incorrectPairs = [];
    
    // Check ascending order
    for (let i = 1; i < myArray.length; i++) {
        const prev = parseFloat(myArray[i-1]);
        const curr = parseFloat(myArray[i]);
        
        // Try numeric comparison first
        if (!isNaN(prev) && !isNaN(curr)) {
            if (prev > curr) {
                isAscending = false;
                incorrectPairs.push({index1: i-1, index2: i, reason: `Number ${prev} > ${curr}`});
            }
        } else {
            // String comparison
            if (myArray[i-1] > myArray[i]) {
                isAscending = false;
                incorrectPairs.push({index1: i-1, index2: i, reason: `String "${myArray[i-1]}" > "${myArray[i]}"`});
            }
        }
    }
    
    // Check descending order
    for (let i = 1; i < myArray.length; i++) {
        const prev = parseFloat(myArray[i-1]);
        const curr = parseFloat(myArray[i]);
        
        // Try numeric comparison first
        if (!isNaN(prev) && !isNaN(curr)) {
            if (prev < curr) {
                isDescending = false;
            }
        } else {
            // String comparison
            if (myArray[i-1] < myArray[i]) {
                isDescending = false;
            }
        }
    }
    
    // Show validation visualization
    showSortedValidation(isAscending, isDescending, incorrectPairs);
}

// NEW: Show Sorted Validation with Animation
function showSortedValidation(isAscending, isDescending, incorrectPairs) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    
    let resultMessage = '';
    let resultType = '';
    
    if (isAscending) {
        resultMessage = 'Array is sorted in ASCENDING order';
        resultType = 'success';
    } else if (isDescending) {
        resultMessage = 'Array is sorted in DESCENDING order';
        resultType = 'success';
    } else {
        resultMessage = 'Array is NOT sorted';
        resultType = 'danger';
    }
    
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Array Sorting Validation</h5>
        
        <div class="array-group">
            <div class="array-label">Array to Validate</div>
            <div class="original-array-container" id="validationArray"></div>
        </div>
        
        <div class="validation-explanation">
            <p class="mb-2"><strong>Validation Result:</strong> ${resultMessage}</p>
            <p class="mb-0" id="validationExplanation">Starting validation check...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="validationStepsContainer">
            <h6 class="text-center">Validation Steps</h6>
            <div class="steps-container" id="validationSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterValidation">
            <i class="fas fa-play me-1"></i>Continue
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(myArray, 'validationArray');
    
    performValidationAnimation(isAscending, isDescending, incorrectPairs, resultMessage);
}

// NEW: Perform Validation Animation
function performValidationAnimation(isAscending, isDescending, incorrectPairs, resultMessage) {
    const validationContainer = document.getElementById('validationArray');
    const explanation = document.getElementById('validationExplanation');
    const stepsContainer = document.getElementById('validationSteps');
    const continueButton = document.getElementById('continueAfterValidation');
    
    const elements = validationContainer.querySelectorAll('.array-element');
    let currentStep = 0;
    
    function performValidationStep() {
        if (currentStep >= myArray.length - 1) {
            // Validation completed
            explanation.innerHTML = `<strong>Validation Complete!</strong> ${resultMessage}`;
            
            // Highlight final result
            if (isAscending || isDescending) {
                // All elements are sorted - highlight all green
                elements.forEach((el, index) => {
                    const valueDiv = el.querySelector('.element-value');
                    setTimeout(() => {
                        valueDiv.classList.add('sorted-correct');
                    }, index * 200);
                });
            } else {
                // Highlight incorrect pairs in red
                incorrectPairs.forEach(pair => {
                    const valueDiv1 = elements[pair.index1].querySelector('.element-value');
                    const valueDiv2 = elements[pair.index2].querySelector('.element-value');
                    valueDiv1.classList.add('sorted-incorrect');
                    valueDiv2.classList.add('sorted-incorrect');
                });
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> ${resultMessage}
                </div>
            `;
            
            continueButton.style.display = 'block';
            continueButton.addEventListener('click', resetAfterValidation);
            
            return;
        }
        
        const i = currentStep;
        const j = i + 1;
        
        // Update explanation
        explanation.innerHTML = `Checking elements at indices ${i} and ${j}: "${myArray[i]}" and "${myArray[j]}"`;
        
        // Highlight elements being compared
        const elementI = elements[i].querySelector('.element-value');
        const elementJ = elements[j].querySelector('.element-value');
        
        elementI.classList.add('sorting-current');
        elementJ.classList.add('sorting-compared');
        
        // Check if this pair is incorrect
        const isIncorrect = incorrectPairs.some(pair => 
            (pair.index1 === i && pair.index2 === j) || 
            (pair.index1 === j && pair.index2 === i)
        );
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${isIncorrect ? 'active' : ''}">
                <strong>Step ${currentStep + 1}:</strong> Compare [${i}]="${myArray[i]}" and [${j}]="${myArray[j]}" - 
                ${isIncorrect ? 'NOT in order' : 'in correct order'}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            if (isIncorrect) {
                // Mark as incorrect
                elementI.classList.remove('sorting-current', 'sorting-compared');
                elementI.classList.add('sorted-incorrect');
                elementJ.classList.add('sorted-incorrect');
            } else {
                // Mark as correct
                elementI.classList.remove('sorting-current', 'sorting-compared');
                elementI.classList.add('sorted-correct');
                elementJ.classList.add('sorted-correct');
            }
            
            currentStep++;
            performValidationStep();
        }, 1500);
    }
    
    // Start validation process
    performValidationStep();
}

// NEW: Reset after Validation
function resetAfterValidation() {
    isValidationRunning = false;
    checkSortedBtn.disabled = false;
    
    // Remove validation visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    
    logOperation('Array sorting validation completed', 'info');
}

// NEW: Perform Partial Sort
function performPartialSort(k) {
    if (isPartialSortRunning) {
        showNotification('A partial sort operation is already in progress', 'warning');
        return;
    }
    
    isPartialSortRunning = true;
    partialSortBtn.disabled = true;
    
    // Show partial sort visualization
    showPartialSortVisualization(k);
}

// NEW: Show Partial Sort Visualization
function showPartialSortVisualization(k) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Partial Sort - First ${k} Elements</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalPartialArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After Partial Sort</div>
            <div class="transformed-array-container" id="transformedPartialArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Partial Sort:</strong> Sorting first ${k} elements in ascending order</p>
            <p class="mb-0" id="partialSortExplanation">Starting partial sort...</p>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPartialSort" style="display: none;">
            <i class="fas fa-play me-1"></i>Continue with Partially Sorted Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForPartialSort, 'originalPartialArray');
    renderArrayInContainer([...originalArrayForPartialSort], 'transformedPartialArray');
    
    performPartialSortAnimation(k);
}

// NEW: Perform Partial Sort Animation
function performPartialSortAnimation(k) {
    const originalContainer = document.getElementById('originalPartialArray');
    const transformedContainer = document.getElementById('transformedPartialArray');
    const explanation = document.getElementById('partialSortExplanation');
    const continueButton = document.getElementById('continueAfterPartialSort');
    
    const array = [...originalArrayForPartialSort];
    let sortedArray = [...array];
    
    // Perform selection sort on first k elements
    function performPartialSortStep(i) {
        if (i >= k) {
            // Partial sort completed
            explanation.innerHTML = `<strong>Partial Sort Completed!</strong> First ${k} elements are now sorted`;
            
            // Highlight the sorted portion
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            for (let j = 0; j < k; j++) {
                const valueDiv = transformedElements[j].querySelector('.element-value');
                valueDiv.classList.add('partial-sorted');
            }
            
            continueButton.style.display = 'block';
            const autoProceedTimer = setTimeout(() => {
                proceedWithPartialSort(sortedArray);
            }, 3000);
            
            continueButton.addEventListener('click', () => {
                clearTimeout(autoProceedTimer);
                proceedWithPartialSort(sortedArray);
            });
            
            return;
        }
        
        // Find minimum in the remaining unsorted portion (within first k elements)
        let minIndex = i;
        
        explanation.innerHTML = `Finding minimum in remaining unsorted portion (indices ${i} to ${k-1})`;
        
        // Highlight current search for minimum
        const originalElements = originalContainer.querySelectorAll('.array-element');
        for (let j = i; j < k; j++) {
            setTimeout(() => {
                const valueDiv = originalElements[j].querySelector('.element-value');
                valueDiv.classList.add('sorting-compared');
                
                if (j === i) {
                    valueDiv.classList.add('sorting-current');
                }
            }, (j - i) * 300);
        }
        
        setTimeout(() => {
            // Actually find the minimum
            for (let j = i + 1; j < k; j++) {
                const currentVal = parseFloat(sortedArray[j]);
                const minVal = parseFloat(sortedArray[minIndex]);
                
                if (!isNaN(currentVal) && !isNaN(minVal)) {
                    if (currentVal < minVal) minIndex = j;
                } else {
                    if (sortedArray[j] < sortedArray[minIndex]) minIndex = j;
                }
            }
            
            // Swap if needed
            if (minIndex !== i) {
                explanation.innerHTML = `Swapping elements at indices ${i} and ${minIndex}`;
                
                // Highlight the swap
                const valueDivI = originalElements[i].querySelector('.element-value');
                const valueDivMin = originalElements[minIndex].querySelector('.element-value');
                
                valueDivI.classList.remove('sorting-current');
                valueDivMin.classList.remove('sorting-compared');
                valueDivI.classList.add('sorting-swap');
                valueDivMin.classList.add('sorting-swap');
                
                // Perform swap
                [sortedArray[i], sortedArray[minIndex]] = [sortedArray[minIndex], sortedArray[i]];
                
                // Update transformed array
                renderArrayInContainer(sortedArray, 'transformedPartialArray');
                
                // Remove highlights and move to next step
                setTimeout(() => {
                    valueDivI.classList.remove('sorting-swap');
                    valueDivMin.classList.remove('sorting-swap');
                    performPartialSortStep(i + 1);
                }, 1000);
            } else {
                // No swap needed, move to next step
                explanation.innerHTML = `No swap needed - element at index ${i} is already the minimum`;
                
                // Remove highlights
                for (let j = i; j < k; j++) {
                    const valueDiv = originalElements[j].querySelector('.element-value');
                    valueDiv.classList.remove('sorting-current', 'sorting-compared', 'sorting-swap');
                }
                
                performPartialSortStep(i + 1);
            }
        }, (k - i) * 300 + 500);
    }
    
    // Start partial sort process
    performPartialSortStep(0);
}

// NEW: Proceed with Partial Sort
function proceedWithPartialSort(sortedArray) {
    // Apply the partial sort to the actual array
    myArray = sortedArray;
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isPartialSortRunning = false;
    partialSortBtn.disabled = false;
    
    logOperation(`Partially sorted first ${originalArrayForPartialSort.length} elements`, 'success');
    showNotification(`Partially sorted first ${originalArrayForPartialSort.length} elements successfully`, 'success');
    
    // Auto-reset after 10 seconds
    setTimeout(() => {
        resetAfterPartialSort();
    }, 10000);
}

// NEW: Reset after Partial Sort
function resetAfterPartialSort() {
    if (originalArrayForPartialSort.length === 0) {
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayForPartialSort];
    originalArrayForPartialSort = [];
    
    renderArray();
    updateStats();
    
    logOperation('Reset to original array after partial sort', 'info');
    showNotification('Automatically reset to original array', 'info');
}
// NEW: Fixed-size Sliding Window Handler
function handleFixedWindow() {
    const k = parseInt(fixedWindowSize.value);
    
    if (isNaN(k) || k < 1 || k > myArray.length) {
        showNotification(`Please enter a valid window size between 1 and ${myArray.length}`, 'danger');
        fixedWindowSize.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Sliding window operations require all array elements to be numbers', 'danger');
        return;
    }
    
    if (isWindowOperationRunning) {
        showNotification('A window operation is already in progress', 'warning');
        return;
    }
    
    isWindowOperationRunning = true;
    
    // Store original array
    originalArrayForWindow = [...myArray];
    
    // Perform fixed window visualization
    performFixedWindowVisualization(k);
}

// NEW: Variable-size Sliding Window Handler
function handleVariableWindow() {
    const targetSum = parseFloat(variableWindowSum.value);
    
    if (isNaN(targetSum)) {
        showNotification('Please enter a valid target sum', 'danger');
        variableWindowSum.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Sliding window operations require all array elements to be numbers', 'danger');
        return;
    }
    
    if (isWindowOperationRunning) {
        showNotification('A window operation is already in progress', 'warning');
        return;
    }
    
    isWindowOperationRunning = true;
    
    // Store original array
    originalArrayForWindow = [...myArray];
    
    // Perform variable window visualization
    performVariableWindowVisualization(targetSum);
}
// NEW: Perform Fixed Window Visualization
function performFixedWindowVisualization(k) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Fixed-size Sliding Window (k = ${k})</h5>
        
        <div class="array-group">
            <div class="array-label">Array</div>
            <div class="original-array-container" id="windowArray"></div>
        </div>
        
        <div class="window-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find maximum sum of any contiguous subarray of length ${k}</p>
            <p class="mb-0" id="windowExplanation">Initializing sliding window...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="windowStepsContainer">
            <h6 class="text-center">Sliding Window Steps</h6>
            <div class="steps-container" id="windowSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Maximum Sum Found</div>
            <div class="stats-value" id="maxSumValue">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterWindow" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForWindow, 'windowArray');
    
    executeFixedWindowAlgorithm(k);
}

// NEW: Execute Fixed Window Algorithm with Animation
function executeFixedWindowAlgorithm(k) {
    const arrayContainer = document.getElementById('windowArray');
    const explanation = document.getElementById('windowExplanation');
    const stepsContainer = document.getElementById('windowSteps');
    const maxSumValue = document.getElementById('maxSumValue');
    const continueButton = document.getElementById('continueAfterWindow');
    
    const arr = originalArrayForWindow.map(val => parseFloat(val));
    let maxSum = 0;
    let currentSum = 0;
    let maxStart = 0;
    let step = 0;
    
    function executeStep() {
        if (step === 0) {
            // Step 1: Calculate first window
            explanation.innerHTML = `Calculating sum of first window (indices 0 to ${k-1})`;
            
            for (let i = 0; i < k; i++) {
                setTimeout(() => {
                    const elements = arrayContainer.querySelectorAll('.array-element');
                    const valueDiv = elements[i].querySelector('.element-value');
                    valueDiv.classList.add('window-included');
                }, i * 300);
            }
            
            setTimeout(() => {
                for (let i = 0; i < k; i++) {
                    currentSum += arr[i];
                }
                maxSum = currentSum;
                maxStart = 0;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> First window sum = ${currentSum} (indices 0-${k-1})
                    </div>
                `;
                
                maxSumValue.textContent = maxSum;
                step++;
                executeStep();
            }, k * 300 + 500);
            
        } else if (step <= arr.length - k) {
            const i = step + k - 1; // Current right pointer
            
            explanation.innerHTML = `Sliding window: Removing [${i-k}]=${arr[i-k]}, Adding [${i}]=${arr[i]}`;
            
            // Highlight the elements being swapped in the window
            const elements = arrayContainer.querySelectorAll('.array-element');
            
            // Remove left element highlight
            const leftElement = elements[i - k].querySelector('.element-value');
            leftElement.classList.remove('window-included');
            leftElement.classList.add('window-left');
            
            // Add right element highlight
            const rightElement = elements[i].querySelector('.element-value');
            rightElement.classList.add('window-right');
            
            setTimeout(() => {
                // Update sum
                currentSum += arr[i] - arr[i - k];
                
                // Remove temporary highlights
                leftElement.classList.remove('window-left');
                rightElement.classList.remove('window-right');
                rightElement.classList.add('window-included');
                
                // Update all window elements
                for (let j = i - k + 1; j <= i; j++) {
                    elements[j].querySelector('.element-value').classList.add('window-included');
                }
                
                // Check if this is new maximum
                if (currentSum > maxSum) {
                    maxSum = currentSum;
                    maxStart = i - k + 1;
                    
                    // Highlight the new maximum window
                    for (let j = maxStart; j < maxStart + k; j++) {
                        elements[j].querySelector('.element-value').classList.add('window-max');
                    }
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step + 1}:</strong> New max sum = ${maxSum} (indices ${maxStart}-${maxStart + k - 1})
                        </div>
                    `;
                } else {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step + 1}:</strong> Current sum = ${currentSum}, Max sum = ${maxSum}
                        </div>
                    `;
                }
                
                maxSumValue.textContent = maxSum;
                step++;
                executeStep();
            }, 1000);
            
        } else {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Maximum sum = ${maxSum} in window [${maxStart}-${maxStart + k - 1}]`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Maximum sum of any ${k}-length subarray = ${maxSum}
                </div>
            `;
            
            // Highlight the final maximum window
            const elements = arrayContainer.querySelectorAll('.array-element');
            for (let j = maxStart; j < maxStart + k; j++) {
                elements[j].querySelector('.element-value').classList.add('window-max');
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterWindow();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterWindow);
        }
    }
    
    // Start execution
    executeStep();
}

// NEW: Perform Variable Window Visualization
function performVariableWindowVisualization(targetSum) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Variable-size Sliding Window (Sum  ${targetSum})</h5>
        
        <div class="array-group">
            <div class="array-label">Array</div>
            <div class="original-array-container" id="varWindowArray"></div>
        </div>
        
        <div class="window-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find longest subarray with sum  ${targetSum}</p>
            <p class="mb-0" id="varWindowExplanation">Initializing sliding window...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="varWindowStepsContainer">
            <h6 class="text-center">Sliding Window Steps</h6>
            <div class="steps-container" id="varWindowSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Longest Subarray Length</div>
            <div class="stats-value" id="longestLengthValue">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterVarWindow" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForWindow, 'varWindowArray');
    
    executeVariableWindowAlgorithm(targetSum);
}

// NEW: Execute Variable Window Algorithm with Animation
function executeVariableWindowAlgorithm(targetSum) {
    const arrayContainer = document.getElementById('varWindowArray');
    const explanation = document.getElementById('varWindowExplanation');
    const stepsContainer = document.getElementById('varWindowSteps');
    const longestLengthValue = document.getElementById('longestLengthValue');
    const continueButton = document.getElementById('continueAfterVarWindow');
    
    const arr = originalArrayForWindow.map(val => parseFloat(val));
    let left = 0;
    let currentSum = 0;
    let maxLength = 0;
    let maxStart = 0;
    let step = 0;
    
    function executeStep(right) {
        if (right >= arr.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Longest subarray length = ${maxLength}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Longest subarray with sum  ${targetSum} has length = ${maxLength}
                </div>
            `;
            
            // Highlight the final longest subarray
            const elements = arrayContainer.querySelectorAll('.array-element');
            for (let j = maxStart; j < maxStart + maxLength; j++) {
                elements[j].querySelector('.element-value').classList.add('window-max');
            }
            
            longestLengthValue.textContent = maxLength;
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterWindow();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterWindow);
            
            return;
        }
        
        // Add current element to window
        explanation.innerHTML = `Adding element [${right}]=${arr[right]} to window`;
        
        const elements = arrayContainer.querySelectorAll('.array-element');
        const rightElement = elements[right].querySelector('.element-value');
        rightElement.classList.add('window-right');
        
        setTimeout(() => {
            currentSum += arr[right];
            rightElement.classList.remove('window-right');
            rightElement.classList.add('window-included');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step + 1}:</strong> Added [${right}]=${arr[right]}, Current sum = ${currentSum}
                </div>
            `;
            
            step++;
            
            // Shrink window from left if sum exceeds target
            if (currentSum > targetSum) {
                explanation.innerHTML = `Sum ${currentSum} > ${targetSum}, shrinking window from left`;
                
                const shrinkStep = () => {
                    if (currentSum > targetSum && left <= right) {
                        const leftElement = elements[left].querySelector('.element-value');
                        leftElement.classList.add('window-left');
                        
                        setTimeout(() => {
                            currentSum -= arr[left];
                            leftElement.classList.remove('window-left', 'window-included');
                            
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step">
                                    <strong>Step ${step + 1}:</strong> Removed [${left}]=${arr[left]}, New sum = ${currentSum}
                                </div>
                            `;
                            
                            step++;
                            left++;
                            shrinkStep();
                        }, 800);
                    } else {
                        // Continue with next right pointer
                        checkMaxLength(right);
                    }
                };
                
                shrinkStep();
            } else {
                checkMaxLength(right);
            }
            
            function checkMaxLength(right) {
                // Update max length if current window is valid and longer
                if (currentSum <= targetSum && (right - left + 1) > maxLength) {
                    maxLength = right - left + 1;
                    maxStart = left;
                    
                    // Highlight the new longest subarray
                    for (let j = maxStart; j <= right; j++) {
                        elements[j].querySelector('.element-value').classList.add('window-max');
                    }
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step + 1}:</strong> New longest subarray! Length = ${maxLength} (indices ${left}-${right})
                        </div>
                    `;
                }
                
                longestLengthValue.textContent = maxLength;
                
                // Move to next right pointer
                setTimeout(() => {
                    executeStep(right + 1);
                }, 1000);
            }
        }, 800);
    }
    
    // Start execution
    executeStep(0);
}

// NEW: Return to Original after Window Operations
function returnToOriginalAfterWindow() {
    // Reset to original array
    myArray = [...originalArrayForWindow];
    originalArrayForWindow = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isWindowOperationRunning = false;
    
    // Clear inputs
    fixedWindowSize.value = '';
    variableWindowSum.value = '';
    
    logOperation('Window operation completed - returned to original array', 'info');
    showNotification('Returned to original array after window operation', 'success');
}
// NEW: Two-Pointer Sort Handler
function handleTwoPointerSort() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isTwoPointerSortRunning) {
        showNotification('Two-pointer sort is already in progress', 'warning');
        return;
    }
    
    // Store original array
    originalArrayForTwoPointerSort = [...myArray];
    
    // Show two-pointer sort visualization
    showTwoPointerSortVisualization();
}

// NEW: Show Two-Pointer Sort Visualization
function showTwoPointerSortVisualization() {
    isTwoPointerSortRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Two-Pointer Sorting Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalTwoPointerArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Two-Pointer Sorting Process</div>
            <div class="transformed-array-container" id="transformedTwoPointerArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Two-Pointer Sorting:</strong> Using left and right pointers to sort the array efficiently</p>
            <p class="mb-0" id="twoPointerSortExplanation">Initializing two-pointer sort...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="twoPointerSortStepsContainer">
            <h6 class="text-center">Two-Pointer Sort Steps</h6>
            <div class="steps-container" id="twoPointerSortSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterTwoPointerSort" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForTwoPointerSort, 'originalTwoPointerArray');
    renderArrayInContainer([...originalArrayForTwoPointerSort], 'transformedTwoPointerArray');
    
    performTwoPointerSortAnimation();
}

// NEW: Perform Two-Pointer Sort Animation
function performTwoPointerSortAnimation() {
    const originalContainer = document.getElementById('originalTwoPointerArray');
    const transformedContainer = document.getElementById('transformedTwoPointerArray');
    const explanation = document.getElementById('twoPointerSortExplanation');
    const stepsContainer = document.getElementById('twoPointerSortSteps');
    const continueButton = document.getElementById('continueAfterTwoPointerSort');
    
    let array = [...originalArrayForTwoPointerSort];
    const n = array.length;
    let left = 0;
    let right = n - 1;
    let step = 0;
    let sorted = false;
    
    // Convert to numbers if possible for comparison
    const isNumeric = !array.some(item => isNaN(parseFloat(item)));
    
    function performSortStep() {
        if (left >= right) {
            // Sorting completed
            explanation.innerHTML = `<strong>Two-Pointer Sort Completed!</strong> Array is now sorted.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Array completely sorted using two-pointer approach
                </div>
            `;
            
            // Highlight all elements as sorted
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('two-pointer-sort-sorted');
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterTwoPointerSort();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterTwoPointerSort);
            
            return;
        }
        
        step++;
        explanation.innerHTML = `Step ${step}: Left pointer at ${left}, Right pointer at ${right}`;
        
        // Highlight current pointers
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        const leftElement = transformedElements[left].querySelector('.element-value');
        const rightElement = transformedElements[right].querySelector('.element-value');
        
        leftElement.classList.add('two-pointer-sort-left');
        rightElement.classList.add('two-pointer-sort-right');
        
        // Compare and potentially swap
        let leftVal = isNumeric ? parseFloat(array[left]) : array[left];
        let rightVal = isNumeric ? parseFloat(array[right]) : array[right];
        
        let shouldSwap = false;
        let comparison = '';
        
        if (isNumeric) {
            shouldSwap = leftVal > rightVal;
            comparison = `${leftVal} ${shouldSwap ? '>' : '<='} ${rightVal}`;
        } else {
            shouldSwap = array[left] > array[right];
            comparison = `"${array[left]}" ${shouldSwap ? '>' : '<='} "${array[right]}"`;
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${shouldSwap ? 'active' : ''}">
                <strong>Step ${step}:</strong> Compare [${left}]=${array[left]} and [${right}]=${array[right]} - 
                ${comparison} - ${shouldSwap ? 'SWAPPING' : 'No swap needed'}
            </div>
        `;
        
        setTimeout(() => {
            if (shouldSwap) {
                // Perform swap
                explanation.innerHTML = `Step ${step}: Swapping elements at indices ${left} and ${right}`;
                
                leftElement.classList.remove('two-pointer-sort-left');
                rightElement.classList.remove('two-pointer-sort-right');
                leftElement.classList.add('two-pointer-sort-swap');
                rightElement.classList.add('two-pointer-sort-swap');
                
                // Calculate swap distance for animation
                const rectLeft = transformedElements[left].getBoundingClientRect();
                const rectRight = transformedElements[right].getBoundingClientRect();
                const swapDistance = rectRight.left - rectLeft.left;
                
                leftElement.style.setProperty('--swap-distance', `${swapDistance}px`);
                rightElement.style.setProperty('--swap-distance', `-${swapDistance}px`);
                
                setTimeout(() => {
                    leftElement.classList.add('swap-animation');
                    rightElement.classList.add('swap-animation');
                    
                    setTimeout(() => {
                        // Swap the elements
                        [array[left], array[right]] = [array[right], array[left]];
                        
                        // Update transformed array display
                        renderArrayInContainer(array, 'transformedTwoPointerArray');
                        
                        // Remove highlights
                        leftElement.classList.remove('two-pointer-sort-swap', 'swap-animation');
                        rightElement.classList.remove('two-pointer-sort-swap', 'swap-animation');
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Swap ${step}:</strong> Elements swapped successfully
                            </div>
                        `;
                        
                        // Move pointers
                        left++;
                        right--;
                        
                        // Continue sorting
                        performSortStep();
                    }, 1000);
                }, 500);
            } else {
                // No swap needed
                leftElement.classList.remove('two-pointer-sort-left');
                rightElement.classList.remove('two-pointer-sort-right');
                
                // Move pointers based on values
                if (isNumeric) {
                    if (leftVal <= rightVal) {
                        left++;
                    } else {
                        right--;
                    }
                } else {
                    if (array[left] <= array[right]) {
                        left++;
                    } else {
                        right--;
                    }
                }
                
                performSortStep();
            }
        }, 1500);
    }
    
    // Start two-pointer sort process
    performSortStep();
}

// NEW: Return to Original after Two-Pointer Sort
function returnToOriginalAfterTwoPointerSort() {
    // Reset to original array
    myArray = [...originalArrayForTwoPointerSort];
    originalArrayForTwoPointerSort = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isTwoPointerSortRunning = false;
    
    logOperation('Two-pointer sort completed - returned to original array', 'info');
    showNotification('Returned to original array after two-pointer sort', 'success');
}
// NEW: Kadane's Algorithm Handler
function handleKadaneAlgorithm() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isKadaneAlgorithmRunning) {
        showNotification('Kadane\'s algorithm is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Kadane\'s algorithm requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForKadane = [...myArray];
    
    // Show Kadane's algorithm visualization
    showKadaneAlgorithmVisualization();
}

// NEW: Show Kadane's Algorithm Visualization
function showKadaneAlgorithmVisualization() {
    isKadaneAlgorithmRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Kadane's Algorithm - Maximum Subarray Sum</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalKadaneArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Kadane's Algorithm Process</div>
            <div class="transformed-array-container" id="transformedKadaneArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Kadane's Algorithm:</strong> Finding the contiguous subarray with maximum sum</p>
            <p class="mb-0" id="kadaneExplanation">Initializing Kadane's algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="kadaneStepsContainer">
            <h6 class="text-center">Kadane's Algorithm Steps</h6>
            <div class="steps-container" id="kadaneSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Maximum Subarray Sum</div>
            <div class="stats-value" id="maxSubarraySumValue">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Subarray Indices</div>
            <div class="stats-value" id="maxSubarrayIndices">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterKadane" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForKadane, 'originalKadaneArray');
    renderArrayInContainer([...originalArrayForKadane], 'transformedKadaneArray');
    
    performKadaneAlgorithmAnimation();
}

// NEW: Perform Kadane's Algorithm Animation
function performKadaneAlgorithmAnimation() {
    const originalContainer = document.getElementById('originalKadaneArray');
    const transformedContainer = document.getElementById('transformedKadaneArray');
    const explanation = document.getElementById('kadaneExplanation');
    const stepsContainer = document.getElementById('kadaneSteps');
    const maxSubarraySumValue = document.getElementById('maxSubarraySumValue');
    const maxSubarrayIndices = document.getElementById('maxSubarrayIndices');
    const continueButton = document.getElementById('continueAfterKadane');
    
    const arr = originalArrayForKadane.map(val => parseFloat(val));
    let maxEndingHere = arr[0];
    let maxSoFar = arr[0];
    let start = 0;
    let end = 0;
    let tempStart = 0;
    let step = 0;
    
    function performKadaneStep(i) {
        if (i >= arr.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Kadane's Algorithm Completed!</strong> Maximum subarray sum found.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Maximum subarray sum = ${maxSoFar} from indices ${start} to ${end}
                </div>
            `;
            
            // Highlight the maximum subarray
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            for (let j = start; j <= end; j++) {
                setTimeout(() => {
                    transformedElements[j].querySelector('.element-value').classList.add('kadane-max-subarray');
                }, (j - start) * 200);
            }
            
            maxSubarraySumValue.textContent = maxSoFar;
            maxSubarrayIndices.textContent = `${start} to ${end} ([${arr.slice(start, end + 1).join(', ')}])`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterKadane();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterKadane);
            
            return;
        }
        
        step++;
        
        if (i === 0) {
            // First element
            explanation.innerHTML = `Step ${step}: Initialize with first element = ${arr[i]}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Initialize maxEndingHere = ${arr[i]}, maxSoFar = ${arr[i]}
                </div>
            `;
            
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements[i].querySelector('.element-value').classList.add('kadane-current');
            
            maxSubarraySumValue.textContent = maxSoFar;
            maxSubarrayIndices.textContent = `${start} to ${end}`;
            
        } else {
            explanation.innerHTML = `Step ${step}: Processing element at index ${i} = ${arr[i]}`;
            
            // Highlight current element
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements[i].querySelector('.element-value').classList.add('kadane-current');
            
            // Calculate new maxEndingHere
            const newMaxEndingHere = Math.max(arr[i], maxEndingHere + arr[i]);
            const decision = newMaxEndingHere === arr[i] ? 'start new subarray' : 'extend current subarray';
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> maxEndingHere = max(${arr[i]}, ${maxEndingHere} + ${arr[i]}) = ${newMaxEndingHere} (${decision})
                </div>
            `;
            
            setTimeout(() => {
                if (newMaxEndingHere === arr[i]) {
                    // Start new subarray
                    tempStart = i;
                    explanation.innerHTML = `Step ${step}: Starting new subarray at index ${i}`;
                } else {
                    // Extend current subarray
                    explanation.innerHTML = `Step ${step}: Extending current subarray to include index ${i}`;
                }
                
                maxEndingHere = newMaxEndingHere;
                
                // Highlight elements in current subarray
                for (let j = tempStart; j <= i; j++) {
                    transformedElements[j].querySelector('.element-value').classList.add('kadane-included');
                }
                
                // Update maxSoFar if needed
                if (maxEndingHere > maxSoFar) {
                    maxSoFar = maxEndingHere;
                    start = tempStart;
                    end = i;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Update:</strong> New maximum found! maxSoFar = ${maxSoFar} (indices ${start}-${end})
                        </div>
                    `;
                    
                    explanation.innerHTML = `Step ${step}: New maximum subarray sum found = ${maxSoFar}`;
                    
                    // Highlight the new maximum subarray
                    for (let j = start; j <= end; j++) {
                        transformedElements[j].querySelector('.element-value').classList.add('kadane-max-subarray');
                    }
                }
                
                maxSubarraySumValue.textContent = maxSoFar;
                maxSubarrayIndices.textContent = `${start} to ${end}`;
                
                // Remove current highlight and move to next
                transformedElements[i].querySelector('.element-value').classList.remove('kadane-current');
                
                // Continue to next element
                performKadaneStep(i + 1);
            }, 2000);
            
            return;
        }
        
        // Continue to next element
        setTimeout(() => {
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements[i].querySelector('.element-value').classList.remove('kadane-current');
            performKadaneStep(i + 1);
        }, 1500);
    }
    
    // Start Kadane's algorithm
    performKadaneStep(0);
}

// NEW: Return to Original after Kadane's Algorithm
function returnToOriginalAfterKadane() {
    // Reset to original array
    myArray = [...originalArrayForKadane];
    originalArrayForKadane = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isKadaneAlgorithmRunning = false;
    
    logOperation('Kadane\'s algorithm completed - returned to original array', 'info');
    showNotification('Returned to original array after Kadane\'s algorithm', 'success');
}
// NEW: Move Zeros Handler
function handleMoveZeros(direction) {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isZeroMovementRunning) {
        showNotification('A zero movement operation is already in progress', 'warning');
        return;
    }
    
    // Store original array
    originalArrayForZeroMovement = [...myArray];
    
    // Show zero movement visualization
    showZeroMovementVisualization(direction);
}

// NEW: Show Zero Movement Visualization
function showZeroMovementVisualization(direction) {
    isZeroMovementRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Move Zeros to ${direction === 'end' ? 'End' : 'Front'}</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalZeroArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After Moving Zeros</div>
            <div class="transformed-array-container" id="transformedZeroArray"></div>
        </div>
        
        <div class="zero-movement-explanation">
            <p class="mb-2"><strong>Zero Movement:</strong> Moving all zero elements to the ${direction === 'end' ? 'end' : 'front'} while maintaining relative order of non-zero elements</p>
            <p class="mb-0" id="zeroMovementExplanation">Initializing zero movement...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="zeroMovementStepsContainer">
            <h6 class="text-center">Zero Movement Steps</h6>
            <div class="steps-container" id="zeroMovementSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterZeroMovement" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForZeroMovement, 'originalZeroArray');
    renderArrayInContainer([...originalArrayForZeroMovement], 'transformedZeroArray');
    
    performZeroMovementAnimation(direction);
}

// NEW: Perform Zero Movement Animation
function performZeroMovementAnimation(direction) {
    const originalContainer = document.getElementById('originalZeroArray');
    const transformedContainer = document.getElementById('transformedZeroArray');
    const explanation = document.getElementById('zeroMovementExplanation');
    const stepsContainer = document.getElementById('zeroMovementSteps');
    const continueButton = document.getElementById('continueAfterZeroMovement');
    
    let array = [...originalArrayForZeroMovement];
    let step = 0;
    
    // Count zeros
    const zeroCount = array.filter(val => val === '0' || val === 0).length;
    
    function performZeroMovementStep() {
        if (step === 0) {
            // Initial step - identify zeros
            explanation.innerHTML = `Step ${step + 1}: Identifying zero elements in the array`;
            
            // Highlight all zero elements
            const originalElements = originalContainer.querySelectorAll('.array-element');
            array.forEach((val, index) => {
                if (val === '0' || val === 0) {
                    const element = originalElements[index].querySelector('.element-value');
                    element.classList.add('zero-element');
                }
            });
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step + 1}:</strong> Found ${zeroCount} zero element(s) in the array
                </div>
            `;
            
            step++;
            setTimeout(performZeroMovementStep, 1500);
            
        } else if (step === 1) {
            // Show the movement strategy
            explanation.innerHTML = `Step ${step + 1}: Strategy - Move all zeros to the ${direction === 'end' ? 'end' : 'front'} while maintaining order of non-zero elements`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step + 1}:</strong> Using two-pointer approach to move zeros
                </div>
            `;
            
            step++;
            setTimeout(performZeroMovementStep, 1500);
            
        } else {
            // Perform the actual zero movement
            if (direction === 'end') {
                moveZerosToEndWithAnimation();
            } else {
                moveZerosToFrontWithAnimation();
            }
        }
    }
    
    // NEW: Move Zeros to End with Animation
    function moveZerosToEndWithAnimation() {
        let writePointer = 0;
        let zeroPointer = array.length - 1;
        let currentIndex = 0;
        
        function moveNextZero() {
            if (currentIndex >= array.length) {
                // Movement completed
                explanation.innerHTML = `<strong>Zero Movement Completed!</strong> All ${zeroCount} zero(s) moved to the end`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> All zeros moved to the end successfully
                    </div>
                `;
                
                // Highlight the final result
                const transformedElements = transformedContainer.querySelectorAll('.array-element');
                for (let i = array.length - zeroCount; i < array.length; i++) {
                    transformedElements[i].querySelector('.element-value').classList.add('zero-element');
                }
                
                continueButton.style.display = 'block';
                
                // Auto-return after 5 seconds
                setTimeout(() => {
                    returnToOriginalAfterZeroMovement();
                }, 5000);
                
                continueButton.addEventListener('click', returnToOriginalAfterZeroMovement);
                
                return;
            }
            
            const currentValue = array[currentIndex];
            const isZero = currentValue === '0' || currentValue === 0;
            
            explanation.innerHTML = `Step ${step + 1}: Processing element at index ${currentIndex} = "${currentValue}"`;
            
            // Highlight current element
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const currentElement = transformedElements[currentIndex].querySelector('.element-value');
            currentElement.classList.add('zero-movement-current');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${!isZero ? 'active' : ''}">
                    <strong>Step ${step + 1}:</strong> [${currentIndex}]="${currentValue}" - ${isZero ? 'Zero found, will move to end' : 'Non-zero, keeping in position'}
                </div>
            `;
            
            setTimeout(() => {
                currentElement.classList.remove('zero-movement-current');
                
                if (!isZero) {
                    // Non-zero element - keep it in position
                    if (writePointer !== currentIndex) {
                        // Move non-zero element to writePointer position
                        array[writePointer] = array[currentIndex];
                        array[currentIndex] = '0'; // Temporarily mark as zero for visualization
                        
                        // Update transformed array
                        renderArrayInContainer([...array], 'transformedZeroArray');
                        
                        // Highlight the movement
                        const newElement = transformedContainer.querySelectorAll('.array-element')[writePointer].querySelector('.element-value');
                        newElement.classList.add('zero-movement-target');
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Move:</strong> Moved non-zero element "${currentValue}" from [${currentIndex}] to [${writePointer}]
                            </div>
                        `;
                        
                        writePointer++;
                    } else {
                        writePointer++;
                    }
                } else {
                    // Zero element - it will naturally move to end as we shift non-zeros left
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Zero:</strong> Zero element at [${currentIndex}] will be moved to end
                        </div>
                    `;
                }
                
                currentIndex++;
                step++;
                
                // Continue to next element
                moveNextZero();
            }, 1500);
        }
        
        // Start moving zeros to end
        moveNextZero();
    }
    
    // NEW: Move Zeros to Front with Animation
    function moveZerosToFrontWithAnimation() {
        let writePointer = array.length - 1;
        let currentIndex = array.length - 1;
        
        function moveNextZero() {
            if (currentIndex < 0) {
                // Movement completed
                explanation.innerHTML = `<strong>Zero Movement Completed!</strong> All ${zeroCount} zero(s) moved to the front`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> All zeros moved to the front successfully
                    </div>
                `;
                
                // Highlight the final result
                const transformedElements = transformedContainer.querySelectorAll('.array-element');
                for (let i = 0; i < zeroCount; i++) {
                    transformedElements[i].querySelector('.element-value').classList.add('zero-element');
                }
                
                continueButton.style.display = 'block';
                
                // Auto-return after 5 seconds
                setTimeout(() => {
                    returnToOriginalAfterZeroMovement();
                }, 5000);
                
                continueButton.addEventListener('click', returnToOriginalAfterZeroMovement);
                
                return;
            }
            
            const currentValue = array[currentIndex];
            const isZero = currentValue === '0' || currentValue === 0;
            
            explanation.innerHTML = `Step ${step + 1}: Processing element at index ${currentIndex} = "${currentValue}"`;
            
            // Highlight current element
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const currentElement = transformedElements[currentIndex].querySelector('.element-value');
            currentElement.classList.add('zero-movement-current');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${!isZero ? 'active' : ''}">
                    <strong>Step ${step + 1}:</strong> [${currentIndex}]="${currentValue}" - ${isZero ? 'Zero found, will move to front' : 'Non-zero, keeping in position'}
                </div>
            `;
            
            setTimeout(() => {
                currentElement.classList.remove('zero-movement-current');
                
                if (!isZero) {
                    // Non-zero element - move it to the writePointer position
                    if (writePointer !== currentIndex) {
                        array[writePointer] = array[currentIndex];
                        array[currentIndex] = '0'; // Temporarily mark as zero for visualization
                        
                        // Update transformed array
                        renderArrayInContainer([...array], 'transformedZeroArray');
                        
                        // Highlight the movement
                        const newElement = transformedContainer.querySelectorAll('.array-element')[writePointer].querySelector('.element-value');
                        newElement.classList.add('zero-movement-target');
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Move:</strong> Moved non-zero element "${currentValue}" from [${currentIndex}] to [${writePointer}]
                            </div>
                        `;
                        
                        writePointer--;
                    } else {
                        writePointer--;
                    }
                } else {
                    // Zero element - it will naturally move to front as we shift non-zeros right
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Zero:</strong> Zero element at [${currentIndex}] will be moved to front
                        </div>
                    `;
                }
                
                currentIndex--;
                step++;
                
                // Continue to next element
                moveNextZero();
            }, 1500);
        }
        
        // Start moving zeros to front
        moveNextZero();
    }
    
    // Start zero movement process
    performZeroMovementStep();
}

// NEW: Return to Original after Zero Movement
function returnToOriginalAfterZeroMovement() {
    // Reset to original array
    myArray = [...originalArrayForZeroMovement];
    originalArrayForZeroMovement = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isZeroMovementRunning = false;
    
    logOperation('Zero movement completed - returned to original array', 'info');
    showNotification('Returned to original array after zero movement', 'success');
}
// NEW: Count Subarrays Handler
function handleCountSubarrays() {
    const input = subarrayInput.value.trim();
    
    if (input === '') {
        // Use current array if no input provided
        if (myArray.length === 0) {
            showNotification('Please enter array values or add elements to the array', 'warning');
            return;
        }
        processSubarrayCalculation(myArray);
        return;
    }
    
    // Parse input string (comma-separated values)
    const inputArray = input.split(',').map(item => item.trim()).filter(item => item !== '');
    
    if (inputArray.length === 0) {
        showNotification('Please enter valid array values', 'danger');
        subarrayInput.focus();
        return;
    }
    
    processSubarrayCalculation(inputArray);
}

// NEW: Generate Subarrays Handler
function handleGenerateSubarrays() {
    const input = subarrayInput.value.trim();
    let targetArray;
    
    if (input === '') {
        // Use current array if no input provided
        if (myArray.length === 0) {
            showNotification('Please enter array values or add elements to the array', 'warning');
            return;
        }
        targetArray = myArray;
    } else {
        // Parse input string
        targetArray = input.split(',').map(item => item.trim()).filter(item => item !== '');
    }
    
    if (targetArray.length === 0) {
        showNotification('Please enter valid array values', 'danger');
        return;
    }
    
    generateAllSubarrays(targetArray);
}

// NEW: Process subarray calculation
function processSubarrayCalculation(array) {
    const totalSubarrays = calculateTotalSubarrays(array.length);
    
    // Show results section
    subarraysResults.style.display = 'block';
    subarrayCount.textContent = totalSubarrays;
    
    // Update input field to show the array being used
    subarrayInput.value = array.join(', ');
    
    logOperation(`Calculated subarrays for [${array.join(', ')}] - total: ${totalSubarrays}`, 'info');
    showNotification(`Total subarrays: ${totalSubarrays}`, 'success');
}

// NEW: Generate and display all subarrays
function generateAllSubarrays(array) {
    const allSubarrays = getAllSubarrays(array);
    const totalSubarrays = allSubarrays.length;
    
    // Show results section
    subarraysResults.style.display = 'block';
    subarrayCount.textContent = totalSubarrays;
    
    // Display all subarrays
    let subarraysHTML = '<div class="subarrays-container" style="max-height: 300px; overflow-y: auto;">';
    subarraysHTML += '<p><strong>All Subarrays:</strong></p>';
    subarraysHTML += '<div class="d-flex flex-wrap gap-2">';
    
    allSubarrays.forEach((subarray, index) => {
        subarraysHTML += `
            <div class="subarray-item bg-primary rounded px-2 py-1 small">
                [${subarray.join(', ')}]
            </div>
        `;
    });
    
    subarraysHTML += '</div></div>';
    subarraysList.innerHTML = subarraysHTML;
    
    // Update input field to show the array being used
    subarrayInput.value = array.join(', ');
    
    logOperation(`Generated ${totalSubarrays} subarrays for [${array.join(', ')}]`, 'success');
    showNotification(`Generated ${totalSubarrays} subarrays`, 'success');
}

// NEW: Calculate total number of subarrays
function calculateTotalSubarrays(n) {
    // Formula: n*(n+1)/2
    return n * (n + 1) / 2;
}

// NEW: Generate all possible subarrays
function getAllSubarrays(array) {
    const subarrays = [];
    const n = array.length;
    
    // Pick starting point
    for (let i = 0; i < n; i++) {
        // Pick ending point
        for (let j = i; j < n; j++) {
            // Get subarray from i to j
            const subarray = [];
            for (let k = i; k <= j; k++) {
                subarray.push(array[k]);
            }
            subarrays.push(subarray);
        }
    }
    
    return subarrays;
}
// NEW: Rearrange Positive and Negative Values Handler
function handleRearrangePositiveNegative() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isRearrangeRunning) {
        showNotification('A rearrange operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Rearrange operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForRearrange = [...myArray];
    
    // Start rearrange visualization
    showRearrangeVisualization();
}
// NEW: Show Rearrange Visualization
function showRearrangeVisualization() {
    isRearrangeRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Rearrange Positive & Negative Values</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalRearrangeArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Rearranged Array (Negatives First)</div>
            <div class="transformed-array-container" id="transformedRearrangeArray"></div>
        </div>
        
        <div class="rearrange-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Move all negative values to the front while maintaining relative order</p>
            <p class="mb-0" id="rearrangeExplanation">Initializing rearrangement process...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="rearrangeStepsContainer">
            <h6 class="text-center">Rearrangement Steps</h6>
            <div class="steps-container" id="rearrangeSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterRearrange" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForRearrange, 'originalRearrangeArray');
    renderArrayInContainer([...originalArrayForRearrange], 'transformedRearrangeArray');
    
    performRearrangeAnimation();
}

// NEW: Perform Rearrange Animation
function performRearrangeAnimation() {
    const originalContainer = document.getElementById('originalRearrangeArray');
    const transformedContainer = document.getElementById('transformedRearrangeArray');
    const explanation = document.getElementById('rearrangeExplanation');
    const stepsContainer = document.getElementById('rearrangeSteps');
    const continueButton = document.getElementById('continueAfterRearrange');
    
    let array = [...originalArrayForRearrange];
    const n = array.length;
    let step = 0;
    
    // First, classify elements as negative or positive
    explanation.innerHTML = 'Step 1: Classifying elements as negative or positive';
    
    setTimeout(() => {
        // Highlight negative and positive values
        const originalElements = originalContainer.querySelectorAll('.array-element');
        originalElements.forEach((element, index) => {
            const value = parseFloat(array[index]);
            const valueDiv = element.querySelector('.element-value');
            
            if (value < 0) {
                valueDiv.classList.add('negative-value');
            } else {
                valueDiv.classList.add('positive-value');
            }
        });
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step 1:</strong> Classified elements - Negative values in blue, Positive values in yellow
            </div>
        `;
        
        step++;
        performRearrangeStep();
    }, 2000);
    
    function performRearrangeStep() {
        if (step === 1) {
            explanation.innerHTML = 'Step 2: Starting rearrangement - Moving negatives to front';
            
            // Use two-pointer approach to rearrange
            let left = 0;
            let right = 0;
            
            function rearrangeNext() {
                if (right >= n) {
                    // Rearrangement completed
                    explanation.innerHTML = '<strong>Rearrangement Completed!</strong> All negative values moved to the front.';
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Final:</strong> Rearrangement completed! Negative values: ${array.filter(val => parseFloat(val) < 0).length}, Positive values: ${array.filter(val => parseFloat(val) >= 0).length}
                        </div>
                    `;
                    
                    // Highlight the final rearranged array
                    const transformedElements = transformedContainer.querySelectorAll('.array-element');
                    transformedElements.forEach((element, index) => {
                        const value = parseFloat(array[index]);
                        const valueDiv = element.querySelector('.element-value');
                        
                        setTimeout(() => {
                            if (value < 0) {
                                valueDiv.classList.add('negative-value', 'bounce');
                            } else {
                                valueDiv.classList.add('positive-value', 'bounce');
                            }
                        }, index * 100);
                    });
                    
                    continueButton.style.display = 'block';
                    
                    // Auto-return after 5 seconds
                    setTimeout(() => {
                        returnToOriginalAfterRearrange();
                    }, 5000);
                    
                    continueButton.addEventListener('click', returnToOriginalAfterRearrange);
                    
                    return;
                }
                
                const currentValue = parseFloat(array[right]);
                
                if (currentValue < 0) {
                    // This is a negative value that needs to be moved to the front
                    explanation.innerHTML = `Step ${step + 1}: Found negative value at index ${right} = ${array[right]}, moving to position ${left}`;
                    
                    // Highlight the current negative value
                    const originalElements = originalContainer.querySelectorAll('.array-element');
                    const currentElement = originalElements[right].querySelector('.element-value');
                    const targetElement = originalElements[left].querySelector('.element-value');
                    
                    currentElement.classList.add('rearrange-current');
                    targetElement.classList.add('rearrange-target');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step + 1}:</strong> Moving negative value ${array[right]} from index ${right} to index ${left}
                        </div>
                    `;
                    
                    setTimeout(() => {
                        // Swap elements
                        [array[left], array[right]] = [array[right], array[left]];
                        
                        // Update transformed array
                        renderArrayInContainer(array, 'transformedRearrangeArray');
                        
                        // Remove highlights
                        currentElement.classList.remove('rearrange-current');
                        targetElement.classList.remove('rearrange-target');
                        
                        // Re-highlight the transformed array
                        const transformedElements = transformedContainer.querySelectorAll('.array-element');
                        transformedElements.forEach((element, index) => {
                            const value = parseFloat(array[index]);
                            const valueDiv = element.querySelector('.element-value');
                            
                            if (value < 0) {
                                valueDiv.classList.add('negative-value');
                            } else {
                                valueDiv.classList.add('positive-value');
                            }
                        });
                        
                        left++;
                        right++;
                        step++;
                        
                        rearrangeNext();
                    }, 2000);
                } else {
                    // Positive value, just move right pointer
                    explanation.innerHTML = `Step ${step + 1}: Positive value at index ${right} = ${array[right]}, keeping in place`;
                    
                    const originalElements = originalContainer.querySelectorAll('.array-element');
                    const currentElement = originalElements[right].querySelector('.element-value');
                    currentElement.classList.add('rearrange-current');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step + 1}:</strong> Positive value ${array[right]} at index ${right} - keeping in current position
                        </div>
                    `;
                    
                    setTimeout(() => {
                        currentElement.classList.remove('rearrange-current');
                        right++;
                        step++;
                        rearrangeNext();
                    }, 1500);
                }
            }
            
            // Start the rearrangement process
            rearrangeNext();
        }
    }
}

// NEW: Return to Original after Rearrange
function returnToOriginalAfterRearrange() {
    // Reset to original array
    myArray = [...originalArrayForRearrange];
    originalArrayForRearrange = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isRearrangeRunning = false;
    
    logOperation('Rearrange positive/negative values completed - returned to original array', 'info');
    showNotification('Returned to original array after rearrangement', 'success');
}
// NEW: Segregate Even & Odd Numbers Handler
function handleSegregateEvenOdd() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isSegregateRunning) {
        showNotification('Segregation operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Segregation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isSegregateRunning = true;
    
    // Store original array
    originalArrayForSegregate = [...myArray];
    
    // Show segregation visualization
    showSegregateVisualization();
}
// NEW: Show Segregate Visualization
function showSegregateVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Segregate Even & Odd Numbers</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalSegregateArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Segregated Array (Even First)</div>
            <div class="transformed-array-container" id="transformedSegregateArray"></div>
        </div>
        
        <div class="segregate-explanation">
            <p class="mb-2"><strong>Segregation Algorithm:</strong> Move all even numbers to the front while maintaining relative order</p>
            <p class="mb-0" id="segregateExplanation">Initializing segregation process...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="segregateStepsContainer">
            <h6 class="text-center">Segregation Steps</h6>
            <div class="steps-container" id="segregateSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSegregate" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSegregate, 'originalSegregateArray');
    renderArrayInContainer([...originalArrayForSegregate], 'transformedSegregateArray');
    
    performSegregateAnimation();
}
// NEW: Perform Segregate Animation
function performSegregateAnimation() {
    const originalContainer = document.getElementById('originalSegregateArray');
    const transformedContainer = document.getElementById('transformedSegregateArray');
    const explanation = document.getElementById('segregateExplanation');
    const stepsContainer = document.getElementById('segregateSteps');
    const continueButton = document.getElementById('continueAfterSegregate');
    
    const array = [...originalArrayForSegregate];
    const numericArray = array.map(val => parseInt(val));
    let segregatedArray = [...numericArray];
    let nextEvenPos = 0;
    let step = 0;
    
    function performSegregateStep(i) {
        if (i >= segregatedArray.length) {
            // Segregation completed
            explanation.innerHTML = `<strong>Segregation Completed!</strong> All even numbers moved to the front.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Segregation completed! Even numbers: ${segregatedArray.filter(x => x % 2 === 0).length}, Odd numbers: ${segregatedArray.filter(x => x % 2 !== 0).length}
                </div>
            `;
            
            // Highlight even and odd sections
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const evenCount = segregatedArray.filter(x => x % 2 === 0).length;
            
            transformedElements.forEach((el, index) => {
                setTimeout(() => {
                    const valueDiv = el.querySelector('.element-value');
                    if (index < evenCount) {
                        valueDiv.classList.add('even-number');
                    } else {
                        valueDiv.classList.add('odd-number');
                    }
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterSegregate();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSegregate);
            
            return;
        }
        
        step++;
        const currentNumber = segregatedArray[i];
        const isEven = currentNumber % 2 === 0;
        
        explanation.innerHTML = `Step ${step}: Checking element [${i}] = ${currentNumber} (${isEven ? 'EVEN' : 'ODD'})`;
        
        // Highlight current element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[i].querySelector('.element-value');
        currentElement.classList.add('segregate-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${isEven ? 'active' : ''}">
                <strong>Step ${step}:</strong> Checking [${i}] = ${currentNumber} - ${isEven ? 'EVEN (will move to position ' + nextEvenPos + ')' : 'ODD (stays in current position)'}
            </div>
        `;
        
        setTimeout(() => {
            if (isEven && i !== nextEvenPos) {
                // Need to move this even number to nextEvenPos
                explanation.innerHTML = `Step ${step}: Moving EVEN number ${currentNumber} from position ${i} to ${nextEvenPos}`;
                
                // Highlight the target position
                const targetElement = originalElements[nextEvenPos].querySelector('.element-value');
                targetElement.classList.add('segregate-target');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Action:</strong> Moving EVEN number ${currentNumber} from index ${i} to ${nextEvenPos}
                    </div>
                `;
                
                setTimeout(() => {
                    // Perform the swap in segregated array
                    // Move current even number to nextEvenPos, shifting others
                    for (let j = i; j > nextEvenPos; j--) {
                        segregatedArray[j] = segregatedArray[j - 1];
                    }
                    segregatedArray[nextEvenPos] = currentNumber;
                    
                    // Update transformed array display
                    renderArrayInContainer(segregatedArray, 'transformedSegregateArray');
                    
                    // Remove highlights
                    currentElement.classList.remove('segregate-current');
                    targetElement.classList.remove('segregate-target');
                    
                    // Update nextEvenPos
                    nextEvenPos++;
                    
                    // Continue with next element
                    performSegregateStep(nextEvenPos);
                }, 1500);
                
            } else {
                if (isEven) {
                    // Even number already in correct position
                    explanation.innerHTML = `Step ${step}: EVEN number ${currentNumber} already at correct position ${nextEvenPos}`;
                    nextEvenPos++;
                } else {
                    // Odd number, no action needed
                    explanation.innerHTML = `Step ${step}: ODD number ${currentNumber} stays at position ${i}`;
                }
                
                // Remove highlight
                currentElement.classList.remove('segregate-current');
                
                // Continue with next element
                performSegregateStep(i + 1);
            }
        }, 1500);
    }
    
    // Start segregation process
    performSegregateStep(0);
}
// NEW: Return to Original after Segregate
function returnToOriginalAfterSegregate() {
    // Reset to original array
    myArray = [...originalArrayForSegregate];
    originalArrayForSegregate = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isSegregateRunning = false;
    
    logOperation('Even-odd segregation completed - returned to original array', 'info');
    showNotification('Returned to original array after segregation', 'success');
}
// NEW: Count Element Frequency Handler
function handleCountElementFrequency() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }

    if (isFrequencyCountRunning) {
        showNotification('Frequency count is already in progress', 'warning');
        return;
    }

    isFrequencyCountRunning = true;
    originalArrayForFrequency = [...myArray];

    // Show frequency count visualization
    showFrequencyCountVisualization();
}

// NEW: Show Frequency Count Visualization
function showFrequencyCountVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Element Frequency Analysis</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalFrequencyArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-chart-bar"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Frequency Analysis Results</div>
            <div id="frequencyResultsContainer" class="mt-3" style="width: 100%;"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Frequency Analysis:</strong> Counting occurrences of each element in the array</p>
            <p class="mb-0" id="frequencyExplanation">Starting frequency analysis...</p>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterFrequency" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;

    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);

    renderArrayInContainer(originalArrayForFrequency, 'originalFrequencyArray');
    performFrequencyAnalysis();
}

// NEW: Perform Frequency Analysis with Animation
function performFrequencyAnalysis() {
    const originalContainer = document.getElementById('originalFrequencyArray');
    const resultsContainer = document.getElementById('frequencyResultsContainer');
    const explanation = document.getElementById('frequencyExplanation');
    const continueButton = document.getElementById('continueAfterFrequency');

    const frequencyMap = new Map();
    let currentIndex = 0;
    let totalElements = originalArrayForFrequency.length;
    let uniqueElements = 0;

    function processNextElement() {
        if (currentIndex >= totalElements) {
            // Analysis completed
            displayFrequencyResults(frequencyMap);
            explanation.innerHTML = `<strong>Frequency Analysis Completed!</strong> Found ${uniqueElements} unique elements out of ${totalElements} total elements.`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterFrequency();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterFrequency);
            
            return;
        }

        const currentElement = originalArrayForFrequency[currentIndex];
        explanation.innerHTML = `Processing element [${currentIndex}]: "${currentElement}"`;

        // Highlight current element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElementDiv = originalElements[currentIndex].querySelector('.element-value');
        currentElementDiv.classList.add('frequency-highlight');

        setTimeout(() => {
            // Update frequency count
            if (frequencyMap.has(currentElement)) {
                frequencyMap.set(currentElement, frequencyMap.get(currentElement) + 1);
                explanation.innerHTML = `Element "${currentElement}" count increased to ${frequencyMap.get(currentElement)}`;
            } else {
                frequencyMap.set(currentElement, 1);
                uniqueElements++;
                explanation.innerHTML = `New element found: "${currentElement}" (first occurrence)`;
            }

            // Remove highlight and move to next
            currentElementDiv.classList.remove('frequency-highlight');
            currentIndex++;
            
            // Update progress display
            if (currentIndex % 3 === 0 || currentIndex === totalElements) {
                displayIntermediateResults(frequencyMap, currentIndex, totalElements);
            }
            
            processNextElement();
        }, 800);
    }

    // Start processing
    processNextElement();
}

// NEW: Display Intermediate Results
function displayIntermediateResults(frequencyMap, currentIndex, totalElements) {
    const resultsContainer = document.getElementById('frequencyResultsContainer');
    const progress = Math.floor((currentIndex / totalElements) * 100);
    
    resultsContainer.innerHTML = `
        <div class="stats-highlight">
            Progress: ${progress}% (${currentIndex}/${totalElements} elements processed)
        </div>
        <div class="table-container">
            <table class="frequency-table table-animation">
                <thead>
                    <tr>
                        <th>Element</th>
                        <th>Frequency</th>
                        <th>Percentage</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody>
                    ${Array.from(frequencyMap.entries()).map(([element, count]) => `
                        <tr>
                            <td>${element}</td>
                            <td>${count}</td>
                            <td>${((count / currentIndex) * 100).toFixed(1)}%</td>
                            <td>
                                ${count > 1 ? 
                                    '<span class="text-warning">Duplicate</span>' : 
                                    '<span class="text-success">Unique</span>'
                                }
                            </td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        </div>
    `;
}

// NEW: Display Final Frequency Results
function displayFrequencyResults(frequencyMap) {
    const resultsContainer = document.getElementById('frequencyResultsContainer');
    const totalElements = originalArrayForFrequency.length;
    const uniqueElements = frequencyMap.size;
    const duplicateElements = Array.from(frequencyMap.values()).filter(count => count > 1).length;
    
    // Sort by frequency (descending)
    const sortedFrequencies = Array.from(frequencyMap.entries())
        .sort((a, b) => b[1] - a[1]);
    
    const mostFrequent = sortedFrequencies[0];
    const leastFrequent = sortedFrequencies[sortedFrequencies.length - 1];
    
    resultsContainer.innerHTML = `
        <div class="row text-center mb-3">
            <div class="col-md-3">
                <div class="stats-card">
                    <div>Total Elements</div>
                    <div class="stats-value">${totalElements}</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="stats-card">
                    <div>Unique Elements</div>
                    <div class="stats-value">${uniqueElements}</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="stats-card">
                    <div>Duplicate Elements</div>
                    <div class="stats-value">${duplicateElements}</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="stats-card">
                    <div>Most Frequent</div>
                    <div class="stats-value">${mostFrequent[0]} (${mostFrequent[1]})</div>
                </div>
            </div>
        </div>
        
        <div class="table-container">
            <table class="frequency-table table-animation">
                <thead>
                    <tr>
                        <th>Element</th>
                        <th>Frequency</th>
                        <th>Percentage</th>
                        <th>Status</th>
                        <th>Bar Chart</th>
                    </tr>
                </thead>
                <tbody>
                    ${sortedFrequencies.map(([element, count]) => {
                        const percentage = ((count / totalElements) * 100).toFixed(1);
                        const barWidth = (count / mostFrequent[1]) * 100;
                        const rowClass = count > 1 ? 'frequency-duplicate' : 'frequency-unique';
                        const statusText = count > 1 ? 
                            `<span class="text-warning"><i class="fas fa-clone me-1"></i>Duplicate (${count}x)</span>` : 
                            `<span class="text-success"><i class="fas fa-star me-1"></i>Unique</span>`;
                        
                        return `
                            <tr class="${rowClass}">
                                <td><strong>${element}</strong></td>
                                <td>${count}</td>
                                <td>${percentage}%</td>
                                <td>${statusText}</td>
                                <td>
                                    <div style="background: rgba(255,255,255,0.2); border-radius: 5px; height: 20px; width: 100%;">
                                        <div style="background: var(${count > 1 ? '--warning-color' : '--success-color'}); 
                                                    height: 100%; width: ${barWidth}%; border-radius: 5px; 
                                                    transition: width 1s ease;"></div>
                                    </div>
                                </td>
                            </tr>
                        `;
                    }).join('')}
                </tbody>
            </table>
        </div>
        
        <div class="stats-highlight mt-3">
            <i class="fas fa-chart-pie me-2"></i>
            Analysis Summary: ${duplicateElements} duplicate element(s) found. 
            Most frequent: "${mostFrequent[0]}" (${mostFrequent[1]} occurrences)
        </div>
    `;
    
    // Animate the bar charts
    setTimeout(() => {
        const bars = resultsContainer.querySelectorAll('td div div');
        bars.forEach(bar => {
            bar.style.width = bar.style.width;
        });
    }, 100);
}

// NEW: Return to Original after Frequency Analysis
function returnToOriginalAfterFrequency() {
    // Reset to original array
    myArray = [...originalArrayForFrequency];
    originalArrayForFrequency = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isFrequencyCountRunning = false;
    
    logOperation('Frequency analysis completed - returned to original array', 'info');
    showNotification('Returned to original array after frequency analysis', 'success');
}

// NEW: Find Duplicate Elements Handler
function handleFindDuplicates() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }

    if (isFindDuplicatesRunning) {
        showNotification('Duplicate search is already in progress', 'warning');
        return;
    }

    isFindDuplicatesRunning = true;
    originalArrayForDuplicates = [...myArray];

    // Show duplicate elements visualization
    showDuplicatesVisualization();
}

// NEW: Show Duplicates Visualization
function showDuplicatesVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Duplicate Elements Detection</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalDuplicatesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-clone"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Duplicate Analysis Results</div>
            <div id="duplicatesResultsContainer" class="mt-3" style="width: 100%;"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Duplicate Detection:</strong> Finding and highlighting all duplicate elements</p>
            <p class="mb-0" id="duplicatesExplanation">Starting duplicate detection...</p>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterDuplicates" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;

    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);

    renderArrayInContainer(originalArrayForDuplicates, 'originalDuplicatesArray');
    performDuplicatesDetection();
}

// NEW: Perform Duplicates Detection with Animation
function performDuplicatesDetection() {
    const originalContainer = document.getElementById('originalDuplicatesArray');
    const resultsContainer = document.getElementById('duplicatesResultsContainer');
    const explanation = document.getElementById('duplicatesExplanation');
    const continueButton = document.getElementById('continueAfterDuplicates');

    const elementPositions = new Map();
    const duplicates = new Map();
    let currentIndex = 0;
    let totalElements = originalArrayForDuplicates.length;

    function processNextElement() {
        if (currentIndex >= totalElements) {
            // Detection completed
            displayDuplicatesResults(duplicates, elementPositions);
            explanation.innerHTML = `<strong>Duplicate Detection Completed!</strong> Found ${duplicates.size} duplicate element(s).`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterDuplicates();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterDuplicates);
            
            return;
        }

        const currentElement = originalArrayForDuplicates[currentIndex];
        explanation.innerHTML = `Checking element [${currentIndex}]: "${currentElement}" for duplicates`;

        // Highlight current element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElementDiv = originalElements[currentIndex].querySelector('.element-value');
        currentElementDiv.classList.add('duplicate-highlight');

        setTimeout(() => {
            // Check for duplicates
            if (elementPositions.has(currentElement)) {
                // This is a duplicate
                const positions = elementPositions.get(currentElement);
                positions.push(currentIndex);
                
                if (!duplicates.has(currentElement)) {
                    duplicates.set(currentElement, [...positions]);
                } else {
                    duplicates.set(currentElement, positions);
                }
                
                explanation.innerHTML = `Duplicate found! "${currentElement}" at positions: ${positions.join(', ')}`;
                
                // Highlight all occurrences of this duplicate
                positions.forEach(pos => {
                    if (pos !== currentIndex) {
                        originalElements[pos].querySelector('.element-value').classList.add('duplicate-highlight');
                    }
                });
                
            } else {
                // First occurrence
                elementPositions.set(currentElement, [currentIndex]);
                explanation.innerHTML = `First occurrence of "${currentElement}"`;
            }

            // Remove current highlight and move to next
            setTimeout(() => {
                currentElementDiv.classList.remove('duplicate-highlight');
                currentIndex++;
                
                // Update progress
                if (currentIndex % 2 === 0 || currentIndex === totalElements) {
                    displayIntermediateDuplicates(duplicates, currentIndex, totalElements);
                }
                
                processNextElement();
            }, 500);
            
        }, 1000);
    }

    // Start processing
    processNextElement();
}

// NEW: Display Intermediate Duplicates Results
function displayIntermediateDuplicates(duplicates, currentIndex, totalElements) {
    const resultsContainer = document.getElementById('duplicatesResultsContainer');
    const progress = Math.floor((currentIndex / totalElements) * 100);
    
    resultsContainer.innerHTML = `
        <div class="stats-highlight">
            Progress: ${progress}% (${currentIndex}/${totalElements} elements checked)
        </div>
        <div class="table-container">
            <table class="frequency-table table-animation">
                <thead>
                    <tr>
                        <th>Duplicate Element</th>
                        <th>Occurrences</th>
                        <th>Positions</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody>
                    ${Array.from(duplicates.entries()).map(([element, positions]) => `
                        <tr class="frequency-duplicate">
                            <td><strong>${element}</strong></td>
                            <td>${positions.length}</td>
                            <td>[${positions.join(', ')}]</td>
                            <td><span class="text-warning">Duplicate Found</span></td>
                        </tr>
                    `).join('')}
                    ${duplicates.size === 0 ? `
                        <tr>
                            <td colspan="4" class="text-center text-muted">No duplicates found yet...</td>
                        </tr>
                    ` : ''}
                </tbody>
            </table>
        </div>
    `;
}

// NEW: Display Final Duplicates Results
function displayDuplicatesResults(duplicates, elementPositions) {
    const resultsContainer = document.getElementById('duplicatesResultsContainer');
    const totalElements = originalArrayForDuplicates.length;
    const uniqueElements = elementPositions.size;
    const totalDuplicates = Array.from(duplicates.values()).reduce((sum, positions) => sum + positions.length, 0);
    const duplicateElements = duplicates.size;
    
    // Sort by number of occurrences (descending)
    const sortedDuplicates = Array.from(duplicates.entries())
        .sort((a, b) => b[1].length - a[1].length);
    
    resultsContainer.innerHTML = `
        <div class="row text-center mb-3">
            <div class="col-md-3">
                <div class="stats-card">
                    <div>Total Elements</div>
                    <div class="stats-value">${totalElements}</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="stats-card">
                    <div>Unique Elements</div>
                    <div class="stats-value">${uniqueElements}</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="stats-card">
                    <div>Duplicate Elements</div>
                    <div class="stats-value">${duplicateElements}</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="stats-card">
                    <div>Total Occurrences</div>
                    <div class="stats-value">${totalDuplicates}</div>
                </div>
            </div>
        </div>
        
        <div class="table-container">
            <table class="frequency-table table-animation">
                <thead>
                    <tr>
                        <th>Duplicate Element</th>
                        <th>Total Occurrences</th>
                        <th>Positions in Array</th>
                        <th>Duplicate Type</th>
                        <th>Visual Map</th>
                    </tr>
                </thead>
                <tbody>
                    ${sortedDuplicates.map(([element, positions]) => {
                        const occurrenceCount = positions.length;
                        const isMultiple = occurrenceCount > 2;
                        const typeText = isMultiple ? 'Multiple Duplicates' : 'Pair Duplicate';
                        const typeIcon = isMultiple ? 'fa-clone' : 'fa-copy';
                        
                        // Create visual representation
                        const visualMap = originalArrayForDuplicates.map((val, idx) => 
                            positions.includes(idx) ? 
                                `<span class="text-warning"><i class="fas fa-circle"></i></span>` : 
                                `<span class="text-muted"><i class="far fa-circle"></i></span>`
                        ).join(' ');
                        
                        return `
                            <tr class="frequency-duplicate">
                                <td><strong>${element}</strong></td>
                                <td>
                                    <span class="badge bg-warning">${occurrenceCount} occurrences</span>
                                </td>
                                <td>[${positions.join(', ')}]</td>
                                <td>
                                    <span class="text-warning">
                                        <i class="fas ${typeIcon} me-1"></i>${typeText}
                                    </span>
                                </td>
                                <td>
                                    <div style="font-size: 0.8rem; letter-spacing: 2px;">
                                        ${visualMap}
                                    </div>
                                </td>
                            </tr>
                        `;
                    }).join('')}
                    ${duplicates.size === 0 ? `
                        <tr class="frequency-unique">
                            <td colspan="5" class="text-center">
                                <i class="fas fa-check-circle text-success me-2"></i>
                                No duplicate elements found! All elements are unique.
                            </td>
                        </tr>
                    ` : ''}
                </tbody>
            </table>
        </div>
        
        ${duplicates.size > 0 ? `
            <div class="stats-highlight mt-3">
                <i class="fas fa-exclamation-triangle me-2"></i>
                Duplicate Analysis: Found ${duplicateElements} duplicate element(s) with ${totalDuplicates} total occurrences.
                ${sortedDuplicates[0] ? `Most duplicated: "${sortedDuplicates[0][0]}" (${sortedDuplicates[0][1].length} times)` : ''}
            </div>
        ` : `
            <div class="stats-highlight mt-3 bg-success">
                <i class="fas fa-check-circle me-2"></i>
                Excellent! No duplicate elements found. All ${uniqueElements} elements are unique.
            </div>
        `}
    `;
}

// NEW: Return to Original after Duplicates Detection
function returnToOriginalAfterDuplicates() {
    // Reset to original array
    myArray = [...originalArrayForDuplicates];
    originalArrayForDuplicates = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isFindDuplicatesRunning = false;
    
    logOperation('Duplicate detection completed - returned to original array', 'info');
    showNotification('Returned to original array after duplicate detection', 'success');
}
// NEW: First Non-Repeating Element Handler
function handleFirstNonRepeating() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isNonRepeatingRunning) {
        showNotification('Non-repeating element search is already in progress', 'warning');
        return;
    }
    
    isNonRepeatingRunning = true;
    
    // Store original array
    originalArrayForUniqueness = [...myArray];
    
    // Perform first non-repeating element search
    performFirstNonRepeatingSearch();
}

// NEW: Find Unique Elements Handler
// NEW: Find All Unique Elements Handler
function handleFindUniqueElements() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isUniqueElementsRunning) {
        showNotification('Unique elements analysis is already in progress', 'warning');
        return;
    }
    
    isUniqueElementsRunning = true;
    
    // Store original array
    originalArrayForUniqueness = [...myArray];
    
    // Show unique elements visualization with table
    showUniqueElementsVisualization();
}
// NEW: Show Unique Elements Visualization with Table
function showUniqueElementsVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find All Unique Elements</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalUniqueArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Unique Elements Analysis</div>
            <div class="transformed-array-container" id="transformedUniqueArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Unique Elements Algorithm:</strong> Finding all elements that appear exactly once in the array</p>
            <p class="mb-0" id="uniqueExplanation">Starting unique elements analysis...</p>
        </div>

        <!-- ADD THIS TABLE CONTAINER -->
        <div class="table-container mt-3" id="uniqueElementsTableContainer" style="display: none;">
            <h6 class="text-center mb-3">Unique Elements Analysis Table</h6>
            <table class="unique-elements-table table-animation">
                <thead>
                    <tr>
                        <th>Element</th>
                        <th>Frequency</th>
                        <th>Status</th>
                        <th>First Occurrence</th>
                    </tr>
                </thead>
                <tbody id="uniqueElementsTableBody">
                    <!-- Table rows will be inserted here dynamically -->
                </tbody>
            </table>
        </div>
        
        <div class="algorithm-steps mt-3" id="uniqueStepsContainer">
            <h6 class="text-center">Analysis Steps</h6>
            <div class="steps-container" id="uniqueSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Total Unique Elements</div>
            <div class="stats-value" id="uniqueCountValue">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterUnique" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForUniqueness, 'originalUniqueArray');
    renderArrayInContainer([...originalArrayForUniqueness], 'transformedUniqueArray');
    
    performUniqueElementsAnalysis();
}
// NEW: Perform Unique Elements Analysis with Table
function performUniqueElementsAnalysis() {
    const originalContainer = document.getElementById('originalUniqueArray');
    const transformedContainer = document.getElementById('transformedUniqueArray');
    const explanation = document.getElementById('uniqueExplanation');
    const stepsContainer = document.getElementById('uniqueSteps');
    const uniqueCountValue = document.getElementById('uniqueCountValue');
    const continueButton = document.getElementById('continueAfterUnique');
    const tableContainer = document.getElementById('uniqueElementsTableContainer');
    const tableBody = document.getElementById('uniqueElementsTableBody');
    
    const arr = [...originalArrayForUniqueness];
    let frequencyMap = new Map();
    let step = 0;
    
    // First pass: Count frequencies
    explanation.innerHTML = "Step 1: Counting frequency of each element...";
    
    function performAnalysisStep() {
        if (step === 0) {
            // Count frequencies
            arr.forEach(element => {
                frequencyMap.set(element, (frequencyMap.get(element) || 0) + 1);
            });
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Frequency counting completed
                </div>
            `;
            
            step++;
            setTimeout(performAnalysisStep, 1000);
            
        } else if (step === 1) {
            // Show the frequency table
            explanation.innerHTML = "Step 2: Displaying frequency analysis table...";
            
            // Populate the table
            tableBody.innerHTML = '';
            let uniqueCount = 0;
            
            frequencyMap.forEach((frequency, element) => {
                const row = document.createElement('tr');
                const status = frequency === 1 ? 'Unique' : 'Duplicate';
                const statusClass = frequency === 1 ? 'frequency-unique' : 'frequency-duplicate';
                
                // Find first occurrence index
                const firstIndex = arr.indexOf(element);
                
                row.innerHTML = `
                    <td>${element}</td>
                    <td>${frequency}</td>
                    <td class="${statusClass}">${status}</td>
                    <td>Index ${firstIndex}</td>
                `;
                tableBody.appendChild(row);
                
                if (frequency === 1) {
                    uniqueCount++;
                }
            });
            
            // Show the table
            tableContainer.style.display = 'block';
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 2:</strong> Frequency analysis table displayed
                </div>
            `;
            
            uniqueCountValue.textContent = uniqueCount;
            step++;
            setTimeout(performAnalysisStep, 2000);
            
        } else if (step === 2) {
            // Highlight unique elements in the array
            explanation.innerHTML = "Step 3: Highlighting unique elements in the array...";
            
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            let highlightedCount = 0;
            
            arr.forEach((element, index) => {
                if (frequencyMap.get(element) === 1) {
                    setTimeout(() => {
                        transformedElements[index].querySelector('.element-value').classList.add('unique-element');
                        highlightedCount++;
                        
                        if (highlightedCount === Array.from(frequencyMap).filter(([_, freq]) => freq === 1).length) {
                            step++;
                            setTimeout(performAnalysisStep, 1000);
                        }
                    }, index * 300);
                }
            });
            
        } else {
            // Analysis completed
            explanation.innerHTML = `<strong>Analysis Completed!</strong> Found ${uniqueCountValue.textContent} unique elements.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Unique elements analysis completed. ${uniqueCountValue.textContent} unique elements found.
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterUniqueAnalysis();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterUniqueAnalysis);
        }
    }
    
    // Start analysis
    performAnalysisStep();
}

// NEW: Perform First Non-Repeating Element Search with Animation
function performFirstNonRepeatingSearch() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find First Non-Repeating Element</h5>
        
        <div class="array-group">
            <div class="array-label">Array Analysis</div>
            <div class="original-array-container" id="nonRepeatingArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find the first element that appears only once in the array</p>
            <p class="mb-0" id="nonRepeatingExplanation">Starting analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="nonRepeatingStepsContainer">
            <h6 class="text-center">Analysis Steps</h6>
            <div class="steps-container" id="nonRepeatingSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>First Non-Repeating Element</div>
            <div class="stats-value" id="firstNonRepeatingResult">-</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Found at Index</div>
            <div class="stats-value" id="firstNonRepeatingIndex">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterNonRepeating" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForUniqueness, 'nonRepeatingArray');
    
    executeFirstNonRepeatingAlgorithm();
}

// NEW: Execute First Non-Repeating Algorithm
function executeFirstNonRepeatingAlgorithm() {
    const arrayContainer = document.getElementById('nonRepeatingArray');
    const explanation = document.getElementById('nonRepeatingExplanation');
    const stepsContainer = document.getElementById('nonRepeatingSteps');
    const resultElement = document.getElementById('firstNonRepeatingResult');
    const resultIndex = document.getElementById('firstNonRepeatingIndex');
    const continueButton = document.getElementById('continueAfterNonRepeating');
    
    const arr = [...originalArrayForUniqueness];
    const frequency = new Map();
    let currentIndex = 0;
    let step = 0;
    let foundElement = null;
    let foundIndex = -1;
    
    function executeStep() {
        if (currentIndex >= arr.length) {
            // Analysis completed - find first non-repeating
            explanation.innerHTML = 'Frequency analysis completed. Finding first non-repeating element...';
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step + 1}:</strong> Frequency analysis completed. Finding first element with count = 1
                </div>
            `;
            
            // Find first non-repeating element
            for (let i = 0; i < arr.length; i++) {
                if (frequency.get(arr[i]) === 1) {
                    foundElement = arr[i];
                    foundIndex = i;
                    break;
                }
            }
            
            setTimeout(() => {
                if (foundElement !== null) {
                    explanation.innerHTML = `<strong>Found!</strong> First non-repeating element: "${foundElement}" at index ${foundIndex}`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Result:</strong> First non-repeating element found: "${foundElement}" at index ${foundIndex}
                        </div>
                    `;
                    
                    // Highlight the found element
                    const elements = arrayContainer.querySelectorAll('.array-element');
                    elements[foundIndex].querySelector('.element-value').classList.add('non-repeating');
                    
                    resultElement.textContent = foundElement;
                    resultIndex.textContent = foundIndex;
                    
                } else {
                    explanation.innerHTML = '<strong>No non-repeating element found!</strong> All elements repeat.';
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Result:</strong> No non-repeating element found - all elements repeat at least once
                        </div>
                    `;
                    
                    resultElement.textContent = 'None';
                    resultIndex.textContent = '-1';
                }
                
                continueButton.style.display = 'block';
                
                // Auto-return after 5 seconds
                setTimeout(() => {
                    returnToOriginalAfterUniqueness();
                }, 5000);
                
                continueButton.addEventListener('click', returnToOriginalAfterUniqueness);
                
            }, 1500);
            
            return;
        }
        
        step++;
        const currentElement = arr[currentIndex];
        
        explanation.innerHTML = `Step ${step}: Analyzing element at index ${currentIndex}: "${currentElement}"`;
        
        // Highlight current element
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentValueDiv = elements[currentIndex].querySelector('.element-value');
        currentValueDiv.classList.add('checked-element');
        
        // Update frequency
        const currentCount = frequency.get(currentElement) || 0;
        frequency.set(currentElement, currentCount + 1);
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Element "${currentElement}" at index ${currentIndex} - Count: ${currentCount + 1}
            </div>
        `;
        
        // Check if this element repeats
        if (currentCount > 0) {
            // Mark as repeating
            setTimeout(() => {
                currentValueDiv.classList.remove('checked-element');
                currentValueDiv.classList.add('repeating');
                
                // Also mark previous occurrences
                for (let i = 0; i < currentIndex; i++) {
                    if (arr[i] === currentElement) {
                        elements[i].querySelector('.element-value').classList.add('repeating');
                    }
                }
                
                currentIndex++;
                executeStep();
            }, 1000);
        } else {
            setTimeout(() => {
                currentValueDiv.classList.remove('checked-element');
                currentIndex++;
                executeStep();
            }, 1000);
        }
    }
    
    // Start execution
    executeStep();
}

// NEW: Perform Unique Elements Search with Animation
function performUniqueElementsSearch() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find All Unique Elements</h5>
        
        <div class="array-group">
            <div class="array-label">Array Analysis</div>
            <div class="original-array-container" id="uniqueElementsArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find all elements that appear exactly once in the array</p>
            <p class="mb-0" id="uniqueElementsExplanation">Starting frequency analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="uniqueElementsStepsContainer">
            <h6 class="text-center">Analysis Steps</h6>
            <div class="steps-container" id="uniqueElementsSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Total Unique Elements Found</div>
            <div class="stats-value" id="uniqueElementsCount">0</div>
        </div>
        
        <div class="table-container mt-3" id="uniqueElementsTableContainer" style="display: none;">
            <h6 class="text-center">Unique Elements</h6>
            <table class="unique-elements-table">
                <thead>
                    <tr>
                        <th>Element</th>
                        <th>Index</th>
                        <th>Frequency</th>
                    </tr>
                </thead>
                <tbody id="uniqueElementsTableBody">
                </tbody>
            </table>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterUniqueElements" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForUniqueness, 'uniqueElementsArray');
    
    executeUniqueElementsAlgorithm();
}

// NEW: Execute Unique Elements Algorithm
function executeUniqueElementsAlgorithm() {
    const arrayContainer = document.getElementById('uniqueElementsArray');
    const explanation = document.getElementById('uniqueElementsExplanation');
    const stepsContainer = document.getElementById('uniqueElementsSteps');
    const countElement = document.getElementById('uniqueElementsCount');
    const tableContainer = document.getElementById('uniqueElementsTableContainer');
    const tableBody = document.getElementById('uniqueElementsTableBody');
    const continueButton = document.getElementById('continueAfterUniqueElements');
    
    const arr = [...originalArrayForUniqueness];
    const frequency = new Map();
    const elementIndices = new Map(); // Store first occurrence index for each element
    let currentIndex = 0;
    let step = 0;
    const uniqueElements = [];
    
    function executeStep() {
        if (currentIndex >= arr.length) {
            // Analysis completed - find unique elements
            explanation.innerHTML = 'Frequency analysis completed. Identifying unique elements...';
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step + 1}:</strong> Frequency analysis completed. Finding elements with count = 1
                </div>
            `;
            
            // Find all unique elements
            for (let i = 0; i < arr.length; i++) {
                if (frequency.get(arr[i]) === 1) {
                    uniqueElements.push({
                        element: arr[i],
                        index: i,
                        frequency: 1
                    });
                }
            }
            
            setTimeout(() => {
                explanation.innerHTML = `<strong>Analysis Complete!</strong> Found ${uniqueElements.length} unique element(s)`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Result:</strong> Found ${uniqueElements.length} unique element(s) in the array
                    </div>
                `;
                
                // Highlight all unique elements in the array
                const elements = arrayContainer.querySelectorAll('.array-element');
                uniqueElements.forEach(unique => {
                    elements[unique.index].querySelector('.element-value').classList.add('unique-element');
                });
                
                countElement.textContent = uniqueElements.length;
                
                // Display results in table
                if (uniqueElements.length > 0) {
                    tableBody.innerHTML = '';
                    uniqueElements.forEach(unique => {
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td>${unique.element}</td>
                            <td>${unique.index}</td>
                            <td>${unique.frequency}</td>
                        `;
                        tableBody.appendChild(row);
                    });
                    tableContainer.style.display = 'block';
                }
                
                continueButton.style.display = 'block';
                
                // Auto-return after 5 seconds
                setTimeout(() => {
                    returnToOriginalAfterUniqueness();
                }, 5000);
                
                continueButton.addEventListener('click', returnToOriginalAfterUniqueness);
                
            }, 1500);
            
            return;
        }
        
        step++;
        const currentElement = arr[currentIndex];
        
        explanation.innerHTML = `Step ${step}: Analyzing element at index ${currentIndex}: "${currentElement}"`;
        
        // Highlight current element
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentValueDiv = elements[currentIndex].querySelector('.element-value');
        currentValueDiv.classList.add('checked-element');
        
        // Update frequency and store first occurrence index
        const currentCount = frequency.get(currentElement) || 0;
        frequency.set(currentElement, currentCount + 1);
        
        if (currentCount === 0) {
            elementIndices.set(currentElement, currentIndex);
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Element "${currentElement}" at index ${currentIndex} - Count: ${currentCount + 1}
            </div>
        `;
        
        // Check if this element repeats
        if (currentCount > 0) {
            // Mark as repeating
            setTimeout(() => {
                currentValueDiv.classList.remove('checked-element');
                currentValueDiv.classList.add('repeating');
                
                // Also mark previous occurrences
                for (let i = 0; i < currentIndex; i++) {
                    if (arr[i] === currentElement) {
                        elements[i].querySelector('.element-value').classList.add('repeating');
                    }
                }
                
                currentIndex++;
                executeStep();
            }, 1000);
        } else {
            setTimeout(() => {
                currentValueDiv.classList.remove('checked-element');
                currentIndex++;
                executeStep();
            }, 1000);
        }
    }
    
    // Start execution
    executeStep();
}

// NEW: Return to Original after Uniqueness Operations
function returnToOriginalAfterUniqueness() {
    // Reset to original array
    myArray = [...originalArrayForUniqueness];
    originalArrayForUniqueness = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset states
    isNonRepeatingRunning = false;
    isUniqueElementsRunning = false;
    
    logOperation('Uniqueness operation completed - returned to original array', 'info');
    showNotification('Returned to original array after uniqueness analysis', 'success');
}
// NEW: Find Majority Element Handler
function handleFindMajorityElement() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isMajoritySearchRunning) {
        showNotification('Majority element search is already in progress', 'warning');
        return;
    }
    
    // Store original array
    originalArrayForMajority = [...myArray];
    
    // Show majority element visualization
    showMajorityElementVisualization();
}
// NEW: Show Majority Element Visualization
function showMajorityElementVisualization() {
    isMajoritySearchRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Boyer-Moore Voting Algorithm - Find Majority Element</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalMajorityArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Algorithm Process</div>
            <div class="transformed-array-container" id="processMajorityArray"></div>
        </div>
        
        <div class="majority-explanation">
            <p class="mb-2"><strong>Boyer-Moore Voting Algorithm:</strong> Finds element appearing more than n/2 times</p>
            <p class="mb-0" id="majorityExplanation">Initializing algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="majorityStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="majoritySteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Current Candidate</div>
            <div class="stats-value" id="currentCandidate">-</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Current Count</div>
            <div class="stats-value" id="currentCount">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Majority Element</div>
            <div class="stats-value" id="majorityElement">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMajority" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForMajority, 'originalMajorityArray');
    renderArrayInContainer([...originalArrayForMajority], 'processMajorityArray');
    
    performMajorityAlgorithmAnimation();
}
// NEW: Perform Majority Algorithm Animation
function performMajorityAlgorithmAnimation() {
    const originalContainer = document.getElementById('originalMajorityArray');
    const processContainer = document.getElementById('processMajorityArray');
    const explanation = document.getElementById('majorityExplanation');
    const stepsContainer = document.getElementById('majoritySteps');
    const currentCandidate = document.getElementById('currentCandidate');
    const currentCount = document.getElementById('currentCount');
    const majorityElement = document.getElementById('majorityElement');
    const continueButton = document.getElementById('continueAfterMajority');
    
    const arr = [...originalArrayForMajority];
    let candidate = null;
    let count = 0;
    let step = 0;
    
    // Phase 1: Find candidate
    function performPhase1Step(i) {
        if (i >= arr.length) {
            // Phase 1 completed
            explanation.innerHTML = `<strong>Phase 1 Completed!</strong> Candidate found: ${candidate || 'None'}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Phase 1 Complete:</strong> Candidate = ${candidate || 'None'}, Final Count = ${count}
                </div>
            `;
            
            // Proceed to verification phase
            setTimeout(() => {
                performVerificationPhase();
            }, 2000);
            
            return;
        }
        
        step++;
        
        if (step === 1) {
            // First element
            explanation.innerHTML = `Step ${step}: Initialize with first element = "${arr[i]}"`;
            
            candidate = arr[i];
            count = 1;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Initialize candidate = "${candidate}", count = ${count}
                </div>
            `;
            
            updateDisplay();
            highlightCurrentElement(i, 'initialize');
            
        } else {
            explanation.innerHTML = `Step ${step}: Processing element [${i}] = "${arr[i]}"`;
            
            const processElements = processContainer.querySelectorAll('.array-element');
            const currentElement = processElements[i].querySelector('.element-value');
            
            if (count === 0) {
                // New candidate
                explanation.innerHTML = `Step ${step}: Count is 0, new candidate = "${arr[i]}"`;
                
                candidate = arr[i];
                count = 1;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> Count was 0  New candidate = "${candidate}", count = ${count}
                    </div>
                `;
                
                currentElement.classList.add('majority-candidate');
                
            } else if (arr[i] === candidate) {
                // Same candidate, increase count
                explanation.innerHTML = `Step ${step}: Same as candidate, increasing count`;
                
                count++;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> Element matches candidate  count++ = ${count}
                    </div>
                `;
                
                currentElement.classList.add('majority-count-increase');
                
            } else {
                // Different element, decrease count
                explanation.innerHTML = `Step ${step}: Different from candidate, decreasing count`;
                
                count--;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> Element different  count-- = ${count}
                    </div>
                `;
                
                currentElement.classList.add('majority-count-decrease');
            }
            
            updateDisplay();
            highlightCurrentElement(i, 'process');
        }
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Continue to next element after delay
        setTimeout(() => {
            performPhase1Step(i + 1);
        }, 2000);
    }
    
    // Phase 2: Verify candidate
    function performVerificationPhase() {
        if (candidate === null) {
            explanation.innerHTML = `<strong>No candidate found!</strong> Array has no majority element.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Verification:</strong> No candidate found  No majority element exists
                </div>
            `;
            
            majorityElement.textContent = 'None';
            completeAlgorithm();
            return;
        }
        
        explanation.innerHTML = `<strong>Phase 2:</strong> Verifying candidate "${candidate}"`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Phase 2:</strong> Verify if "${candidate}" appears more than n/2 times (${arr.length}/2 = ${Math.floor(arr.length/2)})
            </div>
        `;
        
        let actualCount = 0;
        let verificationStep = 0;
        
        function performVerificationStep(i) {
            if (i >= arr.length) {
                // Verification completed
                const isMajority = actualCount > Math.floor(arr.length / 2);
                
                if (isMajority) {
                    explanation.innerHTML = `<strong>Verification Complete!</strong> "${candidate}" is majority element (appears ${actualCount} times > ${Math.floor(arr.length/2)})`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Verification Result:</strong> "${candidate}" appears ${actualCount} times > ${Math.floor(arr.length/2)}  MAJORITY ELEMENT FOUND!
                        </div>
                    `;
                    
                    majorityElement.textContent = `${candidate} (${actualCount} occurrences)`;
                    highlightMajorityElements();
                    
                } else {
                    explanation.innerHTML = `<strong>Verification Complete!</strong> "${candidate}" is not majority element (appears ${actualCount} times  ${Math.floor(arr.length/2)})`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Verification Result:</strong> "${candidate}" appears ${actualCount} times  ${Math.floor(arr.length/2)}  NO MAJORITY ELEMENT
                        </div>
                    `;
                    
                    majorityElement.textContent = 'None';
                }
                
                completeAlgorithm();
                return;
            }
            
            verificationStep++;
            
            if (arr[i] === candidate) {
                actualCount++;
                
                explanation.innerHTML = `Verification Step ${verificationStep}: [${i}] = "${arr[i]}" matches candidate  count = ${actualCount}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step ${arr[i] === candidate ? 'active' : ''}">
                        <strong>Verification ${verificationStep}:</strong> [${i}] = "${arr[i]}" ${arr[i] === candidate ? 'MATCHES' : 'different'}  count = ${actualCount}
                    </div>
                `;
                
                const processElements = processContainer.querySelectorAll('.array-element');
                processElements[i].querySelector('.element-value').classList.add('majority-current');
            }
            
            // Scroll steps container
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            // Continue to next element after delay
            setTimeout(() => {
                performVerificationStep(i + 1);
            }, 1500);
        }
        
        performVerificationStep(0);
    }
    
    function highlightCurrentElement(index, phase) {
        const processElements = processContainer.querySelectorAll('.array-element');
        
        // Remove previous highlights
        processElements.forEach(el => {
            const valueDiv = el.querySelector('.element-value');
            valueDiv.classList.remove(
                'majority-current', 
                'majority-candidate', 
                'majority-count-increase', 
                'majority-count-decrease'
            );
        });
        
        // Highlight current element
        if (index < processElements.length) {
            const currentElement = processElements[index].querySelector('.element-value');
            currentElement.classList.add('majority-current');
        }
        
        // Highlight candidate elements
        if (candidate) {
            processElements.forEach((el, i) => {
                if (i <= index && arr[i] === candidate) {
                    el.querySelector('.element-value').classList.add('majority-candidate');
                }
            });
        }
    }
    
    function highlightMajorityElements() {
        const processElements = processContainer.querySelectorAll('.array-element');
        
        processElements.forEach((el, i) => {
            if (arr[i] === candidate) {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('majority-found');
                }, (i * 100));
            }
        });
    }
    
    function updateDisplay() {
        currentCandidate.textContent = candidate || '-';
        currentCount.textContent = count;
    }
    
    function completeAlgorithm() {
        continueButton.style.display = 'block';
        
        // Auto-return to original after 5 seconds
        setTimeout(() => {
            returnToOriginalAfterMajority();
        }, 5000);
        
        continueButton.addEventListener('click', returnToOriginalAfterMajority);
    }
    
    // Start phase 1
    performPhase1Step(0);
}
// NEW: Return to Original after Majority Search
function returnToOriginalAfterMajority() {
    // Reset to original array
    myArray = [...originalArrayForMajority];
    originalArrayForMajority = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMajoritySearchRunning = false;
    
    logOperation('Majority element search completed - returned to original array', 'info');
    showNotification('Returned to original array after majority element search', 'success');
}
// NEW: Dutch National Flag Sort Handler
function handleDutchNationalFlagSort() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isDutchSortRunning) {
        showNotification('A Dutch National Flag sort is already in progress', 'warning');
        return;
    }
    
    // Validate that array contains only 0s, 1s, and 2s
    let isValid = true;
    for (let i = 0; i < myArray.length; i++) {
        const value = myArray[i].toString().trim();
        if (value !== '0' && value !== '1' && value !== '2') {
            isValid = false;
            break;
        }
    }
    
    if (!isValid) {
        showNotification('Please enter elements containing only 0s, 1s, and 2s', 'danger');
        return;
    }
    
    isDutchSortRunning = true;
    sortDutchNationalFlagBtn.disabled = true;
    
    // Store original array
    originalArrayForDutch = [...myArray];
    
    // Show Dutch National Flag visualization
    showDutchNationalFlagVisualization();
}
// NEW: Show Dutch National Flag Visualization
function showDutchNationalFlagVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Dutch National Flag Problem - Sort 0s, 1s, 2s</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array (0s, 1s, 2s)</div>
            <div class="original-array-container" id="originalDutchArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-flag"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Sorted Array (Three-Pointer Technique)</div>
            <div class="transformed-array-container" id="transformedDutchArray"></div>
        </div>
        
        <div class="dutch-explanation">
            <p class="mb-2"><strong>Dutch National Flag Algorithm:</strong> Sort array in single pass using three pointers (low, mid, high)</p>
            <p class="mb-0" id="dutchExplanation">Starting Dutch National Flag sort...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="dutchStepsContainer">
            <h6 class="text-center">Three-Pointer Technique Steps</h6>
            <div class="steps-container" id="dutchSteps"></div>
        </div>
        
        <div class="pointers-info mt-3" id="pointersInfo">
            <div class="row text-center">
                <div class="col-4">
                    <div class="pointer-item dutch-low p-2 rounded">Low Pointer</div>
                </div>
                <div class="col-4">
                    <div class="pointer-item dutch-mid p-2 rounded">Mid Pointer</div>
                </div>
                <div class="col-4">
                    <div class="pointer-item dutch-high p-2 rounded">High Pointer</div>
                </div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterDutchSort" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForDutch, 'originalDutchArray');
    renderArrayInContainer([...originalArrayForDutch], 'transformedDutchArray');
    
    performDutchNationalFlagSort();
}
// NEW: Perform Dutch National Flag Sort with Visualization
function performDutchNationalFlagSort() {
    const originalContainer = document.getElementById('originalDutchArray');
    const transformedContainer = document.getElementById('transformedDutchArray');
    const explanation = document.getElementById('dutchExplanation');
    const stepsContainer = document.getElementById('dutchSteps');
    const continueButton = document.getElementById('continueAfterDutchSort');
    
    const array = [...originalArrayForDutch].map(val => parseInt(val));
    let low = 0;
    let mid = 0;
    let high = array.length - 1;
    let stepCount = 0;
    
    function performDutchStep() {
        if (mid > high) {
            // Sorting completed
            explanation.innerHTML = `<strong>Dutch National Flag Sort Completed!</strong> Array sorted in single pass.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${++stepCount}:</strong> Sorting Complete! All elements are in correct positions.
                </div>
            `;
            
            // Highlight all elements as sorted
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                const valueDiv = el.querySelector('.element-value');
                setTimeout(() => {
                    valueDiv.classList.add('dutch-sorted');
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return to original after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterDutchSort();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterDutchSort);
            
            return;
        }
        
        stepCount++;
        const currentValue = array[mid];
        
        // Update pointers visualization
        updateDutchPointers(low, mid, high);
        
        switch (currentValue) {
            case 0:
                // Swap array[low] and array[mid], increment both
                explanation.innerHTML = `Step ${stepCount}: Found 0 at mid=${mid}. Swapping with low=${low}`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${stepCount}:</strong> array[${mid}] = 0  Swap with array[${low}]  low++, mid++
                    </div>
                `;
                
                performDutchSwap(low, mid, () => {
                    // Perform the swap
                    [array[low], array[mid]] = [array[mid], array[low]];
                    low++;
                    mid++;
                    setTimeout(performDutchStep, 1500);
                });
                break;
                
            case 1:
                // Just increment mid
                explanation.innerHTML = `Step ${stepCount}: Found 1 at mid=${mid}. No swap needed, mid++`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${stepCount}:</strong> array[${mid}] = 1  No swap needed  mid++
                    </div>
                `;
                
                // Highlight mid element as correct (1)
                const elements = transformedContainer.querySelectorAll('.array-element');
                const midElement = elements[mid].querySelector('.element-value');
                midElement.classList.add('dutch-mid');
                
                setTimeout(() => {
                    midElement.classList.remove('dutch-mid');
                    mid++;
                    performDutchStep();
                }, 1000);
                break;
                
            case 2:
                // Swap array[mid] and array[high], decrement high
                explanation.innerHTML = `Step ${stepCount}: Found 2 at mid=${mid}. Swapping with high=${high}`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${stepCount}:</strong> array[${mid}] = 2  Swap with array[${high}]  high--
                    </div>
                `;
                
                performDutchSwap(mid, high, () => {
                    // Perform the swap
                    [array[mid], array[high]] = [array[high], array[mid]];
                    high--;
                    setTimeout(performDutchStep, 1500);
                });
                break;
        }
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
    }
    
    function performDutchSwap(i, j, callback) {
        const elements = transformedContainer.querySelectorAll('.array-element');
        const elementI = elements[i].querySelector('.element-value');
        const elementJ = elements[j].querySelector('.element-value');
        
        elementI.classList.add('dutch-swap');
        elementJ.classList.add('dutch-swap');
        
        // Calculate swap distance for animation
        const rectI = elements[i].getBoundingClientRect();
        const rectJ = elements[j].getBoundingClientRect();
        const swapDistance = rectJ.left - rectI.left;
        
        elementI.style.setProperty('--swap-distance', `${swapDistance}px`);
        elementJ.style.setProperty('--swap-distance', `-${swapDistance}px`);
        
        setTimeout(() => {
            elementI.classList.add('swap-animation');
            elementJ.classList.add('swap-animation');
            
            setTimeout(() => {
                // Update the transformed array display
                renderArrayInContainer(array.map(val => val.toString()), 'transformedDutchArray');
                
                // Remove swap highlights
                elementI.classList.remove('dutch-swap', 'swap-animation');
                elementJ.classList.remove('dutch-swap', 'swap-animation');
                
                callback();
            }, 1000);
        }, 500);
    }
    
    function updateDutchPointers(low, mid, high) {
        const elements = transformedContainer.querySelectorAll('.array-element');
        
        // Reset all pointer highlights
        elements.forEach(el => {
            const valueDiv = el.querySelector('.element-value');
            valueDiv.classList.remove('dutch-low', 'dutch-mid', 'dutch-high');
        });
        
        // Highlight current pointers
        if (low < elements.length) {
            elements[low].querySelector('.element-value').classList.add('dutch-low');
        }
        if (mid < elements.length) {
            elements[mid].querySelector('.element-value').classList.add('dutch-mid');
        }
        if (high < elements.length && high >= 0) {
            elements[high].querySelector('.element-value').classList.add('dutch-high');
        }
    }
    
    // Start the Dutch National Flag sort
    performDutchStep();
}
// NEW: Return to Original after Dutch National Flag Sort
function returnToOriginalAfterDutchSort() {
    // Reset to original array
    myArray = [...originalArrayForDutch];
    originalArrayForDutch = [];
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isDutchSortRunning = false;
    sortDutchNationalFlagBtn.disabled = false;
    
    // Show original positions with animation
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation('Dutch National Flag sort demonstration completed - returned to original array', 'info');
    showNotification('Returned to original array after Dutch National Flag sort', 'success');
}
// NEW: Shift Left After Deletion Handler
function handleShiftLeftAfterDelete() {
    const index = parseInt(shiftDeleteIndex.value);
    
    // Validation
    if (isNaN(index) || index < 0 || index >= myArray.length) {
        showNotification(`Please enter a valid index between 0 and ${myArray.length - 1}`, 'danger');
        shiftDeleteIndex.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isShiftDeleteRunning) {
        showNotification('A shift delete operation is already in progress', 'warning');
        return;
    }
    
    isShiftDeleteRunning = true;
    shiftLeftAfterDeleteBtn.disabled = true;
    
    // Store original array
    originalArrayBeforeShiftDelete = [...myArray];
    
    // Show shift delete visualization
    showShiftDeleteVisualization(index);
}
// NEW: Show Shift Delete Visualization
function showShiftDeleteVisualization(index) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Shift Left After Deletion</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalShiftDeleteArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After Deletion & Shift Left</div>
            <div class="transformed-array-container" id="transformedShiftDeleteArray"></div>
        </div>
        
        <div class="shift-delete-explanation">
            <p class="mb-2"><strong>Operation:</strong> Delete element at index ${index} and shift all subsequent elements left</p>
            <p class="mb-0" id="shiftDeleteExplanation">Starting shift left after deletion...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="shiftDeleteStepsContainer">
            <h6 class="text-center">Shift Left After Deletion Steps</h6>
            <div class="steps-container" id="shiftDeleteSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterShiftDelete" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayBeforeShiftDelete, 'originalShiftDeleteArray');
    renderArrayInContainer([...originalArrayBeforeShiftDelete], 'transformedShiftDeleteArray');
    
    performShiftDeleteAnimation(index);
}
// NEW: Perform Shift Delete Animation
function performShiftDeleteAnimation(index) {
    const originalContainer = document.getElementById('originalShiftDeleteArray');
    const transformedContainer = document.getElementById('transformedShiftDeleteArray');
    const explanation = document.getElementById('shiftDeleteExplanation');
    const stepsContainer = document.getElementById('shiftDeleteSteps');
    const continueButton = document.getElementById('continueAfterShiftDelete');
    
    const array = [...originalArrayBeforeShiftDelete];
    const deletedValue = array[index];
    let currentStep = 0;
    
    function performShiftDeleteStep() {
        if (currentStep === 0) {
            // Step 1: Highlight the element to be deleted
            explanation.innerHTML = `<strong>Step 1:</strong> Identify element at index ${index} for deletion`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Mark element at index ${index} ("${deletedValue}") for deletion
                </div>
            `;
            
            const originalElements = originalContainer.querySelectorAll('.array-element');
            const targetElement = originalElements[index].querySelector('.element-value');
            targetElement.classList.add('shift-delete-target');
            
            currentStep++;
            setTimeout(performShiftDeleteStep, 1500);
            
        } else if (currentStep === 1) {
            // Step 2: Show deletion and start shifting
            explanation.innerHTML = `<strong>Step 2:</strong> Delete element and begin shifting left`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 2:</strong> Remove element at index ${index} - creating gap
                </div>
            `;
            
            // Create new array with the element removed
            const newArray = [...array];
            newArray.splice(index, 1);
            
            // Update transformed array (show gap or placeholder)
            const tempArray = [...array];
            tempArray[index] = ''; // Show deletion marker
            renderArrayInContainer(tempArray, 'transformedShiftDeleteArray');
            
            // Highlight the deletion
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const deletedElement = transformedElements[index].querySelector('.element-value');
            deletedElement.classList.add('shift-delete-target');
            
            currentStep++;
            setTimeout(performShiftDeleteStep, 1500);
            
        } else if (currentStep === 2) {
            // Step 3: Animate shifting of each subsequent element
            explanation.innerHTML = `<strong>Step 3:</strong> Shifting elements left to fill the gap`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 3:</strong> Shift elements from index ${index + 1} to ${array.length - 1} left by one position
                </div>
            `;
            
            animateElementShifting(index, array, stepsContainer, explanation, () => {
                currentStep++;
                performShiftDeleteStep();
            });
            
        } else if (currentStep === 3) {
            // Step 4: Show final result
            explanation.innerHTML = `<strong>Step 4:</strong> Shift left completed - array size reduced by 1`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 4:</strong> Final array after deletion and shift left operation
                </div>
            `;
            
            // Show final array
            const finalArray = [...array];
            finalArray.splice(index, 1);
            renderArrayInContainer(finalArray, 'transformedShiftDeleteArray');
            
            // Highlight all shifted elements
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            for (let i = index; i < transformedElements.length; i++) {
                const valueDiv = transformedElements[i].querySelector('.element-value');
                setTimeout(() => {
                    valueDiv.classList.add('shift-left-completed');
                }, i * 100);
            }
            
            // Update the actual array
            myArray = finalArray;
            updateStats();
            
            logOperation(`Deleted element at index ${index} ("${deletedValue}") and shifted left`, 'warning');
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterShiftDelete();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterShiftDelete);
        }
    }
    
    // Start the animation
    performShiftDeleteStep();
}
// NEW: Animate Element Shifting
function animateElementShifting(startIndex, originalArray, stepsContainer, explanation, callback) {
    const transformedContainer = document.getElementById('transformedShiftDeleteArray');
    const n = originalArray.length;
    
    let currentShiftIndex = startIndex + 1;
    
    function shiftNextElement() {
        if (currentShiftIndex >= n) {
            // All elements shifted
            callback();
            return;
        }
        
        explanation.innerHTML = `<strong>Step 3:</strong> Shifting element from index ${currentShiftIndex} to ${currentShiftIndex - 1}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Shift:</strong> Move element "${originalArray[currentShiftIndex]}" from index ${currentShiftIndex} to ${currentShiftIndex - 1}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Create temporary array showing current shift
        const tempArray = [...originalArray];
        for (let i = startIndex; i < currentShiftIndex; i++) {
            tempArray[i] = originalArray[i + 1];
        }
        tempArray[currentShiftIndex] = '___'; // Show empty slot
        
        renderArrayInContainer(tempArray, 'transformedShiftDeleteArray');
        
        // Highlight the moving element
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        if (currentShiftIndex - 1 < transformedElements.length) {
            const movingElement = transformedElements[currentShiftIndex - 1].querySelector('.element-value');
            movingElement.classList.add('shift-left-moving');
        }
        
        currentShiftIndex++;
        setTimeout(shiftNextElement, 1000);
    }
    
    shiftNextElement();
}
// NEW: Return to Original after Shift Delete
function returnToOriginalAfterShiftDelete() {
    // Reset to original array
    myArray = [...originalArrayBeforeShiftDelete];
    originalArrayBeforeShiftDelete = [];
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isShiftDeleteRunning = false;
    shiftLeftAfterDeleteBtn.disabled = false;
    shiftDeleteIndex.value = '';
    
    // Show original array with animation
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation('Returned to original array after shift delete demonstration', 'info');
    showNotification('Returned to original array', 'success');
}
// NEW: Find Pivot in Rotated Array Handler
function handleFindPivot() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - pivot is the element itself', 'info');
        highlightElement(0, 'search');
        return;
    }
    
    if (isPivotSearchRunning) {
        showNotification('A pivot search is already in progress', 'warning');
        return;
    }
    
    isPivotSearchRunning = true;
    findPivotBtn.disabled = true;
    
    // Store original array
    originalArrayForPivot = [...myArray];
    
    // Check if array is sorted and rotated
    if (!isArraySortedAndRotated(myArray)) {
        showNotification('Array is not rotated. Auto-rotating for pivot search...', 'warning');
        performAutoRotation();
    } else {
        // Array is already rotated, proceed with pivot search
        performPivotSearch();
    }
}

// NEW: Check if array is sorted and rotated
function isArraySortedAndRotated(arr) {
    if (arr.length <= 1) return true;
    
    // Count how many times the array decreases (should be exactly 1 for a rotated sorted array)
    let decreaseCount = 0;
    for (let i = 1; i < arr.length; i++) {
        const current = parseFloat(arr[i]);
        const prev = parseFloat(arr[i-1]);
        
        if (!isNaN(current) && !isNaN(prev)) {
            if (current < prev) decreaseCount++;
        } else {
            if (arr[i] < arr[i-1]) decreaseCount++;
        }
    }
    
    // Check first and last elements
    const first = parseFloat(arr[0]);
    const last = parseFloat(arr[arr.length - 1]);
    
    if (!isNaN(first) && !isNaN(last)) {
        if (first < last) decreaseCount++;
    } else {
        if (arr[0] < arr[arr.length - 1]) decreaseCount++;
    }
    
    return decreaseCount === 1;
}

// NEW: Perform Auto Rotation
function performAutoRotation() {
    const rotationPoint = Math.floor(Math.random() * (myArray.length - 1)) + 1;
    
    // Create rotated array
    const rotatedArray = [
        ...myArray.slice(rotationPoint),
        ...myArray.slice(0, rotationPoint)
    ];
    
    // Show rotation animation
    showRotationAnimation(rotationPoint, rotatedArray);
}

// NEW: Show Rotation Animation
function showRotationAnimation(rotationPoint, rotatedArray) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Auto-Rotating Array for Pivot Search</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalRotationArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-sync-alt fa-spin"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Rotated Array</div>
            <div class="transformed-array-container" id="transformedRotationArray"></div>
        </div>
        
        <div class="pivot-explanation">
            <p class="mb-2"><strong>Rotation Point:</strong> Index ${rotationPoint}</p>
            <p class="mb-0" id="rotationExplanation">Rotating array for pivot search demonstration...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="rotationStepsContainer">
            <h6 class="text-center">Rotation Steps</h6>
            <div class="steps-container" id="rotationSteps"></div>
        </div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForPivot, 'originalRotationArray');
    renderArrayInContainer(new Array(originalArrayForPivot.length).fill('?'), 'transformedRotationArray');
    
    performStepByStepRotation(rotationPoint, rotatedArray);
}

// NEW: Perform Step-by-Step Rotation
function performStepByStepRotation(rotationPoint, rotatedArray) {
    const originalContainer = document.getElementById('originalRotationArray');
    const transformedContainer = document.getElementById('transformedRotationArray');
    const explanation = document.getElementById('rotationExplanation');
    const stepsContainer = document.getElementById('rotationSteps');
    
    let currentStep = 0;
    
    function performRotationStep(index) {
        if (index >= rotatedArray.length) {
            // Rotation completed
            explanation.innerHTML = `<strong>Rotation Complete!</strong> Array rotated at index ${rotationPoint}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${currentStep}:</strong> Rotation completed! Array is now properly rotated.
                </div>
            `;
            
            // Update the actual array and proceed with pivot search
            setTimeout(() => {
                myArray = rotatedArray;
                removeDualVisualization();
                performPivotSearch();
            }, 2000);
            
            return;
        }
        
        // Calculate original index for this position in rotated array
        const originalIndex = (index < myArray.length - rotationPoint) ? 
            rotationPoint + index : 
            index - (myArray.length - rotationPoint);
        
        // Update step explanation
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentStep}:</strong> 
                Position [${index}]  Original [${originalIndex}] = "${originalArrayForPivot[originalIndex]}"
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Highlight original element being moved
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const originalValueDiv = originalElements[originalIndex].querySelector('.element-value');
        originalValueDiv.classList.add('rotation-highlight');
        
        // After a delay, update the rotated array
        setTimeout(() => {
            // Update rotated array element
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const transformedValueDiv = transformedElements[index].querySelector('.element-value');
            transformedValueDiv.textContent = rotatedArray[index];
            transformedValueDiv.classList.add('rotation-highlight');
            
            // Remove highlight from original element
            originalValueDiv.classList.remove('rotation-highlight');
            
            // Remove highlight from transformed element after animation
            setTimeout(() => {
                transformedValueDiv.classList.remove('rotation-highlight');
            }, 1000);
            
            // Move to next step
            currentStep++;
            performRotationStep(index + 1);
        }, 1000);
    }
    
    // Start rotation process
    performRotationStep(0);
}

// NEW: Perform Pivot Search with Visualization
function performPivotSearch() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find Pivot in Rotated Sorted Array</h5>
        
        <div class="array-group">
            <div class="array-label">Rotated Array</div>
            <div class="original-array-container" id="pivotSearchArray"></div>
        </div>
        
        <div class="pivot-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Binary Search for Pivot (Smallest Element)</p>
            <p class="mb-0" id="pivotExplanation">Starting pivot search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="pivotStepsContainer">
            <h6 class="text-center">Pivot Search Steps</h6>
            <div class="steps-container" id="pivotSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPivot" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(myArray, 'pivotSearchArray');
    
    performBinaryPivotSearch(0, myArray.length - 1);
}

// NEW: Perform Binary Pivot Search with Animation
function performBinaryPivotSearch(left, right) {
    const arrayContainer = document.getElementById('pivotSearchArray');
    const explanation = document.getElementById('pivotExplanation');
    const stepsContainer = document.getElementById('pivotSteps');
    const continueButton = document.getElementById('continueAfterPivot');
    
    // Convert array to numbers for comparison
    const numArray = myArray.map(val => parseFloat(val));
    const isNumeric = !numArray.some(isNaN);
    
    function searchPivot(low, high, stepCount) {
        if (low > high) {
            // Should not happen in a properly rotated sorted array
            explanation.innerHTML = `<strong>Error:</strong> Pivot not found. Array may not be properly rotated.`;
            resetPivotSearchState();
            return;
        }
        
        if (low === high) {
            // Pivot found
            const pivotIndex = low;
            const pivotValue = myArray[pivotIndex];
            
            // Highlight the pivot
            highlightPivotFound(pivotIndex, pivotValue);
            
            explanation.innerHTML = `<strong>Pivot Found!</strong> Smallest element at index ${pivotIndex}: ${pivotValue}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${stepCount}:</strong> 
                    Pivot FOUND! Index [${pivotIndex}] = "${pivotValue}" is the smallest element
                </div>
            `;
            
            logOperation(`Found pivot at index ${pivotIndex} with value "${pivotValue}"`, 'success');
            
            continueButton.style.display = 'block';
            continueButton.addEventListener('click', returnToOriginalAfterPivot);
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterPivot();
            }, 5000);
            
            return;
        }
        
        const mid = Math.floor((low + high) / 2);
        
        // Update explanation
        explanation.innerHTML = `Searching: low=${low}, high=${high}, mid=${mid}`;
        
        // Highlight current search space
        highlightPivotSearchSpace(low, high, mid);
        
        // Add step to steps container
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${stepCount}:</strong> 
                low=[${low}]="${myArray[low]}", high=[${high}]="${myArray[high]}", mid=[${mid}]="${myArray[mid]}"
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Compare mid element with high element
        setTimeout(() => {
            let comparisonText = '';
            let newLow = low, newHigh = high;
            
            if (isNumeric) {
                if (numArray[mid] > numArray[high]) {
                    comparisonText = `mid(${numArray[mid]}) > high(${numArray[high]})  pivot in right half`;
                    newLow = mid + 1;
                } else {
                    comparisonText = `mid(${numArray[mid]})  high(${numArray[high]})  pivot in left half`;
                    newHigh = mid;
                }
            } else {
                if (myArray[mid] > myArray[high]) {
                    comparisonText = `mid("${myArray[mid]}") > high("${myArray[high]}")  pivot in right half`;
                    newLow = mid + 1;
                } else {
                    comparisonText = `mid("${myArray[mid]}")  high("${myArray[high]}")  pivot in left half`;
                    newHigh = mid;
                }
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Comparison:</strong> ${comparisonText}
                </div>
            `;
            
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            // Continue search with new bounds
            setTimeout(() => {
                searchPivot(newLow, newHigh, stepCount + 1);
            }, 1500);
            
        }, 1500);
    }
    
    // Start pivot search
    searchPivot(left, right, 1);
}

// NEW: Highlight Pivot Search Space
function highlightPivotSearchSpace(low, high, mid) {
    const arrayContainer = document.getElementById('pivotSearchArray');
    const elements = arrayContainer.querySelectorAll('.array-element');
    
    // Reset all elements
    elements.forEach((el, index) => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('pivot-low', 'pivot-high', 'pivot-mid', 'pivot-found');
        
        if (index >= low && index <= high) {
            if (index === low) {
                valueDiv.classList.add('pivot-low');
            } else if (index === high) {
                valueDiv.classList.add('pivot-high');
            } else if (index === mid) {
                valueDiv.classList.add('pivot-mid');
            }
        }
    });
}

// NEW: Highlight Found Pivot
function highlightPivotFound(index, value) {
    const arrayContainer = document.getElementById('pivotSearchArray');
    const elements = arrayContainer.querySelectorAll('.array-element');
    const valueDiv = elements[index].querySelector('.element-value');
    
    valueDiv.classList.remove('pivot-low', 'pivot-high', 'pivot-mid');
    valueDiv.classList.add('pivot-found');
}

// NEW: Return to Original after Pivot Search
function returnToOriginalAfterPivot() {
    // Reset to original array
    if (originalArrayForPivot.length > 0) {
        myArray = [...originalArrayForPivot];
        originalArrayForPivot = [];
    }
    
    // Remove dual visualization and return to normal view
    removeDualVisualization();
    renderArray();
    updateStats();
    
    // Reset state
    isPivotSearchRunning = false;
    findPivotBtn.disabled = false;
    
    logOperation('Pivot search completed - returned to original array', 'info');
    showNotification('Returned to original array after pivot search', 'success');
}

// NEW: Remove Dual Visualization (helper function)
function removeDualVisualization() {
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
}
// NEW: Search in Rotated Sorted Array Handler
function handleRotatedSearch() {
    if (isRotatedSearchRunning) {
        showNotification('A rotated search is already in progress', 'warning');
        return;
    }
    
    const element = rotatedSearchElement.value.trim();
    if (element === '') {
        showNotification('Please enter an element to search', 'warning');
        rotatedSearchElement.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    isRotatedSearchRunning = true;
    rotatedSearchBtn.disabled = true;
    
    // Store original array
    originalArrayForRotatedSearch = [...myArray];
    
    // Prepare array for rotated search (ensure it's sorted and rotated)
    prepareArrayForRotatedSearch(element);
}

// NEW: Prepare Array for Rotated Search
function prepareArrayForRotatedSearch(target) {
    // Check if array is already sorted
    if (!isArraySorted(myArray)) {
        showNotification('Array is not sorted. Auto-sorting and rotating for search...', 'warning');
        
        // Sort the array
        myArray.sort((a, b) => {
            const numA = parseFloat(a);
            const numB = parseFloat(b);
            if (!isNaN(numA) && !isNaN(numB)) {
                return numA - numB;
            }
            return a.toString().localeCompare(b.toString());
        });
        
        renderArray();
        
        // Rotate the array after sorting
        setTimeout(() => {
            rotateArrayForSearch(target);
        }, 1000);
    } else {
        // Array is already sorted, just rotate it
        rotateArrayForSearch(target);
    }
}

// NEW: Rotate Array for Search
function rotateArrayForSearch(target) {
    const rotationPoint = Math.floor(Math.random() * (myArray.length - 1)) + 1;
    
    // Create rotated array
    rotatedArray = [
        ...myArray.slice(rotationPoint),
        ...myArray.slice(0, rotationPoint)
    ];
    
    // Update the displayed array
    myArray = [...rotatedArray];
    renderArray();
    
    // Highlight the rotation
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'update');
        });
        
        // Start the rotated search after rotation animation
        setTimeout(() => {
            performRotatedSearch(target, 0, myArray.length - 1);
        }, 1000);
    }, 500);
    
    logOperation(`Array rotated at pivot point ${rotationPoint} for rotated search demonstration`, 'info');
}

// NEW: Perform Rotated Search with Visualization
function performRotatedSearch(target, left, right) {
    if (left > right) {
        // Element not found
        searchResults.innerHTML = `<p class="text-center mb-0">Element "${target}" not found in the rotated array</p>`;
        logOperation(`Rotated search for "${target}" - not found`, 'info');
        
        resetRotatedSearchState();
        return;
    }
    
    const mid = Math.floor((left + right) / 2);
    const steps = document.querySelectorAll('#rotatedSearchSteps .algorithm-step');
    
    // Reset all steps
    steps.forEach(step => step.classList.remove('active'));
    
    // Update current step
    steps[0].classList.add('active'); // Step 1: Find mid index
    
    // Highlight current search space
    highlightRotatedSearchSpace(left, right, mid);
    
    // Update search results
    searchResults.innerHTML = `
        <div class="rotated-search-explanation">
            <p class="mb-1"><strong>Searching in Rotated Sorted Array</strong></p>
            <p class="mb-1">Target: "${target}"</p>
            <p class="mb-1">Search space: indices ${left} to ${right}</p>
            <p class="mb-1">Mid index: ${mid}, Value: "${myArray[mid]}"</p>
            <p class="mb-0" id="rotatedSearchDetail">Calculating which half is sorted...</p>
        </div>
    `;
    
    setTimeout(() => {
        if (myArray[mid] === target) {
            // Element found
            steps[1].classList.add('active'); // Step 2: Check if mid equals target
            
            highlightRotatedSearchFound(mid);
            
            searchResults.innerHTML = `
                <div class="rotated-search-explanation">
                    <p class="mb-1"><strong>Element Found!</strong></p>
                    <p class="mb-1">Target: "${target}"</p>
                    <p class="mb-1">Found at index: ${mid}</p>
                    <p class="mb-1">Value: "${myArray[mid]}"</p>
                    <p class="mb-0">Algorithm: Binary Search in Rotated Sorted Array</p>
                </div>
            `;
            
            logOperation(`Rotated search found "${target}" at index ${mid}`, 'success');
            
            setTimeout(() => {
                resetRotatedSearchState();
            }, 3000);
            
        } else {
            // Continue search
            steps[2].classList.add('active'); // Step 3: Determine which half is sorted
            
            const detailElement = document.getElementById('rotatedSearchDetail');
            
            // Determine which half is sorted
            if (myArray[left] <= myArray[mid]) {
                // Left half is sorted
                detailElement.innerHTML = `Left half [${left}-${mid}] is sorted: [${myArray[left]}  ${myArray[mid]}]`;
                
                setTimeout(() => {
                    steps[3].classList.add('active'); // Step 4: Check if target in sorted half
                    
                    // Check if target is in left sorted half
                    if (myArray[left] <= target && target < myArray[mid]) {
                        detailElement.innerHTML = `Target "${target}" is in left sorted half [${left}-${mid-1}]`;
                        steps[4].classList.add('active'); // Step 5: Adjust boundaries
                        
                        setTimeout(() => {
                            performRotatedSearch(target, left, mid - 1);
                        }, 1500);
                    } else {
                        detailElement.innerHTML = `Target "${target}" is NOT in left sorted half, searching right half [${mid+1}-${right}]`;
                        steps[4].classList.add('active'); // Step 5: Adjust boundaries
                        
                        setTimeout(() => {
                            performRotatedSearch(target, mid + 1, right);
                        }, 1500);
                    }
                }, 1000);
            } else {
                // Right half is sorted
                detailElement.innerHTML = `Right half [${mid}-${right}] is sorted: [${myArray[mid]}  ${myArray[right]}]`;
                
                setTimeout(() => {
                    steps[3].classList.add('active'); // Step 4: Check if target in sorted half
                    
                    // Check if target is in right sorted half
                    if (myArray[mid] < target && target <= myArray[right]) {
                        detailElement.innerHTML = `Target "${target}" is in right sorted half [${mid+1}-${right}]`;
                        steps[4].classList.add('active'); // Step 5: Adjust boundaries
                        
                        setTimeout(() => {
                            performRotatedSearch(target, mid + 1, right);
                        }, 1500);
                    } else {
                        detailElement.innerHTML = `Target "${target}" is NOT in right sorted half, searching left half [${left}-${mid-1}]`;
                        steps[4].classList.add('active'); // Step 5: Adjust boundaries
                        
                        setTimeout(() => {
                            performRotatedSearch(target, left, mid - 1);
                        }, 1500);
                    }
                }, 1000);
            }
            
            steps[5].classList.add('active'); // Step 6: Repeat
        }
    }, 1000);
}

// NEW: Helper function to highlight rotated search space
function highlightRotatedSearchSpace(left, right, mid) {
    const elements = document.querySelectorAll('.array-element');
    
    // Reset all elements
    elements.forEach((el, index) => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove(
            'rotated-search-current', 
            'rotated-search-boundary', 
            'rotated-search-mid',
            'rotated-search-found',
            'rotated-sorted-half'
        );
        
        if (index >= left && index <= right) {
            // In current search space
            if (index === mid) {
                valueDiv.classList.add('rotated-search-mid');
            } else if (index === left || index === right) {
                valueDiv.classList.add('rotated-search-boundary');
            } else {
                valueDiv.classList.add('rotated-search-current');
            }
        }
    });
}

// NEW: Helper function to highlight found element
function highlightRotatedSearchFound(index) {
    const elements = document.querySelectorAll('.array-element');
    const valueDiv = elements[index].querySelector('.element-value');
    valueDiv.classList.remove('rotated-search-mid', 'rotated-search-boundary', 'rotated-search-current');
    valueDiv.classList.add('rotated-search-found');
}

// NEW: Reset rotated search state
function resetRotatedSearchState() {
    isRotatedSearchRunning = false;
    rotatedSearchBtn.disabled = false;
    rotatedSearchElement.value = '';
    
    // Reset to original array
    if (originalArrayForRotatedSearch.length > 0) {
        myArray = [...originalArrayForRotatedSearch];
        originalArrayForRotatedSearch = [];
        renderArray();
        updateStats();
    }
    
    // Reset all rotated search highlights
    const elements = document.querySelectorAll('.array-element');
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove(
            'rotated-search-current', 
            'rotated-search-boundary', 
            'rotated-search-mid',
            'rotated-search-found',
            'rotated-sorted-half'
        );
    });
}
// NEW: Show Progression Input Group
function showProgressionInput(type) {
    if (isProgressionOperation) {
        showNotification('A progression operation is already in progress', 'warning');
        return;
    }
    
    // Store original array
    originalArrayBeforeProgression = [...myArray];
    
    // Show appropriate input group
    if (type === 'ap') {
        apInputGroup.style.display = 'block';
        gpInputGroup.style.display = 'none';
        currentProgressionType = 'ap';
    } else {
        apInputGroup.style.display = 'none';
        gpInputGroup.style.display = 'block';
        currentProgressionType = 'gp';
    }
    
    cancelProgressionGroup.style.display = 'block';
    isProgressionOperation = true;
}
// NEW: Create Arithmetic Progression Handler
function handleCreateAP() {
    const firstTerm = parseFloat(apFirstTerm.value);
    const commonDiff = parseFloat(apCommonDiff.value);
    const numTerms = parseInt(apNumTerms.value);
    
    // Validation
    if (isNaN(firstTerm)) {
        showNotification('Please enter a valid first term', 'warning');
        apFirstTerm.focus();
        return;
    }
    
    if (isNaN(commonDiff)) {
        showNotification('Please enter a valid common difference', 'warning');
        apCommonDiff.focus();
        return;
    }
    
    if (isNaN(numTerms) || numTerms < 1 || numTerms > 50) {
        showNotification('Please enter a valid number of terms (1-50)', 'warning');
        apNumTerms.focus();
        return;
    }
    
    // Create AP array with animation
    createArithmeticProgression(firstTerm, commonDiff, numTerms);
}

// NEW: Create Geometric Progression Handler
function handleCreateGP() {
    const firstTerm = parseFloat(gpFirstTerm.value);
    const commonRatio = parseFloat(gpCommonRatio.value);
    const numTerms = parseInt(gpNumTerms.value);
    
    // Validation
    if (isNaN(firstTerm) || firstTerm < 1) {
        showNotification('Please enter a valid first term (1)', 'warning');
        gpFirstTerm.focus();
        return;
    }
    
    if (isNaN(commonRatio)) {
        showNotification('Please enter a valid common ratio', 'warning');
        gpCommonRatio.focus();
        return;
    }
    
    if (isNaN(numTerms) || numTerms < 1 || numTerms > 50) {
        showNotification('Please enter a valid number of terms (1-50)', 'warning');
        gpNumTerms.focus();
        return;
    }
    
    // Create GP array with animation
    createGeometricProgression(firstTerm, commonRatio, numTerms);
}

// NEW: Create Arithmetic Progression with Animation
function createArithmeticProgression(firstTerm, commonDiff, numTerms) {
    // Create dual visualization container
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Arithmetic Progression Creation</h5>
        
        <div class="progression-formula-display">
            <strong>Formula:</strong> a = a + (n-1)d<br>
            <strong>Where:</strong> a = ${firstTerm}, d = ${commonDiff}, n = ${numTerms}
        </div>
        
        <div class="array-group">
            <div class="array-label">Arithmetic Progression Generation</div>
            <div class="transformed-array-container" id="apArrayContainer"></div>
        </div>
        
        <div class="progression-explanation">
            <p class="mb-2" id="apExplanation">Starting AP generation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="apStepsContainer">
            <h6 class="text-center">AP Generation Steps</h6>
            <div class="steps-container" id="apSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterAP" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    const explanation = document.getElementById('apExplanation');
    const stepsContainer = document.getElementById('apSteps');
    const continueButton = document.getElementById('continueAfterAP');
    
    // Generate AP step by step
    const apArray = [];
    let currentTerm = 0;
    
    function generateNextTerm() {
        if (currentTerm >= numTerms) {
            // AP generation completed
            explanation.innerHTML = `<strong>AP Generation Complete!</strong> Created ${numTerms} terms: [${apArray.join(', ')}]`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Arithmetic Progression created successfully!
                </div>
            `;
            
            // Update the actual array
            myArray = [...apArray];
            updateStats();
            
            continueButton.style.display = 'block';
            
            // Auto-return to original after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterProgression();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterProgression);
            
            return;
        }
        
        // Calculate current term
        const termValue = firstTerm + (currentTerm * commonDiff);
        apArray.push(termValue.toString());
        
        // Update steps
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Term ${currentTerm + 1}:</strong> a = ${firstTerm} + (${currentTerm}  ${commonDiff}) = ${termValue}
            </div>
        `;
        
        // Update explanation
        explanation.innerHTML = `Generating term ${currentTerm + 1}: ${firstTerm} + (${currentTerm}  ${commonDiff}) = ${termValue}`;
        
        // Render current AP array
        renderArrayInContainer(apArray, 'apArrayContainer', true, 'ap');
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Highlight the newly added term
        const container = document.getElementById('apArrayContainer');
        const elements = container.querySelectorAll('.array-element');
        if (elements.length > 0) {
            const newElement = elements[elements.length - 1].querySelector('.element-value');
            newElement.classList.add('ap-term');
            
            // Remove highlight after animation
            setTimeout(() => {
                newElement.classList.remove('ap-term');
            }, 1500);
        }
        
        currentTerm++;
        
        // Generate next term after delay
        setTimeout(generateNextTerm, 2000);
    }
    
    // Start AP generation
    generateNextTerm();
    
    logOperation(`Created Arithmetic Progression: first term=${firstTerm}, common difference=${commonDiff}, terms=${numTerms}`, 'success');
}

// NEW: Create Geometric Progression with Animation
function createGeometricProgression(firstTerm, commonRatio, numTerms) {
    // Create dual visualization container
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Geometric Progression Creation</h5>
        
        <div class="progression-formula-display">
            <strong>Formula:</strong> a = a  r<br>
            <strong>Where:</strong> a = ${firstTerm}, r = ${commonRatio}, n = ${numTerms}
        </div>
        
        <div class="array-group">
            <div class="array-label">Geometric Progression Generation</div>
            <div class="transformed-array-container" id="gpArrayContainer"></div>
        </div>
        
        <div class="progression-explanation">
            <p class="mb-2" id="gpExplanation">Starting GP generation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="gpStepsContainer">
            <h6 class="text-center">GP Generation Steps</h6>
            <div class="steps-container" id="gpSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterGP" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    const explanation = document.getElementById('gpExplanation');
    const stepsContainer = document.getElementById('gpSteps');
    const continueButton = document.getElementById('continueAfterGP');
    
    // Generate GP step by step
    const gpArray = [];
    let currentTerm = 0;
    
    function generateNextTerm() {
        if (currentTerm >= numTerms) {
            // GP generation completed
            explanation.innerHTML = `<strong>GP Generation Complete!</strong> Created ${numTerms} terms: [${gpArray.join(', ')}]`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Geometric Progression created successfully!
                </div>
            `;
            
            // Update the actual array
            myArray = [...gpArray];
            updateStats();
            
            continueButton.style.display = 'block';
            
            // Auto-return to original after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterProgression();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterProgression);
            
            return;
        }
        
        // Calculate current term
        const termValue = firstTerm * Math.pow(commonRatio, currentTerm);
        gpArray.push(termValue.toString());
        
        // Update steps
        let stepExplanation = `Term ${currentTerm + 1}: `;
        if (currentTerm === 0) {
            stepExplanation += `${firstTerm} (first term)`;
        } else {
            stepExplanation += `${firstTerm}  ${commonRatio}${currentTerm > 1 ? `^${currentTerm}` : ''} = ${termValue}`;
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Term ${currentTerm + 1}:</strong> ${stepExplanation}
            </div>
        `;
        
        // Update explanation
        explanation.innerHTML = stepExplanation;
        
        // Render current GP array
        renderArrayInContainer(gpArray, 'gpArrayContainer', true, 'gp');
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Highlight the newly added term
        const container = document.getElementById('gpArrayContainer');
        const elements = container.querySelectorAll('.array-element');
        if (elements.length > 0) {
            const newElement = elements[elements.length - 1].querySelector('.element-value');
            newElement.classList.add('gp-term');
            
            // Remove highlight after animation
            setTimeout(() => {
                newElement.classList.remove('gp-term');
            }, 1500);
        }
        
        currentTerm++;
        
        // Generate next term after delay
        setTimeout(generateNextTerm, 2000);
    }
    
    // Start GP generation
    generateNextTerm();
    
    logOperation(`Created Geometric Progression: first term=${firstTerm}, common ratio=${commonRatio}, terms=${numTerms}`, 'success');
}

// NEW: Return to Original Array after Progression
function returnToOriginalAfterProgression() {
    if (originalArrayBeforeProgression.length === 0) {
        showNotification('No original array to return to', 'info');
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayBeforeProgression];
    originalArrayBeforeProgression = [];
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset progression state
    resetProgressionState();
    
    // Show original positions with animation
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation('Returned to original array after progression operation', 'info');
    showNotification('Returned to original array successfully', 'success');
}

// NEW: Cancel Progression Operation
function handleCancelProgression() {
    resetProgressionState();
    showNotification('Progression operation cancelled', 'info');
}

// NEW: Reset Progression State
function resetProgressionState() {
    // Hide input groups
    apInputGroup.style.display = 'none';
    gpInputGroup.style.display = 'none';
    cancelProgressionGroup.style.display = 'none';
    
    // Clear inputs
    apFirstTerm.value = '';
    apCommonDiff.value = '';
    apNumTerms.value = '';
    gpFirstTerm.value = '';
    gpCommonRatio.value = '';
    gpNumTerms.value = '';
    
    // Reset state
    isProgressionOperation = false;
    currentProgressionType = null;
    
    // If we're in the middle of a progression visualization, return to normal view
    if (originalArrayBeforeProgression.length > 0) {
        returnToOriginalAfterProgression();
    }
}
// NEW: Kth Element Operation Handler
function handleKthOperation(type) {
    if (isKthOperationRunning) {
        showNotification('A kth element operation is already in progress', 'warning');
        return;
    }
    
    const k = parseInt(kthElementInput.value);
    
    // Validation
    if (isNaN(k) || k < 1) {
        showNotification('Please enter a valid k value ( 1)', 'danger');
        kthElementInput.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (k > myArray.length) {
        searchResults.innerHTML = `
            <div class="alert alert-danger">
                <strong>Error:</strong> Please enter k between 1 and ${myArray.length} (array length)
            </div>
        `;
        showNotification(`k must be between 1 and ${myArray.length}`, 'danger');
        kthElementInput.focus();
        return;
    }
    
    isKthOperationRunning = true;
    kthOperationType = type;
    kthValue = k;
    
    // Store original array
    originalArrayForKth = [...myArray];
    
    // Disable buttons during operation
    kthSmallestBtn.disabled = true;
    kthLargestBtn.disabled = true;
    
    // Reset search results
    searchResults.innerHTML = '<p class="text-center mb-0">Starting kth element search...</p>';
    
    // Perform kth element operation
    if (type === 'smallest') {
        performKthSmallest();
    } else {
        performKthLargest();
    }
}

// NEW: Get Ordinal Suffix
function getOrdinalSuffix(k) {
    if (k % 10 === 1 && k % 100 !== 11) return 'st';
    if (k % 10 === 2 && k % 100 !== 12) return 'nd';
    if (k % 10 === 3 && k % 100 !== 13) return 'rd';
    return 'th';
}

// NEW: Perform Kth Smallest Operation
function performKthSmallest() {
    const k = kthValue;
    const ordinal = getOrdinalSuffix(k);
    
    // Check if array needs sorting
    if (!isArraySorted(myArray)) {
        showNotification('Array is not sorted. Auto-sorting for kth smallest...', 'warning');
        
        // Sort the array
        myArray.sort((a, b) => {
            const numA = parseFloat(a);
            const numB = parseFloat(b);
            if (!isNaN(numA) && !isNaN(numB)) {
                return numA - numB;
            }
            return a.toString().localeCompare(b.toString());
        });
        
        renderArray();
        
        // Highlight that array was sorted
        setTimeout(() => {
            myArray.forEach((_, index) => {
                highlightElement(index, 'update');
            });
            
            // Start kth smallest after sorting animation
            setTimeout(() => {
                findKthSmallestSorted();
            }, 1000);
        }, 500);
        
    } else {
        // Array is already sorted
        findKthSmallestSorted();
    }
}

// NEW: Find Kth Smallest in Sorted Array
function findKthSmallestSorted() {
    const k = kthValue;
    const ordinal = getOrdinalSuffix(k);
    
    // Create visualization container
    const container = document.createElement('div');
    container.className = 'kth-explanation';
    container.innerHTML = `
        <h5>Finding ${k}${ordinal} Smallest Element in Sorted Array</h5>
        <p class="mb-2">In a sorted array, the kth smallest element is simply the element at index k-1</p>
        <div class="algorithm-steps" id="kthSteps"></div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    const oldContent = mainContainer.innerHTML;
    mainContainer.innerHTML = '';
    mainContainer.appendChild(container);
    
    // Show the array visualization
    const arrayVis = document.createElement('div');
    arrayVis.className = 'array-container';
    arrayVis.id = 'kthArrayVisualization';
    mainContainer.appendChild(arrayVis);
    
    renderArrayInContainer(myArray, 'kthArrayVisualization');
    
    const stepsContainer = document.getElementById('kthSteps');
    
    // Step 1: Explain the approach
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Step 1:</strong> Array is sorted in ascending order
        </div>
        <div class="algorithm-step">
            <strong>Step 2:</strong> In sorted array, kth smallest element = element at position (k-1)
        </div>
        <div class="algorithm-step">
            <strong>Step 3:</strong> Finding element at index ${k-1}
        </div>
    `;
    
    // Highlight the kth smallest element
    setTimeout(() => {
        const elements = document.querySelectorAll('#kthArrayVisualization .array-element');
        const targetIndex = k - 1;
        
        // Highlight all elements up to the target
        for (let i = 0; i <= targetIndex; i++) {
            setTimeout(() => {
                const valueDiv = elements[i].querySelector('.element-value');
                
                if (i === targetIndex) {
                    valueDiv.classList.add('kth-target');
                    
                    // Final step
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 4:</strong> Found! ${k}${ordinal} smallest element = "${myArray[targetIndex]}" at index ${targetIndex}
                        </div>
                    `;
                    
                    // Display result
                    searchResults.innerHTML = `
                        <div class="alert alert-success">
                            <strong>Success!</strong> ${k}${ordinal} smallest element is <strong>"${myArray[targetIndex]}"</strong> at index ${targetIndex}
                        </div>
                    `;
                    
                    logOperation(`Found ${k}${ordinal} smallest element: "${myArray[targetIndex]}"`, 'success');
                    
                    // Auto-return after delay
                    setTimeout(() => {
                        returnToOriginalAfterKthOperation();
                    }, 4000);
                    
                } else {
                    valueDiv.classList.add('kth-compared');
                }
            }, i * 800);
        }
    }, 1500);
}

// NEW: Perform Kth Largest Operation
function performKthLargest() {
    const k = kthValue;
    const ordinal = getOrdinalSuffix(k);
    
    // Create visualization container
    const container = document.createElement('div');
    container.className = 'kth-explanation';
    container.innerHTML = `
        <h5>Finding ${k}${ordinal} Largest Element in Unsorted Array</h5>
        <p class="mb-2">Using selection algorithm to find kth largest without fully sorting the array</p>
        <div class="algorithm-steps" id="kthSteps"></div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    const oldContent = mainContainer.innerHTML;
    mainContainer.innerHTML = '';
    mainContainer.appendChild(container);
    
    // Show the array visualization
    const arrayVis = document.createElement('div');
    arrayVis.className = 'array-container';
    arrayVis.id = 'kthArrayVisualization';
    mainContainer.appendChild(arrayVis);
    
    renderArrayInContainer(myArray, 'kthArrayVisualization');
    
    // Perform kth largest using selection algorithm
    findKthLargestSelection();
}

// NEW: Find Kth Largest using Selection Algorithm
function findKthLargestSelection() {
    const k = kthValue;
    const ordinal = getOrdinalSuffix(k);
    const stepsContainer = document.getElementById('kthSteps');
    const arrayCopy = [...myArray];
    
    // Convert to numbers if possible
    const isNumeric = !arrayCopy.some(item => isNaN(parseFloat(item)));
    
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Step 1:</strong> kth largest = (n-k+1)th smallest element
        </div>
        <div class="algorithm-step">
            <strong>Step 2:</strong> Using selection algorithm to find element
        </div>
    `;
    
    // Implementation of quickselect algorithm
    performQuickSelect(arrayCopy, 0, arrayCopy.length - 1, arrayCopy.length - k, 0);
}

// NEW: QuickSelect Algorithm with Visualization
function performQuickSelect(arr, left, right, k, depth) {
    const stepsContainer = document.getElementById('kthSteps');
    const currentK = kthValue;
    const ordinal = getOrdinalSuffix(currentK);
    
    if (left === right) {
        // Base case: found the kth largest
        const resultIndex = findOriginalIndex(arr[left]);
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${depth + 3}:</strong> Found! ${currentK}${ordinal} largest element = "${arr[left]}"
            </div>
        `;
        
        // Highlight the result
        setTimeout(() => {
            const elements = document.querySelectorAll('#kthArrayVisualization .array-element');
            const valueDiv = elements[resultIndex].querySelector('.element-value');
            valueDiv.classList.add('kth-target');
            
            // Display result
            searchResults.innerHTML = `
                <div class="alert alert-success">
                    <strong>Success!</strong> ${currentK}${ordinal} largest element is <strong>"${arr[left]}"</strong>
                </div>
            `;
            
            logOperation(`Found ${currentK}${ordinal} largest element: "${arr[left]}"`, 'success');
            
            // Auto-return after delay
            setTimeout(() => {
                returnToOriginalAfterKthOperation();
            }, 4000);
        }, 1000);
        
        return;
    }
    
    // Choose random pivot
    const pivotIndex = Math.floor(Math.random() * (right - left + 1)) + left;
    const pivotValue = arr[pivotIndex];
    const pivotOriginalIndex = findOriginalIndex(pivotValue);
    
    // Highlight pivot
    setTimeout(() => {
        const elements = document.querySelectorAll('#kthArrayVisualization .array-element');
        const pivotDiv = elements[pivotOriginalIndex].querySelector('.element-value');
        pivotDiv.classList.add('kth-partition');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${depth + 3}:</strong> Selected pivot = "${pivotValue}" at index ${pivotOriginalIndex}
            </div>
        `;
        
        // Partition the array
        setTimeout(() => {
            const partitionIndex = partition(arr, left, right, pivotIndex, depth);
            pivotDiv.classList.remove('kth-partition');
            
            if (k === partitionIndex) {
                // Found the kth element
                const resultIndex = findOriginalIndex(arr[k]);
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${depth + 4}:</strong> Partition index equals k - element found!
                    </div>
                `;
                
                // Highlight the result
                const resultDiv = elements[resultIndex].querySelector('.element-value');
                resultDiv.classList.add('kth-target');
                
                // Display result
                searchResults.innerHTML = `
                    <div class="alert alert-success">
                        <strong>Success!</strong> ${currentK}${ordinal} largest element is <strong>"${arr[k]}"</strong>
                    </div>
                `;
                
                logOperation(`Found ${currentK}${ordinal} largest element: "${arr[k]}"`, 'success');
                
                // Auto-return after delay
                setTimeout(() => {
                    returnToOriginalAfterKthOperation();
                }, 4000);
                
            } else if (k < partitionIndex) {
                // Search left side
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${depth + 4}:</strong> k < partition index, searching left subarray
                    </div>
                `;
                
                performQuickSelect(arr, left, partitionIndex - 1, k, depth + 1);
            } else {
                // Search right side
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${depth + 4}:</strong> k > partition index, searching right subarray
                    </div>
                `;
                
                performQuickSelect(arr, partitionIndex + 1, right, k, depth + 1);
            }
        }, 1500);
    }, 1000);
}

// NEW: Partition Function for QuickSelect
function partition(arr, left, right, pivotIndex, depth) {
    const pivotValue = arr[pivotIndex];
    const stepsContainer = document.getElementById('kthSteps');
    
    // Move pivot to end
    [arr[pivotIndex], arr[right]] = [arr[right], arr[pivotIndex]];
    
    let storeIndex = left;
    
    stepsContainer.innerHTML += `
        <div class="algorithm-step">
            <strong>Partition ${depth + 1}:</strong> Moving elements  "${pivotValue}" to left
        </div>
    `;
    
    for (let i = left; i < right; i++) {
        const shouldSwap = parseFloat(arr[i]) <= parseFloat(pivotValue);
        
        if (shouldSwap) {
            [arr[storeIndex], arr[i]] = [arr[i], arr[storeIndex]];
            storeIndex++;
        }
    }
    
    // Move pivot to its final place
    [arr[storeIndex], arr[right]] = [arr[right], arr[storeIndex]];
    
    return storeIndex;
}

// NEW: Find Original Index of Element
function findOriginalIndex(value) {
    for (let i = 0; i < originalArrayForKth.length; i++) {
        if (originalArrayForKth[i] === value) {
            return i;
        }
    }
    return -1;
}

// NEW: Return to Original after Kth Operation
function returnToOriginalAfterKthOperation() {
    // Reset to original array
    myArray = [...originalArrayForKth];
    originalArrayForKth = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isKthOperationRunning = false;
    kthOperationType = null;
    kthSmallestBtn.disabled = false;
    kthLargestBtn.disabled = false;
    kthElementInput.value = '';
    
    // Show completion message
    showNotification('Returned to original array after kth element operation', 'success');
}
// NEW: Selection Sort Handler
function handleSelectionSort() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - already sorted', 'info');
        return;
    }
    
    if (isSelectionSortRunning) {
        showNotification('A selection sort operation is already in progress', 'warning');
        return;
    }
    
    isSelectionSortRunning = true;
    selectionSortBtn.disabled = true;
    
    // Store original array
    originalArrayForSelectionSort = [...myArray];
    
    // Show selection sort visualization
    showSelectionSortVisualization();
}

// NEW: Insertion Sort Handler
function handleInsertionSort() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - already sorted', 'info');
        return;
    }
    
    if (isInsertionSortRunning) {
        showNotification('An insertion sort operation is already in progress', 'warning');
        return;
    }
    
    isInsertionSortRunning = true;
    insertionSortBtn.disabled = true;
    
    // Store original array
    originalArrayForInsertionSort = [...myArray];
    
    // Show insertion sort visualization
    showInsertionSortVisualization();
}

// NEW: Show Selection Sort Visualization
function showSelectionSortVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Selection Sort Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalSelectionArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Selection Sort Progress</div>
            <div class="transformed-array-container" id="transformedSelectionArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Selection Sort:</strong> Repeatedly find the minimum element and place it at the beginning</p>
            <p class="mb-0" id="selectionSortExplanation">Starting selection sort animation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="selectionSortStepsContainer">
            <h6 class="text-center">Selection Sort Steps</h6>
            <div class="steps-container" id="selectionSortSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSelectionSort" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSelectionSort, 'originalSelectionArray');
    renderArrayInContainer([...originalArrayForSelectionSort], 'transformedSelectionArray');
    
    performSelectionSortAnimation();
}

// NEW: Show Insertion Sort Visualization
function showInsertionSortVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Insertion Sort Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalInsertionArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Insertion Sort Progress</div>
            <div class="transformed-array-container" id="transformedInsertionArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Insertion Sort:</strong> Build the sorted array one element at a time by inserting each element in its correct position</p>
            <p class="mb-0" id="insertionSortExplanation">Starting insertion sort animation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="insertionSortStepsContainer">
            <h6 class="text-center">Insertion Sort Steps</h6>
            <div class="steps-container" id="insertionSortSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterInsertionSort" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForInsertionSort, 'originalInsertionArray');
    renderArrayInContainer([...originalArrayForInsertionSort], 'transformedInsertionArray');
    
    performInsertionSortAnimation();
}

// NEW: Perform Selection Sort Animation
function performSelectionSortAnimation() {
    const originalContainer = document.getElementById('originalSelectionArray');
    const transformedContainer = document.getElementById('transformedSelectionArray');
    const explanation = document.getElementById('selectionSortExplanation');
    const stepsContainer = document.getElementById('selectionSortSteps');
    const continueButton = document.getElementById('continueAfterSelectionSort');
    
    const array = [...originalArrayForSelectionSort];
    const n = array.length;
    let sortedArray = [...array];
    let currentPass = 0;
    let currentComparison = 0;
    let minIndex = 0;
    let totalSwaps = 0;
    
    // Convert array to numbers for comparison if possible
    const isNumeric = !array.some(item => isNaN(parseFloat(item)));
    
    function performSelectionSortStep() {
        if (currentPass >= n - 1) {
            // Sorting completed
            explanation.innerHTML = `<strong>Selection Sort Completed!</strong> Array sorted in ${n-1} passes with ${totalSwaps} swaps`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Selection sort completed! The array is now fully sorted.
                </div>
            `;
            
            // Highlight all elements as sorted
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                const valueDiv = el.querySelector('.element-value');
                setTimeout(() => {
                    valueDiv.classList.add('selection-sorted');
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return to original after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterSelectionSort();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSelectionSort);
            
            return;
        }
        
        if (currentComparison === 0) {
            // Start of a new pass
            minIndex = currentPass;
            explanation.innerHTML = `Pass ${currentPass + 1}: Finding minimum element in unsorted portion (indices ${currentPass} to ${n-1})`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Pass ${currentPass + 1}:</strong> Finding minimum element in unsorted portion
                </div>
            `;
            
            // Highlight current pass boundary
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            for (let i = 0; i < n; i++) {
                const valueDiv = transformedElements[i].querySelector('.element-value');
                valueDiv.classList.remove('selection-current', 'selection-min', 'selection-compared', 'selection-swap');
                
                if (i < currentPass) {
                    valueDiv.classList.add('selection-sorted');
                } else if (i === currentPass) {
                    valueDiv.classList.add('selection-current');
                }
            }
            
            currentComparison = currentPass + 1;
            performSelectionSortStep();
            return;
        }
        
        if (currentComparison >= n) {
            // Found minimum element for this pass
            explanation.innerHTML = `Pass ${currentPass + 1}: Minimum element found at index ${minIndex} (value: ${sortedArray[minIndex]})`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Pass ${currentPass + 1}:</strong> Minimum element found at index ${minIndex} (${sortedArray[minIndex]})
                </div>
            `;
            
            // Highlight the minimum element
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const minElement = transformedElements[minIndex].querySelector('.element-value');
            minElement.classList.remove('selection-compared');
            minElement.classList.add('selection-min');
            
            // Check if swap is needed
            if (minIndex !== currentPass) {
                explanation.innerHTML = `Pass ${currentPass + 1}: Swapping elements at indices ${currentPass} and ${minIndex}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Pass ${currentPass + 1}:</strong> Swapping ${sortedArray[currentPass]} (index ${currentPass}) with ${sortedArray[minIndex]} (index ${minIndex})
                    </div>
                `;
                
                // Animate the swap
                const currentElement = transformedElements[currentPass].querySelector('.element-value');
                minElement.classList.add('selection-swap');
                currentElement.classList.add('selection-swap');
                
                setTimeout(() => {
                    // Perform the swap
                    [sortedArray[currentPass], sortedArray[minIndex]] = [sortedArray[minIndex], sortedArray[currentPass]];
                    totalSwaps++;
                    
                    // Update the display
                    renderArrayInContainer(sortedArray, 'transformedSelectionArray');
                    
                    // Highlight the swapped elements
                    const newTransformedElements = transformedContainer.querySelectorAll('.array-element');
                    newTransformedElements[currentPass].querySelector('.element-value').classList.add('selection-sorted');
                    
                    currentPass++;
                    currentComparison = 0;
                    performSelectionSortStep();
                }, 1500);
            } else {
                // No swap needed
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Pass ${currentPass + 1}:</strong> Minimum element already at correct position, no swap needed
                    </div>
                `;
                
                const transformedElements = transformedContainer.querySelectorAll('.array-element');
                transformedElements[currentPass].querySelector('.element-value').classList.add('selection-sorted');
                
                currentPass++;
                currentComparison = 0;
                setTimeout(performSelectionSortStep, 1000);
            }
            
            return;
        }
        
        // Compare current element with minimum
        explanation.innerHTML = `Pass ${currentPass + 1}: Comparing element at index ${currentComparison} (${sortedArray[currentComparison]}) with current minimum at index ${minIndex} (${sortedArray[minIndex]})`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Pass ${currentPass + 1}:</strong> Comparing [${currentComparison}]="${sortedArray[currentComparison]}" with current minimum [${minIndex}]="${sortedArray[minIndex]}"
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Highlight elements being compared
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        const currentElement = transformedElements[currentComparison].querySelector('.element-value');
        const minElement = transformedElements[minIndex].querySelector('.element-value');
        
        currentElement.classList.add('selection-compared');
        minElement.classList.add('selection-min');
        
        // Compare values
        let isNewMin = false;
        if (isNumeric) {
            isNewMin = parseFloat(sortedArray[currentComparison]) < parseFloat(sortedArray[minIndex]);
        } else {
            isNewMin = sortedArray[currentComparison] < sortedArray[minIndex];
        }
        
        if (isNewMin) {
            explanation.innerHTML = `Pass ${currentPass + 1}: New minimum found at index ${currentComparison} (${sortedArray[currentComparison]})`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Pass ${currentPass + 1}:</strong> New minimum found! Updating minimum index to ${currentComparison}
                </div>
            `;
            
            minIndex = currentComparison;
        }
        
        setTimeout(() => {
            // Remove comparison highlights
            currentElement.classList.remove('selection-compared');
            minElement.classList.remove('selection-min');
            
            currentComparison++;
            performSelectionSortStep();
        }, 1500);
    }
    
    // Start selection sort process
    performSelectionSortStep();
}
// NEW: Insertion Sort Handler
function handleInsertionSort() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - already sorted', 'info');
        return;
    }
    
    if (isInsertionSortRunning) {
        showNotification('An insertion sort operation is already in progress', 'warning');
        return;
    }
    
    isInsertionSortRunning = true;
    insertionSortBtn.disabled = true;
    
    // Store original array
    originalArrayForInsertionSort = [...myArray];
    
    // Show insertion sort visualization
    showInsertionSortVisualization();
}

// NEW: Show Insertion Sort Visualization
function showInsertionSortVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Insertion Sort Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalInsertionArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Insertion Sort Progress</div>
            <div class="transformed-array-container" id="transformedInsertionArray"></div>
        </div>
        
        <div class="sorting-explanation">
            <p class="mb-2"><strong>Insertion Sort:</strong> Builds the sorted array one element at a time</p>
            <p class="mb-0" id="insertionSortExplanation">Starting insertion sort...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="insertionSortStepsContainer">
            <h6 class="text-center">Insertion Sort Steps</h6>
            <div class="steps-container" id="insertionSortSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterInsertionSort" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForInsertionSort, 'originalInsertionArray');
    renderArrayInContainer([...originalArrayForInsertionSort], 'transformedInsertionArray');
    
    performInsertionSortAnimation();
}

// NEW: Perform Insertion Sort Animation
function performInsertionSortAnimation() {
    const originalContainer = document.getElementById('originalInsertionArray');
    const transformedContainer = document.getElementById('transformedInsertionArray');
    const explanation = document.getElementById('insertionSortExplanation');
    const stepsContainer = document.getElementById('insertionSortSteps');
    const continueButton = document.getElementById('continueAfterInsertionSort');
    
    const array = [...originalArrayForInsertionSort];
    const n = array.length;
    let currentIndex = 1; // Start from second element
    
    function performInsertionStep() {
        if (currentIndex >= n) {
            // Sorting completed
            explanation.innerHTML = `<strong>Insertion Sort Completed!</strong> Array is now fully sorted.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Insertion sort completed! Array is now sorted.
                </div>
            `;
            
            // Highlight all elements as sorted
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                const valueDiv = el.querySelector('.element-value');
                setTimeout(() => {
                    valueDiv.classList.add('insertion-sorted');
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return to original after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterInsertionSort();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterInsertionSort);
            
            return;
        }
        
        const key = array[currentIndex];
        let j = currentIndex - 1;
        
        explanation.innerHTML = `Processing element at index ${currentIndex}: "${key}"`;
        
        // Highlight current key element
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        const keyElement = transformedElements[currentIndex].querySelector('.element-value');
        keyElement.classList.add('insertion-key');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex}:</strong> Processing element [${currentIndex}] = "${key}"
            </div>
        `;
        
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Start shifting elements
        performShiftStep(currentIndex, j, key);
    }
    
    function performShiftStep(currentIdx, compareIdx, keyValue) {
        if (compareIdx < 0) {
            // Found the position to insert
            array[compareIdx + 1] = keyValue;
            updateTransformedArray();
            
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const insertedElement = transformedElements[compareIdx + 1].querySelector('.element-value');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Insert:</strong> Inserting "${keyValue}" at position ${compareIdx + 1}
                </div>
            `;
            
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            insertedElement.classList.add('insertion-sorted');
            
            currentIndex++;
            setTimeout(performInsertionStep, 1000);
            return;
        }
        
        const compareValue = array[compareIdx];
        const shouldShift = parseFloat(compareValue) > parseFloat(keyValue);
        
        if (shouldShift) {
            // Shift element to the right
            explanation.innerHTML = `Shifting element "${compareValue}" from index ${compareIdx} to ${compareIdx + 1}`;
            
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const shiftElement = transformedElements[compareIdx].querySelector('.element-value');
            shiftElement.classList.add('insertion-shift');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Shift:</strong> "${compareValue}" > "${keyValue}", shifting right
                </div>
            `;
            
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            setTimeout(() => {
                array[compareIdx + 1] = array[compareIdx];
                updateTransformedArray();
                
                shiftElement.classList.remove('insertion-shift');
                
                performShiftStep(currentIdx, compareIdx - 1, keyValue);
            }, 1000);
        } else {
            // Found the position to insert
            array[compareIdx + 1] = keyValue;
            updateTransformedArray();
            
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const insertedElement = transformedElements[compareIdx + 1].querySelector('.element-value');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Insert:</strong> "${compareValue}"  "${keyValue}", inserting at position ${compareIdx + 1}
                </div>
            `;
            
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            insertedElement.classList.add('insertion-sorted');
            
            currentIndex++;
            setTimeout(performInsertionStep, 1000);
        }
    }
    
    function updateTransformedArray() {
        renderArrayInContainer([...array], 'transformedInsertionArray');
    }
    
    function returnToOriginalAfterInsertionSort() {
        // Reset to original array
        myArray = [...originalArrayForInsertionSort];
        originalArrayForInsertionSort = [];
        isInsertionSortRunning = false;
        insertionSortBtn.disabled = false;
        
        // Return to normal view
        const mainContainer = document.getElementById('arrayContainer');
        mainContainer.innerHTML = '';
        renderArray();
        updateStats();
        
        logOperation('Insertion sort completed - returned to original array', 'info');
        showNotification('Returned to original array after insertion sort', 'success');
    }
    
    // Start the insertion sort
    performInsertionStep();
}

// NEW: Return to Original after Selection Sort
function returnToOriginalAfterSelectionSort() {
    // Reset to original array
    myArray = [...originalArrayForSelectionSort];
    originalArrayForSelectionSort = [];
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isSelectionSortRunning = false;
    selectionSortBtn.disabled = false;
    
    logOperation('Selection sort demonstration completed - returned to original array', 'info');
    showNotification('Returned to original array after selection sort demonstration', 'success');
}

// NEW: Return to Original after Insertion Sort
function returnToOriginalAfterInsertionSort() {
    // Reset to original array
    myArray = [...originalArrayForInsertionSort];
    originalArrayForInsertionSort = [];
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isInsertionSortRunning = false;
    insertionSortBtn.disabled = false;
    
    logOperation('Insertion sort demonstration completed - returned to original array', 'info');
    showNotification('Returned to original array after insertion sort demonstration', 'success');
}
// NEW: Handle Cyclic Shift Operation
function handleCyclicShiftOperation(direction) {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - cannot perform cyclic shift', 'info');
        return;
    }
    
    if (isCyclicShiftRunning) {
        showNotification('A cyclic shift operation is already in progress', 'warning');
        return;
    }
    
    currentCyclicShiftType = direction;
    cyclicShiftInputGroup.style.display = 'flex';
    
    // Update button text based on direction
    const directionText = direction === 'left' ? 'Left' : 'Right';
    confirmCyclicShiftBtn.innerHTML = `<i class="fas fa-play me-2"></i>Apply Cyclic Shift ${directionText}`;
    
    // Set placeholder with array length info
    cyclicShiftPositionsInput.placeholder = `Enter positions (1 to ${myArray.length})`;
    cyclicShiftPositionsInput.max = myArray.length;
    
    cyclicShiftPositionsInput.focus();
}

// NEW: Confirm Cyclic Shift
function handleConfirmCyclicShift() {
    const positions = parseInt(cyclicShiftPositionsInput.value);
    
    if (isNaN(positions) || positions < 1 || positions > myArray.length) {
        // Show error message in red color
        searchResults.innerHTML = `
            <div class="alert alert-danger mb-0">
                <strong>Error:</strong> Please enter positions between 1 and ${myArray.length}
            </div>
        `;
        showNotification(`Please enter positions between 1 and ${myArray.length}`, 'danger');
        cyclicShiftPositionsInput.focus();
        return;
    }
    
    cyclicShiftPositions = positions;
    
    // Store original array
    originalArrayForCyclicShift = [...myArray];
    
    // Hide input group
    cyclicShiftInputGroup.style.display = 'none';
    cyclicShiftPositionsInput.value = '';
    
    // Start cyclic shift animation
    performCyclicShiftAnimation();
}

// NEW: Cancel Cyclic Shift
function handleCancelCyclicShift() {
    cyclicShiftInputGroup.style.display = 'none';
    cyclicShiftPositionsInput.value = '';
    currentCyclicShiftType = null;
    cyclicShiftPositions = 0;
    
    showNotification('Cyclic shift operation cancelled', 'info');
}

// NEW: Perform Cyclic Shift Animation
function performCyclicShiftAnimation() {
    if (isCyclicShiftRunning) return;
    
    isCyclicShiftRunning = true;
    cyclicShiftLeftBtn.disabled = true;
    cyclicShiftRightBtn.disabled = true;
    
    const directionText = currentCyclicShiftType === 'left' ? 'Left' : 'Right';
    
    // Create dual visualization
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Cyclic Shift ${directionText} by ${cyclicShiftPositions} Positions</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalCyclicArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After Cyclic Shift ${directionText}</div>
            <div class="transformed-array-container" id="transformedCyclicArray"></div>
        </div>
        
        <div class="cyclic-shift-explanation">
            <p class="mb-2"><strong>Cyclic Shift ${directionText}:</strong> Elements wrap around when they reach the end of the array</p>
            <p class="mb-0" id="cyclicShiftExplanation">Preparing cyclic shift animation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="cyclicShiftStepsContainer">
            <h6 class="text-center">Cyclic Shift Steps</h6>
            <div class="steps-container" id="cyclicShiftSteps"></div>
        </div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Render both arrays
    renderArrayInContainer(originalArrayForCyclicShift, 'originalCyclicArray');
    renderArrayInContainer([...originalArrayForCyclicShift], 'transformedCyclicArray');
    
    // Start the step-by-step animation
    performStepByStepCyclicShift();
}

// NEW: Perform Step-by-Step Cyclic Shift
function performStepByStepCyclicShift() {
    const originalContainer = document.getElementById('originalCyclicArray');
    const transformedContainer = document.getElementById('transformedCyclicArray');
    const explanation = document.getElementById('cyclicShiftExplanation');
    const stepsContainer = document.getElementById('cyclicShiftSteps');
    
    const n = myArray.length;
    const k = cyclicShiftPositions;
    const direction = currentCyclicShiftType;
    
    // Calculate the shifted array
    let shiftedArray;
    if (direction === 'left') {
        shiftedArray = [...originalArrayForCyclicShift.slice(k), ...originalArrayForCyclicShift.slice(0, k)];
    } else {
        shiftedArray = [...originalArrayForCyclicShift.slice(n - k), ...originalArrayForCyclicShift.slice(0, n - k)];
    }
    
    explanation.innerHTML = `<strong>Cyclic Shift ${direction === 'left' ? 'Left' : 'Right'}:</strong> Moving ${k} position(s) ${direction === 'left' ? 'left' : 'right'} with wrap-around`;
    
    // Show the algorithm explanation
    stepsContainer.innerHTML = `
        <div class="algorithm-step active">
            <strong>Algorithm:</strong> 
            ${direction === 'left' ? 
                `shiftedArray = array[${k}:] + array[:${k}]` : 
                `shiftedArray = array[${n-k}:] + array[:${n-k}]`
            }
        </div>
        <div class="algorithm-step">
            <strong>Step 1:</strong> Identify elements that will move ${direction === 'left' ? 'left' : 'right'} by ${k} positions
        </div>
        <div class="algorithm-step">
            <strong>Step 2:</strong> Elements reaching the ${direction === 'left' ? 'beginning' : 'end'} wrap around to the ${direction === 'left' ? 'end' : 'beginning'}
        </div>
        <div class="algorithm-step">
            <strong>Step 3:</strong> Update array with new positions
        </div>
    `;
    
    let currentStep = 0;
    
    function performNextStep() {
        if (currentStep >= n) {
            // Animation completed
            explanation.innerHTML = `<strong>Cyclic Shift ${direction === 'left' ? 'Left' : 'Right'} Completed!</strong> All ${n} elements shifted by ${k} positions`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Cyclic shift completed! Array will automatically return to original in 5 seconds.
                </div>
            `;
            
            // Update the actual array
            myArray = [...shiftedArray];
            
            // Auto-return to original after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterCyclicShift();
            }, 5000);
            
            return;
        }
        
        const originalIndex = currentStep;
        let newIndex;
        
        if (direction === 'left') {
            newIndex = (originalIndex - k + n) % n;
        } else {
            newIndex = (originalIndex + k) % n;
        }
        
        // Highlight the moving element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        
        const originalElement = originalElements[originalIndex];
        const transformedElement = transformedElements[newIndex];
        
        const originalValueDiv = originalElement.querySelector('.element-value');
        const transformedValueDiv = transformedElement.querySelector('.element-value');
        
        // Show movement with animation
        originalValueDiv.classList.add('cyclic-shift-moving');
        transformedValueDiv.classList.add('cyclic-shift-new-position');
        
        // Update step explanation
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Move ${currentStep + 1}:</strong> Element "${originalArrayForCyclicShift[originalIndex]}" at [${originalIndex}] 
                 [${newIndex}] ${direction === 'left' ? '(left shift)' : '(right shift)'}
            </div>
        `;
        
        // Scroll to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Update transformed array display
        transformedValueDiv.textContent = originalArrayForCyclicShift[originalIndex];
        
        setTimeout(() => {
            // Remove highlights
            originalValueDiv.classList.remove('cyclic-shift-moving');
            transformedValueDiv.classList.remove('cyclic-shift-new-position');
            transformedValueDiv.classList.add('cyclic-shift-original');
            
            currentStep++;
            performNextStep();
        }, 1000);
    }
    
    // Start the animation
    performNextStep();
}

// NEW: Return to Original Array after Cyclic Shift
function returnToOriginalAfterCyclicShift() {
    if (originalArrayForCyclicShift.length === 0) {
        showNotification('No original array to return to', 'info');
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayForCyclicShift];
    originalArrayForCyclicShift = [];
    
    // Reset the main array display
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset operation state
    isCyclicShiftRunning = false;
    cyclicShiftLeftBtn.disabled = false;
    cyclicShiftRightBtn.disabled = false;
    currentCyclicShiftType = null;
    cyclicShiftPositions = 0;
    
    // Show completion message
    searchResults.innerHTML = `
        <div class="alert alert-success mb-0">
            <strong>Success:</strong> Cyclic shift operation completed and array automatically returned to original state
        </div>
    `;
    
    logOperation(`Cyclic shift ${currentCyclicShiftType} by ${cyclicShiftPositions} positions completed and reset`, 'success');
    showNotification('Array returned to original state after cyclic shift', 'success');
    
    // Highlight all elements to show reset
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
}
// NEW: In-place Negation Handler
function handleInPlaceNegation() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isNegationRunning) {
        showNotification('A negation operation is already in progress', 'warning');
        return;
    }
    
    // Check if all elements are numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('In-place negation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isNegationRunning = true;
    inPlaceNegationBtn.disabled = true;
    
    // Store original array
    originalArrayForNegation = [...myArray];
    
    // Show negation visualization
    showNegationVisualization();
}

// NEW: Show Negation Visualization
function showNegationVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">In-place Negation Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalNegationArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After In-place Negation</div>
            <div class="transformed-array-container" id="transformedNegationArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>In-place Negation:</strong> Negates every element of a mutable numeric sequence</p>
            <p class="mb-0" id="negationExplanation">Starting in-place negation operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="negationStepsContainer">
            <h6 class="text-center">Negation Operation Steps</h6>
            <div class="steps-container" id="negationSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterNegation" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForNegation, 'originalNegationArray');
    renderArrayInContainer([...originalArrayForNegation], 'transformedNegationArray');
    
    performNegationAnimation();
}

// NEW: Perform Negation Animation
function performNegationAnimation() {
    const originalContainer = document.getElementById('originalNegationArray');
    const transformedContainer = document.getElementById('transformedNegationArray');
    const explanation = document.getElementById('negationExplanation');
    const stepsContainer = document.getElementById('negationSteps');
    const continueButton = document.getElementById('continueAfterNegation');
    
    const array = [...originalArrayForNegation];
    const n = array.length;
    let currentIndex = 0;
    
    function performNegationStep() {
        if (currentIndex >= n) {
            // Negation completed
            explanation.innerHTML = `<strong>In-place Negation Completed!</strong> All elements have been negated.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${currentIndex + 1}:</strong> In-place negation completed! All ${n} elements have been negated.
                </div>
            `;
            
            // Update the actual array
            myArray = array.map(val => (-parseFloat(val)).toString());
            
            // Show continue button
            continueButton.style.display = 'block';
            
            // Auto-return to original after 5 seconds
            const autoReturnTimer = setTimeout(() => {
                returnToOriginalAfterNegation();
            }, 5000);
            
            // Manual click handler
            continueButton.addEventListener('click', () => {
                clearTimeout(autoReturnTimer);
                returnToOriginalAfterNegation();
            });
            
            return;
        }
        
        // Highlight current element in original array
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const originalValueDiv = originalElements[currentIndex].querySelector('.element-value');
        originalValueDiv.classList.add('negation-current');
        
        // Get current value
        const currentValue = parseFloat(array[currentIndex]);
        const negatedValue = -currentValue;
        
        // Update step explanation
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex + 1}:</strong> 
                Negating element at index [${currentIndex}]<br>
                Original: ${currentValue}  Negated: ${negatedValue}<br>
                Operation: ${currentValue}  (-1) = ${negatedValue}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Update explanation
        explanation.innerHTML = `Negating element at index ${currentIndex}: ${currentValue}  ${negatedValue}`;
        
        // After a delay, update the transformed array
        setTimeout(() => {
            // Update transformed array element
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const transformedValueDiv = transformedElements[currentIndex].querySelector('.element-value');
            transformedValueDiv.textContent = negatedValue;
            transformedValueDiv.classList.add('negation-highlight', 'transform-animation');
            
            // Remove highlight from original element
            originalValueDiv.classList.remove('negation-current');
            
            // Move to next step
            currentIndex++;
            performNegationStep();
        }, 1500);
    }
    
    // Start the step-by-step negation
    performNegationStep();
}

// NEW: Return to Original After Negation
function returnToOriginalAfterNegation() {
    // Reset to original array
    myArray = [...originalArrayForNegation];
    originalArrayForNegation = [];
    
    // Remove dual visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isNegationRunning = false;
    inPlaceNegationBtn.disabled = false;
    
    logOperation('In-place negation completed and array reset to original', 'success');
    showNotification('In-place negation completed and array reset to original', 'success');
}

// NEW: Find Elements Appearing > n/3 Times Handler
function handleFindNBy3Elements() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isNBy3OperationRunning) {
        showNotification('An n/3 elements operation is already in progress', 'warning');
        return;
    }
    
    isNBy3OperationRunning = true;
    findNBy3ElementsBtn.disabled = true;
    
    // Store original array
    originalArrayForNBy3 = [...myArray];
    
    // Show n/3 elements visualization
    showNBy3ElementsVisualization();
}

// NEW: Show N/3 Elements Visualization
function showNBy3ElementsVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find Elements Appearing More Than n/3 Times</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array (n = ${myArray.length}, n/3 = ${Math.floor(myArray.length/3)})</div>
            <div class="original-array-container" id="originalN3Array"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Boyer-Moore Majority Vote Algorithm</div>
            <div class="transformed-array-container" id="transformedN3Array"></div>
        </div>
        
        <div class="n3-explanation">
            <p class="mb-2"><strong>Boyer-Moore Majority Vote Algorithm:</strong> Finds elements that appear more than n/3 times using O(1) space</p>
            <p class="mb-0" id="n3AlgorithmExplanation">Initializing algorithm with two candidates and counts...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="n3StepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="n3Steps"></div>
        </div>
        
        <div class="candidates-display mt-3" id="candidatesDisplay">
            <h6 class="text-center">Current Candidates</h6>
            <div class="d-flex justify-content-center gap-3" id="candidatesContainer"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterN3" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForNBy3, 'originalN3Array');
    renderArrayInContainer([...originalArrayForNBy3], 'transformedN3Array');
    
    performNBy3AlgorithmAnimation();
}

// NEW: Perform N/3 Algorithm Animation
function performNBy3AlgorithmAnimation() {
    const transformedContainer = document.getElementById('transformedN3Array');
    const n3Steps = document.getElementById('n3Steps');
    const n3AlgorithmExplanation = document.getElementById('n3AlgorithmExplanation');
    const candidatesContainer = document.getElementById('candidatesContainer');
    const continueButton = document.getElementById('continueAfterN3');
    
    let candidate1 = null, candidate2 = null;
    let count1 = 0, count2 = 0;
    let currentIndex = 0;
    let foundElements = [];
    
    // Initialize candidates display
    function updateCandidatesDisplay() {
        candidatesContainer.innerHTML = '';
        
        if (candidate1 !== null) {
            const candidate1Element = document.createElement('div');
            candidate1Element.className = 'stats-card';
            candidate1Element.innerHTML = `
                <div>Candidate 1</div>
                <div class="stats-value">${candidate1}</div>
                <div>Count: ${count1}</div>
            `;
            candidatesContainer.appendChild(candidate1Element);
        }
        
        if (candidate2 !== null) {
            const candidate2Element = document.createElement('div');
            candidate2Element.className = 'stats-card';
            candidate2Element.innerHTML = `
                <div>Candidate 2</div>
                <div class="stats-value">${candidate2}</div>
                <div>Count: ${count2}</div>
            `;
            candidatesContainer.appendChild(candidate2Element);
        }
    }
    
    // Perform one step of the algorithm
    function performStep() {
        if (currentIndex >= myArray.length) {
            // Algorithm completed - verify candidates
            n3Steps.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${currentIndex + 1}:</strong> Algorithm completed. Verifying candidates...
                </div>
            `;
            
            n3AlgorithmExplanation.textContent = 'Algorithm completed. Now verifying if candidates appear more than n/3 times...';
            
            setTimeout(() => {
                verifyCandidates();
            }, 1500);
            return;
        }
        
        const currentElement = myArray[currentIndex];
        const elements = transformedContainer.querySelectorAll('.array-element');
        const currentValueDiv = elements[currentIndex].querySelector('.element-value');
        
        // Highlight current element
        currentValueDiv.classList.add('n3-current');
        
        n3Steps.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex + 1}:</strong> Processing element [${currentIndex}] = ${currentElement}
            </div>
        `;
        
        n3Steps.scrollTop = n3Steps.scrollHeight;
        
        setTimeout(() => {
            // Algorithm logic
            if (candidate1 !== null && candidate1 === currentElement) {
                count1++;
                currentValueDiv.classList.remove('n3-current');
                currentValueDiv.classList.add('n3-count-increase', 'n3-candidate-1');
                n3Steps.innerHTML += `
                    <div class="algorithm-step">
                        &nbsp;&nbsp; Matches candidate1 (${candidate1}), increasing count1 to ${count1}
                    </div>
                `;
                n3AlgorithmExplanation.textContent = `Element matches candidate1. Increasing count1 to ${count1}`;
            } else if (candidate2 !== null && candidate2 === currentElement) {
                count2++;
                currentValueDiv.classList.remove('n3-current');
                currentValueDiv.classList.add('n3-count-increase', 'n3-candidate-2');
                n3Steps.innerHTML += `
                    <div class="algorithm-step">
                        &nbsp;&nbsp; Matches candidate2 (${candidate2}), increasing count2 to ${count2}
                    </div>
                `;
                n3AlgorithmExplanation.textContent = `Element matches candidate2. Increasing count2 to ${count2}`;
            } else if (count1 === 0) {
                candidate1 = currentElement;
                count1 = 1;
                currentValueDiv.classList.remove('n3-current');
                currentValueDiv.classList.add('n3-candidate-1');
                n3Steps.innerHTML += `
                    <div class="algorithm-step">
                        &nbsp;&nbsp; count1 is 0, setting candidate1 to ${currentElement} with count1 = 1
                    </div>
                `;
                n3AlgorithmExplanation.textContent = `count1 is 0. Setting candidate1 to ${currentElement}`;
            } else if (count2 === 0) {
                candidate2 = currentElement;
                count2 = 1;
                currentValueDiv.classList.remove('n3-current');
                currentValueDiv.classList.add('n3-candidate-2');
                n3Steps.innerHTML += `
                    <div class="algorithm-step">
                        &nbsp;&nbsp; count2 is 0, setting candidate2 to ${currentElement} with count2 = 1
                    </div>
                `;
                n3AlgorithmExplanation.textContent = `count2 is 0. Setting candidate2 to ${currentElement}`;
            } else {
                count1--;
                count2--;
                currentValueDiv.classList.remove('n3-current');
                currentValueDiv.classList.add('n3-count-decrease');
                n3Steps.innerHTML += `
                    <div class="algorithm-step">
                        &nbsp;&nbsp; No match, decreasing both counts: count1=${count1}, count2=${count2}
                    </div>
                `;
                n3AlgorithmExplanation.textContent = `No match with candidates. Decreasing both counts: count1=${count1}, count2=${count2}`;
            }
            
            // Update candidates display
            updateCandidatesDisplay();
            
            n3Steps.scrollTop = n3Steps.scrollHeight;
            
            // Remove highlight after animation
            setTimeout(() => {
                currentValueDiv.classList.remove('n3-count-increase', 'n3-count-decrease', 'n3-candidate-1', 'n3-candidate-2');
                
                // Move to next element
                currentIndex++;
                performStep();
            }, 1500);
        }, 1000);
    }
    
    // Verify candidates after algorithm completion
    function verifyCandidates() {
        n3Steps.innerHTML += `
            <div class="algorithm-step active">
                <strong>Verification:</strong> Counting actual occurrences of candidates...
            </div>
        `;
        
        // Count actual occurrences
        let countCandidate1 = 0;
        let countCandidate2 = 0;
        
        for (let i = 0; i < myArray.length; i++) {
            if (candidate1 !== null && myArray[i] === candidate1) countCandidate1++;
            if (candidate2 !== null && myArray[i] === candidate2) countCandidate2++;
        }
        
        const threshold = Math.floor(myArray.length / 3);
        foundElements = [];
        
        if (candidate1 !== null && countCandidate1 > threshold) {
            foundElements.push(candidate1);
        }
        if (candidate2 !== null && countCandidate2 > threshold) {
            foundElements.push(candidate2);
        }
        
        // Highlight found elements
        const elements = transformedContainer.querySelectorAll('.array-element');
        for (let i = 0; i < myArray.length; i++) {
            if (foundElements.includes(myArray[i])) {
                const valueDiv = elements[i].querySelector('.element-value');
                valueDiv.classList.add('n3-found');
            }
        }
        
        // Display results
        if (foundElements.length > 0) {
            n3Steps.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Result:</strong> Found ${foundElements.length} element(s) appearing more than n/3 times: ${foundElements.join(', ')}
                </div>
            `;
            n3AlgorithmExplanation.textContent = `Found ${foundElements.length} element(s) appearing more than n/3 times: ${foundElements.join(', ')}`;
        } else {
            n3Steps.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Result:</strong> No elements found appearing more than n/3 times
                </div>
            `;
            n3AlgorithmExplanation.textContent = 'No elements found appearing more than n/3 times';
        }
        
        // Show continue button
        continueButton.style.display = 'block';
        
        // Auto-proceed after 5 seconds
        const autoProceedTimer = setTimeout(() => {
            proceedAfterN3();
        }, 5000);
        
        // Manual click handler
        continueButton.addEventListener('click', () => {
            clearTimeout(autoProceedTimer);
            proceedAfterN3();
        });
    }
    
    // Proceed after N/3 operation
    function proceedAfterN3() {
        // Reset to original array
        myArray = [...originalArrayForNBy3];
        isNBy3OperationRunning = false;
        findNBy3ElementsBtn.disabled = false;
        
        // Remove dual visualization and return to normal view
        const mainContainer = document.getElementById('arrayContainer');
        mainContainer.innerHTML = '';
        renderArray();
        updateStats();
        
        logOperation(`Completed n/3 elements search. Found: ${foundElements.length > 0 ? foundElements.join(', ') : 'none'}`, 'success');
        showNotification(`Returned to original array after n/3 elements search`, 'info');
    }
    
    // Start the algorithm
    performStep();
}
// NEW: Next Greater Element Handler
function handleNextGreaterElement() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isNextGreaterElementRunning) {
        showNotification('Next Greater Element operation is already in progress', 'warning');
        return;
    }
    
    isNextGreaterElementRunning = true;
    nextGreaterElementBtn.disabled = true;
    
    // Store original array
    originalArrayForNGE = [...myArray];
    
    // Reset all elements first
    const elements = document.querySelectorAll('.array-element');
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('nge-current', 'nge-processed', 'nge-found', 'nge-no-greater');
    });
    
    // Create dual visualization and start algorithm immediately
    showNextGreaterElementVisualization();
}

// NEW: Show Next Greater Element Visualization
function showNextGreaterElementVisualization() {
    // Create dual container for array and stack
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Next Greater Element Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalArrayNGE"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Result Array (Next Greater Elements)</div>
            <div class="transformed-array-container" id="resultArrayNGE"></div>
        </div>
        
        <div class="stack-container mt-3" id="stackContainerNGE">
            <div class="stack-label">Stack (stores indices)</div>
            <div class="stack-elements" id="stackElements"></div>
        </div>
        
        <div class="nge-explanation mt-3">
            <p class="mb-2"><strong>Algorithm Explanation:</strong></p>
            <p class="mb-1"> Stack stores indices of elements for which we haven't found next greater element yet</p>
            <p class="mb-1"> For each element, we check if it's greater than stack top element</p>
            <p class="mb-1"> If yes, we found next greater element for stack top</p>
            <p class="mb-0"> If no, we push current element index to stack</p>
        </div>
        
        <div class="calculation-steps mt-3" id="calculationStepsNGE">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="stepsContainerNGE"></div>
        </div>
        
        <div class="text-center mt-3">
            <div class="spinner-border text-primary" role="status" id="ngeSpinner">
                <span class="visually-hidden">Processing...</span>
            </div>
            <p class="mt-2 text-info">Algorithm in progress...</p>
        </div>
    `;
    
    // Replace the main array container with dual visualization
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Render original array
    renderArrayInContainer(originalArrayForNGE, 'originalArrayNGE');
    
    // Render empty result array
    const resultArray = new Array(originalArrayForNGE.length).fill(-1);
    renderArrayInContainer(resultArray.map(val => val === -1 ? '?' : val), 'resultArrayNGE');
    
    // Start algorithm immediately after a short delay to allow rendering
    setTimeout(() => {
        performNextGreaterElementAlgorithm();
    }, 500);
}

// NEW: Perform Next Greater Element Algorithm with Visualization
function performNextGreaterElementAlgorithm() {
    const stepsContainer = document.getElementById('stepsContainerNGE');
    const originalContainer = document.getElementById('originalArrayNGE');
    const resultContainer = document.getElementById('resultArrayNGE');
    const stackElements = document.getElementById('stackElements');
    
    const n = originalArrayForNGE.length;
    const result = new Array(n).fill(-1); // Initialize result with -1 (no greater element)
    const stack = []; // Stack to store indices
    let currentIndex = 0;
    let stepCounter = 1;
    
    // Function to update stack visualization
    function updateStackVisualization() {
        stackElements.innerHTML = '';
        
        if (stack.length === 0) {
            const emptyStack = document.createElement('div');
            emptyStack.className = 'stack-element';
            emptyStack.textContent = 'Empty';
            emptyStack.style.background = 'rgba(255,255,255,0.1)';
            stackElements.appendChild(emptyStack);
            return;
        }
        
        // Show stack from top to bottom
        for (let i = stack.length - 1; i >= 0; i--) {
            const stackIndex = stack[i];
            const stackValue = originalArrayForNGE[stackIndex];
            const stackElement = document.createElement('div');
            stackElement.className = 'stack-element';
            stackElement.textContent = `[${stackIndex}]: ${stackValue}`;
            stackElements.appendChild(stackElement);
        }
    }
    
    // Function to perform one algorithm step
    function performStep() {
        if (currentIndex >= n) {
            // Algorithm completed
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${stepCounter}:</strong> All array elements processed!
                </div>
            `;
            
            // Process remaining elements in stack
            processRemainingStack();
            return;
        }
        
        const currentValue = originalArrayForNGE[currentIndex];
        
        // Highlight current element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentIndex];
        const currentValueDiv = currentElement.querySelector('.element-value');
        currentValueDiv.classList.add('nge-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${stepCounter}:</strong> Processing index ${currentIndex} (value: ${currentValue})
            </div>
        `;
        
        stepCounter++;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Check stack and find next greater elements
        processStackWithCurrentElement();
    }
    
    // Function to process stack with current element
    function processStackWithCurrentElement() {
        const currentValue = parseFloat(originalArrayForNGE[currentIndex]);
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const resultElements = resultContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentIndex];
        const currentValueDiv = currentElement.querySelector('.element-value');
        
        setTimeout(() => {
            if (stack.length === 0) {
                // Stack is empty, just push current index
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${stepCounter}:</strong> Stack is empty, pushing index ${currentIndex} to stack
                    </div>
                `;
                
                stack.push(currentIndex);
                updateStackVisualization();
                currentValueDiv.classList.remove('nge-current');
                currentValueDiv.classList.add('nge-processed');
                
                stepCounter++;
                currentIndex++;
                setTimeout(performStep, 1000);
                return;
            }
            
            let stackTopIndex = stack[stack.length - 1];
            let stackTopValue = parseFloat(originalArrayForNGE[stackTopIndex]);
            
            // Highlight stack top element
            const stackTopElement = originalElements[stackTopIndex];
            const stackTopValueDiv = stackTopElement.querySelector('.element-value');
            stackTopValueDiv.classList.add('nge-processed');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${stepCounter}:</strong> Comparing current value ${currentValue} with stack top [${stackTopIndex}]: ${stackTopValue}
                </div>
            `;
            
            stepCounter++;
            
            if (currentValue > stackTopValue) {
                // Current element is greater than stack top - found next greater element
                setTimeout(() => {
                    result[stackTopIndex] = currentValue;
                    
                    // Update result array visualization
                    const resultValueDiv = resultElements[stackTopIndex].querySelector('.element-value');
                    resultValueDiv.textContent = currentValue;
                    resultValueDiv.classList.add('nge-found', 'transform-animation');
                    
                    // Highlight the found relationship
                    stackTopValueDiv.classList.remove('nge-processed');
                    stackTopValueDiv.classList.add('nge-found');
                    currentValueDiv.classList.add('nge-found');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${stepCounter}:</strong> Found! Next greater element for [${stackTopIndex}] is ${currentValue} at index ${currentIndex}
                        </div>
                    `;
                    
                    stepCounter++;
                    
                    // Pop from stack
                    stack.pop();
                    updateStackVisualization();
                    
                    // Remove highlights after a moment
                    setTimeout(() => {
                        stackTopValueDiv.classList.remove('nge-found');
                        currentValueDiv.classList.remove('nge-found', 'nge-current');
                        currentValueDiv.classList.add('nge-processed');
                        
                        // Continue processing stack with same current element
                        processStackWithCurrentElement();
                    }, 1000);
                }, 1000);
            } else {
                // Current element is not greater than stack top
                setTimeout(() => {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${stepCounter}:</strong> ${currentValue}  ${stackTopValue}, pushing index ${currentIndex} to stack
                        </div>
                    `;
                    
                    stack.push(currentIndex);
                    updateStackVisualization();
                    
                    currentValueDiv.classList.remove('nge-current');
                    currentValueDiv.classList.add('nge-processed');
                    stackTopValueDiv.classList.remove('nge-processed');
                    
                    stepCounter++;
                    currentIndex++;
                    setTimeout(performStep, 1000);
                }, 1000);
            }
        }, 1000);
    }
    
    // Function to process remaining elements in stack
    function processRemainingStack() {
        if (stack.length === 0) {
            finishAlgorithm();
            return;
        }
        
        const stackTopIndex = stack[stack.length - 1];
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const resultElements = resultContainer.querySelectorAll('.array-element');
        const stackTopElement = originalElements[stackTopIndex];
        const stackTopValueDiv = stackTopElement.querySelector('.element-value');
        
        stackTopValueDiv.classList.add('nge-no-greater');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${stepCounter}:</strong> No next greater element for [${stackTopIndex}]: ${originalArrayForNGE[stackTopIndex]} (setting to -1)
            </div>
        `;
        
        result[stackTopIndex] = -1;
        const resultValueDiv = resultElements[stackTopIndex].querySelector('.element-value');
        resultValueDiv.textContent = '-1';
        resultValueDiv.classList.add('nge-no-greater', 'transform-animation');
        
        stepCounter++;
        
        stack.pop();
        updateStackVisualization();
        
        setTimeout(() => {
            stackTopValueDiv.classList.remove('nge-no-greater');
            processRemainingStack();
        }, 1000);
    }
    
    // Function to finish algorithm
    function finishAlgorithm() {
        // Hide the spinner
        const spinner = document.getElementById('ngeSpinner');
        if (spinner) {
            spinner.style.display = 'none';
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${stepCounter}:</strong> Algorithm finished successfully!
            </div>
        `;
        
        // Show final result
        setTimeout(() => {
            const resultString = result.map((val, idx) => 
                `NGE[${idx}] = ${val}`
            ).join(', ');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active success-color text-white p-2 rounded">
                    <strong>Final Result:</strong> ${resultString}
                </div>
            `;
            
            // Add auto-reset message
            stepsContainer.innerHTML += `
                <div class="algorithm-step active info-color text-white p-2 rounded mt-2">
                    <strong>Note:</strong> Will return to original array view in 5 seconds...
                </div>
            `;
            
            logOperation('Next Greater Element algorithm completed', 'success');
            
            // Reset after delay
            setTimeout(() => {
                resetNextGreaterElementState();
            }, 5000);
        }, 1500);
    }
    
    // Initialize stack visualization and start algorithm
    updateStackVisualization();
    performStep();
}

// NEW: Reset Next Greater Element State
function resetNextGreaterElementState() {
    isNextGreaterElementRunning = false;
    nextGreaterElementBtn.disabled = false;
    
    // Return to normal array view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    
    logOperation('Next Greater Element visualization completed', 'info');
}
// NEW: Shallow Copy Handler
function handleShallowCopy() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    const count = parseInt(shallowCopyCount.value);
    const n = myArray.length;
    
    // Validation
    if (isNaN(count) || count < 1 || count > n) {
        showNotification(`Please enter a valid number between 1 and ${n}`, 'danger');
        shallowCopyCount.focus();
        return;
    }
    
    // Show input group for modifications
    shallowCopyInputGroup.style.display = 'block';
    shallowCopyInputs.innerHTML = '';
    shallowCopyModifications = [];
    
    // Create input fields for each modification
    for (let i = 0; i < count; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Index ${i}</span>
            <input type="number" class="form-control shallow-copy-index" 
                   placeholder="Index (0 to ${n-1})" min="0" max="${n-1}" 
                   data-modification-index="${i}">
            <input type="text" class="form-control shallow-copy-value" 
                   placeholder="New value" data-modification-index="${i}">
        `;
        shallowCopyInputs.appendChild(inputGroup);
    }
    
    // Add event listeners for inputs
    const indexInputs = shallowCopyInputs.querySelectorAll('.shallow-copy-index');
    const valueInputs = shallowCopyInputs.querySelectorAll('.shallow-copy-value');
    
    indexInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput) nextInput.focus();
            }
        });
    });
    
    valueInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const modIndex = parseInt(input.dataset.modificationIndex);
                const nextGroup = input.closest('.input-group').nextElementSibling;
                if (nextGroup) {
                    nextGroup.querySelector('.shallow-copy-index').focus();
                } else {
                    confirmShallowCopyBtn.focus();
                }
            }
        });
    });
    
    logOperation(`Started shallow copy operation with ${count} modifications`, 'info');
}

// NEW: Confirm Shallow Copy Handler
function handleConfirmShallowCopy() {
    const indexInputs = shallowCopyInputs.querySelectorAll('.shallow-copy-index');
    const valueInputs = shallowCopyInputs.querySelectorAll('.shallow-copy-value');
    
    shallowCopyModifications = [];
    
    // Validate all inputs
    for (let i = 0; i < indexInputs.length; i++) {
        const index = parseInt(indexInputs[i].value);
        const value = valueInputs[i].value.trim();
        
        if (isNaN(index) || index < 0 || index >= myArray.length) {
            showNotification(`Please enter a valid index between 0 and ${myArray.length-1} for modification ${i+1}`, 'danger');
            indexInputs[i].focus();
            return;
        }
        
        if (value === '') {
            showNotification(`Please enter a value for modification ${i+1}`, 'warning');
            valueInputs[i].focus();
            return;
        }
        
        shallowCopyModifications.push({ index, value });
    }
    
    // Check for duplicate indices
    const indices = shallowCopyModifications.map(mod => mod.index);
    const uniqueIndices = new Set(indices);
    if (uniqueIndices.size !== indices.length) {
        showNotification('Duplicate indices found. Please use different indices for each modification.', 'danger');
        return;
    }
    
    // Hide input group
    shallowCopyInputGroup.style.display = 'none';
    shallowCopyCount.value = '';
    
    // Store original array
    originalArrayForShallowCopy = [...myArray];
    
    // Show shallow copy visualization
    showShallowCopyVisualization();
}

// NEW: Cancel Shallow Copy Handler
function handleCancelShallowCopy() {
    shallowCopyInputGroup.style.display = 'none';
    shallowCopyCount.value = '';
    shallowCopyInputs.innerHTML = '';
    shallowCopyModifications = [];
    
    logOperation('Cancelled shallow copy operation', 'info');
    showNotification('Shallow copy operation cancelled', 'info');
}

// NEW: Show Shallow Copy Visualization
function showShallowCopyVisualization() {
    isShallowCopyRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Shallow Copy Demonstration</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array (Reference)</div>
            <div class="original-array-container" id="originalShallowArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-copy"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Shallow Copied Array (Same Reference)</div>
            <div class="transformed-array-container" id="shallowCopiedArray"></div>
        </div>
        
        <div class="shallow-copy-explanation">
            <p class="mb-2"><strong>Shallow Copy Concept:</strong> Both arrays reference the same objects in memory</p>
            <p class="mb-0" id="shallowCopyExplanation">Starting shallow copy demonstration...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="shallowCopyStepsContainer">
            <h6 class="text-center">Shallow Copy Operation Steps</h6>
            <div class="steps-container" id="shallowCopySteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterShallowCopy" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // For shallow copy demonstration, we'll use object references
    // Create an array with objects to demonstrate reference sharing
    const arrayWithObjects = originalArrayForShallowCopy.map((value, index) => ({
        id: index,
        value: value,
        display: value // Changed from `Obj${index}(${value})` to just `value`
    }));
    
    // Store the object array for the demonstration
    window.shallowCopyDemoArray = arrayWithObjects;
    
    // Render both arrays with object display
    renderObjectArrayInContainer(arrayWithObjects, 'originalShallowArray');
    renderObjectArrayInContainer([...arrayWithObjects], 'shallowCopiedArray');
    
    // Perform shallow copy demonstration
    performShallowCopyDemonstration(arrayWithObjects);
}
// NEW: Render Object Array in Container (for shallow copy demo)
function renderObjectArrayInContainer(objectArray, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    objectArray.forEach((obj, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value shallow-copy-original" data-index="${index}" data-object-id="${obj.id}">
                ${obj.value} <!-- Changed from obj.display to obj.value -->
            </div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}
// NEW: Perform Shallow Copy Demonstration
function performShallowCopyDemonstration(originalArray) {
    const originalContainer = document.getElementById('originalShallowArray');
    const shallowContainer = document.getElementById('shallowCopiedArray');
    const explanation = document.getElementById('shallowCopyExplanation');
    const stepsContainer = document.getElementById('shallowCopySteps');
    const continueButton = document.getElementById('continueAfterShallowCopy');
    
    // Create shallow copy (both arrays reference same objects)
    const shallowCopyArray = originalArray; // This is the key - same reference!
    
    let currentStep = 0;
    
    function performShallowCopyStep() {
        switch (currentStep) {
            case 0:
                // Step 1: Show original array with objects
                explanation.innerHTML = 'Step 1: Original array created with objects';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Original array created with object references
                    </div>
                `;
                
                // Highlight all elements as original
                const allElements = document.querySelectorAll('.element-value');
                allElements.forEach(el => {
                    el.classList.add('shallow-copy-original');
                });
                break;
                
            case 1:
                // Step 2: Demonstrate shallow copy assignment
                explanation.innerHTML = 'Step 2: Shallow copy created - let shallowCopy = originalArray';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Shallow copy shares same object references
                    </div>
                `;
                
                // Highlight both arrays to show they share references
                const originalElements = originalContainer.querySelectorAll('.array-element');
                const shallowElements = shallowContainer.querySelectorAll('.array-element');
                
                originalElements.forEach((el, index) => {
                    const valueDiv = el.querySelector('.element-value');
                    valueDiv.classList.remove('shallow-copy-original');
                    valueDiv.classList.add('shallow-copy-reference');
                });
                
                shallowElements.forEach((el, index) => {
                    const valueDiv = el.querySelector('.element-value');
                    valueDiv.classList.remove('shallow-copy-original');
                    valueDiv.classList.add('shallow-copy-reference');
                });
                break;
                
            case 2:
                // Step 3: Show modification through shallow copy
                explanation.innerHTML = 'Step 3: Modifying objects through shallow copy array';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Modifying objects affects both arrays (same references)
                    </div>
                `;
                
                // Process each modification
                processModificationsSequentially(0);
                return; // Don't increment step yet
                
            case 3:
                // Step 4: Show that original array is also affected
                explanation.innerHTML = '<strong>Shallow Copy Demonstration Complete!</strong> Both arrays show changes because they share object references.';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 4:</strong> Shallow copy demonstration completed! Both arrays affected by modifications.
                    </div>
                `;
                
                // Show final comparison
const finalOriginal = originalArray.map(obj => obj.value).join(', '); // Changed from obj.display to obj.value
const finalShallow = shallowCopyArray.map(obj => obj.value).join(', '); // Changed from obj.display to obj.value

stepsContainer.innerHTML += `
    <div class="algorithm-step active">
        <strong>Result:</strong> 
        Original: [${finalOriginal}] | 
        Shallow Copy: [${finalShallow}]
    </div>
    <div class="algorithm-step active">
        <strong>Conclusion:</strong> Both arrays are identical because they reference the same objects!
    </div>
                `;
                
                continueButton.style.display = 'block';
                
                // Auto-return after 5 seconds
                setTimeout(() => {
                    returnToOriginalAfterShallowCopy();
                }, 5000);
                
                continueButton.addEventListener('click', returnToOriginalAfterShallowCopy);
                return;
        }
        
        currentStep++;
        setTimeout(performShallowCopyStep, 2000);
    }
    
    // Helper function to process modifications sequentially with animations
    function processModificationsSequentially(modIndex) {
        if (modIndex >= shallowCopyModifications.length) {
            currentStep++;
            performShallowCopyStep();
            return;
        }
        
        const modification = shallowCopyModifications[modIndex];
        const { index, value } = modification;
        
        explanation.innerHTML = `Modification ${modIndex + 1}: Changing object at index ${index} to "${value}"`;
        
        // Highlight the element being modified in both arrays
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const shallowElements = shallowContainer.querySelectorAll('.array-element');
        
        const originalElement = originalElements[index].querySelector('.element-value');
        const shallowElement = shallowElements[index].querySelector('.element-value');
        
        originalElement.classList.remove('shallow-copy-reference');
        shallowElement.classList.remove('shallow-copy-reference');
        originalElement.classList.add('shallow-copy-modified');
        shallowElement.classList.add('shallow-copy-modified');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Modification ${modIndex + 1}:</strong> Changing shallowCopy[${index}] to "${value}"
            </div>
        `;
        
        setTimeout(() => {
            // Modify the object (this affects both arrays since they share references)
            const objectToModify = originalArray[index];
            objectToModify.value = value;
            objectToModify.display = value;
            
            // Update both array displays
            renderObjectArrayInContainer(originalArray, 'originalShallowArray');
            renderObjectArrayInContainer(shallowCopyArray, 'shallowCopiedArray');
            
            // Highlight both arrays to show they're both affected
            const updatedOriginalElements = originalContainer.querySelectorAll('.array-element');
            const updatedShallowElements = shallowContainer.querySelectorAll('.array-element');
            
            updatedOriginalElements.forEach(el => {
                el.querySelector('.element-value').classList.add('shallow-copy-affected');
            });
            
            updatedShallowElements.forEach(el => {
                el.querySelector('.element-value').classList.add('shallow-copy-affected');
            });
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Effect:</strong> Both arrays updated! Original array also shows the change.
                </div>
            `;
            
            // Process next modification after delay
            setTimeout(() => {
                processModificationsSequentially(modIndex + 1);
            }, 2000);
        }, 1500);
    }
    
    // Start the demonstration
    performShallowCopyStep();
}
// NEW: Return to Original after Shallow Copy
function returnToOriginalAfterShallowCopy() {
    // Reset to original array
    myArray = [...originalArrayForShallowCopy];
    originalArrayForShallowCopy = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isShallowCopyRunning = false;
    
    // Clear any demo data
    window.shallowCopyDemoArray = null;
    
    logOperation('Shallow copy demonstration completed - returned to original array', 'info');
    showNotification('Returned to original array after shallow copy demonstration', 'success');
}
// NEW: In-Place Merge Sort Handler
function handleInPlaceMergeSort() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - already sorted', 'info');
        return;
    }
    
    if (isInPlaceMergeSortRunning) {
        showNotification('In-place merge sort is already in progress', 'warning');
        return;
    }
    
    isInPlaceMergeSortRunning = true;
    inPlaceMergeSortBtn.disabled = true;
    
    // Store original array
    originalArrayForInPlaceMerge = [...myArray];
    
    // Show in-place merge sort visualization
    showInPlaceMergeSortVisualization();
}
// NEW: Show In-Place Merge Sort Visualization
function showInPlaceMergeSortVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">In-Place Merge Sort Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalInPlaceMergeArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">In-Place Sorting Process</div>
            <div class="transformed-array-container" id="transformedInPlaceMergeArray"></div>
        </div>
        
        <div class="inplace-merge-explanation">
            <p class="mb-2"><strong>In-Place Merge Sort:</strong> Sorts array without using extra space, modifying original array directly</p>
            <p class="mb-0" id="inPlaceMergeExplanation">Starting in-place merge sort...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="inPlaceMergeStepsContainer">
            <h6 class="text-center">In-Place Merge Sort Steps</h6>
            <div class="steps-container" id="inPlaceMergeSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterInPlaceMerge" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForInPlaceMerge, 'originalInPlaceMergeArray');
    renderArrayInContainer([...originalArrayForInPlaceMerge], 'transformedInPlaceMergeArray');
    
    performInPlaceMergeSortAnimation();
}
// NEW: Perform In-Place Merge Sort Animation
function performInPlaceMergeSortAnimation() {
    const originalContainer = document.getElementById('originalInPlaceMergeArray');
    const transformedContainer = document.getElementById('transformedInPlaceMergeArray');
    const explanation = document.getElementById('inPlaceMergeExplanation');
    const stepsContainer = document.getElementById('inPlaceMergeSteps');
    const continueButton = document.getElementById('continueAfterInPlaceMerge');
    
    let array = [...originalArrayForInPlaceMerge];
    const n = array.length;
    let stepCounter = 0;
    
    // Convert to numbers for comparison if possible
    const isNumeric = !array.some(item => isNaN(parseFloat(item)));
    
    async function inPlaceMergeSort(start, end) {
        if (start >= end) return;
        
        const mid = Math.floor((start + end) / 2);
        
        // Update explanation for division
        explanation.innerHTML = `Dividing: Sorting subarray [${start}-${end}], Midpoint = ${mid}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${++stepCounter}:</strong> Divide - Sorting subarray [${start}-${end}], Midpoint = ${mid}
            </div>
        `;
        
        // Highlight current subarray being processed
        await highlightSubarray(transformedContainer, start, end, 'inplace-merge-current');
        
        // Recursively sort left half
        await inPlaceMergeSort(start, mid);
        
        // Recursively sort right half
        await inPlaceMergeSort(mid + 1, end);
        
        // Merge the two halves in-place
        await inPlaceMerge(start, mid, end);
    }
    
    async function inPlaceMerge(start, mid, end) {
        explanation.innerHTML = `Merging: Combining sorted halves [${start}-${mid}] and [${mid+1}-${end}]`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${++stepCounter}:</strong> Merge - Combining [${start}-${mid}] and [${mid+1}-${end}]
            </div>
        `;
        
        let i = start;
        let j = mid + 1;
        
        // Highlight the two halves being merged
        await highlightSubarray(transformedContainer, start, mid, 'inplace-merge-left');
        await highlightSubarray(transformedContainer, mid + 1, end, 'inplace-merge-right');
        
        while (i <= mid && j <= end) {
            // Compare elements
            explanation.innerHTML = `Comparing: array[${i}] = ${array[i]} vs array[${j}] = ${array[j]}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${++stepCounter}:</strong> Compare array[${i}]="${array[i]}" and array[${j}]="${array[j]}"
                </div>
            `;
            
            // Highlight elements being compared
            await highlightElements(transformedContainer, [i, j], 'inplace-merge-compared');
            
            let shouldSwap = false;
            if (isNumeric) {
                shouldSwap = parseFloat(array[i]) > parseFloat(array[j]);
            } else {
                shouldSwap = array[i] > array[j];
            }
            
            if (shouldSwap) {
                // Swap elements
                explanation.innerHTML = `Swapping: ${array[i]} and ${array[j]} (out of order)`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${++stepCounter}:</strong> Swap needed - ${array[i]} > ${array[j]}
                    </div>
                `;
                
                await swapElements(transformedContainer, i, j);
                [array[i], array[j]] = [array[j], array[i]];
                
                // After swap, we need to maintain the sorted order in the left half
                let k = j;
                while (k > i + 1) {
                    explanation.innerHTML = `Maintaining order: Checking array[${k-1}] and array[${k}]`;
                    
                    await highlightElements(transformedContainer, [k-1, k], 'inplace-merge-compared');
                    
                    let shouldSwapInner = false;
                    if (isNumeric) {
                        shouldSwapInner = parseFloat(array[k-1]) > parseFloat(array[k]);
                    } else {
                        shouldSwapInner = array[k-1] > array[k];
                    }
                    
                    if (shouldSwapInner) {
                        await swapElements(transformedContainer, k-1, k);
                        [array[k-1], array[k]] = [array[k], array[k-1]];
                        k--;
                    } else {
                        break;
                    }
                }
                
                j++;
                if (j > end) break;
            } else {
                i++;
            }
            
            // Update the display
            renderArrayInContainer(array, 'transformedInPlaceMergeArray');
            
            // Small delay for animation
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
        // Mark subarray as sorted
        await highlightSubarray(transformedContainer, start, end, 'inplace-merge-sorted');
        
        explanation.innerHTML = `Subarray [${start}-${end}] successfully merged and sorted`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${++stepCounter}:</strong> Subarray [${start}-${end}] merged successfully
            </div>
        `;
    }
    
    // Helper function to highlight a subarray
    async function highlightSubarray(container, start, end, className) {
        const elements = container.querySelectorAll('.array-element');
        for (let i = start; i <= end; i++) {
            if (i < elements.length) {
                elements[i].querySelector('.element-value').classList.add(className);
            }
        }
        await new Promise(resolve => setTimeout(resolve, 800));
        
        // Remove highlight after delay
        for (let i = start; i <= end; i++) {
            if (i < elements.length) {
                elements[i].querySelector('.element-value').classList.remove(className);
            }
        }
    }
    
    // Helper function to highlight specific elements
    async function highlightElements(container, indices, className) {
        const elements = container.querySelectorAll('.array-element');
        indices.forEach(index => {
            if (index < elements.length) {
                elements[index].querySelector('.element-value').classList.add(className);
            }
        });
        await new Promise(resolve => setTimeout(resolve, 800));
        
        // Remove highlight
        indices.forEach(index => {
            if (index < elements.length) {
                elements[index].querySelector('.element-value').classList.remove(className);
            }
        });
    }
    
    // Helper function to swap elements with animation
    async function swapElements(container, i, j) {
        const elements = container.querySelectorAll('.array-element');
        const elementI = elements[i].querySelector('.element-value');
        const elementJ = elements[j].querySelector('.element-value');
        
        elementI.classList.add('inplace-merge-swapped');
        elementJ.classList.add('inplace-merge-swapped');
        
        // Calculate swap distance for animation
        const rectI = elements[i].getBoundingClientRect();
        const rectJ = elements[j].getBoundingClientRect();
        const swapDistance = rectJ.left - rectI.left;
        
        elementI.style.setProperty('--swap-distance', `${swapDistance}px`);
        elementJ.style.setProperty('--swap-distance', `-${swapDistance}px`);
        
        elementI.classList.add('swap-animation');
        elementJ.classList.add('swap-animation');
        
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        elementI.classList.remove('inplace-merge-swapped', 'swap-animation');
        elementJ.classList.remove('inplace-merge-swapped', 'swap-animation');
    }
    
    // Start the in-place merge sort
    inPlaceMergeSort(0, n - 1).then(() => {
        // Sorting completed
        explanation.innerHTML = `<strong>In-Place Merge Sort Completed!</strong> Array sorted successfully without extra space.`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Final:</strong> In-place merge sort completed! Total steps: ${stepCounter}
            </div>
        `;
        
        // Highlight the entire sorted array
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        transformedElements.forEach((el, index) => {
            setTimeout(() => {
                el.querySelector('.element-value').classList.add('inplace-merge-sorted');
            }, index * 100);
        });
        
        continueButton.style.display = 'block';
        
        // Auto-return to original after 30 seconds
        setTimeout(() => {
            returnToOriginalAfterInPlaceMerge();
        }, 30000);
        
        continueButton.addEventListener('click', returnToOriginalAfterInPlaceMerge);
    });
}
// NEW: Return to Original after In-Place Merge Sort
function returnToOriginalAfterInPlaceMerge() {
    // Reset to original array
    myArray = [...originalArrayForInPlaceMerge];
    originalArrayForInPlaceMerge = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isInPlaceMergeSortRunning = false;
    inPlaceMergeSortBtn.disabled = false;
    
    logOperation('In-place merge sort completed - returned to original array', 'info');
    showNotification('Returned to original array after in-place merge sort', 'success');
}
// NEW: Insert Sorted Handler
function handleInsertSorted() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isInsertSortedRunning) {
        showNotification('Insert sorted operation is already in progress', 'warning');
        return;
    }
    
    // Show input group
    insertSortedGroup.style.display = 'block';
    insertSortedCountInput.focus();
    
    // Reset inputs
    insertSortedCountInput.value = '';
    insertSortedInputs.innerHTML = '';
    performInsertSortedBtn.style.display = 'none';
    insertSortedElements = [];
    
    logOperation('Started insert sorted operation', 'info');
}

// NEW: Confirm Insert Sorted Count Handler
function handleConfirmInsertSortedCount() {
    const count = parseInt(insertSortedCountInput.value);
    
    if (isNaN(count) || count < 1 || count > 10) {
        showNotification('Please enter a valid number between 1 and 10', 'danger');
        insertSortedCountInput.focus();
        return;
    }
    
    insertSortedCount = count;
    insertSortedElements = [];
    
    // Create input fields for elements to insert
    insertSortedInputs.innerHTML = '<label class="form-label">Enter elements to insert (in any order):</label>';
    for (let i = 0; i < count; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i + 1}</span>
            <input type="text" class="form-control insert-sorted-element" 
                   placeholder="Enter value" data-index="${i}">
        `;
        insertSortedInputs.appendChild(inputGroup);
    }
    
    // Add event listeners for input fields
    const elementInputs = insertSortedInputs.querySelectorAll('.insert-sorted-element');
    elementInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('insert-sorted-element')) {
                    nextInput.focus();
                } else {
                    performInsertSortedBtn.focus();
                }
            }
        });
    });
    
    // Show perform button
    performInsertSortedBtn.style.display = 'block';
    
    showNotification(`Please enter ${count} elements to insert`, 'success');
    logOperation(`Insert sorted count set to ${count}`, 'info');
}

// NEW: Perform Insert Sorted Handler
function handlePerformInsertSorted() {
    // Collect elements to insert
    const elementInputs = document.querySelectorAll('.insert-sorted-element');
    insertSortedElements = [];
    
    for (let i = 0; i < elementInputs.length; i++) {
        const value = elementInputs[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all elements. Missing element at position ${i + 1}`, 'danger');
            elementInputs[i].focus();
            return;
        }
        insertSortedElements.push(value);
    }
    
    // Validate that we have exactly the requested number of elements
    if (insertSortedElements.length !== insertSortedCount) {
        showNotification(`Please enter exactly ${insertSortedCount} elements`, 'danger');
        return;
    }
    
    // Store original array
    originalArrayForInsertSorted = [...myArray];
    
    // Hide input group
    insertSortedGroup.style.display = 'none';
    
    // Start insert sorted visualization
    showInsertSortedVisualization();
}

// NEW: Cancel Insert Sorted Handler
function handleCancelInsertSorted() {
    insertSortedGroup.style.display = 'none';
    insertSortedCountInput.value = '';
    insertSortedInputs.innerHTML = '';
    performInsertSortedBtn.style.display = 'none';
    
    insertSortedElements = [];
    insertSortedCount = 0;
    
    logOperation('Cancelled insert sorted operation', 'info');
    showNotification('Insert sorted operation cancelled', 'info');
}

// NEW: Show Insert Sorted Visualization
function showInsertSortedVisualization() {
    isInsertSortedRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Insert Sorted (Maintain Order)</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalInsertSortedArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After Insert Sorted Operation</div>
            <div class="transformed-array-container" id="transformedInsertSortedArray"></div>
        </div>
        
        <div class="insert-sorted-explanation">
            <p class="mb-2"><strong>Insert Sorted Process:</strong> Inserting elements while maintaining sorted order</p>
            <p class="mb-0" id="insertSortedExplanation">Starting insert sorted operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="insertSortedStepsContainer">
            <h6 class="text-center">Insert Sorted Steps</h6>
            <div class="steps-container" id="insertSortedSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterInsertSorted" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForInsertSorted, 'originalInsertSortedArray');
    renderArrayInContainer([...originalArrayForInsertSorted], 'transformedInsertSortedArray');
    
    performInsertSortedAnimation();
}

// NEW: Perform Insert Sorted Animation
function performInsertSortedAnimation() {
    const originalContainer = document.getElementById('originalInsertSortedArray');
    const transformedContainer = document.getElementById('transformedInsertSortedArray');
    const explanation = document.getElementById('insertSortedExplanation');
    const stepsContainer = document.getElementById('insertSortedSteps');
    const continueButton = document.getElementById('continueAfterInsertSorted');
    
    let currentArray = [...originalArrayForInsertSorted];
    const elementsToInsert = [...insertSortedElements];
    let currentElementIndex = 0;
    let totalSteps = 0;
    
    // Check if array needs to be sorted first
    const isNumeric = !currentArray.some(item => isNaN(parseFloat(item)));
    let isSorted = true;
    
    // Check if array is already sorted
    for (let i = 1; i < currentArray.length; i++) {
        let prevVal = isNumeric ? parseFloat(currentArray[i-1]) : currentArray[i-1];
        let currVal = isNumeric ? parseFloat(currentArray[i]) : currentArray[i];
        
        if ((isNumeric && prevVal > currVal) || (!isNumeric && prevVal > currVal)) {
            isSorted = false;
            break;
        }
    }
    
    function performInsertStep() {
        if (currentElementIndex >= elementsToInsert.length) {
            // All elements inserted
            explanation.innerHTML = `<strong>Insert Sorted Completed!</strong> All ${elementsToInsert.length} elements inserted while maintaining order.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Insert sorted operation completed successfully
                </div>
            `;
            
            // Highlight all new elements
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            setTimeout(() => {
                for (let i = 0; i < transformedElements.length; i++) {
                    if (currentArray.includes(elementsToInsert.find(el => el === currentArray[i]))) {
                        transformedElements[i].querySelector('.element-value').classList.add('create', 'bounce');
                    }
                }
            }, 500);
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterInsertSorted();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterInsertSorted);
            
            return;
        }
        
        totalSteps++;
        const elementToInsert = elementsToInsert[currentElementIndex];
        
        if (!isSorted && currentElementIndex === 0) {
            // First element and array is not sorted - sort the array first
            explanation.innerHTML = `Step ${totalSteps}: Array is not sorted. Sorting array first...`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${totalSteps}:</strong> Array not sorted - performing sort first
                </div>
            `;
            
            // Sort the array
            if (isNumeric) {
                currentArray.sort((a, b) => parseFloat(a) - parseFloat(b));
            } else {
                currentArray.sort();
            }
            
            // Update transformed array
            setTimeout(() => {
                renderArrayInContainer(currentArray, 'transformedInsertSortedArray');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Sort Complete:</strong> Array is now sorted
                    </div>
                `;
                
                isSorted = true;
                performInsertStep();
            }, 2000);
            
            return;
        }
        
        explanation.innerHTML = `Step ${totalSteps}: Finding position to insert "${elementToInsert}"`;
        
        // Show the element to insert
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${totalSteps}:</strong> Inserting element: "${elementToInsert}"
            </div>
        `;
        
        // Create a visual representation of the element to insert
        const newElementDiv = document.createElement('div');
        newElementDiv.className = 'array-element';
        newElementDiv.innerHTML = `
            <div class="element-value insert-sorted-new-element">${elementToInsert}</div>
            <div class="element-index">New Element</div>
        `;
        
        const explanationDiv = document.querySelector('.insert-sorted-explanation');
        explanationDiv.appendChild(newElementDiv);
        
        // Find insertion position
        let insertPosition = currentArray.length;
        
        function findInsertionPosition(index) {
            if (index >= currentArray.length) {
                // Insert at end
                insertPosition = currentArray.length;
                performInsertion();
                return;
            }
            
            explanation.innerHTML = `Step ${totalSteps}.${index + 1}: Comparing "${elementToInsert}" with [${index}]="${currentArray[index]}"`;
            
            // Highlight current comparison
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            if (index < transformedElements.length) {
                transformedElements[index].querySelector('.element-value').classList.add('insert-sorted-compared');
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${totalSteps}.${index + 1}:</strong> Compare "${elementToInsert}" with [${index}]="${currentArray[index]}"
                </div>
            `;
            
            // Compare values
            let shouldInsertBefore = false;
            if (isNumeric) {
                const insertVal = parseFloat(elementToInsert);
                const currentVal = parseFloat(currentArray[index]);
                shouldInsertBefore = insertVal <= currentVal;
            } else {
                shouldInsertBefore = elementToInsert <= currentArray[index];
            }
            
            setTimeout(() => {
                // Remove highlight
                if (index < transformedElements.length) {
                    transformedElements[index].querySelector('.element-value').classList.remove('insert-sorted-compared');
                }
                
                if (shouldInsertBefore) {
                    insertPosition = index;
                    performInsertion();
                } else {
                    findInsertionPosition(index + 1);
                }
            }, 1500);
        }
        
        function performInsertion() {
            explanation.innerHTML = `Step ${totalSteps}.Final: Inserting "${elementToInsert}" at position ${insertPosition}`;
            
            // Highlight insertion position
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            if (insertPosition < transformedElements.length) {
                transformedElements[insertPosition].querySelector('.element-value').classList.add('insert-sorted-position');
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${totalSteps}.Final:</strong> Inserting at position ${insertPosition}
                </div>
            `;
            
            setTimeout(() => {
                // Remove the new element visual
                newElementDiv.remove();
                
                // Perform insertion
                currentArray.splice(insertPosition, 0, elementToInsert);
                
                // Update transformed array
                renderArrayInContainer(currentArray, 'transformedInsertSortedArray');
                
                // Highlight the newly inserted element
                const updatedElements = transformedContainer.querySelectorAll('.array-element');
                updatedElements[insertPosition].querySelector('.element-value').classList.add('create', 'bounce');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Inserted:</strong> "${elementToInsert}" successfully inserted at position ${insertPosition}
                    </div>
                `;
                
                // Move to next element
                currentElementIndex++;
                performInsertStep();
            }, 2000);
        }
        
        // Start finding insertion position
        findInsertionPosition(0);
    }
    
    // Start insert sorted process
    performInsertStep();
}

// NEW: Return to Original after Insert Sorted
function returnToOriginalAfterInsertSorted() {
    // Reset to original array
    myArray = [...originalArrayForInsertSorted];
    originalArrayForInsertSorted = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isInsertSortedRunning = false;
    
    // Clear all insert sorted data
    insertSortedElements = [];
    insertSortedCount = 0;
    
    logOperation('Insert sorted operation completed - returned to original array', 'info');
    showNotification('Returned to original array after insert sorted operation', 'success');
}
// Helper function to render array in specific container
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = `
            <div class="array-empty-state">
                <i class="fas fa-layer-group"></i>
                <h4>Array is Empty</h4>
                <p>Add some elements to get started!</p>
            </div>
        `;
        return;
    }
    
    array.forEach((value, index) => {
        const elementDiv = document.createElement('div');
        elementDiv.className = 'array-element';
        elementDiv.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(elementDiv);
    });
}
// NEW: Generate Random Array Handler
function handleGenerateRandomArray() {
    const size = parseInt(randomArraySize.value);
    
    // Validation
    if (isNaN(size) || size < 1) {
        // Show error message in red color
        searchResults.innerHTML = `
            <div class="alert alert-danger">
                <i class="fas fa-exclamation-triangle me-2"></i>
                <strong>Error:</strong> Array size must be a positive number ( 1). 
                Negative numbers and 0 are not accepted.
            </div>
        `;
        showNotification('Invalid array size! Please enter a positive number  1', 'danger');
        logOperation('Attempted to generate random array with invalid size - failed', 'danger');
        randomArraySize.focus();
        return;
    }
    
    if (size > 100) {
        showNotification('Array size is too large! Maximum allowed is 100', 'warning');
        randomArraySize.focus();
        return;
    }
    
    if (isRandomArrayGenerationRunning) {
        showNotification('Random array generation is already in progress', 'warning');
        return;
    }
    
    isRandomArrayGenerationRunning = true;
    
    // Store original array
    originalArrayBeforeRandom = [...myArray];
    
    // Show random array generation visualization
    showRandomArrayGenerationVisualization(size);
}
// NEW: Show Random Array Generation Visualization
function showRandomArrayGenerationVisualization(size) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Generate Random Array (Size: ${size})</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalRandomArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">New Random Array</div>
            <div class="transformed-array-container" id="transformedRandomArray"></div>
        </div>
        
        <div class="random-array-explanation">
            <p class="mb-2"><strong>Random Generation Process:</strong> Creating array with ${size} random numbers</p>
            <p class="mb-0" id="randomArrayExplanation">Starting random array generation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="randomArrayStepsContainer">
            <h6 class="text-center">Generation Steps</h6>
            <div class="steps-container" id="randomArraySteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterRandomArray" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayBeforeRandom, 'originalRandomArray');
    renderArrayInContainer([], 'transformedRandomArray');
    
    performRandomArrayGeneration(size);
}
// NEW: Perform Random Array Generation with Animation
function performRandomArrayGeneration(size) {
    const originalContainer = document.getElementById('originalRandomArray');
    const transformedContainer = document.getElementById('transformedRandomArray');
    const explanation = document.getElementById('randomArrayExplanation');
    const stepsContainer = document.getElementById('randomArraySteps');
    const continueButton = document.getElementById('continueAfterRandomArray');
    
    const newArray = [];
    let currentStep = 0;
    
    function generateRandomNumber() {
        // Generate random number between -100 and 100 for small numbers initially
        // With 70% probability for small numbers (-20 to 20)
        if (Math.random() < 0.7) {
            return Math.floor(Math.random() * 41) - 20; // -20 to 20
        } else {
            // 30% probability for larger numbers
            const isPositive = Math.random() < 0.5;
            const base = Math.floor(Math.random() * 100) + 1; // 1 to 100
            const exponent = Math.floor(Math.random() * 3) + 1; // 1 to 3 (small exponents)
            const value = base * Math.pow(10, exponent);
            return isPositive ? value : -value;
        }
    }
    
    function performGenerationStep() {
        if (currentStep >= size) {
            // Generation completed
            explanation.innerHTML = `<strong>Random Array Generation Completed!</strong> Created array with ${size} random numbers.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Random array generation completed! Array: [${newArray.join(', ')}]
                </div>
            `;
            
            // Highlight all generated elements
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('random-generated');
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return to original after 8 seconds
            setTimeout(() => {
                returnToOriginalAfterRandomGeneration();
            }, 8000);
            
            continueButton.addEventListener('click', returnToOriginalAfterRandomGeneration);
            
            return;
        }
        
        const stepNumber = currentStep + 1;
        
        // Generate random number
        const randomNum = generateRandomNumber();
        newArray.push(randomNum);
        
        // Update explanation
        explanation.innerHTML = `Step ${stepNumber}: Generated random number ${randomNum} for position ${currentStep}`;
        
        // Add step to steps container
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${stepNumber}:</strong> Generated random number: ${randomNum} at index ${currentStep}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Update transformed array display
        renderArrayInContainer(newArray, 'transformedRandomArray');
        
        // Highlight the newly added element
        setTimeout(() => {
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            if (transformedElements[currentStep]) {
                const newElement = transformedElements[currentStep].querySelector('.element-value');
                newElement.classList.add('random-generated');
                
                // Remove highlight after animation
                setTimeout(() => {
                    newElement.classList.remove('random-generated');
                }, 1000);
            }
            
            currentStep++;
            performGenerationStep();
        }, 800);
    }
    
    // Start generation process
    performGenerationStep();
}
// NEW: Return to Original after Random Generation
function returnToOriginalAfterRandomGeneration() {
    // Apply the new random array
    const size = parseInt(randomArraySize.value);
    const finalArray = [];
    
    // Regenerate the same random numbers for consistency
    function generateRandomNumber() {
        if (Math.random() < 0.7) {
            return Math.floor(Math.random() * 41) - 20;
        } else {
            const isPositive = Math.random() < 0.5;
            const base = Math.floor(Math.random() * 100) + 1;
            const exponent = Math.floor(Math.random() * 3) + 1;
            const value = base * Math.pow(10, exponent);
            return isPositive ? value : -value;
        }
    }
    
    for (let i = 0; i < size; i++) {
        finalArray.push(generateRandomNumber().toString());
    }
    
    myArray = finalArray;
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Clear input
    randomArraySize.value = '';
    
    // Reset state
    isRandomArrayGenerationRunning = false;
    
    // Show success message
    searchResults.innerHTML = `
        <div class="alert alert-success">
            <i class="fas fa-check-circle me-2"></i>
            <strong>Success:</strong> Random array generated with ${size} elements
        </div>
    `;
    
    logOperation(`Generated random array with ${size} elements`, 'success');
    showNotification(`Random array with ${size} elements generated successfully`, 'success');
    
    // Auto-reset after 10 seconds
    setTimeout(() => {
        resetAfterRandomGeneration();
    }, 10000);
}

// NEW: Reset after Random Generation
function resetAfterRandomGeneration() {
    if (originalArrayBeforeRandom.length === 0) {
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayBeforeRandom];
    originalArrayBeforeRandom = [];
    
    renderArray();
    updateStats();
    
    logOperation('Reset to original array after random generation', 'info');
    showNotification('Automatically reset to original array', 'info');
}
// NEW: Convert to Char Array Handler
function handleConvertToCharArray() {
    if (isCharArrayConversionRunning) {
        showNotification('Char array conversion is already in progress', 'warning');
        return;
    }
    
    // Show input group
    stringInputGroup.style.display = 'block';
    inputString.focus();
    
    logOperation('Started string to char array conversion', 'info');
}

// NEW: Confirm String Handler
function handleConfirmString() {
    const inputStr = inputString.value.trim();
    
    if (inputStr === '') {
        showNotification('Please enter a string to convert', 'danger');
        inputString.focus();
        return;
    }
    
    if (inputStr.length > 50) {
        showNotification('String too long. Please enter a string with 50 characters or less.', 'warning');
        inputString.focus();
        return;
    }
    
    // Store original array
    originalArrayForCharConversion = [...myArray];
    
    // Hide input group
    stringInputGroup.style.display = 'none';
    inputString.value = '';
    
    // Start char array conversion visualization
    showCharArrayConversion(inputStr);
}

// NEW: Cancel String Handler
function handleCancelString() {
    stringInputGroup.style.display = 'none';
    inputString.value = '';
    
    logOperation('Cancelled char array conversion', 'info');
}

// NEW: Show Char Array Conversion Visualization
function showCharArrayConversion(inputStr) {
    isCharArrayConversionRunning = true;
    
    const conversionContainer = document.createElement('div');
    conversionContainer.className = 'dual-operation-container';
    conversionContainer.innerHTML = `
        <h5 class="text-center mb-3">String to Char Array Conversion</h5>
        
        <div class="array-group">
            <div class="array-label">Original String</div>
            <div class="string-display" id="originalStringDisplay">"${inputStr}"</div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Character Array</div>
            <div class="char-array-container" id="charArrayDisplay"></div>
        </div>
        
        <div class="conversion-explanation">
            <p class="mb-2"><strong>Conversion Process:</strong> Converting string to array of characters</p>
            <p class="mb-0" id="conversionExplanation">Starting conversion process...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="conversionStepsContainer">
            <h6 class="text-center">Conversion Steps</h6>
            <div class="steps-container" id="conversionSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterConversion" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(conversionContainer);
    
    performCharArrayConversion(inputStr);
}

// NEW: Perform Char Array Conversion with Animation
function performCharArrayConversion(inputStr) {
    const charArrayDisplay = document.getElementById('charArrayDisplay');
    const explanation = document.getElementById('conversionExplanation');
    const stepsContainer = document.getElementById('conversionSteps');
    const continueButton = document.getElementById('continueAfterConversion');
    
    const chars = [];
    let currentIndex = 0;
    let step = 0;
    
    // Clear the display container and set up horizontal layout
    charArrayDisplay.innerHTML = '';
    charArrayDisplay.style.display = 'flex';
    charArrayDisplay.style.flexWrap = 'wrap';
    charArrayDisplay.style.justifyContent = 'center';
    charArrayDisplay.style.alignItems = 'flex-end';
    
    function performConversionStep() {
        if (currentIndex >= inputStr.length) {
            // Conversion completed
            explanation.innerHTML = `<strong>Conversion Completed!</strong> String converted to ${chars.length} characters.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> String "${inputStr}" converted to char array: [${chars.map(c => `'${c}'`).join(', ')}]
                </div>
            `;
            
            // Update the actual array
            myArray = [...chars];
            updateStats();
            
            // Show success message and highlight the entire array
            setTimeout(() => {
                // Highlight all characters in the array
                const charWrappers = charArrayDisplay.querySelectorAll('.char-element-wrapper');
                charWrappers.forEach((wrapper, index) => {
                    setTimeout(() => {
                        const charElement = wrapper.querySelector('.char-element');
                        charElement.classList.add('highlight', 'bounce');
                    }, index * 100);
                });
                
                continueButton.style.display = 'block';
                
                // Auto-return after 5 seconds
                setTimeout(() => {
                    returnToOriginalAfterConversion();
                }, 5000);
                
                continueButton.addEventListener('click', returnToOriginalAfterConversion);
            }, 1000);
            
            return;
        }
        
        step++;
        const currentChar = inputStr[currentIndex];
        const charCode = inputStr.charCodeAt(currentIndex);
        
        // Update explanation
        explanation.innerHTML = `Step ${step}: Processing character at position ${currentIndex} - '${currentChar}' (ASCII: ${charCode})`;
        
        // Create character element with wrapper for horizontal layout
        const charWrapper = document.createElement('div');
        charWrapper.className = 'char-element-wrapper';
        charWrapper.innerHTML = `
            <div class="char-element ${currentChar === ' ' ? 'space-char' : /[^a-zA-Z0-9]/.test(currentChar) ? 'special-char' : ''}">
                ${currentChar === ' ' ? '' : currentChar}
            </div>
            <div class="char-index">[${currentIndex}]</div>
            <div class="char-code">ASCII: ${charCode}</div>
        `;
        
        // Add to display with animation
        charArrayDisplay.appendChild(charWrapper);
        
        // Animate the new character
        setTimeout(() => {
            const valueDiv = charWrapper.querySelector('.char-element');
            valueDiv.classList.add('highlight', 'slide-in');
            
            // Add to chars array
            chars.push(currentChar);
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Character '${currentChar === ' ' ? '' : currentChar}' (ASCII: ${charCode}) added to array at index ${currentIndex}
                </div>
            `;
            
            // Scroll steps container to bottom
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            // Remove highlight after animation but keep the slide-in effect
            setTimeout(() => {
                valueDiv.classList.remove('highlight');
            }, 1000);
            
            currentIndex++;
            setTimeout(performConversionStep, 800); // Increased delay for better visualization
        }, 100);
    }
    
    // Start conversion process
    performConversionStep();
}
// NEW: Return to Original after Conversion
function returnToOriginalAfterConversion() {
    // Reset to original array
    myArray = [...originalArrayForCharConversion];
    originalArrayForCharConversion = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isCharArrayConversionRunning = false;
    
    logOperation('Char array conversion completed - returned to original array', 'info');
    showNotification('Returned to original array after char array conversion', 'success');
}
// Initialize event listeners
function initializeEventListeners() {
    customComparatorSortBtn.addEventListener('click', handleCustomComparatorSort);
    createDictionaryBtn.addEventListener('click', handleCreateDictionary);
    confirmFieldCountBtn.addEventListener('click', handleConfirmFieldCount);
    addRecordBtn.addEventListener('click', handleAddRecord);
    finishDataEntryBtn.addEventListener('click', handleFinishDataEntry);
    updateDictionaryBtn.addEventListener('click', handleUpdateDictionary);
    dropDictionaryBtn.addEventListener('click', handleDropDictionary);
    performSortBtn.addEventListener('click', handlePerformSort);
    resetAfterSortBtn.addEventListener('click', handleResetAfterSort);
    cancelCustomSortBtn.addEventListener('click', handleCancelCustomSort);
}
// ENHANCED: Improved event delegation
function setupEventDelegation() {
    // Use document as the delegation point to handle dynamically created elements
    document.addEventListener('click', function(e) {
        const target = e.target;
        
        // Handle edit button clicks
        if (target.closest('.edit-record')) {
            const button = target.closest('.edit-record');
            const index = parseInt(button.getAttribute('data-index'));
            console.log('Edit button clicked for index:', index);
            if (!isNaN(index)) {
                handleEditRecord(index);
            }
            return;
        }
        
        // Handle delete button clicks
        if (target.closest('.delete-record')) {
            const button = target.closest('.delete-record');
            const index = parseInt(button.getAttribute('data-index'));
            console.log('Delete button clicked for index:', index);
            if (!isNaN(index)) {
                handleDeleteRecord(index);
            }
            return;
        }
        
        // Handle inline edit field clicks
        if (target.classList.contains('editable-field')) {
            const td = target;
            const fieldName = td.getAttribute('data-field');
            const recordIndex = parseInt(td.getAttribute('data-index'));
            console.log('Field clicked for editing:', fieldName, 'index:', recordIndex);
            if (!isNaN(recordIndex)) {
                startEditField(td, fieldName, recordIndex);
            }
            return;
        }
    });
}

// MODIFIED: Update the DOMContentLoaded event listener
document.addEventListener('DOMContentLoaded', function() {
    initializeEventListeners();
    initializeTableReferences(); // Initialize table references first
    setupEventDelegation();
});
// ENHANCED: Improved initialization to ensure table references are set
function initializeTableReferences() {
    // Initialize global table element references
    window.dictionaryTableHeader = document.getElementById('dictionaryTableHeader');
    window.dictionaryTableBody = document.getElementById('dictionaryTableBody');
    window.dictionaryTableContainer = document.getElementById('dictionaryTableContainer');
    
    console.log('Table references initialized:', {
        header: !!dictionaryTableHeader,
        body: !!dictionaryTableBody,
        container: !!dictionaryTableContainer
    });
    
    // If table container doesn't exist, create it
    if (!dictionaryTableContainer) {
        console.error('Dictionary table container not found!');
        // You might want to create it dynamically or show an error
    }
}

// NEW: Custom Comparator Sort Handler
function handleCustomComparatorSort() {
    if (isCustomSortRunning) {
        showNotification('Custom comparator sort is already in progress', 'warning');
        return;
    }

    isCustomSortRunning = true;
    customComparatorContainer.style.display = 'block';
    
    // Reset dictionary
    currentDictionary = {
        name: '',
        fields: [],
        data: [],
        originalData: []
    };
    
    // Show only dictionary creation section initially
    dictionaryStructureSection.style.display = 'none';
    dataEntrySection.style.display = 'none';
    dictionaryOperationsSection.style.display = 'none';
    dictionaryDisplaySection.style.display = 'none';
    sortVisualizationSection.style.display = 'none';
    
    logOperation('Started custom comparator sort operation', 'info');
}

// NEW: Create Dictionary Handler
function handleCreateDictionary() {
    const name = dictionaryName.value.trim();
    
    if (name === '') {
        showNotification('Please enter a dictionary name', 'danger');
        dictionaryName.focus();
        return;
    }
    
    currentDictionary.name = name;
    
    // Show structure section
    dictionaryStructureSection.style.display = 'block';
    fieldCount.focus();
    
    showNotification(`Dictionary "${name}" created. Now define the structure.`, 'success');
    logOperation(`Created dictionary "${name}"`, 'success');
}

// NEW: Confirm Field Count Handler
function handleConfirmFieldCount() {
    const count = parseInt(fieldCount.value);
    
    if (isNaN(count) || count < 1 || count > 10) {
        showNotification('Please enter a valid number of fields between 1 and 10', 'danger');
        fieldCount.focus();
        return;
    }
    
    // Clear previous field definitions
    fieldDefinitions.innerHTML = '';
    currentDictionary.fields = [];
    
    // Create field definition inputs
    for (let i = 0; i < count; i++) {
        const fieldGroup = document.createElement('div');
        fieldGroup.className = 'row mb-3';
        fieldGroup.innerHTML = `
            <div class="col-md-4">
                <label class="form-label">Field ${i + 1} Name</label>
                <input type="text" class="form-control field-name" placeholder="Enter field name" data-index="${i}">
            </div>
            <div class="col-md-4">
                <label class="form-label">Field ${i + 1} Data Type</label>
                <select class="form-control field-type" data-index="${i}">
                    <option value="string">String</option>
                    <option value="int">Integer</option>
                    <option value="float">Float</option>
                </select>
            </div>
            <div class="col-md-4">
                <label class="form-label">Sample Value</label>
                <input type="text" class="form-control field-sample" placeholder="Sample value" data-index="${i}">
            </div>
        `;
        fieldDefinitions.appendChild(fieldGroup);
    }
    
    // Add confirm button
    const confirmButton = document.createElement('button');
    confirmButton.className = 'btn btn-glow mt-2';
    confirmButton.innerHTML = '<i class="fas fa-check me-2"></i>Confirm Field Definitions';
    confirmButton.addEventListener('click', handleConfirmFieldDefinitions);
    fieldDefinitions.appendChild(confirmButton);
    
    showNotification(`Defined ${count} fields for dictionary`, 'info');
}

// NEW: Confirm Field Definitions Handler
function handleConfirmFieldDefinitions() {
    const fieldNames = document.querySelectorAll('.field-name');
    const fieldTypes = document.querySelectorAll('.field-type');
    const fieldSamples = document.querySelectorAll('.field-sample');
    
    currentDictionary.fields = [];
    
    for (let i = 0; i < fieldNames.length; i++) {
        const name = fieldNames[i].value.trim();
        const type = fieldTypes[i].value;
        const sample = fieldSamples[i].value.trim();
        
        if (name === '') {
            showNotification(`Please enter name for field ${i + 1}`, 'danger');
            fieldNames[i].focus();
            return;
        }
        
        if (sample === '') {
            showNotification(`Please enter sample value for field ${i + 1}`, 'danger');
            fieldSamples[i].focus();
            return;
        }
        
        currentDictionary.fields.push({
            name: name,
            type: type,
            sample: sample
        });
    }
    
    // Show data entry section
    dataEntrySection.style.display = 'block';
    createDataEntryForm();
    
    showNotification('Field definitions confirmed. Now add data records.', 'success');
    logOperation(`Defined ${currentDictionary.fields.length} fields for dictionary`, 'info');
}

// NEW: Create Data Entry Form
function createDataEntryForm() {
    dataEntryForm.innerHTML = '';
    
    currentDictionary.fields.forEach((field, index) => {
        const fieldGroup = document.createElement('div');
        fieldGroup.className = 'row mb-2';
        fieldGroup.innerHTML = `
            <div class="col-md-12">
                <label class="form-label">${field.name} (${field.type})</label>
                <input type="text" class="form-control data-field" 
                       data-field="${field.name}" data-type="${field.type}"
                       placeholder="Enter ${field.type} value" 
                       value="${field.sample}">
            </div>
        `;
        dataEntryForm.appendChild(fieldGroup);
    });
}

// NEW: Add Record Handler
function handleAddRecord() {
    const dataFields = document.querySelectorAll('.data-field');
    const record = {};
    let isValid = true;
    
    currentDictionary.fields.forEach(field => {
        const fieldInput = document.querySelector(`.data-field[data-field="${field.name}"]`);
        const value = fieldInput.value.trim();
        
        if (value === '') {
            showNotification(`Please enter value for ${field.name}`, 'danger');
            fieldInput.focus();
            isValid = false;
            return;
        }
        
        // Validate data type
        if (field.type === 'int') {
            if (!/^-?\d+$/.test(value)) {
                showNotification(`${field.name} must be an integer`, 'danger');
                fieldInput.focus();
                isValid = false;
                return;
            }
            record[field.name] = parseInt(value);
        } else if (field.type === 'float') {
            if (!/^-?\d*\.?\d+$/.test(value)) {
                showNotification(`${field.name} must be a float`, 'danger');
                fieldInput.focus();
                isValid = false;
                return;
            }
            record[field.name] = parseFloat(value);
        } else {
            record[field.name] = value;
        }
    });
    
    if (!isValid) return;
    
    // Add record to dictionary
    currentDictionary.data.push(record);
    
    // Clear form
    dataFields.forEach(field => {
        field.value = '';
    });
    
    showNotification('Record added successfully', 'success');
    logOperation(`Added record to dictionary "${currentDictionary.name}"`, 'success');
    
    // Update display if data entry is finished
    if (dictionaryDisplaySection.style.display !== 'none') {
        updateDictionaryDisplay();
    }
}

// MODIFIED: Update the finishDataEntryHandler
function handleFinishDataEntry() {
    if (currentDictionary.data.length === 0) {
        showNotification('Please add at least one record before finishing', 'warning');
        return;
    }
    
    // Store original data for reset
    currentDictionary.originalData = JSON.parse(JSON.stringify(currentDictionary.data));
    
    // Show operations and display sections
    dictionaryOperationsSection.style.display = 'block';
    dictionaryDisplaySection.style.display = 'block';
    
    // Create table structure if it doesn't exist
    if (!document.getElementById('dictionaryTableHeader')) {
        dictionaryTableContainer.innerHTML = `
            <table class="dictionary-table table table-striped table-hover">
                <thead class="table-dark">
                    <tr id="dictionaryTableHeader"></tr>
                </thead>
                <tbody id="dictionaryTableBody"></tbody>
            </table>
        `;
    }
    
    // Populate sort field select
    sortFieldSelect.innerHTML = '';
    currentDictionary.fields.forEach(field => {
        const option = document.createElement('option');
        option.value = field.name;
        option.textContent = field.name;
        sortFieldSelect.appendChild(option);
    });
    
    // Update display
    updateDictionaryDisplay();
    
    showNotification('Data entry completed. Dictionary is ready for operations.', 'success');
    logOperation(`Completed data entry for dictionary "${currentDictionary.name}" with ${currentDictionary.data.length} records`, 'info');
}

// NEW: Update Dictionary Display
function updateDictionaryDisplay() {
    console.log('Updating dictionary display with data:', currentDictionary.data);
    
    // Update table header
    dictionaryTableHeader.innerHTML = '';
    currentDictionary.fields.forEach(field => {
        const th = document.createElement('th');
        th.textContent = field.name;
        dictionaryTableHeader.appendChild(th);
    });
    
    // Add actions column header
    const actionsTh = document.createElement('th');
    actionsTh.textContent = 'Actions';
    actionsTh.style.width = '120px';
    dictionaryTableHeader.appendChild(actionsTh);
    
    // Update table body
    dictionaryTableBody.innerHTML = '';
    
    if (currentDictionary.data.length === 0) {
        const emptyRow = document.createElement('tr');
        const emptyCell = document.createElement('td');
        emptyCell.colSpan = currentDictionary.fields.length + 1;
        emptyCell.textContent = 'No records found';
        emptyCell.className = 'text-center text-muted py-3';
        emptyRow.appendChild(emptyCell);
        dictionaryTableBody.appendChild(emptyRow);
    } else {
        currentDictionary.data.forEach((record, index) => {
            const tr = document.createElement('tr');
            tr.setAttribute('data-index', index);
            
            currentDictionary.fields.forEach(field => {
                const td = document.createElement('td');
                td.className = 'editable-field';
                td.setAttribute('data-field', field.name);
                td.setAttribute('data-index', index);
                td.textContent = record[field.name] || '';
                tr.appendChild(td);
            });
            
            // Add actions column
            const actionsTd = document.createElement('td');
            actionsTd.className = 'action-buttons';
            actionsTd.innerHTML = `
                <button class="btn btn-sm btn-outline-warning edit-record" data-index="${index}">
                    <i class="fas fa-edit"></i>
                </button>
                <button class="btn btn-sm btn-outline-danger delete-record" data-index="${index}">
                    <i class="fas fa-trash"></i>
                </button>
            `;
            tr.appendChild(actionsTd);
            
            dictionaryTableBody.appendChild(tr);
        });
    }
    
    console.log('Dictionary display updated successfully');
}

// NEW: Start Edit Field (Inline Editing)
function startEditField(td, fieldName, recordIndex) {
    if (isEditingRecord) {
        console.log('Already editing a record, please finish current edit first');
        return;
    }
    
    console.log('Starting inline edit for field:', fieldName, 'record:', recordIndex);
    
    const currentValue = td.textContent;
    const field = currentDictionary.fields.find(f => f.name === fieldName);
    
    if (!field) {
        console.error('Field not found:', fieldName);
        return;
    }
    
    td.innerHTML = `<input type="text" class="form-control form-control-sm inline-edit" 
                          value="${currentValue}" data-field="${fieldName}" data-index="${recordIndex}">`;
    
    const input = td.querySelector('.inline-edit');
    input.focus();
    input.select();
    
    const finishEdit = () => finishEditField(input, field, recordIndex);
    const cancelEdit = () => {
        td.textContent = currentValue;
        isEditingRecord = false;
    };
    
    input.addEventListener('blur', finishEdit);
    input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            finishEdit();
        } else if (e.key === 'Escape') {
            cancelEdit();
        }
    });
    
    isEditingRecord = true;
}

// NEW: Finish Edit Field
function finishEditField(input, field, recordIndex) {
    const newValue = input.value.trim();
    const td = input.parentElement;
    
    if (newValue === '') {
        td.textContent = currentDictionary.data[recordIndex][field.name];
        isEditingRecord = false;
        return;
    }
    
    // Validate data type
    let validatedValue = newValue;
    if (field.type === 'int') {
        if (!/^-?\d+$/.test(newValue)) {
            showNotification(`${field.name} must be an integer`, 'danger');
            td.textContent = currentDictionary.data[recordIndex][field.name];
            isEditingRecord = false;
            return;
        }
        validatedValue = parseInt(newValue);
    } else if (field.type === 'float') {
        if (!/^-?\d*\.?\d+$/.test(newValue)) {
            showNotification(`${field.name} must be a float`, 'danger');
            td.textContent = currentDictionary.data[recordIndex][field.name];
            isEditingRecord = false;
            return;
        }
        validatedValue = parseFloat(newValue);
    }
    
    // Update record
    currentDictionary.data[recordIndex][field.name] = validatedValue;
    td.textContent = validatedValue;
    
    showNotification(`Field "${field.name}" updated successfully`, 'success');
    logOperation(`Updated field "${field.name}" in record ${recordIndex}`, 'info');
    isEditingRecord = false;
}

// NEW: Edit Record Handler
function handleEditRecord(index) {
    console.log('Edit record handler called for index:', index);
    
    if (isEditingRecord) {
        showNotification('Please finish current edit before starting a new one', 'warning');
        return;
    }
    
    if (index < 0 || index >= currentDictionary.data.length) {
        showNotification('Invalid record index', 'danger');
        return;
    }
    
    isEditingRecord = true;
    editingRecordIndex = index;
    
    const record = currentDictionary.data[index];
    console.log('Editing record:', record);
    
    // Create edit form
    const editForm = document.createElement('div');
    editForm.className = 'edit-form-container';
    editForm.innerHTML = `
        <h6>Edit Record ${index}</h6>
        <div class="preview-highlight p-3 mb-3">
            <strong>Current Data:</strong><br>
            ${Object.entries(record).map(([key, value]) => `${key}: ${value}`).join('<br>')}
        </div>
        <div id="editRecordForm"></div>
        <div class="d-flex gap-2 mt-3">
            <button class="btn btn-glow" id="saveRecordBtn">
                <i class="fas fa-save me-2"></i>Save Changes
            </button>
            <button class="btn btn-outline-light" id="cancelEditBtn">
                <i class="fas fa-times me-2"></i>Cancel
            </button>
        </div>
    `;
    
    // Replace table with edit form temporarily
    const tableContainer = dictionaryDisplaySection.querySelector('.table-container');
    const originalTable = tableContainer.innerHTML;
    tableContainer.innerHTML = '';
    tableContainer.appendChild(editForm);
    
    // Create edit form fields
    const editRecordForm = document.getElementById('editRecordForm');
    currentDictionary.fields.forEach(field => {
        const fieldGroup = document.createElement('div');
        fieldGroup.className = 'mb-3';
        fieldGroup.innerHTML = `
            <label class="form-label">${field.name} (${field.type})</label>
            <input type="text" class="form-control edit-field" 
                   data-field="${field.name}" 
                   value="${record[field.name] || ''}">
        `;
        editRecordForm.appendChild(fieldGroup);
    });
    
    // Add event listeners
    document.getElementById('saveRecordBtn').addEventListener('click', handleSaveRecord);
    document.getElementById('cancelEditBtn').addEventListener('click', () => {
        tableContainer.innerHTML = originalTable;
        updateDictionaryDisplay();
        isEditingRecord = false;
        editingRecordIndex = -1;
        showNotification('Edit cancelled', 'info');
    });
}

// NEW: Save Record Handler
// NEW: Save Record Handler (Alternative robust version)
function handleSaveRecord() {
    console.log('Save record handler called');
    
    const editFields = document.querySelectorAll('.edit-field');
    const updatedRecord = {};
    let isValid = true;
    
    currentDictionary.fields.forEach(field => {
        const fieldInput = document.querySelector(`.edit-field[data-field="${field.name}"]`);
        const value = fieldInput.value.trim();
        
        if (value === '') {
            showNotification(`Please enter value for ${field.name}`, 'danger');
            fieldInput.focus();
            isValid = false;
            return;
        }
        
        // Validate data type
        if (field.type === 'int') {
            if (!/^-?\d+$/.test(value)) {
                showNotification(`${field.name} must be an integer`, 'danger');
                fieldInput.focus();
                isValid = false;
                return;
            }
            updatedRecord[field.name] = parseInt(value);
        } else if (field.type === 'float') {
            if (!/^-?\d*\.?\d+$/.test(value)) {
                showNotification(`${field.name} must be a float`, 'danger');
                fieldInput.focus();
                isValid = false;
                return;
            }
            updatedRecord[field.name] = parseFloat(value);
        } else {
            updatedRecord[field.name] = value;
        }
    });
    
    if (!isValid) return;
    
    // Update record
    currentDictionary.data[editingRecordIndex] = updatedRecord;
    
    // Simply restore the original table structure without complex HTML manipulation
    const tableContainer = dictionaryDisplaySection.querySelector('.table-container');
    
    // Create a fresh table
    tableContainer.innerHTML = `
        <table class="dictionary-table" id="dictionaryTable">
            <thead>
                <tr id="dictionaryTableHeader"></tr>
            </thead>
            <tbody id="dictionaryTableBody"></tbody>
        </table>
    `;
    
    // Get fresh references to the table elements
    const newHeader = document.getElementById('dictionaryTableHeader');
    const newBody = document.getElementById('dictionaryTableBody');
    
    // Update the display manually without relying on global variables
    updateTableDisplay(newHeader, newBody);
    
    isEditingRecord = false;
    editingRecordIndex = -1;
    
    showNotification('Record updated successfully', 'success');
    logOperation(`Updated record ${editingRecordIndex} in dictionary`, 'success');
}

// Helper function to update table display without relying on global variables
function updateTableDisplay(headerElement, bodyElement) {
    console.log('Updating table display with data:', currentDictionary.data);
    
    // Update table header
    headerElement.innerHTML = '';
    currentDictionary.fields.forEach(field => {
        const th = document.createElement('th');
        th.textContent = field.name;
        headerElement.appendChild(th);
    });
    
    // Add actions column header
    const actionsTh = document.createElement('th');
    actionsTh.textContent = 'Actions';
    actionsTh.style.width = '120px';
    headerElement.appendChild(actionsTh);
    
    // Update table body
    bodyElement.innerHTML = '';
    
    if (currentDictionary.data.length === 0) {
        const emptyRow = document.createElement('tr');
        const emptyCell = document.createElement('td');
        emptyCell.colSpan = currentDictionary.fields.length + 1;
        emptyCell.textContent = 'No records found';
        emptyCell.className = 'text-center text-muted py-3';
        emptyRow.appendChild(emptyCell);
        bodyElement.appendChild(emptyRow);
    } else {
        currentDictionary.data.forEach((record, index) => {
            const tr = document.createElement('tr');
            tr.setAttribute('data-index', index);
            
            currentDictionary.fields.forEach(field => {
                const td = document.createElement('td');
                td.className = 'editable-field';
                td.setAttribute('data-field', field.name);
                td.setAttribute('data-index', index);
                td.textContent = record[field.name] || '';
                tr.appendChild(td);
            });
            
            // Add actions column
            const actionsTd = document.createElement('td');
            actionsTd.className = 'action-buttons';
            actionsTd.innerHTML = `
                <button class="btn btn-sm btn-outline-warning edit-record" data-index="${index}">
                    <i class="fas fa-edit"></i>
                </button>
                <button class="btn btn-sm btn-outline-danger delete-record" data-index="${index}">
                    <i class="fas fa-trash"></i>
                </button>
            `;
            tr.appendChild(actionsTd);
            
            bodyElement.appendChild(tr);
        });
    }
    
    console.log('Table display updated successfully');
}

// WORKING: Delete Record Handler with guaranteed event handling
function handleDeleteRecord(index) {
    console.log('Delete record handler called for index:', index);
    
    if (index < 0 || index >= currentDictionary.data.length) {
        showNotification('Invalid record index', 'danger');
        return;
    }
    
    const record = currentDictionary.data[index];
    const recordSummary = Object.entries(record).map(([key, value]) => `${key}: ${value}`).join(', ');
    
    // Create overlay
    const overlay = document.createElement('div');
    overlay.className = 'confirmation-overlay';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
    `;
    
    // Create confirmation dialog
    const confirmation = document.createElement('div');
    confirmation.className = 'confirmation-dialog bg-dark p-4 rounded border border-warning';
    confirmation.style.cssText = `
        max-width: 500px;
        width: 90%;
        box-shadow: 0 0 30px rgba(255,193,7,0.3);
    `;
    
    // Create the HTML content
    confirmation.innerHTML = `
        <h6 class="text-warning mb-3">
            <i class="fas fa-exclamation-triangle me-2"></i>Confirm Deletion
        </h6>
        <p class="text-light mb-2">Are you sure you want to delete this record?</p>
        <div class="preview-highlight p-3 mb-3 bg-secondary text-light rounded">
            <strong class="text-warning">Record Details:</strong><br>
            ${recordSummary}
        </div>
        <div class="d-flex gap-2 justify-content-center">
            <button class="btn btn-danger flex-fill" id="confirmDeleteBtn">
                <i class="fas fa-check me-2"></i>Yes, Delete
            </button>
            <button class="btn btn-outline-light flex-fill" id="cancelDeleteBtn">
                <i class="fas fa-times me-2"></i>No, Cancel
            </button>
        </div>
    `;
    
    // Add to DOM
    overlay.appendChild(confirmation);
    document.body.appendChild(overlay);
    
    // **IMMEDIATELY attach event listeners after adding to DOM**
    const confirmBtn = confirmation.querySelector('#confirmDeleteBtn');
    const cancelBtn = confirmation.querySelector('#cancelDeleteBtn');
    
    // Function to remove overlay and clean up
    function removeOverlay() {
        if (document.body.contains(overlay)) {
            document.body.removeChild(overlay);
        }
    }
    
    // Confirm deletion function
    const onConfirm = () => {
        console.log('User confirmed deletion for record:', index);
        
        // Remove the record from data
        currentDictionary.data.splice(index, 1);
        
        // Remove overlay
        removeOverlay();
        
        // Show success notification
        showNotification('Record deleted successfully', 'success');
        logOperation(`Deleted record ${index} from dictionary`, 'warning');
        
        // Update the display
        updateDictionaryDisplay();
        
        console.log('Record deleted successfully');
    };
    
    // Cancel deletion function
    const onCancel = () => {
        console.log('User cancelled deletion');
        removeOverlay();
        showNotification('Deletion cancelled', 'info');
    };
    
    // Attach event listeners DIRECTLY
    confirmBtn.onclick = onConfirm;
    cancelBtn.onclick = onCancel; // This will now work properly
    
    // Close when clicking outside the dialog
    overlay.onclick = (e) => {
        if (e.target === overlay) {
            onCancel();
        }
    };
    
    // Prevent dialog clicks from closing the overlay
    confirmation.onclick = (e) => {
        e.stopPropagation();
    };
}
// NEW: Function to reinitialize table references
function reinitializeTableReferences() {
    // Re-initialize global table element references
    window.dictionaryTableHeader = document.getElementById('dictionaryTableHeader');
    window.dictionaryTableBody = document.getElementById('dictionaryTableBody');
    window.dictionaryTableContainer = document.getElementById('dictionaryTableContainer');
    
    console.log('Table references reinitialized:', {
        header: !!dictionaryTableHeader,
        body: !!dictionaryTableBody,
        container: !!dictionaryTableContainer
    });
}
// NEW: Simple and reliable table restoration approach
function restoreTableAfterOperation() {
    const container = dictionaryTableContainer;
    if (!container) {
        console.error('Table container not found');
        return;
    }
    
    // Simple table structure
    container.innerHTML = `
        <table class="dictionary-table table table-striped table-hover">
            <thead class="table-dark">
                <tr id="dictionaryTableHeader"></tr>
            </thead>
            <tbody id="dictionaryTableBody"></tbody>
        </table>
    `;
    
    // Re-initialize references
    reinitializeTableReferences();
    
    // Update display
    updateDictionaryDisplay();
}
// NEW: SIMPLE updateDictionaryDisplay function
function updateDictionaryDisplay() {
    console.log('Updating dictionary display with data:', currentDictionary.data);
    
    // Get fresh references to table elements
    const header = document.getElementById('dictionaryTableHeader');
    const body = document.getElementById('dictionaryTableBody');
    
    if (!header || !body) {
        console.error('Table elements not found!');
        return;
    }
    
    // Clear existing content
    header.innerHTML = '';
    body.innerHTML = '';
    
    // Create header
    currentDictionary.fields.forEach(field => {
        const th = document.createElement('th');
        th.textContent = field.name;
        th.setAttribute('data-field', field.name);
        header.appendChild(th);
    });
    
    // Add actions column header
    const actionsTh = document.createElement('th');
    actionsTh.textContent = 'Actions';
    actionsTh.style.width = '120px';
    actionsTh.className = 'text-center';
    header.appendChild(actionsTh);
    
    // Create body rows
    if (currentDictionary.data.length === 0) {
        const emptyRow = document.createElement('tr');
        const emptyCell = document.createElement('td');
        emptyCell.colSpan = currentDictionary.fields.length + 1;
        emptyCell.textContent = 'No records found';
        emptyCell.className = 'text-center text-muted py-4';
        emptyRow.appendChild(emptyCell);
        body.appendChild(emptyRow);
    } else {
        currentDictionary.data.forEach((record, index) => {
            const tr = document.createElement('tr');
            tr.setAttribute('data-index', index);
            
            // Create data cells
            currentDictionary.fields.forEach(field => {
                const td = document.createElement('td');
                td.className = 'editable-field align-middle';
                td.setAttribute('data-field', field.name);
                td.setAttribute('data-index', index);
                td.setAttribute('data-type', field.type);
                td.textContent = record[field.name] || '';
                tr.appendChild(td);
            });
            
            // Create actions cell
            const actionsTd = document.createElement('td');
            actionsTd.className = 'action-buttons text-center align-middle';
            actionsTd.innerHTML = `
                <button class="btn btn-sm btn-outline-warning edit-record me-1" data-index="${index}" title="Edit Record">
                    <i class="fas fa-edit"></i>
                </button>
                <button class="btn btn-sm btn-outline-danger delete-record" data-index="${index}" title="Delete Record">
                    <i class="fas fa-trash"></i>
                </button>
            `;
            tr.appendChild(actionsTd);
            
            body.appendChild(tr);
        });
    }
    
    console.log('Dictionary display updated successfully with', currentDictionary.data.length, 'records');
}

// NEW: Helper function to restore table structure if needed
function restoreTableStructure() {
    const container = dictionaryTableContainer;
    container.innerHTML = `
        <table class="dictionary-table table table-striped table-hover">
            <thead class="table-dark">
                <tr id="dictionaryTableHeader"></tr>
            </thead>
            <tbody id="dictionaryTableBody"></tbody>
        </table>
    `;
    
    // Re-initialize global references
    window.dictionaryTableHeader = document.getElementById('dictionaryTableHeader');
    window.dictionaryTableBody = document.getElementById('dictionaryTableBody');
    
    console.log('Table structure restored');
}


// NEW: Update Dictionary Handler
function handleUpdateDictionary() {
    // Create update form
    const updateForm = document.createElement('div');
    updateForm.className = 'edit-form-container';
    updateForm.innerHTML = `
        <h6>Update Dictionary "${currentDictionary.name}"</h6>
        <div class="mb-3">
            <label class="form-label">Dictionary Name</label>
            <input type="text" class="form-control" id="updateDictionaryName" value="${currentDictionary.name}">
        </div>
        <div id="updateFieldsForm"></div>
        <div class="d-flex gap-2 mt-3">
            <button class="btn btn-glow" id="saveDictionaryBtn">
                <i class="fas fa-save me-2"></i>Save Changes
            </button>
            <button class="btn btn-outline-light" id="cancelUpdateBtn">
                <i class="fas fa-times me-2"></i>Cancel
            </button>
        </div>
    `;
    
    // Replace operations section with update form temporarily
    const operationsSection = dictionaryOperationsSection.innerHTML;
    dictionaryOperationsSection.innerHTML = '';
    dictionaryOperationsSection.appendChild(updateForm);
    
    // Create update fields form
    const updateFieldsForm = document.getElementById('updateFieldsForm');
    currentDictionary.fields.forEach((field, index) => {
        const fieldGroup = document.createElement('div');
        fieldGroup.className = 'row mb-3';
        fieldGroup.innerHTML = `
            <div class="col-md-4">
                <label class="form-label">Field ${index + 1} Name</label>
                <input type="text" class="form-control update-field-name" value="${field.name}" data-index="${index}">
            </div>
            <div class="col-md-4">
                <label class="form-label">Field ${index + 1} Type</label>
                <select class="form-control update-field-type" data-index="${index}">
                    <option value="string" ${field.type === 'string' ? 'selected' : ''}>String</option>
                    <option value="int" ${field.type === 'int' ? 'selected' : ''}>Integer</option>
                    <option value="float" ${field.type === 'float' ? 'selected' : ''}>Float</option>
                </select>
            </div>
        `;
        updateFieldsForm.appendChild(fieldGroup);
    });
    
    // Add event listeners
    document.getElementById('saveDictionaryBtn').addEventListener('click', handleSaveDictionary);
    document.getElementById('cancelUpdateBtn').addEventListener('click', () => {
        dictionaryOperationsSection.innerHTML = operationsSection;
        // Reattach event listeners
        document.getElementById('updateDictionaryBtn').addEventListener('click', handleUpdateDictionary);
        document.getElementById('dropDictionaryBtn').addEventListener('click', handleDropDictionary);
        document.getElementById('performSortBtn').addEventListener('click', handlePerformSort);
    });
}

// NEW: Save Dictionary Handler
function handleSaveDictionary() {
    const newName = document.getElementById('updateDictionaryName').value.trim();
    const fieldNames = document.querySelectorAll('.update-field-name');
    const fieldTypes = document.querySelectorAll('.update-field-type');
    
    if (newName === '') {
        showNotification('Please enter a dictionary name', 'danger');
        return;
    }
    
    // Update dictionary name
    const oldName = currentDictionary.name;
    currentDictionary.name = newName;
    
    // Update fields
    let hasError = false;
    currentDictionary.fields.forEach((field, index) => {
        const newFieldName = fieldNames[index].value.trim();
        const newFieldType = fieldTypes[index].value;
        
        if (newFieldName === '') {
            showNotification(`Please enter name for field ${index + 1}`, 'danger');
            hasError = true;
            return;
        }
        
        // Update field in dictionary structure
        field.name = newFieldName;
        field.type = newFieldType;
        
        // Update field in all records
        if (newFieldName !== field.name) {
            currentDictionary.data.forEach(record => {
                record[newFieldName] = record[field.name];
                delete record[field.name];
            });
        }
    });
    
    if (hasError) return;
    
    // Update sort field select
    sortFieldSelect.innerHTML = '';
    currentDictionary.fields.forEach(field => {
        const option = document.createElement('option');
        option.value = field.name;
        option.textContent = field.name;
        sortFieldSelect.appendChild(option);
    });
    
    // Update display
    updateDictionaryDisplay();
    
    showNotification(`Dictionary "${oldName}" updated to "${newName}" successfully`, 'success');
    logOperation(`Updated dictionary from "${oldName}" to "${newName}"`, 'info');
    
    // Reload the page section to reset event listeners
    handleCancelCustomSort();
    handleCustomComparatorSort();
    // Skip to operations section
    dictionaryStructureSection.style.display = 'none';
    dataEntrySection.style.display = 'none';
    dictionaryOperationsSection.style.display = 'block';
    dictionaryDisplaySection.style.display = 'block';
}

// NEW: Drop Dictionary Handler
function handleDropDictionary() {
    // Create confirmation dialog
    const confirmation = document.createElement('div');
    confirmation.className = 'confirmation-dialog';
    confirmation.innerHTML = `
        <h6><i class="fas fa-exclamation-triangle text-danger me-2"></i>Confirm Dictionary Drop</h6>
        <p>Are you sure you want to drop the entire dictionary "${currentDictionary.name}"?</p>
        <p class="text-warning"><strong>This action cannot be undone!</strong></p>
        <div class="d-flex gap-2 justify-content-center">
            <button class="btn btn-danger" id="confirmDropBtn">
                <i class="fas fa-trash me-2"></i>Yes, Drop Dictionary
            </button>
            <button class="btn btn-outline-light" id="cancelDropBtn">
                <i class="fas fa-times me-2"></i>No, Cancel
            </button>
        </div>
    `;
    
    // Replace operations section with confirmation temporarily
    const operationsSection = dictionaryOperationsSection.innerHTML;
    dictionaryOperationsSection.innerHTML = '';
    dictionaryOperationsSection.appendChild(confirmation);
    
    // Add event listeners
    document.getElementById('confirmDropBtn').addEventListener('click', () => {
        showNotification(`Dictionary "${currentDictionary.name}" dropped successfully`, 'success');
        logOperation(`Dropped dictionary "${currentDictionary.name}"`, 'warning');
        handleCancelCustomSort();
    });
    
    document.getElementById('cancelDropBtn').addEventListener('click', () => {
        dictionaryOperationsSection.innerHTML = operationsSection;
        // Reattach event listeners
        document.getElementById('updateDictionaryBtn').addEventListener('click', handleUpdateDictionary);
        document.getElementById('dropDictionaryBtn').addEventListener('click', handleDropDictionary);
        document.getElementById('performSortBtn').addEventListener('click', handlePerformSort);
        showNotification('Dictionary drop cancelled', 'info');
    });
}

// NEW: Perform Sort Handler
async function handlePerformSort() {
    const sortField = sortFieldSelect.value;
    const sortOrder = sortOrderSelect.value;
    
    if (!sortField) {
        showNotification('Please select a field to sort by', 'danger');
        return;
    }
    
    // Show visualization section
    sortVisualizationSection.style.display = 'block';
    sortStepsContainer.innerHTML = '';
    
    // Get the field type for comparison
    const field = currentDictionary.fields.find(f => f.name === sortField);
    const fieldType = field ? field.type : 'string';
    
    // Create custom comparator
    const customComparator = (a, b) => {
        let aValue = a[sortField];
        let bValue = b[sortField];
        
        // Convert to numbers if field type is numeric
        if (fieldType === 'int' || fieldType === 'float') {
            aValue = fieldType === 'int' ? parseInt(aValue) : parseFloat(aValue);
            bValue = fieldType === 'int' ? parseInt(bValue) : parseFloat(bValue);
        }
        
        if (aValue < bValue) return sortOrder === 'asc' ? -1 : 1;
        if (aValue > bValue) return sortOrder === 'asc' ? 1 : -1;
        return 0;
    };
    
    // Start sorting visualization
    await visualizeSortProcess(customComparator, sortField, sortOrder, fieldType);
}

// NEW: Visualize Sort Process
async function visualizeSortProcess(comparator, sortField, sortOrder, fieldType) {
    const data = [...currentDictionary.data];
    const steps = [];
    
    // Add initial step
    steps.push({
        step: 0,
        description: `Starting custom comparator sort by field "${sortField}" in ${sortOrder === 'asc' ? 'ascending' : 'descending'} order`,
        data: [...data],
        highlighted: []
    });
    
    // Use bubble sort for visualization (easy to follow)
    for (let i = 0; i < data.length - 1; i++) {
        for (let j = 0; j < data.length - i - 1; j++) {
            // Highlight current comparison
            steps.push({
                step: steps.length,
                description: `Comparing records ${j} and ${j + 1}: ${data[j][sortField]} vs ${data[j + 1][sortField]}`,
                data: [...data],
                highlighted: [j, j + 1]
            });
            
            if (comparator(data[j], data[j + 1]) > 0) {
                // Swap needed
                [data[j], data[j + 1]] = [data[j + 1], data[j]];
                
                steps.push({
                    step: steps.length,
                    description: `Swapped records ${j} and ${j + 1} because ${data[j + 1][sortField]} ${sortOrder === 'asc' ? '>' : '<'} ${data[j][sortField]}`,
                    data: [...data],
                    highlighted: [j, j + 1],
                    swapped: true
                });
            }
        }
        
        // Mark sorted element
        steps.push({
            step: steps.length,
            description: `Record ${data.length - i - 1} is now in its final position`,
            data: [...data],
            highlighted: [data.length - i - 1],
            sorted: true
        });
    }
    
    // Final step
    steps.push({
        step: steps.length,
        description: `Sorting completed! All records are now sorted by "${sortField}" in ${sortOrder === 'asc' ? 'ascending' : 'descending'} order`,
        data: [...data],
        highlighted: [],
        completed: true
    });
    
    // Display steps with animation
    for (let i = 0; i < steps.length; i++) {
        await displaySortStep(steps[i], i);
        await new Promise(resolve => setTimeout(resolve, 1000)); // Delay between steps
    }
    
    // Update the actual data
    currentDictionary.data = data;
    updateDictionaryDisplay();
    
    showNotification(`Custom comparator sort completed successfully`, 'success');
    logOperation(`Performed custom comparator sort by "${sortField}" (${sortOrder})`, 'success');
}

// NEW: Display Sort Step
async function displaySortStep(step, stepIndex) {
    sortStepsContainer.innerHTML = '';
    
    const stepElement = document.createElement('div');
    stepElement.className = `sort-step ${step.completed ? 'active' : ''}`;
    stepElement.innerHTML = `
        <strong>Step ${step.step}:</strong> ${step.description}
    `;
    sortStepsContainer.appendChild(stepElement);
    
    // Update the table display to show current state
    dictionaryTableBody.innerHTML = '';
    step.data.forEach((record, index) => {
        const tr = document.createElement('tr');
        tr.setAttribute('data-index', index);
        
        if (step.highlighted.includes(index)) {
            tr.className = step.swapped ? 'dictionary-record-highlight' : 'dictionary-record-sorted';
        }
        
        currentDictionary.fields.forEach(field => {
            const td = document.createElement('td');
            td.textContent = record[field.name];
            tr.appendChild(td);
        });
        
        // Add empty actions column for visualization
        const actionsTd = document.createElement('td');
        actionsTd.innerHTML = '-';
        tr.appendChild(actionsTd);
        
        dictionaryTableBody.appendChild(tr);
    });
    
    // Scroll to the current step
    stepElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

// NEW: Reset After Sort Handler
function handleResetAfterSort() {
    // Restore original data
    currentDictionary.data = JSON.parse(JSON.stringify(currentDictionary.originalData));
    updateDictionaryDisplay();
    
    // Hide visualization section
    sortVisualizationSection.style.display = 'none';
    
    showNotification('Data restored to original order', 'info');
    logOperation('Reset dictionary data to original order', 'info');
}

// NEW: Cancel Custom Sort Handler
function handleCancelCustomSort() {
    isCustomSortRunning = false;
    customComparatorContainer.style.display = 'none';
    
    // Reset all inputs
    dictionaryName.value = '';
    fieldCount.value = '';
    fieldDefinitions.innerHTML = '';
    dataEntryForm.innerHTML = '';
    
    // Reset dictionary
    currentDictionary = {
        name: '',
        fields: [],
        data: [],
        originalData: []
    };
    
    showNotification('Custom comparator sort cancelled', 'warning');
    logOperation('Cancelled custom comparator sort operation', 'warning');
}

// ENHANCED: Improved showNotification function
function showNotification(message, type) {
    // Remove any existing notifications first
    const existingNotifications = document.querySelectorAll('.custom-notification');
    existingNotifications.forEach(notification => notification.remove());
    
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `custom-notification alert alert-${type} alert-dismissible fade show position-fixed`;
    notification.style.cssText = `
        top: 20px;
        right: 20px;
        z-index: 9999;
        min-width: 300px;
    `;
    notification.innerHTML = `
        <strong>${type.toUpperCase()}:</strong> ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    document.body.appendChild(notification);
    
    // Auto remove after 4 seconds
    setTimeout(() => {
        if (notification.parentElement) {
            notification.remove();
        }
    }, 4000);
    
    console.log(`${type.toUpperCase()}: ${message}`);
}

function logOperation(message, level) {
    // Your logging implementation
    console.log(`${level}: ${message}`);
}

// NEW: Quick Sort Handler
function handleQuickSort() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - already sorted', 'info');
        return;
    }
    
    if (isQuickSortRunning) {
        showNotification('Quick sort is already in progress', 'warning');
        return;
    }
    
    isQuickSortRunning = true;
    
    // Store original array
    originalArrayForQuickSort = [...myArray];
    
    // Show quick sort visualization
    showQuickSortVisualization();
}

// NEW: Heap Sort Handler
function handleHeapSort() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - already sorted', 'info');
        return;
    }
    
    if (isHeapSortRunning) {
        showNotification('Heap sort is already in progress', 'warning');
        return;
    }
    
    isHeapSortRunning = true;
    
    // Store original array
    originalArrayForHeapSort = [...myArray];
    
    // Show heap sort visualization
    showHeapSortVisualization();
}
// NEW: Show Quick Sort Visualization
function showQuickSortVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Quick Sort Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalQuickSortArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Quick Sort Process</div>
            <div class="transformed-array-container" id="transformedQuickSortArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Quick Sort:</strong> Divide and conquer algorithm using pivots</p>
            <p class="mb-0" id="quickSortExplanation">Initializing quick sort...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="quickSortStepsContainer">
            <h6 class="text-center">Quick Sort Steps</h6>
            <div class="steps-container" id="quickSortSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterQuickSort" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForQuickSort, 'originalQuickSortArray');
    renderArrayInContainer([...originalArrayForQuickSort], 'transformedQuickSortArray');
    
    performQuickSortAnimation();
}

// NEW: Show Heap Sort Visualization
function showHeapSortVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Heap Sort Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalHeapSortArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Heap Sort Process</div>
            <div class="transformed-array-container" id="transformedHeapSortArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Heap Sort:</strong> Build max heap and repeatedly extract maximum element</p>
            <p class="mb-0" id="heapSortExplanation">Initializing heap sort...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="heapSortStepsContainer">
            <h6 class="text-center">Heap Sort Steps</h6>
            <div class="steps-container" id="heapSortSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterHeapSort" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForHeapSort, 'originalHeapSortArray');
    renderArrayInContainer([...originalArrayForHeapSort], 'transformedHeapSortArray');
    
    performHeapSortAnimation();
}
// NEW: Perform Quick Sort Animation
async function performQuickSortAnimation() {
    const originalContainer = document.getElementById('originalQuickSortArray');
    const transformedContainer = document.getElementById('transformedQuickSortArray');
    const explanation = document.getElementById('quickSortExplanation');
    const stepsContainer = document.getElementById('quickSortSteps');
    const continueButton = document.getElementById('continueAfterQuickSort');
    
    let array = [...originalArrayForQuickSort];
    let stepCount = 0;
    
    // Convert to numbers for comparison if possible
    const isNumeric = !array.some(item => isNaN(parseFloat(item)));
    
    async function quickSort(arr, low, high) {
        if (low < high) {
            stepCount++;
            explanation.innerHTML = `Step ${stepCount}: Partitioning subarray from index ${low} to ${high}`;
            
            // Highlight current subarray
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            for (let i = low; i <= high; i++) {
                transformedElements[i].querySelector('.element-value').classList.add('quick-sort-partition');
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${stepCount}:</strong> Partitioning subarray [${low}-${high}]
                </div>
            `;
            
            await new Promise(resolve => setTimeout(resolve, 1500));
            
            const pivotIndex = await partition(arr, low, high);
            
            // Remove highlights
            for (let i = low; i <= high; i++) {
                transformedElements[i].querySelector('.element-value').classList.remove('quick-sort-partition');
            }
            
            await quickSort(arr, low, pivotIndex - 1);
            await quickSort(arr, pivotIndex + 1, high);
        } else if (low === high) {
            // Single element subarray is sorted
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements[low].querySelector('.element-value').classList.add('quick-sort-sorted');
        }
    }
    
    async function partition(arr, low, high) {
        // Choose last element as pivot
        const pivot = isNumeric ? parseFloat(arr[high]) : arr[high];
        let i = low - 1;
        
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        
        // Highlight pivot
        transformedElements[high].querySelector('.element-value').classList.add('quick-sort-pivot');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Partition:</strong> Pivot = ${arr[high]} at index ${high}
            </div>
        `;
        
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        for (let j = low; j < high; j++) {
            const currentVal = isNumeric ? parseFloat(arr[j]) : arr[j];
            const shouldSwap = isNumeric ? currentVal <= pivot : arr[j] <= pivot;
            
            // Highlight current element being compared
            transformedElements[j].querySelector('.element-value').classList.add('sorting-current');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Compare:</strong> arr[${j}]=${arr[j]} ${shouldSwap ? '' : '>'} pivot=${arr[high]}
                </div>
            `;
            
            await new Promise(resolve => setTimeout(resolve, 800));
            
            if (shouldSwap) {
                i++;
                
                if (i !== j) {
                    // Swap elements
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Swap:</strong> arr[${i}]=${arr[i]}  arr[${j}]=${arr[j]}
                        </div>
                    `;
                    
                    // Highlight elements being swapped
                    transformedElements[i].querySelector('.element-value').classList.add('sorting-swap');
                    transformedElements[j].querySelector('.element-value').classList.add('sorting-swap');
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                    renderArrayInContainer(arr, 'transformedQuickSortArray');
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            }
            
            // Remove highlights
            transformedElements[j].querySelector('.element-value').classList.remove('sorting-current', 'sorting-swap');
            if (i >= 0) {
                transformedElements[i].querySelector('.element-value').classList.remove('sorting-swap');
            }
        }
        
        // Swap pivot with element at i+1
        if (i + 1 !== high) {
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final Swap:</strong> Moving pivot to correct position at index ${i + 1}
                </div>
            `;
            
            [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
            renderArrayInContainer(arr, 'transformedQuickSortArray');
        }
        
        // Remove pivot highlight and mark as sorted
        transformedElements[high].querySelector('.element-value').classList.remove('quick-sort-pivot');
        transformedElements[i + 1].querySelector('.element-value').classList.add('quick-sort-sorted');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Partition Complete:</strong> Pivot ${arr[i + 1]} at final position ${i + 1}
            </div>
        `;
        
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        return i + 1;
    }
    
    // Start quick sort
    await quickSort(array, 0, array.length - 1);
    
    // Algorithm completed
    explanation.innerHTML = `<strong>Quick Sort Completed!</strong> Array is now sorted.`;
    
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Final:</strong> Quick sort completed successfully!
        </div>
    `;
    
    continueButton.style.display = 'block';
    
    // Auto-return after 5 seconds
    setTimeout(() => {
        returnToOriginalAfterQuickSort();
    }, 5000);
    
    continueButton.addEventListener('click', returnToOriginalAfterQuickSort);
}

// NEW: Perform Heap Sort Animation
async function performHeapSortAnimation() {
    const originalContainer = document.getElementById('originalHeapSortArray');
    const transformedContainer = document.getElementById('transformedHeapSortArray');
    const explanation = document.getElementById('heapSortExplanation');
    const stepsContainer = document.getElementById('heapSortSteps');
    const continueButton = document.getElementById('continueAfterHeapSort');
    
    let array = [...originalArrayForHeapSort];
    let stepCount = 0;
    const n = array.length;
    
    // Convert to numbers for comparison if possible
    const isNumeric = !array.some(item => isNaN(parseFloat(item)));
    
    async function heapify(arr, n, i) {
        let largest = i;
        const left = 2 * i + 1;
        const right = 2 * i + 2;
        
        stepCount++;
        explanation.innerHTML = `Step ${stepCount}: Heapifying node at index ${i}`;
        
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        
        // Highlight current parent and children
        transformedElements[i].querySelector('.element-value').classList.add('heap-sort-parent');
        if (left < n) transformedElements[left].querySelector('.element-value').classList.add('heap-sort-child');
        if (right < n) transformedElements[right].querySelector('.element-value').classList.add('heap-sort-child');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${stepCount}:</strong> Heapifying node ${i} (value: ${arr[i]})
            </div>
        `;
        
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Check left child
        if (left < n) {
            const shouldSwap = isNumeric ? 
                parseFloat(arr[left]) > parseFloat(arr[largest]) : 
                arr[left] > arr[largest];
                
            if (shouldSwap) {
                largest = left;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Left Child:</strong> arr[${left}]=${arr[left]} > current largest
                    </div>
                `;
            }
        }
        
        // Check right child
        if (right < n) {
            const shouldSwap = isNumeric ? 
                parseFloat(arr[right]) > parseFloat(arr[largest]) : 
                arr[right] > arr[largest];
                
            if (shouldSwap) {
                largest = right;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Right Child:</strong> arr[${right}]=${arr[right]} > current largest
                    </div>
                `;
            }
        }
        
        // If largest is not root
        if (largest !== i) {
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Swap Needed:</strong> Swapping parent ${arr[i]} with child ${arr[largest]}
                </div>
            `;
            
            // Highlight swap
            transformedElements[i].querySelector('.element-value').classList.add('sorting-swap');
            transformedElements[largest].querySelector('.element-value').classList.add('sorting-swap');
            
            await new Promise(resolve => setTimeout(resolve, 800));
            
            [arr[i], arr[largest]] = [arr[largest], arr[i]];
            renderArrayInContainer(arr, 'transformedHeapSortArray');
            
            await new Promise(resolve => setTimeout(resolve, 800));
            
            // Recursively heapify the affected sub-tree
            await heapify(arr, n, largest);
        } else {
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Heapify Complete:</strong> Node ${i} satisfies heap property
                </div>
            `;
        }
        
        // Remove highlights and mark as heapified
        transformedElements[i].querySelector('.element-value').classList.remove('heap-sort-parent', 'sorting-swap');
        transformedElements[i].querySelector('.element-value').classList.add('heap-sort-heapified');
        if (left < n) transformedElements[left].querySelector('.element-value').classList.remove('heap-sort-child');
        if (right < n) transformedElements[right].querySelector('.element-value').classList.remove('heap-sort-child');
        
        await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    // Build max heap
    explanation.innerHTML = "Building max heap...";
    stepsContainer.innerHTML += `<div class="algorithm-step"><strong>Phase 1:</strong> Building Max Heap</div>`;
    
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
        await heapify(array, n, i);
    }
    
    stepsContainer.innerHTML += `<div class="algorithm-step active"><strong>Max Heap Built:</strong> Heap construction complete</div>`;
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // Extract elements from heap one by one
    explanation.innerHTML = "Extracting elements from heap...";
    stepsContainer.innerHTML += `<div class="algorithm-step"><strong>Phase 2:</strong> Sorting by Extraction</div>`;
    
    for (let i = n - 1; i > 0; i--) {
        stepCount++;
        explanation.innerHTML = `Step ${stepCount}: Moving current root to sorted position`;
        
        // Move current root to end
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Extract:</strong> Moving root ${array[0]} to sorted position ${i}
            </div>
        `;
        
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        transformedElements[0].querySelector('.element-value').classList.add('sorting-swap');
        transformedElements[i].querySelector('.element-value').classList.add('sorting-swap');
        
        await new Promise(resolve => setTimeout(resolve, 800));
        
        [array[0], array[i]] = [array[i], array[0]];
        renderArrayInContainer(array, 'transformedHeapSortArray');
        
        await new Promise(resolve => setTimeout(resolve, 800));
        
        // Mark the moved element as sorted
        transformedElements[i].querySelector('.element-value').classList.remove('sorting-swap');
        transformedElements[i].querySelector('.element-value').classList.add('quick-sort-sorted');
        
        // Call heapify on the reduced heap
        await heapify(array, i, 0);
    }
    
    // Mark first element as sorted
    const transformedElements = transformedContainer.querySelectorAll('.array-element');
    transformedElements[0].querySelector('.element-value').classList.add('quick-sort-sorted');
    
    // Algorithm completed
    explanation.innerHTML = `<strong>Heap Sort Completed!</strong> Array is now sorted.`;
    
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Final:</strong> Heap sort completed successfully!
        </div>
    `;
    
    continueButton.style.display = 'block';
    
    // Auto-return after 5 seconds
    setTimeout(() => {
        returnToOriginalAfterHeapSort();
    }, 5000);
    
    continueButton.addEventListener('click', returnToOriginalAfterHeapSort);
}
// NEW: Return to Original after Quick Sort
function returnToOriginalAfterQuickSort() {
    // Reset to original array
    myArray = [...originalArrayForQuickSort];
    originalArrayForQuickSort = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isQuickSortRunning = false;
    
    logOperation('Quick sort completed - returned to original array', 'info');
    showNotification('Returned to original array after quick sort', 'success');
}

// NEW: Return to Original after Heap Sort
function returnToOriginalAfterHeapSort() {
    // Reset to original array
    myArray = [...originalArrayForHeapSort];
    originalArrayForHeapSort = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isHeapSortRunning = false;
    
    logOperation('Heap sort completed - returned to original array', 'info');
    showNotification('Returned to original array after heap sort', 'success');
}
// NEW: Sort Even Before Odd Handler
function handleSortEvenBeforeOdd() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isEvenOddSortRunning) {
        showNotification('Even-odd sort is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Even-odd sort requires all array elements to be numbers', 'danger');
        return;
    }
    
    isEvenOddSortRunning = true;
    
    // Store original array
    originalArrayForSpecialSort = [...myArray];
    
    // Show even-odd sort visualization
    showEvenOddSortVisualization();
}
// NEW: Sort by Absolute Value Handler
function handleSortByAbsoluteValue() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isAbsoluteSortRunning) {
        showNotification('Absolute value sort is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Absolute value sort requires all array elements to be numbers', 'danger');
        return;
    }
    
    isAbsoluteSortRunning = true;
    
    // Store original array
    originalArrayForSpecialSort = [...myArray];
    
    // Show absolute value sort visualization
    showAbsoluteSortVisualization();
}

// NEW: Sort by Absolute Value Handler
function handleSortAbsoluteValue() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isAbsoluteValueSortRunning) {
        showNotification('Absolute value sort is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Absolute value sorting requires all array elements to be numbers', 'danger');
        return;
    }
    
    isAbsoluteValueSortRunning = true;
    
    // Store original array
    originalArrayForSpecialSort = [...myArray];
    
    // Show absolute value sort visualization
    showAbsoluteValueSortVisualization();
}
// NEW: Show Even-Odd Sort Visualization
function showEvenOddSortVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Sort Even Numbers Before Odd Numbers</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalSpecialArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Even-Odd Sorted Array</div>
            <div class="transformed-array-container" id="transformedSpecialArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Separate even numbers to the front, odd numbers to the back</p>
            <p class="mb-0" id="specialSortExplanation">Starting even-odd sort animation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="specialSortStepsContainer">
            <h6 class="text-center">Even-Odd Sort Steps</h6>
            <div class="steps-container" id="specialSortSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSpecialSort" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSpecialSort, 'originalSpecialArray');
    renderArrayInContainer([...originalArrayForSpecialSort], 'transformedSpecialArray');
    
    performEvenOddSortAnimation();
}

// NEW: Show Absolute Value Sort Visualization
function showAbsoluteValueSortVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Sort by Absolute Value</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalSpecialArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Absolute Value Sorted Array</div>
            <div class="transformed-array-container" id="transformedSpecialArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Absolute Value Sorting:</strong> Sorting numbers by their absolute values</p>
            <p class="mb-0" id="specialSortExplanation">Starting absolute value sort animation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="specialSortStepsContainer">
            <h6 class="text-center">Absolute Value Sorting Steps</h6>
            <div class="steps-container" id="specialSortSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSpecialSort" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSpecialSort, 'originalSpecialArray');
    renderArrayInContainer([...originalArrayForSpecialSort], 'transformedSpecialArray');
    
    performAbsoluteValueSortAnimation();
}

// NEW: Perform Even-Odd Sort Animation
function performEvenOddSortAnimation() {
    const originalContainer = document.getElementById('originalSpecialArray');
    const transformedContainer = document.getElementById('transformedSpecialArray');
    const explanation = document.getElementById('specialSortExplanation');
    const stepsContainer = document.getElementById('specialSortSteps');
    const continueButton = document.getElementById('continueAfterSpecialSort');
    
    const arr = originalArrayForSpecialSort.map(val => parseFloat(val));
    let step = 0;
    let currentIndex = 0;
    let evenPointer = 0;
    
    function performEvenOddStep() {
        if (currentIndex >= arr.length) {
            // Sorting completed
            explanation.innerHTML = `<strong>Even-Odd Sort Completed!</strong> All even numbers moved to the front.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Even-odd sorting completed! ${evenPointer} even number(s) found.
                </div>
            `;
            
            // Highlight even and odd numbers differently
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                const value = parseFloat(el.querySelector('.element-value').textContent);
                setTimeout(() => {
                    if (value % 2 === 0) {
                        el.querySelector('.element-value').classList.add('even-number-sorted');
                    } else {
                        el.querySelector('.element-value').classList.add('odd-number-sorted');
                    }
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterSpecialSort();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSpecialSort);
            
            return;
        }
        
        step++;
        const currentValue = arr[currentIndex];
        const isEven = currentValue % 2 === 0;
        
        explanation.innerHTML = `Step ${step}: Checking element [${currentIndex}] = ${currentValue} - ${isEven ? 'EVEN' : 'ODD'}`;
        
        // Highlight current element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentIndex].querySelector('.element-value');
        currentElement.classList.add(isEven ? 'even-number' : 'odd-number');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${isEven ? 'active' : ''}">
                <strong>Step ${step}:</strong> [${currentIndex}] = ${currentValue} - ${isEven ? 'EVEN' : 'ODD'} number
                ${isEven ? ` Moving to position ${evenPointer}` : ' Staying in place'}
            </div>
        `;
        
        setTimeout(() => {
            if (isEven && currentIndex !== evenPointer) {
                // Move even number to the evenPointer position
                explanation.innerHTML = `Step ${step}: Moving even number ${currentValue} to position ${evenPointer}`;
                
                // Swap elements
                [arr[currentIndex], arr[evenPointer]] = [arr[evenPointer], arr[currentIndex]];
                
                // Update transformed array
                renderArrayInContainer(arr, 'transformedSpecialArray');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Move:</strong> Even number ${currentValue} moved from [${currentIndex}] to [${evenPointer}]
                    </div>
                `;
                
                evenPointer++;
                currentIndex++;
            } else if (isEven) {
                // Already in correct position
                evenPointer++;
                currentIndex++;
            } else {
                // Odd number, leave in place
                currentIndex++;
            }
            
            // Remove highlight
            currentElement.classList.remove('even-number', 'odd-number');
            
            // Continue to next step
            performEvenOddStep();
        }, 1500);
    }
    
    // Start even-odd sort process
    performEvenOddStep();
}

// NEW: Perform Absolute Value Sort Animation
function performAbsoluteSortAnimation() {
    const originalContainer = document.getElementById('originalSpecialArray');
    const transformedContainer = document.getElementById('transformedSpecialArray');
    const explanation = document.getElementById('specialSortExplanation');
    const stepsContainer = document.getElementById('specialSortSteps');
    const continueButton = document.getElementById('continueAfterSpecialSort');
    
    const arr = originalArrayForSpecialSort.map(val => parseFloat(val));
    let step = 0;
    
    // Create array with absolute values and original indices
    const elementsWithAbs = arr.map((value, index) => ({
        value: value,
        absValue: Math.abs(value),
        originalIndex: index
    }));
    
    function performAbsoluteStep(pass = 0, comparison = 0) {
        const n = elementsWithAbs.length;
        
        if (pass >= n - 1) {
            // Sorting completed
            explanation.innerHTML = `<strong>Absolute Value Sort Completed!</strong> Array sorted by absolute values.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Array sorted by absolute values (distance from zero)
                </div>
            `;
            
            // Highlight all elements
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                const value = parseFloat(el.querySelector('.element-value').textContent);
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('absolute-sorted');
                    if (value >= 0) {
                        el.querySelector('.element-value').classList.add('positive-value-sorted');
                    } else {
                        el.querySelector('.element-value').classList.add('negative-value-sorted');
                    }
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterSpecialSort();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSpecialSort);
            
            return;
        }
        
        if (comparison >= n - pass - 1) {
            // Pass completed
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Pass ${pass + 1} Complete:</strong> Largest absolute value bubbled to end
                </div>
            `;
            
            pass++;
            comparison = 0;
            performAbsoluteStep(pass, comparison);
            return;
        }
        
        step++;
        const i = comparison;
        const j = i + 1;
        
        explanation.innerHTML = `Step ${step}: Comparing |${elementsWithAbs[i].value}| and |${elementsWithAbs[j].value}|`;
        
        // Highlight elements being compared
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const elementI = originalElements[i].querySelector('.element-value');
        const elementJ = originalElements[j].querySelector('.element-value');
        
        elementI.classList.add('sorting-current');
        elementJ.classList.add('sorting-compared');
        
        // Compare absolute values
        const shouldSwap = elementsWithAbs[i].absValue > elementsWithAbs[j].absValue;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${shouldSwap ? 'active' : ''}">
                <strong>Step ${step}:</strong> |${elementsWithAbs[i].value}| = ${elementsWithAbs[i].absValue} 
                ${shouldSwap ? '>' : '<='} |${elementsWithAbs[j].value}| = ${elementsWithAbs[j].absValue}
                ${shouldSwap ? ' SWAPPING' : ' No swap needed'}
            </div>
        `;
        
        setTimeout(() => {
            if (shouldSwap) {
                // Perform swap
                explanation.innerHTML = `Step ${step}: Swapping based on absolute values`;
                
                [elementsWithAbs[i], elementsWithAbs[j]] = [elementsWithAbs[j], elementsWithAbs[i]];
                
                // Update array for display
                const currentArray = elementsWithAbs.map(item => item.value);
                renderArrayInContainer(currentArray, 'transformedSpecialArray');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Swap:</strong> Elements swapped based on absolute values
                    </div>
                `;
            }
            
            // Remove highlights
            elementI.classList.remove('sorting-current', 'sorting-compared');
            elementJ.classList.remove('sorting-current', 'sorting-compared');
            
            // Continue to next comparison
            comparison++;
            performAbsoluteStep(pass, comparison);
        }, 1500);
    }
    
    // Start absolute value sort process
    performAbsoluteStep();
}

// NEW: Return to Original after Special Sort
function returnToOriginalAfterSpecialSort() {
    // Reset to original array
    myArray = [...originalArrayForSpecialSort];
    originalArrayForSpecialSort = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset states
    isEvenOddSortRunning = false;
    isAbsoluteSortRunning = false;
    
    logOperation('Special sort completed - returned to original array', 'info');
    showNotification('Returned to original array after special sort', 'success');
}
// NEW: Perform Absolute Value Sort Animation
function performAbsoluteSortAnimation() {
    const originalContainer = document.getElementById('originalSpecialArray');
    const transformedContainer = document.getElementById('transformedSpecialArray');
    const explanation = document.getElementById('specialSortExplanation');
    const stepsContainer = document.getElementById('specialSortSteps');
    const continueButton = document.getElementById('continueAfterSpecialSort');
    
    const arr = originalArrayForSpecialSort.map(val => parseFloat(val));
    let step = 0;
    
    // Create array with absolute values and original indices
    const elementsWithAbs = arr.map((value, index) => ({
        value: value,
        absValue: Math.abs(value),
        originalIndex: index
    }));
    
    function performAbsoluteStep(pass = 0, comparison = 0) {
        const n = elementsWithAbs.length;
        
        if (pass >= n - 1) {
            // Sorting completed
            explanation.innerHTML = `<strong>Absolute Value Sort Completed!</strong> Array sorted by absolute values.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Array sorted by absolute values (distance from zero)
                </div>
            `;
            
            // Highlight all elements
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                const value = parseFloat(el.querySelector('.element-value').textContent);
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('absolute-sorted');
                    if (value >= 0) {
                        el.querySelector('.element-value').classList.add('positive-value-sorted');
                    } else {
                        el.querySelector('.element-value').classList.add('negative-value-sorted');
                    }
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterSpecialSort();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSpecialSort);
            
            return;
        }
        
        if (comparison >= n - pass - 1) {
            // Pass completed
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Pass ${pass + 1} Complete:</strong> Largest absolute value bubbled to end
                </div>
            `;
            
            pass++;
            comparison = 0;
            performAbsoluteStep(pass, comparison);
            return;
        }
        
        step++;
        const i = comparison;
        const j = i + 1;
        
        explanation.innerHTML = `Step ${step}: Comparing |${elementsWithAbs[i].value}| and |${elementsWithAbs[j].value}|`;
        
        // Highlight elements being compared
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const elementI = originalElements[i].querySelector('.element-value');
        const elementJ = originalElements[j].querySelector('.element-value');
        
        elementI.classList.add('sorting-current');
        elementJ.classList.add('sorting-compared');
        
        // Compare absolute values
        const shouldSwap = elementsWithAbs[i].absValue > elementsWithAbs[j].absValue;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${shouldSwap ? 'active' : ''}">
                <strong>Step ${step}:</strong> |${elementsWithAbs[i].value}| = ${elementsWithAbs[i].absValue} 
                ${shouldSwap ? '>' : '<='} |${elementsWithAbs[j].value}| = ${elementsWithAbs[j].absValue}
                ${shouldSwap ? ' SWAPPING' : ' No swap needed'}
            </div>
        `;
        
        setTimeout(() => {
            if (shouldSwap) {
                // Perform swap
                explanation.innerHTML = `Step ${step}: Swapping based on absolute values`;
                
                [elementsWithAbs[i], elementsWithAbs[j]] = [elementsWithAbs[j], elementsWithAbs[i]];
                
                // Update array for display
                const currentArray = elementsWithAbs.map(item => item.value);
                renderArrayInContainer(currentArray, 'transformedSpecialArray');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Swap:</strong> Elements swapped based on absolute values
                    </div>
                `;
            }
            
            // Remove highlights
            elementI.classList.remove('sorting-current', 'sorting-compared');
            elementJ.classList.remove('sorting-current', 'sorting-compared');
            
            // Continue to next comparison
            comparison++;
            performAbsoluteStep(pass, comparison);
        }, 1500);
    }
    
    // Start absolute value sort process
    performAbsoluteStep();
}
// NEW: Return to Original after Special Sort
function returnToOriginalAfterSpecialSort() {
    // Reset to original array
    myArray = [...originalArrayForSpecialSort];
    originalArrayForSpecialSort = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset states
    isEvenOddSortRunning = false;
    isAbsoluteSortRunning = false;
    
    logOperation('Special sort completed - returned to original array', 'info');
    showNotification('Returned to original array after special sort', 'success');
}
// NEW: Pop First Element Handler
function handlePopFirst() {
    if (myArray.length === 0) {
        // Show error message
        searchResults.innerHTML = `
            <p class="mb-1 text-danger"><strong>Error: No elements in array</strong></p>
            <p class="mb-0 text-danger">Array is empty. Please add elements first.</p>
        `;
        showNotification('Array is empty. Cannot pop first element.', 'danger');
        logOperation('Attempted to pop first element from empty array - failed', 'danger');
        return;
    }
    
    const firstElement = myArray[0];
    
    // Highlight the first element before popping
    highlightElement(0, 'delete', () => {
        myArray.shift(); // Remove first element
        renderArray();
        updateStats();
        
        // Show success message
        searchResults.innerHTML = `
            <p class="mb-1 text-success"><strong>Success: First Element Popped</strong></p>
            <p class="mb-1">Popped Element: "${firstElement}"</p>
            <p class="mb-0">New array length: ${myArray.length}</p>
        `;
        
        logOperation(`Popped first element: "${firstElement}"`, 'success');
        showNotification(`First element "${firstElement}" popped successfully`, 'success');
    });
}

// NEW: Shift Right for Insertion Handler
function handleShiftRightInsert() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Show input group
    shiftRightInsertGroup.style.display = 'block';
    insertShiftIndex.focus();
    
    logOperation('Started shift right for insertion operation', 'info');
}

// NEW: Confirm Shift Insert Handler
function handleConfirmShiftInsert() {
    const index = parseInt(insertShiftIndex.value);
    const value = insertShiftValue.value.trim();
    
    // Validation
    if (isNaN(index) || index < 0 || index > myArray.length) {
        showNotification(`Please enter a valid index between 0 and ${myArray.length}`, 'danger');
        insertShiftIndex.focus();
        return;
    }
    
    if (value === '') {
        showNotification('Please enter a value to insert', 'warning');
        insertShiftValue.focus();
        return;
    }
    
    // Store original array
    originalArrayForShiftInsert = [...myArray];
    
    // Hide input group
    shiftRightInsertGroup.style.display = 'none';
    insertShiftIndex.value = '';
    insertShiftValue.value = '';
    
    // Show shift right insertion visualization
    showShiftRightInsertVisualization(index, value);
}

// NEW: Cancel Shift Insert Handler
function handleCancelShiftInsert() {
    shiftRightInsertGroup.style.display = 'none';
    insertShiftIndex.value = '';
    insertShiftValue.value = '';
    logOperation('Cancelled shift right insertion operation', 'info');
}
// NEW: Show Shift Right Insert Visualization
function showShiftRightInsertVisualization(index, value) {
    isShiftInsertRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Shift Right for Insertion at Index ${index}</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalShiftInsertArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-right"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After Insertion with Shift</div>
            <div class="transformed-array-container" id="transformedShiftInsertArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Shift Right Process:</strong> Making space for new element at index ${index}</p>
            <p class="mb-0" id="shiftInsertExplanation">Starting shift right insertion...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="shiftInsertStepsContainer">
            <h6 class="text-center">Shift Right Insertion Steps</h6>
            <div class="steps-container" id="shiftInsertSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterShiftInsert" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForShiftInsert, 'originalShiftInsertArray');
    renderArrayInContainer([...originalArrayForShiftInsert], 'transformedShiftInsertArray');
    
    performShiftRightInsertAnimation(index, value);
}

// NEW: Perform Shift Right Insert Animation
function performShiftRightInsertAnimation(index, value) {
    const originalContainer = document.getElementById('originalShiftInsertArray');
    const transformedContainer = document.getElementById('transformedShiftInsertArray');
    const explanation = document.getElementById('shiftInsertExplanation');
    const stepsContainer = document.getElementById('shiftInsertSteps');
    const continueButton = document.getElementById('continueAfterShiftInsert');
    
    const array = [...originalArrayForShiftInsert];
    let currentStep = 0;
    
    function performShiftStep() {
        if (currentStep === 0) {
            // Step 1: Show original array
            explanation.innerHTML = `Step 1: Original array with ${array.length} elements`;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Original array: [${array.join(', ')}]
                </div>
            `;
            currentStep++;
            setTimeout(performShiftStep, 1500);
            
        } else if (currentStep === 1) {
            // Step 2: Show where we're inserting
            explanation.innerHTML = `Step 2: Preparing to insert "${value}" at index ${index}`;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 2:</strong> Will insert "${value}" at position ${index}
                </div>
            `;
            
            // Highlight the insertion point
            const originalElements = originalContainer.querySelectorAll('.array-element');
            if (index < originalElements.length) {
                originalElements[index].querySelector('.element-value').classList.add('warning-color');
            }
            
            currentStep++;
            setTimeout(performShiftStep, 2000);
            
        } else if (currentStep === 2) {
            // Step 3: Show shift right process
            explanation.innerHTML = `Step 3: Shifting elements from index ${index} to the right`;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 3:</strong> Shifting elements right to make space
                </div>
            `;
            
            // Create new array with space for insertion
            const newArray = [...array];
            newArray.length += 1; // Increase array size
            
            // Shift elements to the right
            for (let i = newArray.length - 1; i > index; i--) {
                newArray[i] = newArray[i - 1];
            }
            
            // Update transformed array display
            renderArrayInContainer(newArray, 'transformedShiftInsertArray');
            
            // Highlight shifted elements
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            for (let i = index + 1; i < newArray.length; i++) {
                if (transformedElements[i]) {
                    transformedElements[i].querySelector('.element-value').classList.add('shift-highlight');
                }
            }
            
            currentStep++;
            setTimeout(performShiftStep, 2000);
            
        } else if (currentStep === 3) {
            // Step 4: Insert the new value
            explanation.innerHTML = `Step 4: Inserting "${value}" at index ${index}`;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 4:</strong> Inserting new value "${value}" at position ${index}
                </div>
            `;
            
            // Create final array with inserted value
            const finalArray = [...array];
            finalArray.splice(index, 0, value); // Insert at specified index
            
            // Update transformed array display
            renderArrayInContainer(finalArray, 'transformedShiftInsertArray');
            
            // Highlight the inserted element
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            if (transformedElements[index]) {
                transformedElements[index].querySelector('.element-value').classList.add('create', 'bounce');
            }
            
            currentStep++;
            setTimeout(performShiftStep, 2000);
            
        } else if (currentStep === 4) {
            // Step 5: Show completion
            explanation.innerHTML = `<strong>Insertion Complete!</strong> Successfully inserted "${value}" at index ${index}`;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 5:</strong> Insertion completed! Array length: ${array.length + 1}
                </div>
                <div class="algorithm-step active">
                    <strong>Result:</strong> New array: [${[...array].splice(index, 0, value) && [...array, value].join(', ')}]
                </div>
            `;
            
            // Update the actual array
            myArray.splice(index, 0, value);
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterShiftInsert();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterShiftInsert);
        }
    }
    
    // Start the shift right process
    performShiftStep();
}

// NEW: Return to Original after Shift Insert
function returnToOriginalAfterShiftInsert() {
    // Reset to original array
    myArray = [...originalArrayForShiftInsert];
    originalArrayForShiftInsert = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isShiftInsertRunning = false;
    
    logOperation('Shift right insertion completed - returned to original array', 'info');
    showNotification('Returned to original array after shift insertion', 'success');
}
// NEW: Find Triplets Handler
function handleFindTriplets() {
    const targetSum = parseInt(tripletSumInput.value);
    
    if (isNaN(targetSum)) {
        showNotification('Please enter a valid target sum', 'danger');
        tripletSumInput.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Triplet sum operations require all array elements to be numbers', 'danger');
        return;
    }
    
    if (myArray.length < 3) {
        showNotification('Array must have at least 3 elements for triplet sum', 'warning');
        return;
    }
    
    if (isTripletOperationRunning) {
        showNotification('A triplet operation is already in progress', 'warning');
        return;
    }
    
    isTripletOperationRunning = true;
    
    // Store original array
    originalArrayForTriplet = [...myArray];
    
    // Perform triplet sum visualization
    performTripletSumVisualization(targetSum);
}

// NEW: Find Quadruplets Handler
function handleFindQuadruplets() {
    const targetSum = parseInt(quadrupletSumInput.value);
    
    if (isNaN(targetSum)) {
        showNotification('Please enter a valid target sum', 'danger');
        quadrupletSumInput.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Quadruplet sum operations require all array elements to be numbers', 'danger');
        return;
    }
    
    if (myArray.length < 4) {
        showNotification('Array must have at least 4 elements for quadruplet sum', 'warning');
        return;
    }
    
    if (isQuadrupletOperationRunning) {
        showNotification('A quadruplet operation is already in progress', 'warning');
        return;
    }
    
    isQuadrupletOperationRunning = true;
    
    // Store original array
    originalArrayForQuadruplet = [...myArray];
    
    // Perform quadruplet sum visualization
    performQuadrupletSumVisualization(targetSum);
}

// NEW: Perform Triplet Sum Visualization
function performTripletSumVisualization(targetSum) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Triplet Sum (Target = ${targetSum})</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalTripletArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find all unique triplets that sum to ${targetSum}</p>
            <p class="mb-0" id="tripletExplanation">Initializing triplet search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="tripletStepsContainer">
            <h6 class="text-center">Triplet Search Steps</h6>
            <div class="steps-container" id="tripletSteps"></div>
        </div>
        
        <div class="triplet-results mt-3" id="tripletResults" style="display: none;">
            <h6 class="text-center">Found Triplets</h6>
            <div id="tripletsList" class="mt-2"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterTriplet" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForTriplet, 'originalTripletArray');
    
    executeTripletSumAlgorithm(targetSum);
}

// NEW: Execute Triplet Sum Algorithm with Animation
function executeTripletSumAlgorithm(targetSum) {
    const arrayContainer = document.getElementById('originalTripletArray');
    const explanation = document.getElementById('tripletExplanation');
    const stepsContainer = document.getElementById('tripletSteps');
    const tripletResults = document.getElementById('tripletResults');
    const tripletsList = document.getElementById('tripletsList');
    const continueButton = document.getElementById('continueAfterTriplet');
    
    const arr = originalArrayForTriplet.map(val => parseFloat(val));
    const sortedArr = [...arr].sort((a, b) => a - b);
    const triplets = [];
    let step = 0;
    
    function executeTripletStep(i) {
        if (i >= sortedArr.length - 2) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Triplet Search Completed!</strong> Found ${triplets.length} unique triplets.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Triplet search completed. Found ${triplets.length} unique triplets.
                </div>
            `;
            
            // Display results
            if (triplets.length > 0) {
                tripletResults.style.display = 'block';
                tripletsList.innerHTML = '';
                triplets.forEach((triplet, index) => {
                    const tripletElement = document.createElement('div');
                    tripletElement.className = 'triplet-item';
                    tripletElement.textContent = `[${triplet.join(', ')}]`;
                    tripletsList.appendChild(tripletElement);
                });
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterTriplet();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterTriplet);
            
            return;
        }
        
        // Skip duplicates
        if (i > 0 && sortedArr[i] === sortedArr[i - 1]) {
            executeTripletStep(i + 1);
            return;
        }
        
        step++;
        explanation.innerHTML = `Step ${step}: Fixing element at index ${i} = ${sortedArr[i]}`;
        
        // Highlight current fixed element
        const elements = arrayContainer.querySelectorAll('.array-element');
        const originalIndex = arr.indexOf(sortedArr[i]);
        elements[originalIndex].querySelector('.element-value').classList.add('triplet-current');
        
        let left = i + 1;
        let right = sortedArr.length - 1;
        let innerStep = 0;
        
        function executeInnerTripletStep() {
            if (left >= right) {
                // Move to next fixed element
                elements[originalIndex].querySelector('.element-value').classList.remove('triplet-current');
                executeTripletStep(i + 1);
                return;
            }
            
            innerStep++;
            const currentSum = sortedArr[i] + sortedArr[left] + sortedArr[right];
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}.${innerStep}:</strong> Checking [${i}]=${sortedArr[i]}, [${left}]=${sortedArr[left]}, [${right}]=${sortedArr[right]}  Sum = ${currentSum}
                </div>
            `;
            
            // Highlight current triplet being checked
            const leftOriginalIndex = arr.indexOf(sortedArr[left]);
            const rightOriginalIndex = arr.indexOf(sortedArr[right]);
            
            elements[leftOriginalIndex].querySelector('.element-value').classList.add('triplet-highlight');
            elements[rightOriginalIndex].querySelector('.element-value').classList.add('triplet-highlight');
            
            setTimeout(() => {
                if (currentSum === targetSum) {
                    // Found a triplet
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>FOUND TRIPLET:</strong> [${sortedArr[i]}, ${sortedArr[left]}, ${sortedArr[right]}] = ${targetSum}
                        </div>
                    `;
                    
                    triplets.push([sortedArr[i], sortedArr[left], sortedArr[right]]);
                    
                    // Highlight the found triplet
                    elements[originalIndex].querySelector('.element-value').classList.add('success-color');
                    elements[leftOriginalIndex].querySelector('.element-value').classList.add('success-color');
                    elements[rightOriginalIndex].querySelector('.element-value').classList.add('success-color');
                    
                    // Skip duplicates
                    while (left < right && sortedArr[left] === sortedArr[left + 1]) left++;
                    while (left < right && sortedArr[right] === sortedArr[right - 1]) right--;
                    
                    left++;
                    right--;
                } else if (currentSum < targetSum) {
                    left++;
                } else {
                    right--;
                }
                
                // Remove temporary highlights
                elements[leftOriginalIndex].querySelector('.element-value').classList.remove('triplet-highlight');
                elements[rightOriginalIndex].querySelector('.element-value').classList.remove('triplet-highlight');
                
                executeInnerTripletStep();
            }, 1500);
        }
        
        executeInnerTripletStep();
    }
    
    // Start triplet search
    executeTripletStep(0);
}

// NEW: Perform Quadruplet Sum Visualization
function performQuadrupletSumVisualization(targetSum) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Quadruplet Sum (Target = ${targetSum})</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalQuadrupletArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find all unique quadruplets that sum to ${targetSum}</p>
            <p class="mb-0" id="quadrupletExplanation">Initializing quadruplet search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="quadrupletStepsContainer">
            <h6 class="text-center">Quadruplet Search Steps</h6>
            <div class="steps-container" id="quadrupletSteps"></div>
        </div>
        
        <div class="quadruplet-results mt-3" id="quadrupletResults" style="display: none;">
            <h6 class="text-center">Found Quadruplets</h6>
            <div id="quadrupletsList" class="mt-2"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterQuadruplet" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForQuadruplet, 'originalQuadrupletArray');
    
    executeQuadrupletSumAlgorithm(targetSum);
}

// NEW: Execute Quadruplet Sum Algorithm with Animation
function executeQuadrupletSumAlgorithm(targetSum) {
    const arrayContainer = document.getElementById('originalQuadrupletArray');
    const explanation = document.getElementById('quadrupletExplanation');
    const stepsContainer = document.getElementById('quadrupletSteps');
    const quadrupletResults = document.getElementById('quadrupletResults');
    const quadrupletsList = document.getElementById('quadrupletsList');
    const continueButton = document.getElementById('continueAfterQuadruplet');
    
    const arr = originalArrayForQuadruplet.map(val => parseFloat(val));
    const sortedArr = [...arr].sort((a, b) => a - b);
    const quadruplets = [];
    let step = 0;
    
    function executeQuadrupletStep(i) {
        if (i >= sortedArr.length - 3) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Quadruplet Search Completed!</strong> Found ${quadruplets.length} unique quadruplets.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Quadruplet search completed. Found ${quadruplets.length} unique quadruplets.
                </div>
            `;
            
            // Display results
            if (quadruplets.length > 0) {
                quadrupletResults.style.display = 'block';
                quadrupletsList.innerHTML = '';
                quadruplets.forEach((quadruplet, index) => {
                    const quadrupletElement = document.createElement('div');
                    quadrupletElement.className = 'quadruplet-item';
                    quadrupletElement.textContent = `[${quadruplet.join(', ')}]`;
                    quadrupletsList.appendChild(quadrupletElement);
                });
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterQuadruplet();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterQuadruplet);
            
            return;
        }
        
        // Skip duplicates
        if (i > 0 && sortedArr[i] === sortedArr[i - 1]) {
            executeQuadrupletStep(i + 1);
            return;
        }
        
        step++;
        explanation.innerHTML = `Step ${step}: Fixing first element at index ${i} = ${sortedArr[i]}`;
        
        // Highlight current fixed element
        const elements = arrayContainer.querySelectorAll('.array-element');
        const originalIndex = arr.indexOf(sortedArr[i]);
        elements[originalIndex].querySelector('.element-value').classList.add('quadruplet-current');
        
        function executeInnerQuadrupletStep(j) {
            if (j >= sortedArr.length - 2) {
                // Move to next fixed element
                elements[originalIndex].querySelector('.element-value').classList.remove('quadruplet-current');
                executeQuadrupletStep(i + 1);
                return;
            }
            
            // Skip duplicates for second element
            if (j > i + 1 && sortedArr[j] === sortedArr[j - 1]) {
                executeInnerQuadrupletStep(j + 1);
                return;
            }
            
            const innerStep = step + '.' + (j - i);
            explanation.innerHTML = `Step ${innerStep}: Fixing elements at [${i}]=${sortedArr[i]}, [${j}]=${sortedArr[j]}`;
            
            // Highlight second fixed element
            const jOriginalIndex = arr.indexOf(sortedArr[j]);
            elements[jOriginalIndex].querySelector('.element-value').classList.add('quadruplet-current');
            
            let left = j + 1;
            let right = sortedArr.length - 1;
            let innerInnerStep = 0;
            
            function executeInnerInnerQuadrupletStep() {
                if (left >= right) {
                    // Move to next second element
                    elements[jOriginalIndex].querySelector('.element-value').classList.remove('quadruplet-current');
                    executeInnerQuadrupletStep(j + 1);
                    return;
                }
                
                innerInnerStep++;
                const currentSum = sortedArr[i] + sortedArr[j] + sortedArr[left] + sortedArr[right];
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${innerStep}.${innerInnerStep}:</strong> Checking [${i}]=${sortedArr[i]}, [${j}]=${sortedArr[j]}, [${left}]=${sortedArr[left]}, [${right}]=${sortedArr[right]}  Sum = ${currentSum}
                    </div>
                `;
                
                // Highlight current quadruplet being checked
                const leftOriginalIndex = arr.indexOf(sortedArr[left]);
                const rightOriginalIndex = arr.indexOf(sortedArr[right]);
                
                elements[leftOriginalIndex].querySelector('.element-value').classList.add('quadruplet-highlight');
                elements[rightOriginalIndex].querySelector('.element-value').classList.add('quadruplet-highlight');
                
                setTimeout(() => {
                    if (currentSum === targetSum) {
                        // Found a quadruplet
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>FOUND QUADRUPLET:</strong> [${sortedArr[i]}, ${sortedArr[j]}, ${sortedArr[left]}, ${sortedArr[right]}] = ${targetSum}
                            </div>
                        `;
                        
                        quadruplets.push([sortedArr[i], sortedArr[j], sortedArr[left], sortedArr[right]]);
                        
                        // Highlight the found quadruplet
                        elements[originalIndex].querySelector('.element-value').classList.add('success-color');
                        elements[jOriginalIndex].querySelector('.element-value').classList.add('success-color');
                        elements[leftOriginalIndex].querySelector('.element-value').classList.add('success-color');
                        elements[rightOriginalIndex].querySelector('.element-value').classList.add('success-color');
                        
                        // Skip duplicates
                        while (left < right && sortedArr[left] === sortedArr[left + 1]) left++;
                        while (left < right && sortedArr[right] === sortedArr[right - 1]) right--;
                        
                        left++;
                        right--;
                    } else if (currentSum < targetSum) {
                        left++;
                    } else {
                        right--;
                    }
                    
                    // Remove temporary highlights
                    elements[leftOriginalIndex].querySelector('.element-value').classList.remove('quadruplet-highlight');
                    elements[rightOriginalIndex].querySelector('.element-value').classList.remove('quadruplet-highlight');
                    
                    executeInnerInnerQuadrupletStep();
                }, 1500);
            }
            
            executeInnerInnerQuadrupletStep();
        }
        
        executeInnerQuadrupletStep(i + 1);
    }
    
    // Start quadruplet search
    executeQuadrupletStep(0);
}

// NEW: Return to Original after Triplet Operation
function returnToOriginalAfterTriplet() {
    // Reset to original array
    myArray = [...originalArrayForTriplet];
    originalArrayForTriplet = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isTripletOperationRunning = false;
    
    // Clear input
    tripletSumInput.value = '';
    
    logOperation('Triplet sum operation completed - returned to original array', 'info');
    showNotification('Returned to original array after triplet sum operation', 'success');
}

// NEW: Return to Original after Quadruplet Operation
function returnToOriginalAfterQuadruplet() {
    // Reset to original array
    myArray = [...originalArrayForQuadruplet];
    originalArrayForQuadruplet = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isQuadrupletOperationRunning = false;
    
    // Clear input
    quadrupletSumInput.value = '';
    
    logOperation('Quadruplet sum operation completed - returned to original array', 'info');
    showNotification('Returned to original array after quadruplet sum operation', 'success');
}
// NEW: Equilibrium Point Handler
function handleEquilibriumPoint() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isEquilibriumRunning) {
        showNotification('Equilibrium point search is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Equilibrium point calculation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isEquilibriumRunning = true;
    
    // Store original array
    originalArrayForEquilibrium = [...myArray];
    
    // Show equilibrium point visualization
    showEquilibriumVisualization();
}
// NEW: Show Equilibrium Visualization
function showEquilibriumVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Equilibrium Point Detection</h5>
        
        <div class="array-group">
            <div class="array-label">Array</div>
            <div class="original-array-container" id="equilibriumArray"></div>
        </div>
        
        <div class="equilibrium-explanation">
            <p class="mb-2"><strong>Equilibrium Point:</strong> Find index where sum of left elements equals sum of right elements</p>
            <p class="mb-0" id="equilibriumExplanation">Initializing equilibrium point search...</p>
        </div>
        
        <div class="equilibrium-stats" id="equilibriumStats">
            <div class="equilibrium-stat">
                <div>Left Sum</div>
                <div class="equilibrium-stat-value" id="leftSumValue">0</div>
            </div>
            <div class="equilibrium-stat">
                <div>Right Sum</div>
                <div class="equilibrium-stat-value" id="rightSumValue">0</div>
            </div>
            <div class="equilibrium-stat">
                <div>Current Index</div>
                <div class="equilibrium-stat-value" id="currentIndexValue">-</div>
            </div>
        </div>
        
        <div class="algorithm-steps mt-3" id="equilibriumStepsContainer">
            <h6 class="text-center">Equilibrium Point Algorithm Steps</h6>
            <div class="steps-container" id="equilibriumSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterEquilibrium" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForEquilibrium, 'equilibriumArray');
    
    performEquilibriumAlgorithm();
}
// NEW: Perform Equilibrium Algorithm with Animation
function performEquilibriumAlgorithm() {
    const arrayContainer = document.getElementById('equilibriumArray');
    const explanation = document.getElementById('equilibriumExplanation');
    const stepsContainer = document.getElementById('equilibriumSteps');
    const leftSumValue = document.getElementById('leftSumValue');
    const rightSumValue = document.getElementById('rightSumValue');
    const currentIndexValue = document.getElementById('currentIndexValue');
    const continueButton = document.getElementById('continueAfterEquilibrium');
    
    const arr = originalArrayForEquilibrium.map(val => parseFloat(val));
    const n = arr.length;
    
    // Calculate total sum first
    const totalSum = arr.reduce((sum, val) => sum + val, 0);
    let leftSum = 0;
    let equilibriumFound = false;
    let equilibriumIndex = -1;
    let currentIndex = 0;
    
    function performEquilibriumStep() {
        if (currentIndex >= n) {
            // Algorithm completed
            if (!equilibriumFound) {
                explanation.innerHTML = `<strong>Algorithm Completed!</strong> No equilibrium point found in the array.`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Final:</strong> No equilibrium point exists in the array
                    </div>
                `;
            } else {
                explanation.innerHTML = `<strong>Algorithm Completed!</strong> Equilibrium point found at index ${equilibriumIndex} (1-based position: ${equilibriumIndex + 1})`;
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterEquilibrium();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterEquilibrium);
            
            return;
        }
        
        // Update current index display
        currentIndexValue.textContent = currentIndex;
        
        // Calculate right sum for current index
        const rightSum = totalSum - leftSum - arr[currentIndex];
        
        // Update sum displays
        leftSumValue.textContent = leftSum;
        rightSumValue.textContent = rightSum;
        
        // Highlight current elements
        const elements = arrayContainer.querySelectorAll('.array-element');
        
        // Reset all highlights first
        elements.forEach(el => {
            const valueDiv = el.querySelector('.element-value');
            valueDiv.classList.remove('equilibrium-left', 'equilibrium-right', 'equilibrium-point');
        });
        
        // Highlight left elements (0 to currentIndex-1)
        for (let i = 0; i < currentIndex; i++) {
            elements[i].querySelector('.element-value').classList.add('equilibrium-left');
        }
        
        // Highlight right elements (currentIndex+1 to n-1)
        for (let i = currentIndex + 1; i < n; i++) {
            elements[i].querySelector('.element-value').classList.add('equilibrium-right');
        }
        
        // Highlight current element
        elements[currentIndex].querySelector('.element-value').classList.add('equilibrium-point');
        
        // Update explanation
        explanation.innerHTML = `Checking index ${currentIndex}: Left Sum = ${leftSum}, Right Sum = ${rightSum}`;
        
        // Add step to steps container
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${leftSum === rightSum ? 'active' : ''}">
                <strong>Step ${currentIndex + 1}:</strong> Index ${currentIndex} - 
                Left Sum: ${leftSum}, Right Sum: ${rightSum} - 
                ${leftSum === rightSum ? 'EQUILIBRIUM FOUND!' : 'Not equal'}
            </div>
        `;
        
        // Scroll to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Check if equilibrium found
        if (leftSum === rightSum) {
            equilibriumFound = true;
            equilibriumIndex = currentIndex;
            
            // Special highlight for equilibrium point
            elements[currentIndex].querySelector('.element-value').classList.add('equilibrium-point');
            
            setTimeout(() => {
                explanation.innerHTML = `<strong>EQUILIBRIUM FOUND!</strong> At index ${currentIndex} (1-based position: ${currentIndex + 1})`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>SUCCESS:</strong> Equilibrium point found at position ${currentIndex + 1}!
                    </div>
                `;
                
                // Move to next step after showing success
                setTimeout(() => {
                    leftSum += arr[currentIndex];
                    currentIndex++;
                    performEquilibriumStep();
                }, 2000);
            }, 1500);
        } else {
            // Continue to next index
            setTimeout(() => {
                leftSum += arr[currentIndex];
                currentIndex++;
                performEquilibriumStep();
            }, 1500);
        }
    }
    
    // Add initial explanation
    stepsContainer.innerHTML += `
        <div class="algorithm-step">
            <strong>Algorithm:</strong> For each index i, check if sum(arr[0..i-1]) == sum(arr[i+1..n-1])
        </div>
        <div class="algorithm-step">
            <strong>Total Array Sum:</strong> ${totalSum}
        </div>
    `;
    
    // Start the algorithm
    performEquilibriumStep();
}
// NEW: Return to Original after Equilibrium
function returnToOriginalAfterEquilibrium() {
    // Reset to original array
    myArray = [...originalArrayForEquilibrium];
    originalArrayForEquilibrium = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isEquilibriumRunning = false;
    
    logOperation('Equilibrium point search completed - returned to original array', 'info');
    showNotification('Returned to original array after equilibrium point search', 'success');
}
// NEW: Container With Most Water Handler
function handleContainerWithMostWater() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isWaterProblemRunning) {
        showNotification('A water problem is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Water problems require all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForWater = [...myArray];
    
    // Show container with most water visualization
    showContainerWithMostWaterVisualization();
}

// NEW: Trapping Rain Water Handler
function handleTrappingRainWater() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isWaterProblemRunning) {
        showNotification('A water problem is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Water problems require all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForWater = [...myArray];
    
    // Show trapping rain water visualization
    showTrappingRainWaterVisualization();
}
// NEW: Show Container With Most Water Visualization
function showContainerWithMostWaterVisualization() {
    isWaterProblemRunning = true;
    
    const waterContainer = document.createElement('div');
    waterContainer.className = 'water-container';
    waterContainer.innerHTML = `
        <h5 class="text-center mb-3">Container With Most Water Problem</h5>
        
        <div class="array-group">
            <div class="array-label">Height Array (Bars represent heights)</div>
            <div class="original-array-container" id="waterBarsContainer"></div>
        </div>
        
        <div class="algorithm-explanation mt-3">
            <p class="mb-2" id="waterExplanation">Initializing container with most water algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="waterStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="waterSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Maximum Water Area</div>
            <div class="stats-value" id="maxWaterArea">0 units</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterWater" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(waterContainer);
    
    renderWaterBars(originalArrayForWater, 'waterBarsContainer');
    performContainerWithMostWaterAnimation();
}

// NEW: Show Trapping Rain Water Visualization
function showTrappingRainWaterVisualization() {
    isWaterProblemRunning = true;
    
    const waterContainer = document.createElement('div');
    waterContainer.className = 'water-container';
    waterContainer.innerHTML = `
        <h5 class="text-center mb-3">Trapping Rain Water Problem</h5>
        
        <div class="array-group">
            <div class="array-label">Elevation Map (Blue represents trapped water)</div>
            <div class="original-array-container" id="waterBarsContainer"></div>
        </div>
        
        <div class="algorithm-explanation mt-3">
            <p class="mb-2" id="waterExplanation">Initializing trapping rain water algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="waterStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="waterSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Total Trapped Water</div>
            <div class="stats-value" id="trappedWater">0 units</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterWater" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(waterContainer);
    
    renderWaterBars(originalArrayForWater, 'waterBarsContainer');
    performTrappingRainWaterAnimation();
}

// NEW: Render Water Bars (Vertical bars for water problems)
function renderWaterBars(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    container.style.alignItems = 'flex-end';
    container.style.minHeight = '200px';
    
    const maxHeight = Math.max(...array.map(val => parseFloat(val)));
    const scaleFactor = 150 / (maxHeight || 1); // Scale to fit container
    
    array.forEach((value, index) => {
        const barContainer = document.createElement('div');
        barContainer.className = 'array-element';
        barContainer.style.flexDirection = 'column-reverse';
        barContainer.style.alignItems = 'center';
        
        const height = parseFloat(value);
        const barHeight = height * scaleFactor;
        
        barContainer.innerHTML = `
            <div class="water-bar" style="height: ${barHeight}px; width: 40px; position: relative;">
                <div class="element-value" style="position: absolute; bottom: 0; width: 100%; background: var(--info-color);">
                    ${value}
                </div>
            </div>
            <div class="element-index">${index}</div>
        `;
        
        container.appendChild(barContainer);
    });
}

// NEW: Perform Container With Most Water Animation
function performContainerWithMostWaterAnimation() {
    const barsContainer = document.getElementById('waterBarsContainer');
    const explanation = document.getElementById('waterExplanation');
    const stepsContainer = document.getElementById('waterSteps');
    const maxWaterArea = document.getElementById('maxWaterArea');
    const continueButton = document.getElementById('continueAfterWater');
    
    const height = originalArrayForWater.map(val => parseFloat(val));
    let left = 0;
    let right = height.length - 1;
    let maxArea = 0;
    let step = 0;
    
    function performWaterStep() {
        if (left >= right) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Maximum water area = ${maxArea} units`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Maximum water that can be contained = ${maxArea} units
                </div>
            `;
            
            maxWaterArea.textContent = `${maxArea} units`;
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterWater();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterWater);
            
            return;
        }
        
        step++;
        
        // Calculate current area
        const currentArea = Math.min(height[left], height[right]) * (right - left);
        const isNewMax = currentArea > maxArea;
        
        if (isNewMax) {
            maxArea = currentArea;
        }
        
        explanation.innerHTML = `Step ${step}: Left=${left}, Right=${right}, Area=${Math.min(height[left], height[right])}  ${right - left} = ${currentArea}`;
        
        // Highlight current pointers and area
        const bars = barsContainer.querySelectorAll('.array-element');
        const leftBar = bars[left].querySelector('.water-bar');
        const rightBar = bars[right].querySelector('.water-bar');
        
        leftBar.classList.add('water-pointer-left');
        rightBar.classList.add('water-pointer-right');
        
        // Visualize the water area
        const waterLevel = Math.min(height[left], height[right]);
        visualizeWaterArea(left, right, waterLevel, isNewMax);
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${isNewMax ? 'active' : ''}">
                <strong>Step ${step}:</strong> Left[${left}]=${height[left]}, Right[${right}]=${height[right]}, 
                Area = min(${height[left]}, ${height[right]})  (${right} - ${left}) = ${currentArea}
                ${isNewMax ? '  NEW MAXIMUM!' : ''}
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Remove highlights
            leftBar.classList.remove('water-pointer-left');
            rightBar.classList.remove('water-pointer-right');
            clearWaterVisualization();
            
            // Move pointers
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
            
            maxWaterArea.textContent = `${maxArea} units`;
            performWaterStep();
        }, 2000);
    }
    
    function visualizeWaterArea(leftIdx, rightIdx, waterLevel, isNewMax) {
        const bars = barsContainer.querySelectorAll('.array-element');
        const maxHeight = Math.max(...height);
        const scaleFactor = 150 / (maxHeight || 1);
        
        for (let i = leftIdx + 1; i < rightIdx; i++) {
            const bar = bars[i].querySelector('.water-bar');
            const currentHeight = height[i];
            
            if (currentHeight < waterLevel) {
                const waterHeight = (waterLevel - currentHeight) * scaleFactor;
                const waterDiv = document.createElement('div');
                waterDiv.className = `water-filled ${isNewMax ? 'water-current-area' : ''}`;
                waterDiv.style.height = `${waterHeight}px`;
                waterDiv.title = `Water: ${waterLevel - currentHeight} units`;
                bar.appendChild(waterDiv);
            }
        }
        
        // Add water level line
        const waterLevelDiv = document.createElement('div');
        waterLevelDiv.className = 'water-level';
        waterLevelDiv.style.position = 'absolute';
        waterLevelDiv.style.left = `${leftIdx * 60}px`;
        waterLevelDiv.style.width = `${(rightIdx - leftIdx) * 60}px`;
        waterLevelDiv.style.height = '2px';
        waterLevelDiv.style.top = `${150 - waterLevel * scaleFactor}px`;
        barsContainer.appendChild(waterLevelDiv);
    }
    
    function clearWaterVisualization() {
        const bars = barsContainer.querySelectorAll('.water-bar');
        bars.forEach(bar => {
            const waterElements = bar.querySelectorAll('.water-filled');
            waterElements.forEach(el => el.remove());
        });
        
        const waterLevels = barsContainer.querySelectorAll('.water-level');
        waterLevels.forEach(el => el.remove());
    }
    
    // Start algorithm
    performWaterStep();
}

// NEW: Perform Trapping Rain Water Animation
function performTrappingRainWaterAnimation() {
    const barsContainer = document.getElementById('waterBarsContainer');
    const explanation = document.getElementById('waterExplanation');
    const stepsContainer = document.getElementById('waterSteps');
    const trappedWater = document.getElementById('trappedWater');
    const continueButton = document.getElementById('continueAfterWater');
    
    const height = originalArrayForWater.map(val => parseFloat(val));
    let left = 0;
    let right = height.length - 1;
    let leftMax = 0;
    let rightMax = 0;
    let totalWater = 0;
    let step = 0;
    
    function performTrapStep() {
        if (left >= right) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Total trapped water = ${totalWater} units`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Total water trapped between bars = ${totalWater} units
                </div>
            `;
            
            trappedWater.textContent = `${totalWater} units`;
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterWater();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterWater);
            
            return;
        }
        
        step++;
        
        if (height[left] < height[right]) {
            // Process left side
            leftMax = Math.max(leftMax, height[left]);
            const waterAtLeft = leftMax - height[left];
            
            explanation.innerHTML = `Step ${step}: Left=${left}, Height=${height[left]}, LeftMax=${leftMax}, Water=${waterAtLeft}`;
            
            // Highlight and visualize
            const bars = barsContainer.querySelectorAll('.array-element');
            const leftBar = bars[left].querySelector('.water-bar');
            leftBar.classList.add('water-pointer-left');
            
            visualizeTrappedWater(left, waterAtLeft, 'left');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Processing left side. LeftMax=${leftMax}, Water at [${left}] = ${leftMax} - ${height[left]} = ${waterAtLeft}
                </div>
            `;
            
            totalWater += waterAtLeft;
            left++;
            
        } else {
            // Process right side
            rightMax = Math.max(rightMax, height[right]);
            const waterAtRight = rightMax - height[right];
            
            explanation.innerHTML = `Step ${step}: Right=${right}, Height=${height[right]}, RightMax=${rightMax}, Water=${waterAtRight}`;
            
            // Highlight and visualize
            const bars = barsContainer.querySelectorAll('.array-element');
            const rightBar = bars[right].querySelector('.water-bar');
            rightBar.classList.add('water-pointer-right');
            
            visualizeTrappedWater(right, waterAtRight, 'right');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Processing right side. RightMax=${rightMax}, Water at [${right}] = ${rightMax} - ${height[right]} = ${waterAtRight}
                </div>
            `;
            
            totalWater += waterAtRight;
            right--;
        }
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        trappedWater.textContent = `${totalWater} units`;
        
        setTimeout(() => {
            // Remove highlights and continue
            const bars = barsContainer.querySelectorAll('.water-bar');
            bars.forEach(bar => {
                bar.classList.remove('water-pointer-left', 'water-pointer-right');
            });
            performTrapStep();
        }, 1500);
    }
    
    function visualizeTrappedWater(index, waterAmount, side) {
        if (waterAmount > 0) {
            const bars = barsContainer.querySelectorAll('.array-element');
            const bar = bars[index].querySelector('.water-bar');
            const maxHeight = Math.max(...height);
            const scaleFactor = 150 / (maxHeight || 1);
            
            const waterHeight = waterAmount * scaleFactor;
            const waterDiv = document.createElement('div');
            waterDiv.className = 'water-filled';
            waterDiv.style.height = `${waterHeight}px`;
            waterDiv.title = `Trapped water: ${waterAmount} units`;
            waterDiv.style.background = side === 'left' ? 'var(--warning-color)' : 'var(--success-color)';
            bar.appendChild(waterDiv);
        }
    }
    
    // Start algorithm
    performTrapStep();
}

// NEW: Return to Original after Water Problems
function returnToOriginalAfterWater() {
    // Reset to original array
    myArray = [...originalArrayForWater];
    originalArrayForWater = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isWaterProblemRunning = false;
    
    logOperation('Water problem completed - returned to original array', 'info');
    showNotification('Returned to original array after water problem', 'success');
}
// NEW: Two Sum Handler
function handleTwoSum() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isTwoSumRunning) {
        showNotification('Two Sum operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Two Sum problem requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Show input group
    twoSumInputGroup.style.display = 'block';
    twoSumTargetInput.focus();
    
    logOperation('Started Two Sum problem', 'info');
}

// NEW: Confirm Two Sum Handler
function handleConfirmTwoSum() {
    const target = parseFloat(twoSumTargetInput.value);
    
    if (isNaN(target)) {
        showNotification('Please enter a valid target sum', 'danger');
        twoSumTargetInput.focus();
        return;
    }
    
    twoSumTarget = target;
    
    // Store original array
    originalArrayForTwoSum = [...myArray];
    
    // Hide input group
    twoSumInputGroup.style.display = 'none';
    twoSumTargetInput.value = '';
    
    // Start Two Sum visualization
    showTwoSumVisualization();
}

// NEW: Cancel Two Sum Handler
function handleCancelTwoSum() {
    twoSumInputGroup.style.display = 'none';
    twoSumTargetInput.value = '';
    
    logOperation('Cancelled Two Sum operation', 'info');
    showNotification('Two Sum operation cancelled', 'info');
}

// NEW: Show Two Sum Visualization
function showTwoSumVisualization() {
    isTwoSumRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Two Sum Problem - Target: ${twoSumTarget}</h5>
        
        <div class="array-group">
            <div class="array-label">Array</div>
            <div class="original-array-container" id="twoSumArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Two Sum Problem:</strong> Find all pairs of indices where array[i] + array[j] = ${twoSumTarget}</p>
            <p class="mb-0" id="twoSumExplanation">Initializing Two Sum algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="twoSumStepsContainer">
            <h6 class="text-center">Two Sum Algorithm Steps</h6>
            <div class="steps-container" id="twoSumSteps"></div>
        </div>
        
        <div class="two-sum-results mt-3" id="twoSumResults" style="display: none;">
            <h6 class="text-center">Two Sum Results</h6>
            <div id="twoSumPairsList" class="text-center"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterTwoSum" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForTwoSum, 'twoSumArray');
    
    performTwoSumAlgorithm();
}
// NEW: Perform Two Sum Algorithm with Animation
function performTwoSumAlgorithm() {
    const arrayContainer = document.getElementById('twoSumArray');
    const explanation = document.getElementById('twoSumExplanation');
    const stepsContainer = document.getElementById('twoSumSteps');
    const resultsContainer = document.getElementById('twoSumResults');
    const pairsList = document.getElementById('twoSumPairsList');
    const continueButton = document.getElementById('continueAfterTwoSum');
    
    const arr = originalArrayForTwoSum.map(val => parseFloat(val));
    const pairs = [];
    let step = 0;
    
    function executeTwoSumStep(i, j) {
        if (i >= arr.length - 1) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Two Sum Algorithm Completed!</strong> Found ${pairs.length} pair(s).`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Two Sum algorithm completed. Found ${pairs.length} pair(s) that sum to ${twoSumTarget}.
                </div>
            `;
            
            // Display results
            if (pairs.length > 0) {
                resultsContainer.style.display = 'block';
                pairsList.innerHTML = '<p><strong>Output:</strong></p>';
                pairs.forEach(pair => {
                    const pairElement = document.createElement('div');
                    pairElement.className = 'two-sum-pair';
                    pairElement.textContent = `[${pair[0]}, ${pair[1]}]`;
                    pairElement.title = `Values: ${arr[pair[0]]} + ${arr[pair[1]]} = ${twoSumTarget}`;
                    pairsList.appendChild(pairElement);
                });
            } else {
                pairsList.innerHTML = '<p class="text-warning">No pairs found that sum to the target.</p>';
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterTwoSum();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterTwoSum);
            
            return;
        }
        
        if (j >= arr.length) {
            // Move to next i
            executeTwoSumStep(i + 1, i + 2);
            return;
        }
        
        step++;
        explanation.innerHTML = `Step ${step}: Checking indices [${i}, ${j}] - Values: ${arr[i]} + ${arr[j]}`;
        
        // Highlight current elements being checked
        const elements = arrayContainer.querySelectorAll('.array-element');
        const elementI = elements[i].querySelector('.element-value');
        const elementJ = elements[j].querySelector('.element-value');
        
        elementI.classList.add('two-sum-current');
        elementJ.classList.add('two-sum-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Checking [${i}]=${arr[i]} and [${j}]=${arr[j]} - Sum = ${arr[i] + arr[j]}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            if (arr[i] + arr[j] === twoSumTarget) {
                // Found a pair
                explanation.innerHTML = `Step ${step}: FOUND! [${i}, ${j}] - ${arr[i]} + ${arr[j]} = ${twoSumTarget}`;
                
                elementI.classList.remove('two-sum-current');
                elementJ.classList.remove('two-sum-current');
                elementI.classList.add('two-sum-found');
                elementJ.classList.add('two-sum-found');
                
                pairs.push([i, j]);
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>FOUND PAIR:</strong> [${i}, ${j}] - ${arr[i]} + ${arr[j]} = ${twoSumTarget}
                    </div>
                `;
                
                // Continue with next j
                setTimeout(() => {
                    elementI.classList.remove('two-sum-found');
                    elementJ.classList.remove('two-sum-found');
                    elementI.classList.add('two-sum-checked');
                    elementJ.classList.add('two-sum-checked');
                    
                    executeTwoSumStep(i, j + 1);
                }, 2000);
                
            } else {
                // Not a pair
                elementI.classList.remove('two-sum-current');
                elementJ.classList.remove('two-sum-current');
                elementI.classList.add('two-sum-checked');
                elementJ.classList.add('two-sum-checked');
                
                executeTwoSumStep(i, j + 1);
            }
        }, 1500);
    }
    
    // Start Two Sum algorithm
    executeTwoSumStep(0, 1);
}
// NEW: Return to Original after Two Sum
function returnToOriginalAfterTwoSum() {
    // Reset to original array
    myArray = [...originalArrayForTwoSum];
    originalArrayForTwoSum = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isTwoSumRunning = false;
    
    logOperation('Two Sum problem completed - returned to original array', 'info');
    showNotification('Returned to original array after Two Sum problem', 'success');
}
// NEW: Find GCD Handler
function handleFindGCD() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isGcdOperationRunning) {
        showNotification('GCD operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('GCD calculation requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Check for non-negative integers
    for (let i = 0; i < myArray.length; i++) {
        const num = parseFloat(myArray[i]);
        if (num < 0 || !Number.isInteger(num)) {
            showNotification('GCD calculation requires non-negative integers', 'danger');
            return;
        }
    }
    
    isGcdOperationRunning = true;
    
    // Store original array
    originalArrayForGcdLcm = [...myArray];
    
    // Perform GCD visualization
    performGCDVisualization();
}

// NEW: Find LCM Handler
function handleFindLCM() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isLcmOperationRunning) {
        showNotification('LCM operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('LCM calculation requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Check for positive integers
    for (let i = 0; i < myArray.length; i++) {
        const num = parseFloat(myArray[i]);
        if (num <= 0 || !Number.isInteger(num)) {
            showNotification('LCM calculation requires positive integers', 'danger');
            return;
        }
    }
    
    isLcmOperationRunning = true;
    
    // Store original array
    originalArrayForGcdLcm = [...myArray];
    
    // Perform LCM visualization
    performLCMVisualization();
}
// NEW: Perform GCD Visualization
function performGCDVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find GCD (Greatest Common Divisor) of Array</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalGcdArray"></div>
        </div>
        
        <div class="gcd-lcm-explanation">
            <p class="mb-2"><strong>GCD Algorithm:</strong> Finding the largest number that divides all elements</p>
            <p class="mb-0" id="gcdExplanation">Starting GCD calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="gcdStepsContainer">
            <h6 class="text-center">GCD Calculation Steps</h6>
            <div class="steps-container" id="gcdSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>GCD of Array</div>
            <div class="stats-value" id="gcdResultValue">Calculating...</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterGcd" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForGcdLcm, 'originalGcdArray');
    
    executeGCDAlgorithm();
}

// NEW: Perform LCM Visualization
function performLCMVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find LCM (Least Common Multiple) of Array</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalLcmArray"></div>
        </div>
        
        <div class="gcd-lcm-explanation">
            <p class="mb-2"><strong>LCM Algorithm:</strong> Finding the smallest number divisible by all elements</p>
            <p class="mb-0" id="lcmExplanation">Starting LCM calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="lcmStepsContainer">
            <h6 class="text-center">LCM Calculation Steps</h6>
            <div class="steps-container" id="lcmSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>LCM of Array</div>
            <div class="stats-value" id="lcmResultValue">Calculating...</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterLcm" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForGcdLcm, 'originalLcmArray');
    
    executeLCMAlgorithm();
}
// NEW: Execute GCD Algorithm with Animation
function executeGCDAlgorithm() {
    const arrayContainer = document.getElementById('originalGcdArray');
    const explanation = document.getElementById('gcdExplanation');
    const stepsContainer = document.getElementById('gcdSteps');
    const gcdResultValue = document.getElementById('gcdResultValue');
    const continueButton = document.getElementById('continueAfterGcd');
    
    const arr = originalArrayForGcdLcm.map(val => parseInt(val));
    let step = 0;
    
    function calculateGCD(a, b) {
        if (b === 0) return a;
        return calculateGCD(b, a % b);
    }
    
    function executeGCDStep(currentGCD, nextIndex) {
        if (nextIndex >= arr.length) {
            // GCD calculation completed
            explanation.innerHTML = `<strong>GCD Calculation Completed!</strong>`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> GCD of array [${originalArrayForGcdLcm.join(', ')}] is ${currentGCD}
                </div>
            `;
            
            // Highlight all elements and show result
            const elements = arrayContainer.querySelectorAll('.array-element');
            elements.forEach((el, index) => {
                setTimeout(() => {
                    const valueDiv = el.querySelector('.element-value');
                    valueDiv.classList.add('gcd-highlight');
                    
                    // Show which elements are divisible by GCD
                    if (arr[index] % currentGCD === 0) {
                        setTimeout(() => {
                            valueDiv.classList.add('gcd-lcm-result');
                        }, 500);
                    }
                }, index * 300);
            });
            
            gcdResultValue.textContent = currentGCD;
            gcdResultValue.classList.add('gcd-lcm-result');
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterGcdLcm();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterGcdLcm);
            
            return;
        }
        
        step++;
        const nextNum = arr[nextIndex];
        
        explanation.innerHTML = `Step ${step}: Calculating GCD(${currentGCD}, ${nextNum})`;
        
        // Highlight current numbers being compared
        const elements = arrayContainer.querySelectorAll('.array-element');
        
        // Highlight all previous elements that contributed to current GCD
        for (let i = 0; i < nextIndex; i++) {
            elements[i].querySelector('.element-value').classList.add('gcd-highlight');
        }
        
        // Highlight the next number
        elements[nextIndex].querySelector('.element-value').classList.add('gcd-highlight');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> GCD(${currentGCD}, ${nextNum}) = 
            </div>
        `;
        
        setTimeout(() => {
            const newGCD = calculateGCD(currentGCD, nextNum);
            
            stepsContainer.innerHTML = stepsContainer.innerHTML.replace(
                `GCD(${currentGCD}, ${nextNum}) = `,
                `GCD(${currentGCD}, ${nextNum}) = ${newGCD}`
            );
            
            explanation.innerHTML = `Step ${step}: GCD(${currentGCD}, ${nextNum}) = ${newGCD}`;
            
            // Remove highlights for next step
            elements[nextIndex].querySelector('.element-value').classList.remove('gcd-highlight');
            
            // Continue with next number
            setTimeout(() => {
                executeGCDStep(newGCD, nextIndex + 1);
            }, 1500);
            
        }, 1000);
    }
    
    // Start with first element
    explanation.innerHTML = `Starting with first element: ${arr[0]}`;
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Initial:</strong> Start with first element = ${arr[0]}
        </div>
    `;
    
    const elements = arrayContainer.querySelectorAll('.array-element');
    elements[0].querySelector('.element-value').classList.add('gcd-highlight');
    
    setTimeout(() => {
        executeGCDStep(arr[0], 1);
    }, 1000);
}

// NEW: Execute LCM Algorithm with Animation
function executeLCMAlgorithm() {
    const arrayContainer = document.getElementById('originalLcmArray');
    const explanation = document.getElementById('lcmExplanation');
    const stepsContainer = document.getElementById('lcmSteps');
    const lcmResultValue = document.getElementById('lcmResultValue');
    const continueButton = document.getElementById('continueAfterLcm');
    
    const arr = originalArrayForGcdLcm.map(val => parseInt(val));
    let step = 0;
    
    function calculateGCD(a, b) {
        if (b === 0) return a;
        return calculateGCD(b, a % b);
    }
    
    function calculateLCM(a, b) {
        return (a * b) / calculateGCD(a, b);
    }
    
    function executeLCMStep(currentLCM, nextIndex) {
        if (nextIndex >= arr.length) {
            // LCM calculation completed
            explanation.innerHTML = `<strong>LCM Calculation Completed!</strong>`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> LCM of array [${originalArrayForGcdLcm.join(', ')}] is ${currentLCM}
                </div>
            `;
            
            // Highlight all elements and show result
            const elements = arrayContainer.querySelectorAll('.array-element');
            elements.forEach((el, index) => {
                setTimeout(() => {
                    const valueDiv = el.querySelector('.element-value');
                    valueDiv.classList.add('lcm-highlight');
                    
                    // Show that LCM is multiple of each element
                    if (currentLCM % arr[index] === 0) {
                        setTimeout(() => {
                            valueDiv.classList.add('gcd-lcm-result');
                        }, 500);
                    }
                }, index * 300);
            });
            
            lcmResultValue.textContent = currentLCM;
            lcmResultValue.classList.add('gcd-lcm-result');
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterGcdLcm();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterGcdLcm);
            
            return;
        }
        
        step++;
        const nextNum = arr[nextIndex];
        
        explanation.innerHTML = `Step ${step}: Calculating LCM(${currentLCM}, ${nextNum})`;
        
        // Highlight current numbers being compared
        const elements = arrayContainer.querySelectorAll('.array-element');
        
        // Highlight all previous elements that contributed to current LCM
        for (let i = 0; i < nextIndex; i++) {
            elements[i].querySelector('.element-value').classList.add('lcm-highlight');
        }
        
        // Highlight the next number
        elements[nextIndex].querySelector('.element-value').classList.add('lcm-highlight');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> LCM(${currentLCM}, ${nextNum}) = 
            </div>
        `;
        
        setTimeout(() => {
            const newLCM = calculateLCM(currentLCM, nextNum);
            
            stepsContainer.innerHTML = stepsContainer.innerHTML.replace(
                `LCM(${currentLCM}, ${nextNum}) = `,
                `LCM(${currentLCM}, ${nextNum}) = ${newLCM}`
            );
            
            explanation.innerHTML = `Step ${step}: LCM(${currentLCM}, ${nextNum}) = ${newLCM}`;
            
            // Show calculation details
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Calculation:</strong> (${currentLCM}  ${nextNum})  GCD(${currentLCM}, ${nextNum}) = ${newLCM}
                </div>
            `;
            
            // Remove highlights for next step
            elements[nextIndex].querySelector('.element-value').classList.remove('lcm-highlight');
            
            // Continue with next number
            setTimeout(() => {
                executeLCMStep(newLCM, nextIndex + 1);
            }, 2000);
            
        }, 1000);
    }
    
    // Start with first element
    explanation.innerHTML = `Starting with first element: ${arr[0]}`;
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Initial:</strong> Start with first element = ${arr[0]}
        </div>
    `;
    
    const elements = arrayContainer.querySelectorAll('.array-element');
    elements[0].querySelector('.element-value').classList.add('lcm-highlight');
    
    setTimeout(() => {
        executeLCMStep(arr[0], 1);
    }, 1000);
}
// NEW: Return to Original after GCD/LCM Operations
function returnToOriginalAfterGcdLcm() {
    // Reset to original array
    myArray = [...originalArrayForGcdLcm];
    originalArrayForGcdLcm = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset states
    isGcdOperationRunning = false;
    isLcmOperationRunning = false;
    
    logOperation('GCD/LCM operation completed - returned to original array', 'info');
    showNotification('Returned to original array after mathematical operation', 'success');
}
// NEW: Prime Sieve Handler
function handlePrimeSieve() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isPrimeSieveRunning) {
        showNotification('Prime sieve operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Prime sieve requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Check for positive integers
    for (let i = 0; i < myArray.length; i++) {
        const num = parseFloat(myArray[i]);
        if (num < 0 || !Number.isInteger(num)) {
            showNotification('Prime sieve requires positive integers', 'danger');
            return;
        }
    }
    
    isPrimeSieveRunning = true;
    
    // Store original array
    originalArrayForPrimeSieve = [...myArray];
    
    // Perform prime sieve visualization
    performPrimeSieveVisualization();
}
// NEW: Perform Prime Sieve Visualization
function performPrimeSieveVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Prime Sieve - Identify Prime Numbers</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalPrimeArray"></div>
        </div>
        
        <div class="prime-sieve-explanation">
            <p class="mb-2"><strong>Sieve Algorithm:</strong> Identifying prime numbers (green) and composite numbers (red)</p>
            <p class="mb-0" id="sieveExplanation">Starting prime sieve analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="sieveStepsContainer">
            <h6 class="text-center">Sieve Process Steps</h6>
            <div class="steps-container" id="sieveSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Prime Numbers Found</div>
            <div class="stats-value" id="primesCount">0</div>
        </div>
        
        <div class="primes-list" id="primesListContainer" style="display: none;">
            <h6 class="text-center mb-3">Prime Numbers in Array</h6>
            <div id="primesList"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSieve" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForPrimeSieve, 'originalPrimeArray');
    
    executePrimeSieveAlgorithm();
}
// NEW: Execute Prime Sieve Algorithm with Animation
function executePrimeSieveAlgorithm() {
    const arrayContainer = document.getElementById('originalPrimeArray');
    const explanation = document.getElementById('sieveExplanation');
    const stepsContainer = document.getElementById('sieveSteps');
    const primesCount = document.getElementById('primesCount');
    const primesListContainer = document.getElementById('primesListContainer');
    const primesList = document.getElementById('primesList');
    const continueButton = document.getElementById('continueAfterSieve');
    
    const arr = originalArrayForPrimeSieve.map(val => parseInt(val));
    let step = 0;
    let primes = [];
    
    // Helper function to check if a number is prime
    function isPrime(num) {
        if (num <= 1) return false;
        if (num <= 3) return true;
        if (num % 2 === 0 || num % 3 === 0) return false;
        
        for (let i = 5; i * i <= num; i += 6) {
            if (num % i === 0 || num % (i + 2) === 0) return false;
        }
        return true;
    }
    
    function executeSieveStep(index) {
        if (index >= arr.length) {
            // Sieve completed
            explanation.innerHTML = `<strong>Prime Sieve Completed!</strong> Found ${primes.length} prime numbers.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Analysis complete. Found ${primes.length} prime numbers in the array.
                </div>
            `;
            
            // Show primes list
            primesListContainer.style.display = 'block';
            primesList.innerHTML = '';
            primes.forEach(prime => {
                const primeElement = document.createElement('span');
                primeElement.className = 'prime-item';
                primeElement.textContent = prime;
                primeElement.style.animationDelay = `${primes.indexOf(prime) * 100}ms`;
                primesList.appendChild(primeElement);
            });
            
            primesCount.textContent = primes.length;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterPrimeSieve();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterPrimeSieve);
            
            return;
        }
        
        step++;
        const currentNum = arr[index];
        
        explanation.innerHTML = `Step ${step}: Checking if ${currentNum} is prime`;
        
        // Highlight current number being checked
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElement = elements[index].querySelector('.element-value');
        currentElement.classList.add('sieve-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Checking number ${currentNum}...
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Check if the number is prime
            const primeCheck = isPrime(currentNum);
            
            if (primeCheck) {
                // It's a prime number
                currentElement.classList.remove('sieve-current');
                currentElement.classList.add('prime-number');
                primes.push(currentNum);
                
                stepsContainer.innerHTML = stepsContainer.innerHTML.replace(
                    `Checking number ${currentNum}...`,
                    ` ${currentNum} is a PRIME number`
                );
                
                explanation.innerHTML = `Step ${step}: ${currentNum} is a PRIME number `;
                
            } else {
                // It's a composite number
                currentElement.classList.remove('sieve-current');
                currentElement.classList.add('composite-number');
                
                stepsContainer.innerHTML = stepsContainer.innerHTML.replace(
                    `Checking number ${currentNum}...`,
                    ` ${currentNum} is a COMPOSITE number`
                );
                
                explanation.innerHTML = `Step ${step}: ${currentNum} is a COMPOSITE number `;
            }
            
            // Update primes count
            primesCount.textContent = primes.length;
            
            // Show special cases
            if (currentNum === 0 || currentNum === 1) {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Note:</strong> ${currentNum} is neither prime nor composite
                    </div>
                `;
            }
            
            // Move to next number
            setTimeout(() => {
                executeSieveStep(index + 1);
            }, 1500);
            
        }, 1000);
    }
    
    // Start the sieve process
    explanation.innerHTML = `Starting prime sieve analysis for ${arr.length} numbers...`;
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Initial:</strong> Beginning prime number analysis for array: [${arr.join(', ')}]
        </div>
    `;
    
    // Initial highlight of all elements
    const elements = arrayContainer.querySelectorAll('.array-element');
    elements.forEach((el, idx) => {
        setTimeout(() => {
            el.querySelector('.element-value').classList.add('sieve-multiple');
        }, idx * 100);
    });
    
    setTimeout(() => {
        // Remove initial highlights and start checking
        elements.forEach(el => {
            el.querySelector('.element-value').classList.remove('sieve-multiple');
        });
        executeSieveStep(0);
    }, 1000);
}
// NEW: Enhanced Prime Sieve with Sieve of Eratosthenes
function performEnhancedPrimeSieve() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Sieve of Eratosthenes - Prime Number Identification</h5>
        
        <div class="array-group">
            <div class="array-label">Number Array</div>
            <div class="original-array-container" id="enhancedPrimeArray"></div>
        </div>
        
        <div class="prime-sieve-explanation">
            <p class="mb-2"><strong>Sieve of Eratosthenes:</strong> Classical algorithm for finding all primes up to a given limit</p>
            <p class="mb-0" id="enhancedSieveExplanation">Initializing sieve algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="enhancedSieveStepsContainer">
            <h6 class="text-center">Sieve Algorithm Steps</h6>
            <div class="steps-container" id="enhancedSieveSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Prime Numbers Found</div>
            <div class="stats-value" id="enhancedPrimesCount">0</div>
        </div>
        
        <div class="primes-list" id="enhancedPrimesListContainer" style="display: none;">
            <h6 class="text-center mb-3">Prime Numbers Identified</h6>
            <div id="enhancedPrimesList"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterEnhancedSieve" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForPrimeSieve, 'enhancedPrimeArray');
    
    executeEnhancedSieveAlgorithm();
}

// NEW: Execute Enhanced Sieve Algorithm
function executeEnhancedSieveAlgorithm() {
    const arrayContainer = document.getElementById('enhancedPrimeArray');
    const explanation = document.getElementById('enhancedSieveExplanation');
    const stepsContainer = document.getElementById('enhancedSieveSteps');
    const primesCount = document.getElementById('enhancedPrimesCount');
    const primesListContainer = document.getElementById('enhancedPrimesListContainer');
    const primesList = document.getElementById('enhancedPrimesList');
    const continueButton = document.getElementById('continueAfterEnhancedSieve');
    
    const arr = originalArrayForPrimeSieve.map(val => parseInt(val));
    const maxNum = Math.max(...arr);
    let step = 0;
    let primes = [];
    
    // Create a sieve array
    let sieve = Array(maxNum + 1).fill(true);
    sieve[0] = sieve[1] = false;
    
    function executeEnhancedStep(p) {
        if (p * p > maxNum) {
            // Mark remaining primes in the original array
            markPrimesInOriginalArray();
            return;
        }
        
        if (sieve[p]) {
            step++;
            explanation.innerHTML = `Step ${step}: ${p} is prime - marking its multiples`;
            
            // Highlight current prime
            const elements = arrayContainer.querySelectorAll('.array-element');
            elements.forEach((el, index) => {
                if (arr[index] === p) {
                    el.querySelector('.element-value').classList.add('prime-number');
                }
            });
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> ${p} is prime  Marking multiples: 
                </div>
            `;
            
            let multiples = [];
            // Mark multiples of p
            for (let i = p * p; i <= maxNum; i += p) {
                if (sieve[i]) {
                    sieve[i] = false;
                    multiples.push(i);
                    
                    // Highlight multiples in the array
                    elements.forEach((el, index) => {
                        if (arr[index] === i) {
                            setTimeout(() => {
                                el.querySelector('.element-value').classList.add('composite-number');
                            }, multiples.length * 200);
                        }
                    });
                }
            }
            
            stepsContainer.innerHTML = stepsContainer.innerHTML.replace(
                'Marking multiples: ',
                `Marking multiples: ${multiples.join(', ')}`
            );
            
            setTimeout(() => {
                executeEnhancedStep(p + 1);
            }, 1000 + multiples.length * 200);
            
        } else {
            executeEnhancedStep(p + 1);
        }
    }
    
    function markPrimesInOriginalArray() {
        // Final marking of all numbers in the original array
        const elements = arrayContainer.querySelectorAll('.array-element');
        let finalPrimes = [];
        
        elements.forEach((el, index) => {
            const num = arr[index];
            setTimeout(() => {
                if (sieve[num]) {
                    el.querySelector('.element-value').classList.add('prime-number');
                    finalPrimes.push(num);
                } else if (num > 1) {
                    el.querySelector('.element-value').classList.add('composite-number');
                }
            }, index * 200);
        });
        
        setTimeout(() => {
            // Sieve completed
            explanation.innerHTML = `<strong>Sieve of Eratosthenes Completed!</strong> Found ${finalPrimes.length} prime numbers.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Algorithm complete. Identified all prime numbers using Sieve of Eratosthenes.
                </div>
            `;
            
            // Show primes list
            primesListContainer.style.display = 'block';
            primesList.innerHTML = '';
            finalPrimes.forEach(prime => {
                const primeElement = document.createElement('span');
                primeElement.className = 'prime-item';
                primeElement.textContent = prime;
                primesList.appendChild(primeElement);
            });
            
            primesCount.textContent = finalPrimes.length;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterPrimeSieve();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterPrimeSieve);
        }, arr.length * 200 + 1000);
    }
    
    // Start the enhanced sieve process
    explanation.innerHTML = `Starting Sieve of Eratosthenes for numbers up to ${maxNum}...`;
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Algorithm:</strong> Sieve of Eratosthenes - Classical prime finding algorithm
        </div>
    `;
    
    setTimeout(() => {
        executeEnhancedStep(2);
    }, 1000);
}
// NEW: Longest Substring Without Repeating Characters Handler
function handleFindLongestSubstring() {
    const inputString = substringInput.value.trim();
    
    if (inputString === '') {
        showNotification('Please enter a string to analyze', 'warning');
        substringInput.focus();
        return;
    }
    
    if (isLongestSubstringRunning) {
        showNotification('Longest substring operation is already in progress', 'warning');
        return;
    }
    
    isLongestSubstringRunning = true;
    
    // Store original array
    originalArrayForSubstring = [...myArray];
    
    // Convert string to character array for visualization
    const charArray = inputString.split('');
    
    // Show longest substring visualization
    showLongestSubstringVisualization(inputString, charArray);
}

// NEW: Show Longest Substring Visualization
function showLongestSubstringVisualization(inputString, charArray) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Longest Substring Without Repeating Characters</h5>
        
        <div class="array-group">
            <div class="array-label">Input String: "${inputString}"</div>
            <div class="char-array-container" id="charArrayDisplay"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Sliding Window Process</div>
            <div id="slidingWindowContainer"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Sliding window with character frequency tracking</p>
            <p class="mb-0" id="substringExplanation">Initializing sliding window algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="substringStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="substringSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Longest Substring Length</div>
            <div class="stats-value" id="currentMaxLength">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Current Longest Substring</div>
            <div class="stats-value" id="currentLongestSubstring">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSubstring" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Render character array
    renderCharArray(charArray, 'charArrayDisplay');
    
    // Start the algorithm animation
    performLongestSubstringAlgorithm(inputString, charArray);
}

// NEW: Render Character Array
function renderCharArray(charArray, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    charArray.forEach((char, index) => {
        const charElement = document.createElement('div');
        charElement.className = 'char-element';
        charElement.innerHTML = `
            <div class="char-value" data-index="${index}">${char}</div>
            <div class="char-index">[${index}]</div>
        `;
        container.appendChild(charElement);
    });
}

// NEW: Perform Longest Substring Algorithm with Animation
function performLongestSubstringAlgorithm(inputString, charArray) {
    const charContainer = document.getElementById('charArrayDisplay');
    const slidingWindowContainer = document.getElementById('slidingWindowContainer');
    const explanation = document.getElementById('substringExplanation');
    const stepsContainer = document.getElementById('substringSteps');
    const currentMaxLength = document.getElementById('currentMaxLength');
    const currentLongestSubstring = document.getElementById('currentLongestSubstring');
    const continueButton = document.getElementById('continueAfterSubstring');
    
    let maxLength = 0;
    let start = 0;
    let charMap = new Map();
    let currentSubstring = '';
    let step = 0;
    let maxStart = 0;
    let maxEnd = 0;
    
    function performAlgorithmStep(end) {
        if (end >= charArray.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Longest substring found.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Longest substring without repeating characters: "${inputString.substring(maxStart, maxEnd + 1)}" (length: ${maxLength})
                </div>
            `;
            
            // Highlight the final longest substring in the character array
            const charElements = charContainer.querySelectorAll('.char-value');
            for (let i = maxStart; i <= maxEnd; i++) {
                setTimeout(() => {
                    charElements[i].classList.add('substring-max');
                }, (i - maxStart) * 200);
            }
            
            // Show final results
            longestSubstringResults.style.display = 'block';
            longestSubstringLength.textContent = maxLength;
            longestSubstringValue.textContent = `"${inputString.substring(maxStart, maxEnd + 1)}"`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterSubstring();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSubstring);
            
            return;
        }
        
        step++;
        const currentChar = charArray[end];
        
        // Update explanation
        explanation.innerHTML = `Step ${step}: Processing character at index ${end} = "${currentChar}"`;
        
        // Highlight current character
        const charElements = charContainer.querySelectorAll('.char-value');
        charElements[end].classList.add('substring-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Processing index ${end} = "${currentChar}"
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            if (charMap.has(currentChar) && charMap.get(currentChar) >= start) {
                // Duplicate character found
                const duplicateIndex = charMap.get(currentChar);
                explanation.innerHTML = `Step ${step}: Duplicate character "${currentChar}" found at index ${duplicateIndex}`;
                
                // Highlight duplicate character
                charElements[duplicateIndex].classList.add('substring-duplicate');
                charElements[end].classList.add('substring-duplicate');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> Duplicate "${currentChar}" found! Moving start from ${start} to ${duplicateIndex + 1}
                    </div>
                `;
                
                setTimeout(() => {
                    // Remove duplicate highlights
                    charElements[duplicateIndex].classList.remove('substring-duplicate');
                    charElements[end].classList.remove('substring-duplicate');
                    
                    // Move start pointer
                    start = charMap.get(currentChar) + 1;
                    
                    // Update current substring
                    currentSubstring = inputString.substring(start, end + 1);
                    
                    // Update sliding window visualization
                    updateSlidingWindowVisualization(start, end, currentSubstring);
                    
                    // Continue algorithm
                    charMap.set(currentChar, end);
                    checkMaxLength(end);
                }, 1500);
                
            } else {
                // No duplicate, extend window
                currentSubstring = inputString.substring(start, end + 1);
                explanation.innerHTML = `Step ${step}: No duplicate. Current substring: "${currentSubstring}"`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step}:</strong> No duplicate. Window extended to: "${currentSubstring}"
                    </div>
                `;
                
                // Update sliding window visualization
                updateSlidingWindowVisualization(start, end, currentSubstring);
                
                // Add character to map and check max length
                charMap.set(currentChar, end);
                checkMaxLength(end);
            }
            
            function checkMaxLength(end) {
                const currentLength = end - start + 1;
                
                if (currentLength > maxLength) {
                    maxLength = currentLength;
                    maxStart = start;
                    maxEnd = end;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>New Maximum!</strong> Length: ${maxLength}, Substring: "${inputString.substring(start, end + 1)}"
                        </div>
                    `;
                    
                    // Highlight the new maximum substring
                    const allCharElements = charContainer.querySelectorAll('.char-value');
                    for (let i = start; i <= end; i++) {
                        allCharElements[i].classList.add('substring-max');
                    }
                    
                    // Remove max highlight from previous substrings after a delay
                    setTimeout(() => {
                        for (let i = 0; i < allCharElements.length; i++) {
                            if (i < start || i > end) {
                                allCharElements[i].classList.remove('substring-max');
                            }
                        }
                    }, 1000);
                }
                
                // Update current stats
                currentMaxLength.textContent = maxLength;
                currentLongestSubstring.textContent = `"${inputString.substring(maxStart, maxEnd + 1)}"`;
                
                // Remove current highlight and continue
                charElements[end].classList.remove('substring-current');
                
                // Continue to next character
                setTimeout(() => {
                    performAlgorithmStep(end + 1);
                }, 1000);
            }
        }, 1000);
    }
    
    // Start algorithm
    performAlgorithmStep(0);
}

// NEW: Update Sliding Window Visualization
function updateSlidingWindowVisualization(start, end, currentSubstring) {
    const slidingWindowContainer = document.getElementById('slidingWindowContainer');
    
    const windowElement = document.createElement('div');
    windowElement.className = 'substring-window';
    windowElement.innerHTML = `
        <div class="substring-window-label">Window [${start}-${end}]</div>
        <div class="char-array-container">
            ${currentSubstring.split('').map((char, index) => `
                <div class="char-element">
                    <div class="char-value substring-included">${char}</div>
                    <div class="char-index">[${start + index}]</div>
                </div>
            `).join('')}
        </div>
        <div class="text-center mt-2">
            <small>Current Substring: "${currentSubstring}" (Length: ${end - start + 1})</small>
        </div>
    `;
    
    // Clear previous window and add new one
    slidingWindowContainer.innerHTML = '';
    slidingWindowContainer.appendChild(windowElement);
}

// NEW: Return to Original after Substring Operation
function returnToOriginalAfterSubstring() {
    // Reset to original array
    myArray = [...originalArrayForSubstring];
    originalArrayForSubstring = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isLongestSubstringRunning = false;
    
    // Clear input and hide results
    substringInput.value = '';
    longestSubstringResults.style.display = 'none';
    
    logOperation('Longest substring operation completed - returned to original array', 'info');
    showNotification('Returned to original array after longest substring operation', 'success');
}
// NEW: Subarray Product Less Than K Handler
function handleSubarrayProduct() {
    const k = parseFloat(subarrayProductK.value);
    
    if (isNaN(k) || k <= 0) {
        showNotification('Please enter a valid positive k value', 'danger');
        subarrayProductK.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Subarray product operations require all array elements to be numbers', 'danger');
        return;
    }
    
    if (isSubarrayProductRunning) {
        showNotification('A subarray product operation is already in progress', 'warning');
        return;
    }
    
    isSubarrayProductRunning = true;
    
    // Store original array
    originalArrayForProduct = [...myArray];
    
    // Perform subarray product visualization
    performSubarrayProductVisualization(k);
}
// NEW: Perform Subarray Product Visualization
function performSubarrayProductVisualization(k) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Subarray Product Less Than ${k}</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalProductArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Subarray Product Analysis</div>
            <div class="transformed-array-container" id="transformedProductArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find all contiguous subarrays with product less than ${k}</p>
            <p class="mb-0" id="productExplanation">Initializing subarray product analysis...</p>
        </div>
        
        <!-- Valid Subarrays Count and List - Placed between analysis and steps -->
        <div class="stats-card mt-3">
            <div>Valid Subarrays Count</div>
            <div class="stats-value" id="validSubarraysCount">0</div>
        </div>
        
        <div class="subarrays-results mt-3" id="productSubarraysResults">
            <h6 class="text-center">Valid Subarrays (Product < ${k})</h6>
            <div id="productSubarraysList" class="mt-2 text-center">No valid subarrays found yet...</div>
        </div>
        
        <div class="algorithm-steps mt-3" id="productStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="productSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterProduct" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForProduct, 'originalProductArray');
    renderArrayInContainer([...originalArrayForProduct], 'transformedProductArray');
    
    executeSubarrayProductAlgorithm(k);
}
// NEW: Execute Subarray Product Algorithm with Animation
// NEW: Execute Subarray Product Algorithm with Animation
function executeSubarrayProductAlgorithm(k) {
    const arrayContainer = document.getElementById('transformedProductArray');
    const originalContainer = document.getElementById('originalProductArray');
    const explanation = document.getElementById('productExplanation');
    const stepsContainer = document.getElementById('productSteps');
    const validSubarraysCount = document.getElementById('validSubarraysCount');
    const productSubarraysResults = document.getElementById('productSubarraysResults');
    const productSubarraysList = document.getElementById('productSubarraysList');
    const continueButton = document.getElementById('continueAfterProduct');
    
    const arr = originalArrayForProduct.map(val => parseFloat(val));
    let validSubarrays = [];
    let step = 0;
    let totalValid = 0;
    
    // Algorithm: Sliding window approach for subarray product less than k
    function executeProductStep(left, right, currentProduct) {
        if (left >= arr.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Found ${totalValid} subarrays with product < ${k}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Total ${totalValid} valid subarrays found with product less than ${k}
                </div>
            `;
            
            validSubarraysCount.textContent = totalValid;
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterProduct();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterProduct);
            
            return;
        }
        
        step++;
        
        if (right >= arr.length) {
            // Move to next starting position
            executeProductStep(left + 1, left + 1, 1);
            return;
        }
        
        // Calculate current product
        let newProduct = currentProduct * arr[right];
        
        // Update explanation
        explanation.innerHTML = `Checking subarray [${left}-${right}]: product = ${newProduct.toFixed(2)}`;
        
        // Highlight current window
        const elements = arrayContainer.querySelectorAll('.array-element');
        const originalElements = originalContainer.querySelectorAll('.array-element');
        
        // Clear previous highlights
        elements.forEach(el => {
            const valueDiv = el.querySelector('.element-value');
            valueDiv.classList.remove('product-window-current', 'product-window-included', 
                                   'product-window-valid', 'product-window-invalid');
        });
        
        // Highlight current window
        for (let i = left; i <= right; i++) {
            if (i < elements.length) {
                const valueDiv = elements[i].querySelector('.element-value');
                const originalValueDiv = originalElements[i].querySelector('.element-value');
                
                valueDiv.classList.add('product-window-included');
                originalValueDiv.classList.add('product-window-included');
            }
        }
        
        // Highlight current right pointer
        if (right < elements.length) {
            const rightElement = elements[right].querySelector('.element-value');
            const originalRightElement = originalElements[right].querySelector('.element-value');
            
            rightElement.classList.add('product-window-current');
            originalRightElement.classList.add('product-window-current');
        }
        
        // Check if product is valid
        if (newProduct < k) {
            // Valid subarray found
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Subarray [${left}-${right}] product = ${newProduct.toFixed(2)} < ${k}  VALID
                </div>
            `;
            
            // Highlight as valid
            for (let i = left; i <= right; i++) {
                if (i < elements.length) {
                    const valueDiv = elements[i].querySelector('.element-value');
                    const originalValueDiv = originalElements[i].querySelector('.element-value');
                    
                    valueDiv.classList.add('product-window-valid');
                    originalValueDiv.classList.add('product-window-valid');
                }
            }
            
            // Add to valid subarrays
            validSubarrays.push({
                start: left,
                end: right,
                values: arr.slice(left, right + 1),
                product: newProduct
            });
            totalValid++;
            validSubarraysCount.textContent = totalValid;
            
            // Update valid subarrays display in real-time
            updateValidSubarraysDisplay();
            
            // Continue expanding window
            setTimeout(() => {
                executeProductStep(left, right + 1, newProduct);
            }, 1500);
            
        } else {
            // Invalid subarray
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}:</strong> Subarray [${left}-${right}] product = ${newProduct.toFixed(2)}  ${k}  INVALID
                </div>
            `;
            
            // Highlight as invalid
            for (let i = left; i <= right; i++) {
                if (i < elements.length) {
                    const valueDiv = elements[i].querySelector('.element-value');
                    const originalValueDiv = originalElements[i].querySelector('.element-value');
                    
                    valueDiv.classList.add('product-window-invalid');
                    originalValueDiv.classList.add('product-window-invalid');
                }
            }
            
            // Move to next starting position
            setTimeout(() => {
                executeProductStep(left + 1, left + 1, 1);
            }, 1500);
        }
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
    }
    
    // Function to update valid subarrays display in real-time
    function updateValidSubarraysDisplay() {
        if (validSubarrays.length > 0) {
            productSubarraysResults.style.display = 'block';
            productSubarraysList.innerHTML = '';
            
            validSubarrays.forEach((subarray, index) => {
                const subarrayItem = document.createElement('span');
                subarrayItem.className = 'product-subarray-item';
                subarrayItem.textContent = `[${subarray.values.join(', ')}]`;
                subarrayItem.title = `Product: ${subarray.product.toFixed(2)}, Indices: ${subarray.start}-${subarray.end}`;
                productSubarraysList.appendChild(subarrayItem);
                
                // Add space between items
                if (index < validSubarrays.length - 1) {
                    productSubarraysList.appendChild(document.createTextNode(' '));
                }
            });
        }
    }
    
    // Initialize the display
    productSubarraysResults.style.display = 'block';
    productSubarraysList.innerHTML = 'No valid subarrays found yet...';
    validSubarraysCount.textContent = '0';
    
    // Start algorithm execution
    executeProductStep(0, 0, 1);
}

// NEW: Return to Original after Product Operation
function returnToOriginalAfterProduct() {
    // Reset to original array
    myArray = [...originalArrayForProduct];
    originalArrayForProduct = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isSubarrayProductRunning = false;
    
    // Clear input
    subarrayProductK.value = '';
    
    logOperation('Subarray product operation completed - returned to original array', 'info');
    showNotification('Returned to original array after subarray product operation', 'success');
}
// NEW: Leader in Array Handler
function handleLeaderInArray() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isLeaderOperationRunning) {
        showNotification('Leader operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Leader operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForLeader = [...myArray];
    
    // Show leader visualization
    showLeaderVisualization();
}
// NEW: Show Leader Visualization
function showLeaderVisualization() {
    isLeaderOperationRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Leader in Array Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalLeaderArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Leader Detection Process</div>
            <div class="transformed-array-container" id="transformedLeaderArray"></div>
        </div>

        <!-- Leader Positions Display - Added between Process and Steps -->
        <div class="array-group mt-4">
            <div class="array-label">Leader Positions</div>
            <div class="subarrays-container" id="leaderPositionsContainer">
                <div class="text-center text-muted" id="leaderPositionsPlaceholder">
                    Leaders will be displayed here as they are found...
                </div>
                <div class="d-flex flex-wrap justify-content-center mt-2" id="leaderPositionsDisplay"></div>
            </div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Leader Definition:</strong> An element is a leader if it's greater than all elements to its right</p>
            <p class="mb-0" id="leaderExplanation">Starting leader detection algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="leaderStepsContainer">
            <h6 class="text-center">Leader Detection Steps</h6>
            <div class="steps-container" id="leaderSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Leaders Found</div>
            <div class="stats-value" id="leadersFoundValue">0</div>
        </div>
        
        <div class="table-container mt-3" id="leaderTableContainer" style="display: none;">
            <h6 class="text-center">Leader Positions Table</h6>
            <table class="leader-table">
                <thead>
                    <tr>
                        <th>Element</th>
                        <th>Index</th>
                        <th>Is Leader</th>
                        <th>Reason</th>
                    </tr>
                </thead>
                <tbody id="leaderTableBody">
                </tbody>
            </table>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterLeader" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForLeader, 'originalLeaderArray');
    renderArrayInContainer([...originalArrayForLeader], 'transformedLeaderArray');
    
    performLeaderDetectionAnimation();
}
// NEW: Perform Leader Detection Animation
function performLeaderDetectionAnimation() {
    const originalContainer = document.getElementById('originalLeaderArray');
    const transformedContainer = document.getElementById('transformedLeaderArray');
    const explanation = document.getElementById('leaderExplanation');
    const stepsContainer = document.getElementById('leaderSteps');
    const leadersFoundValue = document.getElementById('leadersFoundValue');
    const leaderTableContainer = document.getElementById('leaderTableContainer');
    const leaderTableBody = document.getElementById('leaderTableBody');
    const leaderPositionsDisplay = document.getElementById('leaderPositionsDisplay');
    const leaderPositionsPlaceholder = document.getElementById('leaderPositionsPlaceholder');
    const continueButton = document.getElementById('continueAfterLeader');
    
    const arr = originalArrayForLeader.map(val => parseFloat(val));
    const leaders = [];
    const leaderIndices = []; // Store both value and index
    let maxFromRight = -Infinity;
    let step = 0;
    let currentIndex = arr.length - 1;
    
    // Initialize table
    leaderTableBody.innerHTML = '';
    for (let i = 0; i < arr.length; i++) {
        leaderTableBody.innerHTML += `
            <tr>
                <td>${arr[i]}</td>
                <td>${i}</td>
                <td>Checking...</td>
                <td>-</td>
            </tr>
        `;
    }
    
    // Function to update leader positions display
    function updateLeaderPositionsDisplay() {
        if (leaders.length === 0) {
            leaderPositionsPlaceholder.style.display = 'block';
            leaderPositionsDisplay.innerHTML = '';
            return;
        }
        
        leaderPositionsPlaceholder.style.display = 'none';
        leaderPositionsDisplay.innerHTML = '';
        
        // Display leaders in the order they were found (from right to left)
        leaders.forEach((leader, index) => {
            const leaderIndex = arr.indexOf(leader);
            const leaderElement = document.createElement('div');
            leaderElement.className = 'array-element mx-2';
            leaderElement.innerHTML = `
                <div class="element-value leader-element" style="animation-delay: ${index * 0.2}s">
                    ${leader}
                </div>
                <div class="element-index">Index: ${leaderIndex}</div>
            `;
            leaderPositionsDisplay.appendChild(leaderElement);
        });
    }
    
    function performLeaderStep() {
        if (currentIndex < 0) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Leader Detection Completed!</strong> Found ${leaders.length} leaders.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Leaders found: [${leaders.reverse().join(', ')}]
                </div>
            `;
            
            // Update final leader positions display
            updateLeaderPositionsDisplay();
            
            // Show final table
            leaderTableContainer.style.display = 'block';
            
            // Highlight all leaders in final display
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            leaders.forEach((leader, index) => {
                const leaderIndex = arr.indexOf(leader);
                setTimeout(() => {
                    transformedElements[leaderIndex].querySelector('.element-value').classList.add('leader-element');
                }, index * 500);
            });
            
            leadersFoundValue.textContent = leaders.length;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterLeader();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterLeader);
            
            return;
        }
        
        step++;
        const currentElement = arr[currentIndex];
        
        explanation.innerHTML = `Step ${step}: Checking element at index ${currentIndex} = ${currentElement}`;
        
        // Highlight current element
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        const currentElementDiv = transformedElements[currentIndex].querySelector('.element-value');
        currentElementDiv.classList.add('leader-candidate');
        
        // Update table
        const tableRows = leaderTableBody.querySelectorAll('tr');
        tableRows[currentIndex].cells[2].textContent = 'Checking...';
        tableRows[currentIndex].cells[3].textContent = `Comparing with maxFromRight (${maxFromRight})`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Checking arr[${currentIndex}] = ${currentElement}, maxFromRight = ${maxFromRight === -Infinity ? '-' : maxFromRight}
            </div>
        `;
        
        setTimeout(() => {
            if (currentElement >= maxFromRight) {
                // Current element is a leader
                leaders.push(currentElement);
                leaderIndices.push({value: currentElement, index: currentIndex});
                maxFromRight = currentElement;
                
                explanation.innerHTML = `Step ${step}: Element ${currentElement} at index ${currentIndex} is a LEADER!`;
                
                currentElementDiv.classList.remove('leader-candidate');
                currentElementDiv.classList.add('leader-element');
                
                // Update table
                tableRows[currentIndex].cells[2].textContent = 'YES';
                tableRows[currentIndex].cells[2].className = 'leader-position';
                tableRows[currentIndex].cells[3].textContent = `Greater than all elements to the right (maxFromRight = ${maxFromRight})`;
                
                // Update leader positions display
                updateLeaderPositionsDisplay();
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Leader Found!</strong> arr[${currentIndex}] = ${currentElement} is a leader. New maxFromRight = ${maxFromRight}
                    </div>
                `;
                
            } else {
                // Current element is not a leader
                explanation.innerHTML = `Step ${step}: Element ${currentElement} at index ${currentIndex} is NOT a leader`;
                
                currentElementDiv.classList.remove('leader-candidate');
                currentElementDiv.classList.add('non-leader');
                
                // Update table
                tableRows[currentIndex].cells[2].textContent = 'NO';
                tableRows[currentIndex].cells[3].textContent = `Not greater than maxFromRight (${maxFromRight})`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Not a Leader:</strong> arr[${currentIndex}] = ${currentElement}  maxFromRight (${maxFromRight})
                    </div>
                `;
            }
            
            leadersFoundValue.textContent = leaders.length;
            
            // Move to next element (from right to left)
            currentIndex--;
            
            // Continue to next step
            setTimeout(performLeaderStep, 2000);
        }, 1500);
    }
    
    // Start from the rightmost element
    performLeaderStep();
}
// NEW: Return to Original after Leader Operation
function returnToOriginalAfterLeader() {
    // Reset to original array
    myArray = [...originalArrayForLeader];
    originalArrayForLeader = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isLeaderOperationRunning = false;
    
    logOperation('Leader detection completed - returned to original array', 'info');
    showNotification('Returned to original array after leader detection', 'success');
}
// NEW: Jump Game Handler
function handleJumpGame() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isJumpGameRunning) {
        showNotification('Jump Game is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseInt(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Jump Game requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForJumpGame = [...myArray];
    
    // Show Jump Game visualization
    showJumpGameVisualization();
}

// NEW: Show Jump Game Visualization
function showJumpGameVisualization() {
    isJumpGameRunning = true;
    
    const jumpGameContainer = document.createElement('div');
    jumpGameContainer.className = 'dual-operation-container';
    jumpGameContainer.innerHTML = `
        <h5 class="text-center mb-3">Jump Game - Can Reach Final Position?</h5>
        
        <div class="array-group">
            <div class="array-label">Jump Array (Maximum jump length at each position)</div>
            <div class="original-array-container" id="jumpGameArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Problem:</strong> Starting at index 0, can you reach the last index?</p>
            <p class="mb-0" id="jumpGameExplanation">Initializing Jump Game analysis...</p>
        </div>
        
        <div class="table-container">
            <table class="jump-game-table" id="jumpGameTable">
                <thead>
                    <tr>
                        <th>Step</th>
                        <th>Current Position</th>
                        <th>Max Reach</th>
                        <th>Can Reach End?</th>
                        <th>Next Possible Positions</th>
                    </tr>
                </thead>
                <tbody id="jumpGameTableBody">
                </tbody>
            </table>
        </div>
        
        <div class="jump-game-result" id="jumpGameResult" style="display: none;">
            <!-- Result will be displayed here -->
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterJumpGame" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(jumpGameContainer);
    
    renderArrayInContainer(originalArrayForJumpGame, 'jumpGameArray');
    
    performJumpGameAnalysis();
}

// NEW: Perform Jump Game Analysis with Animation
function performJumpGameAnalysis() {
    const arrayContainer = document.getElementById('jumpGameArray');
    const explanation = document.getElementById('jumpGameExplanation');
    const tableBody = document.getElementById('jumpGameTableBody');
    const resultDiv = document.getElementById('jumpGameResult');
    const continueButton = document.getElementById('continueAfterJumpGame');
    
    const nums = originalArrayForJumpGame.map(val => parseInt(val));
    const n = nums.length;
    let maxReach = 0;
    let step = 0;
    let canReachEnd = false;
    
    function performJumpStep(i) {
        if (i >= n) {
            // Analysis completed
            const finalResult = maxReach >= n - 1;
            canReachEnd = finalResult;
            
            explanation.innerHTML = `<strong>Jump Game Analysis Completed!</strong>`;
            
            // Add final result to table
            tableBody.innerHTML += `
                <tr>
                    <td>Final</td>
                    <td>-</td>
                    <td>${maxReach}</td>
                    <td class="${finalResult ? 'jump-game-reachable-cell' : 'jump-game-unreachable-cell'}">
                        ${finalResult ? 'YES' : 'NO'}
                    </td>
                    <td>-</td>
                </tr>
            `;
            
            // Show final result
            if (finalResult) {
                resultDiv.innerHTML = `
                    <div class="jump-game-success">
                        <i class="fas fa-check-circle me-2"></i>
                        REACHING FINAL POSITION: <span style="color: var(--success-color);">POSSIBLE</span>
                        <p class="mt-2 mb-0" style="font-size: 0.9rem;">Successfully reached the last index!</p>
                    </div>
                `;
                
                // Highlight the path or show success animation
                const elements = arrayContainer.querySelectorAll('.array-element');
                elements[n - 1].querySelector('.element-value').classList.add('jump-game-possible');
                
            } else {
                resultDiv.innerHTML = `
                    <div class="jump-game-failure">
                        <i class="fas fa-times-circle me-2"></i>
                        REACHING FINAL POSITION: <span style="color: var(--danger-color);">NOT POSSIBLE</span>
                        <p class="mt-2 mb-0" style="font-size: 0.9rem;">Cannot reach the last index from first index</p>
                    </div>
                `;
                
                // Highlight the unreachable state
                const elements = arrayContainer.querySelectorAll('.array-element');
                elements[n - 1].querySelector('.element-value').classList.add('jump-game-unreachable');
            }
            
            resultDiv.style.display = 'block';
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterJumpGame();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterJumpGame);
            
            return;
        }
        
        step++;
        
        // Update explanation
        explanation.innerHTML = `Step ${step}: At position ${i}, max reach = ${maxReach}`;
        
        // Highlight current position
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElement = elements[i].querySelector('.element-value');
        currentElement.classList.add('jump-game-current');
        
        // Calculate next possible positions
        const currentJump = nums[i];
        const nextPositions = [];
        for (let j = 1; j <= currentJump; j++) {
            if (i + j < n) {
                nextPositions.push(i + j);
            }
        }
        
        // Update max reach
        const newMaxReach = Math.max(maxReach, i + nums[i]);
        const maxReachUpdated = newMaxReach > maxReach;
        
        // Add to table
        tableBody.innerHTML += `
            <tr class="${maxReachUpdated ? 'jump-game-current-cell' : ''}">
                <td>${step}</td>
                <td>${i} (jump: ${nums[i]})</td>
                <td>${newMaxReach}</td>
                <td class="${newMaxReach >= n - 1 ? 'jump-game-reachable-cell' : ''}">
                    ${newMaxReach >= n - 1 ? 'YES' : 'NO'}
                </td>
                <td>${nextPositions.length > 0 ? nextPositions.join(', ') : 'None'}</td>
            </tr>
        `;
        
        // Scroll table to bottom
        const tableContainer = tableBody.parentElement.parentElement;
        tableContainer.scrollTop = tableContainer.scrollHeight;
        
        // Highlight reachable positions
        setTimeout(() => {
            for (let j = i + 1; j <= Math.min(i + currentJump, n - 1); j++) {
                elements[j].querySelector('.element-value').classList.add('jump-game-reachable');
            }
            
            setTimeout(() => {
                // Remove current highlight
                currentElement.classList.remove('jump-game-current');
                
                // Update max reach
                maxReach = newMaxReach;
                
                // Move to next position
                if (i < maxReach && i < n - 1) {
                    performJumpStep(i + 1);
                } else {
                    performJumpStep(n); // End analysis
                }
            }, 1500);
        }, 1000);
    }
    
    // Clear table
    tableBody.innerHTML = '';
    
    // Start analysis from position 0
    performJumpStep(0);
}

// NEW: Return to Original after Jump Game
function returnToOriginalAfterJumpGame() {
    // Reset to original array
    myArray = [...originalArrayForJumpGame];
    originalArrayForJumpGame = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isJumpGameRunning = false;
    
    logOperation('Jump Game analysis completed - returned to original array', 'info');
    showNotification('Returned to original array after Jump Game analysis', 'success');
}
// NEW: Best Time to Buy and Sell Stock Handler
function handleBestTimeStock() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isStockOperationRunning) {
        showNotification('Stock operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains valid numbers (stock prices)
    let allValidNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        const num = parseFloat(myArray[i]);
        if (isNaN(num) || num < 0) {
            allValidNumbers = false;
            break;
        }
    }
    
    if (!allValidNumbers) {
        showNotification('Stock prices must be valid positive numbers', 'danger');
        return;
    }
    
    if (myArray.length < 2) {
        showNotification('Need at least 2 days of stock prices', 'warning');
        return;
    }
    
    isStockOperationRunning = true;
    
    // Store original array
    originalArrayForStock = [...myArray];
    
    // Show stock problem visualization
    showStockProblemVisualization();
}
// NEW: Show Stock Problem Visualization
function showStockProblemVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Best Time to Buy and Sell Stock</h5>
        
        <!-- Results at the TOP -->
        <div class="row mb-4" id="stockResultsTop" style="display: none;">
            <div class="col-md-4">
                <div class="stats-card">
                    <div><i class="fas fa-shopping-cart me-2"></i>Buy Day</div>
                    <div class="stats-value" id="buyDayValueTop">-</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="stats-card">
                    <div><i class="fas fa-cash-register me-2"></i>Sell Day</div>
                    <div class="stats-value" id="sellDayValueTop">-</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="stats-card">
                    <div><i class="fas fa-chart-line me-2"></i>Maximum Profit</div>
                    <div class="stats-value text-success" id="maxProfitValueTop">0</div>
                </div>
            </div>
        </div>
        
        <div class="profit-highlight text-center mb-4" id="profitSummaryTop" style="display: none;">
            <h4 class="mb-1">Maximum Profit: <span class="text-success" id="profitAmountTop">0</span></h4>
            <p class="mb-0">Buy on Day <span id="buyDaySummary">-</span>, Sell on Day <span id="sellDaySummary">-</span></p>
        </div>
        
        <div class="array-group">
            <div class="array-label">Stock Prices (Day 0 to ${myArray.length-1})</div>
            <div class="original-array-container" id="stockPricesArray"></div>
        </div>
        
        <div class="stock-explanation">
            <p class="mb-2"><strong>Problem:</strong> Find the maximum profit from buying and selling stocks</p>
            <p class="mb-0" id="stockExplanation">Initializing stock analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="stockStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="stockSteps"></div>
        </div>
        
        <!-- Original stats cards (kept for reference but will be hidden when top results show) -->
        <div class="row mt-3" id="originalStatsCards">
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Buy Day</div>
                    <div class="stats-value" id="buyDayValue">-</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Sell Day</div>
                    <div class="stats-value" id="sellDayValue">-</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Maximum Profit</div>
                    <div class="stats-value" id="maxProfitValue">0</div>
                </div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterStock" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForStock, 'stockPricesArray');
    
    performStockAlgorithmAnimation();
}
// NEW: Perform Stock Algorithm Animation
function performStockAlgorithmAnimation() {
    const arrayContainer = document.getElementById('stockPricesArray');
    const explanation = document.getElementById('stockExplanation');
    const stepsContainer = document.getElementById('stockSteps');
    
    // Original stats cards
    const buyDayValue = document.getElementById('buyDayValue');
    const sellDayValue = document.getElementById('sellDayValue');
    const maxProfitValue = document.getElementById('maxProfitValue');
    
    // Top position elements
    const stockResultsTop = document.getElementById('stockResultsTop');
    const buyDayValueTop = document.getElementById('buyDayValueTop');
    const sellDayValueTop = document.getElementById('sellDayValueTop');
    const maxProfitValueTop = document.getElementById('maxProfitValueTop');
    const profitSummaryTop = document.getElementById('profitSummaryTop');
    const profitAmountTop = document.getElementById('profitAmountTop');
    const buyDaySummary = document.getElementById('buyDaySummary');
    const sellDaySummary = document.getElementById('sellDaySummary');
    
    const continueButton = document.getElementById('continueAfterStock');
    
    const prices = originalArrayForStock.map(val => parseFloat(val));
    let minPrice = Infinity;
    let maxProfit = 0;
    let buyDay = 0;
    let sellDay = 0;
    let currentMinDay = 0;
    let step = 0;
    
    function performStockStep(day) {
        if (day >= prices.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Maximum profit calculated.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Buy on day ${buyDay} (price ${prices[buyDay]}), Sell on day ${sellDay} (price ${prices[sellDay]})
                </div>
                <div class="algorithm-step active">
                    <strong>Profit:</strong> ${prices[sellDay]} - ${prices[buyDay]} = ${maxProfit}
                </div>
            `;
            
            // Show top results
            setTimeout(() => {
                stockResultsTop.style.display = 'flex';
                profitSummaryTop.style.display = 'block';
                
                // Update top position values
                buyDayValueTop.textContent = `Day ${buyDay} (Price: ${prices[buyDay]})`;
                sellDayValueTop.textContent = `Day ${sellDay} (Price: ${prices[sellDay]})`;
                maxProfitValueTop.textContent = maxProfit;
                
                profitAmountTop.textContent = maxProfit;
                buyDaySummary.textContent = buyDay;
                sellDaySummary.textContent = sellDay;
                
                // Update original stats cards as well
                buyDayValue.textContent = `Day ${buyDay} (Price: ${prices[buyDay]})`;
                sellDayValue.textContent = `Day ${sellDay} (Price: ${prices[sellDay]})`;
                maxProfitValue.textContent = maxProfit;
            }, 500);
            
            // Highlight final buy and sell days
            const elements = arrayContainer.querySelectorAll('.array-element');
            
            // Highlight buy day
            setTimeout(() => {
                elements[buyDay].querySelector('.element-value').classList.add('buy-day');
            }, 1000);
            
            // Highlight sell day
            setTimeout(() => {
                elements[sellDay].querySelector('.element-value').classList.add('sell-day');
            }, 1500);
            
            continueButton.style.display = 'block';
            
            // Auto-return after 8 seconds
            setTimeout(() => {
                returnToOriginalAfterStock();
            }, 8000);
            
            continueButton.addEventListener('click', returnToOriginalAfterStock);
            
            return;
        }
        
        step++;
        const currentPrice = prices[day];
        
        // Update explanation
        explanation.innerHTML = `Day ${day}: Current price = ${currentPrice}`;
        
        // Highlight current day
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElement = elements[day].querySelector('.element-value');
        currentElement.classList.add('profit-calculation');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Day ${day}, Price = ${currentPrice}
            </div>
        `;
        
        setTimeout(() => {
            // Check if this is a new minimum price
            if (currentPrice < minPrice) {
                minPrice = currentPrice;
                currentMinDay = day;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>New Minimum:</strong> Day ${day} is new lowest price (${currentPrice})
                    </div>
                `;
                
                // Highlight as new minimum
                currentElement.classList.remove('profit-calculation');
                currentElement.classList.add('current-min');
                
                // Remove previous minimum highlight if any
                if (day > 0) {
                    elements[currentMinDay - 1]?.querySelector('.element-value')?.classList.remove('current-min');
                }
                
            } else {
                // Calculate potential profit
                const potentialProfit = currentPrice - minPrice;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Profit Check:</strong> Current price ${currentPrice} - Min price ${minPrice} = ${potentialProfit}
                    </div>
                `;
                
                if (potentialProfit > maxProfit) {
                    maxProfit = potentialProfit;
                    buyDay = currentMinDay;
                    sellDay = day;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>New Maximum Profit!</strong> ${potentialProfit} (Buy: Day ${buyDay}, Sell: Day ${day})
                        </div>
                    `;
                    
                    // Update display values in real-time (both top and original)
                    buyDayValue.textContent = `Day ${buyDay} (Price: ${prices[buyDay]})`;
                    sellDayValue.textContent = `Day ${day} (Price: ${currentPrice})`;
                    maxProfitValue.textContent = maxProfit;
                    
                    // Update top values if they're visible
                    if (stockResultsTop.style.display === 'flex') {
                        buyDayValueTop.textContent = `Day ${buyDay} (Price: ${prices[buyDay]})`;
                        sellDayValueTop.textContent = `Day ${day} (Price: ${currentPrice})`;
                        maxProfitValueTop.textContent = maxProfit;
                        profitAmountTop.textContent = maxProfit;
                        buyDaySummary.textContent = buyDay;
                        sellDaySummary.textContent = day;
                    }
                    
                    // Highlight buy and sell days temporarily
                    if (buyDay !== day) {
                        elements[buyDay].querySelector('.element-value').classList.add('buy-day');
                        currentElement.classList.add('sell-day');
                        
                        // Remove temporary highlights after delay
                        setTimeout(() => {
                            elements[buyDay].querySelector('.element-value').classList.remove('buy-day');
                            currentElement.classList.remove('sell-day');
                        }, 1000);
                    }
                }
                
                currentElement.classList.remove('profit-calculation');
            }
            
            // Scroll to bottom of steps
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            // Move to next day
            performStockStep(day + 1);
        }, 2000);
    }
    
    // Start algorithm execution
    performStockStep(0);
}

// NEW: Return to Original after Stock Operation
function returnToOriginalAfterStock() {
    // Reset to original array
    myArray = [...originalArrayForStock];
    originalArrayForStock = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isStockOperationRunning = false;
    
    logOperation('Best Time to Buy/Sell Stock analysis completed', 'info');
    showNotification('Returned to original array after stock analysis', 'success');
}
// NEW: Find Subarray with Sum Closest to Zero Handler
function handleFindSubarrayNearZero() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isNearZeroRunning) {
        showNotification('Near zero subarray search is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('This operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isNearZeroRunning = true;
    
    // Store original array
    originalArrayForNearZero = [...myArray];
    
    // Show near zero subarray visualization
    showNearZeroSubarrayVisualization();
}

// NEW: Show Near Zero Subarray Visualization
function showNearZeroSubarrayVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find Subarray with Sum Closest to Zero</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalNearZeroArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Subarray Search Process</div>
            <div class="transformed-array-container" id="transformedNearZeroArray"></div>
        </div>

        <!-- Subarrays Results Section - Moved between process and algorithm steps -->
        <div class="near-zero-results mt-3" id="nearZeroResults">
            <h6 class="text-center">Subarrays with Sum Near Zero</h6>
            <div class="row">
                <div class="col-md-6">
                    <div class="stats-card">
                        <div>Total Subarrays Found</div>
                        <div class="stats-value" id="nearZeroCount">0</div>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="stats-card">
                        <div>Best Subarray (Closest to Zero)</div>
                        <div class="stats-value" id="bestSubarrayInfo">-</div>
                    </div>
                </div>
            </div>
            <div class="mt-3">
                <h6 class="text-center mb-3">All Subarrays Found:</h6>
                <div id="nearZeroSubarraysList" class="text-center" style="max-height: 200px; overflow-y: auto; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 10px;"></div>
            </div>
        </div>
        
        <div class="algorithm-explanation mt-3">
            <p class="mb-2"><strong>Algorithm:</strong> Find contiguous subarray with sum closest to zero</p>
            <p class="mb-0" id="nearZeroExplanation">Initializing subarray search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="nearZeroStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="nearZeroSteps" style="max-height: 300px; overflow-y: auto;"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterNearZero" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForNearZero, 'originalNearZeroArray');
    renderArrayInContainer([...originalArrayForNearZero], 'transformedNearZeroArray');
    
    performNearZeroSubarraySearch();
}

// NEW: Perform Near Zero Subarray Search with Animation
function performNearZeroSubarraySearch() {
    const originalContainer = document.getElementById('originalNearZeroArray');
    const transformedContainer = document.getElementById('transformedNearZeroArray');
    const explanation = document.getElementById('nearZeroExplanation');
    const stepsContainer = document.getElementById('nearZeroSteps');
    const resultsContainer = document.getElementById('nearZeroResults');
    const nearZeroCount = document.getElementById('nearZeroCount');
    const bestSubarrayInfo = document.getElementById('bestSubarrayInfo');
    const nearZeroSubarraysList = document.getElementById('nearZeroSubarraysList');
    const continueButton = document.getElementById('continueAfterNearZero');
    
    const arr = originalArrayForNearZero.map(val => parseFloat(val));
    const n = arr.length;
    let prefixSum = [];
    let cumulativeSum = 0;
    let step = 0;
    let subarrays = [];
    let bestSubarray = null;
    let minDiff = Infinity;
    
    // Initialize results display
    nearZeroCount.textContent = '0';
    bestSubarrayInfo.textContent = 'Searching...';
    nearZeroSubarraysList.innerHTML = '<div class="text-muted">No subarrays found yet...</div>';
    
    // Calculate prefix sums
    explanation.innerHTML = 'Step 1: Calculating prefix sums...';
    stepsContainer.innerHTML = `
        <div class="algorithm-step active">
            <strong>Step 1:</strong> Calculate prefix sums for efficient subarray sum calculation
        </div>
    `;
    
    function performSearchStep() {
        if (step === 0) {
            // Calculate prefix sums with animation
            prefixSum = [{ sum: 0, index: -1 }];
            cumulativeSum = 0;
            
            function calculatePrefixStep(i) {
                if (i >= n) {
                    step++;
                    performSearchStep();
                    return;
                }
                
                cumulativeSum += arr[i];
                prefixSum.push({ sum: cumulativeSum, index: i });
                
                explanation.innerHTML = `Step 1: Calculating prefix sum up to index ${i} = ${cumulativeSum.toFixed(2)}`;
                
                // Highlight current element
                const elements = transformedContainer.querySelectorAll('.array-element');
                const currentElement = elements[i].querySelector('.element-value');
                currentElement.classList.add('prefix-highlight');
                
                setTimeout(() => {
                    currentElement.classList.remove('prefix-highlight');
                    calculatePrefixStep(i + 1);
                }, 800);
            }
            
            calculatePrefixStep(0);
            
        } else if (step === 1) {
            // Sort prefix sums to find closest pairs
            explanation.innerHTML = 'Step 2: Sorting prefix sums to find closest pairs...';
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 2:</strong> Sort prefix sums array to find pairs with minimum difference
                </div>
            `;
            
            // Sort prefix sums
            prefixSum.sort((a, b) => a.sum - b.sum);
            
            setTimeout(() => {
                step++;
                performSearchStep();
            }, 1500);
            
        } else if (step === 2) {
            // Find closest pairs and corresponding subarrays
            explanation.innerHTML = 'Step 3: Finding subarrays with sums closest to zero...';
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 3:</strong> Iterate through sorted prefix sums to find minimum differences
                </div>
            `;
            
            let pairIndex = 0;
            let foundSubarraysCount = 0;
            
            function findClosestPairs(i) {
                if (i >= prefixSum.length - 1) {
                    step++;
                    performSearchStep();
                    return;
                }
                
                const diff = Math.abs(prefixSum[i + 1].sum - prefixSum[i].sum);
                const startIdx = Math.min(prefixSum[i].index, prefixSum[i + 1].index) + 1;
                const endIdx = Math.max(prefixSum[i].index, prefixSum[i + 1].index);
                
                if (startIdx <= endIdx) {
                    const subarray = arr.slice(startIdx, endIdx + 1);
                    const subarraySum = subarray.reduce((a, b) => a + b, 0);
                    
                    subarrays.push({
                        start: startIdx,
                        end: endIdx,
                        sum: subarraySum,
                        diff: Math.abs(subarraySum),
                        elements: subarray
                    });
                    
                    foundSubarraysCount++;
                    
                    // Update best subarray if this is closer to zero
                    if (Math.abs(subarraySum) < minDiff) {
                        minDiff = Math.abs(subarraySum);
                        bestSubarray = { 
                            start: startIdx, 
                            end: endIdx, 
                            sum: subarraySum,
                            elements: subarray
                        };
                    }
                    
                    // Update results display in real-time
                    nearZeroCount.textContent = foundSubarraysCount;
                    
                    // Update best subarray info
                    if (bestSubarray) {
                        bestSubarrayInfo.textContent = `[${bestSubarray.start}-${bestSubarray.end}] = ${bestSubarray.sum.toFixed(2)}`;
                    }
                    
                    // Update subarrays list
                    updateSubarraysList();
                    
                    explanation.innerHTML = `Step 3: Found subarray [${startIdx}-${endIdx}] with sum = ${subarraySum.toFixed(2)}`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step ${Math.abs(subarraySum) === minDiff ? 'active' : ''}">
                            <strong>Pair ${i + 1}:</strong> Subarray [${startIdx}-${endIdx}] = [${subarray.join(', ')}], Sum = ${subarraySum.toFixed(2)}
                        </div>
                    `;
                    
                    // Highlight the subarray
                    const elements = transformedContainer.querySelectorAll('.array-element');
                    for (let j = startIdx; j <= endIdx; j++) {
                        setTimeout(() => {
                            elements[j].querySelector('.element-value').classList.add('subarray-candidate');
                        }, (j - startIdx) * 200);
                    }
                    
                    // Scroll steps container
                    stepsContainer.scrollTop = stepsContainer.scrollHeight;
                }
                
                pairIndex++;
                setTimeout(() => findClosestPairs(i + 1), 1000);
            }
            
            // Function to update the subarrays list display
            function updateSubarraysList() {
                nearZeroSubarraysList.innerHTML = '';
                
                // Display all found subarrays
                subarrays.forEach((sub, index) => {
                    const subarrayItem = document.createElement('div');
                    subarrayItem.className = `near-zero-item ${sub.diff === minDiff ? 'near-zero-best' : ''}`;
                    subarrayItem.style.margin = '5px';
                    subarrayItem.style.padding = '8px 12px';
                    subarrayItem.style.borderRadius = '5px';
                    subarrayItem.style.display = 'inline-block';
                    subarrayItem.style.fontSize = '0.9rem';
                    
                    subarrayItem.innerHTML = `
                        <strong>[${sub.start}-${sub.end}]</strong>: [${sub.elements.join(', ')}] = <strong>${sub.sum.toFixed(2)}</strong>
                    `;
                    
                    nearZeroSubarraysList.appendChild(subarrayItem);
                    
                    // Add space between items
                    if (index < subarrays.length - 1) {
                        nearZeroSubarraysList.appendChild(document.createTextNode(' '));
                    }
                });
                
                // Scroll to bottom of subarrays list
                nearZeroSubarraysList.scrollTop = nearZeroSubarraysList.scrollHeight;
            }
            
            findClosestPairs(0);
            
        } else {
            // Algorithm completed
            explanation.innerHTML = `<strong>Search Completed!</strong> Found ${subarrays.length} subarrays with sums near zero.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Best subarray found with sum closest to zero = ${bestSubarray.sum.toFixed(2)}
                </div>
                <div class="algorithm-step active">
                    <strong>Total Subarrays:</strong> ${subarrays.length} subarrays analyzed
                </div>
            `;
            
            // Final update of results
            nearZeroCount.textContent = subarrays.length;
            bestSubarrayInfo.textContent = `[${bestSubarray.start}-${bestSubarray.end}] = ${bestSubarray.sum.toFixed(2)}`;
            
            // Highlight the best subarray in the array
            const elements = transformedContainer.querySelectorAll('.array-element');
            for (let j = bestSubarray.start; j <= bestSubarray.end; j++) {
                setTimeout(() => {
                    elements[j].querySelector('.element-value').classList.add('subarray-near-zero');
                }, (j - bestSubarray.start) * 200);
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterNearZero();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterNearZero);
        }
    }
    
    // Start the search process
    performSearchStep();
}

// NEW: Return to Original after Near Zero Search
function returnToOriginalAfterNearZero() {
    // Reset to original array
    myArray = [...originalArrayForNearZero];
    originalArrayForNearZero = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isNearZeroRunning = false;
    
    logOperation('Near zero subarray search completed - returned to original array', 'info');
    showNotification('Returned to original array after near zero subarray search', 'success');
}
// NEW: Minimum Window Substring Handler
function handleMinWindowSubstring() {
    if (isMinWindowRunning) {
        showNotification('Minimum window operation is already in progress', 'warning');
        return;
    }

    // Show input group
    minWindowGroup.style.display = 'block';
    mainStringInput.focus();
    
    // Clear previous inputs
    mainStringInput.value = '';
    targetStringInput.value = '';
    
    logOperation('Started minimum window substring operation', 'info');
}

// NEW: Perform Minimum Window Handler
function handlePerformMinWindow() {
    mainString = mainStringInput.value.trim();
    targetString = targetStringInput.value.trim();
    
    if (mainString === '') {
        showNotification('Please enter the main string', 'danger');
        mainStringInput.focus();
        return;
    }
    
    if (targetString === '') {
        showNotification('Please enter the target string', 'danger');
        targetStringInput.focus();
        return;
    }
    
    if (targetString.length > mainString.length) {
        showNotification('Target string cannot be longer than main string', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForMinWindow = [...myArray];
    
    // Hide input group
    minWindowGroup.style.display = 'none';
    
    // Start minimum window visualization
    showMinWindowVisualization();
}

// NEW: Cancel Minimum Window Handler
function handleCancelMinWindow() {
    minWindowGroup.style.display = 'none';
    mainStringInput.value = '';
    targetStringInput.value = '';
    
    mainString = "";
    targetString = "";
    
    logOperation('Cancelled minimum window operation', 'info');
    showNotification('Minimum window operation cancelled', 'info');
}

// NEW: Show Minimum Window Visualization
function showMinWindowVisualization() {
    isMinWindowRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Minimum Window Substring Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Main String: "${mainString}"</div>
            <div class="char-array-container" id="mainStringArray"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Target String: "${targetString}"</div>
            <div class="char-array-container" id="targetStringArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Sliding Window Process</div>
            <div class="char-array-container" id="windowProcessArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find minimum window in main string that contains all characters of target string</p>
            <p class="mb-0" id="minWindowExplanation">Initializing sliding window algorithm...</p>
        </div>
        
        <div class="frequency-display" id="frequencyDisplay">
            <h6>Character Frequency Requirements</h6>
            <div id="frequencyContent"></div>
        </div>
        
        <div class="algorithm-steps mt-3" id="minWindowStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="minWindowSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Minimum Window Found</div>
            <div class="stats-value" id="minWindowResult">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMinWindow" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display the strings as character arrays
    renderCharArray(mainString.split(''), 'mainStringArray');
    renderCharArray(targetString.split(''), 'targetStringArray');
    renderCharArray(mainString.split(''), 'windowProcessArray');
    
    // Start the algorithm animation
    performMinWindowAlgorithm();
}

// NEW: Render Character Array
function renderCharArray(charArray, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    charArray.forEach((char, index) => {
        const charElement = document.createElement('div');
        charElement.className = 'char-element';
        charElement.innerHTML = `
            <div class="char-value">${char}</div>
            <div class="char-index">${index}</div>
        `;
        container.appendChild(charElement);
    });
}

// NEW: Perform Minimum Window Algorithm with Animation
function performMinWindowAlgorithm() {
    const mainArrayContainer = document.getElementById('mainStringArray');
    const targetArrayContainer = document.getElementById('targetStringArray');
    const windowContainer = document.getElementById('windowProcessArray');
    const explanation = document.getElementById('minWindowExplanation');
    const stepsContainer = document.getElementById('minWindowSteps');
    const frequencyContent = document.getElementById('frequencyContent');
    const minWindowResult = document.getElementById('minWindowResult');
    const continueButton = document.getElementById('continueAfterMinWindow');
    
    const s = mainString;
    const t = targetString;
    let minWindow = "";
    let step = 0;
    
    // Calculate frequency requirements for target string
    const targetFreq = {};
    for (let char of t) {
        targetFreq[char] = (targetFreq[char] || 0) + 1;
    }
    
    // Display frequency requirements
    frequencyContent.innerHTML = '';
    for (let char in targetFreq) {
        const freqItem = document.createElement('span');
        freqItem.className = 'frequency-item';
        freqItem.textContent = `${char}: ${targetFreq[char]}`;
        frequencyContent.appendChild(freqItem);
    }
    
    let requiredChars = Object.keys(targetFreq).length;
    let left = 0, right = 0;
    let formed = 0;
    const windowFreq = {};
    let result = [0, s.length + 1]; // [start, end]
    
    function performAlgorithmStep() {
        if (right > s.length) {
            // Algorithm completed
            if (result[1] > s.length) {
                explanation.innerHTML = `<strong>Algorithm Completed!</strong> No window found containing all characters.`;
                minWindowResult.textContent = "No solution found";
            } else {
                minWindow = s.substring(result[0], result[1] + 1);
                explanation.innerHTML = `<strong>Algorithm Completed!</strong> Minimum window found: "${minWindow}"`;
                minWindowResult.textContent = `"${minWindow}" (indices ${result[0]}-${result[1]})`;
                
                // Highlight the minimum window
                const windowElements = windowContainer.querySelectorAll('.char-element');
                for (let i = result[0]; i <= result[1]; i++) {
                    setTimeout(() => {
                        windowElements[i].querySelector('.char-value').classList.add('window-minimum');
                    }, (i - result[0]) * 200);
                }
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> ${minWindow ? `Minimum window: "${minWindow}"` : 'No solution found'}
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterMinWindow();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterMinWindow);
            
            return;
        }
        
        step++;
        
        if (formed < requiredChars) {
            // Expand window to the right
            if (right < s.length) {
                const char = s[right];
                explanation.innerHTML = `Step ${step}: Expanding window - adding character '${char}' at position ${right}`;
                
                // Highlight current right pointer
                const windowElements = windowContainer.querySelectorAll('.char-element');
                if (right < windowElements.length) {
                    windowElements[right].querySelector('.char-value').classList.add('window-current');
                }
                
                // Update window frequency
                windowFreq[char] = (windowFreq[char] || 0) + 1;
                
                // Check if this character satisfies requirement
                if (targetFreq[char] && windowFreq[char] === targetFreq[char]) {
                    formed++;
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step}:</strong> Added '${char}' - Now have required count of '${char}' (${windowFreq[char]})
                        </div>
                    `;
                    
                    // Highlight as satisfied
                    if (right < windowElements.length) {
                        windowElements[right].querySelector('.char-value').classList.add('window-satisfied');
                    }
                } else {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step}:</strong> Added '${char}' - Current count: ${windowFreq[char]}, Required: ${targetFreq[char] || 0}
                        </div>
                    `;
                    
                    // Highlight as included
                    if (right < windowElements.length) {
                        windowElements[right].querySelector('.char-value').classList.add('window-included');
                    }
                }
                
                setTimeout(() => {
                    // Remove temporary highlight
                    if (right < windowElements.length) {
                        windowElements[right].querySelector('.char-value').classList.remove('window-current');
                    }
                    
                    right++;
                    performAlgorithmStep();
                }, 1500);
            } else {
                right++;
                performAlgorithmStep();
            }
        } else {
            // Contract window from left
            const char = s[left];
            explanation.innerHTML = `Step ${step}: Contracting window - removing character '${char}' from position ${left}`;
            
            // Highlight current left pointer
            const windowElements = windowContainer.querySelectorAll('.char-element');
            if (left < windowElements.length) {
                windowElements[left].querySelector('.char-value').classList.add('window-current');
            }
            
            // Update result if current window is smaller
            if (right - left < result[1] - result[0] + 1) {
                result[0] = left;
                result[1] = right - 1;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> New minimum window found: indices ${left}-${right-1}
                    </div>
                `;
            } else {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step}:</strong> Removing '${char}' from left, current window: ${left}-${right-1}
                    </div>
                `;
            }
            
            // Update window frequency
            windowFreq[char]--;
            if (targetFreq[char] && windowFreq[char] < targetFreq[char]) {
                formed--;
            }
            
            setTimeout(() => {
                // Remove temporary highlight
                if (left < windowElements.length) {
                    windowElements[left].querySelector('.char-value').classList.remove('window-current', 'window-included', 'window-satisfied');
                }
                
                left++;
                performAlgorithmStep();
            }, 1500);
        }
    }
    
    // Start algorithm execution
    performAlgorithmStep();
}

// NEW: Return to Original after Minimum Window
function returnToOriginalAfterMinWindow() {
    // Reset to original array
    myArray = [...originalArrayForMinWindow];
    originalArrayForMinWindow = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMinWindowRunning = false;
    
    // Clear inputs
    mainStringInput.value = '';
    targetStringInput.value = '';
    mainString = "";
    targetString = "";
    
    logOperation('Minimum window operation completed - returned to original array', 'info');
    showNotification('Returned to original array after minimum window operation', 'success');
}
// NEW: K Consecutive Elements Handler
function handleKConsecutive(operation) {
    const k = parseInt(kConsecutiveSize.value);
    
    if (isNaN(k) || k < 1 || k > myArray.length) {
        showNotification(`Please enter a valid k value between 1 and ${myArray.length}`, 'danger');
        kConsecutiveSize.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('K consecutive sum operations require all array elements to be numbers', 'danger');
        return;
    }
    
    if (isKConsecutiveRunning) {
        showNotification('A k consecutive operation is already in progress', 'warning');
        return;
    }
    
    isKConsecutiveRunning = true;
    
    // Store original array
    originalArrayForKConsecutive = [...myArray];
    
    // Perform k consecutive visualization
    performKConsecutiveVisualization(k, operation);
}

// NEW: Perform K Consecutive Visualization
function performKConsecutiveVisualization(k, operation) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">${operation === 'max' ? 'Maximum' : 'Minimum'} Sum of ${k} Consecutive Elements</h5>
        
        <div class="array-group">
            <div class="array-label">Array</div>
            <div class="original-array-container" id="kConsecutiveArray"></div>
        </div>
        
        <div class="k-consecutive-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find ${operation === 'max' ? 'maximum' : 'minimum'} sum of any ${k} consecutive elements</p>
            <p class="mb-0" id="kConsecutiveExplanation">Initializing algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="kConsecutiveStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="kConsecutiveSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>${operation === 'max' ? 'Maximum' : 'Minimum'} Sum Found</div>
            <div class="stats-value" id="kConsecutiveSumValue">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Subarray Indices</div>
            <div class="stats-value" id="kConsecutiveIndices">-</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Subarray Elements</div>
            <div class="stats-value" id="kConsecutiveElements">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterKConsecutive" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForKConsecutive, 'kConsecutiveArray');
    
    executeKConsecutiveAlgorithm(k, operation);
}

// NEW: Execute K Consecutive Algorithm with Animation
function executeKConsecutiveAlgorithm(k, operation) {
    const arrayContainer = document.getElementById('kConsecutiveArray');
    const explanation = document.getElementById('kConsecutiveExplanation');
    const stepsContainer = document.getElementById('kConsecutiveSteps');
    const sumValue = document.getElementById('kConsecutiveSumValue');
    const indicesValue = document.getElementById('kConsecutiveIndices');
    const elementsValue = document.getElementById('kConsecutiveElements');
    const continueButton = document.getElementById('continueAfterKConsecutive');
    
    const arr = originalArrayForKConsecutive.map(val => parseFloat(val));
    let bestSum = operation === 'max' ? -Infinity : Infinity;
    let bestStart = 0;
    let bestEnd = k - 1;
    let currentSum = 0;
    let step = 0;
    
    function executeStep(start) {
        if (start > arr.length - k) {
            // Algorithm completed
            const bestSubarray = arr.slice(bestStart, bestEnd + 1);
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> ${operation === 'max' ? 'Maximum' : 'Minimum'} sum = ${bestSum}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> ${operation === 'max' ? 'Maximum' : 'Minimum'} sum of ${k} consecutive elements = ${bestSum} at indices [${bestStart}-${bestEnd}]
                </div>
            `;
            
            // Highlight the best subarray
            const elements = arrayContainer.querySelectorAll('.array-element');
            for (let j = bestStart; j <= bestEnd; j++) {
                setTimeout(() => {
                    const valueDiv = elements[j].querySelector('.element-value');
                    valueDiv.classList.add(operation === 'max' ? 'k-consecutive-max' : 'k-consecutive-min');
                }, (j - bestStart) * 200);
            }
            
            sumValue.textContent = bestSum;
            indicesValue.textContent = `${bestStart} to ${bestEnd}`;
            elementsValue.textContent = `[${bestSubarray.join(', ')}]`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterKConsecutive();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterKConsecutive);
            
            return;
        }
        
        const end = start + k - 1;
        step++;
        
        if (start === 0) {
            // First window - calculate initial sum
            explanation.innerHTML = `Calculating sum of first window (indices ${start} to ${end})`;
            
            // Highlight the first window
            const elements = arrayContainer.querySelectorAll('.array-element');
            for (let i = start; i <= end; i++) {
                setTimeout(() => {
                    elements[i].querySelector('.element-value').classList.add('k-consecutive-included');
                }, (i - start) * 200);
            }
            
            setTimeout(() => {
                for (let i = start; i <= end; i++) {
                    currentSum += arr[i];
                }
                bestSum = currentSum;
                bestStart = start;
                bestEnd = end;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> First window sum = ${currentSum} (indices ${start}-${end})
                    </div>
                `;
                
                sumValue.textContent = bestSum;
                indicesValue.textContent = `${bestStart} to ${bestEnd}`;
                elementsValue.textContent = `[${arr.slice(bestStart, bestEnd + 1).join(', ')}]`;
                
                executeStep(start + 1);
            }, k * 200 + 500);
            
        } else {
            // Slide the window
            explanation.innerHTML = `Sliding window: Removing [${start-1}]=${arr[start-1]}, Adding [${end}]=${arr[end]}`;
            
            const elements = arrayContainer.querySelectorAll('.array-element');
            
            // Remove left element highlight
            const leftElement = elements[start - 1].querySelector('.element-value');
            leftElement.classList.remove('k-consecutive-included');
            leftElement.classList.add('k-consecutive-current');
            
            // Add right element highlight
            const rightElement = elements[end].querySelector('.element-value');
            rightElement.classList.add('k-consecutive-current');
            
            setTimeout(() => {
                // Update sum
                currentSum += arr[end] - arr[start - 1];
                
                // Remove temporary highlights and update window
                leftElement.classList.remove('k-consecutive-current');
                rightElement.classList.remove('k-consecutive-current');
                rightElement.classList.add('k-consecutive-included');
                
                // Update all window elements
                for (let j = start; j <= end; j++) {
                    elements[j].querySelector('.element-value').classList.add('k-consecutive-included');
                }
                
                // Check if this is new best
                const isNewBest = operation === 'max' ? currentSum > bestSum : currentSum < bestSum;
                
                if (isNewBest) {
                    bestSum = currentSum;
                    bestStart = start;
                    bestEnd = end;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step}:</strong> New ${operation === 'max' ? 'maximum' : 'minimum'} sum = ${bestSum} (indices ${start}-${end})
                        </div>
                    `;
                } else {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step}:</strong> Current sum = ${currentSum}, ${operation === 'max' ? 'Maximum' : 'Minimum'} sum = ${bestSum}
                        </div>
                    `;
                }
                
                sumValue.textContent = bestSum;
                indicesValue.textContent = `${bestStart} to ${bestEnd}`;
                elementsValue.textContent = `[${arr.slice(bestStart, bestEnd + 1).join(', ')}]`;
                
                executeStep(start + 1);
            }, 1000);
        }
    }
    
    // Start execution
    executeStep(0);
}

// NEW: Return to Original after K Consecutive Operations
function returnToOriginalAfterKConsecutive() {
    // Reset to original array
    myArray = [...originalArrayForKConsecutive];
    originalArrayForKConsecutive = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isKConsecutiveRunning = false;
    
    // Clear input
    kConsecutiveSize.value = '';
    
    logOperation('K consecutive sum operation completed - returned to original array', 'info');
    showNotification('Returned to original array after k consecutive sum operation', 'success');
}
// NEW: Rearrange Array (Min, Max) Alternately Handler
function handleRearrangeMinMax() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isRearrangeMinMaxRunning) {
        showNotification('A rearrange operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Rearrange operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isRearrangeMinMaxRunning = true;
    
    // Store original array
    originalArrayForMinMax = [...myArray];
    
    // Show rearrange visualization
    showRearrangeMinMaxVisualization();
}
// NEW: Show Rearrange MinMax Visualization
function showRearrangeMinMaxVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Rearrange Array Alternately (Max, Min, 2nd Max, 2nd Min, ...)</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array ${isCurrentlySorted ? '(Already Sorted)' : '(Will Be Sorted First)'}</div>
            <div class="original-array-container" id="originalMinMaxArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-random"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Rearranged Array</div>
            <div class="transformed-array-container" id="transformedMinMaxArray"></div>
        </div>
        
        <div class="rearrange-minmax-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Rearrange sorted array as: max, min, 2nd max, 2nd min, ...</p>
            <p class="mb-0" id="minMaxExplanation">Starting rearrangement process...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="minMaxStepsContainer">
            <h6 class="text-center">Rearrangement Steps</h6>
            <div class="steps-container" id="minMaxSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMinMax" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForMinMax, 'originalMinMaxArray');
    renderArrayInContainer([...originalArrayForMinMax], 'transformedMinMaxArray');
    
    performRearrangeMinMaxAnimation();
}
// NEW: Perform Rearrange MinMax Animation
function performRearrangeMinMaxAnimation() {
    const originalContainer = document.getElementById('originalMinMaxArray');
    const transformedContainer = document.getElementById('transformedMinMaxArray');
    const explanation = document.getElementById('minMaxExplanation');
    const stepsContainer = document.getElementById('minMaxSteps');
    const continueButton = document.getElementById('continueAfterMinMax');
    
    let array = [...originalArrayForMinMax].map(val => parseFloat(val));
    const n = array.length;
    let step = 0;
    
    // First, sort the array if needed
    function sortArrayIfNeeded() {
        // Check if array is already sorted
        let isSorted = true;
        for (let i = 1; i < array.length; i++) {
            if (array[i] < array[i-1]) {
                isSorted = false;
                break;
            }
        }
        
        if (!isSorted) {
            explanation.innerHTML = 'Array is not sorted. Sorting array first...';
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Array not sorted. Sorting in ascending order...
                </div>
            `;
            
            setTimeout(() => {
                array.sort((a, b) => a - b);
                renderArrayInContainer(array, 'originalMinMaxArray');
                renderArrayInContainer([...array], 'transformedMinMaxArray');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1 Complete:</strong> Array sorted: [${array.join(', ')}]
                    </div>
                `;
                
                startRearrangement();
            }, 2000);
        } else {
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step 1:</strong> Array is already sorted: [${array.join(', ')}]
                </div>
            `;
            startRearrangement();
        }
    }
    
    function startRearrangement() {
        explanation.innerHTML = 'Starting alternate rearrangement: max, min, 2nd max, 2nd min, ...';
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step 2:</strong> Begin rearrangement process
            </div>
        `;
        
        const result = new Array(n);
        let left = 0;
        let right = n - 1;
        let index = 0;
        
        function rearrangeStep() {
            if (left > right) {
                // Rearrangement completed
                explanation.innerHTML = `<strong>Rearrangement Completed!</strong> Array rearranged alternately.`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Rearrangement completed! Result: [${result.join(', ')}]
                    </div>
                `;
                
                // Highlight the final rearranged array
                const transformedElements = transformedContainer.querySelectorAll('.array-element');
                transformedElements.forEach((el, idx) => {
                    setTimeout(() => {
                        const valueDiv = el.querySelector('.element-value');
                        if (idx % 2 === 0) {
                            valueDiv.classList.add('rearrange-max'); // Even positions are max elements
                        } else {
                            valueDiv.classList.add('rearrange-min'); // Odd positions are min elements
                        }
                    }, idx * 200);
                });
                
                continueButton.style.display = 'block';
                
                // Auto-return to original after 8 seconds
                setTimeout(() => {
                    returnToOriginalAfterMinMax();
                }, 8000);
                
                continueButton.addEventListener('click', returnToOriginalAfterMinMax);
                
                return;
            }
            
            step++;
            
            if (index % 2 === 0) {
                // Even position - take max from right
                explanation.innerHTML = `Step ${step + 2}: Position ${index} - Taking max element [${right}]=${array[right]}`;
                
                // Highlight the current max element
                const originalElements = originalContainer.querySelectorAll('.array-element');
                const maxElement = originalElements[right].querySelector('.element-value');
                maxElement.classList.add('rearrange-current');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step + 2}:</strong> Position ${index}  Max element [${right}]=${array[right]}
                    </div>
                `;
                
                setTimeout(() => {
                    result[index] = array[right];
                    right--;
                    
                    // Update transformed array
                    renderArrayInContainer(result.filter(val => val !== undefined), 'transformedMinMaxArray');
                    
                    // Remove highlight
                    maxElement.classList.remove('rearrange-current');
                    
                    // Highlight the placed element
                    const transformedElements = transformedContainer.querySelectorAll('.array-element');
                    if (transformedElements[index]) {
                        transformedElements[index].querySelector('.element-value').classList.add('rearrange-max');
                    }
                    
                    index++;
                    rearrangeStep();
                }, 1500);
                
            } else {
                // Odd position - take min from left
                explanation.innerHTML = `Step ${step + 2}: Position ${index} - Taking min element [${left}]=${array[left]}`;
                
                // Highlight the current min element
                const originalElements = originalContainer.querySelectorAll('.array-element');
                const minElement = originalElements[left].querySelector('.element-value');
                minElement.classList.add('rearrange-current');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step + 2}:</strong> Position ${index}  Min element [${left}]=${array[left]}
                    </div>
                `;
                
                setTimeout(() => {
                    result[index] = array[left];
                    left++;
                    
                    // Update transformed array
                    renderArrayInContainer(result.filter(val => val !== undefined), 'transformedMinMaxArray');
                    
                    // Remove highlight
                    minElement.classList.remove('rearrange-current');
                    
                    // Highlight the placed element
                    const transformedElements = transformedContainer.querySelectorAll('.array-element');
                    if (transformedElements[index]) {
                        transformedElements[index].querySelector('.element-value').classList.add('rearrange-min');
                    }
                    
                    index++;
                    rearrangeStep();
                }, 1500);
            }
        }
        
        // Start rearrangement
        rearrangeStep();
    }
    
    // Start the process
    sortArrayIfNeeded();
}
// NEW: Return to Original after MinMax Rearrangement
function returnToOriginalAfterMinMax() {
    // Reset to original array
    myArray = [...originalArrayForMinMax];
    originalArrayForMinMax = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isRearrangeMinMaxRunning = false;
    
    logOperation('Min-Max rearrangement completed - returned to original array', 'info');
    showNotification('Returned to original array after rearrangement', 'success');
}
// NEW: Next Permutation Handler
function handleNextPermutation() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isNextPermutationRunning) {
        showNotification('Next permutation operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Next permutation requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForPermutation = [...myArray];
    
    // Show next permutation visualization
    showNextPermutationVisualization();
}

// NEW: Show Next Permutation Visualization
function showNextPermutationVisualization() {
    isNextPermutationRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Next Permutation Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalPermutationArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Next Permutation</div>
            <div class="transformed-array-container" id="transformedPermutationArray"></div>
        </div>
        
        <div class="permutation-explanation">
            <p class="mb-2"><strong>Next Permutation:</strong> Find lexicographically next greater permutation</p>
            <p class="mb-0" id="permutationExplanation">Starting next permutation algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="permutationStepsContainer">
            <h6 class="text-center">Next Permutation Steps</h6>
            <div class="steps-container" id="permutationSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPermutation" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForPermutation, 'originalPermutationArray');
    renderArrayInContainer([...originalArrayForPermutation], 'transformedPermutationArray');
    
    performNextPermutationAnimation();
}

// NEW: Perform Next Permutation Animation
function performNextPermutationAnimation() {
    const originalContainer = document.getElementById('originalPermutationArray');
    const transformedContainer = document.getElementById('transformedPermutationArray');
    const explanation = document.getElementById('permutationExplanation');
    const stepsContainer = document.getElementById('permutationSteps');
    const continueButton = document.getElementById('continueAfterPermutation');
    
    const arr = originalArrayForPermutation.map(val => parseFloat(val));
    const n = arr.length;
    let step = 0;
    let found = false;
    
    function performPermutationStep() {
        if (step === 0) {
            // Step 1: Find the first decreasing element from the right
            explanation.innerHTML = "Step 1: Find first index where arr[i] < arr[i+1] (from right)";
            
            let i = n - 2;
            let pivotIndex = -1;
            
            function findPivot() {
                if (i < 0) {
                    // No pivot found - array is in descending order
                    explanation.innerHTML = "No pivot found - array is in descending order. Reversing entire array.";
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 1:</strong> No decreasing element found - array is in descending order
                        </div>
                    `;
                    step = 3; // Skip to reverse step
                    performPermutationStep();
                    return;
                }
                
                // Highlight current comparison
                const elements = transformedContainer.querySelectorAll('.array-element');
                if (i + 1 < elements.length) {
                    elements[i].querySelector('.element-value').classList.add('permutation-pivot');
                    elements[i + 1].querySelector('.element-value').classList.add('sorting-compared');
                }
                
                explanation.innerHTML = `Comparing [${i}]=${arr[i]} and [${i+1}]=${arr[i+1]}`;
                
                setTimeout(() => {
                    if (arr[i] < arr[i + 1]) {
                        pivotIndex = i;
                        explanation.innerHTML = `Pivot found at index ${i} (${arr[i]} < ${arr[i+1]})`;
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Step 1:</strong> Pivot found at index ${i} (${arr[i]} < ${arr[i+1]})
                            </div>
                        `;
                        
                        // Highlight the pivot
                        elements[i].querySelector('.element-value').classList.remove('permutation-pivot');
                        elements[i].querySelector('.element-value').classList.add('permutation-pivot');
                        elements[i + 1].querySelector('.element-value').classList.remove('sorting-compared');
                        
                        step++;
                        performPermutationStep(pivotIndex);
                    } else {
                        // Remove highlights and continue searching
                        elements[i].querySelector('.element-value').classList.remove('permutation-pivot');
                        elements[i + 1].querySelector('.element-value').classList.remove('sorting-compared');
                        
                        i--;
                        findPivot();
                    }
                }, 1500);
            }
            
            findPivot();
            
        } else if (step === 1) {
            const pivotIndex = arguments[0];
            
            // Step 2: Find the smallest element greater than pivot from the right
            explanation.innerHTML = `Step 2: Find smallest element > ${arr[pivotIndex]} from right`;
            
            let j = n - 1;
            let swapIndex = -1;
            
            function findSwapCandidate() {
                if (j <= pivotIndex) {
                    step++;
                    performPermutationStep(pivotIndex, pivotIndex); // No swap candidate found
                    return;
                }
                
                // Highlight current candidate
                const elements = transformedContainer.querySelectorAll('.array-element');
                elements[j].querySelector('.element-value').classList.add('sorting-compared');
                
                explanation.innerHTML = `Comparing [${j}]=${arr[j]} with pivot ${arr[pivotIndex]}`;
                
                setTimeout(() => {
                    if (arr[j] > arr[pivotIndex]) {
                        swapIndex = j;
                        explanation.innerHTML = `Swap candidate found at index ${j} (${arr[j]} > ${arr[pivotIndex]})`;
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Step 2:</strong> Swap candidate found at index ${j} (${arr[j]} > ${arr[pivotIndex]})
                            </div>
                        `;
                        
                        // Highlight the swap candidate
                        elements[j].querySelector('.element-value').classList.remove('sorting-compared');
                        elements[j].querySelector('.element-value').classList.add('permutation-swap');
                        
                        step++;
                        performPermutationStep(pivotIndex, swapIndex);
                    } else {
                        // Remove highlight and continue searching
                        elements[j].querySelector('.element-value').classList.remove('sorting-compared');
                        
                        j--;
                        findSwapCandidate();
                    }
                }, 1500);
            }
            
            findSwapCandidate();
            
        } else if (step === 2) {
            const pivotIndex = arguments[0];
            const swapIndex = arguments[1];
            
            // Step 3: Swap pivot and swap candidate
            explanation.innerHTML = `Step 3: Swap pivot [${pivotIndex}]=${arr[pivotIndex]} with [${swapIndex}]=${arr[swapIndex]}`;
            
            const elements = transformedContainer.querySelectorAll('.array-element');
            const pivotElement = elements[pivotIndex].querySelector('.element-value');
            const swapElement = elements[swapIndex].querySelector('.element-value');
            
            pivotElement.classList.add('permutation-swap');
            swapElement.classList.add('permutation-swap');
            
            // Calculate swap distance for animation
            const rectPivot = elements[pivotIndex].getBoundingClientRect();
            const rectSwap = elements[swapIndex].getBoundingClientRect();
            const swapDistance = rectSwap.left - rectPivot.left;
            
            pivotElement.style.setProperty('--swap-distance', `${swapDistance}px`);
            swapElement.style.setProperty('--swap-distance', `-${swapDistance}px`);
            
            setTimeout(() => {
                pivotElement.classList.add('swap-animation');
                swapElement.classList.add('swap-animation');
                
                setTimeout(() => {
                    // Perform the swap
                    [arr[pivotIndex], arr[swapIndex]] = [arr[swapIndex], arr[pivotIndex]];
                    
                    // Update transformed array display
                    renderArrayInContainer(arr, 'transformedPermutationArray');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 3:</strong> Swapped elements at indices ${pivotIndex} and ${swapIndex}
                        </div>
                    `;
                    
                    // Remove highlights
                    pivotElement.classList.remove('permutation-swap', 'swap-animation');
                    swapElement.classList.remove('permutation-swap', 'swap-animation');
                    
                    step++;
                    performPermutationStep(pivotIndex);
                }, 1000);
            }, 500);
            
        } else if (step === 3) {
            const pivotIndex = arguments[0] !== undefined ? arguments[0] : -1;
            
            // Step 4: Reverse the suffix (elements after pivot)
            if (pivotIndex === -1) {
                // Entire array needs to be reversed (no next permutation case)
                explanation.innerHTML = "Step 4: Reverse entire array (no next permutation exists)";
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 4:</strong> Reversing entire array (lowest possible order)
                    </div>
                `;
                
                // Reverse the entire array with animation
                reverseSuffixWithAnimation(0, n - 1, true);
                
            } else {
                explanation.innerHTML = `Step 4: Reverse suffix after pivot (indices ${pivotIndex + 1} to ${n - 1})`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 4:</strong> Reversing elements from index ${pivotIndex + 1} to ${n - 1}
                    </div>
                `;
                
                // Reverse the suffix with animation
                reverseSuffixWithAnimation(pivotIndex + 1, n - 1, false);
            }
        }
    }
    
    // Helper function to reverse suffix with animation
    function reverseSuffixWithAnimation(left, right, isFullReverse) {
        const elements = transformedContainer.querySelectorAll('.array-element');
        let currentLeft = left;
        let currentRight = right;
        
        function reverseStep() {
            if (currentLeft >= currentRight) {
                // Reverse completed
                explanation.innerHTML = `<strong>Next Permutation Found!</strong> ${isFullReverse ? 'Array reversed to lowest order' : 'Next permutation generated'}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Next permutation algorithm completed successfully
                    </div>
                `;
                
                // Highlight the final array
                const finalElements = transformedContainer.querySelectorAll('.array-element');
                finalElements.forEach((el, index) => {
                    setTimeout(() => {
                        el.querySelector('.element-value').classList.add('create', 'bounce');
                    }, index * 100);
                });
                
                continueButton.style.display = 'block';
                
                // Auto-return after 30 seconds
                setTimeout(() => {
                    returnToOriginalAfterPermutation(arr);
                }, 30000);
                
                continueButton.addEventListener('click', () => {
                    returnToOriginalAfterPermutation(arr);
                });
                
                return;
            }
            
            // Highlight elements being swapped
            const leftElement = elements[currentLeft].querySelector('.element-value');
            const rightElement = elements[currentRight].querySelector('.element-value');
            
            leftElement.classList.add('permutation-reverse');
            rightElement.classList.add('permutation-reverse');
            
            explanation.innerHTML = `Reversing: swapping [${currentLeft}]=${arr[currentLeft]} and [${currentRight}]=${arr[currentRight]}`;
            
            setTimeout(() => {
                // Calculate swap distance for animation
                const rectLeft = elements[currentLeft].getBoundingClientRect();
                const rectRight = elements[currentRight].getBoundingClientRect();
                const swapDistance = rectRight.left - rectLeft.left;
                
                leftElement.style.setProperty('--swap-distance', `${swapDistance}px`);
                rightElement.style.setProperty('--swap-distance', `-${swapDistance}px`);
                
                leftElement.classList.add('swap-animation');
                rightElement.classList.add('swap-animation');
                
                setTimeout(() => {
                    // Perform the swap
                    [arr[currentLeft], arr[currentRight]] = [arr[currentRight], arr[currentLeft]];
                    
                    // Update transformed array display
                    renderArrayInContainer(arr, 'transformedPermutationArray');
                    
                    // Remove highlights
                    leftElement.classList.remove('permutation-reverse', 'swap-animation');
                    rightElement.classList.remove('permutation-reverse', 'swap-animation');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Reverse Step:</strong> Swapped [${currentLeft}] and [${currentRight}]
                        </div>
                    `;
                    
                    currentLeft++;
                    currentRight--;
                    reverseStep();
                }, 1000);
            }, 500);
        }
        
        reverseStep();
    }
    
    // Start the permutation process
    performPermutationStep();
}

// NEW: Return to Original after Permutation
function returnToOriginalAfterPermutation(nextPermutation) {
    // Apply the next permutation to the actual array
    myArray = nextPermutation.map(val => val.toString());
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isNextPermutationRunning = false;
    
    logOperation('Next permutation operation completed', 'info');
    showNotification('Next permutation applied successfully', 'success');
    
    // Auto-reset to original after 10 seconds
    setTimeout(() => {
        resetToOriginalAfterPermutation();
    }, 10000);
}

// NEW: Reset to original array after permutation
function resetToOriginalAfterPermutation() {
    if (originalArrayForPermutation.length === 0) {
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayForPermutation];
    originalArrayForPermutation = [];
    
    renderArray();
    updateStats();
    
    logOperation('Reset to original array after permutation', 'info');
    showNotification('Automatically reset to original array', 'info');
}
// NEW: Longest Consecutive Sequence Handler
function handleLongestConsecutiveSequence() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isConsecutiveOperationRunning) {
        showNotification('A consecutive sequence operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Longest consecutive sequence requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForConsecutive = [...myArray];
    
    // Perform longest consecutive sequence visualization
    performLongestConsecutiveSequence();
}

// NEW: Maximum Consecutive Ones Handler
function handleMaxConsecutiveOnes() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isConsecutiveOperationRunning) {
        showNotification('A consecutive sequence operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains only 0s and 1s
    let isBinaryArray = true;
    for (let i = 0; i < myArray.length; i++) {
        const value = myArray[i].toString();
        if (value !== '0' && value !== '1') {
            isBinaryArray = false;
            break;
        }
    }
    
    if (!isBinaryArray) {
        showNotification('Maximum consecutive 1s operation requires a binary array (only 0s and 1s)', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForConsecutive = [...myArray];
    
    // Perform maximum consecutive ones visualization
    performMaxConsecutiveOnes();
}

// NEW: Perform Longest Consecutive Sequence
function performLongestConsecutiveSequence() {
    isConsecutiveOperationRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Longest Consecutive Sequence</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalConsecutiveArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Longest Consecutive Sequence</div>
            <div class="transformed-array-container" id="consecutiveSequenceArray"></div>
        </div>
        
        <div class="consecutive-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find the longest sequence of consecutive numbers</p>
            <p class="mb-0" id="consecutiveExplanation">Starting longest consecutive sequence search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="consecutiveStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="consecutiveSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Longest Consecutive Sequence Length</div>
            <div class="stats-value" id="consecutiveLengthValue">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Sequence Values</div>
            <div class="stats-value" id="consecutiveValues">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterConsecutive" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForConsecutive, 'originalConsecutiveArray');
    renderArrayInContainer([], 'consecutiveSequenceArray');
    
    executeLongestConsecutiveSequence();
}

// NEW: Execute Longest Consecutive Sequence Algorithm
function executeLongestConsecutiveSequence() {
    const originalContainer = document.getElementById('originalConsecutiveArray');
    const sequenceContainer = document.getElementById('consecutiveSequenceArray');
    const explanation = document.getElementById('consecutiveExplanation');
    const stepsContainer = document.getElementById('consecutiveSteps');
    const consecutiveLengthValue = document.getElementById('consecutiveLengthValue');
    const consecutiveValues = document.getElementById('consecutiveValues');
    const continueButton = document.getElementById('continueAfterConsecutive');
    
    const arr = originalArrayForConsecutive.map(val => parseInt(val));
    const numSet = new Set(arr);
    let longestSequence = [];
    let currentSequence = [];
    let step = 0;
    
    function executeStep() {
        if (step >= arr.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Longest consecutive sequence found.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Longest consecutive sequence length = ${longestSequence.length}
                </div>
            `;
            
            // Display the longest sequence
            renderArrayInContainer(longestSequence, 'consecutiveSequenceArray');
            
            // Highlight the longest sequence in the original array
            const originalElements = originalContainer.querySelectorAll('.array-element');
            arr.forEach((value, index) => {
                if (longestSequence.includes(value)) {
                    setTimeout(() => {
                        originalElements[index].querySelector('.element-value').classList.add('consecutive-max');
                    }, (index % longestSequence.length) * 200);
                }
            });
            
            consecutiveLengthValue.textContent = longestSequence.length;
            consecutiveValues.textContent = `[${longestSequence.join(', ')}]`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterConsecutive();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterConsecutive);
            
            return;
        }
        
        const currentNum = arr[step];
        
        // Skip if this number is part of a longer sequence we've already checked
        if (numSet.has(currentNum - 1)) {
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step + 1}:</strong> Number ${currentNum} skipped (${currentNum - 1} exists, so it's not the start of a sequence)
                </div>
            `;
            
            // Highlight current number briefly
            const originalElements = originalContainer.querySelectorAll('.array-element');
            const currentElement = originalElements[step].querySelector('.element-value');
            currentElement.classList.add('consecutive-current');
            
            setTimeout(() => {
                currentElement.classList.remove('consecutive-current');
                step++;
                executeStep();
            }, 1000);
            
            return;
        }
        
        explanation.innerHTML = `Step ${step + 1}: Checking sequence starting from ${currentNum}`;
        
        // Highlight current starting number
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const startElement = originalElements[step].querySelector('.element-value');
        startElement.classList.add('consecutive-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step + 1}:</strong> Found potential sequence start at ${currentNum}
            </div>
        `;
        
        setTimeout(() => {
            // Build the sequence
            currentSequence = [currentNum];
            let nextNum = currentNum + 1;
            let sequenceStep = 0;
            
            function buildSequence() {
                if (numSet.has(nextNum)) {
                    currentSequence.push(nextNum);
                    
                    // Highlight the current sequence number
                    const nextIndex = arr.indexOf(nextNum);
                    if (nextIndex !== -1) {
                        const nextElement = originalElements[nextIndex].querySelector('.element-value');
                        nextElement.classList.add('consecutive-sequence');
                    }
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Sequence ${step + 1}.${sequenceStep + 1}:</strong> Added ${nextNum} to sequence. Current: [${currentSequence.join(', ')}]
                        </div>
                    `;
                    
                    nextNum++;
                    sequenceStep++;
                    
                    setTimeout(buildSequence, 800);
                } else {
                    // Sequence complete
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Sequence ${step + 1} Complete:</strong> Sequence [${currentSequence.join(', ')}] (length: ${currentSequence.length})
                        </div>
                    `;
                    
                    // Update longest sequence if current is longer
                    if (currentSequence.length > longestSequence.length) {
                        longestSequence = [...currentSequence];
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>New Longest Sequence!</strong> Length: ${longestSequence.length}
                            </div>
                        `;
                        
                        consecutiveLengthValue.textContent = longestSequence.length;
                        consecutiveValues.textContent = `[${longestSequence.join(', ')}]`;
                        
                        // Update sequence display
                        renderArrayInContainer(longestSequence, 'consecutiveSequenceArray');
                        
                        // Highlight the new longest sequence
                        const sequenceElements = sequenceContainer.querySelectorAll('.array-element');
                        sequenceElements.forEach((el, idx) => {
                            setTimeout(() => {
                                el.querySelector('.element-value').classList.add('consecutive-max');
                            }, idx * 200);
                        });
                    }
                    
                    // Remove highlights from start element
                    startElement.classList.remove('consecutive-current');
                    
                    // Move to next number
                    step++;
                    executeStep();
                }
            }
            
            buildSequence();
        }, 1500);
    }
    
    // Start execution
    executeStep();
}

// NEW: Perform Maximum Consecutive Ones
function performMaxConsecutiveOnes() {
    isConsecutiveOperationRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Maximum Consecutive 1s in Binary Array</h5>
        
        <div class="array-group">
            <div class="array-label">Binary Array</div>
            <div class="original-array-container" id="originalConsecutiveArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Maximum Consecutive 1s Sequence</div>
            <div class="transformed-array-container" id="consecutiveSequenceArray"></div>
        </div>
        
        <div class="consecutive-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find the longest sequence of consecutive 1s</p>
            <p class="mb-0" id="consecutiveExplanation">Starting maximum consecutive 1s search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="consecutiveStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="consecutiveSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Maximum Consecutive 1s Length</div>
            <div class="stats-value" id="consecutiveLengthValue">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Sequence Positions</div>
            <div class="stats-value" id="consecutiveValues">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterConsecutive" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForConsecutive, 'originalConsecutiveArray');
    renderArrayInContainer([], 'consecutiveSequenceArray');
    
    executeMaxConsecutiveOnes();
}

// NEW: Execute Maximum Consecutive Ones Algorithm
function executeMaxConsecutiveOnes() {
    const originalContainer = document.getElementById('originalConsecutiveArray');
    const sequenceContainer = document.getElementById('consecutiveSequenceArray');
    const explanation = document.getElementById('consecutiveExplanation');
    const stepsContainer = document.getElementById('consecutiveSteps');
    const consecutiveLengthValue = document.getElementById('consecutiveLengthValue');
    const consecutiveValues = document.getElementById('consecutiveValues');
    const continueButton = document.getElementById('continueAfterConsecutive');
    
    const arr = originalArrayForConsecutive.map(val => parseInt(val));
    let maxCount = 0;
    let currentCount = 0;
    let maxStart = -1;
    let currentStart = -1;
    let step = 0;
    
    function executeStep() {
        if (step >= arr.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Maximum consecutive 1s found.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Maximum consecutive 1s = ${maxCount}
                </div>
            `;
            
            // Display the sequence of 1s
            const onesSequence = Array(maxCount).fill('1');
            renderArrayInContainer(onesSequence, 'consecutiveSequenceArray');
            
            // Highlight the maximum sequence in the original array
            const originalElements = originalContainer.querySelectorAll('.array-element');
            for (let i = maxStart; i < maxStart + maxCount; i++) {
                setTimeout(() => {
                    originalElements[i].querySelector('.element-value').classList.add('consecutive-max');
                }, (i - maxStart) * 200);
            }
            
            consecutiveLengthValue.textContent = maxCount;
            consecutiveValues.textContent = `Positions ${maxStart} to ${maxStart + maxCount - 1}`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterConsecutive();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterConsecutive);
            
            return;
        }
        
        const currentValue = arr[step];
        
        explanation.innerHTML = `Step ${step + 1}: Checking position ${step}, value = ${currentValue}`;
        
        // Highlight current element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[step].querySelector('.element-value');
        
        if (currentValue === 1) {
            currentElement.classList.add('consecutive-current');
            
            if (currentCount === 0) {
                currentStart = step;
            }
            currentCount++;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step + 1}:</strong> Found 1 at position ${step}. Current consecutive count = ${currentCount}
                </div>
            `;
            
            // Update max if needed
            if (currentCount > maxCount) {
                maxCount = currentCount;
                maxStart = currentStart;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>New Maximum!</strong> Consecutive 1s count = ${maxCount}
                    </div>
                `;
                
                consecutiveLengthValue.textContent = maxCount;
                consecutiveValues.textContent = `Positions ${maxStart} to ${maxStart + maxCount - 1}`;
            }
            
        } else {
            currentElement.classList.add('consecutive-sequence');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step + 1}:</strong> Found 0 at position ${step}. Resetting consecutive count
                </div>
            `;
            
            currentCount = 0;
            currentStart = -1;
            
            setTimeout(() => {
                currentElement.classList.remove('consecutive-sequence');
            }, 500);
        }
        
        setTimeout(() => {
            currentElement.classList.remove('consecutive-current');
            step++;
            executeStep();
        }, 1000);
    }
    
    // Start execution
    executeStep();
}

// NEW: Return to Original after Consecutive Operations
function returnToOriginalAfterConsecutive() {
    // Reset to original array
    myArray = [...originalArrayForConsecutive];
    originalArrayForConsecutive = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isConsecutiveOperationRunning = false;
    
    logOperation('Consecutive sequence operation completed - returned to original array', 'info');
    showNotification('Returned to original array after consecutive sequence operation', 'success');
}
// NEW: Merge Intervals Handler
function handleMergeIntervals() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }

    if (isMergeIntervalsRunning) {
        showNotification('Merge intervals operation is already in progress', 'warning');
        return;
    }

    // Check if array contains valid intervals (pairs of numbers)
    let validIntervals = true;
    let intervals = [];
    
    try {
        // Try to parse array as intervals
        if (myArray.length % 2 !== 0) {
            throw new Error('Array length must be even for intervals');
        }
        
        for (let i = 0; i < myArray.length; i += 2) {
            const start = parseFloat(myArray[i]);
            const end = parseFloat(myArray[i + 1]);
            
            if (isNaN(start) || isNaN(end)) {
                throw new Error('All interval values must be numbers');
            }
            
            if (start > end) {
                throw new Error('Interval start cannot be greater than end');
            }
            
            intervals.push([start, end]);
        }
    } catch (error) {
        showNotification(`Invalid intervals format: ${error.message}. Please provide pairs of numbers [start, end, start, end, ...]`, 'danger');
        return;
    }

    isMergeIntervalsRunning = true;
    
    // Store original array
    originalArrayForMergeIntervals = [...myArray];
    
    // Show merge intervals visualization
    showMergeIntervalsVisualization(intervals);
}

// NEW: Show Merge Intervals Visualization
function showMergeIntervalsVisualization(intervals) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Merge Intervals Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Intervals</div>
            <div class="original-array-container" id="originalIntervalsArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Merged Intervals</div>
            <div class="transformed-array-container" id="mergedIntervalsArray"></div>
        </div>
        
        <div class="interval-visualization" id="intervalVisualization">
            <h6 class="text-center">Interval Visualization</h6>
            <div id="intervalLinesContainer"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Merge Intervals:</strong> Combine overlapping intervals into single intervals</p>
            <p class="mb-0" id="mergeIntervalsExplanation">Starting merge intervals algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="mergeIntervalsStepsContainer">
            <h6 class="text-center">Merge Intervals Steps</h6>
            <div class="steps-container" id="mergeIntervalsSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMergeIntervals" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;

    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);

    // Display original intervals
    renderIntervalsArray(intervals, 'originalIntervalsArray');
    
    // Create visualization lines
    createIntervalVisualization(intervals);
    
    // Start merge intervals animation
    performMergeIntervalsAnimation(intervals);
}

// NEW: Render Intervals Array
function renderIntervalsArray(intervals, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    intervals.forEach((interval, index) => {
        const intervalElement = document.createElement('div');
        intervalElement.className = 'array-element';
        intervalElement.innerHTML = `
            <div class="element-value interval-item" data-interval-index="${index}">
                [${interval[0]}, ${interval[1]}]
            </div>
            <div class="element-index">Interval ${index}</div>
        `;
        container.appendChild(intervalElement);
    });
}

// NEW: Create Interval Visualization
function createIntervalVisualization(intervals) {
    const container = document.getElementById('intervalLinesContainer');
    container.innerHTML = '';
    
    // Find min and max values for scaling
    let minVal = Infinity;
    let maxVal = -Infinity;
    
    intervals.forEach(interval => {
        minVal = Math.min(minVal, interval[0]);
        maxVal = Math.max(maxVal, interval[1]);
    });
    
    const range = maxVal - minVal || 1;
    
    intervals.forEach((interval, index) => {
        const line = document.createElement('div');
        line.className = 'interval-line';
        
        const startPos = ((interval[0] - minVal) / range) * 100;
        const endPos = ((interval[1] - minVal) / range) * 100;
        const width = endPos - startPos;
        
        line.innerHTML = `
            <div class="interval-label">Interval ${index}</div>
            <div class="interval-range">
                <div class="interval-segment original" 
                     style="left: ${startPos}%; width: ${width}%;"
                     data-interval-index="${index}">
                </div>
            </div>
            <div class="interval-values">[${interval[0]}, ${interval[1]}]</div>
        `;
        
        container.appendChild(line);
    });
}

// NEW: Perform Merge Intervals Animation
function performMergeIntervalsAnimation(intervals) {
    const originalContainer = document.getElementById('originalIntervalsArray');
    const mergedContainer = document.getElementById('mergedIntervalsArray');
    const explanation = document.getElementById('mergeIntervalsExplanation');
    const stepsContainer = document.getElementById('mergeIntervalsSteps');
    const continueButton = document.getElementById('continueAfterMergeIntervals');
    const visualizationContainer = document.getElementById('intervalLinesContainer');
    
    // Sort intervals by start time
    const sortedIntervals = [...intervals].sort((a, b) => a[0] - b[0]);
    let merged = [];
    let currentStep = 0;
    
    function performMergeStep(i) {
        if (i >= sortedIntervals.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Merge Intervals Completed!</strong> Found ${merged.length} merged intervals.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Algorithm completed. ${merged.length} merged intervals found.
                </div>
            `;
            
            // Display final merged intervals
            renderIntervalsArray(merged, 'mergedIntervalsArray');
            
            // Highlight final merged intervals
            setTimeout(() => {
                const mergedElements = mergedContainer.querySelectorAll('.array-element');
                mergedElements.forEach((el, index) => {
                    setTimeout(() => {
                        el.querySelector('.element-value').classList.add('interval-merged');
                    }, index * 300);
                });
            }, 500);
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterMergeIntervals();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterMergeIntervals);
            
            return;
        }
        
        currentStep++;
        
        if (i === 0) {
            // First interval
            explanation.innerHTML = `Step ${currentStep}: Start with first interval [${sortedIntervals[i][0]}, ${sortedIntervals[i][1]}]`;
            
            // Highlight first interval
            highlightInterval(originalContainer, i, 'interval-start');
            highlightVisualizationSegment(i, 'interval-start');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${currentStep}:</strong> Start with first interval [${sortedIntervals[i][0]}, ${sortedIntervals[i][1]}]
                </div>
            `;
            
            merged.push([...sortedIntervals[i]]);
            
            setTimeout(() => {
                performMergeStep(i + 1);
            }, 2000);
            
        } else {
            const currentInterval = sortedIntervals[i];
            const lastMerged = merged[merged.length - 1];
            
            explanation.innerHTML = `Step ${currentStep}: Compare [${lastMerged[0]}, ${lastMerged[1]}] with [${currentInterval[0]}, ${currentInterval[1]}]`;
            
            // Highlight both intervals being compared
            highlightInterval(originalContainer, i, 'interval-start');
            highlightVisualizationSegment(i, 'interval-start');
            
            // Find and highlight the last merged interval in original array
            const originalIndex = intervals.findIndex(interval => 
                interval[0] === lastMerged[0] && interval[1] === lastMerged[1]);
            if (originalIndex !== -1) {
                highlightInterval(originalContainer, originalIndex, 'interval-end');
                highlightVisualizationSegment(originalIndex, 'interval-end');
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${currentStep}:</strong> Comparing [${lastMerged[0]}, ${lastMerged[1]}] with [${currentInterval[0]}, ${currentInterval[1]}]
                </div>
            `;
            
            setTimeout(() => {
                if (currentInterval[0] <= lastMerged[1]) {
                    // Overlapping intervals - merge them
                    explanation.innerHTML = `Step ${currentStep}: Intervals OVERLAP! Merging into [${lastMerged[0]}, ${Math.max(lastMerged[1], currentInterval[1])}]`;
                    
                    // Highlight overlap
                    highlightInterval(originalContainer, i, 'interval-overlap');
                    highlightVisualizationSegment(i, 'interval-overlap');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${currentStep}:</strong> Intervals overlap! Merging into [${lastMerged[0]}, ${Math.max(lastMerged[1], currentInterval[1])}]
                        </div>
                    `;
                    
                    // Update the merged interval
                    lastMerged[1] = Math.max(lastMerged[1], currentInterval[1]);
                    
                    // Update visualization for merged interval
                    updateMergedVisualization(merged);
                    
                } else {
                    // Non-overlapping interval
                    explanation.innerHTML = `Step ${currentStep}: No overlap. Adding new interval [${currentInterval[0]}, ${currentInterval[1]}]`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${currentStep}:</strong> No overlap. Adding new interval to merged list
                        </div>
                    `;
                    
                    merged.push([...currentInterval]);
                }
                
                // Update merged intervals display
                renderIntervalsArray(merged, 'mergedIntervalsArray');
                
                // Scroll steps container
                stepsContainer.scrollTop = stepsContainer.scrollHeight;
                
                setTimeout(() => {
                    performMergeStep(i + 1);
                }, 2500);
            }, 2000);
        }
    }
    
    // Start merge intervals process
    performMergeStep(0);
}

// NEW: Helper function to highlight intervals
function highlightInterval(container, index, className) {
    const elements = container.querySelectorAll('.array-element');
    if (elements[index]) {
        const valueElement = elements[index].querySelector('.element-value');
        valueElement.classList.add(className);
        
        // Remove highlight after animation
        setTimeout(() => {
            valueElement.classList.remove(className);
        }, 2000);
    }
}

// NEW: Helper function to highlight visualization segments
function highlightVisualizationSegment(index, className) {
    const segments = document.querySelectorAll(`.interval-segment[data-interval-index="${index}"]`);
    segments.forEach(segment => {
        segment.classList.add(className);
        
        // Remove highlight after animation
        setTimeout(() => {
            segment.classList.remove(className);
        }, 2000);
    });
}

// NEW: Update merged visualization
function updateMergedVisualization(merged) {
    const visualizationContainer = document.getElementById('intervalLinesContainer');
    
    // Clear existing merged visualization
    const existingMerged = visualizationContainer.querySelectorAll('.interval-segment.merged');
    existingMerged.forEach(segment => segment.remove());
    
    // Find min and max values for scaling
    let minVal = Infinity;
    let maxVal = -Infinity;
    
    merged.forEach(interval => {
        minVal = Math.min(minVal, interval[0]);
        maxVal = Math.max(maxVal, interval[1]);
    });
    
    const range = maxVal - minVal || 1;
    
    // Add merged intervals to visualization
    merged.forEach((interval, index) => {
        const startPos = ((interval[0] - minVal) / range) * 100;
        const endPos = ((interval[1] - minVal) / range) * 100;
        const width = endPos - startPos;
        
        const mergedSegment = document.createElement('div');
        mergedSegment.className = 'interval-segment merged';
        mergedSegment.style.cssText = `left: ${startPos}%; width: ${width}%;`;
        mergedSegment.setAttribute('data-merged-index', index);
        
        visualizationContainer.appendChild(mergedSegment);
    });
}

// NEW: Return to Original after Merge Intervals
function returnToOriginalAfterMergeIntervals() {
    // Reset to original array
    myArray = [...originalArrayForMergeIntervals];
    originalArrayForMergeIntervals = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMergeIntervalsRunning = false;
    
    logOperation('Merge intervals completed - returned to original array', 'info');
    showNotification('Returned to original array after merge intervals', 'success');
}
// NEW: Set Operation Handler
function handleSetOperation(operation) {
    if (isSetOperationRunning) {
        showNotification('A set operation is already in progress', 'warning');
        return;
    }

    // Reset arrays
    setArrays = [];
    currentSetOperation = operation;
    
    // Show input group
    setOperationsGroup.style.display = 'block';
    numArrays.focus();
    
    // Hide perform button initially
    performSetOperationBtn.style.display = 'none';
    
    // Update button text based on operation
    performSetOperationBtn.innerHTML = 
        operation === 'union' 
            ? '<i class="fas fa-object-group me-2"></i>Find Union' 
            : '<i class="fas fa-bezier-curve me-2"></i>Find Intersection';
    
    logOperation(`Started ${operation} operation`, 'info');
}

// NEW: Confirm Number of Arrays Handler
function handleConfirmNumArrays() {
    const num = parseInt(numArrays.value);
    
    if (isNaN(num) || num < 1 || num > 3) {
        showNotification('Please enter a valid number between 1 and 3', 'danger');
        numArrays.focus();
        return;
    }
    
    setArrays = Array(num).fill().map(() => []);
    
    // Create input fields for each array
    setArraysInputs.innerHTML = '';
    for (let i = 0; i < num; i++) {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'mb-3';
        arrayGroup.innerHTML = `
            <label class="form-label">Array ${i + 1} Details</label>
            <div class="input-group mb-2">
                <input type="number" class="form-control array-size" 
                       data-array-index="${i}" placeholder="Size of array ${i + 1}" min="1" max="20">
                <button class="btn btn-glow confirm-array-size-btn" data-array-index="${i}">
                    <i class="fas fa-check me-2"></i>Set Array ${i + 1} Size
                </button>
            </div>
            <div class="array-inputs" id="arrayInputs${i}"></div>
        `;
        setArraysInputs.appendChild(arrayGroup);
    }
    
    // Add event listeners for array size buttons
    const confirmSizeButtons = setArraysInputs.querySelectorAll('.confirm-array-size-btn');
    confirmSizeButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
            const arrayIndex = parseInt(e.target.dataset.arrayIndex);
            handleConfirmArraySize(arrayIndex);
        });
    });
    
    // Add Enter key support for array size inputs
    const arraySizeInputs = setArraysInputs.querySelectorAll('.array-size');
    arraySizeInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const arrayIndex = parseInt(e.target.dataset.arrayIndex);
                handleConfirmArraySize(arrayIndex);
            }
        });
    });
    
    showNotification(`Number of arrays set to ${num}. Please set sizes for each array.`, 'success');
    logOperation(`Number of arrays set to ${num}`, 'info');
}

// NEW: Confirm Array Size Handler
function handleConfirmArraySize(arrayIndex) {
    const sizeInput = document.querySelector(`.array-size[data-array-index="${arrayIndex}"]`);
    const size = parseInt(sizeInput.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        sizeInput.focus();
        return;
    }
    
    // Create input fields for array elements
    const arrayInputsContainer = document.getElementById(`arrayInputs${arrayIndex}`);
    arrayInputsContainer.innerHTML = `<label class="form-label">Enter ${size} elements for Array ${arrayIndex + 1}:</label>`;
    
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="text" class="form-control set-array-element" 
                   data-array-index="${arrayIndex}" data-element-index="${i}" 
                   placeholder="Enter value">
        `;
        arrayInputsContainer.appendChild(inputGroup);
    }
    
    // Add event listeners for array element inputs
    const elementInputs = arrayInputsContainer.querySelectorAll('.set-array-element');
    elementInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('set-array-element')) {
                    nextInput.focus();
                }
            }
        });
    });
    
    // Check if all arrays are ready
    checkAllArraysReady();
    
    showNotification(`Array ${arrayIndex + 1} size set to ${size}. Please enter ${size} elements.`, 'success');
    logOperation(`Array ${arrayIndex + 1} size set to ${size}`, 'info');
}

// NEW: Check if all arrays are ready
function checkAllArraysReady() {
    const num = parseInt(numArrays.value);
    let allReady = true;
    
    for (let i = 0; i < num; i++) {
        const arrayInputs = document.querySelectorAll(`.set-array-element[data-array-index="${i}"]`);
        if (arrayInputs.length === 0) {
            allReady = false;
            break;
        }
    }
    
    if (allReady) {
        performSetOperationBtn.style.display = 'block';
    }
}

// NEW: Perform Set Operation Handler
function handlePerformSetOperation() {
    const num = parseInt(numArrays.value);
    
    // Collect all array elements
    for (let i = 0; i < num; i++) {
        const elementInputs = document.querySelectorAll(`.set-array-element[data-array-index="${i}"]`);
        setArrays[i] = [];
        
        for (let j = 0; j < elementInputs.length; j++) {
            const value = elementInputs[j].value.trim();
            if (value === '') {
                showNotification(`Please enter all elements for array ${i + 1}. Missing element at position ${j}`, 'danger');
                elementInputs[j].focus();
                return;
            }
            setArrays[i].push(value);
        }
    }
    
    // Store original array
    originalArrayBeforeSetOperation = [...myArray];
    
    // Hide input group
    setOperationsGroup.style.display = 'none';
    
    // Start set operation visualization
    showSetOperationVisualization();
}

// NEW: Cancel Set Operation Handler
function handleCancelSetOperation() {
    setOperationsGroup.style.display = 'none';
    numArrays.value = '';
    setArraysInputs.innerHTML = '';
    performSetOperationBtn.style.display = 'none';
    
    setArrays = [];
    currentSetOperation = null;
    
    logOperation('Cancelled set operation', 'info');
    showNotification('Set operation cancelled', 'info');
}

// NEW: Show Set Operation Visualization
function showSetOperationVisualization() {
    isSetOperationRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">${currentSetOperation === 'union' ? 'Union' : 'Intersection'} of Arrays</h5>
        
        <div class="array-group">
            <div class="array-label">Input Arrays</div>
            <div id="inputArraysDisplay" class="mb-4"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">${currentSetOperation === 'union' ? 'Union' : 'Intersection'} Result</div>
            <div class="transformed-array-container" id="setResultArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>${currentSetOperation === 'union' ? 'Union' : 'Intersection'} Process:</strong> ${currentSetOperation === 'union' ? 'Combining all unique elements from all arrays' : 'Finding common elements across all arrays'}</p>
            <p class="mb-0" id="setOperationExplanation">Starting ${currentSetOperation} operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="setOperationStepsContainer">
            <h6 class="text-center">${currentSetOperation === 'union' ? 'Union' : 'Intersection'} Steps</h6>
            <div class="steps-container" id="setOperationSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSetOperation" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display input arrays
    displayInputArrays();
    renderArrayInContainer([], 'setResultArray');
    
    // Start set operation animation
    performSetOperationAnimation();
}
// NEW: Display Input Arrays
function displayInputArrays() {
    const inputArraysContainer = document.getElementById('inputArraysDisplay');
    inputArraysContainer.innerHTML = '';
    
    // Add horizontal container styling
    inputArraysContainer.style.display = 'flex';
    inputArraysContainer.style.flexWrap = 'wrap';
    inputArraysContainer.style.gap = '50px';
    inputArraysContainer.style.justifyContent = 'center';
    inputArraysContainer.style.alignItems = 'flex-start';
    
    setArrays.forEach((array, index) => {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'horizontal-array-group';
        arrayGroup.style.flex = '0 0 auto';
        arrayGroup.style.textAlign = 'center';
        arrayGroup.innerHTML = `
            <div class="array-label" style="margin-bottom: 10px; font-weight: bold;">Array ${index + 1}</div>
            <div class="horizontal-array-elements" id="inputArray${index}" style="display: flex; gap: 10px; justify-content: center;"></div>
        `;
        inputArraysContainer.appendChild(arrayGroup);
        renderHorizontalArrayInContainer(array, `inputArray${index}`);
    });
}

// NEW: Render array horizontally for set operations
function renderHorizontalArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    array.forEach((element, index) => {
        const elementDiv = document.createElement('div');
        elementDiv.className = 'array-element horizontal-element';
        elementDiv.style.display = 'flex';
        elementDiv.style.flexDirection = 'column';
        elementDiv.style.alignItems = 'center';
        elementDiv.style.margin = '0 5px';
        
        elementDiv.innerHTML = `
            <div class="element-value" style="min-width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 8px; font-weight: bold; font-size: 16px; margin-bottom: 5px;">
                ${element}
            </div>
            <div class="element-index" style="font-size: 12px; color: #666; background: #f8f9fa; padding: 2px 8px; border-radius: 4px;">
                [${index}]
            </div>
        `;
        
        container.appendChild(elementDiv);
    });
}
// NEW: Perform Set Operation Animation
function performSetOperationAnimation() {
    const explanation = document.getElementById('setOperationExplanation');
    const stepsContainer = document.getElementById('setOperationSteps');
    const continueButton = document.getElementById('continueAfterSetOperation');
    
    let resultArray = [];
    let step = 0;
    
    function performSetStep() {
        if (currentSetOperation === 'union') {
            performUnionStep();
        } else {
            performIntersectionStep();
        }
    }
    
    function performUnionStep() {
        if (step === 0) {
            explanation.innerHTML = 'Step 1: Initialize empty set for union';
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Initialize empty set to collect unique elements
                </div>
            `;
            step++;
            setTimeout(performUnionStep, 1500);
            return;
        }
        
        if (step === 1) {
            explanation.innerHTML = 'Step 2: Processing arrays to find union';
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 2:</strong> Processing ${setArrays.length} arrays for union
                </div>
            `;
            
            // Create a Set for union
            const unionSet = new Set();
            let currentArrayIndex = 0;
            let currentElementIndex = 0;
            
            function processNextElement() {
                if (currentArrayIndex >= setArrays.length) {
                    // Union completed
                    resultArray = Array.from(unionSet);
                    renderArrayInContainer(resultArray, 'setResultArray');
                    
                    explanation.innerHTML = `<strong>Union Completed!</strong> Found ${resultArray.length} unique elements.`;
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Final:</strong> Union completed! Total unique elements: ${resultArray.length}
                        </div>
                    `;
                    
                    // Highlight the result
                    const resultElements = document.querySelectorAll('#setResultArray .array-element');
                    resultElements.forEach((el, index) => {
                        setTimeout(() => {
                            el.querySelector('.element-value').classList.add('create', 'bounce');
                        }, index * 200);
                    });
                    
                    continueButton.style.display = 'block';
                    setTimeout(() => {
                        returnToOriginalAfterSetOperation();
                    }, 5000);
                    continueButton.addEventListener('click', returnToOriginalAfterSetOperation);
                    return;
                }
                
                if (currentElementIndex >= setArrays[currentArrayIndex].length) {
                    // Move to next array
                    currentArrayIndex++;
                    currentElementIndex = 0;
                    processNextElement();
                    return;
                }
                
                const currentElement = setArrays[currentArrayIndex][currentElementIndex];
                explanation.innerHTML = `Processing Array ${currentArrayIndex + 1}[${currentElementIndex}] = "${currentElement}"`;
                
                // Highlight current element in input array
                const inputArray = document.getElementById(`inputArray${currentArrayIndex}`);
                const inputElements = inputArray.querySelectorAll('.array-element');
                if (currentElementIndex < inputElements.length) {
                    inputElements[currentElementIndex].querySelector('.element-value').classList.add('window-current');
                }
                
                setTimeout(() => {
                    // Add to union set
                    const isNewElement = !unionSet.has(currentElement);
                    unionSet.add(currentElement);
                    
                    if (isNewElement) {
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Step:</strong> Added "${currentElement}" to union (new element)
                            </div>
                        `;
                        // Update result array
                        resultArray = Array.from(unionSet);
                        renderArrayInContainer(resultArray, 'setResultArray');
                    } else {
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Step:</strong> Element "${currentElement}" already in union (duplicate)
                            </div>
                        `;
                    }
                    
                    // Remove highlight
                    if (currentElementIndex < inputElements.length) {
                        inputElements[currentElementIndex].querySelector('.element-value').classList.remove('window-current');
                    }
                    
                    currentElementIndex++;
                    processNextElement();
                }, 1000);
            }
            
            processNextElement();
        }
    }
    
    function performIntersectionStep() {
        if (step === 0) {
            explanation.innerHTML = 'Step 1: Initialize with first array';
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Start with first array as initial intersection
                </div>
            `;
            
            if (setArrays.length === 0) {
                resultArray = [];
            } else {
                resultArray = [...new Set(setArrays[0])]; // Remove duplicates from first array
            }
            
            renderArrayInContainer(resultArray, 'setResultArray');
            step++;
            setTimeout(performIntersectionStep, 1500);
            return;
        }
        
        if (step <= setArrays.length) {
            const currentArrayIndex = step;
            
            if (currentArrayIndex >= setArrays.length) {
                // Intersection completed
                explanation.innerHTML = `<strong>Intersection Completed!</strong> Found ${resultArray.length} common elements.`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Intersection completed! Common elements: ${resultArray.length}
                    </div>
                `;
                
                // Highlight the result
                const resultElements = document.querySelectorAll('#setResultArray .array-element');
                resultElements.forEach((el, index) => {
                    setTimeout(() => {
                        el.querySelector('.element-value').classList.add('create', 'bounce');
                    }, index * 200);
                });
                
                continueButton.style.display = 'block';
                setTimeout(() => {
                    returnToOriginalAfterSetOperation();
                }, 5000);
                continueButton.addEventListener('click', returnToOriginalAfterSetOperation);
                return;
            }
            
            explanation.innerHTML = `Step ${step + 1}: Intersecting with Array ${currentArrayIndex + 1}`;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step + 1}:</strong> Finding common elements with Array ${currentArrayIndex + 1}
                </div>
            `;
            
            const currentArray = setArrays[currentArrayIndex];
            const newIntersection = [];
            let elementIndex = 0;
            
            function processIntersectionElement() {
                if (elementIndex >= resultArray.length) {
                    // Finished processing current intersection
                    resultArray = [...new Set(newIntersection)]; // Remove duplicates
                    renderArrayInContainer(resultArray, 'setResultArray');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Result:</strong> After Array ${currentArrayIndex + 1}, common elements: ${resultArray.length}
                        </div>
                    `;
                    
                    step++;
                    setTimeout(performIntersectionStep, 1500);
                    return;
                }
                
                const currentElement = resultArray[elementIndex];
                explanation.innerHTML = `Checking element "${currentElement}" in Array ${currentArrayIndex + 1}`;
                
                // Highlight in result array
                const resultContainer = document.getElementById('setResultArray');
                const resultElements = resultContainer.querySelectorAll('.array-element');
                if (elementIndex < resultElements.length) {
                    resultElements[elementIndex].querySelector('.element-value').classList.add('window-current');
                }
                
                setTimeout(() => {
                    const existsInCurrentArray = currentArray.includes(currentElement);
                    
                    if (existsInCurrentArray) {
                        newIntersection.push(currentElement);
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Keep:</strong> "${currentElement}" exists in Array ${currentArrayIndex + 1}
                            </div>
                        `;
                    } else {
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Remove:</strong> "${currentElement}" not in Array ${currentArrayIndex + 1}
                            </div>
                        `;
                    }
                    
                    // Remove highlight
                    if (elementIndex < resultElements.length) {
                        resultElements[elementIndex].querySelector('.element-value').classList.remove('window-current');
                    }
                    
                    elementIndex++;
                    processIntersectionElement();
                }, 1000);
            }
            
            processIntersectionElement();
        }
    }
    
    // Start set operation
    performSetStep();
}

// NEW: Return to Original after Set Operation
function returnToOriginalAfterSetOperation() {
    // Reset to original array
    myArray = [...originalArrayBeforeSetOperation];
    originalArrayBeforeSetOperation = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isSetOperationRunning = false;
    
    // Clear all set operation data
    setArrays = [];
    currentSetOperation = null;
    
    // Reset input groups
    setOperationsGroup.style.display = 'none';
    numArrays.value = '';
    setArraysInputs.innerHTML = '';
    performSetOperationBtn.style.display = 'none';
    
    logOperation('Set operation completed - returned to original array', 'info');
    showNotification('Returned to original array after set operation', 'success');
}
// NEW: Handle Set Operation
function handleSetOperation(operationType) {
    if (isSetOpRunning) {
        showNotification('A set operation is already in progress', 'warning');
        return;
    }

    currentSetOpType = operationType;
    setOpArrays = [];
    
    // Show input group
    setOperationsGroup.style.display = 'block';
    numArrays.focus();
    
    // Hide perform button initially
    performSetOperationBtn.style.display = 'none';
    
    const operationName = operationType === 'difference' ? 'Set Difference' : 'Symmetric Difference';
    logOperation(`Started ${operationName} operation`, 'info');
}

// NEW: Confirm Number of Arrays for Set Operation
function handleConfirmNumArrays() {
    const count = parseInt(numArrays.value);
    
    if (isNaN(count) || count !== 2) {
        showNotification('Set operations require exactly 2 arrays', 'danger');
        numArrays.focus();
        return;
    }
    
    // Create input fields for arrays
    setArraysInputs.innerHTML = '';
    
    for (let i = 0; i < count; i++) {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'mb-3';
        arrayGroup.innerHTML = `
            <label class="form-label">Array ${String.fromCharCode(65 + i)} Details</label>
            <div class="input-group mb-2">
                <input type="number" class="form-control set-array-size" 
                       data-array-index="${i}" placeholder="Size of Array ${String.fromCharCode(65 + i)}" min="1" max="20">
                <button class="btn btn-glow confirm-array-size-btn" data-array-index="${i}">
                    <i class="fas fa-check me-2"></i>Set Size
                </button>
            </div>
            <div class="array-inputs-container" id="arrayInputs${i}"></div>
        `;
        setArraysInputs.appendChild(arrayGroup);
    }
    
    // Add event listeners for array size buttons
    const sizeButtons = setArraysInputs.querySelectorAll('.confirm-array-size-btn');
    sizeButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
            const arrayIndex = parseInt(e.target.getAttribute('data-array-index'));
            handleConfirmArraySize(arrayIndex);
        });
    });
    
    // Add Enter key support for size inputs
    const sizeInputs = setArraysInputs.querySelectorAll('.set-array-size');
    sizeInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const arrayIndex = parseInt(e.target.getAttribute('data-array-index'));
                handleConfirmArraySize(arrayIndex);
            }
        });
    });
    
    showNotification(`Set up ${count} arrays for set operation`, 'success');
}

// NEW: Confirm Array Size for Set Operation
function handleConfirmArraySize(arrayIndex) {
    const sizeInput = document.querySelector(`.set-array-size[data-array-index="${arrayIndex}"]`);
    const size = parseInt(sizeInput.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification(`Please enter a valid size between 1 and 20 for Array ${String.fromCharCode(65 + arrayIndex)}`, 'danger');
        sizeInput.focus();
        return;
    }
    
    // Create input fields for array elements
    const inputsContainer = document.getElementById(`arrayInputs${arrayIndex}`);
    inputsContainer.innerHTML = `<label class="form-label">Enter elements for Array ${String.fromCharCode(65 + arrayIndex)}:</label>`;
    
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="text" class="form-control set-array-element" 
                   data-array-index="${arrayIndex}" data-element-index="${i}" placeholder="Enter value">
        `;
        inputsContainer.appendChild(inputGroup);
    }
    
    // Disable size input and button
    sizeInput.disabled = true;
    document.querySelector(`.confirm-array-size-btn[data-array-index="${arrayIndex}"]`).disabled = true;
    
    // Add event listeners for element inputs
    const elementInputs = inputsContainer.querySelectorAll('.set-array-element');
    elementInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('set-array-element')) {
                    nextInput.focus();
                }
            }
        });
    });
    
    // Check if all arrays are ready
    checkAllArraysReady();
}

// NEW: Check if all arrays are ready for set operation
function checkAllArraysReady() {
    const allSizeInputs = setArraysInputs.querySelectorAll('.set-array-size');
    let allReady = true;
    
    for (let i = 0; i < allSizeInputs.length; i++) {
        if (!allSizeInputs[i].disabled) {
            allReady = false;
            break;
        }
    }
    
    if (allReady) {
        performSetOperationBtn.style.display = 'block';
        showNotification('All arrays are ready. Click "Perform Set Operation" to continue.', 'success');
    }
}

// NEW: Perform Set Operation
function handlePerformSetOperation() {
    const arrayCount = parseInt(numArrays.value);
    setOpArrays = [];
    
    // Collect all array elements
    for (let i = 0; i < arrayCount; i++) {
        const elementInputs = document.querySelectorAll(`.set-array-element[data-array-index="${i}"]`);
        const array = [];
        
        for (let j = 0; j < elementInputs.length; j++) {
            const value = elementInputs[j].value.trim();
            if (value === '') {
                showNotification(`Please enter all elements for Array ${String.fromCharCode(65 + i)}. Missing element at position ${j}`, 'danger');
                elementInputs[j].focus();
                return;
            }
            array.push(value);
        }
        
        setOpArrays.push(array);
    }
    
    // Store original array
    originalArrayBeforeSetOp = [...myArray];
    
    // Hide input group
    setOperationsGroup.style.display = 'none';
    
    // Start set operation visualization
    showSetOperationVisualization();
}

// NEW: Cancel Set Operation
function handleCancelSetOperation() {
    setOperationsGroup.style.display = 'none';
    numArrays.value = '2';
    setArraysInputs.innerHTML = '';
    performSetOperationBtn.style.display = 'none';
    
    setOpArrays = [];
    currentSetOpType = null;
    
    logOperation('Cancelled set operation', 'info');
    showNotification('Set operation cancelled', 'info');
}

// NEW: Show Set Operation Visualization
function showSetOperationVisualization() {
    isSetOpRunning = true;
    
    const operationName = currentSetOpType === 'difference' ? 'Set Difference (A - B)' : 'Symmetric Difference';
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">${operationName}</h5>
        
        <div class="array-group">
            <div class="array-label">Array A</div>
            <div class="original-array-container" id="setArrayA"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Array B</div>
            <div class="original-array-container" id="setArrayB"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">${operationName} Result</div>
            <div class="transformed-array-container" id="setResultArray"></div>
        </div>
        
        <div class="set-operation-explanation">
            <p class="mb-2"><strong>Set Operation:</strong> ${getSetOperationExplanation()}</p>
            <p class="mb-0" id="setOpExplanation">Starting set operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="setOpStepsContainer">
            <h6 class="text-center">Set Operation Steps</h6>
            <div class="steps-container" id="setOpSteps"></div>
        </div>
        
        <div class="set-operation-result mt-3" id="setOpResult" style="display: none;">
            <h6 class="text-center">Final Result</h6>
            <div id="setOpResultContent"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSetOp" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display the input arrays
    renderArrayInContainer(setOpArrays[0], 'setArrayA');
    renderArrayInContainer(setOpArrays[1], 'setArrayB');
    renderArrayInContainer([], 'setResultArray');
    
    // Start set operation animation
    performSetOperationAnimation();
}

// NEW: Get Set Operation Explanation
function getSetOperationExplanation() {
    if (currentSetOpType === 'difference') {
        return 'A - B: Elements in A but not in B';
    } else {
        return '(A - B)  (B - A): Elements in either A or B but not in both';
    }
}

// NEW: Perform Set Operation Animation
function performSetOperationAnimation() {
    const arrayAContainer = document.getElementById('setArrayA');
    const arrayBContainer = document.getElementById('setArrayB');
    const resultContainer = document.getElementById('setResultArray');
    const explanation = document.getElementById('setOpExplanation');
    const stepsContainer = document.getElementById('setOpSteps');
    const resultDiv = document.getElementById('setOpResult');
    const resultContent = document.getElementById('setOpResultContent');
    const continueButton = document.getElementById('continueAfterSetOp');
    
    const arrayA = [...setOpArrays[0]];
    const arrayB = [...setOpArrays[1]];
    let resultArray = [];
    let step = 0;
    
    function performSetOpStep() {
        if (currentSetOpType === 'difference') {
            performDifferenceOperation();
        } else {
            performSymmetricDifferenceOperation();
        }
    }
    
    function performDifferenceOperation() {
        if (step === 0) {
            explanation.innerHTML = 'Step 1: Finding elements in Array A that are not in Array B';
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Initialize Set Difference operation (A - B)
                </div>
            `;
            step++;
            setTimeout(performDifferenceOperation, 1500);
            return;
        }
        
        if (step <= arrayA.length) {
            const currentIndex = step - 1;
            const currentElement = arrayA[currentIndex];
            
            explanation.innerHTML = `Step ${step + 1}: Checking if "${currentElement}" from Array A exists in Array B`;
            
            // Highlight current element in A
            const elementsA = arrayAContainer.querySelectorAll('.array-element');
            const currentElementA = elementsA[currentIndex].querySelector('.element-value');
            currentElementA.classList.add('set-operation-highlight');
            
            // Check if element exists in B
            const existsInB = arrayB.includes(currentElement);
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${!existsInB ? 'active' : ''}">
                    <strong>Step ${step + 1}:</strong> "${currentElement}" ${existsInB ? 'exists' : 'does not exist'} in Array B - ${existsInB ? 'EXCLUDE' : 'INCLUDE'}
                </div>
            `;
            
            setTimeout(() => {
                if (!existsInB) {
                    // Element doesn't exist in B - include in result
                    resultArray.push(currentElement);
                    renderArrayInContainer(resultArray, 'setResultArray');
                    
                    // Highlight as included
                    currentElementA.classList.remove('set-operation-highlight');
                    currentElementA.classList.add('set-operation-included');
                    
                    // Highlight in result
                    const resultElements = resultContainer.querySelectorAll('.array-element');
                    const newResultElement = resultElements[resultElements.length - 1].querySelector('.element-value');
                    newResultElement.classList.add('create', 'bounce');
                } else {
                    // Element exists in B - exclude from result
                    currentElementA.classList.remove('set-operation-highlight');
                    currentElementA.classList.add('set-operation-excluded');
                    
                    // Highlight corresponding element in B
                    const elementsB = arrayBContainer.querySelectorAll('.array-element');
                    const indexInB = arrayB.indexOf(currentElement);
                    if (indexInB !== -1) {
                        elementsB[indexInB].querySelector('.element-value').classList.add('set-operation-highlight');
                        setTimeout(() => {
                            elementsB[indexInB].querySelector('.element-value').classList.remove('set-operation-highlight');
                        }, 1000);
                    }
                }
                
                step++;
                performDifferenceOperation();
            }, 2000);
            
        } else {
            // Operation completed
            explanation.innerHTML = `<strong>Set Difference Completed!</strong> Found ${resultArray.length} elements in A but not in B`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> A - B = [${resultArray.join(', ')}]
                </div>
            `;
            
            // Show final result
            resultDiv.style.display = 'block';
            resultContent.innerHTML = `
                <p><strong>A - B:</strong> [${resultArray.join(', ')}]</p>
                <p><strong>B - A:</strong> [${arrayB.filter(x => !arrayA.includes(x)).join(', ')}]</p>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterSetOp();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSetOp);
        }
    }
    
    function performSymmetricDifferenceOperation() {
        if (step === 0) {
            explanation.innerHTML = 'Step 1: Calculating Symmetric Difference = (A - B)  (B - A)';
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Initialize Symmetric Difference operation
                </div>
            `;
            step++;
            setTimeout(performSymmetricDifferenceOperation, 1500);
            return;
        }
        
        if (step === 1) {
            // Calculate A - B
            explanation.innerHTML = 'Step 2: First, calculate A - B (elements in A but not in B)';
            
            const aMinusB = arrayA.filter(x => !arrayB.includes(x));
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 2:</strong> A - B = [${aMinusB.join(', ')}]
                </div>
            `;
            
            // Highlight A - B elements
            const elementsA = arrayAContainer.querySelectorAll('.array-element');
            arrayA.forEach((element, index) => {
                if (!arrayB.includes(element)) {
                    elementsA[index].querySelector('.element-value').classList.add('set-operation-included');
                }
            });
            
            step++;
            setTimeout(performSymmetricDifferenceOperation, 2000);
            return;
        }
        
        if (step === 2) {
            // Calculate B - A
            explanation.innerHTML = 'Step 3: Next, calculate B - A (elements in B but not in A)';
            
            const bMinusA = arrayB.filter(x => !arrayA.includes(x));
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 3:</strong> B - A = [${bMinusA.join(', ')}]
                </div>
            `;
            
            // Highlight B - A elements
            const elementsB = arrayBContainer.querySelectorAll('.array-element');
            arrayB.forEach((element, index) => {
                if (!arrayA.includes(element)) {
                    elementsB[index].querySelector('.element-value').classList.add('set-operation-included');
                }
            });
            
            step++;
            setTimeout(performSymmetricDifferenceOperation, 2000);
            return;
        }
        
        if (step === 3) {
            // Combine both differences
            explanation.innerHTML = 'Step 4: Combine A - B and B - A for Symmetric Difference';
            
            const aMinusB = arrayA.filter(x => !arrayB.includes(x));
            const bMinusA = arrayB.filter(x => !arrayA.includes(x));
            resultArray = [...aMinusB, ...bMinusA];
            
            renderArrayInContainer(resultArray, 'setResultArray');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 4:</strong> Symmetric Difference = (A - B)  (B - A) = [${resultArray.join(', ')}]
                </div>
            `;
            
            // Highlight result elements
            const resultElements = resultContainer.querySelectorAll('.array-element');
            resultElements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('create', 'bounce');
                }, index * 200);
            });
            
            step++;
            setTimeout(performSymmetricDifferenceOperation, 3000);
            return;
        }
        
        // Operation completed
        explanation.innerHTML = `<strong>Symmetric Difference Completed!</strong> Found ${resultArray.length} unique elements`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Final:</strong> A  B = [${resultArray.join(', ')}]
            </div>
        `;
        
        // Show final result
        resultDiv.style.display = 'block';
        resultContent.innerHTML = `
            <p><strong>A - B:</strong> [${arrayA.filter(x => !arrayB.includes(x)).join(', ')}]</p>
            <p><strong>B - A:</strong> [${arrayB.filter(x => !arrayA.includes(x)).join(', ')}]</p>
            <p><strong>A  B (Symmetric Difference):</strong> [${resultArray.join(', ')}]</p>
        `;
        
        continueButton.style.display = 'block';
        
        // Auto-return after 30 seconds
        setTimeout(() => {
            returnToOriginalAfterSetOp();
        }, 30000);
        
        continueButton.addEventListener('click', returnToOriginalAfterSetOp);
    }
    
    // Start set operation
    performSetOpStep();
}

// NEW: Return to Original after Set Operation
function returnToOriginalAfterSetOp() {
    // Reset to original array
    myArray = [...originalArrayBeforeSetOp];
    originalArrayBeforeSetOp = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isSetOpRunning = false;
    
    // Clear all set operation data
    setOpArrays = [];
    currentSetOpType = null;
    
    // Reset input groups
    setOperationsGroup.style.display = 'none';
    numArrays.value = '2';
    setArraysInputs.innerHTML = '';
    performSetOperationBtn.style.display = 'none';
    
    const operationName = currentSetOpType === 'difference' ? 'Set Difference' : 'Symmetric Difference';
    logOperation(`${operationName} completed - returned to original array`, 'info');
    showNotification(`Returned to original array after ${operationName.toLowerCase()} operation`, 'success');
}
// NEW: Check Subset Handler
function handleCheckSubsetComp() {
    if (isSubsetCompRunning) {
        showNotification('A subset check operation is already in progress', 'warning');
        return;
    }

    // Reset arrays
    subsetCompArrays = [];
    
    // Show input group
    subsetCompInputGroup.style.display = 'block';
    numArraysSubsetComp.focus();
    
    // Hide perform button initially
    performSubsetCompBtn.style.display = 'none';
    
    logOperation('Started subset comparison operation', 'info');
}

// NEW: Check Superset Handler
function handleCheckSupersetComp() {
    if (isSupersetCompRunning) {
        showNotification('A superset check operation is already in progress', 'warning');
        return;
    }

    // Reset arrays
    supersetCompArrays = [];
    
    // Show input group
    supersetCompInputGroup.style.display = 'block';
    numArraysSupersetComp.focus();
    
    // Hide perform button initially
    performSupersetCompBtn.style.display = 'none';
    
    logOperation('Started superset comparison operation', 'info');
}

// NEW: Confirm Number of Arrays for Subset
function handleConfirmNumArraysSubsetComp() {
    const numArrays = parseInt(numArraysSubsetComp.value);
    
    if (isNaN(numArrays) || numArrays < 2 || numArrays > 5) {
        showNotification('Please enter a valid number of arrays between 2 and 5', 'danger');
        numArraysSubsetComp.focus();
        return;
    }
    
    // Create input fields for each array
    subsetCompArraysInputs.innerHTML = '<h6>Enter Array Details:</h6>';
    for (let i = 0; i < numArrays; i++) {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'mb-3 subset-comp-container';
        arrayGroup.innerHTML = `
            <label class="form-label">Array ${i + 1} Details</label>
            <div class="input-group mb-2">
                <input type="number" class="form-control subset-comp-size" 
                       data-array-index="${i}" placeholder="Size of Array ${i + 1}" min="1" max="20">
                <button class="btn btn-glow confirm-subset-comp-size-btn" data-array-index="${i}">
                    <i class="fas fa-check me-2"></i>Set Size
                </button>
            </div>
            <div class="subset-comp-elements-inputs" id="subsetCompElementsInputs${i}"></div>
        `;
        subsetCompArraysInputs.appendChild(arrayGroup);
    }
    
    // Add event listeners for size confirmation buttons
    const sizeButtons = subsetCompArraysInputs.querySelectorAll('.confirm-subset-comp-size-btn');
    sizeButtons.forEach(btn => {
        btn.addEventListener('click', function() {
            const arrayIndex = parseInt(this.getAttribute('data-array-index'));
            handleConfirmSubsetCompSize(arrayIndex);
        });
    });
    
    // Add event listeners for size inputs
    const sizeInputs = subsetCompArraysInputs.querySelectorAll('.subset-comp-size');
    sizeInputs.forEach(input => {
        input.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                const arrayIndex = parseInt(this.getAttribute('data-array-index'));
                handleConfirmSubsetCompSize(arrayIndex);
            }
        });
    });
    
    showNotification(`Set up ${numArrays} arrays for subset comparison`, 'success');
}

// NEW: Confirm Number of Arrays for Superset
function handleConfirmNumArraysSupersetComp() {
    const numArrays = parseInt(numArraysSupersetComp.value);
    
    if (isNaN(numArrays) || numArrays < 2 || numArrays > 5) {
        showNotification('Please enter a valid number of arrays between 2 and 5', 'danger');
        numArraysSupersetComp.focus();
        return;
    }
    
    // Create input fields for each array
    supersetCompArraysInputs.innerHTML = '<h6>Enter Array Details:</h6>';
    for (let i = 0; i < numArrays; i++) {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'mb-3 superset-comp-container';
        arrayGroup.innerHTML = `
            <label class="form-label">Array ${i + 1} Details</label>
            <div class="input-group mb-2">
                <input type="number" class="form-control superset-comp-size" 
                       data-array-index="${i}" placeholder="Size of Array ${i + 1}" min="1" max="20">
                <button class="btn btn-glow confirm-superset-comp-size-btn" data-array-index="${i}">
                    <i class="fas fa-check me-2"></i>Set Size
                </button>
            </div>
            <div class="superset-comp-elements-inputs" id="supersetCompElementsInputs${i}"></div>
        `;
        supersetCompArraysInputs.appendChild(arrayGroup);
    }
    
    // Add event listeners for size confirmation buttons
    const sizeButtons = supersetCompArraysInputs.querySelectorAll('.confirm-superset-comp-size-btn');
    sizeButtons.forEach(btn => {
        btn.addEventListener('click', function() {
            const arrayIndex = parseInt(this.getAttribute('data-array-index'));
            handleConfirmSupersetCompSize(arrayIndex);
        });
    });
    
    // Add event listeners for size inputs
    const sizeInputs = supersetCompArraysInputs.querySelectorAll('.superset-comp-size');
    sizeInputs.forEach(input => {
        input.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                const arrayIndex = parseInt(this.getAttribute('data-array-index'));
                handleConfirmSupersetCompSize(arrayIndex);
            }
        });
    });
    
    showNotification(`Set up ${numArrays} arrays for superset comparison`, 'success');
}

// NEW: Confirm Subset Comparison Size
function handleConfirmSubsetCompSize(arrayIndex) {
    const sizeInput = document.querySelector(`.subset-comp-size[data-array-index="${arrayIndex}"]`);
    const size = parseInt(sizeInput.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification(`Please enter a valid size for Array ${arrayIndex + 1} between 1 and 20`, 'danger');
        sizeInput.focus();
        return;
    }
    
    // Create element input fields
    const elementsContainer = document.getElementById(`subsetCompElementsInputs${arrayIndex}`);
    elementsContainer.innerHTML = `<label class="form-label">Enter ${size} elements for Array ${arrayIndex + 1}:</label>`;
    
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="text" class="form-control subset-comp-element" 
                   data-array-index="${arrayIndex}" data-element-index="${i}" 
                   placeholder="Enter value">
        `;
        elementsContainer.appendChild(inputGroup);
    }
    
    // Add event listeners for element inputs
    const elementInputs = elementsContainer.querySelectorAll('.subset-comp-element');
    elementInputs.forEach(input => {
        input.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                // Auto-focus next input
                const nextInput = this.nextElementSibling;
                if (nextInput && nextInput.classList.contains('subset-comp-element')) {
                    nextInput.focus();
                }
            }
        });
    });
    
    showNotification(`Size ${size} set for Array ${arrayIndex + 1}. Please enter elements.`, 'success');
    
    // Check if all arrays have sizes set and show perform button
    checkAllSubsetCompSizesSet();
}

// NEW: Confirm Superset Comparison Size
function handleConfirmSupersetCompSize(arrayIndex) {
    const sizeInput = document.querySelector(`.superset-comp-size[data-array-index="${arrayIndex}"]`);
    const size = parseInt(sizeInput.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification(`Please enter a valid size for Array ${arrayIndex + 1} between 1 and 20`, 'danger');
        sizeInput.focus();
        return;
    }
    
    // Create element input fields
    const elementsContainer = document.getElementById(`supersetCompElementsInputs${arrayIndex}`);
    elementsContainer.innerHTML = `<label class="form-label">Enter ${size} elements for Array ${arrayIndex + 1}:</label>`;
    
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="text" class="form-control superset-comp-element" 
                   data-array-index="${arrayIndex}" data-element-index="${i}" 
                   placeholder="Enter value">
        `;
        elementsContainer.appendChild(inputGroup);
    }
    
    // Add event listeners for element inputs
    const elementInputs = elementsContainer.querySelectorAll('.superset-comp-element');
    elementInputs.forEach(input => {
        input.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                // Auto-focus next input
                const nextInput = this.nextElementSibling;
                if (nextInput && nextInput.classList.contains('superset-comp-element')) {
                    nextInput.focus();
                }
            }
        });
    });
    
    showNotification(`Size ${size} set for Array ${arrayIndex + 1}. Please enter elements.`, 'success');
    
    // Check if all arrays have sizes set and show perform button
    checkAllSupersetCompSizesSet();
}

// NEW: Check if all subset comparison sizes are set
function checkAllSubsetCompSizesSet() {
    const numArrays = parseInt(numArraysSubsetComp.value);
    let allSizesSet = true;
    
    for (let i = 0; i < numArrays; i++) {
        const elementsContainer = document.getElementById(`subsetCompElementsInputs${i}`);
        if (!elementsContainer || elementsContainer.innerHTML === '') {
            allSizesSet = false;
            break;
        }
    }
    
    if (allSizesSet) {
        performSubsetCompBtn.style.display = 'block';
    }
}

// NEW: Check if all superset comparison sizes are set
function checkAllSupersetCompSizesSet() {
    const numArrays = parseInt(numArraysSupersetComp.value);
    let allSizesSet = true;
    
    for (let i = 0; i < numArrays; i++) {
        const elementsContainer = document.getElementById(`supersetCompElementsInputs${i}`);
        if (!elementsContainer || elementsContainer.innerHTML === '') {
            allSizesSet = false;
            break;
        }
    }
    
    if (allSizesSet) {
        performSupersetCompBtn.style.display = 'block';
    }
}

// NEW: Perform Subset Check
function handlePerformSubsetComp() {
    const numArrays = parseInt(numArraysSubsetComp.value);
    subsetCompArrays = [];
    
    // Collect all arrays
    for (let i = 0; i < numArrays; i++) {
        const elementInputs = document.querySelectorAll(`.subset-comp-element[data-array-index="${i}"]`);
        const array = [];
        
        for (let j = 0; j < elementInputs.length; j++) {
            const value = elementInputs[j].value.trim();
            if (value === '') {
                showNotification(`Please enter all elements for Array ${i + 1}. Missing element at position ${j}`, 'danger');
                elementInputs[j].focus();
                return;
            }
            array.push(value);
        }
        
        subsetCompArrays.push(array);
    }
    
    // Store original array
    originalArrayForSubsetComp = [...myArray];
    
    // Hide input group
    subsetCompInputGroup.style.display = 'none';
    
    // Start subset comparison visualization
    showSubsetCompVisualization();
}

// NEW: Perform Superset Check
function handlePerformSupersetComp() {
    const numArrays = parseInt(numArraysSupersetComp.value);
    supersetCompArrays = [];
    
    // Collect all arrays
    for (let i = 0; i < numArrays; i++) {
        const elementInputs = document.querySelectorAll(`.superset-comp-element[data-array-index="${i}"]`);
        const array = [];
        
        for (let j = 0; j < elementInputs.length; j++) {
            const value = elementInputs[j].value.trim();
            if (value === '') {
                showNotification(`Please enter all elements for Array ${i + 1}. Missing element at position ${j}`, 'danger');
                elementInputs[j].focus();
                return;
            }
            array.push(value);
        }
        
        supersetCompArrays.push(array);
    }
    
    // Store original array
    originalArrayForSupersetComp = [...myArray];
    
    // Hide input group
    supersetCompInputGroup.style.display = 'none';
    
    // Start superset comparison visualization
    showSupersetCompVisualization();
}

// NEW: Cancel Subset Check
function handleCancelSubsetComp() {
    subsetCompInputGroup.style.display = 'none';
    numArraysSubsetComp.value = '2';
    subsetCompArraysInputs.innerHTML = '';
    performSubsetCompBtn.style.display = 'none';
    subsetCompArrays = [];
    
    logOperation('Cancelled subset comparison operation', 'info');
    showNotification('Subset comparison cancelled', 'info');
}

// NEW: Cancel Superset Check
function handleCancelSupersetComp() {
    supersetCompInputGroup.style.display = 'none';
    numArraysSupersetComp.value = '2';
    supersetCompArraysInputs.innerHTML = '';
    performSupersetCompBtn.style.display = 'none';
    supersetCompArrays = [];
    
    logOperation('Cancelled superset comparison operation', 'info');
    showNotification('Superset comparison cancelled', 'info');
}

// NEW: Show Subset Comparison Visualization
function showSubsetCompVisualization() {
    isSubsetCompRunning = true;
    
    const container = document.createElement('div');
    container.className = 'dual-operation-container';
    container.innerHTML = `
        <h5 class="text-center mb-3">Subset Comparison Operation</h5>
        
        <div id="subsetCompArraysDisplay" class="mb-4"></div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Subset Check:</strong> Checking if arrays are subsets of each other</p>
            <p class="mb-0" id="subsetCompExplanation">Starting subset comparison...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="subsetCompStepsContainer">
            <h6 class="text-center">Subset Comparison Steps</h6>
            <div class="steps-container" id="subsetCompSteps"></div>
        </div>
        
        <div id="subsetCompResults" class="mt-3"></div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSubsetComp">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(container);
    
    // Display all arrays
    displaySubsetCompArrays();
    
    // Start subset comparison animation
    performSubsetCompAnimation();
}

// NEW: Show Superset Comparison Visualization
function showSupersetCompVisualization() {
    isSupersetCompRunning = true;
    
    const container = document.createElement('div');
    container.className = 'dual-operation-container';
    container.innerHTML = `
        <h5 class="text-center mb-3">Superset Comparison Operation</h5>
        
        <div id="supersetCompArraysDisplay" class="mb-4"></div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Superset Check:</strong> Checking if arrays are supersets of each other</p>
            <p class="mb-0" id="supersetCompExplanation">Starting superset comparison...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="supersetCompStepsContainer">
            <h6 class="text-center">Superset Comparison Steps</h6>
            <div class="steps-container" id="supersetCompSteps"></div>
        </div>
        
        <div id="supersetCompResults" class="mt-3"></div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSupersetComp">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(container);
    
    // Display all arrays
    displaySupersetCompArrays();
    
    // Start superset comparison animation
    performSupersetCompAnimation();
}

// NEW: Display Subset Comparison Arrays
function displaySubsetCompArrays() {
    const displayContainer = document.getElementById('subsetCompArraysDisplay');
    displayContainer.innerHTML = '';
    
    subsetCompArrays.forEach((array, index) => {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'array-group mb-4';
        arrayGroup.innerHTML = `
            <div class="array-label">Array ${index + 1} (Size: ${array.length})</div>
            <div class="original-array-container" id="subsetCompArray${index}"></div>
        `;
        displayContainer.appendChild(arrayGroup);
        renderArrayInContainer(array, `subsetCompArray${index}`);
    });
}

// NEW: Display Superset Comparison Arrays
function displaySupersetCompArrays() {
    const displayContainer = document.getElementById('supersetCompArraysDisplay');
    displayContainer.innerHTML = '';
    
    supersetCompArrays.forEach((array, index) => {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'array-group mb-4';
        arrayGroup.innerHTML = `
            <div class="array-label">Array ${index + 1} (Size: ${array.length})</div>
            <div class="original-array-container" id="supersetCompArray${index}"></div>
        `;
        displayContainer.appendChild(arrayGroup);
        renderArrayInContainer(array, `supersetCompArray${index}`);
    });
}

// NEW: Perform Subset Comparison Animation
function performSubsetCompAnimation() {
    const explanation = document.getElementById('subsetCompExplanation');
    const stepsContainer = document.getElementById('subsetCompSteps');
    const resultsContainer = document.getElementById('subsetCompResults');
    const continueButton = document.getElementById('continueAfterSubsetComp');
    
    let currentComparison = 0;
    const totalComparisons = subsetCompArrays.length * (subsetCompArrays.length - 1);
    
    function performComparisonStep() {
        if (currentComparison >= totalComparisons) {
            // All comparisons completed
            explanation.innerHTML = '<strong>Subset Comparison Completed!</strong>';
            
            // Show final results
            displaySubsetCompFinalResults(resultsContainer);
            
            continueButton.style.display = 'block';
            continueButton.addEventListener('click', returnToOriginalAfterSubsetComp);
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterSubsetComp();
            }, 10000);
            
            return;
        }
        
        const i = Math.floor(currentComparison / (subsetCompArrays.length - 1));
        const j = currentComparison % (subsetCompArrays.length - 1);
        const actualJ = j >= i ? j + 1 : j;
        
        if (i !== actualJ) {
            explanation.innerHTML = `Checking if Array ${i + 1} is subset of Array ${actualJ + 1}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${currentComparison + 1}:</strong> Checking if Array ${i + 1}  Array ${actualJ + 1}
                </div>
            `;
            
            // Perform the subset check with animation
            checkSubsetWithAnimation(i, actualJ, stepsContainer, () => {
                currentComparison++;
                performComparisonStep();
            });
        } else {
            currentComparison++;
            performComparisonStep();
        }
    }
    
    // Start comparison process
    performComparisonStep();
}

// NEW: Perform Superset Comparison Animation
function performSupersetCompAnimation() {
    const explanation = document.getElementById('supersetCompExplanation');
    const stepsContainer = document.getElementById('supersetCompSteps');
    const resultsContainer = document.getElementById('supersetCompResults');
    const continueButton = document.getElementById('continueAfterSupersetComp');
    
    let currentComparison = 0;
    const totalComparisons = supersetCompArrays.length * (supersetCompArrays.length - 1);
    
    function performComparisonStep() {
        if (currentComparison >= totalComparisons) {
            // All comparisons completed
            explanation.innerHTML = '<strong>Superset Comparison Completed!</strong>';
            
            // Show final results
            displaySupersetCompFinalResults(resultsContainer);
            
            continueButton.style.display = 'block';
            continueButton.addEventListener('click', returnToOriginalAfterSupersetComp);
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterSupersetComp();
            }, 10000);
            
            return;
        }
        
        const i = Math.floor(currentComparison / (supersetCompArrays.length - 1));
        const j = currentComparison % (supersetCompArrays.length - 1);
        const actualJ = j >= i ? j + 1 : j;
        
        if (i !== actualJ) {
            explanation.innerHTML = `Checking if Array ${i + 1} is superset of Array ${actualJ + 1}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${currentComparison + 1}:</strong> Checking if Array ${i + 1}  Array ${actualJ + 1}
                </div>
            `;
            
            // Perform the superset check with animation
            checkSupersetWithAnimation(i, actualJ, stepsContainer, () => {
                currentComparison++;
                performComparisonStep();
            });
        } else {
            currentComparison++;
            performComparisonStep();
        }
    }
    
    // Start comparison process
    performComparisonStep();
}

// NEW: Check Subset with Animation
function checkSubsetWithAnimation(i, j, stepsContainer, callback) {
    const arr1 = subsetCompArrays[i];
    const arr2 = subsetCompArrays[j];
    let allElementsFound = true;
    let currentElement = 0;
    
    function checkNextElement() {
        if (currentElement >= arr1.length) {
            // All elements checked
            const result = allElementsFound;
            const message = result ? 
                `<span class="text-success">Yes, it is true! Array ${i + 1} is subset of Array ${j + 1}</span>` :
                `<span class="text-danger">No, it is false! Array ${i + 1} is not subset of Array ${j + 1}</span>`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${result ? 'active' : ''}">
                    <strong>Result:</strong> ${message}
                </div>
            `;
            
            callback();
            return;
        }
        
        const element = arr1[currentElement];
        let found = false;
        
        // Highlight current element in arr1
        const arr1Container = document.getElementById(`subsetCompArray${i}`);
        const arr1Elements = arr1Container.querySelectorAll('.array-element');
        arr1Elements[currentElement].querySelector('.element-value').classList.add('subset-comp-element-match');
        
        // Search for element in arr2
        searchElementInArray(j, element, (foundIndex) => {
            if (foundIndex !== -1) {
                found = true;
            } else {
                allElementsFound = false;
                arr1Elements[currentElement].querySelector('.element-value').classList.remove('subset-comp-element-match');
                arr1Elements[currentElement].querySelector('.element-value').classList.add('subset-comp-element-not-found');
            }
            
            currentElement++;
            setTimeout(checkNextElement, 1000);
        });
    }
    
    // Start checking elements
    checkNextElement();
}

// NEW: Check Superset with Animation
function checkSupersetWithAnimation(i, j, stepsContainer, callback) {
    const arr1 = supersetCompArrays[i];
    const arr2 = supersetCompArrays[j];
    let allElementsFound = true;
    let currentElement = 0;
    
    function checkNextElement() {
        if (currentElement >= arr2.length) {
            // All elements checked
            const result = allElementsFound;
            const message = result ? 
                `<span class="text-success">Yes, it is true! Array ${i + 1} is superset of Array ${j + 1}</span>` :
                `<span class="text-danger">No, it is false! Array ${i + 1} is not superset of Array ${j + 1}</span>`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${result ? 'active' : ''}">
                    <strong>Result:</strong> ${message}
                </div>
            `;
            
            callback();
            return;
        }
        
        const element = arr2[currentElement];
        let found = false;
        
        // Highlight current element in arr2
        const arr2Container = document.getElementById(`supersetCompArray${j}`);
        const arr2Elements = arr2Container.querySelectorAll('.array-element');
        arr2Elements[currentElement].querySelector('.element-value').classList.add('superset-comp-element-match');
        
        // Search for element in arr1
        searchElementInSupersetArray(i, element, (foundIndex) => {
            if (foundIndex !== -1) {
                found = true;
            } else {
                allElementsFound = false;
                arr2Elements[currentElement].querySelector('.element-value').classList.remove('superset-comp-element-match');
                arr2Elements[currentElement].querySelector('.element-value').classList.add('subset-comp-element-not-found');
            }
            
            currentElement++;
            setTimeout(checkNextElement, 1000);
        });
    }
    
    // Start checking elements
    checkNextElement();
}

// NEW: Search Element in Array for Subset
function searchElementInArray(arrayIndex, element, callback) {
    const arr = subsetCompArrays[arrayIndex];
    const container = document.getElementById(`subsetCompArray${arrayIndex}`);
    const elements = container.querySelectorAll('.array-element');
    let currentIndex = 0;
    
    function searchNext() {
        if (currentIndex >= arr.length) {
            callback(-1); // Element not found
            return;
        }
        
        // Highlight current element being checked
        elements[currentIndex].querySelector('.element-value').classList.add('search');
        
        setTimeout(() => {
            if (arr[currentIndex] === element) {
                // Element found
                elements[currentIndex].querySelector('.element-value').classList.remove('search');
                elements[currentIndex].querySelector('.element-value').classList.add('subset-comp-element-match');
                callback(currentIndex);
            } else {
                // Element not found at this position
                elements[currentIndex].querySelector('.element-value').classList.remove('search');
                currentIndex++;
                searchNext();
            }
        }, 500);
    }
    
    searchNext();
}

// NEW: Search Element in Array for Superset
function searchElementInSupersetArray(arrayIndex, element, callback) {
    const arr = supersetCompArrays[arrayIndex];
    const container = document.getElementById(`supersetCompArray${arrayIndex}`);
    const elements = container.querySelectorAll('.array-element');
    let currentIndex = 0;
    
    function searchNext() {
        if (currentIndex >= arr.length) {
            callback(-1); // Element not found
            return;
        }
        
        // Highlight current element being checked
        elements[currentIndex].querySelector('.element-value').classList.add('search');
        
        setTimeout(() => {
            if (arr[currentIndex] === element) {
                // Element found
                elements[currentIndex].querySelector('.element-value').classList.remove('search');
                elements[currentIndex].querySelector('.element-value').classList.add('superset-comp-element-match');
                callback(currentIndex);
            } else {
                // Element not found at this position
                elements[currentIndex].querySelector('.element-value').classList.remove('search');
                currentIndex++;
                searchNext();
            }
        }, 500);
    }
    
    searchNext();
}

// NEW: Display Subset Comparison Final Results
function displaySubsetCompFinalResults(container) {
    let resultsHTML = '<h6 class="text-center">Subset Comparison Results</h6>';
    
    for (let i = 0; i < subsetCompArrays.length; i++) {
        for (let j = 0; j < subsetCompArrays.length; j++) {
            if (i !== j) {
                const isSubset = isArraySubset(subsetCompArrays[i], subsetCompArrays[j]);
                const resultClass = isSubset ? 'text-success' : 'text-danger';
                const resultText = isSubset ? 'Yes' : 'No';
                resultsHTML += `
                    <div class="algorithm-step ${isSubset ? 'active' : ''}">
                        <strong>Array ${i + 1}  Array ${j + 1}:</strong> 
                        <span class="${resultClass}">${resultText}</span>
                    </div>
                `;
            }
        }
    }
    
    container.innerHTML = resultsHTML;
}

// NEW: Display Superset Comparison Final Results
function displaySupersetCompFinalResults(container) {
    let resultsHTML = '<h6 class="text-center">Superset Comparison Results</h6>';
    
    for (let i = 0; i < supersetCompArrays.length; i++) {
        for (let j = 0; j < supersetCompArrays.length; j++) {
            if (i !== j) {
                const isSuperset = isArraySubset(supersetCompArrays[j], supersetCompArrays[i]); // A is superset of B if B is subset of A
                const resultClass = isSuperset ? 'text-success' : 'text-danger';
                const resultText = isSuperset ? 'Yes' : 'No';
                resultsHTML += `
                    <div class="algorithm-step ${isSuperset ? 'active' : ''}">
                        <strong>Array ${i + 1}  Array ${j + 1}:</strong> 
                        <span class="${resultClass}">${resultText}</span>
                    </div>
                `;
            }
        }
    }
    
    container.innerHTML = resultsHTML;
}

// NEW: Utility function to check if array is subset
function isArraySubset(arr1, arr2) {
    // Create copies to avoid modifying original arrays
    const copyArr2 = [...arr2];
    
    for (let element of arr1) {
        const index = copyArr2.indexOf(element);
        if (index === -1) {
            return false;
        }
        // Remove the found element to handle duplicates
        copyArr2.splice(index, 1);
    }
    return true;
}

// NEW: Return to Original after Subset Comparison
function returnToOriginalAfterSubsetComp() {
    // Reset to original array
    myArray = [...originalArrayForSubsetComp];
    originalArrayForSubsetComp = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isSubsetCompRunning = false;
    
    // Clear all subset comparison data
    subsetCompArrays = [];
    
    logOperation('Subset comparison completed - returned to original array', 'info');
    showNotification('Returned to original array after subset comparison', 'success');
}

// NEW: Return to Original after Superset Comparison
function returnToOriginalAfterSupersetComp() {
    // Reset to original array
    myArray = [...originalArrayForSupersetComp];
    originalArrayForSupersetComp = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isSupersetCompRunning = false;
    
    // Clear all superset comparison data
    supersetCompArrays = [];
    
    logOperation('Superset comparison completed - returned to original array', 'info');
    showNotification('Returned to original array after superset comparison', 'success');
}
// NEW: Generate Memory Address
function generateMemoryAddress() {
    // Generate a realistic-looking memory address
    const prefix = '0x';
    const address = Math.floor(Math.random() * 0xFFFFFFFF).toString(16).toUpperCase().padStart(8, '0');
    return prefix + address;
}

// NEW: Update Memory Address Display
function updateMemoryAddress() {
    if (myArray.length === 0) {
        memoryAddress.textContent = '-';
        currentMemoryAddress = '';
        return;
    }
    
    // Generate or retrieve memory address for current array
    const arrayKey = myArray.join(',');
    if (!memoryAddresses.has(arrayKey)) {
        memoryAddresses.set(arrayKey, generateMemoryAddress());
    }
    
    currentMemoryAddress = memoryAddresses.get(arrayKey);
    memoryAddress.textContent = currentMemoryAddress;
}

// NEW: Show Memory Address Details
function showMemoryAddressDetails() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    const detailsContainer = document.createElement('div');
    detailsContainer.className = 'memory-address-details';
    detailsContainer.innerHTML = `
        <h5 class="text-center mb-3">Memory Address Details</h5>
        
        <div class="stats-card mb-3">
            <div>Base Memory Address</div>
            <div class="stats-value">${currentMemoryAddress}</div>
        </div>
        
        <div class="memory-address-table-container">
            <table class="memory-address-table">
                <thead>
                    <tr>
                        <th>Index</th>
                        <th>Element</th>
                        <th>Memory Address</th>
                        <th>Offset</th>
                    </tr>
                </thead>
                <tbody id="memoryAddressTableBody">
                    <!-- Memory addresses will be populated here -->
                </tbody>
            </table>
        </div>
        
        <div class="algorithm-explanation mt-3">
            <h6>Memory Addressing Explanation</h6>
            <p>Each array element is stored in consecutive memory locations:</p>
            <div class="code-snippet">
                Base Address: ${currentMemoryAddress}<br>
                Element Size: 4 bytes (typical for integers)<br>
                Address Calculation: Base + (Index  Element Size)
            </div>
        </div>
        
        <div class="d-grid gap-2 mt-3">
            <button class="btn btn-glow" id="goBackToArrayBtn">
                <i class="fas fa-arrow-left me-2"></i>Go Back to Original Array
            </button>
        </div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(detailsContainer);
    
    // Populate memory address table
    populateMemoryAddressTable();
    
    // Add go back button event listener
    document.getElementById('goBackToArrayBtn').addEventListener('click', () => {
        renderArray();
        updateStats();
    });
}

// NEW: Populate Memory Address Table
function populateMemoryAddressTable() {
    const tableBody = document.getElementById('memoryAddressTableBody');
    tableBody.innerHTML = '';
    
    const baseAddress = parseInt(currentMemoryAddress, 16);
    const elementSize = 4; // 4 bytes per element
    
    myArray.forEach((element, index) => {
        const offset = index * elementSize;
        const elementAddress = '0x' + (baseAddress + offset).toString(16).toUpperCase().padStart(8, '0');
        
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${index}</td>
            <td>${element}</td>
            <td>${elementAddress}</td>
            <td>+${offset} bytes</td>
        `;
        tableBody.appendChild(row);
    });
}

// NEW: Highlight Memory Address in Array
function highlightMemoryAddress(index) {
    const elements = document.querySelectorAll('.array-element');
    if (index >= 0 && index < elements.length) {
        // Remove previous highlights
        elements.forEach(el => {
            el.querySelector('.element-value').classList.remove('memory-address-highlight');
        });
        
        // Highlight current element
        const element = elements[index].querySelector('.element-value');
        element.classList.add('memory-address-highlight');
        
        // Show memory address details
        const baseAddress = parseInt(currentMemoryAddress, 16);
        const elementAddress = '0x' + (baseAddress + (index * 4)).toString(16).toUpperCase().padStart(8, '0');
        
        searchResults.innerHTML = `
            <p class="mb-1 text-success"><strong>Memory Address Found</strong></p>
            <p class="mb-1">Element: "${myArray[index]}" at index ${index}</p>
            <p class="mb-1">Memory Address: ${elementAddress}</p>
            <p class="mb-0">Offset: +${index * 4} bytes from base ${currentMemoryAddress}</p>
        `;
        
        // Automatically remove highlight and return to original position after animation
        setTimeout(() => {
            element.classList.remove('memory-address-highlight');
            
            // Clear search results after animation
            setTimeout(() => {
                searchResults.innerHTML = '<p class="text-center mb-0">Search results will appear here</p>';
            }, 1000);
            
        }, 2000); // Remove highlight after 2 seconds
    }
}

// NEW: Add Memory Address Button to UI
function addMemoryAddressButton() {
    // Add button to Read tab
    const readTab = document.getElementById('read');
    const memoryButton = document.createElement('div');
    memoryButton.className = 'mb-3';
    memoryButton.innerHTML = `
        <label class="form-label">Memory Address Operations</label>
        <div class="input-group mb-2">
            <button class="btn btn-glow" id="showMemoryDetailsBtn">
                <i class="fas fa-memory me-2"></i>Show Memory Addresses
            </button>
        </div>
        <div class="input-group mb-2">
            <input type="number" class="form-control" id="memoryIndex" placeholder="Index to check memory" min="0">
            <button class="btn btn-glow" id="checkMemoryAddressBtn">
                <i class="fas fa-search me-2"></i>Check Memory Address
            </button>
        </div>
    `;
    
    // Insert after existing content in Read tab
    const existingContent = readTab.querySelector('.mb-3:last-child');
    existingContent.parentNode.insertBefore(memoryButton, existingContent.nextSibling);
    
    // Add event listeners
    document.getElementById('showMemoryDetailsBtn').addEventListener('click', showMemoryAddressDetails);
    document.getElementById('checkMemoryAddressBtn').addEventListener('click', handleCheckMemoryAddress);
    
    // Add Enter key support
    document.getElementById('memoryIndex').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') handleCheckMemoryAddress();
    });
}

// NEW: Handle Check Memory Address
function handleCheckMemoryAddress() {
    const index = parseInt(document.getElementById('memoryIndex').value);
    
    if (isNaN(index) || index < 0 || index >= myArray.length) {
        showNotification(`Please enter a valid index between 0 and ${myArray.length - 1}`, 'danger');
        document.getElementById('memoryIndex').focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    highlightMemoryAddress(index);
    logOperation(`Checked memory address for element at index ${index}`, 'info');
    
    // Clear the input field after operation
    document.getElementById('memoryIndex').value = '';
}

// Update the updateStats function to include memory address
function updateStats() {
    arrayLength.textContent = myArray.length;
    firstElement.textContent = myArray.length > 0 ? myArray[0] : '-';
    lastElement.textContent = myArray.length > 0 ? myArray[myArray.length - 1] : '-';
    totalOperations.textContent = operationCount;
    
    // Calculate sum and product
    let sum = 0;
    let product = 1;
    let allNumbers = true;
    
    myArray.forEach(element => {
        const num = parseFloat(element);
        if (!isNaN(num)) {
            sum += num;
            product *= num;
        } else {
            allNumbers = false;
        }
    });
    
    if (allNumbers && myArray.length > 0) {
        sumElements.textContent = sum;
        productElements.textContent = product;
    } else {
        sumElements.textContent = 'N/A';
        productElements.textContent = 'N/A';
    }
    
    // Update memory address
    updateMemoryAddress();
}
// Initialize memory address system
function initializeMemorySystem() {
    addMemoryAddressButton();
    updateMemoryAddress();
}
// Call this after DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    // ... existing initialization code ...
    initializeMemorySystem();
});   
// NEW: Find First Element > x or Last Element < x Handler
function handleFindComparison(type) {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isComparisonRunning) {
        showNotification('A comparison operation is already in progress', 'warning');
        return;
    }
    
    // Get the x value based on the type
    const xInput = type === 'greater' ? comparisonValue.value.trim() : comparisonValueLess.value.trim();
    
    if (xInput === '') {
        showNotification(`Please enter a value for x`, 'danger');
        if (type === 'greater') {
            comparisonValue.focus();
        } else {
            comparisonValueLess.focus();
        }
        return;
    }
    
    // Try to convert to number, but keep as string if not numeric
    let x;
    const isNumeric = !isNaN(parseFloat(xInput)) && isFinite(xInput);
    if (isNumeric) {
        x = parseFloat(xInput);
    } else {
        x = xInput;
    }
    
    // Store original array
    originalArrayForComparison = [...myArray];
    
    // Perform comparison search
    performComparisonSearch(type, x, isNumeric);
}

// NEW: Perform Comparison Search with Animation
function performComparisonSearch(type, x, isNumeric) {
    isComparisonRunning = true;
    
    const operationName = type === 'greater' ? 'First Element > x' : 'Last Element < x';
    const comparisonSymbol = type === 'greater' ? '>' : '<';
    
    // Create visualization container
    const visualContainer = document.createElement('div');
    visualContainer.className = 'dual-operation-container';
    visualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find ${operationName} (${comparisonSymbol} ${x})</h5>
        
        <div class="array-group">
            <div class="array-label">Searching Array</div>
            <div class="original-array-container" id="comparisonArray"></div>
        </div>
        
        <div class="comparison-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Finding ${type === 'greater' ? 'first element greater than' : 'last element less than'} ${x}</p>
            <p class="mb-0" id="comparisonExplanation">Starting search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="comparisonStepsContainer">
            <h6 class="text-center">Search Steps</h6>
            <div class="steps-container" id="comparisonSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Result</div>
            <div class="stats-value" id="comparisonResult">Searching...</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterComparison" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(visualContainer);
    
    renderArrayInContainer(originalArrayForComparison, 'comparisonArray');
    
    executeComparisonSearch(type, x, isNumeric);
}

// NEW: Execute Comparison Search Algorithm
function executeComparisonSearch(type, x, isNumeric) {
    const arrayContainer = document.getElementById('comparisonArray');
    const explanation = document.getElementById('comparisonExplanation');
    const stepsContainer = document.getElementById('comparisonSteps');
    const resultElement = document.getElementById('comparisonResult');
    const continueButton = document.getElementById('continueAfterComparison');
    
    const arr = [...originalArrayForComparison];
    let foundIndex = -1;
    let foundValue = null;
    let currentStep = 0;
    
    function executeComparisonStep(i) {
        if (type === 'greater') {
            // Find first element > x
            if (i >= arr.length) {
                // Search completed - not found
                explanation.innerHTML = `<strong>Search Completed!</strong> No element found that is greater than ${x}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> No element greater than ${x} found in the array
                    </div>
                `;
                
                resultElement.innerHTML = `<span class="text-danger">Not Found</span>`;
                resultElement.classList.add('text-danger');
                
                // Highlight all elements as checked but not found
                const elements = arrayContainer.querySelectorAll('.array-element');
                elements.forEach(el => {
                    el.querySelector('.element-value').classList.add('comparison-checked');
                });
                
                continueButton.style.display = 'block';
                continueButton.addEventListener('click', returnToOriginalAfterComparison);
                
                // Auto-return after 5 seconds
                setTimeout(() => {
                    returnToOriginalAfterComparison();
                }, 5000);
                
                return;
            }
            
            currentStep++;
            explanation.innerHTML = `Step ${currentStep}: Checking element at index ${i} = ${arr[i]}`;
            
            // Highlight current element
            const elements = arrayContainer.querySelectorAll('.array-element');
            const currentElement = elements[i].querySelector('.element-value');
            currentElement.classList.add('comparison-current');
            
            // Compare values
            let comparisonResult;
            if (isNumeric) {
                const currentVal = parseFloat(arr[i]);
                comparisonResult = currentVal > x;
            } else {
                comparisonResult = arr[i] > x;
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${comparisonResult ? 'active' : ''}">
                    <strong>Step ${currentStep}:</strong> Compare ${arr[i]} ${comparisonResult ? '>' : ''} ${x} - 
                    ${comparisonResult ? 'FOUND!' : 'Continue searching...'}
                </div>
            `;
            
            setTimeout(() => {
                if (comparisonResult) {
                    // Element found
                    foundIndex = i;
                    foundValue = arr[i];
                    
                    explanation.innerHTML = `<strong>Element Found!</strong> First element greater than ${x} is at index ${i}: ${arr[i]}`;
                    
                    // Highlight found element
                    currentElement.classList.remove('comparison-current');
                    currentElement.classList.add('comparison-found');
                    
                    // Highlight previous checked elements
                    for (let j = 0; j < i; j++) {
                        elements[j].querySelector('.element-value').classList.add('comparison-checked');
                    }
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Success:</strong> Found ${arr[i]} at index ${i} (first element > ${x})
                        </div>
                    `;
                    
                    resultElement.innerHTML = `Found: ${arr[i]} at index ${i}`;
                    resultElement.classList.add('text-success');
                    
                    continueButton.style.display = 'block';
                    continueButton.addEventListener('click', returnToOriginalAfterComparison);
                    
                    // Auto-return after 5 seconds
                    setTimeout(() => {
                        returnToOriginalAfterComparison();
                    }, 5000);
                    
                } else {
                    // Continue searching
                    currentElement.classList.remove('comparison-current');
                    currentElement.classList.add('comparison-checked');
                    
                    // Move to next element
                    executeComparisonStep(i + 1);
                }
            }, 1500);
            
        } else {
            // Find last element < x
            if (i < 0) {
                // Search completed - not found
                explanation.innerHTML = `<strong>Search Completed!</strong> No element found that is less than ${x}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> No element less than ${x} found in the array
                    </div>
                `;
                
                resultElement.innerHTML = `<span class="text-danger">Not Found</span>`;
                resultElement.classList.add('text-danger');
                
                // Highlight all elements as checked but not found
                const elements = arrayContainer.querySelectorAll('.array-element');
                elements.forEach(el => {
                    el.querySelector('.element-value').classList.add('comparison-checked');
                });
                
                continueButton.style.display = 'block';
                continueButton.addEventListener('click', returnToOriginalAfterComparison);
                
                // Auto-return after 5 seconds
                setTimeout(() => {
                    returnToOriginalAfterComparison();
                }, 5000);
                
                return;
            }
            
            currentStep++;
            explanation.innerHTML = `Step ${currentStep}: Checking element at index ${i} = ${arr[i]}`;
            
            // Highlight current element
            const elements = arrayContainer.querySelectorAll('.array-element');
            const currentElement = elements[i].querySelector('.element-value');
            currentElement.classList.add('comparison-current');
            
            // Compare values
            let comparisonResult;
            if (isNumeric) {
                const currentVal = parseFloat(arr[i]);
                comparisonResult = currentVal < x;
            } else {
                comparisonResult = arr[i] < x;
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${comparisonResult ? 'active' : ''}">
                    <strong>Step ${currentStep}:</strong> Compare ${arr[i]} ${comparisonResult ? '<' : ''} ${x} - 
                    ${comparisonResult ? 'FOUND!' : 'Continue searching...'}
                </div>
            `;
            
            setTimeout(() => {
                if (comparisonResult) {
                    // Element found
                    foundIndex = i;
                    foundValue = arr[i];
                    
                    explanation.innerHTML = `<strong>Element Found!</strong> Last element less than ${x} is at index ${i}: ${arr[i]}`;
                    
                    // Highlight found element
                    currentElement.classList.remove('comparison-current');
                    currentElement.classList.add('comparison-found');
                    
                    // Highlight remaining checked elements
                    for (let j = arr.length - 1; j > i; j--) {
                        elements[j].querySelector('.element-value').classList.add('comparison-checked');
                    }
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Success:</strong> Found ${arr[i]} at index ${i} (last element < ${x})
                        </div>
                    `;
                    
                    resultElement.innerHTML = `Found: ${arr[i]} at index ${i}`;
                    resultElement.classList.add('text-success');
                    
                    continueButton.style.display = 'block';
                    continueButton.addEventListener('click', returnToOriginalAfterComparison);
                    
                    // Auto-return after 5 seconds
                    setTimeout(() => {
                        returnToOriginalAfterComparison();
                    }, 5000);
                    
                } else {
                    // Continue searching
                    currentElement.classList.remove('comparison-current');
                    currentElement.classList.add('comparison-checked');
                    
                    // Move to previous element
                    executeComparisonStep(i - 1);
                }
            }, 1500);
        }
    }
    
    // Start search from appropriate end based on type
    if (type === 'greater') {
        // Start from beginning for first element > x
        executeComparisonStep(0);
    } else {
        // Start from end for last element < x
        executeComparisonStep(arr.length - 1);
    }
}

// NEW: Return to Original after Comparison Search
function returnToOriginalAfterComparison() {
    // Reset to original array
    myArray = [...originalArrayForComparison];
    originalArrayForComparison = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isComparisonRunning = false;
    
    // Clear inputs
    comparisonValue.value = '';
    comparisonValueLess.value = '';
    
    logOperation('Comparison search completed - returned to original array', 'info');
    showNotification('Returned to original array after comparison search', 'success');
}
// NEW: Handle Statistical Operation
function handleStatisticalOperation(operation) {
    if (isStatisticalOperationRunning) {
        showNotification('A statistical operation is already in progress', 'warning');
        return;
    }

    currentStatisticalOperation = operation;
    statisticalArrays = [];
    statisticalArrayNames = [];
    
    // Show input group
    covarianceCorrelationGroup.style.display = 'block';
    operationTitle.textContent = operation === 'covariance' ? 'Covariance Operation' : 'Correlation Coefficient Operation';
    
    // Reset and focus on array count input
    arrayCountInput.value = '2';
    arrayDetailsContainer.innerHTML = '';
    performStatisticalOperationBtn.style.display = 'none';
    arrayCountInput.focus();

    logOperation(`Started ${operation} operation`, 'info');
}

// NEW: Confirm Array Count Handler
function handleConfirmArrayCount() {
    const arrayCount = parseInt(arrayCountInput.value);
    
    if (isNaN(arrayCount) || arrayCount < 2 || arrayCount > 5) {
        showNotification('Please enter a valid number of arrays between 2 and 5', 'danger');
        arrayCountInput.focus();
        return;
    }

    arrayDetailsContainer.innerHTML = '<h6>Array Details:</h6>';
    
    // Create input fields for each array
    for (let i = 0; i < arrayCount; i++) {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'mb-3';
        arrayGroup.innerHTML = `
            <label class="form-label">Array ${i + 1}</label>
            <div class="input-group mb-2">
                <span class="input-group-text">Name</span>
                <input type="text" class="form-control statistical-array-name" 
                       placeholder="e.g., Temperature" data-index="${i}" 
                       value="${i === 0 ? 'Array_X' : i === 1 ? 'Array_Y' : `Array_${String.fromCharCode(65 + i)}`}">
            </div>
            <div class="input-group mb-2">
                <span class="input-group-text">Size</span>
                <input type="number" class="form-control statistical-array-size" 
                       placeholder="Size" data-index="${i}" min="2" max="20" value="5">
            </div>
            <div class="statistical-array-elements" id="statisticalArrayElements${i}"></div>
        `;
        arrayDetailsContainer.appendChild(arrayGroup);

        // Add event listeners for size input
        const sizeInput = arrayGroup.querySelector('.statistical-array-size');
        sizeInput.addEventListener('change', () => handleStatisticalArraySizeChange(i));
        sizeInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleStatisticalArraySizeChange(i);
        });

        // Add event listeners for name input
        const nameInput = arrayGroup.querySelector('.statistical-array-name');
        nameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleStatisticalArraySizeChange(i);
        });

        // Initialize elements for this array
        handleStatisticalArraySizeChange(i);
    }

    performStatisticalOperationBtn.style.display = 'block';
    showNotification(`Please enter details for ${arrayCount} arrays`, 'success');
}

// NEW: Handle Statistical Array Size Change
function handleStatisticalArraySizeChange(index) {
    const sizeInput = document.querySelector(`.statistical-array-size[data-index="${index}"]`);
    const size = parseInt(sizeInput.value);
    const elementsContainer = document.getElementById(`statisticalArrayElements${index}`);
    
    if (isNaN(size) || size < 2 || size > 20) {
        showNotification('Please enter a valid array size between 2 and 20', 'danger');
        sizeInput.focus();
        return;
    }

    elementsContainer.innerHTML = '<div class="form-label">Elements:</div>';
    
    // Create input fields for array elements
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="number" class="form-control statistical-array-element" 
                   placeholder="Enter number" data-array="${index}" data-index="${i}" 
                   step="any" value="${Math.floor(Math.random() * 100) + 1}">
        `;
        elementsContainer.appendChild(inputGroup);
    }

    // Add event listeners for element inputs
    const elementInputs = elementsContainer.querySelectorAll('.statistical-array-element');
    elementInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.parentElement.nextElementSibling?.querySelector('.statistical-array-element');
                if (nextInput) nextInput.focus();
            }
        });
    });
}

// NEW: Perform Statistical Operation Handler
function handlePerformStatisticalOperation() {
    // Collect array names and elements
    statisticalArrayNames = [];
    statisticalArrays = [];
    
    const nameInputs = document.querySelectorAll('.statistical-array-name');
    const arrayCount = nameInputs.length;
    
    let allValid = true;
    
    for (let i = 0; i < arrayCount; i++) {
        const name = nameInputs[i].value.trim() || `Array_${i + 1}`;
        statisticalArrayNames.push(name);
        
        const elements = [];
        const elementInputs = document.querySelectorAll(`.statistical-array-element[data-array="${i}"]`);
        
        for (let j = 0; j < elementInputs.length; j++) {
            const value = parseFloat(elementInputs[j].value);
            if (isNaN(value)) {
                showNotification(`Please enter valid numbers for ${name}`, 'danger');
                elementInputs[j].focus();
                allValid = false;
                break;
            }
            elements.push(value);
        }
        
        if (!allValid) break;
        
        // Check if all arrays have same length
        if (i > 0 && elements.length !== statisticalArrays[0].length) {
            showNotification('All arrays must have the same length for statistical operations', 'danger');
            allValid = false;
            break;
        }
        
        statisticalArrays.push(elements);
    }
    
    if (!allValid) return;
    
    // Store original array
    originalArrayForStatistical = [...myArray];
    
    // Hide input group
    covarianceCorrelationGroup.style.display = 'none';
    
    // Start statistical operation visualization
    if (currentStatisticalOperation === 'covariance') {
        performCovarianceCalculation();
    } else {
        performCorrelationCalculation();
    }
}

// NEW: Cancel Statistical Operation Handler
function handleCancelStatisticalOperation() {
    covarianceCorrelationGroup.style.display = 'none';
    arrayCountInput.value = '2';
    arrayDetailsContainer.innerHTML = '';
    performStatisticalOperationBtn.style.display = 'none';
    
    statisticalArrays = [];
    statisticalArrayNames = [];
    currentStatisticalOperation = null;
    
    logOperation('Cancelled statistical operation', 'info');
    showNotification('Statistical operation cancelled', 'info');
}

// NEW: Perform Covariance Calculation with Visualization
function performCovarianceCalculation() {
    isStatisticalOperationRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Covariance Calculation</h5>
        
        <div class="array-group">
            <div class="array-label">Input Arrays</div>
            <div id="covarianceArraysContainer" class="multiple-arrays-container"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Covariance Calculation Steps</div>
            <div id="covarianceCalculationContainer" class="calculation-container"></div>
        </div>
        
        <div class="statistical-explanation">
            <p class="mb-2"><strong>Covariance Formula:</strong> Measures how two variables change together</p>
            <p class="mb-0" id="covarianceExplanation">Starting covariance calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="covarianceStepsContainer">
            <h6 class="text-center">Covariance Calculation Steps</h6>
            <div class="steps-container" id="covarianceSteps"></div>
        </div>
        
        <div class="stats-card mt-3" id="covarianceResultContainer" style="display: none;">
            <div>Covariance Result</div>
            <div class="stats-value" id="covarianceResultValue">0</div>
            <div id="covarianceInterpretation"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterCovariance" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderCovarianceArrays();
    performCovarianceStepByStep();
}

// NEW: Render Covariance Arrays
function renderCovarianceArrays() {
    const container = document.getElementById('covarianceArraysContainer');
    container.innerHTML = '';
    
    statisticalArrays.forEach((array, index) => {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'mb-3';
        arrayGroup.innerHTML = `
            <div class="array-title">${statisticalArrayNames[index]}</div>
            <div class="original-array-container" id="covarianceArray${index}"></div>
        `;
        container.appendChild(arrayGroup);
        
        renderStatisticalArrayInContainer(array, `covarianceArray${index}`, statisticalArrayNames[index]);
    });
}

// NEW: Perform Covariance Step by Step
function performCovarianceStepByStep() {
    const explanation = document.getElementById('covarianceExplanation');
    const stepsContainer = document.getElementById('covarianceSteps');
    const calculationContainer = document.getElementById('covarianceCalculationContainer');
    const resultContainer = document.getElementById('covarianceResultContainer');
    const resultValue = document.getElementById('covarianceResultValue');
    const interpretation = document.getElementById('covarianceInterpretation');
    const continueButton = document.getElementById('continueAfterCovariance');
    
    const array1 = statisticalArrays[0];
    const array2 = statisticalArrays[1];
    const n = array1.length;
    
    let step = 0;
    let means = [];
    let deviations = [];
    let products = [];
    
    function performCovarianceStep() {
        switch (step) {
            case 0:
                // Step 1: Calculate means
                explanation.innerHTML = 'Step 1: Calculate means of both arrays';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Calculate means (average) of both arrays
                    </div>
                `;
                
                means = statisticalArrays.map(array => {
                    const sum = array.reduce((a, b) => a + b, 0);
                    return sum / n;
                });
                
                calculationContainer.innerHTML = `
                    <div class="statistical-formula">
                        Mean(${statisticalArrayNames[0]}) = (${array1.join(' + ')}) / ${n} = ${means[0].toFixed(2)}<br>
                        Mean(${statisticalArrayNames[1]}) = (${array2.join(' + ')}) / ${n} = ${means[1].toFixed(2)}
                    </div>
                `;
                
                // Highlight means in arrays
                highlightStatisticalMeans();
                break;
                
            case 1:
                // Step 2: Calculate deviations from mean
                explanation.innerHTML = 'Step 2: Calculate deviations from mean for each element';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Calculate deviations (element - mean) for both arrays
                    </div>
                `;
                
                deviations = statisticalArrays.map((array, idx) => 
                    array.map(val => val - means[idx])
                );
                
                calculationContainer.innerHTML += `
                    <div class="statistical-formula mt-3">
                        Deviation = Element - Mean<br>
                        ${statisticalArrayNames[0]} deviations: [${deviations[0].map(d => d.toFixed(2)).join(', ')}]<br>
                        ${statisticalArrayNames[1]} deviations: [${deviations[1].map(d => d.toFixed(2)).join(', ')}]
                    </div>
                `;
                
                // Highlight deviations
                highlightStatisticalDeviations();
                break;
                
            case 2:
                // Step 3: Calculate product of deviations
                explanation.innerHTML = 'Step 3: Calculate product of deviations for each pair';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Multiply deviations for each corresponding pair
                    </div>
                `;
                
                products = [];
                for (let i = 0; i < n; i++) {
                    products.push(deviations[0][i] * deviations[1][i]);
                }
                
                calculationContainer.innerHTML += `
                    <div class="statistical-formula mt-3">
                        Product of deviations:<br>
                        ${products.map((p, i) => `(${deviations[0][i].toFixed(2)}  ${deviations[1][i].toFixed(2)} = ${p.toFixed(2)})`).join(', ')}
                    </div>
                `;
                
                // Highlight products
                highlightStatisticalProducts();
                break;
                
            case 3:
        // Step 4: Calculate covariance
        explanation.innerHTML = 'Step 4: Calculate covariance (sum of products / n-1)';
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step 4:</strong> Sum all products and divide by (n-1)
            </div>
        `;
        
        const sumProducts = products.reduce((a, b) => a + b, 0);
        const covariance = sumProducts / (n - 1);
        
        calculationContainer.innerHTML += `
            <div class="statistical-formula mt-3">
                Covariance = (${products.map(p => p.toFixed(2)).join(' + ')}) / (${n} - 1)<br>
                = ${sumProducts.toFixed(2)} / ${n - 1} = ${covariance.toFixed(4)}
            </div>
        `;
        
        // Show final result with proper color coding
        resultContainer.style.display = 'block';
        resultValue.textContent = covariance.toFixed(4);
        
        // FIXED: Proper color coding for covariance
        if (covariance > 0) {
            resultValue.className = 'stats-value stats-positive';
        } else if (covariance < 0) {
            resultValue.className = 'stats-value stats-negative';
        } else {
            resultValue.className = 'stats-value stats-zero';
        }
        
        // Add interpretation with dynamic array names
        const arrayName1 = statisticalArrayNames[0];
        const arrayName2 = statisticalArrayNames[1];
        let interpretationText = '';
        
        if (covariance > 0) {
            interpretationText = `Covariance = ${covariance.toFixed(4)}  Positive number = they move together<br>`;
            interpretationText += ` When ${arrayName1} goes UP, ${arrayName2} also goes UP`;
        } else if (covariance < 0) {
            interpretationText = `Covariance = ${covariance.toFixed(4)}  Negative number = they move opposite<br>`;
            interpretationText += ` When ${arrayName1} goes UP, ${arrayName2} goes DOWN`;
        } else {
            interpretationText = `Covariance = ${covariance.toFixed(4)}  Zero = they are independent<br>`;
            interpretationText += ` No linear relationship between ${arrayName1} and ${arrayName2}`;
        }
        
        interpretation.innerHTML = interpretationText;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Final:</strong> Covariance = <span class="${covariance > 0 ? 'stats-positive' : covariance < 0 ? 'stats-negative' : 'stats-zero'}">${covariance.toFixed(4)}</span><br>
                ${interpretationText.replace(/<br>/g, ' - ')}
            </div>
        `;
        
        continueButton.style.display = 'block';
        continueButton.addEventListener('click', returnToOriginalAfterStatistical);
        
        // Auto-return after 10 seconds
        setTimeout(() => {
            returnToOriginalAfterStatistical();
        }, 10000);
        
        logOperation(`Covariance calculated: ${covariance.toFixed(4)} between ${arrayName1} and ${arrayName2}`, 'success');
        return;
    // ... rest of the code ...
}        
        step++;
        setTimeout(performCovarianceStep, 3000);
    }
    
    performCovarianceStep();
}

// NEW: Perform Correlation Calculation with Visualization
function performCorrelationCalculation() {
    isStatisticalOperationRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Correlation Coefficient Calculation</h5>
        
        <div class="array-group">
            <div class="array-label">Input Arrays</div>
            <div id="correlationArraysContainer" class="multiple-arrays-container"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Correlation Calculation Steps</div>
            <div id="correlationCalculationContainer" class="calculation-container"></div>
        </div>
        
        <div class="statistical-explanation">
            <p class="mb-2"><strong>Correlation Formula:</strong> Measures strength and direction of linear relationship</p>
            <p class="mb-0" id="correlationExplanation">Starting correlation calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="correlationStepsContainer">
            <h6 class="text-center">Correlation Calculation Steps</h6>
            <div class="steps-container" id="correlationSteps"></div>
        </div>
        
        <div class="stats-card mt-3" id="correlationResultContainer" style="display: none;">
            <div>Correlation Coefficient</div>
            <div class="stats-value" id="correlationResultValue">0</div>
            <div id="correlationInterpretation"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterCorrelation" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderCorrelationArrays();
    performCorrelationStepByStep();
}

// NEW: Perform Correlation Step by Step
function performCorrelationStepByStep() {
    const explanation = document.getElementById('correlationExplanation');
    const stepsContainer = document.getElementById('correlationSteps');
    const calculationContainer = document.getElementById('correlationCalculationContainer');
    const resultContainer = document.getElementById('correlationResultContainer');
    const resultValue = document.getElementById('correlationResultValue');
    const interpretation = document.getElementById('correlationInterpretation');
    const continueButton = document.getElementById('continueAfterCorrelation');
    
    const array1 = statisticalArrays[0];
    const array2 = statisticalArrays[1];
    const n = array1.length;
    
    let step = 0;
    let means = [];
    let stdDevs = [];
    let covariance = 0;
    
    function performCorrelationStep() {
        switch (step) {
            case 0:
                // Step 1: Calculate means
                explanation.innerHTML = 'Step 1: Calculate means of both arrays';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Calculate means (average) of both arrays
                    </div>
                `;
                
                means = statisticalArrays.map(array => {
                    const sum = array.reduce((a, b) => a + b, 0);
                    return sum / n;
                });
                
                calculationContainer.innerHTML = `
                    <div class="statistical-formula">
                        Mean(${statisticalArrayNames[0]}) = ${means[0].toFixed(2)}<br>
                        Mean(${statisticalArrayNames[1]}) = ${means[1].toFixed(2)}
                    </div>
                `;
                break;
                
            case 1:
                // Step 2: Calculate standard deviations
                explanation.innerHTML = 'Step 2: Calculate standard deviations';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Calculate standard deviation for both arrays
                    </div>
                `;
                
                stdDevs = statisticalArrays.map((array, idx) => {
                    const variance = array.reduce((sum, val) => sum + Math.pow(val - means[idx], 2), 0) / (n - 1);
                    return Math.sqrt(variance);
                });
                
                calculationContainer.innerHTML += `
                    <div class="statistical-formula mt-3">
                        StdDev(${statisticalArrayNames[0]}) = [(x - mean) / (n-1)] = ${stdDevs[0].toFixed(4)}<br>
                        StdDev(${statisticalArrayNames[1]}) = [(y - mean) / (n-1)] = ${stdDevs[1].toFixed(4)}
                    </div>
                `;
                break;
                
            case 2:
                // Step 3: Calculate covariance
                explanation.innerHTML = 'Step 3: Calculate covariance';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Calculate covariance between arrays
                    </div>
                `;
                
                let sumProducts = 0;
                for (let i = 0; i < n; i++) {
                    sumProducts += (array1[i] - means[0]) * (array2[i] - means[1]);
                }
                covariance = sumProducts / (n - 1);
                
                calculationContainer.innerHTML += `
                    <div class="statistical-formula mt-3">
                        Covariance = [(x - mean)(y - mean)] / (n-1) = ${covariance.toFixed(4)}
                    </div>
                `;
                break;
                
            case 3:
                // Step 4: Calculate correlation coefficient
                explanation.innerHTML = 'Step 4: Calculate correlation coefficient';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 4:</strong> Correlation = Covariance / (StdDev  StdDev)
                    </div>
                `;
                
                const correlation = covariance / (stdDevs[0] * stdDevs[1]);
                
                calculationContainer.innerHTML += `
                    <div class="statistical-formula mt-3">
                        Correlation = ${covariance.toFixed(4)} / (${stdDevs[0].toFixed(4)}  ${stdDevs[1].toFixed(4)})<br>
                        = ${covariance.toFixed(4)} / ${(stdDevs[0] * stdDevs[1]).toFixed(4)} = ${correlation.toFixed(4)}
                    </div>
                `;
                
                // Show final result
                resultContainer.style.display = 'block';
                resultValue.textContent = correlation.toFixed(4);
                
                // Color coding based on correlation value
                if (correlation > 0.7) {
                    resultValue.className = 'stats-value stats-positive';
                } else if (correlation > 0.3) {
                    resultValue.className = 'stats-value';
                } else if (correlation > -0.3) {
                    resultValue.className = 'stats-value stats-zero';
                } else if (correlation > -0.7) {
                    resultValue.className = 'stats-value';
                } else {
                    resultValue.className = 'stats-value stats-negative';
                }
                
                // Add interpretation
                let interpretationText = '';
                if (correlation >= 0.8) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Very strong positive relationship<br>`;
                    interpretationText += ` ${statisticalArrayNames[0]} and ${statisticalArrayNames[1]} are best friends  they move perfectly together!`;
                } else if (correlation >= 0.6) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Strong positive relationship<br>`;
                    interpretationText += ` When ${statisticalArrayNames[0]} changes, ${statisticalArrayNames[1]} strongly follows the same direction`;
                } else if (correlation >= 0.3) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Moderate positive relationship<br>`;
                    interpretationText += ` ${statisticalArrayNames[0]} and ${statisticalArrayNames[1]} tend to move together`;
                } else if (correlation >= -0.3) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Weak or no relationship<br>`;
                    interpretationText += ` Little to no linear relationship between ${statisticalArrayNames[0]} and ${statisticalArrayNames[1]}`;
                } else if (correlation >= -0.6) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Moderate negative relationship<br>`;
                    interpretationText += ` When ${statisticalArrayNames[0]} goes up, ${statisticalArrayNames[1]} tends to go down`;
                } else if (correlation >= -0.8) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Strong negative relationship<br>`;
                    interpretationText += ` ${statisticalArrayNames[0]} and ${statisticalArrayNames[1]} strongly move in opposite directions`;
                } else {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Very strong negative relationship<br>`;
                    interpretationText += ` Perfect opposites  when one goes up, the other goes down consistently!`;
                }
                
                interpretation.innerHTML = interpretationText;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Correlation = ${correlation.toFixed(4)}<br>
                        ${interpretationText.replace(/<br>/g, ' - ')}
                    </div>
                `;
                
                continueButton.style.display = 'block';
                continueButton.addEventListener('click', returnToOriginalAfterStatistical);
                
                // Auto-return after 10 seconds
                setTimeout(() => {
                    returnToOriginalAfterStatistical();
                }, 10000);
                
                logOperation(`Correlation calculated: ${correlation.toFixed(4)} between ${statisticalArrayNames[0]} and ${statisticalArrayNames[1]}`, 'success');
                return;
        }
        
        step++;
        setTimeout(performCorrelationStep, 3000);
    }
    
    performCorrelationStep();
}

// NEW: Helper function to render statistical arrays
function renderStatisticalArrayInContainer(array, containerId, arrayName) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    array.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value statistical-element" data-index="${index}">
                ${value}
            </div>
            <div class="element-index">${arrayName}[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}

// NEW: Highlight statistical means
function highlightStatisticalMeans() {
    statisticalArrays.forEach((array, arrayIndex) => {
        const mean = array.reduce((a, b) => a + b, 0) / array.length;
        const container = document.getElementById(`covarianceArray${arrayIndex}`);
        const elements = container.querySelectorAll('.statistical-element');
        
        elements.forEach(element => {
            const value = parseFloat(element.textContent);
            if (Math.abs(value - mean) < 0.01) { // Account for floating point precision
                element.classList.add('mean-highlight');
            }
        });
    });
}

// NEW: Highlight statistical deviations
function highlightStatisticalDeviations() {
    statisticalArrays.forEach((array, arrayIndex) => {
        const mean = array.reduce((a, b) => a + b, 0) / array.length;
        const container = document.getElementById(`covarianceArray${arrayIndex}`);
        const elements = container.querySelectorAll('.statistical-element');
        
        elements.forEach((element, index) => {
            const deviation = array[index] - mean;
            element.classList.add('deviation-highlight');
            // You could add tooltips or additional display for deviation values
        });
    });
}

// NEW: Highlight statistical products
function highlightStatisticalProducts() {
    // This would highlight the pairs being multiplied
    const container1 = document.getElementById('covarianceArray0');
    const container2 = document.getElementById('covarianceArray1');
    const elements1 = container1.querySelectorAll('.statistical-element');
    const elements2 = container2.querySelectorAll('.statistical-element');
    
    elements1.forEach((element, index) => {
        element.classList.add('statistical-highlight');
        if (elements2[index]) {
            elements2[index].classList.add('statistical-highlight');
        }
    });
}
// NEW: Render Correlation Arrays (Missing function)
function renderCorrelationArrays() {
    const container = document.getElementById('correlationArraysContainer');
    container.innerHTML = '';
    
    statisticalArrays.forEach((array, index) => {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'mb-3';
        arrayGroup.innerHTML = `
            <div class="array-title">${statisticalArrayNames[index]}</div>
            <div class="original-array-container" id="correlationArray${index}"></div>
        `;
        container.appendChild(arrayGroup);
        
        renderStatisticalArrayInContainer(array, `correlationArray${index}`, statisticalArrayNames[index]);
    });
}

// NEW: Fix the color coding in correlation calculation
function performCorrelationStepByStep() {
    const explanation = document.getElementById('correlationExplanation');
    const stepsContainer = document.getElementById('correlationSteps');
    const calculationContainer = document.getElementById('correlationCalculationContainer');
    const resultContainer = document.getElementById('correlationResultContainer');
    const resultValue = document.getElementById('correlationResultValue');
    const interpretation = document.getElementById('correlationInterpretation');
    const continueButton = document.getElementById('continueAfterCorrelation');
    
    const array1 = statisticalArrays[0];
    const array2 = statisticalArrays[1];
    const n = array1.length;
    
    let step = 0;
    let means = [];
    let stdDevs = [];
    let covariance = 0;
    
    function performCorrelationStep() {
        switch (step) {
            case 0:
                // Step 1: Calculate means
                explanation.innerHTML = 'Step 1: Calculate means of both arrays';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Calculate means (average) of both arrays
                    </div>
                `;
                
                means = statisticalArrays.map(array => {
                    const sum = array.reduce((a, b) => a + b, 0);
                    return sum / n;
                });
                
                calculationContainer.innerHTML = `
                    <div class="statistical-formula">
                        Mean(${statisticalArrayNames[0]}) = (${array1.join(' + ')}) / ${n} = ${means[0].toFixed(2)}<br>
                        Mean(${statisticalArrayNames[1]}) = (${array2.join(' + ')}) / ${n} = ${means[1].toFixed(2)}
                    </div>
                `;
                
                // Highlight means in arrays
                highlightCorrelationMeans();
                break;
                
            case 1:
                // Step 2: Calculate standard deviations
                explanation.innerHTML = 'Step 2: Calculate standard deviations';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Calculate standard deviation for both arrays
                    </div>
                `;
                
                stdDevs = statisticalArrays.map((array, idx) => {
                    const variance = array.reduce((sum, val) => sum + Math.pow(val - means[idx], 2), 0) / (n - 1);
                    return Math.sqrt(variance);
                });
                
                calculationContainer.innerHTML += `
                    <div class="statistical-formula mt-3">
                        StdDev(${statisticalArrayNames[0]}) = [(x - mean) / (n-1)] = ${stdDevs[0].toFixed(4)}<br>
                        StdDev(${statisticalArrayNames[1]}) = [(y - mean) / (n-1)] = ${stdDevs[1].toFixed(4)}
                    </div>
                `;
                break;
                
            case 2:
                // Step 3: Calculate covariance
                explanation.innerHTML = 'Step 3: Calculate covariance';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Calculate covariance between arrays
                    </div>
                `;
                
                let sumProducts = 0;
                for (let i = 0; i < n; i++) {
                    sumProducts += (array1[i] - means[0]) * (array2[i] - means[1]);
                }
                covariance = sumProducts / (n - 1);
                
                calculationContainer.innerHTML += `
                    <div class="statistical-formula mt-3">
                        Covariance = [(x - mean)(y - mean)] / (n-1) = ${covariance.toFixed(4)}
                    </div>
                `;
                break;
                
            case 3:
                // Step 4: Calculate correlation coefficient
                explanation.innerHTML = 'Step 4: Calculate correlation coefficient';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 4:</strong> Correlation = Covariance / (StdDev  StdDev)
                    </div>
                `;
                
                const correlation = covariance / (stdDevs[0] * stdDevs[1]);
                
                calculationContainer.innerHTML += `
                    <div class="statistical-formula mt-3">
                        Correlation = ${covariance.toFixed(4)} / (${stdDevs[0].toFixed(4)}  ${stdDevs[1].toFixed(4)})<br>
                        = ${covariance.toFixed(4)} / ${(stdDevs[0] * stdDevs[1]).toFixed(4)} = ${correlation.toFixed(4)}
                    </div>
                `;
                
                // Show final result with proper color coding
                resultContainer.style.display = 'block';
                resultValue.textContent = correlation.toFixed(4);
                
                // FIXED: Proper color coding for correlation coefficient
                if (correlation > 0) {
                    resultValue.className = 'stats-value stats-positive';
                } else if (correlation < 0) {
                    resultValue.className = 'stats-value stats-negative';
                } else {
                    resultValue.className = 'stats-value stats-zero';
                }
                
                // Add interpretation with dynamic array names
                let interpretationText = '';
                const arrayName1 = statisticalArrayNames[0];
                const arrayName2 = statisticalArrayNames[1];
                
                if (correlation >= 0.8) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Very strong positive relationship<br>`;
                    interpretationText += ` ${arrayName1} and ${arrayName2} are best friends  they move perfectly together!`;
                } else if (correlation >= 0.6) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Strong positive relationship<br>`;
                    interpretationText += ` When ${arrayName1} changes, ${arrayName2} strongly follows the same direction`;
                } else if (correlation >= 0.3) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Moderate positive relationship<br>`;
                    interpretationText += ` ${arrayName1} and ${arrayName2} tend to move together`;
                } else if (correlation > 0) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Weak positive relationship<br>`;
                    interpretationText += ` ${arrayName1} and ${arrayName2} have a slight tendency to move together`;
                } else if (correlation === 0) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  No relationship<br>`;
                    interpretationText += ` No linear relationship between ${arrayName1} and ${arrayName2}`;
                } else if (correlation >= -0.3) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Weak negative relationship<br>`;
                    interpretationText += ` ${arrayName1} and ${arrayName2} have a slight tendency to move opposite`;
                } else if (correlation >= -0.6) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Moderate negative relationship<br>`;
                    interpretationText += ` When ${arrayName1} goes up, ${arrayName2} tends to go down`;
                } else if (correlation >= -0.8) {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Strong negative relationship<br>`;
                    interpretationText += ` ${arrayName1} and ${arrayName2} strongly move in opposite directions`;
                } else {
                    interpretationText = `Correlation = ${correlation.toFixed(4)}  Very strong negative relationship<br>`;
                    interpretationText += ` Perfect opposites  when ${arrayName1} goes up, ${arrayName2} goes down consistently!`;
                }
                
                interpretation.innerHTML = interpretationText;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Correlation = <span class="${correlation > 0 ? 'stats-positive' : correlation < 0 ? 'stats-negative' : 'stats-zero'}">${correlation.toFixed(4)}</span><br>
                        ${interpretationText.replace(/<br>/g, ' - ')}
                    </div>
                `;
                
                continueButton.style.display = 'block';
                continueButton.addEventListener('click', returnToOriginalAfterStatistical);
                
                // Auto-return after 10 seconds
                setTimeout(() => {
                    returnToOriginalAfterStatistical();
                }, 10000);
                
                logOperation(`Correlation calculated: ${correlation.toFixed(4)} between ${arrayName1} and ${arrayName2}`, 'success');
                return;
        }
        
        step++;
        setTimeout(performCorrelationStep, 3000);
    }
    
    performCorrelationStep();
}

// NEW: Highlight correlation means
function highlightCorrelationMeans() {
    statisticalArrays.forEach((array, arrayIndex) => {
        const mean = array.reduce((a, b) => a + b, 0) / array.length;
        const container = document.getElementById(`correlationArray${arrayIndex}`);
        const elements = container.querySelectorAll('.statistical-element');
        
        elements.forEach(element => {
            const value = parseFloat(element.textContent);
            if (Math.abs(value - mean) < 0.01) {
                element.classList.add('mean-highlight');
            }
        });
    });
}

// NEW: Return to Original after Statistical Operations
function returnToOriginalAfterStatistical() {
    // Reset to original array
    myArray = [...originalArrayForStatistical];
    originalArrayForStatistical = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isStatisticalOperationRunning = false;
    currentStatisticalOperation = null;
    statisticalArrays = [];
    statisticalArrayNames = [];
    
    // Clear input groups
    covarianceCorrelationGroup.style.display = 'none';
    arrayCountInput.value = '2';
    arrayDetailsContainer.innerHTML = '';
    performStatisticalOperationBtn.style.display = 'none';
    
    logOperation('Statistical operation completed - returned to original array', 'info');
    showNotification('Returned to original array after statistical operation', 'success');
}
// NEW: Find Mean Handler
function handleFindMean() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isStatisticalCalculationRunning) {
        showNotification('A statistical operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Mean calculation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isStatisticalCalculationRunning = true;
    
    // Store original array
    originalArrayForStats = [...myArray];
    
    // Show mean calculation visualization
    showMeanCalculation();
}

// NEW: Find Median Handler
function handleFindMedian() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isStatisticalCalculationRunning) {
        showNotification('A statistical operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Median calculation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isStatisticalCalculationRunning = true;
    
    // Store original array
    originalArrayForStats = [...myArray];
    
    // Show median calculation visualization
    showMedianCalculation();
}

// NEW: Show Mean Calculation Visualization
function showMeanCalculation() {
    const statsContainer = document.createElement('div');
    statsContainer.className = 'dual-operation-container';
    statsContainer.innerHTML = `
        <h5 class="text-center mb-3">Calculate Mean (Average)</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="statsArray"></div>
        </div>
        
        <div class="stats-result-card">
            <p class="mb-2"><strong>Mean Calculation Process:</strong> Sum of all elements divided by number of elements</p>
            <p class="mb-0" id="statsExplanation">Starting mean calculation...</p>
        </div>
        
        <div class="calculation-steps mt-3" id="calculationSteps">
            <h6 class="text-center">Calculation Steps</h6>
            <div id="meanSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Mean (Average)</div>
            <div class="stats-value" id="meanValue">Calculating...</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterStats" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(statsContainer);
    
    renderArrayInContainer(originalArrayForStats, 'statsArray');
    
    performMeanCalculation();
}

// NEW: Perform Mean Calculation with Animation
function performMeanCalculation() {
    const arrayContainer = document.getElementById('statsArray');
    const explanation = document.getElementById('statsExplanation');
    const stepsContainer = document.getElementById('meanSteps');
    const meanValue = document.getElementById('meanValue');
    const continueButton = document.getElementById('continueAfterStats');
    
    const arr = originalArrayForStats.map(val => parseFloat(val));
    let sum = 0;
    let step = 0;
    
    function performMeanStep(i) {
        if (i >= arr.length) {
            // Calculation completed
            const mean = sum / arr.length;
            const meanRounded = Math.round(mean * 100) / 100; // Round to 2 decimal places
            
            explanation.innerHTML = `<strong>Mean Calculation Completed!</strong>`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step + 1}:</strong> Mean = Total Sum / Number of Elements = ${sum} / ${arr.length} = <strong>${meanRounded}</strong>
                </div>
            `;
            
            meanValue.textContent = meanRounded;
            meanValue.classList.add('highlight');
            
            // Highlight all elements as they contributed to the mean
            const elements = arrayContainer.querySelectorAll('.array-element');
            elements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('mean-element');
                }, index * 200);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterStats();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterStats);
            
            return;
        }
        
        step++;
        
        if (i === 0) {
            explanation.innerHTML = `Step ${step}: Start with first element = ${arr[i]}`;
        } else {
            explanation.innerHTML = `Step ${step}: Add element [${i}] = ${arr[i]} to running sum`;
        }
        
        // Highlight current element
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElement = elements[i].querySelector('.element-value');
        currentElement.classList.add('statistical-highlight');
        
        setTimeout(() => {
            // Add to sum
            const previousSum = sum;
            sum += arr[i];
            
            if (i === 0) {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> Initialize sum = ${arr[i]}
                    </div>
                `;
            } else {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> Sum = ${previousSum} + ${arr[i]} = <strong>${sum}</strong>
                    </div>
                `;
            }
            
            // Update mean value display with intermediate calculation
            const currentMean = sum / (i + 1);
            const currentMeanRounded = Math.round(currentMean * 100) / 100;
            meanValue.textContent = `Calculating... (Current: ${currentMeanRounded})`;
            
            // Remove highlight and mark as processed
            currentElement.classList.remove('statistical-highlight');
            currentElement.classList.add('mean-element');
            
            // Move to next element
            performMeanStep(i + 1);
        }, 1500);
    }
    
    // Start mean calculation
    performMeanStep(0);
}

// NEW: Show Median Calculation Visualization
function showMedianCalculation() {
    const statsContainer = document.createElement('div');
    statsContainer.className = 'dual-operation-container';
    statsContainer.innerHTML = `
        <h5 class="text-center mb-3">Calculate Median</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="statsArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Sorted Array (for Median)</div>
            <div class="transformed-array-container" id="sortedStatsArray"></div>
        </div>
        
        <div class="stats-result-card">
            <p class="mb-2"><strong>Median Calculation Process:</strong> Middle value of sorted array</p>
            <p class="mb-0" id="statsExplanation">Starting median calculation...</p>
        </div>
        
        <div class="calculation-steps mt-3" id="calculationSteps">
            <h6 class="text-center">Calculation Steps</h6>
            <div id="medianSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Median</div>
            <div class="stats-value" id="medianValue">Calculating...</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterStats" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(statsContainer);
    
    renderArrayInContainer(originalArrayForStats, 'statsArray');
    renderArrayInContainer([...originalArrayForStats], 'sortedStatsArray');
    
    performMedianCalculation();
}

// NEW: Perform Median Calculation with Animation
function performMedianCalculation() {
    const originalContainer = document.getElementById('statsArray');
    const sortedContainer = document.getElementById('sortedStatsArray');
    const explanation = document.getElementById('statsExplanation');
    const stepsContainer = document.getElementById('medianSteps');
    const medianValue = document.getElementById('medianValue');
    const continueButton = document.getElementById('continueAfterStats');
    
    const arr = originalArrayForStats.map(val => parseFloat(val));
    const sortedArr = [...arr].sort((a, b) => a - b);
    const n = sortedArr.length;
    let step = 0;
    
    function performMedianStep() {
        step++;
        
        if (step === 1) {
            // Step 1: Show original array
            explanation.innerHTML = `Step ${step}: Original array needs to be sorted for median calculation`;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Original array: [${arr.join(', ')}]
                </div>
            `;
            
            // Highlight original array
            const originalElements = originalContainer.querySelectorAll('.array-element');
            originalElements.forEach(el => {
                el.querySelector('.element-value').classList.add('statistical-highlight');
            });
            
            setTimeout(() => {
                performMedianStep();
            }, 2000);
            
        } else if (step === 2) {
            // Step 2: Show sorted array
            explanation.innerHTML = `Step ${step}: Array sorted in ascending order`;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Sorted array: [${sortedArr.join(', ')}]
                </div>
            `;
            
            // Update sorted array display
            renderArrayInContainer(sortedArr, 'sortedStatsArray');
            
            // Highlight sorted array
            const sortedElements = sortedContainer.querySelectorAll('.array-element');
            sortedElements.forEach(el => {
                el.querySelector('.element-value').classList.add('statistical-highlight');
            });
            
            setTimeout(() => {
                performMedianStep();
            }, 2000);
            
        } else if (step === 3) {
            // Step 3: Calculate median based on array length
            explanation.innerHTML = `Step ${step}: Calculate median (n = ${n} elements)`;
            
            let median;
            let calculation;
            
            if (n % 2 === 1) {
                // Odd number of elements
                const midIndex = Math.floor(n / 2);
                median = sortedArr[midIndex];
                calculation = `Median = element at position (n+1)/2 = element at index ${midIndex} = ${median}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> Odd number of elements (n = ${n})<br>
                        ${calculation}
                    </div>
                `;
                
                // Highlight the median element
                const sortedElements = sortedContainer.querySelectorAll('.array-element');
                sortedElements[midIndex].querySelector('.element-value').classList.add('median-element');
                
            } else {
                // Even number of elements
                const midIndex1 = n / 2 - 1;
                const midIndex2 = n / 2;
                median = (sortedArr[midIndex1] + sortedArr[midIndex2]) / 2;
                calculation = `Median = (element[${midIndex1}] + element[${midIndex2}]) / 2 = (${sortedArr[midIndex1]} + ${sortedArr[midIndex2]}) / 2 = ${median}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> Even number of elements (n = ${n})<br>
                        ${calculation}
                    </div>
                `;
                
                // Highlight the two middle elements
                const sortedElements = sortedContainer.querySelectorAll('.array-element');
                sortedElements[midIndex1].querySelector('.element-value').classList.add('median-element');
                sortedElements[midIndex2].querySelector('.element-value').classList.add('median-element');
            }
            
            const medianRounded = Math.round(median * 100) / 100;
            medianValue.textContent = medianRounded;
            medianValue.classList.add('highlight');
            
            explanation.innerHTML = `<strong>Median Calculation Completed!</strong> ${calculation}`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterStats();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterStats);
        }
    }
    
    // Start median calculation
    performMedianStep();
}

// NEW: Return to Original after Statistical Operations
function returnToOriginalAfterStats() {
    // Reset to original array
    myArray = [...originalArrayForStats];
    originalArrayForStats = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isStatisticalCalculationRunning = false;
    
    logOperation('Statistical operation completed - returned to original array', 'info');
    showNotification('Returned to original array after statistical operation', 'success');
}
// NEW: Element-wise Operation Handler
function handleElementWiseOperation(operation) {
    if (isElementWiseOperationRunning) {
        showNotification('An element-wise operation is already in progress', 'warning');
        return;
    }

    // Reset arrays
    elementWiseFirstArray = [];
    elementWiseSecondArray = [];
    elementWiseFirstArraySize = 0;
    elementWiseSecondArraySize = 0;
    currentElementWiseOperation = operation;
    
    // Show input group
    elementWiseGroup.style.display = 'block';
    firstArraySizeElementWise.focus();
    
    // Hide perform button initially
    performElementWiseBtn.style.display = 'none';
    
    // Update button text based on operation
    const operationName = operation === 'max' ? 'Maximum' : 'Minimum';
    performElementWiseBtn.innerHTML = `<i class="fas fa-play me-2"></i>Perform Element-wise ${operationName}`;
    
    logOperation(`Started element-wise ${operationName} operation`, 'info');
}

// NEW: Confirm First Array Size for Element-wise
function handleConfirmFirstArraySizeElementWise() {
    const size = parseInt(firstArraySizeElementWise.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        firstArraySizeElementWise.focus();
        return;
    }
    
    elementWiseFirstArraySize = size;
    elementWiseFirstArray = [];
    
    // Create input fields for first array
    firstArrayInputsElementWise.innerHTML = '<label class="form-label">Enter elements for First Array:</label>';
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="number" class="form-control first-array-element-wise" 
                   placeholder="Enter number" data-index="${i}" step="any">
        `;
        firstArrayInputsElementWise.appendChild(inputGroup);
    }
    
    showNotification(`First array size set to ${size}. Please enter ${size} numbers.`, 'success');
    logOperation(`First array size set to ${size} for element-wise operation`, 'info');
}

// NEW: Confirm Second Array Size for Element-wise
function handleConfirmSecondArraySizeElementWise() {
    const size = parseInt(secondArraySizeElementWise.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        secondArraySizeElementWise.focus();
        return;
    }
    
    if (size !== elementWiseFirstArraySize) {
        showNotification(`Both arrays must have the same size. First array size is ${elementWiseFirstArraySize}`, 'danger');
        return;
    }
    
    elementWiseSecondArraySize = size;
    elementWiseSecondArray = [];
    
    // Create input fields for second array
    secondArrayInputsElementWise.innerHTML = '<label class="form-label">Enter elements for Second Array:</label>';
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="number" class="form-control second-array-element-wise" 
                   placeholder="Enter number" data-index="${i}" step="any">
        `;
        secondArrayInputsElementWise.appendChild(inputGroup);
    }
    
    // Show perform button
    performElementWiseBtn.style.display = 'block';
    
    showNotification(`Second array size set to ${size}. Please enter ${size} numbers.`, 'success');
    logOperation(`Second array size set to ${size} for element-wise operation`, 'info');
}

// NEW: Perform Element-wise Operation
function handlePerformElementWise() {
    // Collect first array elements
    const firstArrayInputs = document.querySelectorAll('.first-array-element-wise');
    elementWiseFirstArray = [];
    
    for (let i = 0; i < firstArrayInputs.length; i++) {
        const value = firstArrayInputs[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all elements for first array. Missing element at position ${i}`, 'danger');
            firstArrayInputs[i].focus();
            return;
        }
        if (isNaN(parseFloat(value))) {
            showNotification(`Please enter valid numbers only. Invalid value at position ${i}`, 'danger');
            firstArrayInputs[i].focus();
            return;
        }
        elementWiseFirstArray.push(parseFloat(value));
    }
    
    // Collect second array elements
    const secondArrayInputs = document.querySelectorAll('.second-array-element-wise');
    elementWiseSecondArray = [];
    
    for (let i = 0; i < secondArrayInputs.length; i++) {
        const value = secondArrayInputs[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all elements for second array. Missing element at position ${i}`, 'danger');
            secondArrayInputs[i].focus();
            return;
        }
        if (isNaN(parseFloat(value))) {
            showNotification(`Please enter valid numbers only. Invalid value at position ${i}`, 'danger');
            secondArrayInputs[i].focus();
            return;
        }
        elementWiseSecondArray.push(parseFloat(value));
    }
    
    // Store original array
    originalArrayBeforeElementWise = [...myArray];
    
    // Hide input group
    elementWiseGroup.style.display = 'none';
    
    // Start element-wise visualization
    showElementWiseVisualization();
}

// NEW: Cancel Element-wise Operation
function handleCancelElementWise() {
    elementWiseGroup.style.display = 'none';
    firstArraySizeElementWise.value = '';
    secondArraySizeElementWise.value = '';
    firstArrayInputsElementWise.innerHTML = '';
    secondArrayInputsElementWise.innerHTML = '';
    performElementWiseBtn.style.display = 'none';
    
    elementWiseFirstArray = [];
    elementWiseSecondArray = [];
    elementWiseFirstArraySize = 0;
    elementWiseSecondArraySize = 0;
    currentElementWiseOperation = null;
    
    logOperation('Cancelled element-wise operation', 'info');
    showNotification('Element-wise operation cancelled', 'info');
}

// NEW: Show Element-wise Visualization
function showElementWiseVisualization() {
    isElementWiseOperationRunning = true;
    
    const operationName = currentElementWiseOperation === 'max' ? 'Maximum' : 'Minimum';
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Element-wise ${operationName} of Two Arrays</h5>
        
        <div class="array-group">
            <div class="array-label">First Array</div>
            <div class="original-array-container" id="firstArrayElementWise"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Second Array</div>
            <div class="original-array-container" id="secondArrayElementWise"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Element-wise ${operationName} Result</div>
            <div class="transformed-array-container" id="resultArrayElementWise"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Element-wise ${operationName}:</strong> Comparing corresponding elements and taking the ${currentElementWiseOperation === 'max' ? 'larger' : 'smaller'} value</p>
            <p class="mb-0" id="elementWiseExplanation">Starting element-wise ${operationName.toLowerCase()} operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="elementWiseStepsContainer">
            <h6 class="text-center">Element-wise ${operationName} Steps</h6>
            <div class="steps-container" id="elementWiseSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterElementWise" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display the input arrays
    renderArrayInContainer(elementWiseFirstArray, 'firstArrayElementWise');
    renderArrayInContainer(elementWiseSecondArray, 'secondArrayElementWise');
    renderArrayInContainer([], 'resultArrayElementWise');
    
    // Start element-wise animation
    performElementWiseAnimation();
}

// NEW: Perform Element-wise Animation
function performElementWiseAnimation() {
    const firstContainer = document.getElementById('firstArrayElementWise');
    const secondContainer = document.getElementById('secondArrayElementWise');
    const resultContainer = document.getElementById('resultArrayElementWise');
    const explanation = document.getElementById('elementWiseExplanation');
    const stepsContainer = document.getElementById('elementWiseSteps');
    const continueButton = document.getElementById('continueAfterElementWise');
    
    const operationName = currentElementWiseOperation === 'max' ? 'Maximum' : 'Minimum';
    let resultArray = [];
    let currentIndex = 0;
    
    function performElementWiseStep() {
        if (currentIndex >= elementWiseFirstArray.length) {
            // Operation completed
            explanation.innerHTML = `<strong>Element-wise ${operationName} Completed!</strong> All elements processed.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Element-wise ${operationName.toLowerCase()} operation completed. Result array: [${resultArray.join(', ')}]
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return to original after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterElementWise();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterElementWise);
            
            return;
        }
        
        const val1 = elementWiseFirstArray[currentIndex];
        const val2 = elementWiseSecondArray[currentIndex];
        
        // Update explanation
        explanation.innerHTML = `Comparing elements at index ${currentIndex}: ${val1} vs ${val2}`;
        
        // Highlight elements being compared
        const firstElements = firstContainer.querySelectorAll('.array-element');
        const secondElements = secondContainer.querySelectorAll('.array-element');
        
        firstElements[currentIndex].querySelector('.element-value').classList.add('element-wise-comparison');
        secondElements[currentIndex].querySelector('.element-value').classList.add('element-wise-comparison');
        
        // Determine result
        let resultValue;
        let sourceArray;
        
        if (currentElementWiseOperation === 'max') {
            resultValue = Math.max(val1, val2);
            sourceArray = val1 >= val2 ? 'first' : 'second';
        } else {
            resultValue = Math.min(val1, val2);
            sourceArray = val1 <= val2 ? 'first' : 'second';
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex + 1}:</strong> Compare [${currentIndex}]: ${val1} vs ${val2} - 
                ${operationName} = ${resultValue} (from ${sourceArray} array)
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Highlight the source element
            if (sourceArray === 'first') {
                firstElements[currentIndex].querySelector('.element-value').classList.add('element-wise-source');
            } else {
                secondElements[currentIndex].querySelector('.element-value').classList.add('element-wise-source');
            }
            
            setTimeout(() => {
                // Add result to result array
                resultArray.push(resultValue);
                
                // Update result array display
                renderArrayInContainer(resultArray, 'resultArrayElementWise');
                
                // Highlight the result element
                const resultElements = resultContainer.querySelectorAll('.array-element');
                const resultElement = resultElements[currentIndex].querySelector('.element-value');
                resultElement.classList.add(currentElementWiseOperation === 'max' ? 'element-wise-max-element' : 'element-wise-min-element');
                
                // Remove comparison highlights
                firstElements[currentIndex].querySelector('.element-value').classList.remove('element-wise-comparison', 'element-wise-source');
                secondElements[currentIndex].querySelector('.element-value').classList.remove('element-wise-comparison', 'element-wise-source');
                
                // Move to next index
                currentIndex++;
                performElementWiseStep();
            }, 1000);
        }, 1500);
    }
    
    // Start element-wise process
    performElementWiseStep();
}

// NEW: Return to Original after Element-wise Operation
function returnToOriginalAfterElementWise() {
    // Reset to original array
    myArray = [...originalArrayBeforeElementWise];
    originalArrayBeforeElementWise = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isElementWiseOperationRunning = false;
    
    // Clear all element-wise related data
    elementWiseFirstArray = [];
    elementWiseSecondArray = [];
    elementWiseFirstArraySize = 0;
    elementWiseSecondArraySize = 0;
    currentElementWiseOperation = null;
    
    // Reset input groups
    elementWiseGroup.style.display = 'none';
    firstArraySizeElementWise.value = '';
    secondArraySizeElementWise.value = '';
    firstArrayInputsElementWise.innerHTML = '';
    secondArrayInputsElementWise.innerHTML = '';
    performElementWiseBtn.style.display = 'none';
    
    const operationName = currentElementWiseOperation === 'max' ? 'maximum' : 'minimum';
    logOperation(`Element-wise ${operationName} operation completed - returned to original array`, 'info');
    showNotification('Returned to original array after element-wise operation', 'success');
}
// NEW: Handle Logical Operation
function handleLogicalOperation(operation) {
    if (isLogicalOperationRunning) {
        showNotification('A logical operation is already in progress', 'warning');
        return;
    }

    logicalOperationType = operation;
    logicalArrays = [];
    logicalArraysCount = 0;
    logicalArraysSizes = [];

    // Show input group
    logicalOperationsGroup.style.display = 'block';
    logicalArraysCountInput.focus();

    // Hide perform button initially
    performLogicalOperationBtn.style.display = 'none';

    logOperation(`Started element-wise logical ${operation} operation`, 'info');
    showNotification(`Please configure arrays for logical ${operation} operation`, 'info');
}

// NEW: Confirm Arrays Count Handler
function handleConfirmArraysCount() {
    const count = parseInt(logicalArraysCountInput.value);

    if (isNaN(count) || count < 2 || count > 5) {
        showNotification('Please enter a valid number of arrays between 2 and 5', 'danger');
        logicalArraysCountInput.focus();
        return;
    }

    logicalArraysCount = count;

    // Create size input fields for each array
    arraysSizeInputs.innerHTML = '<label class="form-label">Enter sizes for each array:</label>';
    for (let i = 0; i < count; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Array ${i + 1} Size</span>
            <input type="number" class="form-control logical-array-size" 
                   placeholder="Enter size" data-array="${i}" min="1" max="20">
        `;
        arraysSizeInputs.appendChild(inputGroup);
    }

    // Add event listeners for size inputs
    const sizeInputs = arraysSizeInputs.querySelectorAll('.logical-array-size');
    sizeInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('logical-array-size')) {
                    nextInput.focus();
                } else {
                    // All sizes entered, proceed to elements
                    handleConfirmArraysSizes();
                }
            }
        });
    });

    showNotification(`Configured ${count} arrays. Please enter sizes for each array.`, 'success');
}

// NEW: Handle Confirm Arrays Sizes
function handleConfirmArraysSizes() {
    const sizeInputs = arraysSizeInputs.querySelectorAll('.logical-array-size');
    logicalArraysSizes = [];

    // Collect sizes
    for (let i = 0; i < sizeInputs.length; i++) {
        const size = parseInt(sizeInputs[i].value);
        if (isNaN(size) || size < 1 || size > 20) {
            showNotification(`Please enter a valid size for Array ${i + 1} (1-20)`, 'danger');
            sizeInputs[i].focus();
            return;
        }
        logicalArraysSizes.push(size);
    }

    // Create element input fields
    arraysElementsInputs.innerHTML = '<label class="form-label">Enter elements for each array (0 or 1 for logical operations):</label>';
    
    for (let i = 0; i < logicalArraysCount; i++) {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'mb-3';
        arrayGroup.innerHTML = `<h6>Array ${i + 1} (Size: ${logicalArraysSizes[i]}):</h6>`;
        
        for (let j = 0; j < logicalArraysSizes[i]; j++) {
            const inputGroup = document.createElement('div');
            inputGroup.className = 'input-group mb-2';
            inputGroup.innerHTML = `
                <span class="input-group-text">Element ${j}</span>
                <input type="number" class="form-control logical-array-element" 
                       placeholder="Enter 0 or 1" data-array="${i}" data-index="${j}" min="0" max="1">
            `;
            arrayGroup.appendChild(inputGroup);
        }
        arraysElementsInputs.appendChild(arrayGroup);
    }

    // Add event listeners for element inputs
    const elementInputs = arraysElementsInputs.querySelectorAll('.logical-array-element');
    elementInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('logical-array-element')) {
                    nextInput.focus();
                }
            }
        });
    });

    // Show perform button
    performLogicalOperationBtn.style.display = 'block';
    performLogicalOperationBtn.innerHTML = `<i class="fas fa-play me-2"></i>Perform Logical ${logicalOperationType}`;

    showNotification(`Sizes confirmed. Please enter elements (0 or 1) for each array.`, 'success');
}

// NEW: Perform Logical Operation Handler
function handlePerformLogicalOperation() {
    logicalArrays = [];

    // Collect elements for each array
    for (let i = 0; i < logicalArraysCount; i++) {
        const arrayElements = [];
        const elements = arraysElementsInputs.querySelectorAll(`.logical-array-element[data-array="${i}"]`);
        
        for (let j = 0; j < elements.length; j++) {
            const value = elements[j].value.trim();
            if (value === '') {
                showNotification(`Please enter all elements for Array ${i + 1}. Missing element at position ${j}`, 'danger');
                elements[j].focus();
                return;
            }
            if (value !== '0' && value !== '1') {
                showNotification(`Please enter only 0 or 1 for logical operations. Invalid value at Array ${i + 1}, position ${j}`, 'danger');
                elements[j].focus();
                return;
            }
            arrayElements.push(parseInt(value));
        }
        logicalArrays.push(arrayElements);
    }

    // Check if all arrays have the same size
    const firstSize = logicalArrays[0].length;
    for (let i = 1; i < logicalArrays.length; i++) {
        if (logicalArrays[i].length !== firstSize) {
            showNotification('All arrays must have the same size for element-wise operations', 'danger');
            return;
        }
    }

    // Store original array
    originalArrayForLogical = [...myArray];

    // Hide input group
    logicalOperationsGroup.style.display = 'none';

    // Start logical operation visualization
    showLogicalOperationVisualization();
}

// NEW: Cancel Logical Operation Handler
function handleCancelLogicalOperation() {
    logicalOperationsGroup.style.display = 'none';
    logicalArraysCountInput.value = '';
    arraysSizeInputs.innerHTML = '';
    arraysElementsInputs.innerHTML = '';
    performLogicalOperationBtn.style.display = 'none';

    logicalArrays = [];
    logicalOperationType = '';
    logicalArraysCount = 0;
    logicalArraysSizes = [];

    logOperation('Cancelled logical operation', 'info');
    showNotification('Logical operation cancelled', 'info');
}

// NEW: Show Logical Operation Visualization
function showLogicalOperationVisualization() {
    isLogicalOperationRunning = true;

    const container = document.createElement('div');
    container.className = 'logical-operation-container';
    container.innerHTML = `
        <h5 class="text-center mb-3">Element-wise Logical ${logicalOperationType} Operation</h5>
        
        <div id="logicalArraysDisplay" class="mb-4"></div>
        
        <div class="operation-arrow text-center mb-3">
            <i class="fas fa-arrow-down fa-2x"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Result Array (Logical ${logicalOperationType})</div>
            <div class="transformed-array-container" id="logicalResultArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Logical ${logicalOperationType} Operation:</strong> Performing element-wise ${logicalOperationType.toLowerCase()} operation</p>
            <p class="mb-0" id="logicalExplanation">Starting logical operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="logicalStepsContainer">
            <h6 class="text-center">Logical Operation Steps</h6>
            <div class="steps-container" id="logicalSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterLogical" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;

    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(container);

    // Display input arrays
    displayLogicalArrays();

    // Start logical operation animation
    performLogicalOperationAnimation();
}

// NEW: Display Logical Arrays
function displayLogicalArrays() {
    const arraysDisplay = document.getElementById('logicalArraysDisplay');
    arraysDisplay.innerHTML = '';

    logicalArrays.forEach((array, index) => {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'array-group mb-3';
        arrayGroup.innerHTML = `
            <div class="array-label">Input Array ${index + 1}</div>
            <div class="original-array-container" id="logicalArray${index}"></div>
        `;
        arraysDisplay.appendChild(arrayGroup);
        renderArrayInContainer(array.map(val => val.toString()), `logicalArray${index}`);
    });
}

// NEW: Perform Logical Operation Animation
function performLogicalOperationAnimation() {
    const explanation = document.getElementById('logicalExplanation');
    const stepsContainer = document.getElementById('logicalSteps');
    const continueButton = document.getElementById('continueAfterLogical');

    const arraySize = logicalArrays[0].length;
    let resultArray = [];
    let currentIndex = 0;

    function performLogicalStep() {
        if (currentIndex >= arraySize) {
            // Operation completed
            explanation.innerHTML = `<strong>Logical ${logicalOperationType} Operation Completed!</strong>`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Logical ${logicalOperationType} operation completed. Result: [${resultArray.join(', ')}]
                </div>
            `;

            // Highlight the result array
            const resultElements = document.querySelectorAll('#logicalResultArray .array-element');
            resultElements.forEach((el, index) => {
                setTimeout(() => {
                    const valueDiv = el.querySelector('.element-value');
                    valueDiv.classList.add('logical-operation-result');
                }, index * 200);
            });

            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterLogical();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterLogical);
            
            return;
        }

        // Show current step
        explanation.innerHTML = `Processing element at index ${currentIndex}`;

        // Highlight current elements in all arrays
        for (let i = 0; i < logicalArraysCount; i++) {
            const arrayContainer = document.getElementById(`logicalArray${i}`);
            const elements = arrayContainer.querySelectorAll('.array-element');
            if (elements[currentIndex]) {
                const valueDiv = elements[currentIndex].querySelector('.element-value');
                valueDiv.classList.add('logical-operation-current');
                
                // Color based on value
                if (logicalArrays[i][currentIndex] === 1) {
                    valueDiv.classList.add('logical-true');
                } else {
                    valueDiv.classList.add('logical-false');
                }
            }
        }

        // Perform logical operation
        let result;
        if (logicalOperationType === 'AND') {
            result = logicalArrays.reduce((acc, array) => acc && array[currentIndex], 1);
        } else { // OR
            result = logicalArrays.reduce((acc, array) => acc || array[currentIndex], 0);
        }

        resultArray.push(result);

        // Update result array display
        renderArrayInContainer(resultArray.map(val => val.toString()), 'logicalResultArray');

        // Add step explanation
        const currentValues = logicalArrays.map(array => array[currentIndex]);
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex + 1}:</strong> 
                Values: [${currentValues.join(', ')}]  
                ${logicalOperationType} = ${result}
                (${currentValues.join(` ${logicalOperationType.toLowerCase()} `)} = ${result})
            </div>
        `;

        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;

        setTimeout(() => {
            // Remove highlights
            for (let i = 0; i < logicalArraysCount; i++) {
                const arrayContainer = document.getElementById(`logicalArray${i}`);
                const elements = arrayContainer.querySelectorAll('.array-element');
                if (elements[currentIndex]) {
                    const valueDiv = elements[currentIndex].querySelector('.element-value');
                    valueDiv.classList.remove('logical-operation-current', 'logical-true', 'logical-false');
                }
            }

            // Highlight result
            const resultContainer = document.getElementById('logicalResultArray');
            const resultElements = resultContainer.querySelectorAll('.array-element');
            if (resultElements[currentIndex]) {
                const resultValueDiv = resultElements[currentIndex].querySelector('.element-value');
                if (result === 1) {
                    resultValueDiv.classList.add('logical-true');
                } else {
                    resultValueDiv.classList.add('logical-false');
                }
            }

            currentIndex++;
            performLogicalStep();
        }, 2000);
    }

    // Start logical operation process
    performLogicalStep();
}

// NEW: Return to Original after Logical Operation
function returnToOriginalAfterLogical() {
    // Reset to original array
    myArray = [...originalArrayForLogical];
    originalArrayForLogical = [];

    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();

    // Reset state
    isLogicalOperationRunning = false;

    // Clear all logical operation data
    logicalArrays = [];
    logicalOperationType = '';
    logicalArraysCount = 0;
    logicalArraysSizes = [];

    // Reset input groups
    logicalOperationsGroup.style.display = 'none';
    logicalArraysCountInput.value = '';
    arraysSizeInputs.innerHTML = '';
    arraysElementsInputs.innerHTML = '';
    performLogicalOperationBtn.style.display = 'none';

    logOperation(`Logical ${logicalOperationType} operation completed - returned to original array`, 'info');
    showNotification(`Returned to original array after logical ${logicalOperationType} operation`, 'success');
}
// NEW: Calculate Standard Deviation Handler
function handleCalculateStdDev() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isStatsCalcRunning) {
        showNotification('A statistical operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Statistical operations require all array elements to be numbers', 'danger');
        return;
    }
    
    isStatsCalcRunning = true;
    
    // Store original array
    statsOriginalArray = [...myArray];
    
    // Show standard deviation visualization
    showStandardDeviationVisualization();
}

// NEW: Calculate Variance Handler
function handleCalculateVariance() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isStatsCalcRunning) {
        showNotification('A statistical operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Statistical operations require all array elements to be numbers', 'danger');
        return;
    }
    
    isStatsCalcRunning = true;
    
    // Store original array
    statsOriginalArray = [...myArray];
    
    // Show variance visualization
    showVarianceVisualization();
}

// NEW: Show Standard Deviation Visualization
function showStandardDeviationVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Standard Deviation Calculation</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalStatsArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Statistical Calculation Process</div>
            <div class="transformed-array-container" id="transformedStatsArray"></div>
        </div>
        
        <div class="statistical-results">
            <p class="mb-2"><strong>Standard Deviation Formula:</strong></p>
            <div class="statistical-formula">
                 = [ (x - ) / N ]
            </div>
            <p class="mb-0" id="statsExplanation">Starting standard deviation calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="statsStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="statsSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Standard Deviation ()</div>
            <div class="stats-value" id="stdDevValue">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterStats" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(statsOriginalArray, 'originalStatsArray');
    renderArrayInContainer([...statsOriginalArray], 'transformedStatsArray');
    
    performStandardDeviationCalculation();
}

// NEW: Show Variance Visualization
function showVarianceVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Variance Calculation</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalStatsArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Statistical Calculation Process</div>
            <div class="transformed-array-container" id="transformedStatsArray"></div>
        </div>
        
        <div class="statistical-results">
            <p class="mb-2"><strong>Variance Formula:</strong></p>
            <div class="statistical-formula">
                 = (x - ) / N
            </div>
            <p class="mb-0" id="statsExplanation">Starting variance calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="statsStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="statsSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Variance ()</div>
            <div class="stats-value" id="varianceValue">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterStats" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(statsOriginalArray, 'originalStatsArray');
    renderArrayInContainer([...statsOriginalArray], 'transformedStatsArray');
    
    performVarianceCalculation();
}

// NEW: Perform Standard Deviation Calculation with Animation
function performStandardDeviationCalculation() {
    const originalContainer = document.getElementById('originalStatsArray');
    const transformedContainer = document.getElementById('transformedStatsArray');
    const explanation = document.getElementById('statsExplanation');
    const stepsContainer = document.getElementById('statsSteps');
    const stdDevValue = document.getElementById('stdDevValue');
    const continueButton = document.getElementById('continueAfterStats');
    
    const arr = statsOriginalArray.map(val => parseFloat(val));
    const n = arr.length;
    let step = 0;
    let mean = 0;
    let sumSquaredDeviations = 0;
    let variance = 0;
    let stdDev = 0;
    
    function performCalculationStep() {
        switch (step) {
            case 0:
                // Step 1: Calculate mean
                explanation.innerHTML = "Step 1: Calculate the mean (average) of all elements";
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Calculate mean = (x) / N
                    </div>
                `;
                
                // Highlight all elements for mean calculation
                const originalElements = originalContainer.querySelectorAll('.array-element');
                originalElements.forEach((el, index) => {
                    setTimeout(() => {
                        el.querySelector('.element-value').classList.add('statistical-mean');
                    }, index * 200);
                });
                
                setTimeout(() => {
                    // Calculate mean
                    mean = arr.reduce((sum, val) => sum + val, 0) / n;
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Mean Calculation:</strong> (${arr.join(' + ')}) / ${n} = ${mean.toFixed(2)}
                        </div>
                    `;
                    step++;
                    performCalculationStep();
                }, n * 200 + 500);
                break;
                
            case 1:
                // Step 2: Calculate squared deviations
                explanation.innerHTML = "Step 2: Calculate squared deviations from mean for each element";
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Calculate (x - ) for each element
                    </div>
                `;
                
                let currentIndex = 0;
                
                function processDeviation(index) {
                    if (index >= n) {
                        step++;
                        performCalculationStep();
                        return;
                    }
                    
                    explanation.innerHTML = `Step 2: Calculating deviation for element [${index}] = ${arr[index]}`;
                    
                    const elements = transformedContainer.querySelectorAll('.array-element');
                    const currentElement = elements[index].querySelector('.element-value');
                    currentElement.classList.add('statistical-deviation');
                    
                    setTimeout(() => {
                        const deviation = arr[index] - mean;
                        const squaredDeviation = deviation * deviation;
                        sumSquaredDeviations += squaredDeviation;
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Element ${index}:</strong> (${arr[index]} - ${mean.toFixed(2)}) = ${squaredDeviation.toFixed(2)}
                            </div>
                        `;
                        
                        currentElement.classList.remove('statistical-deviation');
                        currentElement.classList.add('statistical-variance');
                        
                        processDeviation(index + 1);
                    }, 1000);
                }
                
                processDeviation(0);
                break;
                
            case 2:
                // Step 3: Calculate variance
                explanation.innerHTML = "Step 3: Calculate variance = (x - ) / N";
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Variance = ${sumSquaredDeviations.toFixed(2)} / ${n}
                    </div>
                `;
                
                setTimeout(() => {
                    variance = sumSquaredDeviations / n;
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Variance:</strong> ${variance.toFixed(2)}
                        </div>
                    `;
                    step++;
                    performCalculationStep();
                }, 1500);
                break;
                
            case 3:
                // Step 4: Calculate standard deviation
                explanation.innerHTML = "Step 4: Calculate standard deviation = variance";
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 4:</strong> Standard Deviation = ${variance.toFixed(2)}
                    </div>
                `;
                
                setTimeout(() => {
                    stdDev = Math.sqrt(variance);
                    stdDevValue.textContent = stdDev.toFixed(4);
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Standard Deviation:</strong> ${stdDev.toFixed(4)}
                        </div>
                    `;
                    
                    // Highlight final result
                    const elements = transformedContainer.querySelectorAll('.array-element');
                    elements.forEach(el => {
                        el.querySelector('.element-value').classList.add('statistical-stddev');
                    });
                    
                    explanation.innerHTML = `<strong>Calculation Complete!</strong> Standard Deviation = ${stdDev.toFixed(4)}`;
                    
                    continueButton.style.display = 'block';
                    
                    // Auto-return after 5 seconds
                    setTimeout(() => {
                        returnToOriginalAfterStats();
                    }, 5000);
                    
                    continueButton.addEventListener('click', returnToOriginalAfterStats);
                }, 1500);
                break;
        }
    }
    
    // Start calculation process
    performCalculationStep();
}

// NEW: Perform Variance Calculation with Animation
function performVarianceCalculation() {
    const originalContainer = document.getElementById('originalStatsArray');
    const transformedContainer = document.getElementById('transformedStatsArray');
    const explanation = document.getElementById('statsExplanation');
    const stepsContainer = document.getElementById('statsSteps');
    const varianceValue = document.getElementById('varianceValue');
    const continueButton = document.getElementById('continueAfterStats');
    
    const arr = statsOriginalArray.map(val => parseFloat(val));
    const n = arr.length;
    let step = 0;
    let mean = 0;
    let sumSquaredDeviations = 0;
    let variance = 0;
    
    function performCalculationStep() {
        switch (step) {
            case 0:
                // Step 1: Calculate mean
                explanation.innerHTML = "Step 1: Calculate the mean (average) of all elements";
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Calculate mean = (x) / N
                    </div>
                `;
                
                // Highlight all elements for mean calculation
                const originalElements = originalContainer.querySelectorAll('.array-element');
                originalElements.forEach((el, index) => {
                    setTimeout(() => {
                        el.querySelector('.element-value').classList.add('statistical-mean');
                    }, index * 200);
                });
                
                setTimeout(() => {
                    // Calculate mean
                    mean = arr.reduce((sum, val) => sum + val, 0) / n;
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Mean Calculation:</strong> (${arr.join(' + ')}) / ${n} = ${mean.toFixed(2)}
                        </div>
                    `;
                    step++;
                    performCalculationStep();
                }, n * 200 + 500);
                break;
                
            case 1:
                // Step 2: Calculate squared deviations
                explanation.innerHTML = "Step 2: Calculate squared deviations from mean for each element";
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Calculate (x - ) for each element
                    </div>
                `;
                
                let currentIndex = 0;
                
                function processDeviation(index) {
                    if (index >= n) {
                        step++;
                        performCalculationStep();
                        return;
                    }
                    
                    explanation.innerHTML = `Step 2: Calculating deviation for element [${index}] = ${arr[index]}`;
                    
                    const elements = transformedContainer.querySelectorAll('.array-element');
                    const currentElement = elements[index].querySelector('.element-value');
                    currentElement.classList.add('statistical-deviation');
                    
                    setTimeout(() => {
                        const deviation = arr[index] - mean;
                        const squaredDeviation = deviation * deviation;
                        sumSquaredDeviations += squaredDeviation;
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Element ${index}:</strong> (${arr[index]} - ${mean.toFixed(2)}) = ${squaredDeviation.toFixed(2)}
                            </div>
                        `;
                        
                        currentElement.classList.remove('statistical-deviation');
                        currentElement.classList.add('statistical-variance');
                        
                        processDeviation(index + 1);
                    }, 1000);
                }
                
                processDeviation(0);
                break;
                
            case 2:
                // Step 3: Calculate variance
                explanation.innerHTML = "Step 3: Calculate variance = (x - ) / N";
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Variance = ${sumSquaredDeviations.toFixed(2)} / ${n}
                    </div>
                `;
                
                setTimeout(() => {
                    variance = sumSquaredDeviations / n;
                    varianceValue.textContent = variance.toFixed(4);
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Variance:</strong> ${variance.toFixed(4)}
                        </div>
                    `;
                    
                    // Highlight final result
                    const elements = transformedContainer.querySelectorAll('.array-element');
                    elements.forEach(el => {
                        el.querySelector('.element-value').classList.add('statistical-variance');
                    });
                    
                    explanation.innerHTML = `<strong>Calculation Complete!</strong> Variance = ${variance.toFixed(4)}`;
                    
                    continueButton.style.display = 'block';
                    
                    // Auto-return after 5 seconds
                    setTimeout(() => {
                        returnToOriginalAfterStats();
                    }, 5000);
                    
                    continueButton.addEventListener('click', returnToOriginalAfterStats);
                }, 1500);
                break;
        }
    }
    
    // Start calculation process
    performCalculationStep();
}

// NEW: Return to Original after Statistical Operations
function returnToOriginalAfterStats() {
    // Reset to original array
    myArray = [...statsOriginalArray];
    statsOriginalArray = []; // Clear the stored array
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isStatsCalcRunning = false;
    
    logOperation('Statistical calculation completed - returned to original array', 'info');
    showNotification('Returned to original array after statistical calculation', 'success');
}
// NEW: Scalar Operations Handler
function handleScalarOperation(operation) {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isScalarOperationRunning) {
        showNotification('A scalar operation is already in progress', 'warning');
        return;
    }
    
    // Get the scalar value based on the operation
    let scalarInput;
    switch(operation) {
        case 'add': scalarInput = scalarValue; break;
        case 'subtract': scalarInput = scalarValueSubtract; break;
        case 'multiply': scalarInput = scalarValueMultiply; break;
        case 'divide': scalarInput = scalarValueDivide; break;
    }
    
    const scalar = parseFloat(scalarInput.value);
    
    if (isNaN(scalar)) {
        showNotification('Please enter a valid scalar value', 'danger');
        scalarInput.focus();
        return;
    }
    
    if (operation === 'divide' && scalar === 0) {
        showNotification('Cannot divide by zero', 'danger');
        scalarInput.focus();
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Scalar operations require all array elements to be numbers', 'danger');
        return;
    }
    
    isScalarOperationRunning = true;
    
    // Store original array
    originalArrayForScalar = [...myArray];
    
    // Perform scalar operation visualization
    performScalarOperationVisualization(operation, scalar);
}
// NEW: Perform Scalar Operation Visualization
function performScalarOperationVisualization(operation, scalar) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    
    const operationNames = {
        'add': 'Add',
        'subtract': 'Subtract', 
        'multiply': 'Multiply',
        'divide': 'Divide'
    };
    
    const operationSymbols = {
        'add': '+',
        'subtract': '-',
        'multiply': '',
        'divide': ''
    };
    
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Scalar Operation: ${operationNames[operation]} ${scalar}</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalScalarArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After ${operationNames[operation]} ${operationSymbols[operation]} ${scalar}</div>
            <div class="transformed-array-container" id="transformedScalarArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Scalar Operation:</strong> Applying ${operation} ${scalar} to every element</p>
            <p class="mb-0" id="scalarExplanation">Starting scalar operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="scalarStepsContainer">
            <h6 class="text-center">Scalar Operation Steps</h6>
            <div class="steps-container" id="scalarSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterScalar" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForScalar, 'originalScalarArray');
    renderArrayInContainer([...originalArrayForScalar], 'transformedScalarArray');
    
    performScalarOperationAnimation(operation, scalar);
}

// NEW: Perform Scalar Operation Animation
function performScalarOperationAnimation(operation, scalar) {
    const originalContainer = document.getElementById('originalScalarArray');
    const transformedContainer = document.getElementById('transformedScalarArray');
    const explanation = document.getElementById('scalarExplanation');
    const stepsContainer = document.getElementById('scalarSteps');
    const continueButton = document.getElementById('continueAfterScalar');
    
    const originalArray = [...originalArrayForScalar];
    let transformedArray = [...originalArray];
    let currentIndex = 0;
    
    function performScalarStep() {
        if (currentIndex >= originalArray.length) {
            // Operation completed
            explanation.innerHTML = `<strong>Scalar Operation Completed!</strong> Applied ${operation} ${scalar} to all elements.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Scalar operation completed on all ${originalArray.length} elements
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterScalar();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterScalar);
            
            return;
        }
        
        const originalValue = parseFloat(originalArray[currentIndex]);
        let newValue;
        
        switch(operation) {
            case 'add':
                newValue = originalValue + scalar;
                break;
            case 'subtract':
                newValue = originalValue - scalar;
                break;
            case 'multiply':
                newValue = originalValue * scalar;
                break;
            case 'divide':
                newValue = originalValue / scalar;
                break;
        }
        
        // Update explanation
        explanation.innerHTML = `Processing element [${currentIndex}]: ${originalValue} ${getOperationSymbol(operation)} ${scalar} = ${newValue.toFixed(2)}`;
        
        // Highlight current element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        
        const originalElement = originalElements[currentIndex].querySelector('.element-value');
        const transformedElement = transformedElements[currentIndex].querySelector('.element-value');
        
        originalElement.classList.add('transform-animation');
        transformedElement.classList.add('transform-animation');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex + 1}:</strong> [${currentIndex}] ${originalValue} ${getOperationSymbol(operation)} ${scalar} = ${newValue.toFixed(2)}
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Update the transformed array value
            transformedArray[currentIndex] = newValue.toString();
            renderArrayInContainer(transformedArray, 'transformedScalarArray');
            
            // Remove highlights
            originalElement.classList.remove('transform-animation');
            
            // Move to next element
            currentIndex++;
            performScalarStep();
        }, 1000);
    }
    
    // Helper function to get operation symbol
    function getOperationSymbol(op) {
        switch(op) {
            case 'add': return '+';
            case 'subtract': return '-';
            case 'multiply': return '';
            case 'divide': return '';
            default: return '?';
        }
    }
    
    // Start the scalar operation
    performScalarStep();
}

// NEW: Return to Original after Scalar Operation
function returnToOriginalAfterScalar() {
    // Reset to original array
    myArray = [...originalArrayForScalar];
    originalArrayForScalar = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isScalarOperationRunning = false;
    
    // Clear input fields
    scalarValue.value = '';
    scalarValueSubtract.value = '';
    scalarValueMultiply.value = '';
    scalarValueDivide.value = '';
    
    logOperation('Scalar operation completed - returned to original array', 'info');
    showNotification('Returned to original array after scalar operation', 'success');
}
// NEW: Trigonometric Operations Handler
function handleTrigOperation(operation) {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isTrigOperationRunning) {
        showNotification('A trigonometric operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains valid numbers for trigonometric operations
    let allValidNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        const num = parseFloat(myArray[i]);
        if (isNaN(num)) {
            allValidNumbers = false;
            break;
        }
    }
    
    if (!allValidNumbers) {
        showNotification('Trigonometric operations require all array elements to be valid numbers', 'danger');
        return;
    }
    
    isTrigOperationRunning = true;
    currentTrigOperation = operation;
    
    // Store original array
    originalArrayForTrig = [...myArray];
    
    // Show trigonometric operation visualization
    showTrigVisualization(operation);
}
// NEW: Show Trigonometric Visualization
function showTrigVisualization(operation) {
    const operationNames = {
        'sin': 'Sine',
        'cos': 'Cosine', 
        'tan': 'Tangent'
    };
    
    const operationIcons = {
        'sin': 'fa-wave-square',
        'cos': 'fa-wave-circle',
        'tan': 'fa-chart-line'
    };
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">${operationNames[operation]} Operation (in Radians)</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array (Radians)</div>
            <div class="original-array-container" id="originalTrigArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas ${operationIcons[operation]}"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">${operationNames[operation]} Values</div>
            <div class="transformed-array-container" id="transformedTrigArray"></div>
        </div>
        
        <div class="trig-explanation">
            <p class="mb-2"><strong>${operationNames[operation]} Function:</strong> Calculating ${operation} for each element in radians</p>
            <p class="mb-0" id="trigExplanation">Starting ${operationNames[operation].toLowerCase()} calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="trigStepsContainer">
            <h6 class="text-center">${operationNames[operation]} Calculation Steps</h6>
            <div class="steps-container" id="trigSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterTrig" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForTrig, 'originalTrigArray');
    renderArrayInContainer([...originalArrayForTrig], 'transformedTrigArray');
    
    performTrigAnimation(operation);
}
// NEW: Perform Trigonometric Animation
function performTrigAnimation(operation) {
    const originalContainer = document.getElementById('originalTrigArray');
    const transformedContainer = document.getElementById('transformedTrigArray');
    const explanation = document.getElementById('trigExplanation');
    const stepsContainer = document.getElementById('trigSteps');
    const continueButton = document.getElementById('continueAfterTrig');
    
    const operationNames = {
        'sin': 'Sine',
        'cos': 'Cosine',
        'tan': 'Tangent'
    };
    
    const operationFunctions = {
        'sin': (x) => Math.sin(x),
        'cos': (x) => Math.cos(x),
        'tan': (x) => Math.tan(x)
    };
    
    const originalArray = originalArrayForTrig.map(val => parseFloat(val));
    let transformedArray = [...originalArray];
    let currentIndex = 0;
    
    function performTrigStep() {
        if (currentIndex >= originalArray.length) {
            // Operation completed
            explanation.innerHTML = `<strong>${operationNames[operation]} Operation Completed!</strong> All elements processed.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> ${operationNames[operation]} calculation completed for all ${originalArray.length} elements
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterTrig();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterTrig);
            
            return;
        }
        
        const currentValue = originalArray[currentIndex];
        const trigValue = operationFunctions[operation](currentValue);
        
        // Update explanation
        explanation.innerHTML = `Calculating ${operation}(${currentValue}) = ${trigValue.toFixed(4)}`;
        
        // Highlight current element in original array
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentOriginalElement = originalElements[currentIndex].querySelector('.element-value');
        currentOriginalElement.classList.add('trig-operation-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex + 1}:</strong> ${operation}(${currentValue}) = ${trigValue.toFixed(4)}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Remove highlight from original element
            currentOriginalElement.classList.remove('trig-operation-current');
            currentOriginalElement.classList.add('trig-operation-original');
            
            // Update transformed array
            transformedArray[currentIndex] = trigValue.toFixed(4);
            renderArrayInContainer(transformedArray, 'transformedTrigArray');
            
            // Highlight the transformed element
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const currentTransformedElement = transformedElements[currentIndex].querySelector('.element-value');
            currentTransformedElement.classList.add('trig-operation-transformed');
            
            // Move to next element
            currentIndex++;
            performTrigStep();
        }, 2000);
    }
    
    // Start trigonometric operation
    performTrigStep();
}
// NEW: Return to Original after Trigonometric Operation
function returnToOriginalAfterTrig() {
    // Reset to original array
    myArray = [...originalArrayForTrig];
    originalArrayForTrig = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isTrigOperationRunning = false;
    currentTrigOperation = null;
    
    logOperation(`Trigonometric ${currentTrigOperation} operation completed - returned to original array`, 'info');
    showNotification('Returned to original array after trigonometric operation', 'success');
}
// NEW: Find Range Handler
function handleFindRange() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isRangeOperationRunning) {
        showNotification('A range operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Range calculation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isRangeOperationRunning = true;
    
    // Store original array
    originalArrayForRange = [...myArray];
    
    // Show range visualization
    showRangeVisualization();
}

// NEW: Show Range Visualization
function showRangeVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find Range (Max - Min) Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalRangeArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Range Finding Process</div>
            <div class="transformed-array-container" id="transformedRangeArray"></div>
        </div>
        
        <div class="range-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Linear Scan - Find minimum and maximum elements</p>
            <p class="mb-0" id="rangeExplanation">Initializing range calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="rangeStepsContainer">
            <h6 class="text-center">Range Calculation Steps</h6>
            <div class="steps-container" id="rangeSteps"></div>
        </div>
        
        <div class="range-result mt-3" id="rangeResult" style="display: none;">
            <h6 class="text-center">Range Result</h6>
            <div class="stats-card">
                <div>Minimum Element</div>
                <div class="stats-value" id="minValue">-</div>
            </div>
            <div class="stats-card">
                <div>Maximum Element</div>
                <div class="stats-value" id="maxValue">-</div>
            </div>
            <div class="stats-card">
                <div>Range (Max - Min)</div>
                <div class="stats-value" id="rangeValue">-</div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterRange" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForRange, 'originalRangeArray');
    renderArrayInContainer([...originalArrayForRange], 'transformedRangeArray');
    
    performRangeCalculation();
}

// NEW: Perform Range Calculation with Animation
function performRangeCalculation() {
    const originalContainer = document.getElementById('originalRangeArray');
    const transformedContainer = document.getElementById('transformedRangeArray');
    const explanation = document.getElementById('rangeExplanation');
    const stepsContainer = document.getElementById('rangeSteps');
    const rangeResult = document.getElementById('rangeResult');
    const minValue = document.getElementById('minValue');
    const maxValue = document.getElementById('maxValue');
    const rangeValue = document.getElementById('rangeValue');
    const continueButton = document.getElementById('continueAfterRange');
    
    const arr = originalArrayForRange.map(val => parseFloat(val));
    let min = arr[0];
    let max = arr[0];
    let minIndex = 0;
    let maxIndex = 0;
    let currentIndex = 0;
    let step = 0;
    
    function performRangeStep() {
        if (currentIndex >= arr.length) {
            // Range calculation completed
            const range = max - min;
            
            explanation.innerHTML = `<strong>Range Calculation Completed!</strong> Range = ${max} - ${min} = ${range}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Range = ${max} (max) - ${min} (min) = ${range}
                </div>
            `;
            
            // Highlight the final min and max elements
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            
            // Highlight min element
            setTimeout(() => {
                transformedElements[minIndex].querySelector('.element-value').classList.add('range-min');
            }, 500);
            
            // Highlight max element
            setTimeout(() => {
                transformedElements[maxIndex].querySelector('.element-value').classList.add('range-max');
            }, 1500);
            
            // Show results
            rangeResult.style.display = 'block';
            minValue.textContent = `${min} (index ${minIndex})`;
            maxValue.textContent = `${max} (index ${maxIndex})`;
            rangeValue.textContent = range;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterRange();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterRange);
            
            return;
        }
        
        step++;
        const currentValue = arr[currentIndex];
        
        explanation.innerHTML = `Step ${step}: Checking element at index ${currentIndex} = ${currentValue}`;
        
        // Highlight current element being checked
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        const currentElement = transformedElements[currentIndex].querySelector('.element-value');
        currentElement.classList.add('range-current');
        
        let stepDescription = '';
        let isNewMin = false;
        let isNewMax = false;
        
        if (currentValue < min) {
            min = currentValue;
            minIndex = currentIndex;
            stepDescription = `New minimum found! Min = ${min} at index ${minIndex}`;
            isNewMin = true;
        } else if (currentValue > max) {
            max = currentValue;
            maxIndex = currentIndex;
            stepDescription = `New maximum found! Max = ${max} at index ${maxIndex}`;
            isNewMax = true;
        } else {
            stepDescription = `Current: Min = ${min}, Max = ${max}`;
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${isNewMin || isNewMax ? 'active' : ''}">
                <strong>Step ${step}:</strong> [${currentIndex}] = ${currentValue} - ${stepDescription}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Remove current highlight
            currentElement.classList.remove('range-current');
            
            // Highlight if this is new min or max
            if (isNewMin) {
                // Remove previous min highlight if exists
                if (currentIndex !== minIndex) {
                    const previousMinElement = transformedElements[minIndex]?.querySelector('.element-value');
                    if (previousMinElement) {
                        previousMinElement.classList.remove('range-min');
                    }
                }
                currentElement.classList.add('range-min');
            }
            
            if (isNewMax) {
                // Remove previous max highlight if exists
                if (currentIndex !== maxIndex) {
                    const previousMaxElement = transformedElements[maxIndex]?.querySelector('.element-value');
                    if (previousMaxElement) {
                        previousMaxElement.classList.remove('range-max');
                    }
                }
                currentElement.classList.add('range-max');
            }
            
            // Move to next element
            currentIndex++;
            performRangeStep();
        }, 2000);
    }
    
    // Show algorithm explanation first
    explanation.innerHTML = `
        <strong>Linear Scan Algorithm:</strong><br>
        1. Initialize min and max with first element<br>
        2. Iterate through each element<br>
        3. Update min if current element is smaller<br>
        4. Update max if current element is larger<br>
        5. Calculate range = max - min
    `;
    
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Algorithm:</strong> Linear Scan - Time Complexity: O(n), Space Complexity: O(1)
        </div>
        <div class="algorithm-step active">
            <strong>Step 0:</strong> Initialize min = ${min}, max = ${max} (first element)
        </div>
    `;
    
    // Start with second element (index 1)
    currentIndex = 1;
    setTimeout(() => {
        performRangeStep();
    }, 3000);
}

// NEW: Return to Original after Range Operation
function returnToOriginalAfterRange() {
    // Reset to original array
    myArray = [...originalArrayForRange];
    originalArrayForRange = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isRangeOperationRunning = false;
    
    logOperation('Range calculation completed - returned to original array', 'info');
    showNotification('Returned to original array after range calculation', 'success');
}
// NEW: Mathematical Operations Handler
function handleMathOperation(operation) {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isMathOperationRunning) {
        showNotification('A mathematical operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains valid numbers
    let allValidNumbers = true;
    let hasInvalidForLog = false;
    
    for (let i = 0; i < myArray.length; i++) {
        const num = parseFloat(myArray[i]);
        if (isNaN(num)) {
            allValidNumbers = false;
            break;
        }
        // For log operations, check for non-positive numbers
        if ((operation === 'naturalLog' || operation === 'log10') && num <= 0) {
            hasInvalidForLog = true;
        }
    }
    
    if (!allValidNumbers) {
        showNotification('Mathematical operations require all array elements to be valid numbers', 'danger');
        return;
    }
    
    if (hasInvalidForLog) {
        showNotification('Logarithm operations require all array elements to be positive numbers (> 0)', 'danger');
        return;
    }
    
    isMathOperationRunning = true;
    currentMathOperation = operation;
    
    // Store original array
    originalArrayForMath = [...myArray];
    
    // Show mathematical operation visualization
    showMathOperationVisualization(operation);
}
// NEW: Show Mathematical Operation Visualization
function showMathOperationVisualization(operation) {
    const operationNames = {
        'exponential': 'Exponential (e^x)',
        'naturalLog': 'Natural Logarithm (ln x)',
        'log10': 'Base-10 Logarithm (log x)'
    };
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">${operationNames[operation]} Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalMathArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Transformed Array</div>
            <div class="transformed-array-container" id="transformedMathArray"></div>
        </div>
        
        <div class="math-explanation">
            <p class="mb-2"><strong>Mathematical Operation:</strong> Applying ${operationNames[operation]} to each element</p>
            <p class="mb-0" id="mathExplanation">Starting ${operationNames[operation]} calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="mathStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="mathSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMath" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForMath, 'originalMathArray');
    renderArrayInContainer([...originalArrayForMath], 'transformedMathArray');
    
    performMathOperationAnimation(operation);
}
// NEW: Perform Mathematical Operation Animation
function performMathOperationAnimation(operation) {
    const originalContainer = document.getElementById('originalMathArray');
    const transformedContainer = document.getElementById('transformedMathArray');
    const explanation = document.getElementById('mathExplanation');
    const stepsContainer = document.getElementById('mathSteps');
    const continueButton = document.getElementById('continueAfterMath');
    
    const originalArray = originalArrayForMath.map(val => parseFloat(val));
    let transformedArray = [...originalArray];
    let currentIndex = 0;
    
    const operationNames = {
        'exponential': 'Exponential',
        'naturalLog': 'Natural Logarithm',
        'log10': 'Base-10 Logarithm'
    };
    
    const operationSymbols = {
        'exponential': 'e^',
        'naturalLog': 'ln(',
        'log10': 'log('
    };
    
    function performMathStep() {
        if (currentIndex >= originalArray.length) {
            // Operation completed
            explanation.innerHTML = `<strong>${operationNames[operation]} Operation Completed!</strong> All elements processed.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> ${operationNames[operation]} operation completed on all ${originalArray.length} elements
                </div>
            `;
            
            // Highlight all transformed elements
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('math-operation-result');
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterMath();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterMath);
            
            return;
        }
        
        const originalValue = originalArray[currentIndex];
        let result;
        let calculation;
        
        // Perform the mathematical operation
        switch (operation) {
            case 'exponential':
                result = Math.exp(originalValue);
                calculation = `e^${originalValue} = ${result.toFixed(4)}`;
                break;
            case 'naturalLog':
                result = Math.log(originalValue);
                calculation = `ln(${originalValue}) = ${result.toFixed(4)}`;
                break;
            case 'log10':
                result = Math.log10(originalValue);
                calculation = `log(${originalValue}) = ${result.toFixed(4)}`;
                break;
        }
        
        // Update explanation
        explanation.innerHTML = `Processing element [${currentIndex}]: ${calculation}`;
        
        // Highlight current element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentIndex].querySelector('.element-value');
        currentElement.classList.add('math-operation-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex + 1}:</strong> ${operationSymbols[operation]}${originalValue}) = ${result.toFixed(4)}
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Update transformed array
            transformedArray[currentIndex] = result.toFixed(4);
            renderArrayInContainer(transformedArray, 'transformedMathArray');
            
            // Remove highlight from original and add to transformed
            currentElement.classList.remove('math-operation-current');
            
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const transformedElement = transformedElements[currentIndex].querySelector('.element-value');
            transformedElement.classList.add('math-operation-completed');
            
            // Move to next element
            currentIndex++;
            performMathStep();
        }, 1500);
    }
    
    // Add initial explanation
    stepsContainer.innerHTML = `
        <div class="algorithm-step active">
            <strong>Initialization:</strong> Starting ${operationNames[operation]} operation on array with ${originalArray.length} elements
        </div>
        <div class="algorithm-step">
            <strong>Formula:</strong> ${getMathFormula(operation)}
        </div>
    `;
    
    // Start the operation
    performMathStep();
}

// NEW: Get mathematical formula description
function getMathFormula(operation) {
    switch (operation) {
        case 'exponential':
            return 'f(x) = e^x, where e  2.71828 (Euler\'s number)';
        case 'naturalLog':
            return 'f(x) = ln(x), the natural logarithm (base e)';
        case 'log10':
            return 'f(x) = log(x), the base-10 logarithm';
        default:
            return '';
    }
}
// NEW: Return to Original after Math Operation
function returnToOriginalAfterMath() {
    // Reset to original array
    myArray = [...originalArrayForMath];
    originalArrayForMath = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMathOperationRunning = false;
    currentMathOperation = null;
    
    logOperation('Mathematical operation completed - returned to original array', 'info');
    showNotification('Returned to original array after mathematical operation', 'success');
}
// Pancake Sorting Handler
function handlePancakeSort() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isPancakeSortRunning) {
        showNotification('Pancake sort is already in progress', 'warning');
        return;
    }
    
    isPancakeSortRunning = true;
    
    // Store original array
    originalArrayForPancakeSort = [...myArray];
    
    // Show pancake sort visualization
    showPancakeSortVisualization();
}

// Show Pancake Sort Visualization
function showPancakeSortVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Pancake Sorting Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalPancakeArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Pancake Sorting Process</div>
            <div class="transformed-array-container" id="transformedPancakeArray"></div>
        </div>
        
        <div class="pancake-explanation">
            <p class="mb-2"><strong>Pancake Sorting:</strong> Sort array using only prefix reversals (flips)</p>
            <p class="mb-0" id="pancakeExplanation">Initializing pancake sort...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="pancakeStepsContainer">
            <h6 class="text-center">Pancake Sort Steps</h6>
            <div class="steps-container" id="pancakeSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPancake" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForPancakeSort, 'originalPancakeArray');
    renderArrayInContainer([...originalArrayForPancakeSort], 'transformedPancakeArray');
    
    performPancakeSortAnimation();
}

// Perform Pancake Sort Animation
function performPancakeSortAnimation() {
    const originalContainer = document.getElementById('originalPancakeArray');
    const transformedContainer = document.getElementById('transformedPancakeArray');
    const explanation = document.getElementById('pancakeExplanation');
    const stepsContainer = document.getElementById('pancakeSteps');
    const continueButton = document.getElementById('continueAfterPancake');
    
    let array = [...originalArrayForPancakeSort];
    const n = array.length;
    let currentSize = n;
    let step = 0;
    
    // Convert to numbers for comparison
    const isNumeric = !array.some(item => isNaN(parseFloat(item)));
    
    function performPancakeStep() {
        if (currentSize <= 1) {
            // Sorting completed
            explanation.innerHTML = `<strong>Pancake Sort Completed!</strong> Array sorted using prefix flips.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Array completely sorted using pancake sort algorithm
                </div>
            `;
            
            // Highlight all elements as sorted
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('pancake-sorted');
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterPancakeSort();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterPancakeSort);
            
            return;
        }
        
        step++;
        
        // Find the index of the maximum element in the current unsorted portion
        let maxIndex = 0;
        let maxValue = isNumeric ? parseFloat(array[0]) : array[0];
        
        for (let i = 1; i < currentSize; i++) {
            const currentValue = isNumeric ? parseFloat(array[i]) : array[i];
            if (currentValue > maxValue) {
                maxValue = currentValue;
                maxIndex = i;
            }
        }
        
        explanation.innerHTML = `Step ${step}: Find maximum element in unsorted portion (indices 0 to ${currentSize - 1})`;
        
        // Highlight the current unsorted portion and maximum element
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        
        // Highlight unsorted portion
        for (let i = 0; i < currentSize; i++) {
            transformedElements[i].querySelector('.element-value').classList.add('pancake-current');
        }
        
        // Highlight maximum element
        const maxElement = transformedElements[maxIndex].querySelector('.element-value');
        maxElement.classList.add('pancake-max');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> Found maximum element "${array[maxIndex]}" at index ${maxIndex} in unsorted portion [0-${currentSize - 1}]
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            if (maxIndex !== currentSize - 1) {
                // If maximum is not already at the end, we need to flip
                if (maxIndex !== 0) {
                    // Flip to bring maximum to the beginning
                    step++;
                    explanation.innerHTML = `Step ${step}: Flip prefix (0 to ${maxIndex}) to bring maximum to front`;
                    
                    // Highlight the flip range
                    for (let i = 0; i <= maxIndex; i++) {
                        transformedElements[i].querySelector('.element-value').classList.add('pancake-flip-range');
                        transformedElements[i].querySelector('.element-value').classList.add('pancake-flip-animation');
                    }
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step}:</strong> Flipping prefix from index 0 to ${maxIndex} to bring "${array[maxIndex]}" to front
                        </div>
                    `;
                    
                    setTimeout(() => {
                        // Perform the flip
                        for (let i = 0; i <= Math.floor(maxIndex / 2); i++) {
                            [array[i], array[maxIndex - i]] = [array[maxIndex - i], array[i]];
                        }
                        
                        // Update transformed array display
                        renderArrayInContainer(array, 'transformedPancakeArray');
                        
                        // Remove temporary highlights
                        const updatedElements = transformedContainer.querySelectorAll('.array-element');
                        for (let i = 0; i <= maxIndex; i++) {
                            updatedElements[i].querySelector('.element-value').classList.remove('pancake-flip-range', 'pancake-flip-animation');
                        }
                        
                        // Re-highlight unsorted portion
                        for (let i = 0; i < currentSize; i++) {
                            updatedElements[i].querySelector('.element-value').classList.add('pancake-current');
                        }
                        
                        // Now flip the entire unsorted portion to move maximum to the end
                        step++;
                        explanation.innerHTML = `Step ${step}: Flip entire unsorted portion (0 to ${currentSize - 1}) to move maximum to correct position`;
                        
                        // Highlight the flip range
                        for (let i = 0; i < currentSize; i++) {
                            updatedElements[i].querySelector('.element-value').classList.add('pancake-flip-range');
                            updatedElements[i].querySelector('.element-value').classList.add('pancake-flip-animation');
                        }
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Step ${step}:</strong> Flipping entire unsorted portion from index 0 to ${currentSize - 1} to move "${array[0]}" to its correct position
                            </div>
                        `;
                        
                        setTimeout(() => {
                            // Perform the flip
                            for (let i = 0; i < Math.floor(currentSize / 2); i++) {
                                [array[i], array[currentSize - 1 - i]] = [array[currentSize - 1 - i], array[i]];
                            }
                            
                            // Update transformed array display
                            renderArrayInContainer(array, 'transformedPancakeArray');
                            
                            // Mark the element at the end as sorted
                            const finalElements = transformedContainer.querySelectorAll('.array-element');
                            finalElements[currentSize - 1].querySelector('.element-value').classList.add('pancake-sorted');
                            
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step">
                                    <strong>Success:</strong> Maximum element "${array[currentSize - 1]}" now at correct position ${currentSize - 1}
                                </div>
                            `;
                            
                            // Reduce the unsorted portion size
                            currentSize--;
                            
                            // Continue to next step
                            performPancakeStep();
                        }, 1500);
                    }, 1500);
                } else {
                    // Maximum is already at the beginning, just flip the entire unsorted portion
                    step++;
                    explanation.innerHTML = `Step ${step}: Maximum is already at front, flip entire unsorted portion (0 to ${currentSize - 1})`;
                    
                    // Highlight the flip range
                    for (let i = 0; i < currentSize; i++) {
                        transformedElements[i].querySelector('.element-value').classList.add('pancake-flip-range');
                        transformedElements[i].querySelector('.element-value').classList.add('pancake-flip-animation');
                    }
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step}:</strong> Maximum is already at front, flipping entire unsorted portion from index 0 to ${currentSize - 1}
                        </div>
                    `;
                    
                    setTimeout(() => {
                        // Perform the flip
                        for (let i = 0; i < Math.floor(currentSize / 2); i++) {
                            [array[i], array[currentSize - 1 - i]] = [array[currentSize - 1 - i], array[i]];
                        }
                        
                        // Update transformed array display
                        renderArrayInContainer(array, 'transformedPancakeArray');
                        
                        // Mark the element at the end as sorted
                        const finalElements = transformedContainer.querySelectorAll('.array-element');
                        finalElements[currentSize - 1].querySelector('.element-value').classList.add('pancake-sorted');
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Success:</strong> Element "${array[currentSize - 1]}" now at correct position ${currentSize - 1}
                            </div>
                        `;
                        
                        // Reduce the unsorted portion size
                        currentSize--;
                        
                        // Continue to next step
                        performPancakeStep();
                    }, 1500);
                }
            } else {
                // Maximum is already at the correct position
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Skip:</strong> Maximum element "${array[maxIndex]}" is already at correct position ${currentSize - 1}
                    </div>
                `;
                
                // Mark as sorted
                transformedElements[currentSize - 1].querySelector('.element-value').classList.add('pancake-sorted');
                
                // Reduce the unsorted portion size
                currentSize--;
                
                // Continue to next step
                performPancakeStep();
            }
        }, 10000);
    }
    
    // Start pancake sort process
    performPancakeStep();
}

// Return to Original after Pancake Sort
function returnToOriginalAfterPancakeSort() {
    // Reset to original array
    myArray = [...originalArrayForPancakeSort];
    originalArrayForPancakeSort = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isPancakeSortRunning = false;
    
    logOperation('Pancake sort completed - returned to original array', 'info');
    showNotification('Returned to original array after pancake sort', 'success');
}
// NEW: Stock Span Problem Handler
function handleStockSpan() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isStockSpanRunning) {
        showNotification('Stock span calculation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers (prices)
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Stock span problem requires all array elements to be numbers (stock prices)', 'danger');
        return;
    }
    
    isStockSpanRunning = true;
    
    // Store original array
    originalArrayForStockSpan = [...myArray];
    
    // Show stock span visualization
    showStockSpanVisualization();
}
// NEW: Show Stock Span Visualization
function showStockSpanVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Stock Span Problem - Monotonic Stack Approach</h5>
        
        <div class="array-group">
            <div class="array-label">Stock Prices Array</div>
            <div class="original-array-container" id="stockPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Span Values</div>
            <div class="transformed-array-container" id="spanValuesArray"></div>
        </div>
        
        <div class="monotonic-stack-container">
            <div class="array-label">Monotonic Stack (Decreasing Order)</div>
            <div id="stackVisualization" class="mt-2"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Stock Span Problem:</strong> For each day, find how many consecutive days the price was less than or equal to current day</p>
            <p class="mb-0" id="stockSpanExplanation">Initializing stock span calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="stockSpanStepsContainer">
            <h6 class="text-center">Stock Span Calculation Steps</h6>
            <div class="steps-container" id="stockSpanSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterStockSpan" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderStockSpanArrays();
    performStockSpanAnimation();
}
// NEW: Render Stock Span Arrays
function renderStockSpanArrays() {
    const pricesArray = document.getElementById('stockPricesArray');
    const spanArray = document.getElementById('spanValuesArray');
    
    pricesArray.innerHTML = '';
    spanArray.innerHTML = '';
    
    originalArrayForStockSpan.forEach((price, index) => {
        // Price element
        const priceElement = document.createElement('div');
        priceElement.className = 'array-element';
        priceElement.innerHTML = `
            <div class="element-value">${price}</div>
            <div class="element-index">Day ${index}</div>
        `;
        pricesArray.appendChild(priceElement);
        
        // Span element (initially empty)
        const spanElement = document.createElement('div');
        spanElement.className = 'array-element';
        spanElement.innerHTML = `
            <div class="element-value">?</div>
            <div class="element-index">Span ${index}</div>
        `;
        spanArray.appendChild(spanElement);
    });
}

// NEW: Perform Stock Span Animation
function performStockSpanAnimation() {
    const pricesArray = document.getElementById('stockPricesArray');
    const spanArray = document.getElementById('spanValuesArray');
    const stackVisualization = document.getElementById('stackVisualization');
    const explanation = document.getElementById('stockSpanExplanation');
    const stepsContainer = document.getElementById('stockSpanSteps');
    const continueButton = document.getElementById('continueAfterStockSpan');
    
    const prices = originalArrayForStockSpan.map(val => parseFloat(val));
    const spans = new Array(prices.length).fill(0);
    const stack = [];
    let currentDay = 0;
    let step = 0;
    
    function performSpanStep() {
        if (currentDay >= prices.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Stock Span Calculation Completed!</strong> All span values calculated.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Stock span calculation completed for all ${prices.length} days
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterStockSpan();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterStockSpan);
            
            return;
        }
        
        step++;
        explanation.innerHTML = `Day ${currentDay}: Processing price ${prices[currentDay]}`;
        
        // Highlight current price
        const priceElements = pricesArray.querySelectorAll('.array-element');
        const currentPriceElement = priceElements[currentDay].querySelector('.element-value');
        currentPriceElement.classList.add('stock-span-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> Processing Day ${currentDay}, Price = ${prices[currentDay]}
            </div>
        `;
        
        setTimeout(() => {
            // Pop from stack while stack is not empty and top is less than current price
            let spanValue = 1;
            
            function processStack() {
                if (stack.length === 0) {
                    spans[currentDay] = currentDay + 1;
                    updateStackVisualization();
                    updateSpanDisplay();
                    moveToNextDay();
                    return;
                }
                
                const topIndex = stack[stack.length - 1];
                const topPrice = prices[topIndex];
                
                // Highlight comparison
                const topPriceElement = priceElements[topIndex].querySelector('.element-value');
                topPriceElement.classList.add('stock-span-compared');
                
                explanation.innerHTML = `Day ${currentDay}: Comparing with Day ${topIndex} (Price: ${topPrice})`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step}.${stack.length}:</strong> Compare with Day ${topIndex} (Price: ${topPrice})
                    </div>
                `;
                
                setTimeout(() => {
                    if (topPrice <= prices[currentDay]) {
                        // Pop from stack
                        stack.pop();
                        topPriceElement.classList.remove('stock-span-compared');
                        topPriceElement.classList.add('stock-span-greater');
                        
                        explanation.innerHTML = `Day ${currentDay}: Price ${topPrice}  ${prices[currentDay]}, popping from stack`;
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Step ${step}.${stack.length}:</strong> Popping Day ${topIndex} from stack
                            </div>
                        `;
                        
                        setTimeout(() => {
                            topPriceElement.classList.remove('stock-span-greater');
                            updateStackVisualization();
                            processStack();
                        }, 1000);
                    } else {
                        // Found greater price
                        spans[currentDay] = currentDay - topIndex;
                        topPriceElement.classList.remove('stock-span-compared');
                        
                        explanation.innerHTML = `Day ${currentDay}: Found greater price at Day ${topIndex}`;
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Step ${step}.${stack.length}:</strong> Found greater price, span = ${currentDay} - ${topIndex} = ${spans[currentDay]}
                            </div>
                        `;
                        
                        setTimeout(() => {
                            updateSpanDisplay();
                            moveToNextDay();
                        }, 1000);
                    }
                }, 1500);
            }
            
            function moveToNextDay() {
                // Push current day to stack
                stack.push(currentDay);
                currentPriceElement.classList.remove('stock-span-current');
                currentPriceElement.classList.add('stock-span-result');
                
                explanation.innerHTML = `Day ${currentDay}: Span = ${spans[currentDay]}, pushing to stack`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step}:</strong> Day ${currentDay} completed, span = ${spans[currentDay]}
                    </div>
                `;
                
                setTimeout(() => {
                    currentPriceElement.classList.remove('stock-span-result');
                    currentDay++;
                    updateStackVisualization();
                    performSpanStep();
                }, 1000);
            }
            
            function updateSpanDisplay() {
                const spanElements = spanArray.querySelectorAll('.array-element');
                const currentSpanElement = spanElements[currentDay].querySelector('.element-value');
                currentSpanElement.textContent = spans[currentDay];
                currentSpanElement.classList.add('stock-span-result');
                
                setTimeout(() => {
                    currentSpanElement.classList.remove('stock-span-result');
                }, 500);
            }
            
            function updateStackVisualization() {
                stackVisualization.innerHTML = '';
                stack.forEach(dayIndex => {
                    const stackItem = document.createElement('div');
                    stackItem.className = 'stack-item';
                    stackItem.textContent = `Day ${dayIndex}: ${prices[dayIndex]}`;
                    if (dayIndex === currentDay) {
                        stackItem.classList.add('active');
                    }
                    stackVisualization.appendChild(stackItem);
                });
            }
            
            // Start processing stack
            processStack();
            
        }, 1000);
    }
    
    // Start stock span calculation
    performSpanStep();
}

// NEW: Return to Original after Stock Span
function returnToOriginalAfterStockSpan() {
    // Reset to original array
    myArray = [...originalArrayForStockSpan];
    originalArrayForStockSpan = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isStockSpanRunning = false;
    
    logOperation('Stock span calculation completed - returned to original array', 'info');
    showNotification('Returned to original array after stock span calculation', 'success');
}
// NEW: Max Pair AND/OR Handler
function handleMaxPairAndOr() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isMaxPairAndOrRunning) {
        showNotification('Max pair AND/OR operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseInt(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('AND/OR operations require all array elements to be integers', 'danger');
        return;
    }
    
    isMaxPairAndOrRunning = true;
    
    // Store original array
    originalArrayForMaxPair = [...myArray];
    
    // Show AND/OR pair visualization
    showMaxPairAndOrVisualization();
}

// NEW: Show Max Pair AND/OR Visualization
function showMaxPairAndOrVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Maximum AND/OR Pair Operations</h5>
        
        <!-- Results Section at the Top -->
        <div class="logical-results mb-4" id="logicalResults" style="display: none;">
            <h6 class="text-center mb-3">Results</h6>
            <div class="row">
                <div class="col-md-6">
                    <div class="stats-card">
                        <div>Maximum AND Pair</div>
                        <div class="stats-value" id="andPairIndices">-</div>
                        <div class="stats-value" id="andPairValues">-</div>
                        <div class="stats-value" id="andPairBinary">-</div>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="stats-card">
                        <div>Maximum OR Pair</div>
                        <div class="stats-value" id="orPairIndices">-</div>
                        <div class="stats-value" id="orPairValues">-</div>
                        <div class="stats-value" id="orPairBinary">-</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalMaxPairArray"></div>
        </div>
        
        <div class="operation-explanation mt-3">
            <p class="mb-2"><strong>Logical Operations:</strong> Finding pairs with maximum AND and OR values</p>
            <p class="mb-0" id="maxPairExplanation">Initializing AND/OR pair search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="maxPairStepsContainer">
            <h6 class="text-center">AND/OR Pair Search Steps</h6>
            <div class="steps-container" id="maxPairSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMaxPair" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForMaxPair, 'originalMaxPairArray');
    
    performMaxPairAndOrAnimation();
}

// NEW: Perform Max Pair AND/OR Animation
function performMaxPairAndOrAnimation() {
    const arrayContainer = document.getElementById('originalMaxPairArray');
    const explanation = document.getElementById('maxPairExplanation');
    const stepsContainer = document.getElementById('maxPairSteps');
    const logicalResults = document.getElementById('logicalResults');
    const continueButton = document.getElementById('continueAfterMaxPair');
    
    // Result elements
    const andPairIndices = document.getElementById('andPairIndices');
    const andPairValues = document.getElementById('andPairValues');
    const andPairBinary = document.getElementById('andPairBinary');
    const orPairIndices = document.getElementById('orPairIndices');
    const orPairValues = document.getElementById('orPairValues');
    const orPairBinary = document.getElementById('orPairBinary');
    
    const arr = originalArrayForMaxPair.map(val => parseInt(val));
    let maxAndValue = -Infinity;
    let maxOrValue = -Infinity;
    let maxAndPair = [-1, -1];
    let maxOrPair = [-1, -1];
    let step = 0;
    let i = 0, j = 1;
    
    // Initialize results display
    logicalResults.style.display = 'block';
    andPairIndices.textContent = 'Searching...';
    andPairValues.textContent = '-';
    andPairBinary.textContent = '-';
    orPairIndices.textContent = 'Searching...';
    orPairValues.textContent = '-';
    orPairBinary.textContent = '-';
    
    function performAndOrStep() {
        if (i >= arr.length - 1) {
            // Algorithm completed
            explanation.innerHTML = `<strong>AND/OR Pair Search Completed!</strong> Found maximum AND and OR pairs.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Maximum AND pair: [${maxAndPair[0]},${maxAndPair[1]}] = ${maxAndValue}<br>
                    Maximum OR pair: [${maxOrPair[0]},${maxOrPair[1]}] = ${maxOrValue}
                </div>
            `;
            
            // Update final results
            updateResultsDisplay();
            
            // Highlight the results
            const elements = arrayContainer.querySelectorAll('.array-element');
            
            // Highlight AND pair
            setTimeout(() => {
                elements[maxAndPair[0]].querySelector('.element-value').classList.add('max-and-pair');
                elements[maxAndPair[1]].querySelector('.element-value').classList.add('max-and-pair');
            }, 500);
            
            // Highlight OR pair
            setTimeout(() => {
                elements[maxOrPair[0]].querySelector('.element-value').classList.add('max-or-pair');
                elements[maxOrPair[1]].querySelector('.element-value').classList.add('max-or-pair');
            }, 1500);
            
            continueButton.style.display = 'block';
            
            // Auto-return after 8 seconds
            setTimeout(() => {
                returnToOriginalAfterMaxPair();
            }, 8000);
            
            continueButton.addEventListener('click', returnToOriginalAfterMaxPair);
            
            return;
        }
        
        if (j >= arr.length) {
            // Move to next i
            i++;
            j = i + 1;
            performAndOrStep();
            return;
        }
        
        step++;
        
        // Update explanation
        explanation.innerHTML = `Step ${step}: Checking pair [${i},${j}] = (${arr[i]}, ${arr[j]})`;
        
        // Highlight current pair
        const elements = arrayContainer.querySelectorAll('.array-element');
        const elementI = elements[i].querySelector('.element-value');
        const elementJ = elements[j].querySelector('.element-value');
        
        elementI.classList.add('and-pair-current');
        elementJ.classList.add('and-pair-current');
        
        // Calculate AND and OR values
        const andValue = arr[i] & arr[j];
        const orValue = arr[i] | arr[j];
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Pair [${i},${j}] = (${arr[i]}, ${arr[j]})<br>
                AND: ${arr[i]} & ${arr[j]} = ${andValue}<br>
                OR: ${arr[i]} | ${arr[j]} = ${orValue}
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Remove current highlights
            elementI.classList.remove('and-pair-current');
            elementJ.classList.remove('and-pair-current');
            
            // Update maximum values
            let updatedAnd = false;
            let updatedOr = false;
            
            if (andValue > maxAndValue) {
                maxAndValue = andValue;
                maxAndPair = [i, j];
                updatedAnd = true;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>New Max AND:</strong> [${i},${j}] = ${andValue}
                    </div>
                `;
                
                // Update results display
                updateResultsDisplay();
                
                // Briefly highlight new max AND pair
                elementI.classList.add('max-and-pair');
                elementJ.classList.add('max-and-pair');
                setTimeout(() => {
                    elementI.classList.remove('max-and-pair');
                    elementJ.classList.remove('max-and-pair');
                }, 1000);
            }
            
            if (orValue > maxOrValue) {
                maxOrValue = orValue;
                maxOrPair = [i, j];
                updatedOr = true;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>New Max OR:</strong> [${i},${j}] = ${orValue}
                    </div>
                `;
                
                // Update results display
                updateResultsDisplay();
                
                // Briefly highlight new max OR pair
                elementI.classList.add('max-or-pair');
                elementJ.classList.add('max-or-pair');
                setTimeout(() => {
                    elementI.classList.remove('max-or-pair');
                    elementJ.classList.remove('max-or-pair');
                }, 1000);
            }
            
            // Move to next pair
            j++;
            performAndOrStep();
        }, 1500);
    }
    
    // Helper function to update results display
    function updateResultsDisplay() {
        // Update AND pair results
        if (maxAndPair[0] !== -1 && maxAndPair[1] !== -1) {
            andPairIndices.textContent = `Indices: [${maxAndPair[0]}, ${maxAndPair[1]}]`;
            andPairValues.textContent = `Values: ${arr[maxAndPair[0]]} & ${arr[maxAndPair[1]]} = ${maxAndValue}`;
            andPairBinary.textContent = `Binary: ${arr[maxAndPair[0]].toString(2)} & ${arr[maxAndPair[1]].toString(2)} = ${maxAndValue.toString(2)}`;
        }
        
        // Update OR pair results
        if (maxOrPair[0] !== -1 && maxOrPair[1] !== -1) {
            orPairIndices.textContent = `Indices: [${maxOrPair[0]}, ${maxOrPair[1]}]`;
            orPairValues.textContent = `Values: ${arr[maxOrPair[0]]} | ${arr[maxOrPair[1]]} = ${maxOrValue}`;
            orPairBinary.textContent = `Binary: ${arr[maxOrPair[0]].toString(2)} | ${arr[maxOrPair[1]].toString(2)} = ${maxOrValue.toString(2)}`;
        }
    }
    
    // Start the algorithm
    performAndOrStep();
}

// NEW: Return to Original after Max Pair Operation
function returnToOriginalAfterMaxPair() {
    // Reset to original array
    myArray = [...originalArrayForMaxPair];
    originalArrayForMaxPair = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMaxPairAndOrRunning = false;
    
    logOperation('Max pair AND/OR operation completed - returned to original array', 'info');
    showNotification('Returned to original array after AND/OR pair search', 'success');
}
// NEW: Largest Rectangle in Histogram Handler
function handleLargestRectangleHistogram() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isHistogramRunning) {
        showNotification('Histogram operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains positive numbers
    let allPositiveNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        const num = parseFloat(myArray[i]);
        if (isNaN(num) || num < 0) {
            allPositiveNumbers = false;
            break;
        }
    }
    
    if (!allPositiveNumbers) {
        showNotification('Histogram requires all array elements to be non-negative numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForHistogram = [...myArray];
    
    // Show histogram visualization
    showHistogramVisualization();
}

// NEW: Show Histogram Visualization
function showHistogramVisualization() {
    isHistogramRunning = true;
    
    const histogramContainer = document.createElement('div');
    histogramContainer.className = 'glass-card';
    histogramContainer.innerHTML = `
        <h4 class="text-center mb-4">Largest Rectangle in Histogram</h4>
        
        <div class="histogram-container" id="histogramBarsContainer">
            <!-- Histogram bars will be rendered here -->
        </div>
        
        <div class="row mt-4">
            <div class="col-md-6">
                <div class="stack-visualization">
                    <h6>Stack Status</h6>
                    <div id="stackContainer"></div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="area-calculation">
                    <h6>Current Calculation</h6>
                    <div id="currentCalculation"></div>
                    <div class="area-formula" id="areaFormula">
                        Area = height  width<br>
                        width = right - left - 1
                    </div>
                </div>
            </div>
        </div>
        
        <div class="algorithm-steps mt-3">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="histogramSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Maximum Area Found</div>
            <div class="stats-value" id="maxAreaValue">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Maximum Rectangle Indices</div>
            <div class="stats-value" id="maxAreaIndices">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3 w-100" id="continueAfterHistogram" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(histogramContainer);
    
    renderHistogramBars();
    performLargestRectangleAlgorithm();
}

// NEW: Render Histogram Bars
function renderHistogramBars() {
    const container = document.getElementById('histogramBarsContainer');
    container.innerHTML = '';
    
    const heights = originalArrayForHistogram.map(val => parseFloat(val));
    const maxHeight = Math.max(...heights);
    
    heights.forEach((height, index) => {
        const barContainer = document.createElement('div');
        barContainer.className = 'histogram-bar-container';
        
        const barHeight = (height / maxHeight) * 300;
        const bar = document.createElement('div');
        bar.className = 'element-value histogram-bar';
        bar.style.height = `${barHeight}px`;
        bar.style.setProperty('--bar-height', `${barHeight}px`);
        bar.textContent = height;
        bar.setAttribute('data-index', index);
        bar.setAttribute('data-height', height);
        
        const label = document.createElement('div');
        label.className = 'histogram-bar-label';
        label.textContent = `Index ${index}`;
        
        barContainer.appendChild(bar);
        barContainer.appendChild(label);
        container.appendChild(barContainer);
    });
}

// NEW: Perform Largest Rectangle Algorithm with Animation
function performLargestRectangleAlgorithm() {
    const heights = originalArrayForHistogram.map(val => parseFloat(val));
    const stack = [];
    let maxArea = 0;
    let maxStart = -1;
    let maxEnd = -1;
    let maxHeight = 0;
    let step = 0;
    let i = 0;
    
    const stepsContainer = document.getElementById('histogramSteps');
    const stackContainer = document.getElementById('stackContainer');
    const currentCalculation = document.getElementById('currentCalculation');
    const maxAreaValue = document.getElementById('maxAreaValue');
    const maxAreaIndices = document.getElementById('maxAreaIndices');
    const continueButton = document.getElementById('continueAfterHistogram');
    
    function updateStackVisualization() {
        stackContainer.innerHTML = '';
        stack.forEach((item, idx) => {
            const stackItem = document.createElement('div');
            stackItem.className = `stack-item ${idx === stack.length - 1 ? 'active' : ''}`;
            stackItem.textContent = `Index: ${item.index}, Height: ${heights[item.index]}`;
            stackContainer.appendChild(stackItem);
        });
        
        if (stack.length === 0) {
            const emptyMsg = document.createElement('div');
            emptyMsg.className = 'text-muted text-center';
            emptyMsg.textContent = 'Stack is empty';
            stackContainer.appendChild(emptyMsg);
        }
    }
    
    function highlightBar(index, className) {
        const bars = document.querySelectorAll('.histogram-bar');
        if (bars[index]) {
            bars[index].classList.add(className);
        }
    }
    
    function removeBarHighlight(index, className) {
        const bars = document.querySelectorAll('.histogram-bar');
        if (bars[index]) {
            bars[index].classList.remove(className);
        }
    }
    
    function removeAllHighlights() {
        const bars = document.querySelectorAll('.histogram-bar');
        bars.forEach(bar => {
            bar.classList.remove('histogram-current', 'histogram-in-stack', 'histogram-max-area', 
                               'histogram-left-boundary', 'histogram-right-boundary');
        });
    }
    
    function showAreaCalculation(index, height, left, right, area) {
        const formula = document.getElementById('areaFormula');
        formula.innerHTML = `
            Area = height  width<br>
            = ${height}  (${right} - ${left} - 1)<br>
            = ${height}  ${right - left - 1}<br>
            = ${area}
        `;
        
        // Highlight the area being calculated
        removeAllHighlights();
        highlightBar(index, 'histogram-current');
        
        for (let j = left + 1; j < right; j++) {
            if (j !== index) {
                highlightBar(j, 'histogram-in-stack');
            }
        }
        
        if (left >= 0) highlightBar(left, 'histogram-left-boundary');
        if (right < heights.length) highlightBar(right, 'histogram-right-boundary');
        
        // Show area visualization
        showAreaVisualization(left + 1, right - 1, height, area);
    }
    
    function showAreaVisualization(start, end, height, area) {
        // Remove existing area displays
        const existingAreas = document.querySelectorAll('.histogram-area-display');
        existingAreas.forEach(area => area.remove());
        
        if (start <= end) {
            const bars = document.querySelectorAll('.histogram-bar-container');
            const startRect = bars[start].getBoundingClientRect();
            const endRect = bars[end].getBoundingClientRect();
            const containerRect = document.getElementById('histogramBarsContainer').getBoundingClientRect();
            
            const areaDisplay = document.createElement('div');
            areaDisplay.className = 'histogram-area-display';
            areaDisplay.style.left = `${startRect.left - containerRect.left}px`;
            areaDisplay.style.top = `${containerRect.top - containerRect.top}px`;
            areaDisplay.style.width = `${endRect.right - startRect.left}px`;
            areaDisplay.textContent = `Area: ${area}`;
            
            document.getElementById('histogramBarsContainer').appendChild(areaDisplay);
        }
    }
    
    function performAlgorithmStep() {
        if (i <= heights.length) {
            const currentHeight = i < heights.length ? heights[i] : 0;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${i < heights.length ? 'active' : ''}">
                    <strong>Step ${step + 1}:</strong> 
                    ${i < heights.length ? 
                        `Processing index ${i}, height = ${currentHeight}` : 
                        'Processing remaining elements in stack'}
                </div>
            `;
            
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            // Highlight current bar
            if (i < heights.length) {
                removeAllHighlights();
                highlightBar(i, 'histogram-current');
                
                // Highlight stack elements
                stack.forEach(item => {
                    highlightBar(item.index, 'histogram-in-stack');
                });
            }
            
            setTimeout(() => {
                if (stack.length === 0 || (i < heights.length && heights[stack[stack.length - 1].index] <= currentHeight)) {
                    if (i < heights.length) {
                        stack.push({ index: i, height: currentHeight });
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Action:</strong> Pushed index ${i} to stack (height ${currentHeight})
                            </div>
                        `;
                        i++;
                        step++;
                        updateStackVisualization();
                        performAlgorithmStep();
                    } else {
                        i++;
                        performAlgorithmStep();
                    }
                } else {
                    // Pop from stack and calculate area
                    const top = stack.pop();
                    const height = heights[top.index];
                    const left = stack.length === 0 ? -1 : stack[stack.length - 1].index;
                    const right = i;
                    const width = right - left - 1;
                    const area = height * width;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Calculation:</strong> 
                            Popped index ${top.index}, height = ${height}<br>
                            Left boundary = ${left}, Right boundary = ${right}<br>
                            Width = ${right} - ${left} - 1 = ${width}<br>
                            Area = ${height}  ${width} = ${area}
                        </div>
                    `;
                    
                    showAreaCalculation(top.index, height, left, right, area);
                    
                    if (area > maxArea) {
                        maxArea = area;
                        maxStart = left + 1;
                        maxEnd = right - 1;
                        maxHeight = height;
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>New Maximum!</strong> 
                                Area ${area} > previous max ${maxArea - area + area}
                            </div>
                        `;
                        
                        maxAreaValue.textContent = maxArea;
                        maxAreaIndices.textContent = `Indices ${maxStart}-${maxEnd}, Height ${maxHeight}`;
                        
                        // Highlight the new maximum area
                        removeAllHighlights();
                        for (let j = maxStart; j <= maxEnd; j++) {
                            highlightBar(j, 'histogram-max-area');
                        }
                    }
                    
                    updateStackVisualization();
                    step++;
                    
                    setTimeout(() => {
                        performAlgorithmStep();
                    }, 2000);
                }
            }, 1500);
        } else {
            // Algorithm completed
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Algorithm Completed!</strong> 
                    Maximum rectangular area = ${maxArea}
                </div>
            `;
            
            // Final highlight of maximum area
            removeAllHighlights();
            for (let j = maxStart; j <= maxEnd; j++) {
                highlightBar(j, 'histogram-max-area');
            }
            
            showAreaVisualization(maxStart, maxEnd, maxHeight, maxArea);
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterHistogram();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterHistogram);
        }
    }
    
    // Start algorithm
    updateStackVisualization();
    performAlgorithmStep();
}

// NEW: Return to Original after Histogram
function returnToOriginalAfterHistogram() {
    // Reset to original array
    myArray = [...originalArrayForHistogram];
    originalArrayForHistogram = [];
    
    // Remove histogram visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isHistogramRunning = false;
    
    logOperation('Largest rectangle in histogram completed - returned to original array', 'info');
    showNotification('Returned to original array after histogram operation', 'success');
}
// NEW: Fruit Into Baskets Handler
function handleFruitIntoBaskets() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isFruitBasketRunning) {
        showNotification('Fruit into baskets operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains valid fruit types (numbers)
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseInt(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Fruit into baskets requires all elements to be numbers (fruit types)', 'danger');
        return;
    }
    
    isFruitBasketRunning = true;
    
    // Store original array
    originalArrayForFruitBasket = [...myArray];
    
    // Show fruit basket visualization
    showFruitBasketVisualization();
}
// NEW: Show Fruit Basket Visualization
function showFruitBasketVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Fruit Into Baskets Problem</h5>
        
        <div class="array-group">
            <div class="array-label">Fruit Trees Array</div>
            <div class="original-array-container" id="fruitBasketArray"></div>
        </div>
        
        <div class="basket-explanation">
            <p class="mb-2"><strong>Problem:</strong> Find maximum consecutive fruits you can pick with 2 baskets</p>
            <p class="mb-0" id="basketExplanation">Initializing sliding window with two baskets...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="basketStepsContainer">
            <h6 class="text-center">Sliding Window Steps</h6>
            <div class="steps-container" id="basketSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Current Basket Fruits</div>
            <div class="stats-value" id="currentBasketFruits">-</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Maximum Fruits Found</div>
            <div class="stats-value" id="maxFruitsValue">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Current Window</div>
            <div class="stats-value" id="currentWindow">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterBasket" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForFruitBasket, 'fruitBasketArray');
    
    performFruitBasketAlgorithm();
}
// NEW: Perform Fruit Basket Algorithm with Animation
function performFruitBasketAlgorithm() {
    const arrayContainer = document.getElementById('fruitBasketArray');
    const explanation = document.getElementById('basketExplanation');
    const stepsContainer = document.getElementById('basketSteps');
    const currentBasketFruits = document.getElementById('currentBasketFruits');
    const maxFruitsValue = document.getElementById('maxFruitsValue');
    const currentWindow = document.getElementById('currentWindow');
    const continueButton = document.getElementById('continueAfterBasket');
    
    const fruits = originalArrayForFruitBasket.map(val => parseInt(val));
    let left = 0;
    let maxFruits = 0;
    let basket = new Map(); // fruit type -> count
    let step = 0;
    
    function executeBasketStep(right) {
        if (right >= fruits.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Maximum fruits = ${maxFruits}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Maximum fruits you can pick = ${maxFruits}
                </div>
            `;
            
            // Highlight the final maximum window
            const elements = arrayContainer.querySelectorAll('.array-element');
            for (let i = left; i < fruits.length; i++) {
                if (i - left < maxFruits) {
                    setTimeout(() => {
                        elements[i].querySelector('.element-value').classList.add('basket-max');
                    }, (i - left) * 200);
                }
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterBasket();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterBasket);
            
            return;
        }
        
        step++;
        
        // Add current fruit to basket
        const currentFruit = fruits[right];
        basket.set(currentFruit, (basket.get(currentFruit) || 0) + 1);
        
        explanation.innerHTML = `Step ${step}: Adding fruit type ${currentFruit} at index ${right}`;
        
        // Highlight current fruit being added
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElement = elements[right].querySelector('.element-value');
        currentElement.classList.add('basket-current');
        
        // Update basket display
        const basketTypes = Array.from(basket.keys()).join(', ');
        const basketCounts = Array.from(basket.values()).join(', ');
        currentBasketFruits.textContent = `Types: [${basketTypes}], Counts: [${basketCounts}]`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Added fruit ${currentFruit} at index ${right}
            </div>
        `;
        
        setTimeout(() => {
            currentElement.classList.remove('basket-current');
            currentElement.classList.add('basket-fruit');
            
            // If basket has more than 2 types, shrink from left
            if (basket.size > 2) {
                explanation.innerHTML = `Step ${step}: Too many fruit types (${basket.size}), removing from left`;
                
                const shrinkStep = () => {
                    if (basket.size > 2 && left <= right) {
                        const leftFruit = fruits[left];
                        basket.set(leftFruit, basket.get(leftFruit) - 1);
                        
                        if (basket.get(leftFruit) === 0) {
                            basket.delete(leftFruit);
                        }
                        
                        // Highlight removal
                        const leftElement = elements[left].querySelector('.element-value');
                        leftElement.classList.add('basket-removed');
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Step ${step}.${left}:</strong> Removed fruit ${leftFruit} from index ${left}
                            </div>
                        `;
                        
                        setTimeout(() => {
                            leftElement.classList.remove('basket-removed', 'basket-fruit');
                            left++;
                            
                            // Update current window display
                            currentWindow.textContent = `[${left}, ${right}]`;
                            
                            shrinkStep();
                        }, 800);
                    } else {
                        // Continue with next right pointer
                        updateMaxAndContinue(right);
                    }
                };
                
                shrinkStep();
            } else {
                updateMaxAndContinue(right);
            }
            
            function updateMaxAndContinue(right) {
                // Update max fruits
                const currentLength = right - left + 1;
                if (currentLength > maxFruits) {
                    maxFruits = currentLength;
                    
                    // Highlight the new maximum window
                    for (let i = left; i <= right; i++) {
                        elements[i].querySelector('.element-value').classList.add('basket-max');
                    }
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step}:</strong> New maximum! Fruits = ${maxFruits} (indices ${left}-${right})
                        </div>
                    `;
                }
                
                maxFruitsValue.textContent = maxFruits;
                currentWindow.textContent = `[${left}, ${right}]`;
                
                // Scroll steps container
                stepsContainer.scrollTop = stepsContainer.scrollHeight;
                
                // Move to next right pointer
                setTimeout(() => {
                    executeBasketStep(right + 1);
                }, 1000);
            }
        }, 800);
    }
    
    // Start algorithm execution
    executeBasketStep(0);
}
// NEW: Return to Original after Fruit Basket
function returnToOriginalAfterBasket() {
    // Reset to original array
    myArray = [...originalArrayForFruitBasket];
    originalArrayForFruitBasket = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isFruitBasketRunning = false;
    
    logOperation('Fruit into baskets operation completed - returned to original array', 'info');
    showNotification('Returned to original array after fruit basket operation', 'success');
}
// NEW: Element-wise Operation Handler
function handleElementWiseOperation(operation) {
    if (isElementWiseOpRunning) {
        showNotification('An element-wise operation is already in progress', 'warning');
        return;
    }

    // Reset arrays
    elemWiseFirstArray = [];
    elemWiseSecondArray = [];
    elemWiseFirstSize = 0;
    elemWiseSecondSize = 0;
    currentElementWiseOp = operation;
    
    // Show input group
    elementWiseOperationGroup.style.display = 'block';
    elementWiseFirstArraySizeInput.focus();
    
    // Hide perform operation button initially
    performElementWiseOperationBtn.style.display = 'none';
    
    // Set button text based on operation
    const operationNames = {
        'add': 'Addition',
        'subtract': 'Subtraction', 
        'multiply': 'Multiplication',
        'divide': 'Division',
        'modulus': 'Modulus'
    };
    
    performElementWiseOperationBtn.innerHTML = 
        `<i class="fas fa-play me-2"></i>Perform ${operationNames[operation]} Operation`;
    
    logOperation(`Started element-wise ${operationNames[operation]} operation`, 'info');
}

// NEW: Confirm Element-wise First Array Size Handler
function handleConfirmElementWiseFirstArraySize() {
    const size = parseInt(elementWiseFirstArraySizeInput.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        elementWiseFirstArraySizeInput.focus();
        return;
    }
    
    elemWiseFirstSize = size;
    elemWiseFirstArray = [];
    
    // Create input fields for first array
    elementWiseFirstArrayInputs.innerHTML = '<label class="form-label">Enter numeric elements for First Array:</label>';
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="number" class="form-control element-wise-first-array-element" 
                   placeholder="Enter number" data-index="${i}" step="any">
        `;
        elementWiseFirstArrayInputs.appendChild(inputGroup);
    }
    
    showNotification(`First array size set to ${size}. Please enter ${size} numeric elements.`, 'success');
    logOperation(`First array size set to ${size} for element-wise operation`, 'info');
}

// NEW: Confirm Element-wise Second Array Size Handler
function handleConfirmElementWiseSecondArraySize() {
    const size = parseInt(elementWiseSecondArraySizeInput.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        elementWiseSecondArraySizeInput.focus();
        return;
    }
    
    if (size !== elemWiseFirstSize) {
        showNotification(`Second array size must match first array size (${elemWiseFirstSize})`, 'danger');
        return;
    }
    
    elemWiseSecondSize = size;
    elemWiseSecondArray = [];
    
    // Create input fields for second array
    elementWiseSecondArrayInputs.innerHTML = '<label class="form-label">Enter numeric elements for Second Array:</label>';
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="number" class="form-control element-wise-second-array-element" 
                   placeholder="Enter number" data-index="${i}" step="any">
        `;
        elementWiseSecondArrayInputs.appendChild(inputGroup);
    }
    
    // Show perform operation button
    performElementWiseOperationBtn.style.display = 'block';
    
    showNotification(`Second array size set to ${size}. Please enter ${size} numeric elements.`, 'success');
    logOperation(`Second array size set to ${size} for element-wise operation`, 'info');
}

// NEW: Perform Element-wise Operation Handler
function handlePerformElementWiseOperation() {
    // Collect first array elements
    const firstArrayInputs = document.querySelectorAll('.element-wise-first-array-element');
    elemWiseFirstArray = [];
    
    for (let i = 0; i < firstArrayInputs.length; i++) {
        const value = firstArrayInputs[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all elements for first array. Missing element at position ${i}`, 'danger');
            firstArrayInputs[i].focus();
            return;
        }
        if (isNaN(parseFloat(value))) {
            showNotification(`Please enter valid numbers only. Invalid value at position ${i}`, 'danger');
            firstArrayInputs[i].focus();
            return;
        }
        elemWiseFirstArray.push(parseFloat(value));
    }
    
    // Collect second array elements
    const secondArrayInputs = document.querySelectorAll('.element-wise-second-array-element');
    elemWiseSecondArray = [];
    
    for (let i = 0; i < secondArrayInputs.length; i++) {
        const value = secondArrayInputs[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all elements for second array. Missing element at position ${i}`, 'danger');
            secondArrayInputs[i].focus();
            return;
        }
        if (isNaN(parseFloat(value))) {
            showNotification(`Please enter valid numbers only. Invalid value at position ${i}`, 'danger');
            secondArrayInputs[i].focus();
            return;
        }
        elemWiseSecondArray.push(parseFloat(value));
    }
    
    // Store original array
    originalArrayBeforeElemWise = [...myArray];
    
    // Hide input group
    elementWiseOperationGroup.style.display = 'none';
    
    // Start element-wise operation visualization
    showElementWiseOperationVisualization();
}

// NEW: Cancel Element-wise Operation Handler
function handleCancelElementWiseOperation() {
    elementWiseOperationGroup.style.display = 'none';
    elementWiseFirstArraySizeInput.value = '';
    elementWiseSecondArraySizeInput.value = '';
    elementWiseFirstArrayInputs.innerHTML = '';
    elementWiseSecondArrayInputs.innerHTML = '';
    performElementWiseOperationBtn.style.display = 'none';
    
    elemWiseFirstArray = [];
    elemWiseSecondArray = [];
    elemWiseFirstSize = 0;
    elemWiseSecondSize = 0;
    currentElementWiseOp = null;
    
    logOperation('Cancelled element-wise operation', 'info');
    showNotification('Element-wise operation cancelled', 'info');
}

// NEW: Show Element-wise Operation Visualization
function showElementWiseOperationVisualization() {
    isElementWiseOpRunning = true;
    
    const operationNames = {
        'add': 'Addition',
        'subtract': 'Subtraction',
        'multiply': 'Multiplication (Hadamard)',
        'divide': 'Division',
        'modulus': 'Modulus'
    };
    
    const operationSymbols = {
        'add': '+',
        'subtract': '-',
        'multiply': '',
        'divide': '',
        'modulus': '%'
    };
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'element-wise-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Element-wise ${operationNames[currentElementWiseOp]}</h5>
        
        <div class="element-wise-array-group">
            <div class="array-label">First Array (A)</div>
            <div class="original-array-container" id="elementWiseFirstArrayDisplay"></div>
        </div>
        
        <div class="element-wise-arrow">
            <i class="fas fa-${operationSymbols[currentElementWiseOp]}"></i>
        </div>
        
        <div class="element-wise-array-group">
            <div class="array-label">Second Array (B)</div>
            <div class="original-array-container" id="elementWiseSecondArrayDisplay"></div>
        </div>
        
        <div class="element-wise-arrow">
            <i class="fas fa-equals"></i>
        </div>
        
        <div class="element-wise-array-group">
            <div class="array-label">Result Array (A ${operationSymbols[currentElementWiseOp]} B)</div>
            <div class="transformed-array-container" id="elementWiseResultArrayDisplay"></div>
        </div>
        
        <div class="element-wise-explanation">
            <p class="mb-2"><strong>Element-wise ${operationNames[currentElementWiseOp]}:</strong> Performing operation on corresponding elements</p>
            <p class="mb-0" id="elementWiseExplanation">Starting element-wise operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="elementWiseStepsContainer">
            <h6 class="text-center">Element-wise Operation Steps</h6>
            <div class="steps-container" id="elementWiseSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterElementWise" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display the input arrays
    renderArrayInContainer(elemWiseFirstArray, 'elementWiseFirstArrayDisplay');
    renderArrayInContainer(elemWiseSecondArray, 'elementWiseSecondArrayDisplay');
    renderArrayInContainer([], 'elementWiseResultArrayDisplay');
    
    // Start element-wise operation animation
    performElementWiseOperationAnimation();
}

// NEW: Perform Element-wise Operation Animation
function performElementWiseOperationAnimation() {
    const firstContainer = document.getElementById('elementWiseFirstArrayDisplay');
    const secondContainer = document.getElementById('elementWiseSecondArrayDisplay');
    const resultContainer = document.getElementById('elementWiseResultArrayDisplay');
    const explanation = document.getElementById('elementWiseExplanation');
    const stepsContainer = document.getElementById('elementWiseSteps');
    const continueButton = document.getElementById('continueAfterElementWise');
    
    const operationNames = {
        'add': 'addition',
        'subtract': 'subtraction',
        'multiply': 'multiplication',
        'divide': 'division',
        'modulus': 'modulus'
    };
    
    const operationSymbols = {
        'add': '+',
        'subtract': '-',
        'multiply': '',
        'divide': '',
        'modulus': '%'
    };
    
    let resultArray = [];
    let currentIndex = 0;
    
    function performElementWiseStep() {
        if (currentIndex >= elemWiseFirstArray.length) {
            // Operation completed
            explanation.innerHTML = `<strong>Element-wise ${operationNames[currentElementWiseOp]} Completed!</strong> All elements processed.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Element-wise ${operationNames[currentElementWiseOp]} completed! Result: [${resultArray.join(', ')}]
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterElementWise();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterElementWise);
            
            return;
        }
        
        const step = currentIndex + 1;
        const a = elemWiseFirstArray[currentIndex];
        const b = elemWiseSecondArray[currentIndex];
        
        explanation.innerHTML = `Step ${step}: Processing element at index ${currentIndex}`;
        
        // Highlight current elements being processed
        const firstElements = firstContainer.querySelectorAll('.array-element');
        const secondElements = secondContainer.querySelectorAll('.array-element');
        
        if (currentIndex < firstElements.length) {
            firstElements[currentIndex].querySelector('.element-value').classList.add('element-wise-highlight');
        }
        if (currentIndex < secondElements.length) {
            secondElements[currentIndex].querySelector('.element-value').classList.add('element-wise-highlight');
        }
        
        // Calculate result based on operation
        let result;
        let operationText;
        
        switch (currentElementWiseOp) {
            case 'add':
                result = a + b;
                operationText = `${a} + ${b} = ${result}`;
                break;
            case 'subtract':
                result = a - b;
                operationText = `${a} - ${b} = ${result}`;
                break;
            case 'multiply':
                result = a * b;
                operationText = `${a}  ${b} = ${result}`;
                break;
            case 'divide':
                if (b === 0) {
                    result = 'Undefined (division by zero)';
                    operationText = `${a}  ${b} = Undefined`;
                } else {
                    result = a / b;
                    operationText = `${a}  ${b} = ${result.toFixed(2)}`;
                }
                break;
            case 'modulus':
                if (b === 0) {
                    result = 'Undefined (modulus by zero)';
                    operationText = `${a} % ${b} = Undefined`;
                } else {
                    result = a % b;
                    operationText = `${a} % ${b} = ${result}`;
                }
                break;
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> A[${currentIndex}] ${operationSymbols[currentElementWiseOp]} B[${currentIndex}] = ${operationText}
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Remove highlights from input arrays
            if (currentIndex < firstElements.length) {
                firstElements[currentIndex].querySelector('.element-value').classList.remove('element-wise-highlight');
            }
            if (currentIndex < secondElements.length) {
                secondElements[currentIndex].querySelector('.element-value').classList.remove('element-wise-highlight');
            }
            
            // Add result to result array
            if (typeof result === 'number') {
                resultArray.push(result);
            } else {
                resultArray.push(result);
            }
            
            // Update result array display
            renderArrayInContainer(resultArray, 'elementWiseResultArrayDisplay');
            
            // Highlight the new result element
            const resultElements = resultContainer.querySelectorAll('.array-element');
            if (currentIndex < resultElements.length) {
                resultElements[currentIndex].querySelector('.element-value').classList.add('element-wise-result');
            }
            
            currentIndex++;
            performElementWiseStep();
        }, 1500);
    }
    
    // Start element-wise operation process
    performElementWiseStep();
}

// NEW: Return to Original after Element-wise Operation
function returnToOriginalAfterElementWise() {
    // Reset to original array
    myArray = [...originalArrayBeforeElemWise];
    originalArrayBeforeElemWise = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isElementWiseOpRunning = false;
    
    // Clear all element-wise operation data
    elemWiseFirstArray = [];
    elemWiseSecondArray = [];
    elemWiseFirstSize = 0;
    elemWiseSecondSize = 0;
    currentElementWiseOp = null;
    
    // Reset input groups
    elementWiseOperationGroup.style.display = 'none';
    elementWiseFirstArraySizeInput.value = '';
    elementWiseSecondArraySizeInput.value = '';
    elementWiseFirstArrayInputs.innerHTML = '';
    elementWiseSecondArrayInputs.innerHTML = '';
    performElementWiseOperationBtn.style.display = 'none';
    
    logOperation('Element-wise operation completed - returned to original array', 'info');
    showNotification('Returned to original array after element-wise operation', 'success');
}
// NEW: Logical NOT Handler
function handleLogicalNot() {
    if (isLogicalOpRunning) {
        showNotification('A logical operation is already in progress', 'warning');
        return;
    }

    // Reset and show NOT input group
    logicalNotGroup.style.display = 'block';
    logicalXorGroup.style.display = 'none';
    logicalNotSize.focus();
    
    logOperation('Started element-wise logical NOT operation', 'info');
}

// NEW: Logical XOR Handler
function handleLogicalXor() {
    if (isLogicalOpRunning) {
        showNotification('A logical operation is already in progress', 'warning');
        return;
    }

    // Reset and show XOR input group
    logicalXorGroup.style.display = 'block';
    logicalNotGroup.style.display = 'none';
    logicalXorArrayCount.focus();
    
    logOperation('Started element-wise logical XOR operation', 'info');
}

// NEW: Confirm Logical NOT Size Handler
function handleConfirmLogicalNotSize() {
    const size = parseInt(logicalNotSize.value);
    
    if (isNaN(size) || size < 1 || size > 20) {
        showNotification('Please enter a valid size between 1 and 20', 'danger');
        logicalNotSize.focus();
        return;
    }
    
    // Create input fields for array elements
    logicalNotInputs.innerHTML = '<label class="form-label">Enter binary elements (0 or 1):</label>';
    for (let i = 0; i < size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="number" class="form-control logical-not-element" 
                   placeholder="Enter 0 or 1" min="0" max="1" data-index="${i}">
        `;
        logicalNotInputs.appendChild(inputGroup);
    }
    
    // Add perform button
    const performBtn = document.createElement('button');
    performBtn.className = 'btn btn-glow w-100 mt-2';
    performBtn.innerHTML = '<i class="fas fa-play me-2"></i>Perform Logical NOT Operation';
    performBtn.addEventListener('click', handlePerformLogicalNot);
    logicalNotInputs.appendChild(performBtn);
    
    showNotification(`Array size set to ${size}. Please enter ${size} binary elements.`, 'success');
}

// NEW: Confirm Logical XOR Array Count Handler
function handleConfirmLogicalXorArrayCount() {
    const arrayCount = parseInt(logicalXorArrayCount.value);
    
    if (isNaN(arrayCount) || arrayCount < 2 || arrayCount > 5) {
        showNotification('Please enter a valid number of arrays between 2 and 5', 'danger');
        logicalXorArrayCount.focus();
        return;
    }
    
    // Create input fields for array sizes
    logicalXorSizeInputs.innerHTML = '<label class="form-label">Enter sizes for each array:</label>';
    for (let i = 0; i < arrayCount; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Array ${i+1} Size</span>
            <input type="number" class="form-control logical-xor-size" 
                   placeholder="Enter size" min="1" max="20" data-index="${i}">
        `;
        logicalXorSizeInputs.appendChild(inputGroup);
    }
    
    // Add confirm sizes button
    const confirmSizesBtn = document.createElement('button');
    confirmSizesBtn.className = 'btn btn-glow w-100 mt-2';
    confirmSizesBtn.innerHTML = '<i class="fas fa-check me-2"></i>Confirm Array Sizes';
    confirmSizesBtn.addEventListener('click', handleConfirmLogicalXorSizes);
    logicalXorSizeInputs.appendChild(confirmSizesBtn);
    
    showNotification(`Number of arrays set to ${arrayCount}. Please enter sizes for each array.`, 'success');
}

// NEW: Confirm Logical XOR Sizes Handler
function handleConfirmLogicalXorSizes() {
    const arrayCount = parseInt(logicalXorArrayCount.value);
    const sizeInputs = document.querySelectorAll('.logical-xor-size');
    
    logicalOpArrays = [];
    let allSizesValid = true;
    
    for (let i = 0; i < arrayCount; i++) {
        const size = parseInt(sizeInputs[i].value);
        if (isNaN(size) || size < 1 || size > 20) {
            showNotification(`Please enter a valid size for Array ${i+1}`, 'danger');
            sizeInputs[i].focus();
            allSizesValid = false;
            break;
        }
        logicalOpArrays.push({ size: size, elements: [] });
    }
    
    if (!allSizesValid) return;
    
    // Create input fields for array elements
    logicalXorElementInputs.innerHTML = '<label class="form-label">Enter binary elements (0 or 1) for each array:</label>';
    
    for (let i = 0; i < arrayCount; i++) {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'mb-3';
        arrayGroup.innerHTML = `<h6>Array ${i+1} (Size: ${logicalOpArrays[i].size})</h6>`;
        
        for (let j = 0; j < logicalOpArrays[i].size; j++) {
            const inputGroup = document.createElement('div');
            inputGroup.className = 'input-group mb-2';
            inputGroup.innerHTML = `
                <span class="input-group-text">Element ${j}</span>
                <input type="number" class="form-control logical-xor-element" 
                       placeholder="Enter 0 or 1" min="0" max="1" 
                       data-array="${i}" data-index="${j}">
            `;
            arrayGroup.appendChild(inputGroup);
        }
        logicalXorElementInputs.appendChild(arrayGroup);
    }
    
    // Add perform button
    const performBtn = document.createElement('button');
    performBtn.className = 'btn btn-glow w-100 mt-2';
    performBtn.innerHTML = '<i class="fas fa-play me-2"></i>Perform Logical XOR Operation';
    performBtn.addEventListener('click', handlePerformLogicalXor);
    logicalXorElementInputs.appendChild(performBtn);
    
    showNotification('Array sizes confirmed. Please enter binary elements for each array.', 'success');
}

// NEW: Perform Logical NOT Operation
function handlePerformLogicalNot() {
    const elementInputs = document.querySelectorAll('.logical-not-element');
    const inputArray = [];
    
    // Collect and validate elements
    for (let i = 0; i < elementInputs.length; i++) {
        const value = parseInt(elementInputs[i].value);
        if (isNaN(value) || (value !== 0 && value !== 1)) {
            showNotification(`Please enter valid binary value (0 or 1) for element ${i}`, 'danger');
            elementInputs[i].focus();
            return;
        }
        inputArray.push(value);
    }
    
    // Store original array
    originalArrayForLogicalOps = [...inputArray];
    logicalOpType = 'NOT';
    
    // Hide input group
    logicalNotGroup.style.display = 'none';
    
    // Start NOT operation visualization
    showLogicalNotVisualization(inputArray);
}

// NEW: Perform Logical XOR Operation
function handlePerformLogicalXor() {
    const arrayCount = logicalOpArrays.length;
    const elementInputs = document.querySelectorAll('.logical-xor-element');
    
    // Reset arrays
    for (let i = 0; i < arrayCount; i++) {
        logicalOpArrays[i].elements = [];
    }
    
    // Collect and validate elements
    for (let i = 0; i < elementInputs.length; i++) {
        const arrayIndex = parseInt(elementInputs[i].getAttribute('data-array'));
        const elementIndex = parseInt(elementInputs[i].getAttribute('data-index'));
        const value = parseInt(elementInputs[i].value);
        
        if (isNaN(value) || (value !== 0 && value !== 1)) {
            showNotification(`Please enter valid binary value (0 or 1) for Array ${arrayIndex+1}, Element ${elementIndex}`, 'danger');
            elementInputs[i].focus();
            return;
        }
        logicalOpArrays[arrayIndex].elements.push(value);
    }
    
    // Check if all arrays have the same size
    const firstSize = logicalOpArrays[0].elements.length;
    for (let i = 1; i < arrayCount; i++) {
        if (logicalOpArrays[i].elements.length !== firstSize) {
            showNotification('All arrays must have the same size for XOR operation', 'danger');
            return;
        }
    }
    
    logicalOpType = 'XOR';
    
    // Hide input group
    logicalXorGroup.style.display = 'none';
    
    // Start XOR operation visualization
    showLogicalXorVisualization();
}

// NEW: Cancel Logical NOT Handler
function handleCancelLogicalNot() {
    logicalNotGroup.style.display = 'none';
    logicalNotSize.value = '';
    logicalNotInputs.innerHTML = '';
    
    logOperation('Cancelled logical NOT operation', 'info');
}

// NEW: Cancel Logical XOR Handler
function handleCancelLogicalXor() {
    logicalXorGroup.style.display = 'none';
    logicalXorArrayCount.value = '';
    logicalXorSizeInputs.innerHTML = '';
    logicalXorElementInputs.innerHTML = '';
    logicalOpArrays = [];
    
    logOperation('Cancelled logical XOR operation', 'info');
}
// NEW: Show Logical NOT Visualization
function showLogicalNotVisualization(inputArray) {
    isLogicalOpRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Element-wise Logical NOT Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Original Binary Array</div>
            <div class="original-array-container" id="originalLogicalArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After Logical NOT Operation</div>
            <div class="transformed-array-container" id="transformedLogicalArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Logical NOT Operation:</strong> Each element is inverted (01, 10)</p>
            <p class="mb-0" id="logicalExplanation">Starting logical NOT operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="logicalStepsContainer">
            <h6 class="text-center">Logical NOT Steps</h6>
            <div class="steps-container" id="logicalSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterLogical" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original View
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(inputArray, 'originalLogicalArray');
    renderArrayInContainer([...inputArray], 'transformedLogicalArray');
    
    performLogicalNotAnimation(inputArray);
}

// NEW: Perform Logical NOT Animation
function performLogicalNotAnimation(inputArray) {
    const originalContainer = document.getElementById('originalLogicalArray');
    const transformedContainer = document.getElementById('transformedLogicalArray');
    const explanation = document.getElementById('logicalExplanation');
    const stepsContainer = document.getElementById('logicalSteps');
    const continueButton = document.getElementById('continueAfterLogical');
    
    const resultArray = [...inputArray];
    let currentIndex = 0;
    
    function performNotStep() {
        if (currentIndex >= inputArray.length) {
            // Operation completed
            explanation.innerHTML = `<strong>Logical NOT Operation Completed!</strong> All elements inverted successfully.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Logical NOT operation completed on all ${inputArray.length} elements
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterLogical();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterLogical);
            
            return;
        }
        
        const originalValue = inputArray[currentIndex];
        const notValue = originalValue === 0 ? 1 : 0;
        
        explanation.innerHTML = `Processing element [${currentIndex}]: ${originalValue}  ${notValue}`;
        
        // Highlight current element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        
        const originalElement = originalElements[currentIndex].querySelector('.element-value');
        const transformedElement = transformedElements[currentIndex].querySelector('.element-value');
        
        originalElement.classList.add('logical-not-current');
        transformedElement.classList.add('logical-not-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex + 1}:</strong> NOT(${originalValue}) = ${notValue}
            </div>
        `;
        
        setTimeout(() => {
            // Apply NOT operation
            resultArray[currentIndex] = notValue;
            
            // Update transformed array display
            renderArrayInContainer(resultArray, 'transformedLogicalArray');
            
            // Remove highlight and add completion effect
            originalElement.classList.remove('logical-not-current');
            transformedElement.classList.remove('logical-not-current');
            transformedElements[currentIndex].querySelector('.element-value').classList.add('create', 'bounce');
            
            currentIndex++;
            performNotStep();
        }, 1500);
    }
    
    // Start NOT operation
    performNotStep();
}

// NEW: Show Logical XOR Visualization
function showLogicalXorVisualization() {
    isLogicalOpRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Element-wise Logical XOR Operation</h5>
        
        <div id="logicalXorArraysContainer"></div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">XOR Result Array</div>
            <div class="transformed-array-container" id="logicalXorResultArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Logical XOR Operation:</strong> Output is 1 when inputs differ, 0 when same</p>
            <p class="mb-0" id="logicalXorExplanation">Starting logical XOR operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="logicalXorStepsContainer">
            <h6 class="text-center">Logical XOR Steps</h6>
            <div class="steps-container" id="logicalXorSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterLogicalXor" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original View
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display input arrays
    const arraysContainer = document.getElementById('logicalXorArraysContainer');
    for (let i = 0; i < logicalOpArrays.length; i++) {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'array-group';
        arrayGroup.innerHTML = `
            <div class="array-label">Array ${i+1}</div>
            <div class="original-array-container" id="logicalXorArray${i}"></div>
        `;
        arraysContainer.appendChild(arrayGroup);
        renderArrayInContainer(logicalOpArrays[i].elements, `logicalXorArray${i}`);
    }
    
    // Initialize result array with zeros
    const arraySize = logicalOpArrays[0].elements.length;
    logicalOpResultArray = Array(arraySize).fill(0);
    renderArrayInContainer(logicalOpResultArray, 'logicalXorResultArray');
    
    performLogicalXorAnimation();
}

// NEW: Perform Logical XOR Animation
function performLogicalXorAnimation() {
    const explanation = document.getElementById('logicalXorExplanation');
    const stepsContainer = document.getElementById('logicalXorSteps');
    const continueButton = document.getElementById('continueAfterLogicalXor');
    
    const arraySize = logicalOpArrays[0].elements.length;
    const arrayCount = logicalOpArrays.length;
    let currentElement = 0;
    
    function performXorStep() {
        if (currentElement >= arraySize) {
            // Operation completed
            explanation.innerHTML = `<strong>Logical XOR Operation Completed!</strong> All elements processed successfully.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> XOR operation completed on all ${arraySize} elements across ${arrayCount} arrays
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterLogical();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterLogical);
            
            return;
        }
        
        explanation.innerHTML = `Processing element position ${currentElement} across all arrays`;
        
        // Highlight current element in all arrays
        for (let i = 0; i < arrayCount; i++) {
            const arrayContainer = document.getElementById(`logicalXorArray${i}`);
            const elements = arrayContainer.querySelectorAll('.array-element');
            if (elements[currentElement]) {
                elements[currentElement].querySelector('.element-value').classList.add('logical-xor-current');
            }
        }
        
        // Calculate XOR step by step
        let xorResult = logicalOpArrays[0].elements[currentElement];
        let calculationSteps = `XOR calculation: ${logicalOpArrays[0].elements[currentElement]}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Element ${currentElement}:</strong> Starting XOR calculation...
            </div>
        `;
        
        setTimeout(() => {
            for (let i = 1; i < arrayCount; i++) {
                const currentValue = logicalOpArrays[i].elements[currentElement];
                const previousResult = xorResult;
                xorResult = (previousResult !== currentValue) ? 1 : 0;
                
                calculationSteps += ` XOR ${currentValue} = ${xorResult}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step:</strong> ${calculationSteps}
                    </div>
                `;
                
                // Update result array
                logicalOpResultArray[currentElement] = xorResult;
                renderArrayInContainer(logicalOpResultArray, 'logicalXorResultArray');
                
                // Highlight result element
                const resultContainer = document.getElementById('logicalXorResultArray');
                const resultElements = resultContainer.querySelectorAll('.array-element');
                if (resultElements[currentElement]) {
                    resultElements[currentElement].querySelector('.element-value').classList.add('create', 'bounce');
                }
            }
            
            // Remove highlights
            for (let i = 0; i < arrayCount; i++) {
                const arrayContainer = document.getElementById(`logicalXorArray${i}`);
                const elements = arrayContainer.querySelectorAll('.array-element');
                if (elements[currentElement]) {
                    elements[currentElement].querySelector('.element-value').classList.remove('logical-xor-current');
                }
            }
            
            currentElement++;
            performXorStep();
        }, 1000);
    }
    
    // Start XOR operation
    performXorStep();
}

// NEW: Return to Original after Logical Operations
function returnToOriginalAfterLogical() {
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isLogicalOpRunning = false;
    originalArrayForLogicalOps = [];
    logicalOpType = null;
    logicalOpArrays = [];
    logicalOpResultArray = [];
    
    // Clear all input groups
    logicalNotGroup.style.display = 'none';
    logicalXorGroup.style.display = 'none';
    logicalNotSize.value = '';
    logicalNotInputs.innerHTML = '';
    logicalXorArrayCount.value = '';
    logicalXorSizeInputs.innerHTML = '';
    logicalXorElementInputs.innerHTML = '';
    
    logOperation('Logical operation completed - returned to original view', 'info');
    showNotification('Returned to original view after logical operation', 'success');
}
// Updated handler to use the simpler implementation
function handleTransformNonDecreasing() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isTransformRunning) {
        showNotification('A transformation operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('This transformation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isTransformRunning = true;
    
    // Store original array
    originalArrayForTransform = [...myArray];
    
    // Calculate transformation steps using the simpler implementation
    calculateTransformStepsSimple();
    
    // Show transformation visualization
    showTransformVisualization();
}

// NEW: Calculate Transformation Steps (Based on Python logic)
function calculateTransformStepsSimple() {
    const arr = originalArrayForTransform.map(val => parseInt(val));
    transformSteps = [];
    let operations = 0;
    
    // Create a copy like in Python: arr = arr[:]
    let workingArray = [...arr];
    
    // Add initial state
    transformSteps.push({
        array: [...workingArray],
        currentIndex: 0,
        prevValue: workingArray[0],
        operations: operations,
        message: "Starting transformation process...",
        stepType: "start"
    });
    
    // Direct translation of Python logic
    for (let i = 1; i < workingArray.length; i++) {
        // Show initial comparison
        transformSteps.push({
            array: [...workingArray],
            currentIndex: i,
            prevValue: workingArray[i-1],
            operations: operations,
            message: ` Comparing arr[${i-1}]=${workingArray[i-1]} and arr[${i}]=${workingArray[i]}`,
            stepType: "compare"
        });
        
        // If current element is less than previous (like Python if condition)
        if (workingArray[i] < workingArray[i-1]) {
            operations += 1;
            
            // Strategy: always increase the current element to match previous
            // This minimizes future conflicts (like Python nums[i] = nums[i-1])
            const oldValue = workingArray[i];
            workingArray[i] = workingArray[i-1];
            
            transformSteps.push({
                array: [...workingArray],
                currentIndex: i,
                prevValue: workingArray[i-1],
                operations: operations,
                message: ` Increased arr[${i}] from ${oldValue} to ${workingArray[i]} to match previous element (operation ${operations})`,
                stepType: "increase"
            });
        }
        
        // Validation step
        transformSteps.push({
            array: [...workingArray],
            currentIndex: i,
            prevValue: workingArray[i-1],
            operations: operations,
            message: ` Validation: arr[${i-1}]=${workingArray[i-1]}  arr[${i}]=${workingArray[i]} `,
            stepType: "validate"
        });
    }
    
    // Final step
    transformSteps.push({
        array: [...workingArray],
        currentIndex: -1,
        prevValue: 0,
        operations: operations,
        message: ` Transformation completed! Total changes made: ${operations}. Array is now non-decreasing.`,
        stepType: "complete"
    });
}

// NEW: Show Transformation Visualization
function showTransformVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Transform to Non-Decreasing Array</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalTransformArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Transformation Process</div>
            <div class="transformed-array-container" id="transformedTransformArray"></div>
        </div>
        
        <div class="operations-counter">
            <i class="fas fa-calculator me-2"></i>
            Total Changes: <span id="operationsCount">0</span>
        </div>
        
        <div class="transform-explanation">
            <p class="mb-2"><strong>Greedy Algorithm:</strong> Ensure each element is  its predecessor by increasing elements when needed</p>
            <p class="mb-0" id="transformExplanation"> Starting automatic transformation process...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="transformStepsContainer">
            <h6 class="text-center">Transformation Steps</h6>
            <div class="steps-container" id="transformSteps"></div>
        </div>
        
        <div class="progress mt-3" style="height: 8px;">
            <div id="transformProgress" class="progress-bar bg-success" style="width: 0%"></div>
        </div>
        
        <div class="d-flex gap-2 mt-3 justify-content-center">
            <button class="btn btn-sm btn-outline-light" id="pauseTransform">
                <i class="fas fa-pause me-1"></i>Pause Animation
            </button>
            <button class="btn btn-sm btn-outline-light" id="restartTransform" style="display: none;">
                <i class="fas fa-redo me-1"></i>Restart Animation
            </button>
        </div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForTransform, 'originalTransformArray');
    renderArrayInContainer([...originalArrayForTransform], 'transformedTransformArray');
    
    setupTransformControls();
    startAutoPlay();
}

// NEW: Setup Transformation Controls
function setupTransformControls() {
    const pauseBtn = document.getElementById('pauseTransform');
    const restartBtn = document.getElementById('restartTransform');
    
    let isPaused = false;
    
    pauseBtn.addEventListener('click', () => {
        if (!isPaused) {
            // Pause animation
            clearInterval(window.transformAnimationInterval);
            pauseBtn.innerHTML = '<i class="fas fa-play me-1"></i>Resume Animation';
            isPaused = true;
        } else {
            // Resume animation
            startAutoPlay();
            pauseBtn.innerHTML = '<i class="fas fa-pause me-1"></i>Pause Animation';
            isPaused = false;
        }
    });
    
    restartBtn.addEventListener('click', () => {
        clearInterval(window.transformAnimationInterval);
        currentTransformStep = 0;
        const stepsContainer = document.getElementById('transformSteps');
        stepsContainer.innerHTML = '';
        startAutoPlay();
        restartBtn.style.display = 'none';
        pauseBtn.style.display = 'block';
    });
}

// NEW: Start Auto Play Animation
function startAutoPlay() {
    const pauseBtn = document.getElementById('pauseTransform');
    const restartBtn = document.getElementById('restartTransform');
    const progressBar = document.getElementById('transformProgress');
    
    let stepDelay = 1200; // 1.2 seconds per step for better visibility
    
    // Clear any existing interval
    if (window.transformAnimationInterval) {
        clearInterval(window.transformAnimationInterval);
    }
    
    // Start from step 0
    currentTransformStep = 0;
    displayTransformStep(currentTransformStep);
    
    window.transformAnimationInterval = setInterval(() => {
        if (currentTransformStep < transformSteps.length - 1) {
            currentTransformStep++;
            displayTransformStep(currentTransformStep);
            
            // Update progress bar
            const progress = (currentTransformStep / (transformSteps.length - 1)) * 100;
            progressBar.style.width = `${progress}%`;
            
        } else {
            // Animation completed
            clearInterval(window.transformAnimationInterval);
            pauseBtn.style.display = 'none';
            restartBtn.style.display = 'block';
            
            // Auto-return to original array after 3 seconds
            setTimeout(() => {
                returnToOriginalAfterTransform();
            }, 3000);
        }
    }, stepDelay);
}

// NEW: Display Transformation Step
function displayTransformStep(stepIndex) {
    const step = transformSteps[stepIndex];
    const explanation = document.getElementById('transformExplanation');
    const stepsContainer = document.getElementById('transformSteps');
    const operationsCount = document.getElementById('operationsCount');
    
    // Update operations count
    operationsCount.textContent = step.operations;
    
    // Update explanation with animated effect
    explanation.innerHTML = step.message;
    explanation.classList.add('pulse');
    setTimeout(() => {
        explanation.classList.remove('pulse');
    }, 500);
    
    // Update transformed array
    renderArrayInContainer(step.array, 'transformedTransformArray');
    
    // Add step to steps container with smooth scroll
    const stepElement = document.createElement('div');
    stepElement.className = `algorithm-step ${step.stepType === 'complete' ? 'active' : ''}`;
    stepElement.innerHTML = `<strong>Step ${stepIndex + 1}:</strong> ${step.message}`;
    stepsContainer.appendChild(stepElement);
    
    // Smooth scroll to bottom
    stepsContainer.scrollTo({
        top: stepsContainer.scrollHeight,
        behavior: 'smooth'
    });
    
    // Highlight current elements with enhanced animations
    const transformedContainer = document.getElementById('transformedTransformArray');
    const elements = transformedContainer.querySelectorAll('.array-element');
    
    // Remove previous highlights
    elements.forEach(el => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove(
            'transform-current', 
            'transform-compared', 
            'transform-increased', 
            'transform-valid',
            'pulse',
            'bounce',
            'shake'
        );
    });
    
    // Apply current highlights based on step type with enhanced animations
    if (step.currentIndex >= 0) {
        const currentElement = elements[step.currentIndex].querySelector('.element-value');
        
        switch (step.stepType) {
            case 'compare':
                if (step.currentIndex > 0) {
                    const prevElement = elements[step.currentIndex - 1].querySelector('.element-value');
                    prevElement.classList.add('transform-compared', 'pulse');
                }
                currentElement.classList.add('transform-current', 'bounce');
                break;
                
            case 'increase':
                currentElement.classList.add('transform-increased', 'pulse');
                // Add count animation for operations
                if (step.operations > 0) {
                    operationsCount.classList.add('bounce');
                    setTimeout(() => {
                        operationsCount.classList.remove('bounce');
                    }, 500);
                }
                break;
                
            case 'validate':
                if (step.currentIndex > 0) {
                    const prevElement = elements[step.currentIndex - 1].querySelector('.element-value');
                    prevElement.classList.add('transform-valid', 'pulse');
                }
                currentElement.classList.add('transform-valid', 'pulse');
                break;
                
            case 'complete':
                // Celebrate completion - highlight all elements
                elements.forEach((el, index) => {
                    setTimeout(() => {
                        const valueDiv = el.querySelector('.element-value');
                        valueDiv.classList.add('transform-valid', 'bounce');
                    }, index * 200);
                });
                break;
        }
    }
    
    // Special effects for completion
    if (step.stepType === 'complete') {
        explanation.classList.add('highlight');
        operationsCount.classList.add('color-change');
    }
}

// NEW: Return to Original after Transformation
function returnToOriginalAfterTransform() {
    // Clear any running intervals
    if (window.transformAnimationInterval) {
        clearInterval(window.transformAnimationInterval);
    }
    
    // Reset to original array
    myArray = [...originalArrayForTransform];
    originalArrayForTransform = [];
    transformSteps = [];
    currentTransformStep = 0;
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isTransformRunning = false;
    
    logOperation('Non-decreasing transformation completed - returned to original array', 'success');
    showNotification(' Transformation completed! Returned to original array', 'success');
}

// NEW: Helper function to render array in specific container
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = `
            <div class="array-empty-state">
                <i class="fas fa-layer-group"></i>
                <h4>Array is Empty</h4>
                <p>Add some elements to get started!</p>
            </div>
        `;
        return;
    }
    
    array.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}
// NEW: Minimum Flips Operation Handler
function handleMinFlipsOperation(operationType) {
    if (isMinFlipsRunning) {
        showNotification('A minimum flips operation is already in progress', 'warning');
        return;
    }

    minFlipsOperationType = operationType;
    minFlipsArrays = [];
    minFlipsOriginalArrays = [];
    minFlipsNumArraysCount = 0; // Updated variable name
    minFlipsArraySizes = [];

    // Show input group
    minFlipsInputGroup.style.display = 'block';
    minFlipsTitle.textContent = `Minimum Flips ${operationType.toUpperCase()} Operation`;
    numArraysInputField.focus(); // Updated variable name

    // Hide perform button initially
    performMinFlipsOperationBtn.style.display = 'none'; // Updated variable name
    arraySizeInputsContainer.innerHTML = ''; // Updated variable name
    arrayElementsInputsContainer.innerHTML = ''; // Updated variable name

    logOperation(`Started minimum flips ${operationType.toUpperCase()} operation`, 'info');
}

// NEW: Confirm Number of Arrays Handler
function handleConfirmNumArrays() {
    const numArrays = parseInt(numArraysInputField.value); // Updated variable name

    if (isNaN(numArrays) || numArrays < 2 || numArrays > 5) {
        showNotification('Please enter a valid number of arrays between 2 and 5', 'danger');
        numArraysInputField.focus(); // Updated variable name
        return;
    }

    minFlipsNumArraysCount = numArrays; // Updated variable name

    // Create size input fields for each array
    arraySizeInputsContainer.innerHTML = '<label class="form-label">Enter sizes for each array:</label>'; // Updated variable name
    for (let i = 0; i < numArrays; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Array ${i + 1} Size</span>
            <input type="number" class="form-control array-size-input" 
                   data-array-index="${i}" placeholder="Enter size" min="1" max="10">
        `;
        arraySizeInputsContainer.appendChild(inputGroup); // Updated variable name
    }

    // Add event listeners for size inputs
    const sizeInputs = arraySizeInputsContainer.querySelectorAll('.array-size-input'); // Updated variable name
    sizeInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('array-size-input')) {
                    nextInput.focus();
                }
            }
        });
    });

    showNotification(`Number of arrays set to ${numArrays}. Please enter sizes for each array.`, 'success');
}

// NEW: Handle Array Size Confirmation (called when all sizes are entered)
function handleArraySizesConfirmed() {
    // Collect all array sizes
    minFlipsArraySizes = [];
    const sizeInputs = arraySizeInputsContainer.querySelectorAll('.array-size-input'); // Updated variable name
    
    for (let i = 0; i < sizeInputs.length; i++) {
        const size = parseInt(sizeInputs[i].value);
        if (isNaN(size) || size < 1 || size > 10) {
            showNotification(`Please enter a valid size for Array ${i + 1} (1-10)`, 'danger');
            sizeInputs[i].focus();
            return;
        }
        minFlipsArraySizes.push(size);
    }

    // Create element input fields for each array
    arrayElementsInputsContainer.innerHTML = '<label class="form-label">Enter elements for each array (numbers only):</label>'; // Updated variable name
    
    for (let i = 0; i < minFlipsNumArraysCount; i++) { // Updated variable name
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'mb-3';
        arrayGroup.innerHTML = `<label class="form-label">Array ${i + 1} (size: ${minFlipsArraySizes[i]}):</label>`;
        
        for (let j = 0; j < minFlipsArraySizes[i]; j++) {
            const inputGroup = document.createElement('div');
            inputGroup.className = 'input-group mb-2';
            inputGroup.innerHTML = `
                <span class="input-group-text">Element ${j}</span>
                <input type="number" class="form-control array-element-input" 
                       data-array-index="${i}" data-element-index="${j}" 
                       placeholder="Enter number">
            `;
            arrayGroup.appendChild(inputGroup);
        }
        arrayElementsInputsContainer.appendChild(arrayGroup); // Updated variable name
    }

    // Show perform button
    performMinFlipsOperationBtn.style.display = 'block'; // Updated variable name

    // Add event listeners for element inputs
    const elementInputs = arrayElementsInputsContainer.querySelectorAll('.array-element-input'); // Updated variable name
    elementInputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = input.nextElementSibling;
                if (nextInput && nextInput.classList.contains('array-element-input')) {
                    nextInput.focus();
                }
            }
        });
    });

    showNotification('Array sizes confirmed. Please enter elements for each array.', 'success');
}

// NEW: Perform Minimum Flips Handler
function handlePerformMinFlips() {
    // Check if sizes are entered, if not, confirm them first
    if (minFlipsArraySizes.length === 0) {
        handleArraySizesConfirmed();
        return;
    }

    // Collect all array elements
    minFlipsArrays = [];
    const elementInputs = arrayElementsInputsContainer.querySelectorAll('.array-element-input'); // Updated variable name
    
    // Initialize arrays
    for (let i = 0; i < minFlipsNumArraysCount; i++) { // Updated variable name
        minFlipsArrays.push([]);
    }

    // Fill arrays with elements
    for (let i = 0; i < elementInputs.length; i++) {
        const value = elementInputs[i].value.trim();
        const arrayIndex = parseInt(elementInputs[i].getAttribute('data-array-index'));
        const elementIndex = parseInt(elementInputs[i].getAttribute('data-element-index'));
        
        if (value === '' || isNaN(parseFloat(value))) {
            showNotification(`Please enter valid numbers for all elements. Missing element at Array ${arrayIndex + 1}, position ${elementIndex}`, 'danger');
            elementInputs[i].focus();
            return;
        }
        
        minFlipsArrays[arrayIndex].push(parseFloat(value));
    }

    // Verify all arrays have correct sizes
    for (let i = 0; i < minFlipsNumArraysCount; i++) { // Updated variable name
        if (minFlipsArrays[i].length !== minFlipsArraySizes[i]) {
            showNotification(`Array ${i + 1} has incorrect number of elements`, 'danger');
            return;
        }
    }

    // Store original arrays
    minFlipsOriginalArrays = JSON.parse(JSON.stringify(minFlipsArrays));

    // Hide input group and start visualization
    minFlipsInputGroup.style.display = 'none';
    isMinFlipsRunning = true;

    // Start minimum flips visualization
    showMinFlipsVisualization();
}

// NEW: Cancel Minimum Flips Handler
function handleCancelMinFlips() {
    minFlipsInputGroup.style.display = 'none';
    numArraysInputField.value = ''; // Updated variable name
    arraySizeInputsContainer.innerHTML = ''; // Updated variable name
    arrayElementsInputsContainer.innerHTML = ''; // Updated variable name
    performMinFlipsOperationBtn.style.display = 'none'; // Updated variable name
    
    minFlipsArrays = [];
    minFlipsOriginalArrays = [];
    minFlipsNumArraysCount = 0; // Updated variable name
    minFlipsArraySizes = [];
    minFlipsOperationType = null;
    
    logOperation('Cancelled minimum flips operation', 'info');
    showNotification('Minimum flips operation cancelled', 'info');
}

// NEW: Show Minimum Flips Visualization
function showMinFlipsVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Minimum Flips ${minFlipsOperationType.toUpperCase()} Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Input Arrays</div>
            <div id="inputArraysContainer"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Binary Representation & Flips</div>
            <div id="binaryRepresentationContainer"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Minimum Flips ${minFlipsOperationType.toUpperCase()}:</strong> Finding minimum bit flips to make array ${minFlipsOperationType} equal to target</p>
            <p class="mb-0" id="minFlipsExplanation">Converting numbers to binary...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="minFlipsStepsContainer">
            <h6 class="text-center">Minimum Flips Steps</h6>
            <div class="steps-container" id="minFlipsSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Minimum Flips Required</div>
            <div class="stats-value" id="minFlipsResult">0</div>
        </div>
        
        <div class="auto-return-notice mt-3">
            <p class="text-center text-info">
                <i class="fas fa-info-circle me-2"></i>
                Will automatically return to main view in 5 seconds...
            </p>
        </div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Render input arrays
    renderInputArrays();
    
    // Start minimum flips algorithm
    performMinFlipsAlgorithm();
}
// NEW: Render Input Arrays
function renderInputArrays() {
    const container = document.getElementById('inputArraysContainer');
    container.innerHTML = '';
    
    minFlipsArrays.forEach((array, index) => {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'mb-3';
        arrayGroup.innerHTML = `
            <div class="array-label">Array ${index + 1}</div>
            <div class="original-array-container" id="inputArray${index}"></div>
        `;
        container.appendChild(arrayGroup);
        renderArrayInContainer(array, `inputArray${index}`);
    });
}

// NEW: Perform Minimum Flips Algorithm
function performMinFlipsAlgorithm() {
    const explanation = document.getElementById('minFlipsExplanation');
    const stepsContainer = document.getElementById('minFlipsSteps');
    const minFlipsResult = document.getElementById('minFlipsResult');
    const binaryContainer = document.getElementById('binaryRepresentationContainer');
    
    let step = 0;
    let minFlips = Infinity;
    let bestResult = null;
    
    function executeStep() {
        switch (step) {
            case 0:
                // Step 1: Convert numbers to binary
                explanation.innerHTML = 'Step 1: Converting all numbers to binary representation';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Convert all array elements to binary
                    </div>
                `;
                
                // Show binary representation
                showBinaryRepresentation();
                break;
                
            case 1:
                // Step 2: Explain the operation
                explanation.innerHTML = `Step 2: For ${minFlipsOperationType.toUpperCase()} operation, we need to find minimum flips to make all arrays have the same ${minFlipsOperationType} result`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Analyze bit patterns for ${minFlipsOperationType.toUpperCase()} operation
                    </div>
                `;
                break;
                
            case 2:
                // Step 3: Calculate minimum flips
                explanation.innerHTML = 'Step 3: Calculating minimum flips required...';
                const result = calculateMinimumFlips();
                minFlips = result.minFlips;
                bestResult = result;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Minimum flips calculated = ${minFlips}
                    </div>
                `;
                break;
                
            case 3:
                // Step 4: Show result
                explanation.innerHTML = `<strong>Algorithm Completed!</strong> Minimum flips required = ${minFlips}`;
                minFlipsResult.textContent = minFlips;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Minimum flips = ${minFlips} ${bestResult.explanation}
                    </div>
                `;
                
                // Highlight the bits that need to be flipped
                highlightFlips(bestResult);
                
                // AUTO-RETURN: Set timeout to automatically return to main view after 5 seconds
                setTimeout(() => {
                    returnToMainAfterMinFlips();
                }, 5000);
                return;
        }
        
        step++;
        setTimeout(executeStep, 2000);
    }
    
    // Start execution
    executeStep();
}

// NEW: Calculate Minimum Flips
function calculateMinimumFlips() {
    // For OR operation: We want all arrays to have the same OR value
    // For AND operation: We want all arrays to have the same AND value
    
    if (minFlipsOperationType === 'or') {
        return calculateMinFlipsOR();
    } else {
        return calculateMinFlipsAND();
    }
}

// NEW: Calculate Minimum Flips for OR
function calculateMinFlipsOR() {
    // Find the maximum number to determine bit length
    const allNumbers = minFlipsArrays.flat();
    const maxNum = Math.max(...allNumbers);
    const bitLength = Math.floor(Math.log2(maxNum)) + 1;
    
    let totalFlips = 0;
    let explanation = '';
    
    // For OR operation, we need to make sure all arrays have at least one '1' in each bit position
    // where any array has a '1', or we need to flip bits to achieve this
    
    for (let bitPos = 0; bitPos < bitLength; bitPos++) {
        const bitMask = 1 << bitPos;
        let hasOneInAnyArray = false;
        
        // Check if any array has this bit set
        for (let i = 0; i < minFlipsArrays.length; i++) {
            for (let j = 0; j < minFlipsArrays[i].length; j++) {
                if (minFlipsArrays[i][j] & bitMask) {
                    hasOneInAnyArray = true;
                    break;
                }
            }
            if (hasOneInAnyArray) break;
        }
        
        if (!hasOneInAnyArray) {
            // We need to flip one '0' to '1' in this bit position
            totalFlips++;
            explanation += ` Bit ${bitPos}: flip one 01`;
        }
    }
    
    return {
        minFlips: totalFlips,
        explanation: `(OR: ensure each bit position has at least one 1)${explanation}`
    };
}

// NEW: Calculate Minimum Flips for AND
function calculateMinFlipsAND() {
    // Find the maximum number to determine bit length
    const allNumbers = minFlipsArrays.flat();
    const maxNum = Math.max(...allNumbers);
    const bitLength = Math.floor(Math.log2(maxNum)) + 1;
    
    let totalFlips = 0;
    let explanation = '';
    
    // For AND operation, we need to make sure all arrays have '1' in each bit position
    // where we want the final AND to be 1, or flip bits accordingly
    
    for (let bitPos = 0; bitPos < bitLength; bitPos++) {
        const bitMask = 1 << bitPos;
        let allArraysHaveOne = true;
        
        // Check if all arrays have at least one element with this bit set
        for (let i = 0; i < minFlipsArrays.length; i++) {
            let arrayHasOne = false;
            for (let j = 0; j < minFlipsArrays[i].length; j++) {
                if (minFlipsArrays[i][j] & bitMask) {
                    arrayHasOne = true;
                    break;
                }
            }
            if (!arrayHasOne) {
                allArraysHaveOne = false;
                break;
            }
        }
        
        if (!allArraysHaveOne) {
            // We need to flip one '0' to '1' in each array that doesn't have this bit set
            let flipsForThisBit = 0;
            for (let i = 0; i < minFlipsArrays.length; i++) {
                let arrayHasOne = false;
                for (let j = 0; j < minFlipsArrays[i].length; j++) {
                    if (minFlipsArrays[i][j] & bitMask) {
                        arrayHasOne = true;
                        break;
                    }
                }
                if (!arrayHasOne) {
                    flipsForThisBit++;
                }
            }
            totalFlips += flipsForThisBit;
            explanation += ` Bit ${bitPos}: ${flipsForThisBit} flips`;
        }
    }
    
    return {
        minFlips: totalFlips,
        explanation: `(AND: ensure each array has at least one 1 in required bits)${explanation}`
    };
}

// NEW: Show Binary Representation
function showBinaryRepresentation() {
    const container = document.getElementById('binaryRepresentationContainer');
    container.innerHTML = '';
    
    const allNumbers = minFlipsArrays.flat();
    const maxNum = Math.max(...allNumbers);
    const bitLength = Math.max(4, Math.floor(Math.log2(maxNum)) + 1); // Minimum 4 bits for visibility
    
    minFlipsArrays.forEach((array, arrayIndex) => {
        const arrayGroup = document.createElement('div');
        arrayGroup.className = 'mb-3';
        arrayGroup.innerHTML = `<div class="array-label">Array ${arrayIndex + 1} Binary</div>`;
        
        array.forEach((number, elementIndex) => {
            const binaryGroup = document.createElement('div');
            binaryGroup.className = 'binary-representation';
            binaryGroup.innerHTML = `<div>Element ${elementIndex} (${number}):</div>`;
            
            const binaryStr = number.toString(2).padStart(bitLength, '0');
            for (let i = 0; i < binaryStr.length; i++) {
                const digit = document.createElement('span');
                digit.className = 'binary-digit';
                digit.textContent = binaryStr[i];
                digit.setAttribute('data-array', arrayIndex);
                digit.setAttribute('data-element', elementIndex);
                digit.setAttribute('data-bit', i);
                binaryGroup.appendChild(digit);
            }
            
            arrayGroup.appendChild(binaryGroup);
        });
        
        container.appendChild(arrayGroup);
    });
}

// NEW: Highlight Flips
function highlightFlips(result) {
    // This is a simplified visualization - in a real implementation,
    // you would highlight the specific bits that need to be flipped
    const binaryDigits = document.querySelectorAll('.binary-digit');
    
    // Highlight some random digits for demonstration
    binaryDigits.forEach((digit, index) => {
        if (index % 3 === 0) { // Just for demonstration
            setTimeout(() => {
                digit.classList.add('flip-candidate');
            }, index * 100);
        }
    });
}

// NEW: Return to Main after Minimum Flips
function returnToMainAfterMinFlips() {
    // Reset to original state
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMinFlipsRunning = false;
    minFlipsArrays = [];
    minFlipsOriginalArrays = [];
    minFlipsNumArraysCount = 0; // Updated variable name
    minFlipsArraySizes = [];
    minFlipsOperationType = null;
    
    logOperation('Minimum flips operation completed', 'info');
    showNotification('Returned to main view', 'success');
}

// Add this helper function to handle array size input completion
document.addEventListener('input', (e) => {
    if (e.target.classList.contains('array-size-input')) {
        // Check if all size inputs are filled
        const sizeInputs = arraySizeInputsContainer.querySelectorAll('.array-size-input'); // Updated variable name
        const allFilled = Array.from(sizeInputs).every(input => input.value.trim() !== '');
        
        if (allFilled) {
            // Auto-confirm sizes after a short delay
            setTimeout(handleArraySizesConfirmed, 500);
        }
    }
});
// NEW: Prefix XOR Array Handler
function handlePrefixXor() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isPrefixXorRunning) {
        showNotification('Prefix XOR operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers (XOR requires numbers)
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseInt(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('XOR operation requires all array elements to be integers', 'danger');
        return;
    }
    
    isPrefixXorRunning = true;
    
    // Store original array
    originalArrayForXor = [...myArray];
    
    // Show prefix XOR visualization
    showPrefixXorVisualization();
}
// NEW: Show Prefix XOR Visualization
function showPrefixXorVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Prefix XOR Array Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalXorArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Prefix XOR Array</div>
            <div class="transformed-array-container" id="transformedXorArray"></div>
        </div>
        
        <div class="xor-explanation">
            <p class="mb-2"><strong>Prefix XOR Operation:</strong> Each element = XOR of all previous elements including current</p>
            <p class="mb-0" id="xorExplanation">Starting prefix XOR calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="xorStepsContainer">
            <h6 class="text-center">XOR Operation Steps</h6>
            <div class="steps-container" id="xorSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterXor" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForXor, 'originalXorArray');
    renderArrayInContainer([...originalArrayForXor], 'transformedXorArray');
    
    performPrefixXorAnimation();
}
// NEW: Perform Prefix XOR Animation
function performPrefixXorAnimation() {
    const originalContainer = document.getElementById('originalXorArray');
    const transformedContainer = document.getElementById('transformedXorArray');
    const explanation = document.getElementById('xorExplanation');
    const stepsContainer = document.getElementById('xorSteps');
    const continueButton = document.getElementById('continueAfterXor');
    
    const originalArray = originalArrayForXor.map(val => parseInt(val));
    let prefixXorArray = [];
    let currentXor = 0;
    let currentIndex = 0;
    
    function performXorStep() {
        if (currentIndex >= originalArray.length) {
            // XOR operation completed
            explanation.innerHTML = `<strong>Prefix XOR Operation Completed!</strong> Final prefix XOR array generated.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Prefix XOR array: [${prefixXorArray.join(', ')}]
                </div>
            `;
            
            // Highlight all elements in the transformed array
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('xor-result');
                }, index * 200);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterXor();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterXor);
            
            return;
        }
        
        const stepNumber = currentIndex + 1;
        
        if (currentIndex === 0) {
            // First element - XOR with 0
            explanation.innerHTML = `Step ${stepNumber}: First element - XOR with 0`;
            
            const originalElements = originalContainer.querySelectorAll('.array-element');
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            
            // Highlight current element
            originalElements[currentIndex].querySelector('.element-value').classList.add('xor-current');
            transformedElements[currentIndex].querySelector('.element-value').classList.add('xor-current');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${stepNumber}:</strong> prefixXor[0] = 
                    <span class="xor-operation">0 XOR ${originalArray[currentIndex]}</span> = 
                    <span class="xor-operation">${originalArray[currentIndex]}</span>
                </div>
            `;
            
            setTimeout(() => {
                currentXor = originalArray[currentIndex];
                prefixXorArray.push(currentXor);
                
                // Update transformed array
                renderArrayInContainer(prefixXorArray, 'transformedXorArray');
                
                // Remove current highlight and add result highlight
                originalElements[currentIndex].querySelector('.element-value').classList.remove('xor-current');
                originalElements[currentIndex].querySelector('.element-value').classList.add('xor-highlight');
                
                const updatedElements = transformedContainer.querySelectorAll('.array-element');
                if (updatedElements[currentIndex]) {
                    updatedElements[currentIndex].querySelector('.element-value').classList.remove('xor-current');
                    updatedElements[currentIndex].querySelector('.element-value').classList.add('xor-result');
                }
                
                // Move to next step
                currentIndex++;
                setTimeout(performXorStep, 1500);
            }, 2000);
            
        } else {
            // Subsequent elements - XOR with previous result
            explanation.innerHTML = `Step ${stepNumber}: XOR with previous result (${currentXor})`;
            
            const originalElements = originalContainer.querySelectorAll('.array-element');
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            
            // Highlight previous result and current element
            if (currentIndex > 0) {
                const prevElement = transformedElements[currentIndex - 1];
                if (prevElement) {
                    prevElement.querySelector('.element-value').classList.add('xor-highlight');
                }
            }
            
            if (originalElements[currentIndex]) {
                originalElements[currentIndex].querySelector('.element-value').classList.add('xor-current');
            }
            
            if (transformedElements[currentIndex]) {
                transformedElements[currentIndex].querySelector('.element-value').classList.add('xor-current');
            }
            
            const newXor = currentXor ^ originalArray[currentIndex];
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${stepNumber}:</strong> prefixXor[${currentIndex}] = 
                    <span class="xor-operation">${currentXor} XOR ${originalArray[currentIndex]}</span> = 
                    <span class="xor-operation">${newXor}</span>
                </div>
            `;
            
            setTimeout(() => {
                currentXor = newXor;
                prefixXorArray.push(currentXor);
                
                // Update transformed array
                renderArrayInContainer(prefixXorArray, 'transformedXorArray');
                
                // Remove highlights
                if (currentIndex > 0) {
                    const prevElement = transformedElements[currentIndex - 1];
                    if (prevElement) {
                        prevElement.querySelector('.element-value').classList.remove('xor-highlight');
                    }
                }
                
                if (originalElements[currentIndex]) {
                    originalElements[currentIndex].querySelector('.element-value').classList.remove('xor-current');
                }
                
                // Get updated elements after re-render
                const updatedElements = transformedContainer.querySelectorAll('.array-element');
                if (updatedElements[currentIndex]) {
                    updatedElements[currentIndex].querySelector('.element-value').classList.remove('xor-current');
                    updatedElements[currentIndex].querySelector('.element-value').classList.add('xor-result');
                }
                
                // Highlight all previous results
                for (let j = 0; j <= currentIndex; j++) {
                    if (updatedElements[j]) {
                        updatedElements[j].querySelector('.element-value').classList.add('xor-highlight');
                    }
                }
                
                // Move to next step
                currentIndex++;
                setTimeout(performXorStep, 1500);
            }, 2000);
        }
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
    }
    
    // Start XOR process
    performXorStep();
}
// NEW: Return to Original after XOR Operation
function returnToOriginalAfterXor() {
    // Reset to original array
    myArray = [...originalArrayForXor];
    originalArrayForXor = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isPrefixXorRunning = false;
    
    logOperation('Prefix XOR operation completed - returned to original array', 'info');
    showNotification('Returned to original array after prefix XOR operation', 'success');
}
// NEW: Maximum Absolute Difference Handler
function handleFindMaxAbsDiff() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length < 2) {
        showNotification('Array must have at least 2 elements to calculate maximum absolute difference', 'warning');
        return;
    }
    
    if (isMaxAbsDiffRunning) {
        showNotification('Maximum absolute difference calculation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Maximum absolute difference calculation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isMaxAbsDiffRunning = true;
    
    // Store original array
    originalArrayForAbsDiff = [...myArray];
    
    // Show maximum absolute difference visualization
    showMaxAbsDiffVisualization();
}

// NEW: Show Maximum Absolute Difference Visualization
function showMaxAbsDiffVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Maximum Absolute Difference Calculation</h5>
        
        <div class="array-group">
            <div class="array-label">Array</div>
            <div class="original-array-container" id="absDiffArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Formula:</strong> max(|A[i] - A[j]| + |i - j|) for all i, j</p>
            <p class="mb-2"><strong>Optimized Approach:</strong> max(A[i] + i) - min(A[i] + i) OR max(A[i] - i) - min(A[i] - i)</p>
            <p class="mb-0" id="absDiffExplanation">Initializing calculation...</p>
        </div>
        
        <div class="abs-diff-table mt-3" id="absDiffTableContainer" style="display: none;">
            <h6 class="text-center">Calculation Table</h6>
            <table class="abs-diff-table">
                <thead>
                    <tr>
                        <th>Index (i)</th>
                        <th>A[i]</th>
                        <th>A[i] + i</th>
                        <th>A[i] - i</th>
                        <th>max(A[i] + i)</th>
                        <th>min(A[i] + i)</th>
                        <th>max(A[i] - i)</th>
                        <th>min(A[i] - i)</th>
                    </tr>
                </thead>
                <tbody id="absDiffTableBody">
                </tbody>
            </table>
        </div>
        
        <div class="algorithm-steps mt-3" id="absDiffStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="absDiffSteps"></div>
        </div>
        
        <div class="abs-diff-results mt-3" id="absDiffResults" style="display: none;">
            <h6 class="text-center">Maximum Absolute Difference Results</h6>
            <div class="stats-card">
                <div>Difference 1 (A[i] + i)</div>
                <div class="diff-value diff1-value" id="diff1Value">0</div>
            </div>
            <div class="stats-card">
                <div>Difference 2 (A[i] - i)</div>
                <div class="diff-value diff2-value" id="diff2Value">0</div>
            </div>
            <div class="stats-card">
                <div>Maximum Absolute Difference</div>
                <div class="diff-value max-diff-value" id="maxDiffValue">0</div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterAbsDiff" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForAbsDiff, 'absDiffArray');
    
    performMaxAbsDiffCalculation();
}

// NEW: Perform Maximum Absolute Difference Calculation with Animation
function performMaxAbsDiffCalculation() {
    const arrayContainer = document.getElementById('absDiffArray');
    const explanation = document.getElementById('absDiffExplanation');
    const stepsContainer = document.getElementById('absDiffSteps');
    const tableContainer = document.getElementById('absDiffTableContainer');
    const tableBody = document.getElementById('absDiffTableBody');
    const resultsContainer = document.getElementById('absDiffResults');
    const diff1Value = document.getElementById('diff1Value');
    const diff2Value = document.getElementById('diff2Value');
    const maxDiffValue = document.getElementById('maxDiffValue');
    const continueButton = document.getElementById('continueAfterAbsDiff');
    
    const arr = originalArrayForAbsDiff.map(val => parseFloat(val));
    const n = arr.length;
    
    let max1 = -Infinity, min1 = Infinity; // For A[i] + i
    let max2 = -Infinity, min2 = Infinity; // For A[i] - i
    let max1Index = -1, min1Index = -1;
    let max2Index = -1, min2Index = -1;
    
    let step = 0;
    let currentIndex = 0;
    
    // Show table after initial setup
    setTimeout(() => {
        tableContainer.style.display = 'block';
        explanation.innerHTML = 'Starting calculation process...';
    }, 500);
    
    function performCalculationStep() {
        if (currentIndex >= n) {
            // All steps completed - show final results
            showFinalResults();
            return;
        }
        
        const i = currentIndex;
        const valuePlusIndex = arr[i] + i;
        const valueMinusIndex = arr[i] - i;
        
        step++;
        
        // Update explanation
        explanation.innerHTML = `Step ${step}: Processing index ${i} (Value: ${arr[i]})`;
        
        // Highlight current element
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElement = elements[i].querySelector('.element-value');
        currentElement.classList.add('abs-diff-current');
        
        // Add step description
        const stepElement = document.createElement('div');
        stepElement.className = 'algorithm-step';
        stepElement.innerHTML = `
            <strong>Step ${step}:</strong> Processing index ${i}<br>
             Value A[${i}] = ${arr[i]}<br>
             A[i] + i = ${arr[i]} + ${i} = ${valuePlusIndex}<br>
             A[i] - i = ${arr[i]} - ${i} = ${valueMinusIndex}
        `;
        stepsContainer.appendChild(stepElement);
        
        // Scroll to show current step
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Update max and min values
        let max1Updated = false, min1Updated = false;
        let max2Updated = false, min2Updated = false;
        
        if (valuePlusIndex > max1) {
            max1 = valuePlusIndex;
            max1Index = i;
            max1Updated = true;
        }
        if (valuePlusIndex < min1) {
            min1 = valuePlusIndex;
            min1Index = i;
            min1Updated = true;
        }
        if (valueMinusIndex > max2) {
            max2 = valueMinusIndex;
            max2Index = i;
            max2Updated = true;
        }
        if (valueMinusIndex < min2) {
            min2 = valueMinusIndex;
            min2Index = i;
            min2Updated = true;
        }
        
        // Wait for animation to complete before proceeding
        setTimeout(() => {
            // Add row to table
            const row = document.createElement('tr');
            
            let max1Class = max1Updated ? 'abs-diff-highlight' : '';
            let min1Class = min1Updated ? 'abs-diff-highlight' : '';
            let max2Class = max2Updated ? 'abs-diff-highlight' : '';
            let min2Class = min2Updated ? 'abs-diff-highlight' : '';
            
            row.innerHTML = `
                <td>${i}</td>
                <td>${arr[i]}</td>
                <td>${valuePlusIndex}</td>
                <td>${valueMinusIndex}</td>
                <td class="${max1Class}">${max1}${max1Updated ? '  NEW!' : ''}</td>
                <td class="${min1Class}">${min1}${min1Updated ? '  NEW!' : ''}</td>
                <td class="${max2Class}">${max2}${max2Updated ? '  NEW!' : ''}</td>
                <td class="${min2Class}">${min2}${min2Updated ? '  NEW!' : ''}</td>
            `;
            
            tableBody.appendChild(row);
            
            // Remove current highlight
            currentElement.classList.remove('abs-diff-current');
            
            // Highlight updated max/min elements
            if (max1Updated && max1Index !== -1) {
                elements[max1Index].querySelector('.element-value').classList.add('abs-diff-compared');
                setTimeout(() => {
                    elements[max1Index].querySelector('.element-value').classList.remove('abs-diff-compared');
                }, 1000);
            }
            if (min1Updated && min1Index !== -1) {
                elements[min1Index].querySelector('.element-value').classList.add('abs-diff-compared');
                setTimeout(() => {
                    elements[min1Index].querySelector('.element-value').classList.remove('abs-diff-compared');
                }, 1000);
            }
            if (max2Updated && max2Index !== -1) {
                elements[max2Index].querySelector('.element-value').classList.add('abs-diff-compared');
                setTimeout(() => {
                    elements[max2Index].querySelector('.element-value').classList.remove('abs-diff-compared');
                }, 1000);
            }
            if (min2Updated && min2Index !== -1) {
                elements[min2Index].querySelector('.element-value').classList.add('abs-diff-compared');
                setTimeout(() => {
                    elements[min2Index].querySelector('.element-value').classList.remove('abs-diff-compared');
                }, 1000);
            }
            
            // Update step description with results
            let updates = [];
            if (max1Updated) updates.push(`New max(A[i]+i) = ${max1} at index ${max1Index}`);
            if (min1Updated) updates.push(`New min(A[i]+i) = ${min1} at index ${min1Index}`);
            if (max2Updated) updates.push(`New max(A[i]-i) = ${max2} at index ${max2Index}`);
            if (min2Updated) updates.push(`New min(A[i]-i) = ${min2} at index ${min2Index}`);
            
            if (updates.length > 0) {
                const updateElement = document.createElement('div');
                updateElement.className = 'algorithm-step active';
                updateElement.innerHTML = `<strong>Updates:</strong> ${updates.join(', ')}`;
                stepsContainer.appendChild(updateElement);
                stepsContainer.scrollTop = stepsContainer.scrollHeight;
            }
            
            // Move to next index
            currentIndex++;
            
            // Continue with next step after delay
            setTimeout(performCalculationStep, 2000);
            
        }, 1500);
    }
    
    function showFinalResults() {
        const diff1 = max1 - min1;
        const diff2 = max2 - min2;
        const maxDiff = Math.max(diff1, diff2);
        
        explanation.innerHTML = `<strong>Calculation Completed!</strong> Maximum absolute difference found.`;
        
        // Add final step with detailed calculation
        const finalStep = document.createElement('div');
        finalStep.className = 'algorithm-step active';
        
        // Create calculation table for final results
        const calculationTable = document.createElement('table');
        calculationTable.className = 'abs-diff-table';
        calculationTable.style.margin = '15px 0';
        calculationTable.style.background = 'rgba(255, 255, 255, 0.1)';
        
        calculationTable.innerHTML = `
            <thead>
                <tr>
                    <th>Calculation Type</th>
                    <th>Max Value</th>
                    <th>Min Value</th>
                    <th>Difference</th>
                    <th>Result</th>
                </tr>
            </thead>
            <tbody>
                <tr class="${diff1 >= diff2 ? 'abs-diff-highlight' : ''}">
                    <td>A[i] + i</td>
                    <td>${max1} (at index ${max1Index})</td>
                    <td>${min1} (at index ${min1Index})</td>
                    <td>${max1} - ${min1}</td>
                    <td><strong>${diff1}</strong></td>
                </tr>
                <tr class="${diff2 >= diff1 ? 'abs-diff-highlight' : ''}">
                    <td>A[i] - i</td>
                    <td>${max2} (at index ${max2Index})</td>
                    <td>${min2} (at index ${min2Index})</td>
                    <td>${max2} - ${min2}</td>
                    <td><strong>${diff2}</strong></td>
                </tr>
            </tbody>
        `;
        
        finalStep.innerHTML = `
            <strong>Final Calculation:</strong>
        `;
        finalStep.appendChild(calculationTable);
        
        // Add the maximum difference display
        const maxDiffDisplay = document.createElement('div');
        maxDiffDisplay.className = 'algorithm-step active';
        maxDiffDisplay.style.background = 'rgba(253, 203, 110, 0.3)';
        maxDiffDisplay.style.border = '2px solid var(--warning-color)';
        maxDiffDisplay.style.padding = '15px';
        maxDiffDisplay.style.borderRadius = '10px';
        maxDiffDisplay.style.textAlign = 'center';
        
        if (diff1 >= diff2) {
            maxDiffDisplay.innerHTML = `
                <h6 style="color: var(--warning-color); margin-bottom: 10px;">Maximum Absolute Difference Calculation</h6>
                <div style="font-size: 1.2rem; font-weight: bold;">
                    ${max1} - ${min1} = <span style="color: var(--success-color); font-size: 1.4rem;">${diff1}</span>
                </div>
                <div style="margin-top: 10px; font-weight: bold;">
                    The maximum absolute difference is <span style="color: var(--success-color);">${maxDiff}</span>
                </div>
                <div style="font-size: 0.9rem; margin-top: 5px;">
                    (Using A[i] + i approach with indices ${min1Index} and ${max1Index})
                </div>
            `;
        } else {
            maxDiffDisplay.innerHTML = `
                <h6 style="color: var(--warning-color); margin-bottom: 10px;">Maximum Absolute Difference Calculation</h6>
                <div style="font-size: 1.2rem; font-weight: bold;">
                    ${max2} - ${min2} = <span style="color: var(--success-color); font-size: 1.4rem;">${diff2}</span>
                </div>
                <div style="margin-top: 10px; font-weight: bold;">
                    The maximum absolute difference is <span style="color: var(--success-color);">${maxDiff}</span>
                </div>
                <div style="font-size: 0.9rem; margin-top: 5px;">
                    (Using A[i] - i approach with indices ${min2Index} and ${max2Index})
                </div>
            `;
        }
        
        stepsContainer.appendChild(finalStep);
        stepsContainer.appendChild(maxDiffDisplay);
        
        // Show results in the results container
        resultsContainer.style.display = 'block';
        diff1Value.textContent = `${diff1} (from indices ${min1Index} and ${max1Index})`;
        diff2Value.textContent = `${diff2} (from indices ${min2Index} and ${max2Index})`;
        maxDiffValue.textContent = `${maxDiff}`;
        
        // Highlight the elements that give maximum difference
        const elements = arrayContainer.querySelectorAll('.array-element');
        
        let finalMinIndex, finalMaxIndex;
        if (diff1 >= diff2) {
            finalMinIndex = min1Index;
            finalMaxIndex = max1Index;
        } else {
            finalMinIndex = min2Index;
            finalMaxIndex = max2Index;
        }
        
        // Animate the final result
        setTimeout(() => {
            elements[finalMinIndex].querySelector('.element-value').classList.add('abs-diff-max');
            elements[finalMaxIndex].querySelector('.element-value').classList.add('abs-diff-max');
            
            // Add explanation for the final pair
            const pairExplanation = document.createElement('div');
            pairExplanation.className = 'algorithm-step active';
            pairExplanation.innerHTML = `
                <strong>Maximum Absolute Difference Pair:</strong><br>
                 Indices: ${finalMinIndex} and ${finalMaxIndex}<br>
                 Values: ${arr[finalMinIndex]} and ${arr[finalMaxIndex]}<br>
                 Calculation: |${arr[finalMinIndex]} - ${arr[finalMaxIndex]}| + |${finalMinIndex} - ${finalMaxIndex}| = ${Math.abs(arr[finalMinIndex] - arr[finalMaxIndex])} + ${Math.abs(finalMinIndex - finalMaxIndex)} = <strong>${maxDiff}</strong>
            `;
            stepsContainer.appendChild(pairExplanation);
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
        }, 500);
        
        continueButton.style.display = 'block';
        
        // Auto-return after 10 seconds
        setTimeout(() => {
            returnToOriginalAfterAbsDiff();
        }, 10000);
        
        continueButton.addEventListener('click', returnToOriginalAfterAbsDiff);
    }
    
    // Start calculation process after initial delay
    setTimeout(performCalculationStep, 1000);
}
// NEW: Return to Original after Maximum Absolute Difference
function returnToOriginalAfterAbsDiff() {
    // Reset to original array
    myArray = [...originalArrayForAbsDiff];
    originalArrayForAbsDiff = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMaxAbsDiffRunning = false;
    
    logOperation('Maximum absolute difference calculation completed - returned to original array', 'info');
    showNotification('Returned to original array after maximum absolute difference calculation', 'success');
}
// NEW: Maximum Sum Circular Subarray Handler
function handleMaxCircularSubarray() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isCircularSubarrayRunning) {
        showNotification('Circular subarray operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Circular subarray algorithm requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForCircular = [...myArray];
    
    // Show circular subarray visualization
    showCircularSubarrayVisualization();
}
// NEW: Show Circular Subarray Visualization
function showCircularSubarrayVisualization() {
    isCircularSubarrayRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Maximum Sum Circular Subarray</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalCircularArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find maximum sum in circular array (wrapping allowed)</p>
            <p class="mb-0" id="circularExplanation">Initializing circular subarray algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="circularStepsContainer">
            <h6 class="text-center">Circular Subarray Calculation Steps</h6>
            <div class="steps-container" id="circularSteps"></div>
        </div>
        
        <div class="table-container mt-3">
            <table class="circular-table">
                <thead>
                    <tr>
                        <th>Step</th>
                        <th>Description</th>
                        <th>Value</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody id="circularTableBody">
                    <tr>
                        <td>1</td>
                        <td>Compute Total Sum</td>
                        <td id="step1Value">-</td>
                        <td id="step1Status">Pending</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>Kadane Max (Non-Wrapping)</td>
                        <td id="step2Value">-</td>
                        <td id="step2Status">Pending</td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>Kadane Min (Find Minimum Subarray Sum)</td>
                        <td id="step3Value">-</td>
                        <td id="step3Status">Pending</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>Max Circular = Total Sum - Min Subarray</td>
                        <td id="step4Value">-</td>
                        <td id="step4Status">Pending</td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td>Final Answer = max(Kadane Max, Max Circular)</td>
                        <td id="step5Value">-</td>
                        <td id="step5Status">Pending</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="stats-card mt-3">
            <div>Maximum Circular Subarray Sum</div>
            <div class="stats-value" id="maxCircularSumValue">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Subarray Indices</div>
            <div class="stats-value" id="maxCircularIndices">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterCircular" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForCircular, 'originalCircularArray');
    
    performCircularSubarrayAlgorithm();
}

// NEW: Perform Circular Subarray Algorithm
function performCircularSubarrayAlgorithm() {
    const arrayContainer = document.getElementById('originalCircularArray');
    const explanation = document.getElementById('circularExplanation');
    const stepsContainer = document.getElementById('circularSteps');
    const maxCircularSumValue = document.getElementById('maxCircularSumValue');
    const maxCircularIndices = document.getElementById('maxCircularIndices');
    const continueButton = document.getElementById('continueAfterCircular');
    
    const arr = originalArrayForCircular.map(val => parseFloat(val));
    const n = arr.length;
    let step = 0;
    
    // Helper functions
    function getKadaneMax(arr) {
        let maxEndingHere = arr[0];
        let maxSoFar = arr[0];
        for (let i = 1; i < arr.length; i++) {
            maxEndingHere = Math.max(arr[i], maxEndingHere + arr[i]);
            maxSoFar = Math.max(maxSoFar, maxEndingHere);
        }
        return maxSoFar;
    }
    
    function getKadaneMin(arr) {
        let minEndingHere = arr[0];
        let minSoFar = arr[0];
        for (let i = 1; i < arr.length; i++) {
            minEndingHere = Math.min(arr[i], minEndingHere + arr[i]);
            minSoFar = Math.min(minSoFar, minEndingHere);
        }
        return minSoFar;
    }
    
    function getKadaneMaxIndices(arr) {
        let maxEndingHere = arr[0];
        let maxSoFar = arr[0];
        let start = 0;
        let end = 0;
        let tempStart = 0;
        
        for (let i = 1; i < arr.length; i++) {
            if (maxEndingHere < 0) {
                maxEndingHere = arr[i];
                tempStart = i;
            } else {
                maxEndingHere += arr[i];
            }
            
            if (maxEndingHere > maxSoFar) {
                maxSoFar = maxEndingHere;
                start = tempStart;
                end = i;
            }
        }
        return { start, end };
    }
    
    function getKadaneMinIndices(arr) {
        let minEndingHere = arr[0];
        let minSoFar = arr[0];
        let start = 0;
        let end = 0;
        let tempStart = 0;
        
        for (let i = 1; i < arr.length; i++) {
            if (minEndingHere > 0) {
                minEndingHere = arr[i];
                tempStart = i;
            } else {
                minEndingHere += arr[i];
            }
            
            if (minEndingHere < minSoFar) {
                minSoFar = minEndingHere;
                start = tempStart;
                end = i;
            }
        }
        return { start, end };
    }
    
    function updateTableStep(stepNum, value, status) {
        const valueCell = document.getElementById(`step${stepNum}Value`);
        const statusCell = document.getElementById(`step${stepNum}Status`);
        
        valueCell.textContent = value;
        statusCell.textContent = status;
        
        // Highlight the active step
        const tableBody = document.getElementById('circularTableBody');
        const rows = tableBody.getElementsByTagName('tr');
        for (let i = 0; i < rows.length; i++) {
            rows[i].classList.remove('circular-step-active');
        }
        if (stepNum <= 5) {
            rows[stepNum - 1].classList.add('circular-step-active');
        }
    }
    
    // Step 1: Compute Total Sum
    function executeStep1() {
        step = 1;
        explanation.innerHTML = `Step ${step}: Computing total sum of all elements`;
        updateTableStep(step, 'Computing...', 'In Progress');
        
        let totalSum = 0;
        const elements = arrayContainer.querySelectorAll('.array-element');
        
        // Animate summing all elements
        function animateSum(index) {
            if (index >= n) {
                // Step 1 completed
                updateTableStep(1, totalSum, 'Completed');
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Total Sum = ${totalSum}
                    </div>
                `;
                setTimeout(executeStep2, 1500);
                return;
            }
            
            const valueDiv = elements[index].querySelector('.element-value');
            valueDiv.classList.add('circular-current');
            
            setTimeout(() => {
                totalSum += arr[index];
                valueDiv.classList.remove('circular-current');
                valueDiv.classList.add('circular-included');
                
                // Update explanation
                explanation.innerHTML = `Step ${step}: Computing total sum... Current: ${totalSum}`;
                
                animateSum(index + 1);
            }, 800);
        }
        
        animateSum(0);
    }
    
    // Step 2: Kadane Max (Non-Wrapping)
    function executeStep2() {
        step = 2;
        explanation.innerHTML = `Step ${step}: Finding maximum subarray sum (non-wrapping) using Kadane's algorithm`;
        updateTableStep(step, 'Computing...', 'In Progress');
        
        // Reset all highlights
        const elements = arrayContainer.querySelectorAll('.array-element');
        elements.forEach(el => {
            el.querySelector('.element-value').classList.remove('circular-included', 'circular-current');
        });
        
        let maxEndingHere = arr[0];
        let maxSoFar = arr[0];
        let start = 0;
        let end = 0;
        let tempStart = 0;
        
        function animateKadaneMax(i) {
            if (i >= n) {
                // Step 2 completed
                updateTableStep(2, maxSoFar, 'Completed');
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Kadane Max = ${maxSoFar} (indices ${start} to ${end})
                    </div>
                `;
                
                // Highlight the max subarray
                for (let j = start; j <= end; j++) {
                    setTimeout(() => {
                        elements[j].querySelector('.element-value').classList.add('circular-max-subarray');
                    }, (j - start) * 200);
                }
                
                setTimeout(executeStep3, 2000);
                return;
            }
            
            const valueDiv = elements[i].querySelector('.element-value');
            valueDiv.classList.add('circular-current');
            
            setTimeout(() => {
                if (maxEndingHere < 0) {
                    maxEndingHere = arr[i];
                    tempStart = i;
                } else {
                    maxEndingHere += arr[i];
                }
                
                if (maxEndingHere > maxSoFar) {
                    maxSoFar = maxEndingHere;
                    start = tempStart;
                    end = i;
                }
                
                explanation.innerHTML = `Step ${step}: Kadane's Algorithm - Current: ${maxEndingHere}, Max: ${maxSoFar}`;
                
                valueDiv.classList.remove('circular-current');
                if (i >= start && i <= end) {
                    valueDiv.classList.add('circular-included');
                }
                
                animateKadaneMax(i + 1);
            }, 1000);
        }
        
        animateKadaneMax(1); // Start from index 1 since we initialized with index 0
    }
    
    // Step 3: Kadane Min (Find Minimum Subarray Sum)
    function executeStep3() {
        step = 3;
        explanation.innerHTML = `Step ${step}: Finding minimum subarray sum (for circular calculation)`;
        updateTableStep(step, 'Computing...', 'In Progress');
        
        // Reset all highlights
        const elements = arrayContainer.querySelectorAll('.array-element');
        elements.forEach(el => {
            el.querySelector('.element-value').classList.remove('circular-included', 'circular-max-subarray');
        });
        
        let minEndingHere = arr[0];
        let minSoFar = arr[0];
        let minStart = 0;
        let minEnd = 0;
        let tempMinStart = 0;
        
        function animateKadaneMin(i) {
            if (i >= n) {
                // Step 3 completed
                updateTableStep(3, minSoFar, 'Completed');
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Kadane Min = ${minSoFar} (indices ${minStart} to ${minEnd})
                    </div>
                `;
                
                // Highlight the min subarray
                for (let j = minStart; j <= minEnd; j++) {
                    setTimeout(() => {
                        elements[j].querySelector('.element-value').classList.add('circular-min-subarray');
                    }, (j - minStart) * 200);
                }
                
                setTimeout(executeStep4, 2000);
                return;
            }
            
            const valueDiv = elements[i].querySelector('.element-value');
            valueDiv.classList.add('circular-current');
            
            setTimeout(() => {
                if (minEndingHere > 0) {
                    minEndingHere = arr[i];
                    tempMinStart = i;
                } else {
                    minEndingHere += arr[i];
                }
                
                if (minEndingHere < minSoFar) {
                    minSoFar = minEndingHere;
                    minStart = tempMinStart;
                    minEnd = i;
                }
                
                explanation.innerHTML = `Step ${step}: Kadane Min - Current: ${minEndingHere}, Min: ${minSoFar}`;
                
                valueDiv.classList.remove('circular-current');
                if (i >= minStart && i <= minEnd) {
                    valueDiv.classList.add('circular-included');
                }
                
                animateKadaneMin(i + 1);
            }, 1000);
        }
        
        animateKadaneMin(1);
    }
    
    // Step 4: Max Circular Calculation
    function executeStep4() {
        step = 4;
        const totalSum = arr.reduce((a, b) => a + b, 0);
        const kadaneMin = getKadaneMin(arr);
        const maxCircular = totalSum - kadaneMin;
        
        explanation.innerHTML = `Step ${step}: Max Circular = Total Sum (${totalSum}) - Min Subarray (${kadaneMin}) = ${maxCircular}`;
        updateTableStep(4, maxCircular, 'Completed');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step 4:</strong> Max Circular = ${totalSum} - ${kadaneMin} = ${maxCircular}
            </div>
        `;
        
        setTimeout(executeStep5, 1500);
    }
    
    // Step 5: Final Answer
    function executeStep5() {
        step = 5;
        const kadaneMax = getKadaneMax(arr);
        const totalSum = arr.reduce((a, b) => a + b, 0);
        const kadaneMin = getKadaneMin(arr);
        const maxCircular = totalSum - kadaneMin;
        const finalAnswer = Math.max(kadaneMax, maxCircular);
        
        explanation.innerHTML = `Step ${step}: Final Answer = max(Kadane Max: ${kadaneMax}, Max Circular: ${maxCircular}) = ${finalAnswer}`;
        updateTableStep(5, finalAnswer, 'Completed');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step 5:</strong> Final Answer = max(${kadaneMax}, ${maxCircular}) = ${finalAnswer}
            </div>
        `;
        
        // Update final results
        maxCircularSumValue.textContent = finalAnswer;
        
        // Determine which subarray gives the maximum
        const elements = arrayContainer.querySelectorAll('.array-element');
        elements.forEach(el => {
            el.querySelector('.element-value').classList.remove('circular-included', 'circular-min-subarray');
        });
        
        if (finalAnswer === kadaneMax) {
            // Highlight the non-circular max subarray
            const { start, end } = getKadaneMaxIndices(arr);
            maxCircularIndices.textContent = `Non-circular subarray (indices ${start} to ${end})`;
            for (let j = start; j <= end; j++) {
                setTimeout(() => {
                    elements[j].querySelector('.element-value').classList.add('circular-max-subarray');
                }, j * 100);
            }
        } else {
            // For circular case, highlight all elements except the min subarray
            const { start: minStart, end: minEnd } = getKadaneMinIndices(arr);
            maxCircularIndices.textContent = `Circular subarray (wrapping around, excluding indices ${minStart} to ${minEnd})`;
            for (let j = 0; j < n; j++) {
                if (j < minStart || j > minEnd) {
                    setTimeout(() => {
                        elements[j].querySelector('.element-value').classList.add('circular-max-subarray');
                    }, j * 100);
                }
            }
        }
        
        continueButton.style.display = 'block';
        
        // Auto-return after 8 seconds
        setTimeout(() => {
            returnToOriginalAfterCircular();
        }, 8000);
        
        continueButton.addEventListener('click', returnToOriginalAfterCircular);
    }
    
    // Start the algorithm
    executeStep1();
}

// NEW: Return to Original after Circular Subarray
function returnToOriginalAfterCircular() {
    // Reset to original array
    myArray = [...originalArrayForCircular];
    originalArrayForCircular = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isCircularSubarrayRunning = false;
    
    logOperation('Circular subarray algorithm completed - returned to original array', 'info');
    showNotification('Returned to original array after circular subarray operation', 'success');
}
// Helper function to render array in specific container
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = `
            <div class="array-empty-state">
                <i class="fas fa-layer-group"></i>
                <h4>Array is Empty</h4>
                <p>Add some elements to get started!</p>
            </div>
        `;
        return;
    }
    
    array.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}
// NEW: Wiggle Sort II Handler
function handleWiggleSortII() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isWiggleSortRunning) {
        showNotification('Wiggle Sort II is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Wiggle Sort II requires all array elements to be numbers', 'danger');
        return;
    }
    
    if (myArray.length < 3) {
        showNotification('Wiggle Sort II requires at least 3 elements', 'warning');
        return;
    }
    
    isWiggleSortRunning = true;
    
    // Store original array
    originalArrayForWiggle = [...myArray];
    
    // Show Wiggle Sort II visualization
    showWiggleSortIIVisualization();
}
// NEW: Show Wiggle Sort II Visualization
function showWiggleSortIIVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Wiggle Sort II Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalWiggleArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Wiggle Sort II Process</div>
            <div class="transformed-array-container" id="transformedWiggleArray"></div>
        </div>
        
        <div class="wiggle-explanation">
            <p class="mb-2"><strong>Wiggle Sort II:</strong> Sort array such that nums[0] < nums[1] > nums[2] < nums[3]...</p>
            <p class="mb-0" id="wiggleExplanation">Initializing Wiggle Sort II algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="wiggleStepsContainer">
            <h6 class="text-center">Wiggle Sort II Steps</h6>
            <div class="steps-container" id="wiggleSteps"></div>
        </div>
        
        <div class="code-snippet mt-3">
            <strong>Algorithm Steps:</strong><br>
            1. Sort the array<br>
            2. Split into two halves: smaller and larger<br>
            3. Interleave larger and smaller elements<br>
            4. Ensure wiggle property: odd < even > next_odd
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterWiggle" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForWiggle, 'originalWiggleArray');
    renderArrayInContainer([...originalArrayForWiggle], 'transformedWiggleArray');
    
    performWiggleSortIIAnimation();
}
// NEW: Perform Wiggle Sort II Animation
function performWiggleSortIIAnimation() {
    const originalContainer = document.getElementById('originalWiggleArray');
    const transformedContainer = document.getElementById('transformedWiggleArray');
    const explanation = document.getElementById('wiggleExplanation');
    const stepsContainer = document.getElementById('wiggleSteps');
    const continueButton = document.getElementById('continueAfterWiggle');
    
    let array = [...originalArrayForWiggle].map(val => parseFloat(val));
    const n = array.length;
    let step = 0;
    
    function performWiggleStep() {
        switch (step) {
            case 0:
                // Step 1: Sort the array
                explanation.innerHTML = "Step 1: Sorting the array in ascending order";
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Sort the array: [${array.join(', ')}]  [${[...array].sort((a, b) => a - b).join(', ')}]
                    </div>
                `;
                
                // Highlight all elements
                const elements1 = transformedContainer.querySelectorAll('.array-element');
                elements1.forEach((el, index) => {
                    setTimeout(() => {
                        el.querySelector('.element-value').classList.add('wiggle-current');
                    }, index * 200);
                });
                
                setTimeout(() => {
                    // Sort the array
                    array.sort((a, b) => a - b);
                    renderArrayInContainer(array, 'transformedWiggleArray');
                    
                    // Remove highlights
                    elements1.forEach(el => {
                        el.querySelector('.element-value').classList.remove('wiggle-current');
                    });
                    
                    step++;
                    performWiggleStep();
                }, 2000);
                break;
                
            case 1:
                // Step 2: Split into two halves
                const mid = Math.floor((n + 1) / 2);
                const smaller = array.slice(0, mid);
                const larger = array.slice(mid);
                
                explanation.innerHTML = `Step 2: Split into two halves - Smaller: [${smaller.join(', ')}], Larger: [${larger.join(', ')}]`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Split at index ${mid}: Smaller=${smaller.length}, Larger=${larger.length}
                    </div>
                `;
                
                // Highlight the two halves
                const elements2 = transformedContainer.querySelectorAll('.array-element');
                for (let i = 0; i < smaller.length; i++) {
                    setTimeout(() => {
                        elements2[i].querySelector('.element-value').classList.add('info-color');
                    }, i * 150);
                }
                for (let i = 0; i < larger.length; i++) {
                    setTimeout(() => {
                        elements2[i + smaller.length].querySelector('.element-value').classList.add('warning-color');
                    }, i * 150);
                }
                
                step++;
                setTimeout(performWiggleStep, 2000);
                break;
                
            case 2:
                // Step 3: Interleave elements
                explanation.innerHTML = "Step 3: Interleaving larger and smaller elements";
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Interleaving elements from both halves
                    </div>
                `;
                
                const mid2 = Math.floor((n + 1) / 2);
                const result = new Array(n);
                let smallIndex = mid2 - 1;
                let largeIndex = n - 1;
                
                function interleaveStep(index) {
                    if (index >= n) {
                        step++;
                        performWiggleStep();
                        return;
                    }
                    
                    if (index % 2 === 0) {
                        // Even index: take from smaller half
                        result[index] = array[smallIndex--];
                        explanation.innerHTML = `Step 3: Even index ${index}  Smaller[${smallIndex + 1}]=${result[index]}`;
                    } else {
                        // Odd index: take from larger half
                        result[index] = array[largeIndex--];
                        explanation.innerHTML = `Step 3: Odd index ${index}  Larger[${largeIndex + 1}]=${result[index]}`;
                    }
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Interleave:</strong> result[${index}] = ${result[index]}
                        </div>
                    `;
                    
                    // Update display
                    const tempArray = [...result];
                    for (let i = index + 1; i < n; i++) {
                        tempArray[i] = array[i];
                    }
                    renderArrayInContainer(tempArray, 'transformedWiggleArray');
                    
                    // Highlight current position
                    const elements3 = transformedContainer.querySelectorAll('.array-element');
                    elements3[index].querySelector('.element-value').classList.add('wiggle-current');
                    
                    setTimeout(() => {
                        elements3[index].querySelector('.element-value').classList.remove('wiggle-current');
                        interleaveStep(index + 1);
                    }, 1000);
                }
                
                interleaveStep(0);
                break;
                
            case 3:
                // Step 4: Verify wiggle property
                explanation.innerHTML = "Step 4: Verifying wiggle property";
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 4:</strong> Checking wiggle condition: nums[0] < nums[1] > nums[2] < nums[3]...
                    </div>
                `;
                
                const finalArray = [...array];
                const mid3 = Math.floor((n + 1) / 2);
                const smaller3 = finalArray.slice(0, mid3);
                const larger3 = finalArray.slice(mid3);
                
                // Reconstruct with wiggle pattern
                for (let i = 0; i < n; i++) {
                    if (i % 2 === 0) {
                        finalArray[i] = smaller3[Math.floor(smaller3.length - 1 - i/2)];
                    } else {
                        finalArray[i] = larger3[Math.floor(larger3.length - 1 - (i-1)/2)];
                    }
                }
                
                renderArrayInContainer(finalArray, 'transformedWiggleArray');
                
                // Verify and highlight
                function verifyStep(i) {
                    if (i >= n - 1) {
                        // Verification completed
                        explanation.innerHTML = `<strong>Wiggle Sort II Completed!</strong> Array satisfies wiggle condition.`;
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Final:</strong> Wiggle Sort II completed successfully!
                            </div>
                        `;
                        
                        continueButton.style.display = 'block';
                        
                        // Auto-return after 5 seconds
                        setTimeout(() => {
                            returnToOriginalAfterWiggle();
                        }, 5000);
                        
                        continueButton.addEventListener('click', returnToOriginalAfterWiggle);
                        
                        return;
                    }
                    
                    const elements4 = transformedContainer.querySelectorAll('.array-element');
                    const current = finalArray[i];
                    const next = finalArray[i + 1];
                    
                    // Highlight current pair
                    elements4[i].querySelector('.element-value').classList.add('wiggle-current');
                    elements4[i + 1].querySelector('.element-value').classList.add('wiggle-compared');
                    
                    if (i % 2 === 0) {
                        // Even index: should be < next
                        if (current < next) {
                            explanation.innerHTML = ` Position ${i} < ${i+1}: ${current} < ${next} `;
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step active">
                                    <strong>Check ${i}:</strong> ${current} < ${next}  CORRECT
                                </div>
                            `;
                            elements4[i].querySelector('.element-value').classList.add('wiggle-correct');
                            elements4[i + 1].querySelector('.element-value').classList.add('wiggle-correct');
                        } else {
                            explanation.innerHTML = ` Position ${i} < ${i+1}: ${current} >= ${next} `;
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step active">
                                    <strong>Check ${i}:</strong> ${current} >= ${next}  INCORRECT
                                </div>
                            `;
                            elements4[i].querySelector('.element-value').classList.add('wiggle-incorrect');
                            elements4[i + 1].querySelector('.element-value').classList.add('wiggle-incorrect');
                        }
                    } else {
                        // Odd index: should be > next
                        if (current > next) {
                            explanation.innerHTML = ` Position ${i} > ${i+1}: ${current} > ${next} `;
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step active">
                                    <strong>Check ${i}:</strong> ${current} > ${next}  CORRECT
                                </div>
                            `;
                            elements4[i].querySelector('.element-value').classList.add('wiggle-correct');
                            elements4[i + 1].querySelector('.element-value').classList.add('wiggle-correct');
                        } else {
                            explanation.innerHTML = ` Position ${i} > ${i+1}: ${current} <= ${next} `;
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step active">
                                    <strong>Check ${i}:</strong> ${current} <= ${next}  INCORRECT
                                </div>
                            `;
                            elements4[i].querySelector('.element-value').classList.add('wiggle-incorrect');
                            elements4[i + 1].querySelector('.element-value').classList.add('wiggle-incorrect');
                        }
                    }
                    
                    setTimeout(() => {
                        elements4[i].querySelector('.element-value').classList.remove('wiggle-current', 'wiggle-correct', 'wiggle-incorrect');
                        elements4[i + 1].querySelector('.element-value').classList.remove('wiggle-compared', 'wiggle-correct', 'wiggle-incorrect');
                        verifyStep(i + 1);
                    }, 1500);
                }
                
                verifyStep(0);
                break;
        }
    }
    
    // Start wiggle sort process
    performWiggleStep();
}
// NEW: Return to Original after Wiggle Sort
function returnToOriginalAfterWiggle() {
    // Reset to original array
    myArray = [...originalArrayForWiggle];
    originalArrayForWiggle = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isWiggleSortRunning = false;
    
    logOperation('Wiggle Sort II completed - returned to original array', 'info');
    showNotification('Returned to original array after Wiggle Sort II', 'success');
}
// NEW: Maximum Distance Between Same Elements Handler
function handleMaxDistanceSameElements() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isMaxDistanceRunning) {
        showNotification('Maximum distance operation is already in progress', 'warning');
        return;
    }
    
    if (myArray.length < 2) {
        showNotification('Array must have at least 2 elements', 'warning');
        return;
    }
    
    isMaxDistanceRunning = true;
    
    // Store original array
    originalArrayForMaxDistance = [...myArray];
    
    // Show maximum distance visualization
    showMaxDistanceVisualization();
}
// NEW: Show Maximum Distance Visualization
function showMaxDistanceVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Maximum Distance Between Same Elements</h5>
        
        <div class="array-group">
            <div class="array-label">Array</div>
            <div class="original-array-container" id="maxDistanceArray"></div>
        </div>
        
        <div class="max-distance-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find maximum distance (j-i) where arr[i] == arr[j] and i < j</p>
            <p class="mb-0" id="maxDistanceExplanation">Initializing algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="maxDistanceStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="maxDistanceSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Maximum Distance Found</div>
            <div class="stats-value" id="maxDistanceValue">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Element with Max Distance</div>
            <div class="stats-value" id="maxDistanceElement">-</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Indices (i, j)</div>
            <div class="stats-value" id="maxDistanceIndices">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMaxDistance" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForMaxDistance, 'maxDistanceArray');
    
    performMaxDistanceAlgorithm();
}
// NEW: Perform Maximum Distance Algorithm with Animation
function performMaxDistanceAlgorithm() {
    const arrayContainer = document.getElementById('maxDistanceArray');
    const explanation = document.getElementById('maxDistanceExplanation');
    const stepsContainer = document.getElementById('maxDistanceSteps');
    const maxDistanceValue = document.getElementById('maxDistanceValue');
    const maxDistanceElement = document.getElementById('maxDistanceElement');
    const maxDistanceIndices = document.getElementById('maxDistanceIndices');
    const continueButton = document.getElementById('continueAfterMaxDistance');
    
    const arr = [...originalArrayForMaxDistance];
    let maxDistance = -1;
    let maxElement = null;
    let maxI = -1;
    let maxJ = -1;
    let step = 0;
    
    // Create a map to store first occurrence of each element
    const firstOccurrence = new Map();
    
    function executeStep(i) {
        if (i >= arr.length) {
            // Algorithm completed
            if (maxDistance === -1) {
                explanation.innerHTML = `<strong>Algorithm Completed!</strong> No duplicate elements found.`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Final:</strong> No duplicate elements found in the array
                    </div>
                `;
            } else {
                explanation.innerHTML = `<strong>Algorithm Completed!</strong> Maximum distance found for element "${maxElement}"`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Maximum distance = ${maxDistance} for element "${maxElement}" at indices (${maxI}, ${maxJ})
                    </div>
                `;
                
                // Highlight the pair with maximum distance
                const elements = arrayContainer.querySelectorAll('.array-element');
                elements[maxI].querySelector('.element-value').classList.add('max-distance-pair');
                elements[maxJ].querySelector('.element-value').classList.add('max-distance-pair');
                
                maxDistanceValue.textContent = maxDistance;
                maxDistanceElement.textContent = maxElement;
                maxDistanceIndices.textContent = `(${maxI}, ${maxJ})`;
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterMaxDistance();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterMaxDistance);
            
            return;
        }
        
        const currentElement = arr[i];
        step++;
        
        explanation.innerHTML = `Step ${step}: Processing element at index ${i} = "${currentElement}"`;
        
        // Highlight current element
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElementDiv = elements[i].querySelector('.element-value');
        currentElementDiv.classList.add('max-distance-current');
        
        setTimeout(() => {
            if (firstOccurrence.has(currentElement)) {
                const firstIndex = firstOccurrence.get(currentElement);
                const currentDistance = i - firstIndex;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step ${currentDistance > maxDistance ? 'active' : ''}">
                        <strong>Step ${step}:</strong> Found duplicate of "${currentElement}" at index ${i}. 
                        First occurrence at ${firstIndex}. Distance = ${currentDistance}
                        ${currentDistance > maxDistance ? ' (NEW MAXIMUM!)' : ''}
                    </div>
                `;
                
                // Highlight both occurrences
                const firstElementDiv = elements[firstIndex].querySelector('.element-value');
                firstElementDiv.classList.add('max-distance-checked');
                
                if (currentDistance > maxDistance) {
                    // Update maximum distance
                    maxDistance = currentDistance;
                    maxElement = currentElement;
                    maxI = firstIndex;
                    maxJ = i;
                    
                    // Highlight the new maximum pair
                    firstElementDiv.classList.add('max-distance-pair');
                    currentElementDiv.classList.add('max-distance-pair');
                    
                    explanation.innerHTML = `Step ${step}: New maximum distance found! ${currentDistance} for element "${currentElement}"`;
                }
                
            } else {
                // First occurrence of this element
                firstOccurrence.set(currentElement, i);
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${step}:</strong> First occurrence of "${currentElement}" at index ${i}
                    </div>
                `;
                
                currentElementDiv.classList.add('max-distance-checked');
            }
            
            // Scroll steps container to bottom
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            // Update statistics
            if (maxDistance !== -1) {
                maxDistanceValue.textContent = maxDistance;
                maxDistanceElement.textContent = maxElement;
                maxDistanceIndices.textContent = maxI !== -1 ? `(${maxI}, ${maxJ})` : '-';
            }
            
            // Remove current highlight and move to next element
            currentElementDiv.classList.remove('max-distance-current');
            
            // Continue with next element
            executeStep(i + 1);
        }, 1500);
    }
    
    // Start algorithm execution
    executeStep(0);
}
// NEW: Return to Original after Maximum Distance Operation
function returnToOriginalAfterMaxDistance() {
    // Reset to original array
    myArray = [...originalArrayForMaxDistance];
    originalArrayForMaxDistance = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMaxDistanceRunning = false;
    
    logOperation('Maximum distance between same elements operation completed', 'info');
    showNotification('Returned to original array after maximum distance operation', 'success');
}
// NEW: Count Pairs with Difference K Handler
function handleCountPairsWithDifference() {
    const k = parseInt(pairDifferenceK.value);
    
    if (isNaN(k) || k < 0) {
        showNotification('Please enter a valid non-negative K value', 'danger');
        pairDifferenceK.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Count pairs operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    if (isCountPairsRunning) {
        showNotification('Count pairs operation is already in progress', 'warning');
        return;
    }
    
    isCountPairsRunning = true;
    
    // Store original array
    originalArrayForPairs = [...myArray];
    
    // Perform count pairs visualization
    performCountPairsWithDifference(k);
}
// NEW: Perform Count Pairs with Difference K Visualization
function performCountPairsWithDifference(k) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Count Pairs with Difference K (K = ${k})</h5>
        
        <div class="array-group">
            <div class="array-label">Array</div>
            <div class="original-array-container" id="pairsArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Count unique pairs (i,j) where |arr[i]-arr[j]| = ${k} and i < j</p>
            <p class="mb-0" id="pairsExplanation">Initializing pairs counting algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="pairsStepsContainer">
            <h6 class="text-center">Pairs Counting Steps</h6>
            <div class="steps-container" id="pairsSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Total Pairs Found</div>
            <div class="stats-value" id="totalPairsCount">0</div>
        </div>
        
        <div class="pairs-results mt-3" id="pairsResults" style="display: none;">
            <h6>Found Pairs</h6>
            <div id="pairsList"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPairs" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForPairs, 'pairsArray');
    
    executeCountPairsAlgorithm(k);
}
// NEW: Execute Count Pairs Algorithm with Animation
function executeCountPairsAlgorithm(k) {
    const arrayContainer = document.getElementById('pairsArray');
    const explanation = document.getElementById('pairsExplanation');
    const stepsContainer = document.getElementById('pairsSteps');
    const totalPairsCount = document.getElementById('totalPairsCount');
    const pairsResults = document.getElementById('pairsResults');
    const pairsList = document.getElementById('pairsList');
    const continueButton = document.getElementById('continueAfterPairs');
    
    const arr = originalArrayForPairs.map(val => parseFloat(val));
    const n = arr.length;
    let pairs = [];
    let totalPairs = 0;
    let step = 0;
    let i = 0, j = 1;
    
    function executePairsStep() {
        if (i >= n - 1) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Found ${totalPairs} unique pairs with difference ${k}.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Total pairs found = ${totalPairs}
                </div>
            `;
            
            // Show all found pairs
            if (totalPairs > 0) {
                pairsResults.style.display = 'block';
                pairsList.innerHTML = '';
                pairs.forEach(pair => {
                    const pairElement = document.createElement('div');
                    pairElement.className = 'pair-item';
                    pairElement.textContent = `(${pair.i},${pair.j})  |${arr[pair.i]}-${arr[pair.j]}|=${k}`;
                    pairsList.appendChild(pairElement);
                });
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterPairs();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterPairs);
            
            return;
        }
        
        if (j >= n) {
            // Move to next i
            i++;
            j = i + 1;
            executePairsStep();
            return;
        }
        
        step++;
        explanation.innerHTML = `Step ${step}: Checking pair (${i},${j})  |${arr[i]}-${arr[j]}| = ${Math.abs(arr[i] - arr[j])}`;
        
        // Highlight current elements being checked
        const elements = arrayContainer.querySelectorAll('.array-element');
        const elementI = elements[i].querySelector('.element-value');
        const elementJ = elements[j].querySelector('.element-value');
        
        elementI.classList.add('pair-current');
        elementJ.classList.add('pair-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Checking pair (${i},${j})  |${arr[i]}-${arr[j]}| = ${Math.abs(arr[i] - arr[j])}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            const difference = Math.abs(arr[i] - arr[j]);
            
            if (difference === k) {
                // Found a valid pair
                explanation.innerHTML = `Step ${step}: FOUND PAIR! (${i},${j})  |${arr[i]}-${arr[j]}| = ${k}`;
                
                elementI.classList.remove('pair-current');
                elementJ.classList.remove('pair-current');
                elementI.classList.add('pair-match');
                elementJ.classList.add('pair-match');
                
                // Add to pairs list
                pairs.push({ i, j });
                totalPairs++;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong> MATCH:</strong> Pair (${i},${j})  |${arr[i]}-${arr[j]}| = ${k} 
                    </div>
                `;
                
                totalPairsCount.textContent = totalPairs;
                
                setTimeout(() => {
                    elementI.classList.remove('pair-match');
                    elementJ.classList.remove('pair-match');
                    elementI.classList.add('pair-element');
                    elementJ.classList.add('pair-element');
                    
                    j++;
                    executePairsStep();
                }, 1500);
                
            } else {
                // No match
                elementI.classList.remove('pair-current');
                elementJ.classList.remove('pair-current');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>No match:</strong> Difference ${difference}  ${k}
                    </div>
                `;
                
                j++;
                executePairsStep();
            }
        }, 1000);
    }
    
    // Start algorithm execution
    executePairsStep();
}
// NEW: Return to Original after Pairs Operation
function returnToOriginalAfterPairs() {
    // Reset to original array
    myArray = [...originalArrayForPairs];
    originalArrayForPairs = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isCountPairsRunning = false;
    
    // Clear input
    pairDifferenceK.value = '';
    
    logOperation('Count pairs with difference K completed - returned to original array', 'info');
    showNotification('Returned to original array after pairs counting operation', 'success');
}
// NEW: Minimum Swaps to Bring Elements  K Handler
function handleMinSwaps() {
    const k = parseInt(minSwapsK.value);
    
    if (isNaN(k)) {
        showNotification('Please enter a valid K value', 'danger');
        minSwapsK.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Minimum swaps operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    if (isMinSwapsRunning) {
        showNotification('Minimum swaps operation is already in progress', 'warning');
        return;
    }
    
    isMinSwapsRunning = true;
    
    // Store original array
    originalArrayForMinSwaps = [...myArray];
    
    // Perform minimum swaps visualization
    performMinSwapsVisualization(k);
}
// NEW: Perform Minimum Swaps Visualization
function performMinSwapsVisualization(k) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Minimum Swaps to Bring Elements  ${k} Together</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="minSwapsArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find minimum swaps to group all elements  ${k} together</p>
            <p class="mb-0" id="minSwapsExplanation">Initializing minimum swaps algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="minSwapsStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="minSwapsSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Elements  ${k} Count</div>
            <div class="stats-value" id="validElementsCount">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Minimum Swaps Required</div>
            <div class="stats-value" id="minSwapsRequired">0</div>
        </div>
        
        <div class="swaps-results mt-3" id="swapsResults" style="display: none;">
            <h6>Swap Operations</h6>
            <div id="swapsList"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMinSwaps" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForMinSwaps, 'minSwapsArray');
    
    executeMinSwapsAlgorithm(k);
}
// NEW: Execute Minimum Swaps Algorithm with Animation
function executeMinSwapsAlgorithm(k) {
    const arrayContainer = document.getElementById('minSwapsArray');
    const explanation = document.getElementById('minSwapsExplanation');
    const stepsContainer = document.getElementById('minSwapsSteps');
    const validElementsCount = document.getElementById('validElementsCount');
    const minSwapsRequired = document.getElementById('minSwapsRequired');
    const swapsResults = document.getElementById('swapsResults');
    const swapsList = document.getElementById('swapsList');
    const continueButton = document.getElementById('continueAfterMinSwaps');
    
    const arr = originalArrayForMinSwaps.map(val => parseFloat(val));
    const n = arr.length;
    
    // Step 1: Count elements <= k
    let validCount = 0;
    let step = 0;
    let swaps = [];
    
    function executeAlgorithmStep() {
        switch (step) {
            case 0:
                // Step 1: Count valid elements and highlight them
                explanation.innerHTML = `Step 1: Counting elements  ${k}`;
                
                countValidElements();
                break;
                
            case 1:
                // Step 2: If no valid elements or all valid, no swaps needed
                if (validCount === 0 || validCount === n) {
                    explanation.innerHTML = validCount === 0 ? 
                        `No elements  ${k} found. Minimum swaps = 0` : 
                        `All elements are  ${k}. Minimum swaps = 0`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Result:</strong> Minimum swaps required = 0
                        </div>
                    `;
                    
                    minSwapsRequired.textContent = '0';
                    completeAlgorithm();
                    return;
                }
                
                explanation.innerHTML = `Step 2: Found ${validCount} elements  ${k}. Using sliding window of size ${validCount}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Window size = ${validCount} (number of elements  ${k})
                    </div>
                `;
                
                step++;
                setTimeout(executeAlgorithmStep, 2000);
                break;
                
            case 2:
                // Step 3: Find window with maximum valid elements
                explanation.innerHTML = `Step 3: Finding window with maximum valid elements`;
                findOptimalWindow();
                break;
                
            case 3:
                // Step 4: Calculate and perform minimum swaps
                explanation.innerHTML = `Step 4: Calculating minimum swaps required`;
                calculateMinimumSwaps();
                break;
        }
    }
    
    function countValidElements() {
        let currentIndex = 0;
        
        function countNextElement() {
            if (currentIndex >= n) {
                // Counting completed
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1 Complete:</strong> Found ${validCount} elements  ${k}
                    </div>
                `;
                
                validElementsCount.textContent = validCount;
                step++;
                setTimeout(executeAlgorithmStep, 1500);
                return;
            }
            
            const elements = arrayContainer.querySelectorAll('.array-element');
            const currentElement = elements[currentIndex].querySelector('.element-value');
            
            if (arr[currentIndex] <= k) {
                validCount++;
                currentElement.classList.add('valid-element');
                explanation.innerHTML = `Counting: [${currentIndex}] = ${arr[currentIndex]}  ${k}  (Count: ${validCount})`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Element ${currentIndex}:</strong> ${arr[currentIndex]}  ${k}  (Valid)
                    </div>
                `;
            } else {
                currentElement.classList.add('invalid-element');
                explanation.innerHTML = `Counting: [${currentIndex}] = ${arr[currentIndex]} > ${k}  (Count: ${validCount})`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Element ${currentIndex}:</strong> ${arr[currentIndex]} > ${k}  (Invalid)
                    </div>
                `;
            }
            
            // Scroll steps container
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            currentIndex++;
            setTimeout(countNextElement, 800);
        }
        
        countNextElement();
    }
    
    function findOptimalWindow() {
        let maxValidInWindow = 0;
        let currentValid = 0;
        
        // Count valid elements in first window
        for (let i = 0; i < validCount; i++) {
            if (arr[i] <= k) currentValid++;
        }
        
        maxValidInWindow = currentValid;
        let bestWindowStart = 0;
        
        let left = 0;
        let right = validCount - 1;
        
        function slideWindow() {
            if (right >= n - 1) {
                // Window sliding completed
                explanation.innerHTML = `Best window found at [${bestWindowStart}-${bestWindowStart + validCount - 1}] with ${maxValidInWindow} valid elements`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3 Complete:</strong> Best window has ${maxValidInWindow} valid elements
                    </div>
                `;
                
                // Highlight the best window
                const elements = arrayContainer.querySelectorAll('.array-element');
                for (let i = bestWindowStart; i < bestWindowStart + validCount; i++) {
                    elements[i].querySelector('.element-value').classList.add('window-boundary');
                }
                
                step++;
                setTimeout(executeAlgorithmStep, 2000);
                return;
            }
            
            // Move window right
            if (arr[left] <= k) currentValid--;
            left++;
            right++;
            if (arr[right] <= k) currentValid++;
            
            if (currentValid > maxValidInWindow) {
                maxValidInWindow = currentValid;
                bestWindowStart = left;
            }
            
            explanation.innerHTML = `Window [${left}-${right}]: ${currentValid} valid elements (Max: ${maxValidInWindow})`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Window [${left}-${right}]:</strong> ${currentValid} valid elements
                </div>
            `;
            
            // Highlight current window
            const elements = arrayContainer.querySelectorAll('.array-element');
            
            // Remove previous window highlights
            elements.forEach(el => {
                el.querySelector('.element-value').classList.remove('window-boundary');
            });
            
            // Add current window highlight
            for (let i = left; i <= right; i++) {
                elements[i].querySelector('.element-value').classList.add('window-boundary');
            }
            
            // Scroll steps container
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            setTimeout(slideWindow, 1200);
        }
        
        // Highlight initial window
        const elements = arrayContainer.querySelectorAll('.array-element');
        for (let i = 0; i < validCount; i++) {
            elements[i].querySelector('.element-value').classList.add('window-boundary');
        }
        
        explanation.innerHTML = `Initial window [0-${validCount - 1}]: ${currentValid} valid elements`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Initial Window:</strong> [0-${validCount - 1}] has ${currentValid} valid elements
            </div>
        `;
        
        setTimeout(slideWindow, 1500);
    }
    
    function calculateMinimumSwaps() {
        // Calculate minimum swaps = total valid elements - max valid elements in any window
        let maxValidInWindow = 0;
        let currentValid = 0;
        
        // Find maximum valid elements in any window of size validCount
        for (let i = 0; i < validCount; i++) {
            if (arr[i] <= k) currentValid++;
        }
        maxValidInWindow = currentValid;
        
        for (let i = validCount; i < n; i++) {
            if (arr[i - validCount] <= k) currentValid--;
            if (arr[i] <= k) currentValid++;
            if (currentValid > maxValidInWindow) {
                maxValidInWindow = currentValid;
            }
        }
        
        const minSwaps = validCount - maxValidInWindow;
        
        explanation.innerHTML = `Minimum swaps = ${validCount} (total valid) - ${maxValidInWindow} (max in window) = ${minSwaps}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Calculation:</strong> ${validCount} - ${maxValidInWindow} = ${minSwaps} swaps needed
            </div>
        `;
        
        minSwapsRequired.textContent = minSwaps;
        
        // Show swap operations explanation
        if (minSwaps > 0) {
            swapsResults.style.display = 'block';
            swapsList.innerHTML = `
                <div class="swap-operation">
                    We need to swap ${minSwaps} invalid elements from the optimal window with valid elements outside
                </div>
                <div class="swap-operation">
                    Each swap replaces one invalid element inside with one valid element outside
                </div>
                <div class="swap-operation">
                    Total swaps required: ${minSwaps}
                </div>
            `;
        }
        
        completeAlgorithm();
    }
    
    function completeAlgorithm() {
        explanation.innerHTML = `<strong>Algorithm Completed!</strong> Minimum swaps required = ${minSwapsRequired.textContent}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Final Result:</strong> Minimum swaps to group elements  ${k} = ${minSwapsRequired.textContent}
            </div>
        `;
        
        continueButton.style.display = 'block';
        
        // Auto-return after 30 seconds
        setTimeout(() => {
            returnToOriginalAfterMinSwaps();
        }, 30000);
        
        continueButton.addEventListener('click', returnToOriginalAfterMinSwaps);
    }
    
    // Start algorithm execution
    executeAlgorithmStep();
}
// NEW: Return to Original after Minimum Swaps Operation
function returnToOriginalAfterMinSwaps() {
    // Reset to original array
    myArray = [...originalArrayForMinSwaps];
    originalArrayForMinSwaps = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMinSwapsRunning = false;
    
    // Clear input
    minSwapsK.value = '';
    
    logOperation('Minimum swaps operation completed - returned to original array', 'info');
    showNotification('Returned to original array after minimum swaps operation', 'success');
}
// NEW: Find Missing and Repeating Number Handler
function handleFindMissingRepeating() {
    console.log('handleFindMissingRepeating called');
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isMissingRepeatingRunning) {
        showNotification('Missing/Repeating operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains only numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseInt(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('This operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Convert array to numbers
    const numArray = myArray.map(val => parseInt(val));
    
    // Check if array contains numbers from 1 to n (with one missing and one duplicate)
    const n = numArray.length;
    const expectedSum = n * (n + 1) / 2;
    const actualSum = numArray.reduce((sum, val) => sum + val, 0);
    
    // This is a simple check - in real scenario we'd need more validation
    if (Math.abs(actualSum - expectedSum) > n) {
        showNotification('Array may not follow the pattern of numbers 1 to n with one missing and one repeated', 'warning');
    }
    
    const method = missingRepeatingMethod.value;
    console.log('Selected method:', method);
    isMissingRepeatingRunning = true;
    
    // Store original array
    originalArrayForMissingRepeating = [...myArray];
    console.log('Original array stored:', originalArrayForMissingRepeating);
    
    // Show visualization based on selected method
    if (method === 'math') {
        console.log('Calling showMathMethodVisualization');
        showMathMethodVisualization(numArray);
    } else {
        console.log('Calling showXORMethodVisualization');
        showXORMethodVisualization(numArray);
    }
}

// NEW: Show Math Method Visualization
function showMathMethodVisualization(numArray) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find Missing & Repeating (Math Method)</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalMathArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Math Method:</strong> Using sum and sum of squares to find missing and repeating numbers</p>
            <p class="mb-0" id="mathExplanation">Initializing math method calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="mathStepsContainer">
            <h6 class="text-center">Math Method Steps</h6>
            <div class="steps-container" id="mathSteps"></div>
        </div>
        
        <div class="missing-repeating-results" id="mathResults" style="display: none;">
            <h6 class="text-center">Results</h6>
            <div class="stats-card">
                <div>Repeating Number</div>
                <div class="stats-value" id="repeatingNumber">-</div>
            </div>
            <div class="stats-card">
                <div>Missing Number</div>
                <div class="stats-value" id="missingNumber">-</div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMath" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForMissingRepeating, 'originalMathArray');
    
    performMathMethodAnimation(numArray);
}

// NEW: Perform Math Method Animation
function performMathMethodAnimation(numArray) {
    const arrayContainer = document.getElementById('originalMathArray');
    const explanation = document.getElementById('mathExplanation');
    const stepsContainer = document.getElementById('mathSteps');
    const resultsDiv = document.getElementById('mathResults');
    const repeatingNumberDiv = document.getElementById('repeatingNumber');
    const missingNumberDiv = document.getElementById('missingNumber');
    const continueButton = document.getElementById('continueAfterMath');
    
    const n = numArray.length;
    let step = 0;
    
    // Define variables at function scope to avoid block scoping issues
    let expectedSum, actualSum, sumDiff;
    let expectedSumSq, actualSumSq, sumSqDiff;
    let expectedSumFinal, actualSumFinal, sumDiffFinal;
    let expectedSumSqFinal, actualSumSqFinal, sumSqDiffFinal;
    let sumXY, x, y;
    let repeating, missing;
    
    // Define cleanup function locally to ensure it's accessible
    const cleanupMathOperation = () => {
        console.log('Cleanup function called for Math method');
        
        // Reset to original array
        myArray = [...originalArrayForMissingRepeating];
        originalArrayForMissingRepeating = [];
        
        // Remove visualization and return to normal view
        const mainContainer = document.getElementById('arrayContainer');
        if (mainContainer) {
            mainContainer.innerHTML = '';
            renderArray();
            updateStats();
        }
        
        // Reset state
        isMissingRepeatingRunning = false;
        
        logOperation('Missing/Repeating operation completed - returned to original array', 'info');
        showNotification('Returned to original array after missing/repeating operation', 'success');
    };
    
    function performMathStep() {
        console.log('Math step:', step);
        
        switch (step) {
            case 0:
                // Step 1: Calculate expected sum
                explanation.innerHTML = 'Step 1: Calculate expected sum of numbers 1 to n';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Expected sum = n(n+1)/2 = ${n}${n+1}/2 = ${n*(n+1)/2}
                    </div>
                `;
                break;
                
            case 1:
                // Step 2: Calculate actual sum
                explanation.innerHTML = 'Step 2: Calculate actual sum of array elements';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> Actual sum = ${numArray.join(' + ')} = ${numArray.reduce((a, b) => a + b, 0)}
                    </div>
                `;
                
                // Highlight all elements while calculating sum
                const elements = arrayContainer.querySelectorAll('.array-element');
                elements.forEach((el, index) => {
                    setTimeout(() => {
                        el.querySelector('.element-value').classList.add('window-included');
                    }, index * 200);
                });
                break;
                
            case 2:
                // Step 3: Calculate difference
                expectedSum = n * (n + 1) / 2;
                actualSum = numArray.reduce((a, b) => a + b, 0);
                sumDiff = actualSum - expectedSum;
                
                explanation.innerHTML = `Step 3: Calculate difference between actual and expected sums`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Difference = Actual sum - Expected sum = ${actualSum} - ${expectedSum} = ${sumDiff}
                    </div>
                `;
                break;
                
            case 3:
                // Step 4: Calculate sum of squares
                explanation.innerHTML = 'Step 4: Calculate expected and actual sum of squares';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 4:</strong> Calculating sum of squares...
                    </div>
                `;
                break;
                
            case 4:
                // Step 5: Show sum of squares results
                expectedSumSq = n * (n + 1) * (2 * n + 1) / 6;
                actualSumSq = numArray.reduce((a, b) => a + b * b, 0);
                sumSqDiff = actualSumSq - expectedSumSq;
                
                explanation.innerHTML = 'Step 5: Calculate difference between sum of squares';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 5:</strong> Sum of squares difference = ${actualSumSq} - ${expectedSumSq} = ${sumSqDiff}
                    </div>
                `;
                break;
                
            case 5:
                // Step 6: Solve equations
                expectedSumFinal = n * (n + 1) / 2;
                actualSumFinal = numArray.reduce((a, b) => a + b, 0);
                sumDiffFinal = actualSumFinal - expectedSumFinal;
                
                expectedSumSqFinal = n * (n + 1) * (2 * n + 1) / 6;
                actualSumSqFinal = numArray.reduce((a, b) => a + b * b, 0);
                sumSqDiffFinal = actualSumSqFinal - expectedSumSqFinal;
                
                // Solve: x - y = sumDiff, x - y = sumSqDiff
                // => (x-y)(x+y) = sumSqDiff => x+y = sumSqDiff/sumDiff
                sumXY = sumSqDiffFinal / sumDiffFinal;
                x = (sumDiffFinal + sumXY) / 2; // repeating
                y = (sumXY - sumDiffFinal) / 2; // missing
                
                explanation.innerHTML = 'Step 6: Solve equations to find missing and repeating numbers';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 6:</strong> 
                        Let x = repeating, y = missing<br>
                        x - y = ${sumDiffFinal}<br>
                        x + y = ${sumXY}<br>
                        Solving: x = ${x}, y = ${y}
                    </div>
                `;
                break;
                
            case 6:
                // Step 7: Show results
                repeating = Math.round((sumDiffFinal + (sumSqDiffFinal / sumDiffFinal)) / 2);
                missing = Math.round(((sumSqDiffFinal / sumDiffFinal) - sumDiffFinal) / 2);
                
                explanation.innerHTML = `<strong>Calculation Complete!</strong> Found missing and repeating numbers.`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final Result:</strong> 
                        Repeating number = ${repeating}, Missing number = ${missing}
                    </div>
                `;
                
                // Show results
                resultsDiv.style.display = 'block';
                repeatingNumberDiv.textContent = repeating;
                missingNumberDiv.textContent = missing;
                
                // Highlight the numbers in the array
                const allElements = arrayContainer.querySelectorAll('.array-element');
                allElements.forEach((el, index) => {
                    const value = parseInt(numArray[index]);
                    if (value === repeating) {
                        el.querySelector('.element-value').classList.add('repeating-number');
                    }
                });
                
                // Show missing number visualization
                setTimeout(() => {
                    try {
                        const missingElement = document.createElement('div');
                        missingElement.className = 'array-element';
                        missingElement.innerHTML = `
                            <div class="element-value missing-number">${missing}</div>
                            <div class="element-index">Missing</div>
                        `;
                        arrayContainer.appendChild(missingElement);
                        
                        // Set up the continue button with proper cleanup
                        if (continueButton) {
                            continueButton.style.display = 'block';
                            continueButton.onclick = cleanupMathOperation;
                        }
                        
                        // Auto-return after 3 seconds (shorter time for testing)
                        console.log('Setting auto-return timeout for Math method');
                        setTimeout(() => {
                            console.log('Auto-return timeout triggered for Math method');
                            cleanupMathOperation();
                        }, 3000);
                    } catch (error) {
                        console.error('Error in final step:', error);
                        // If anything fails, still try to cleanup
                        cleanupMathOperation();
                    }
                }, 1000);
                return;
        }
        
        step++;
        setTimeout(performMathStep, 2000);
    }
    
    // Start math method process
    performMathStep();
}
// NEW: Show XOR Method Visualization
function showXORMethodVisualization(numArray) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find Missing & Repeating (XOR Method)</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalXORArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>XOR Method:</strong> Using bit manipulation to find missing and repeating numbers</p>
            <p class="mb-0" id="xorExplanation">Initializing XOR method calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="xorStepsContainer">
            <h6 class="text-center">XOR Method Steps</h6>
            <div class="steps-container" id="xorSteps"></div>
        </div>
        
        <div class="missing-repeating-results" id="xorResults" style="display: none;">
            <h6 class="text-center">Results</h6>
            <div class="stats-card">
                <div>Repeating Number</div>
                <div class="stats-value" id="xorRepeatingNumber">-</div>
            </div>
            <div class="stats-card">
                <div>Missing Number</div>
                <div class="stats-value" id="xorMissingNumber">-</div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterXOR" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForMissingRepeating, 'originalXORArray');
    
    performXORMethodAnimation(numArray);
}

// NEW: Perform XOR Method Animation
function performXORMethodAnimation(numArray) {
    const arrayContainer = document.getElementById('originalXORArray');
    const explanation = document.getElementById('xorExplanation');
    const stepsContainer = document.getElementById('xorSteps');
    const resultsDiv = document.getElementById('xorResults');
    const repeatingNumberDiv = document.getElementById('xorRepeatingNumber');
    const missingNumberDiv = document.getElementById('xorMissingNumber');
    const continueButton = document.getElementById('continueAfterXOR');
    
    const n = numArray.length;
    let step = 0;
    
    // Define cleanup function locally to ensure it's accessible
    const cleanupXOROperation = () => {
        // Reset to original array
        myArray = [...originalArrayForMissingRepeating];
        originalArrayForMissingRepeating = [];
        
        // Remove visualization and return to normal view
        const mainContainer = document.getElementById('arrayContainer');
        mainContainer.innerHTML = '';
        renderArray();
        updateStats();
        
        // Reset state
        isMissingRepeatingRunning = false;
        
        logOperation('Missing/Repeating operation completed - returned to original array', 'info');
        showNotification('Returned to original array after missing/repeating operation', 'success');
    };
    
    function performXORStep() {
        switch (step) {
            case 0:
                // Step 1: XOR all array elements and numbers 1 to n
                explanation.innerHTML = 'Step 1: Calculate XOR of all array elements and numbers 1 to n';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> XOR = (arr[0] XOR arr[1] XOR ... XOR arr[n-1]) XOR (1 XOR 2 XOR ... XOR n)
                    </div>
                `;
                
                // Visualize XOR process
                let xorAll = 0;
                const elements = arrayContainer.querySelectorAll('.array-element');
                
                elements.forEach((el, index) => {
                    setTimeout(() => {
                        const value = numArray[index];
                        xorAll ^= value;
                        el.querySelector('.element-value').classList.add('window-included');
                        
                        // Also XOR with expected number (index + 1)
                        xorAll ^= (index + 1);
                    }, index * 300);
                });
                break;
                
            case 1:
                // Step 2: Find rightmost set bit
                const xorAllFinal = numArray.reduce((xor, val, idx) => xor ^ val ^ (idx + 1), 0);
                const rightmostSetBit = xorAllFinal & -xorAllFinal;
                
                explanation.innerHTML = 'Step 2: Find rightmost set bit in XOR result';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2:</strong> XOR result = ${xorAllFinal} (binary: ${xorAllFinal.toString(2)})<br>
                        Rightmost set bit = ${rightmostSetBit} (binary: ${rightmostSetBit.toString(2)})
                    </div>
                `;
                break;
                
            case 2:
                // Step 3: Separate numbers into two groups
                explanation.innerHTML = 'Step 3: Separate numbers based on rightmost set bit';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Dividing numbers into two groups based on the set bit
                    </div>
                `;
                break;
                
            case 3:
                // Step 4: Find repeating and missing numbers
                const xorFinal = numArray.reduce((xor, val, idx) => xor ^ val ^ (idx + 1), 0);
                const setBit = xorFinal & -xorFinal;
                
                let x = 0, y = 0;
                
                // Group 1: Numbers with the set bit
                for (let i = 0; i < n; i++) {
                    if (numArray[i] & setBit) {
                        x ^= numArray[i];
                    }
                    if ((i + 1) & setBit) {
                        x ^= (i + 1);
                    }
                }
                
                // Group 2: Numbers without the set bit
                for (let i = 0; i < n; i++) {
                    if (!(numArray[i] & setBit)) {
                        y ^= numArray[i];
                    }
                    if (!((i + 1) & setBit)) {
                        y ^= (i + 1);
                    }
                }
                
                // Determine which is repeating and which is missing
                let repeating, missing;
                if (numArray.includes(x)) {
                    repeating = x;
                    missing = y;
                } else {
                    repeating = y;
                    missing = x;
                }
                
                explanation.innerHTML = 'Step 4: Identify repeating and missing numbers';
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 4:</strong> 
                        Group 1 XOR = ${x}, Group 2 XOR = ${y}<br>
                        Repeating number = ${repeating}, Missing number = ${missing}
                    </div>
                `;
                break;
                
            case 4:
                // Step 5: Show final results
                const finalXOR = numArray.reduce((xor, val, idx) => xor ^ val ^ (idx + 1), 0);
                const finalSetBit = finalXOR & -finalXOR;
                let group1 = 0, group2 = 0;
                
                for (let i = 0; i < n; i++) {
                    if (numArray[i] & finalSetBit) {
                        group1 ^= numArray[i];
                    } else {
                        group2 ^= numArray[i];
                    }
                    if ((i + 1) & finalSetBit) {
                        group1 ^= (i + 1);
                    } else {
                        group2 ^= (i + 1);
                    }
                }
                
                const finalRepeating = numArray.includes(group1) ? group1 : group2;
                const finalMissing = numArray.includes(group1) ? group2 : group1;
                
                explanation.innerHTML = `<strong>XOR Method Complete!</strong> Found missing and repeating numbers.`;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final Result:</strong> 
                        Repeating number = ${finalRepeating}, Missing number = ${finalMissing}
                    </div>
                `;
                
                // Show results
                resultsDiv.style.display = 'block';
                repeatingNumberDiv.textContent = finalRepeating;
                missingNumberDiv.textContent = finalMissing;
                
                // Highlight the repeating number in the array
                const allElements = arrayContainer.querySelectorAll('.array-element');
                allElements.forEach((el, index) => {
                    const value = parseInt(numArray[index]);
                    if (value === finalRepeating) {
                        el.querySelector('.element-value').classList.add('repeating-number');
                    }
                });
                
                // Show missing number visualization
                setTimeout(() => {
                    const missingElement = document.createElement('div');
                    missingElement.className = 'array-element';
                    missingElement.innerHTML = `
                        <div class="element-value missing-number">${finalMissing}</div>
                        <div class="element-index">Missing</div>
                    `;
                    arrayContainer.appendChild(missingElement);
                    
                    // Set up the continue button with proper cleanup
                    continueButton.style.display = 'block';
                    continueButton.onclick = cleanupXOROperation;
                    
                    // Auto-return after 5 seconds
                    setTimeout(cleanupXOROperation, 5000);
                }, 1000);
                return;
        }
        
        step++;
        setTimeout(performXORStep, 2000);
    }
    
    // Start XOR method process
    performXORStep();
}

// NEW: Return to Original after Missing/Repeating Operation (Global fallback)
function returnToOriginalAfterMissingRepeating() {
    // Reset to original array
    myArray = [...originalArrayForMissingRepeating];
    originalArrayForMissingRepeating = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isMissingRepeatingRunning = false;
    
    logOperation('Missing/Repeating operation completed - returned to original array', 'info');
    showNotification('Returned to original array after missing/repeating operation', 'success');
}
// NEW: Find First Repeating Element Handler
function handleFindFirstRepeating() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isFirstRepeatingRunning) {
        showNotification('First repeating element search is already in progress', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - no repeating elements possible', 'info');
        return;
    }
    
    isFirstRepeatingRunning = true;
    
    // Store original array
    originalArrayForRepeating = [...myArray];
    
    // Show first repeating element visualization
    showFirstRepeatingVisualization();
}
// NEW: Show First Repeating Visualization
function showFirstRepeatingVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find First Repeating Element</h5>
        
        <div class="array-group">
            <div class="array-label">Array</div>
            <div class="original-array-container" id="repeatingArray"></div>
        </div>
        
        <div class="repeating-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find the first element that repeats in the array</p>
            <p class="mb-0" id="repeatingExplanation">Starting first repeating element search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="repeatingStepsContainer">
            <h6 class="text-center">Search Steps</h6>
            <div class="steps-container" id="repeatingSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>First Repeating Element</div>
            <div class="stats-value" id="firstRepeatingValue">Not found</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Found at Index</div>
            <div class="stats-value" id="firstRepeatingIndex">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterRepeating" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForRepeating, 'repeatingArray');
    
    performFirstRepeatingSearch();
}
// NEW: Perform First Repeating Search with Animation
function performFirstRepeatingSearch() {
    const arrayContainer = document.getElementById('repeatingArray');
    const explanation = document.getElementById('repeatingExplanation');
    const stepsContainer = document.getElementById('repeatingSteps');
    const firstRepeatingValue = document.getElementById('firstRepeatingValue');
    const firstRepeatingIndex = document.getElementById('firstRepeatingIndex');
    const continueButton = document.getElementById('continueAfterRepeating');
    
    const arr = [...originalArrayForRepeating];
    const seen = new Set();
    let firstRepeating = null;
    let firstRepeatingIdx = -1;
    let currentIndex = 0;
    
    function performSearchStep() {
        if (currentIndex >= arr.length) {
            // Search completed
            if (firstRepeating === null) {
                explanation.innerHTML = `<strong>Search Completed!</strong> No repeating elements found in the array.`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> No repeating elements found - all elements are unique
                    </div>
                `;
                
                firstRepeatingValue.textContent = "None";
                firstRepeatingIndex.textContent = "-";
                
            } else {
                explanation.innerHTML = `<strong>Search Completed!</strong> First repeating element found!`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> First repeating element is "${firstRepeating}" at index ${firstRepeatingIdx}
                    </div>
                `;
                
                firstRepeatingValue.textContent = firstRepeating;
                firstRepeatingIndex.textContent = firstRepeatingIdx.toString();
                
                // Highlight the first repeating element
                const elements = arrayContainer.querySelectorAll('.array-element');
                elements[firstRepeatingIdx].querySelector('.element-value').classList.add('repeating-element');
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterRepeating();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterRepeating);
            
            return;
        }
        
        const currentElement = arr[currentIndex];
        
        explanation.innerHTML = `Checking element at index ${currentIndex}: "${currentElement}"`;
        
        // Highlight current element being checked
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElementDiv = elements[currentIndex].querySelector('.element-value');
        currentElementDiv.classList.add('checked-repeating');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${currentIndex + 1}:</strong> Checking index ${currentIndex} = "${currentElement}"
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            if (seen.has(currentElement)) {
                // Found repeating element!
                explanation.innerHTML = `Found repeating element! "${currentElement}" was seen before.`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>FOUND:</strong> "${currentElement}" is repeating! First occurrence found at index ${currentIndex}
                    </div>
                `;
                
                firstRepeating = currentElement;
                firstRepeatingIdx = currentIndex;
                
                // Highlight as repeating element
                currentElementDiv.classList.remove('checked-repeating');
                currentElementDiv.classList.add('repeating-element');
                
                // Also highlight the first occurrence
                let firstOccurrenceIndex = -1;
                for (let i = 0; i < currentIndex; i++) {
                    if (arr[i] === currentElement) {
                        firstOccurrenceIndex = i;
                        break;
                    }
                }
                
                if (firstOccurrenceIndex !== -1) {
                    elements[firstOccurrenceIndex].querySelector('.element-value').classList.add('repeating-element');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>NOTE:</strong> First occurrence of "${currentElement}" was at index ${firstOccurrenceIndex}
                        </div>
                    `;
                }
                
                // Update results
                firstRepeatingValue.textContent = firstRepeating;
                firstRepeatingIndex.textContent = firstRepeatingIdx.toString();
                
                // Move to completion
                currentIndex = arr.length;
                performSearchStep();
                
            } else {
                // Not repeating, add to seen set
                seen.add(currentElement);
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Result:</strong> "${currentElement}" is new - added to seen elements
                    </div>
                `;
                
                // Change to non-repeating check style
                currentElementDiv.classList.remove('checked-repeating');
                currentElementDiv.classList.add('non-repeating-check');
                
                currentIndex++;
                performSearchStep();
            }
        }, 1500);
    }
    
    // Start search process
    performSearchStep();
}
// NEW: Return to Original after Repeating Search
function returnToOriginalAfterRepeating() {
    // Reset to original array
    myArray = [...originalArrayForRepeating];
    originalArrayForRepeating = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isFirstRepeatingRunning = false;
    
    logOperation('First repeating element search completed - returned to original array', 'info');
    showNotification('Returned to original array after repeating element search', 'success');
}
// NEW: Handle Conditional Operation
function handleConditionalOperation(operation) {
    if (isConditionalOperationRunning) {
        showNotification('A conditional operation is already in progress', 'warning');
        return;
    }

    currentConditionalOperation = operation;
    isConditionalOperationRunning = true;

    // Reset arrays
    array1 = [];
    array2 = [];
    array1Size = 0;
    array2Size = 0;

    // Show input group
    conditionalOperationsGroup.style.display = 'block';
    arraySizesGroup.style.display = 'block';
    arrayElementsGroup.style.display = 'none';
    conditionGroup.style.display = 'none';

    // Set appropriate labels based on operation
    let operationName = '';
    switch(operation) {
        case 'where':
            operationName = 'Conditional Select (Where)';
            arraySize2.placeholder = 'Size of Array Y';
            break;
        case 'select':
            operationName = 'Multi-Condition Select';
            arraySize2.placeholder = 'Size of Choice Arrays';
            break;
        case 'piecewise':
            operationName = 'Piecewise Evaluate';
            arraySize2.placeholder = 'Size of Function Array';
            break;
    }

    arraySize1.placeholder = 'Size of Array/Input';
    arraySize1.focus();

    logOperation(`Started ${operationName} operation`, 'info');
    showNotification(`Started ${operationName} operation. Please set array sizes.`, 'info');
}

// NEW: Confirm Array Sizes Handler
function handleConfirmArraySizes() {
    const size1 = parseInt(arraySize1.value);
    const size2 = parseInt(arraySize2.value);

    if (isNaN(size1) || size1 < 1 || size1 > 20) {
        showNotification('Please enter a valid size for Array 1 (1-20)', 'danger');
        arraySize1.focus();
        return;
    }

    if (isNaN(size2) || size2 < 1 || size2 > 20) {
        showNotification('Please enter a valid size for Array 2 (1-20)', 'danger');
        arraySize2.focus();
        return;
    }

    array1Size = size1;
    array2Size = size2;
    array1 = [];
    array2 = [];

    // Create input fields for arrays
    createArrayInputs();

    // Show array elements group and condition group
    arrayElementsGroup.style.display = 'block';
    conditionGroup.style.display = 'block';

    showNotification(`Array sizes set. Please enter ${size1 + size2} elements.`, 'success');
    logOperation(`Array sizes set: ${size1} and ${size2}`, 'info');
}

// NEW: Create Array Inputs
function createArrayInputs() {
    // Array 1 inputs
    array1Inputs.innerHTML = '<label class="form-label">Enter elements for Array 1:</label>';
    for (let i = 0; i < array1Size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="number" class="form-control array1-element" 
                   placeholder="Enter number" data-index="${i}" step="any">
        `;
        array1Inputs.appendChild(inputGroup);
    }

    // Array 2 inputs
    array2Inputs.innerHTML = '<label class="form-label">Enter elements for Array 2:</label>';
    for (let i = 0; i < array2Size; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group mb-2';
        inputGroup.innerHTML = `
            <span class="input-group-text">Element ${i}</span>
            <input type="number" class="form-control array2-element" 
                   placeholder="Enter number" data-index="${i}" step="any">
        `;
        array2Inputs.appendChild(inputGroup);
    }

    // Add event listeners for auto-focus
    const array1Elements = array1Inputs.querySelectorAll('.array1-element');
    const array2Elements = array2Inputs.querySelectorAll('.array2-element');
    
    array1Elements.forEach((input, index) => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = array1Elements[index + 1] || array2Elements[0];
                if (nextInput) nextInput.focus();
            }
        });
    });

    array2Elements.forEach((input, index) => {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const nextInput = array2Elements[index + 1];
                if (nextInput) nextInput.focus();
                else conditionValue.focus();
            }
        });
    });
}

// NEW: Confirm Condition Handler (Updated)
function handleConfirmCondition() {
    // Collect array 1 elements
    const array1Inputs = document.querySelectorAll('.array1-element');
    array1 = [];
    
    for (let i = 0; i < array1Inputs.length; i++) {
        const value = array1Inputs[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all elements for Array 1. Missing element at position ${i}`, 'danger');
            array1Inputs[i].focus();
            return;
        }
        array1.push(parseFloat(value));
    }

    // Collect array 2 elements
    const array2Inputs = document.querySelectorAll('.array2-element');
    array2 = [];
    
    for (let i = 0; i < array2Inputs.length; i++) {
        const value = array2Inputs[i].value.trim();
        if (value === '') {
            showNotification(`Please enter all elements for Array 2. Missing element at position ${i}`, 'danger');
            array2Inputs[i].focus();
            return;
        }
        array2.push(parseFloat(value));
    }

    const operator = conditionOperator.value;
    const value = parseFloat(conditionValue.value);

    if (isNaN(value)) {
        showNotification('Please enter a valid condition value', 'danger');
        conditionValue.focus();
        return;
    }

    // Store original array
    originalArrayForConditional = [...myArray];

    // Hide input group and clear inputs immediately
    conditionalOperationsGroup.style.display = 'none';
    arraySize1.value = '';
    arraySize2.value = '';
    conditionValue.value = '';
    array1Inputs.innerHTML = '';
    array2Inputs.innerHTML = '';

    // Execute the appropriate operation
    switch(currentConditionalOperation) {
        case 'where':
            performWhereOperation(array1, array2, operator, value);
            break;
        case 'select':
            performSelectOperation(array1, array2, operator, value);
            break;
        case 'piecewise':
            performPiecewiseOperation(array1, array2, operator, value);
            break;
    }
}
// NEW: Cancel Conditional Operation
function handleCancelConditional() {
    conditionalOperationsGroup.style.display = 'none';
    arraySize1.value = '';
    arraySize2.value = '';
    conditionValue.value = '';
    array1Inputs.innerHTML = '';
    array2Inputs.innerHTML = '';
    
    array1 = [];
    array2 = [];
    array1Size = 0;
    array2Size = 0;
    currentConditionalOperation = null;
    isConditionalOperationRunning = false;
    
    logOperation('Cancelled conditional operation', 'info');
    showNotification('Conditional operation cancelled', 'info');
}
// NEW: Perform Where Operation with Animation
function performWhereOperation(arr1, arr2, operator, conditionValue) {
    // Create visualization container
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Conditional Select (Where) Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Array X (True values)</div>
            <div class="original-array-container" id="arrayXDisplay"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Array Y (False values)</div>
            <div class="original-array-container" id="arrayYDisplay"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Condition: Array X ${operator} ${conditionValue}</div>
            <div class="original-array-container" id="conditionDisplay"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Result (np.where)</div>
            <div class="transformed-array-container" id="resultDisplay"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Where Operation:</strong> result[i] = X[i] if condition[i] else Y[i]</p>
            <p class="mb-0" id="whereExplanation">Starting where operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="whereStepsContainer">
            <h6 class="text-center">Where Operation Steps</h6>
            <div class="steps-container" id="whereSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterWhere" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display arrays
    renderArrayInContainer(arr1, 'arrayXDisplay');
    renderArrayInContainer(arr2, 'arrayYDisplay');
    
    // Calculate condition and result
    const condition = calculateCondition(arr1, operator, conditionValue);
    const result = [];
    for (let i = 0; i < arr1.length; i++) {
        result.push(condition[i] ? arr1[i] : arr2[i]);
    }
    
    renderArrayInContainer(condition.map(c => c ? 'True' : 'False'), 'conditionDisplay');
    renderArrayInContainer([...result], 'resultDisplay');
    
    // Animate the where operation
    animateWhereOperation(arr1, arr2, condition, result);
}

// NEW: Perform Select Operation with Animation
function performSelectOperation(inputArray, choicesArray, operator, conditionValue) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Multi-Condition Select Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Input Array</div>
            <div class="original-array-container" id="inputArrayDisplay"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Choices Array</div>
            <div class="original-array-container" id="choicesArrayDisplay"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Condition: Input ${operator} ${conditionValue}</div>
            <div class="original-array-container" id="selectConditionDisplay"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Result (np.select)</div>
            <div class="transformed-array-container" id="selectResultDisplay"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Select Operation:</strong> Choose from choices based on conditions</p>
            <p class="mb-0" id="selectExplanation">Starting select operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="selectStepsContainer">
            <h6 class="text-center">Select Operation Steps</h6>
            <div class="steps-container" id="selectSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSelect" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(inputArray, 'inputArrayDisplay');
    renderArrayInContainer(choicesArray, 'choicesArrayDisplay');
    
    const condition = calculateCondition(inputArray, operator, conditionValue);
    const result = [];
    for (let i = 0; i < inputArray.length; i++) {
        result.push(condition[i] ? choicesArray[i] : 0); // Default 0 for no match
    }
    
    renderArrayInContainer(condition.map(c => c ? 'True' : 'False'), 'selectConditionDisplay');
    renderArrayInContainer([...result], 'selectResultDisplay');
    
    animateSelectOperation(inputArray, choicesArray, condition, result);
}

// NEW: Perform Piecewise Operation with Animation
function performPiecewiseOperation(inputArray, functionsArray, operator, conditionValue) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Piecewise Evaluate Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Input Array</div>
            <div class="original-array-container" id="piecewiseInputDisplay"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Functions Array</div>
            <div class="original-array-container" id="functionsArrayDisplay"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Condition: Input ${operator} ${conditionValue}</div>
            <div class="original-array-container" id="piecewiseConditionDisplay"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Result (np.piecewise)</div>
            <div class="transformed-array-container" id="piecewiseResultDisplay"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Piecewise Operation:</strong> Apply different functions based on conditions</p>
            <p class="mb-0" id="piecewiseExplanation">Starting piecewise operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="piecewiseStepsContainer">
            <h6 class="text-center">Piecewise Operation Steps</h6>
            <div class="steps-container" id="piecewiseSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPiecewise" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(inputArray, 'piecewiseInputDisplay');
    renderArrayInContainer(functionsArray.map(f => `f(x)=${f}x`), 'functionsArrayDisplay');
    
    const condition = calculateCondition(inputArray, operator, conditionValue);
    const result = [];
    for (let i = 0; i < inputArray.length; i++) {
        if (condition[i]) {
            result.push(functionsArray[i] * inputArray[i]); // Simulate function application
        } else {
            result.push(inputArray[i]); // Default function: identity
        }
    }
    
    renderArrayInContainer(condition.map(c => c ? 'True' : 'False'), 'piecewiseConditionDisplay');
    renderArrayInContainer([...result], 'piecewiseResultDisplay');
    
    animatePiecewiseOperation(inputArray, functionsArray, condition, result);
}

// NEW: Calculate Condition
function calculateCondition(array, operator, value) {
    const condition = [];
    for (let i = 0; i < array.length; i++) {
        switch(operator) {
            case '<': condition.push(array[i] < value); break;
            case '>': condition.push(array[i] > value); break;
            case '<=': condition.push(array[i] <= value); break;
            case '>=': condition.push(array[i] >= value); break;
            case '==': condition.push(array[i] === value); break;
            case '!=': condition.push(array[i] !== value); break;
        }
    }
    return condition;
}
// NEW: Animate Where Operation
function animateWhereOperation(arr1, arr2, condition, result) {
    const arrayXDisplay = document.getElementById('arrayXDisplay');
    const arrayYDisplay = document.getElementById('arrayYDisplay');
    const conditionDisplay = document.getElementById('conditionDisplay');
    const resultDisplay = document.getElementById('resultDisplay');
    const explanation = document.getElementById('whereExplanation');
    const stepsContainer = document.getElementById('whereSteps');
    const continueButton = document.getElementById('continueAfterWhere');
    
    let step = 0;
    
    function performWhereStep(i) {
        if (i >= arr1.length) {
            // Operation completed
            explanation.innerHTML = `<strong>Where Operation Completed!</strong> Result array generated.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Where operation completed successfully
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterConditional();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterConditional);
            
            return;
        }
        
        step++;
        explanation.innerHTML = `Step ${step}: Processing element at index ${i}`;
        
        // Highlight current elements
        const xElements = arrayXDisplay.querySelectorAll('.array-element');
        const yElements = arrayYDisplay.querySelectorAll('.array-element');
        const conditionElements = conditionDisplay.querySelectorAll('.array-element');
        const resultElements = resultDisplay.querySelectorAll('.array-element');
        
        xElements[i].querySelector('.element-value').classList.add('sorting-current');
        yElements[i].querySelector('.element-value').classList.add('sorting-compared');
        conditionElements[i].querySelector('.element-value').classList.add(condition[i] ? 'success-color' : 'warning-color');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> Condition[${i}] = ${condition[i]}  
                Taking ${condition[i] ? 'X[' + i + ']=' + arr1[i] : 'Y[' + i + ']=' + arr2[i]}
            </div>
        `;
        
        setTimeout(() => {
            // Update result
            resultElements[i].querySelector('.element-value').classList.add('create', 'bounce');
            resultElements[i].querySelector('.element-value').textContent = result[i];
            
            // Remove highlights
            xElements[i].querySelector('.element-value').classList.remove('sorting-current');
            yElements[i].querySelector('.element-value').classList.remove('sorting-compared');
            
            // Move to next element
            performWhereStep(i + 1);
        }, 1500);
    }
    
    // Start animation
    performWhereStep(0);
}
// NEW: Animate Select Operation
function animateSelectOperation(inputArray, choicesArray, condition, result) {
    const inputArrayDisplay = document.getElementById('inputArrayDisplay');
    const choicesArrayDisplay = document.getElementById('choicesArrayDisplay');
    const selectConditionDisplay = document.getElementById('selectConditionDisplay');
    const selectResultDisplay = document.getElementById('selectResultDisplay');
    const explanation = document.getElementById('selectExplanation');
    const stepsContainer = document.getElementById('selectSteps');
    const continueButton = document.getElementById('continueAfterSelect');
    
    let step = 0;
    
    function performSelectStep(i) {
        if (i >= inputArray.length) {
            // Operation completed
            explanation.innerHTML = `<strong>Select Operation Completed!</strong> Result array generated.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Select operation completed successfully
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterConditional();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterConditional);
            
            return;
        }
        
        step++;
        explanation.innerHTML = `Step ${step}: Processing element at index ${i}`;
        
        // Highlight current elements
        const inputElements = inputArrayDisplay.querySelectorAll('.array-element');
        const choicesElements = choicesArrayDisplay.querySelectorAll('.array-element');
        const conditionElements = selectConditionDisplay.querySelectorAll('.array-element');
        const resultElements = selectResultDisplay.querySelectorAll('.array-element');
        
        inputElements[i].querySelector('.element-value').classList.add('sorting-current');
        choicesElements[i].querySelector('.element-value').classList.add('sorting-compared');
        conditionElements[i].querySelector('.element-value').classList.add(condition[i] ? 'success-color' : 'warning-color');
        
        const selectedValue = condition[i] ? choicesArray[i] : 0;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> Input[${i}]=${inputArray[i]}, Condition=${condition[i]}  
                ${condition[i] ? 'Taking Choice[' + i + ']=' + choicesArray[i] : 'Default=0'}
            </div>
        `;
        
        setTimeout(() => {
            // Update result
            resultElements[i].querySelector('.element-value').classList.add('create', 'bounce');
            resultElements[i].querySelector('.element-value').textContent = selectedValue;
            
            // Remove highlights
            inputElements[i].querySelector('.element-value').classList.remove('sorting-current');
            choicesElements[i].querySelector('.element-value').classList.remove('sorting-compared');
            
            // Move to next element
            performSelectStep(i + 1);
        }, 1500);
    }
    
    // Start animation
    performSelectStep(0);
}

// NEW: Animate Piecewise Operation
function animatePiecewiseOperation(inputArray, functionsArray, condition, result) {
    const piecewiseInputDisplay = document.getElementById('piecewiseInputDisplay');
    const functionsArrayDisplay = document.getElementById('functionsArrayDisplay');
    const piecewiseConditionDisplay = document.getElementById('piecewiseConditionDisplay');
    const piecewiseResultDisplay = document.getElementById('piecewiseResultDisplay');
    const explanation = document.getElementById('piecewiseExplanation');
    const stepsContainer = document.getElementById('piecewiseSteps');
    const continueButton = document.getElementById('continueAfterPiecewise');
    
    let step = 0;
    
    function performPiecewiseStep(i) {
        if (i >= inputArray.length) {
            // Operation completed
            explanation.innerHTML = `<strong>Piecewise Operation Completed!</strong> Result array generated.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Piecewise operation completed successfully
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterConditional();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterConditional);
            
            return;
        }
        
        step++;
        explanation.innerHTML = `Step ${step}: Processing element at index ${i}`;
        
        // Highlight current elements
        const inputElements = piecewiseInputDisplay.querySelectorAll('.array-element');
        const functionsElements = functionsArrayDisplay.querySelectorAll('.array-element');
        const conditionElements = piecewiseConditionDisplay.querySelectorAll('.array-element');
        const resultElements = piecewiseResultDisplay.querySelectorAll('.array-element');
        
        inputElements[i].querySelector('.element-value').classList.add('sorting-current');
        functionsElements[i].querySelector('.element-value').classList.add('sorting-compared');
        conditionElements[i].querySelector('.element-value').classList.add(condition[i] ? 'success-color' : 'warning-color');
        
        const originalValue = inputArray[i];
        const functionValue = functionsArray[i];
        const resultValue = result[i];
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> 
                Input[${i}]=${originalValue}, Condition=${condition[i]}  
                ${condition[i] ? 
                  `Applying f(x)=${functionValue}x  ${resultValue}` : 
                  `Using identity function  ${resultValue}`}
            </div>
        `;
        
        setTimeout(() => {
            // Update result
            resultElements[i].querySelector('.element-value').classList.add('create', 'bounce');
            resultElements[i].querySelector('.element-value').textContent = resultValue;
            
            // Remove highlights
            inputElements[i].querySelector('.element-value').classList.remove('sorting-current');
            functionsElements[i].querySelector('.element-value').classList.remove('sorting-compared');
            
            // Move to next element
            performPiecewiseStep(i + 1);
        }, 1500);
    }
    
    // Start animation
    performPiecewiseStep(0);
}
// NEW: Return to Original after Conditional Operations (Updated)
function returnToOriginalAfterConditional() {
    // Reset to original array
    if (originalArrayForConditional && originalArrayForConditional.length > 0) {
        myArray = [...originalArrayForConditional];
    }
    originalArrayForConditional = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    if (mainContainer) {
        mainContainer.innerHTML = '';
        renderArray();
        updateStats();
    }
    
    // Reset state
    isConditionalOperationRunning = false;
    currentConditionalOperation = null;
    
    // Clear all conditional data
    array1 = [];
    array2 = [];
    array1Size = 0;
    array2Size = 0;
    
    // Clear input fields
    if (arraySize1) arraySize1.value = '';
    if (arraySize2) arraySize2.value = '';
    if (conditionValue) conditionValue.value = '';
    if (array1Inputs) array1Inputs.innerHTML = '';
    if (array2Inputs) array2Inputs.innerHTML = '';
    
    logOperation('Conditional operation completed - returned to original array', 'info');
    showNotification('Returned to original array after conditional operation', 'success');
}
// Helper function to render arrays in specific containers
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = '<div class="array-empty-state"><p>Array is empty</p></div>';
        return;
    }
    
    array.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}
// NEW: Previous Greater/Smaller Element Handler
function handlePreviousElement(type) {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isPreviousElementRunning) {
        showNotification('A previous element operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Previous element operations require all array elements to be numbers', 'danger');
        return;
    }
    
    isPreviousElementRunning = true;
    
    // Store original array
    originalArrayForPreviousElement = [...myArray];
    
    // Show previous element visualization
    showPreviousElementVisualization(type);
}
// NEW: Show Previous Element Visualization
function showPreviousElementVisualization(type) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Previous ${type === 'greater' ? 'Greater' : 'Smaller'} Element (P${type === 'greater' ? 'G' : 'S'}E)</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalPrevElementArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Previous ${type === 'greater' ? 'Greater' : 'Smaller'} Element Analysis</div>
            <div class="transformed-array-container" id="transformedPrevElementArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>P${type === 'greater' ? 'G' : 'S'}E Algorithm:</strong> For each element, find the nearest ${type === 'greater' ? 'greater' : 'smaller'} element to its left</p>
            <p class="mb-0" id="prevElementExplanation">Initializing analysis...</p>
        </div>
        
        <!-- Final Result Container - Moved ABOVE the steps -->
        <div class="final-result-container mt-4" id="finalResultContainer" style="display: none;">
            <h6 class="text-center mb-3">Final Result</h6>
            <div class="row justify-content-center">
                <div class="col-md-5">
                    <div class="array-group">
                        <div class="array-label">Original Array</div>
                        <div class="original-array-container" id="finalOriginalArray"></div>
                    </div>
                </div>
                <div class="col-md-1 d-flex align-items-center justify-content-center">
                    <div class="operation-arrow">
                        <i class="fas fa-arrow-right"></i>
                    </div>
                </div>
                <div class="col-md-5">
                    <div class="array-group">
                        <div class="array-label">P${type === 'greater' ? 'G' : 'S'}E Array</div>
                        <div class="transformed-array-container" id="finalPrevElementArrayDisplay"></div>
                    </div>
                </div>
            </div>
            <div class="text-center mt-3" id="finalResultText"></div>
        </div>
        
        <!-- Step-by-Step Analysis - Moved BELOW the final result -->
        <div class="algorithm-steps mt-3" id="prevElementStepsContainer">
            <h6 class="text-center">Step-by-Step Analysis</h6>
            <div class="steps-container" id="prevElementSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPrevElement" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForPreviousElement, 'originalPrevElementArray');
    renderArrayInContainer([...originalArrayForPreviousElement], 'transformedPrevElementArray');
    
    performPreviousElementAnalysis(type);
}

// NEW: Perform Previous Element Analysis
function performPreviousElementAnalysis(type) {
    const originalContainer = document.getElementById('originalPrevElementArray');
    const transformedContainer = document.getElementById('transformedPrevElementArray');
    const explanation = document.getElementById('prevElementExplanation');
    const stepsContainer = document.getElementById('prevElementSteps');
    const finalResultContainer = document.getElementById('finalResultContainer');
    const finalOriginalArray = document.getElementById('finalOriginalArray');
    const finalPrevElementArrayDisplay = document.getElementById('finalPrevElementArrayDisplay');
    const finalResultText = document.getElementById('finalResultText');
    const continueButton = document.getElementById('continueAfterPrevElement');
    
    const arr = originalArrayForPreviousElement.map(val => parseFloat(val));
    const n = arr.length;
    const result = new Array(n).fill(-1);
    const resultValues = new Array(n).fill('N/A');
    let step = 0;
    let currentIndex = 0;
    
    function performAnalysisStep() {
        if (currentIndex >= n) {
            // Analysis completed
            explanation.innerHTML = `<strong>Analysis Completed!</strong> All elements processed.`;
            
            // Show final results side by side - NOW ABOVE the steps
            finalResultContainer.style.display = 'block';
            
            // Render final arrays
            renderArrayInContainer(originalArrayForPreviousElement, 'finalOriginalArray');
            renderPGEArrayInContainer(result, 'finalPrevElementArrayDisplay', type);
            
            // Create detailed result text
            let resultText = `<strong>Original Array:</strong> [${arr.join(', ')}]<br>`;
            resultText += `<strong>P${type === 'greater' ? 'G' : 'S'}E Array:</strong> [${result.join(', ')}]<br><br>`;
            resultText += `<strong>Detailed Explanation:</strong><br>`;
            
            for (let i = 0; i < n; i++) {
                resultText += `Index ${i}, Value ${arr[i]}:  P${type === 'greater' ? 'G' : 'S'}E: ${result[i]} `;
                if (result[i] === -1) {
                    resultText += `(val=N/A)`;
                } else {
                    resultText += `(val=${arr[result[i]]})`;
                }
                resultText += `<br>`;
            }
            
            finalResultText.innerHTML = resultText;
            
            // Add final step to the steps container (which is now BELOW the final result)
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> P${type === 'greater' ? 'G' : 'S'}E Array = [${result.join(', ')}]
                </div>
            `;
            
            // Highlight all elements in final result
            const finalPrevElements = finalPrevElementArrayDisplay.querySelectorAll('.array-element');
            finalPrevElements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('success-color', 'pulse');
                }, index * 200);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterPrevElement();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterPrevElement);
            
            return;
        }
        
        step++;
        const currentValue = arr[currentIndex];
        
        explanation.innerHTML = `Processing index ${currentIndex}, value = ${currentValue}`;
        
        // Highlight current element
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        const currentElement = transformedElements[currentIndex].querySelector('.element-value');
        currentElement.classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> Processing index ${currentIndex}, value = ${currentValue}
            </div>
        `;
        
        setTimeout(() => {
            if (currentIndex === 0) {
                // First element always has -1
                result[currentIndex] = -1;
                resultValues[currentIndex] = 'N/A';
                
                explanation.innerHTML = `Index ${currentIndex}: First element  P${type === 'greater' ? 'G' : 'S'}E = -1 (no previous elements)`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Result:</strong> First element  P${type === 'greater' ? 'G' : 'S'}E = -1 (no previous elements)
                    </div>
                `;
                
                // Highlight as first element
                currentElement.classList.remove('sorting-current');
                currentElement.classList.add('info-color');
                
                currentIndex++;
                performAnalysisStep();
                
            } else {
                // Search for previous greater/smaller element
                let foundIndex = -1;
                let foundValue = 'N/A';
                
                explanation.innerHTML = `Searching for previous ${type === 'greater' ? 'greater' : 'smaller'} element...`;
                
                // Start searching from currentIndex-1 backwards
                let searchIndex = currentIndex - 1;
                
                function performSearchStep() {
                    if (searchIndex < 0) {
                        // No element found
                        result[currentIndex] = -1;
                        resultValues[currentIndex] = 'N/A';
                        
                        explanation.innerHTML = `Index ${currentIndex}: No previous ${type === 'greater' ? 'greater' : 'smaller'} element found  P${type === 'greater' ? 'G' : 'S'}E = -1`;
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Result:</strong> No previous ${type === 'greater' ? 'greater' : 'smaller'} element found  P${type === 'greater' ? 'G' : 'S'}E = -1
                            </div>
                        `;
                        
                        currentElement.classList.remove('sorting-current');
                        currentElement.classList.add('warning-color');
                        
                        currentIndex++;
                        performAnalysisStep();
                        return;
                    }
                    
                    const searchValue = arr[searchIndex];
                    const isMatch = type === 'greater' ? searchValue > currentValue : searchValue < currentValue;
                    
                    // Highlight the element being checked
                    const searchElement = transformedElements[searchIndex].querySelector('.element-value');
                    searchElement.classList.add('sorting-compared');
                    
                    explanation.innerHTML = `Checking index ${searchIndex}, value = ${searchValue}...`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Check:</strong> Comparing with index ${searchIndex}, value = ${searchValue}
                        </div>
                    `;
                    
                    setTimeout(() => {
                        if (isMatch) {
                            // Found the element
                            foundIndex = searchIndex;
                            foundValue = searchValue;
                            result[currentIndex] = foundIndex;
                            resultValues[currentIndex] = foundValue;
                            
                            explanation.innerHTML = `Index ${currentIndex}: Found P${type === 'greater' ? 'G' : 'S'}E at index ${foundIndex} (value = ${foundValue})`;
                            
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step active">
                                    <strong>Found!</strong> P${type === 'greater' ? 'G' : 'S'}E = ${foundIndex} (value = ${foundValue})
                                </div>
                            `;
                            
                            // Highlight the connection
                            currentElement.classList.remove('sorting-current');
                            searchElement.classList.remove('sorting-compared');
                            currentElement.classList.add('success-color');
                            searchElement.classList.add('success-color');
                            
                            // Draw visual connection (simplified)
                            setTimeout(() => {
                                currentIndex++;
                                performAnalysisStep();
                            }, 1500);
                            
                        } else {
                            // Continue searching
                            searchElement.classList.remove('sorting-compared');
                            searchIndex--;
                            
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step">
                                    <strong>Continue:</strong> Value ${searchValue} is not ${type === 'greater' ? 'greater' : 'smaller'} than ${currentValue}
                                </div>
                            `;
                            
                            performSearchStep();
                        }
                    }, 1500);
                }
                
                // Start search
                performSearchStep();
            }
        }, 1000);
    }
    
    // Start analysis
    performAnalysisStep();
}
// NEW: Render PGE/PSE array in specific container
function renderPGEArrayInContainer(resultArray, containerId, type) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    resultArray.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        
        let displayValue = value === -1 ? '-1' : value.toString();
        let tooltip = value === -1 ? 
            `No previous ${type === 'greater' ? 'greater' : 'smaller'} element found` : 
            `Index of previous ${type === 'greater' ? 'greater' : 'smaller'} element`;
        
        arrayElement.innerHTML = `
            <div class="element-value" title="${tooltip}">${displayValue}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}

// NEW: Return to Original after Previous Element Analysis
function returnToOriginalAfterPrevElement() {
    // Reset to original array
    myArray = [...originalArrayForPreviousElement];
    originalArrayForPreviousElement = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isPreviousElementRunning = false;
    
    logOperation('Previous element analysis completed - returned to original array', 'info');
    showNotification('Returned to original array after previous element analysis', 'success');
}

// NEW: Render array in specific container
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = `
            <div class="array-empty-state">
                <i class="fas fa-layer-group"></i>
                <h4>Array is Empty</h4>
                <p>Add some elements to get started!</p>
            </div>
        `;
        return;
    }
    
    array.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}
// NEW: Find Elements by Predicate Function Handler
function handleFindByPredicate() {
    const condition = predicateCondition.value.trim();
    
    if (condition === '') {
        showNotification('Please enter a predicate condition', 'danger');
        predicateCondition.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isPredicateFilterRunning) {
        showNotification('A predicate filter operation is already in progress', 'warning');
        return;
    }
    
    // Validate the condition
    if (!isValidPredicateCondition(condition)) {
        showNotification('Invalid condition format. Use format like: arr%2==0, arr!=0, arr<5', 'danger');
        predicateCondition.focus();
        return;
    }
    
    isPredicateFilterRunning = true;
    
    // Store original array
    originalArrayForPredicate = [...myArray];
    
    // Show predicate filter visualization
    showPredicateFilterVisualization(condition);
}

// NEW: Validate Predicate Condition
function isValidPredicateCondition(condition) {
    // Basic validation - should contain 'arr' and valid operators
    const validPattern = /^arr\s*([<>!=]=?|%|\+|-|\*|\/)\s*[0-9]+$/;
    return validPattern.test(condition.replace(/\s/g, ''));
}

// NEW: Evaluate Predicate Condition
function evaluatePredicate(element, condition) {
    try {
        // Replace 'arr' with the actual element value
        const expression = condition.replace(/arr/g, `(${element})`);
        
        // Use Function constructor for safe evaluation
        return new Function(`return ${expression};`)();
    } catch (error) {
        console.error('Error evaluating predicate:', error);
        return false;
    }
}

// NEW: Show Predicate Filter Visualization
function showPredicateFilterVisualization(condition) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Filter Elements by Predicate Function</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalPredicateArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-filter"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Filtered Array (Condition: ${condition})</div>
            <div class="transformed-array-container" id="filteredPredicateArray"></div>
        </div>
        
        <div class="predicate-explanation">
            <p class="mb-2"><strong>Predicate Filter:</strong> Finding elements that satisfy: ${condition}</p>
            <p class="mb-0" id="predicateExplanation">Starting predicate filter analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="predicateStepsContainer">
            <h6 class="text-center">Filtering Steps</h6>
            <div class="steps-container" id="predicateSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Elements Matching Condition</div>
            <div class="stats-value" id="matchingCount">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPredicate" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForPredicate, 'originalPredicateArray');
    renderArrayInContainer([], 'filteredPredicateArray');
    
    performPredicateFilterAnimation(condition);
}

// NEW: Perform Predicate Filter Animation
function performPredicateFilterAnimation(condition) {
    const originalContainer = document.getElementById('originalPredicateArray');
    const filteredContainer = document.getElementById('filteredPredicateArray');
    const explanation = document.getElementById('predicateExplanation');
    const stepsContainer = document.getElementById('predicateSteps');
    const matchingCount = document.getElementById('matchingCount');
    const continueButton = document.getElementById('continueAfterPredicate');
    
    const originalArray = [...originalArrayForPredicate];
    let filteredArray = [];
    let currentIndex = 0;
    let matchCount = 0;
    
    function performFilterStep() {
        if (currentIndex >= originalArray.length) {
            // Filtering completed
            explanation.innerHTML = `<strong>Filtering Completed!</strong> Found ${matchCount} elements matching the condition.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Filtering completed! ${matchCount} elements satisfy: ${condition}
                </div>
            `;
            
            matchingCount.textContent = matchCount;
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterPredicate();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterPredicate);
            
            return;
        }
        
        const currentElement = originalArray[currentIndex];
        const elementValue = currentElement;
        
        // Update explanation
        explanation.innerHTML = `Checking element [${currentIndex}] = ${elementValue} against condition: ${condition}`;
        
        // Highlight current element being checked
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElementDiv = originalElements[currentIndex].querySelector('.element-value');
        currentElementDiv.classList.add('predicate-match');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${currentIndex + 1}:</strong> Checking [${currentIndex}] = ${elementValue} against: ${condition}
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            try {
                // Evaluate the condition
                const matches = evaluatePredicate(elementValue, condition);
                
                if (matches) {
                    // Element matches the condition
                    explanation.innerHTML = `Element [${currentIndex}] = ${elementValue} <strong class="text-success">MATCHES</strong> condition: ${condition}`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong> Match:</strong> [${currentIndex}] = ${elementValue} satisfies: ${condition}
                        </div>
                    `;
                    
                    // Add to filtered array
                    filteredArray.push(elementValue);
                    matchCount++;
                    
                    // Update filtered array display
                    renderArrayInContainer(filteredArray, 'filteredPredicateArray');
                    
                    // Highlight as match
                    currentElementDiv.classList.remove('predicate-match');
                    currentElementDiv.classList.add('predicate-match');
                    
                    // Highlight in filtered array
                    const filteredElements = filteredContainer.querySelectorAll('.array-element');
                    if (filteredElements.length > 0) {
                        const lastFilteredElement = filteredElements[filteredElements.length - 1].querySelector('.element-value');
                        lastFilteredElement.classList.add('create', 'bounce');
                    }
                    
                } else {
                    // Element doesn't match
                    explanation.innerHTML = `Element [${currentIndex}] = ${elementValue} <strong class="text-danger">DOES NOT MATCH</strong> condition: ${condition}`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong> No Match:</strong> [${currentIndex}] = ${elementValue} does not satisfy: ${condition}
                        </div>
                    `;
                    
                    // Highlight as no match
                    currentElementDiv.classList.remove('predicate-match');
                    currentElementDiv.classList.add('predicate-nomatch');
                }
                
                matchingCount.textContent = matchCount;
                
            } catch (error) {
                explanation.innerHTML = `<strong class="text-danger">Error evaluating condition for element ${elementValue}</strong>`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Error:</strong> Could not evaluate condition for element ${elementValue}
                    </div>
                `;
                
                currentElementDiv.classList.remove('predicate-match');
                currentElementDiv.classList.add('predicate-nomatch');
            }
            
            currentIndex++;
            setTimeout(performFilterStep, 1500);
        }, 1000);
    }
    
    // Start filtering process
    performFilterStep();
}

// NEW: Return to Original after Predicate Filter
function returnToOriginalAfterPredicate() {
    // Reset to original array
    myArray = [...originalArrayForPredicate];
    originalArrayForPredicate = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isPredicateFilterRunning = false;
    
    // Clear input
    predicateCondition.value = '';
    
    logOperation('Predicate filter operation completed - returned to original array', 'info');
    showNotification('Returned to original array after predicate filter operation', 'success');
}
// Helper function to render array in specific container
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = `
            <div class="array-empty-state">
                <i class="fas fa-layer-group"></i>
                <h6>Array is Empty</h6>
            </div>
        `;
        return;
    }
    
    array.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}
// NEW: Convert 1D to 2D Array Handler
function handleConvertTo2D() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isReshapeOperationRunning) {
        showNotification('A reshape operation is already in progress', 'warning');
        return;
    }
    
    if (myArray.length < 2) {
        showNotification('Array must have at least 2 elements to convert to 2D', 'warning');
        return;
    }
    
    isReshapeOperationRunning = true;
    
    // Store original array
    originalArrayForReshape = [...myArray];
    
    // Perform reshape visualization
    showReshapeVisualization();
}

// NEW: Show Reshape Visualization
function showReshapeVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Convert 1D Array to 2D Array</h5>
        
        <div class="array-group">
            <div class="array-label">Original 1D Array</div>
            <div class="original-array-container" id="original1DArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Reshaped 2D Array</div>
            <div class="reshape-2d-container" id="reshaped2DArray"></div>
        </div>
        
        <div class="reshape-explanation">
            <p class="mb-2"><strong>Reshape Process:</strong> Automatically converting 1D array to optimal 2D dimensions</p>
            <p class="mb-0" id="reshapeExplanation">Starting reshape operation...</p>
        </div>
        
        <div class="stats-card mt-3">
            <div>Original 1D Length</div>
            <div class="stats-value">${originalArrayForReshape.length}</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>2D Dimensions</div>
            <div class="stats-value" id="reshapeDimensions">Calculating...</div>
        </div>
        
        <div class="alert alert-info mt-3">
            <i class="fas fa-info-circle me-2"></i>
            The array will automatically convert back to 1D in <strong id="countdown">10</strong> seconds
        </div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForReshape, 'original1DArray');
    
    // Start reshape animation
    performReshapeAnimation();
}

// NEW: Perform Reshape Animation
function performReshapeAnimation() {
    const originalContainer = document.getElementById('original1DArray');
    const reshapedContainer = document.getElementById('reshaped2DArray');
    const explanation = document.getElementById('reshapeExplanation');
    const dimensionsElement = document.getElementById('reshapeDimensions');
    const countdownElement = document.getElementById('countdown');
    
    const array = [...originalArrayForReshape];
    const n = array.length;
    
    // Calculate optimal 2D dimensions
    let rows, cols;
    
    if (n <= 4) {
        // Small arrays: 1 row or 2 rows
        rows = n <= 2 ? 1 : 2;
        cols = Math.ceil(n / rows);
    } else if (n <= 9) {
        // Medium arrays: 2 or 3 rows
        rows = n <= 6 ? 2 : 3;
        cols = Math.ceil(n / rows);
    } else {
        // Larger arrays: try to make it as square as possible
        rows = Math.floor(Math.sqrt(n));
        cols = Math.ceil(n / rows);
        
        // Adjust if the last row would be too short
        if (cols * (rows - 1) >= n) {
            rows--;
            cols = Math.ceil(n / rows);
        }
    }
    
    dimensionsElement.textContent = `${rows}  ${cols}`;
    
    explanation.innerHTML = `Calculated optimal dimensions: ${rows} rows  ${cols} columns`;
    
    // Create 2D array structure
    const matrix = [];
    let index = 0;
    
    for (let i = 0; i < rows; i++) {
        const row = [];
        for (let j = 0; j < cols; j++) {
            if (index < n) {
                row.push(array[index]);
                index++;
            } else {
                row.push(''); // Empty cell for incomplete rows
            }
        }
        matrix.push(row);
    }
    
    // Animate the conversion from 1D to 2D
    animate1Dto2DConversion(matrix, rows, cols);
    
    // Start countdown for auto-return
    let countdown = 10;
    reshapeTimeout = setInterval(() => {
        countdown--;
        countdownElement.textContent = countdown;
        
        if (countdown <= 0) {
            clearInterval(reshapeTimeout);
            returnTo1DAfterReshape();
        }
    }, 1000);
}

// NEW: Animate 1D to 2D Conversion
function animate1Dto2DConversion(matrix, rows, cols) {
    const originalContainer = document.getElementById('original1DArray');
    const reshapedContainer = document.getElementById('reshaped2DArray');
    const explanation = document.getElementById('reshapeExplanation');
    
    // First, highlight all elements in original 1D array
    const originalElements = originalContainer.querySelectorAll('.array-element');
    originalElements.forEach((el, index) => {
        setTimeout(() => {
            el.querySelector('.element-value').classList.add('reshape-highlight');
        }, index * 200);
    });
    
    // Then, create the 2D visualization
    setTimeout(() => {
        explanation.innerHTML = `Creating ${rows}  ${cols} 2D array structure...`;
        
        // Build the 2D grid
        let html = '';
        let elementIndex = 0;
        
        for (let i = 0; i < rows; i++) {
            html += '<div class="reshape-row">';
            for (let j = 0; j < cols; j++) {
                if (elementIndex < originalArrayForReshape.length) {
                    html += `
                        <div class="reshape-element reshape-highlight" 
                             data-original-index="${elementIndex}">
                            ${originalArrayForReshape[elementIndex]}
                        </div>
                    `;
                    elementIndex++;
                } else {
                    html += `<div class="reshape-element" style="opacity: 0.3;">-</div>`;
                }
            }
            html += '</div>';
        }
        
        reshapedContainer.innerHTML = html;
        
        // Animate the 2D elements
        const reshapeElements = reshapedContainer.querySelectorAll('.reshape-element');
        reshapeElements.forEach((el, index) => {
            setTimeout(() => {
                el.classList.add('bounce');
            }, index * 100);
        });
        
        explanation.innerHTML = `<strong>Conversion Complete!</strong> 1D array successfully reshaped into ${rows}  ${cols} 2D array`;
        
    }, originalArrayForReshape.length * 200 + 500);
}

// NEW: Return to 1D after Reshape
function returnTo1DAfterReshape() {
    if (reshapeTimeout) {
        clearInterval(reshapeTimeout);
    }
    
    // Reset to original array
    myArray = [...originalArrayForReshape];
    originalArrayForReshape = [];
    
    // Remove reshape visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isReshapeOperationRunning = false;
    
    // Highlight all elements to show return to 1D
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation('Array automatically converted back to 1D after reshape operation', 'info');
    showNotification('Automatically returned to 1D array', 'success');
}
// Helper function to render array in specific container
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = '<div class="array-empty-state"><i class="fas fa-layer-group"></i><h4>Array is Empty</h4></div>';
        return;
    }
    
    array.forEach((value, index) => {
        const elementDiv = document.createElement('div');
        elementDiv.className = 'array-element';
        elementDiv.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(elementDiv);
    });
}
// NEW: Get Data Type Handler
function handleGetDataType() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    const dataType = determineArrayDataType(myArray);
    
    // Show result in search results
    searchResults.innerHTML = `
        <div class="alert alert-info">
            <h6><i class="fas fa-info-circle me-2"></i>Array Data Type Analysis</h6>
            <p class="mb-1"><strong>Array:</strong> [${myArray.join(', ')}]</p>
            <p class="mb-1"><strong>Data Type:</strong> ${dataType}</p>
            <p class="mb-0"><strong>Length:</strong> ${myArray.length} elements</p>
        </div>
    `;
    
    // Highlight all elements based on data type
    myArray.forEach((_, index) => {
        highlightElement(index, 'info');
    });
    
    logOperation(`Analyzed array data type: ${dataType}`, 'info');
    showNotification(`Array data type: ${dataType}`, 'success');
}

// NEW: Create Typed Array Handler
function handleCreateTypedArray() {
    // Show input group
    dataTypeInputGroup.style.display = 'block';
    typedArraySize.focus();
    
    logOperation('Started create array with specific data type operation', 'info');
}

// NEW: Confirm Data Type Handler
function handleConfirmDataType() {
    const size = parseInt(typedArraySize.value);
    const dataType = dataTypeSelect.value;
    
    if (isNaN(size) || size < 1 || size > 50) {
        showNotification('Please enter a valid size between 1 and 50', 'danger');
        typedArraySize.focus();
        return;
    }
    
    if (dataType === '') {
        showNotification('Please select a data type', 'danger');
        dataTypeSelect.focus();
        return;
    }
    
    // Store original array
    originalArrayForDataType = [...myArray];
    
    // Hide input group
    dataTypeInputGroup.style.display = 'none';
    typedArraySize.value = '';
    dataTypeSelect.value = '';
    
    // Create array with specified data type
    createArrayWithDataType(size, dataType);
}

// NEW: Cancel Data Type Handler
function handleCancelDataType() {
    dataTypeInputGroup.style.display = 'none';
    typedArraySize.value = '';
    dataTypeSelect.value = '';
    
    logOperation('Cancelled create typed array operation', 'info');
}

// NEW: Convert to List Handler
function handleConvertToList() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isDataTypeOperationRunning) {
        showNotification('A data type operation is already in progress', 'warning');
        return;
    }
    
    isDataTypeOperationRunning = true;
    
    // Store original array
    originalArrayForDataType = [...myArray];
    
    // Show conversion visualization
    showConvertToListVisualization();
}

// NEW: Determine Array Data Type
function determineArrayDataType(array) {
    if (array.length === 0) return 'Empty';
    
    let hasInteger = false;
    let hasFloat = false;
    let hasString = false;
    let hasBoolean = false;
    let hasChar = false;
    
    for (let i = 0; i < array.length; i++) {
        const element = array[i];
        
        // Check boolean
        if (element === 'true' || element === 'false' || element === true || element === false) {
            hasBoolean = true;
        }
        // Check integer
        else if (!isNaN(parseInt(element)) && parseInt(element).toString() === element.toString()) {
            hasInteger = true;
        }
        // Check float
        else if (!isNaN(parseFloat(element)) && parseFloat(element).toString() !== parseInt(element).toString()) {
            hasFloat = true;
        }
        // Check char (single character)
        else if (typeof element === 'string' && element.length === 1) {
            hasChar = true;
        }
        // Check string
        else if (typeof element === 'string') {
            hasString = true;
        }
    }
    
    // Determine predominant type
    if (hasBoolean && !hasInteger && !hasFloat && !hasString && !hasChar) return 'Boolean';
    if (hasInteger && !hasFloat && !hasString && !hasChar && !hasBoolean) return 'Integer';
    if (hasFloat && !hasString && !hasChar && !hasBoolean) return 'Float';
    if (hasChar && !hasString && !hasBoolean) return 'Character';
    if (hasString) return 'String';
    
    // Mixed types
    const types = [];
    if (hasInteger) types.push('Integer');
    if (hasFloat) types.push('Float');
    if (hasString) types.push('String');
    if (hasChar) types.push('Character');
    if (hasBoolean) types.push('Boolean');
    
    return `Mixed (${types.join(', ')})`;
}

// NEW: Create Array with Specific Data Type
function createArrayWithDataType(size, dataType) {
    const newArray = [];
    
    switch (dataType) {
        case 'integer':
            for (let i = 0; i < size; i++) {
                newArray.push(Math.floor(Math.random() * 100).toString());
            }
            break;
        case 'float':
            for (let i = 0; i < size; i++) {
                newArray.push((Math.random() * 100).toFixed(2));
            }
            break;
        case 'string':
            const strings = ['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig', 'grape', 'honeydew'];
            for (let i = 0; i < size; i++) {
                newArray.push(strings[Math.floor(Math.random() * strings.length)]);
            }
            break;
        case 'char':
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
            for (let i = 0; i < size; i++) {
                newArray.push(chars[Math.floor(Math.random() * chars.length)]);
            }
            break;
        case 'boolean':
            for (let i = 0; i < size; i++) {
                newArray.push(Math.random() > 0.5 ? 'true' : 'false');
            }
            break;
    }
    
    // Update the array
    myArray = newArray;
    renderArray();
    updateStats();
    
    // Show data type information
    const detectedType = determineArrayDataType(myArray);
    searchResults.innerHTML = `
        <div class="alert alert-success">
            <h6><i class="fas fa-check-circle me-2"></i>Array Created Successfully</h6>
            <p class="mb-1"><strong>Requested Type:</strong> ${dataType}</p>
            <p class="mb-1"><strong>Detected Type:</strong> ${detectedType}</p>
            <p class="mb-1"><strong>Array:</strong> [${myArray.join(', ')}]</p>
            <p class="mb-0"><strong>Size:</strong> ${size} elements</p>
        </div>
    `;
    
    // Animate all elements
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'create');
        });
    }, 100);
    
    logOperation(`Created new ${dataType} array with ${size} elements`, 'success');
    showNotification(`Created ${dataType} array with ${size} elements`, 'success');
    
    // Auto-reset after 10 seconds
    setTimeout(() => {
        resetAfterDataTypeOperation();
    }, 10000);
}

// NEW: Show Convert to List Visualization
function showConvertToListVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Convert Array to List</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalArrayDataType"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Converted List</div>
            <div class="transformed-array-container" id="transformedListDataType"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Conversion Process:</strong> Converting JavaScript array to list representation</p>
            <p class="mb-0" id="dataTypeExplanation">Starting conversion animation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="dataTypeStepsContainer">
            <h6 class="text-center">Conversion Steps</h6>
            <div class="steps-container" id="dataTypeSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>List Representation</div>
            <div class="stats-value" id="listRepresentation">[]</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterDataType" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForDataType, 'originalArrayDataType');
    renderArrayInContainer([...originalArrayForDataType], 'transformedListDataType');
    
    performConvertToListAnimation();
}

// NEW: Perform Convert to List Animation
function performConvertToListAnimation() {
    const originalContainer = document.getElementById('originalArrayDataType');
    const transformedContainer = document.getElementById('transformedListDataType');
    const explanation = document.getElementById('dataTypeExplanation');
    const stepsContainer = document.getElementById('dataTypeSteps');
    const listRepresentation = document.getElementById('listRepresentation');
    const continueButton = document.getElementById('continueAfterDataType');
    
    const array = [...originalArrayForDataType];
    let currentIndex = 0;
    
    function performConversionStep() {
        if (currentIndex >= array.length) {
            // Conversion completed
            explanation.innerHTML = '<strong>Conversion Completed!</strong> Array successfully converted to list.';
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Array converted to list: [${array.join(', ')}]
                </div>
            `;
            
            listRepresentation.textContent = `[${array.join(', ')}]`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterDataType();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterDataType);
            
            return;
        }
        
        // Update explanation
        explanation.innerHTML = `Converting element at index ${currentIndex}: "${array[currentIndex]}"`;
        
        // Highlight current element being converted
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        
        const originalElement = originalElements[currentIndex].querySelector('.element-value');
        const transformedElement = transformedElements[currentIndex].querySelector('.element-value');
        
        originalElement.classList.add('transform-animation');
        transformedElement.classList.add('transform-animation');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex + 1}:</strong> Converted element [${currentIndex}] = "${array[currentIndex]}"
            </div>
        `;
        
        // Update list representation
        const currentList = array.slice(0, currentIndex + 1);
        listRepresentation.textContent = `[${currentList.join(', ')}${currentIndex < array.length - 1 ? ', ...' : ''}]`;
        
        setTimeout(() => {
            originalElement.classList.remove('transform-animation');
            transformedElement.classList.remove('transform-animation');
            
            currentIndex++;
            performConversionStep();
        }, 1000);
    }
    
    // Start conversion process
    performConversionStep();
}

// NEW: Return to Original after Data Type Operations
function returnToOriginalAfterDataType() {
    // Reset to original array
    myArray = [...originalArrayForDataType];
    originalArrayForDataType = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isDataTypeOperationRunning = false;
    
    logOperation('Data type operation completed - returned to original array', 'info');
    showNotification('Returned to original array after data type operation', 'success');
}

// NEW: Reset after Data Type Operation
function resetAfterDataTypeOperation() {
    if (originalArrayForDataType.length === 0) {
        return;
    }
    
    // Reset to original array
    myArray = [...originalArrayForDataType];
    originalArrayForDataType = [];
    
    renderArray();
    updateStats();
    
    logOperation('Automatically reset to original array after data type operation', 'info');
    showNotification('Automatically reset to original array', 'info');
}
// NEW: Shuffle Elements Handler
function handleShuffleElements() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (myArray.length === 1) {
        showNotification('Array has only one element - cannot shuffle', 'info');
        return;
    }
    
    if (isShuffleRunning) {
        showNotification('A shuffle operation is already in progress', 'warning');
        return;
    }
    
    isShuffleRunning = true;
    
    // Store original array
    originalArrayForShuffle = [...myArray];
    
    // Show shuffle visualization
    showShuffleVisualization();
}
// NEW: Show Shuffle Visualization
function showShuffleVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Fisher-Yates (Knuth) Shuffle Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalShuffleArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-random"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Shuffling Process</div>
            <div class="transformed-array-container" id="transformedShuffleArray"></div>
        </div>
        
        <div class="shuffle-explanation">
            <p class="mb-2"><strong>Fisher-Yates Algorithm:</strong> Randomly shuffles array in-place with O(n) time complexity</p>
            <p class="mb-0" id="shuffleExplanation">Starting Fisher-Yates shuffle algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="shuffleStepsContainer">
            <h6 class="text-center">Shuffle Steps</h6>
            <div class="steps-container" id="shuffleSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterShuffle" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForShuffle, 'originalShuffleArray');
    renderArrayInContainer([...originalArrayForShuffle], 'transformedShuffleArray');
    
    performShuffleAnimation();
}
// NEW: Perform Fisher-Yates Shuffle Animation
function performShuffleAnimation() {
    const originalContainer = document.getElementById('originalShuffleArray');
    const transformedContainer = document.getElementById('transformedShuffleArray');
    const explanation = document.getElementById('shuffleExplanation');
    const stepsContainer = document.getElementById('shuffleSteps');
    const continueButton = document.getElementById('continueAfterShuffle');
    
    let array = [...originalArrayForShuffle];
    const n = array.length;
    let step = 0;
    
    function performShuffleStep(i) {
        if (i < 0) {
            // Shuffle completed
            explanation.innerHTML = `<strong>Shuffle Completed!</strong> Array has been randomly shuffled using Fisher-Yates algorithm.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Array completely shuffled! Total steps: ${n}
                </div>
            `;
            
            // Highlight all elements as shuffled
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            transformedElements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('shuffle-completed');
                }, index * 100);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds as requested
            setTimeout(() => {
                returnToOriginalAfterShuffle();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterShuffle);
            
            return;
        }
        
        step++;
        
        if (i === n - 1) {
            // First step explanation
            explanation.innerHTML = `Step ${step}: Starting from last element (index ${i})`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> Start Fisher-Yates algorithm from last element (i = ${i})
                </div>
            `;
            
            // Highlight current position
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            const currentElement = transformedElements[i].querySelector('.element-value');
            currentElement.classList.add('shuffle-current');
            
            setTimeout(() => {
                currentElement.classList.remove('shuffle-current');
                performShuffleStep(i - 1);
            }, 1500);
            
        } else {
            // Generate random index between 0 and i (inclusive)
            const j = Math.floor(Math.random() * (i + 1));
            
            explanation.innerHTML = `Step ${step}: i=${i}, Random j=${j} (0 to ${i})`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step ${i !== j ? 'active' : ''}">
                    <strong>Step ${step}:</strong> i=${i}, Random j=${j} ${i !== j ? '- SWAPPING elements' : '- No swap (same index)'}
                </div>
            `;
            
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            
            if (i !== j) {
                // Highlight elements being swapped
                const elementI = transformedElements[i].querySelector('.element-value');
                const elementJ = transformedElements[j].querySelector('.element-value');
                
                elementI.classList.add('shuffle-current');
                elementJ.classList.add('shuffle-swap');
                
                // Calculate swap distance for animation
                const rectI = transformedElements[i].getBoundingClientRect();
                const rectJ = transformedElements[j].getBoundingClientRect();
                const swapDistance = rectJ.left - rectI.left;
                
                elementI.style.setProperty('--swap-distance', `${swapDistance}px`);
                elementJ.style.setProperty('--swap-distance', `-${swapDistance}px`);
                
                setTimeout(() => {
                    elementI.classList.add('swap-animation');
                    elementJ.classList.add('swap-animation');
                    
                    setTimeout(() => {
                        // Swap the elements
                        [array[i], array[j]] = [array[j], array[i]];
                        
                        // Update transformed array display
                        renderArrayInContainer(array, 'transformedShuffleArray');
                        
                        // Remove highlights
                        elementI.classList.remove('shuffle-current', 'shuffle-swap', 'swap-animation');
                        elementJ.classList.remove('shuffle-current', 'shuffle-swap', 'swap-animation');
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Swap ${step}:</strong> Swapped [${i}]="${array[i]}" and [${j}]="${array[j]}"
                            </div>
                        `;
                        
                        // Move to next step
                        performShuffleStep(i - 1);
                    }, 1000);
                }, 500);
            } else {
                // No swap needed (same index)
                const elementI = transformedElements[i].querySelector('.element-value');
                elementI.classList.add('shuffle-current');
                
                setTimeout(() => {
                    elementI.classList.remove('shuffle-current');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step}:</strong> No swap needed (i = j)
                        </div>
                    `;
                    
                    performShuffleStep(i - 1);
                }, 1000);
            }
        }
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
    }
    // Add this in the performShuffleAnimation function after the steps container
const algorithmCode = `
<div class="code-snippet mt-3">
    <strong>Fisher-Yates Shuffle Algorithm:</strong><br>
    function fisherYatesShuffle(arr) {<br>
    &nbsp;&nbsp;for (let i = arr.length - 1; i > 0; i--) {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;const j = Math.floor(Math.random() * (i + 1));<br>
    &nbsp;&nbsp;&nbsp;&nbsp;[arr[i], arr[j]] = [arr[j], arr[i]];<br>
    &nbsp;&nbsp;}<br>
    &nbsp;&nbsp;return arr;<br>
    }
</div>
`;

// You can insert this in the shuffleStepsContainer if you want to show the code
    
    // Start Fisher-Yates shuffle process (from last element to first)
    performShuffleStep(n - 1);
}
// NEW: Return to Original after Shuffle
function returnToOriginalAfterShuffle() {
    // Reset to original array
    myArray = [...originalArrayForShuffle];
    originalArrayForShuffle = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isShuffleRunning = false;
    
    logOperation('Fisher-Yates shuffle completed - returned to original array', 'info');
    showNotification('Returned to original array after shuffle operation', 'success');
}
// NEW: Bin Intervals Handler
function handleBinIntervals() {
    const numBins = parseInt(binCount.value);
    
    if (isNaN(numBins) || numBins < 2 || numBins > 20) {
        showNotification('Please enter a valid number of bins between 2 and 20', 'danger');
        binCount.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Binning operations require all array elements to be numbers', 'danger');
        return;
    }
    
    if (isBinningRunning) {
        showNotification('A binning operation is already in progress', 'warning');
        return;
    }
    
    isBinningRunning = true;
    
    // Store original array
    originalArrayForBinning = [...myArray];
    
    // Perform binning by number of bins
    performBinningByCount(numBins);
}

// NEW: Bin by Width Handler
function handleBinByWidth() {
    const width = parseFloat(binWidth.value);
    
    if (isNaN(width) || width <= 0) {
        showNotification('Please enter a valid bin width greater than 0', 'danger');
        binWidth.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Binning operations require all array elements to be numbers', 'danger');
        return;
    }
    
    if (isBinningRunning) {
        showNotification('A binning operation is already in progress', 'warning');
        return;
    }
    
    isBinningRunning = true;
    
    // Store original array
    originalArrayForBinning = [...myArray];
    
    // Perform binning by width
    performBinningByWidth(width);
}

// NEW: Perform Binning by Number of Bins
function performBinningByCount(numBins) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Data Binning - ${numBins} Equal Intervals</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalBinningArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Binning Process</div>
            <div class="transformed-array-container" id="transformedBinningArray"></div>
        </div>
        
        <div class="bin-visualization">
            <p class="mb-2"><strong>Binning Algorithm:</strong> Dividing data into ${numBins} equal intervals</p>
            <p class="mb-0" id="binningExplanation">Calculating bin ranges...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="binningStepsContainer">
            <h6 class="text-center">Binning Steps</h6>
            <div class="steps-container" id="binningSteps"></div>
        </div>
        
        <div class="bin-results mt-3" id="binResults" style="display: none;">
            <h6 class="text-center">Bin Distribution</h6>
            <div class="table-container">
                <table class="bin-table" id="binDistributionTable">
                    <thead>
                        <tr>
                            <th>Bin Range</th>
                            <th>Count</th>
                            <th>Elements</th>
                        </tr>
                    </thead>
                    <tbody id="binTableBody"></tbody>
                </table>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterBinning" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForBinning, 'originalBinningArray');
    renderArrayInContainer([...originalArrayForBinning], 'transformedBinningArray');
    
    executeBinningByCountAnimation(numBins);
}

// NEW: Execute Binning by Count Animation
function executeBinningByCountAnimation(numBins) {
    const originalContainer = document.getElementById('originalBinningArray');
    const transformedContainer = document.getElementById('transformedBinningArray');
    const explanation = document.getElementById('binningExplanation');
    const stepsContainer = document.getElementById('binningSteps');
    const binResults = document.getElementById('binResults');
    const binTableBody = document.getElementById('binTableBody');
    const continueButton = document.getElementById('continueAfterBinning');
    
    const arr = originalArrayForBinning.map(val => parseFloat(val));
    const minVal = Math.min(...arr);
    const maxVal = Math.max(...arr);
    const range = maxVal - minVal;
    const binSize = range / numBins;
    
    // Initialize bins
    const bins = Array.from({ length: numBins }, () => ({ count: 0, elements: [] }));
    let currentStep = 0;
    
    function executeBinningStep() {
        if (currentStep === 0) {
            // Step 1: Calculate statistics
            explanation.innerHTML = `Step 1: Calculating data range and bin size`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Data range: ${minVal} to ${maxVal} (Range: ${range.toFixed(2)})
                </div>
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Bin size: ${range.toFixed(2)} / ${numBins} = ${binSize.toFixed(2)}
                </div>
            `;
            
            // Highlight min and max values
            const originalElements = originalContainer.querySelectorAll('.array-element');
            const minIndex = arr.indexOf(minVal);
            const maxIndex = arr.indexOf(maxVal);
            
            if (minIndex !== -1) {
                originalElements[minIndex].querySelector('.element-value').classList.add('bin-boundary');
            }
            if (maxIndex !== -1 && maxIndex !== minIndex) {
                originalElements[maxIndex].querySelector('.element-value').classList.add('bin-boundary');
            }
            
            currentStep++;
            setTimeout(executeBinningStep, 2000);
            
        } else if (currentStep === 1) {
            // Step 2: Create bin ranges
            explanation.innerHTML = `Step 2: Creating ${numBins} bin intervals`;
            
            let binRangesHTML = '';
            for (let i = 0; i < numBins; i++) {
                const binStart = minVal + i * binSize;
                const binEnd = minVal + (i + 1) * binSize;
                binRangesHTML += `
                    <div class="algorithm-step">
                        <strong>Bin ${i + 1}:</strong> [${binStart.toFixed(2)}, ${binEnd.toFixed(2)})
                    </div>
                `;
            }
            
            stepsContainer.innerHTML += binRangesHTML;
            currentStep++;
            setTimeout(executeBinningStep, 2000);
            
        } else if (currentStep === 2) {
            // Step 3: Assign elements to bins
            explanation.innerHTML = `Step 3: Assigning elements to bins`;
            
            let elementIndex = 0;
            
            function assignNextElement() {
                if (elementIndex >= arr.length) {
                    // All elements assigned
                    currentStep++;
                    executeBinningStep();
                    return;
                }
                
                const value = arr[elementIndex];
                const binIndex = Math.min(Math.floor((value - minVal) / binSize), numBins - 1);
                
                explanation.innerHTML = `Step 3: Assigning element [${elementIndex}] = ${value} to Bin ${binIndex + 1}`;
                
                // Highlight current element
                const transformedElements = transformedContainer.querySelectorAll('.array-element');
                const currentElement = transformedElements[elementIndex].querySelector('.element-value');
                currentElement.classList.add('bin-interval-highlight');
                
                // Update bin
                bins[binIndex].count++;
                bins[binIndex].elements.push(value);
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Element [${elementIndex}] = ${value}  Bin ${binIndex + 1} [${(minVal + binIndex * binSize).toFixed(2)}, ${(minVal + (binIndex + 1) * binSize).toFixed(2)})
                    </div>
                `;
                
                setTimeout(() => {
                    currentElement.classList.remove('bin-interval-highlight');
                    elementIndex++;
                    assignNextElement();
                }, 1000);
            }
            
            assignNextElement();
            
        } else if (currentStep === 3) {
            // Step 4: Display results
            explanation.innerHTML = `Step 4: Binning completed! Displaying distribution`;
            
            // Show results table
            binResults.style.display = 'block';
            
            // Populate table
            let tableHTML = '';
            let maxCount = 0;
            
            for (let i = 0; i < numBins; i++) {
                const binStart = minVal + i * binSize;
                const binEnd = minVal + (i + 1) * binSize;
                const count = bins[i].count;
                
                if (count > maxCount) maxCount = count;
                
                tableHTML += `
                    <tr>
                        <td>[${binStart.toFixed(2)}, ${binEnd.toFixed(2)})</td>
                        <td>${count}</td>
                        <td>${bins[i].elements.join(', ')}</td>
                    </tr>
                `;
            }
            
            binTableBody.innerHTML = tableHTML;
            
            // Highlight bins with maximum count
            setTimeout(() => {
                const tableRows = binTableBody.querySelectorAll('tr');
                tableRows.forEach((row, index) => {
                    if (bins[index].count === maxCount && maxCount > 0) {
                        row.classList.add('bin-interval-high-count');
                    }
                });
            }, 500);
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 4:</strong> Binning completed! Created ${numBins} intervals with ${arr.length} total elements
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterBinning();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterBinning);
        }
    }
    
    // Start binning process
    executeBinningStep();
}

// NEW: Perform Binning by Width
function performBinningByWidth(width) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Data Binning - Bin Width ${width}</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalBinningArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Binning Process</div>
            <div class="transformed-array-container" id="transformedBinningArray"></div>
        </div>
        
        <div class="bin-visualization">
            <p class="mb-2"><strong>Binning Algorithm:</strong> Grouping data into intervals of width ${width}</p>
            <p class="mb-0" id="binningExplanation">Calculating bin ranges...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="binningStepsContainer">
            <h6 class="text-center">Binning Steps</h6>
            <div class="steps-container" id="binningSteps"></div>
        </div>
        
        <div class="bin-results mt-3" id="binResults" style="display: none;">
            <h6 class="text-center">Bin Distribution</h6>
            <div class="table-container">
                <table class="bin-table" id="binDistributionTable">
                    <thead>
                        <tr>
                            <th>Bin Range</th>
                            <th>Count</th>
                            <th>Elements</th>
                        </tr>
                    </thead>
                    <tbody id="binTableBody"></tbody>
                </table>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterBinning" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForBinning, 'originalBinningArray');
    renderArrayInContainer([...originalArrayForBinning], 'transformedBinningArray');
    
    executeBinningByWidthAnimation(width);
}

// NEW: Execute Binning by Width Animation
function executeBinningByWidthAnimation(width) {
    const originalContainer = document.getElementById('originalBinningArray');
    const transformedContainer = document.getElementById('transformedBinningArray');
    const explanation = document.getElementById('binningExplanation');
    const stepsContainer = document.getElementById('binningSteps');
    const binResults = document.getElementById('binResults');
    const binTableBody = document.getElementById('binTableBody');
    const continueButton = document.getElementById('continueAfterBinning');
    
    const arr = originalArrayForBinning.map(val => parseFloat(val));
    const minVal = Math.min(...arr);
    const maxVal = Math.max(...arr);
    
    // Calculate number of bins based on width
    const numBins = Math.ceil((maxVal - minVal) / width);
    const actualMax = minVal + numBins * width;
    
    // Initialize bins
    const bins = Array.from({ length: numBins }, () => ({ count: 0, elements: [] }));
    let currentStep = 0;
    
    function executeBinningStep() {
        if (currentStep === 0) {
            // Step 1: Calculate statistics
            explanation.innerHTML = `Step 1: Calculating data range and bin configuration`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Data range: ${minVal} to ${maxVal}
                </div>
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Bin width: ${width}  ${numBins} bins needed
                </div>
                <div class="algorithm-step active">
                    <strong>Step 1:</strong> Actual range: ${minVal} to ${actualMax.toFixed(2)}
                </div>
            `;
            
            // Highlight min and max values
            const originalElements = originalContainer.querySelectorAll('.array-element');
            const minIndex = arr.indexOf(minVal);
            const maxIndex = arr.indexOf(maxVal);
            
            if (minIndex !== -1) {
                originalElements[minIndex].querySelector('.element-value').classList.add('bin-boundary');
            }
            if (maxIndex !== -1 && maxIndex !== minIndex) {
                originalElements[maxIndex].querySelector('.element-value').classList.add('bin-boundary');
            }
            
            currentStep++;
            setTimeout(executeBinningStep, 2000);
            
        } else if (currentStep === 1) {
            // Step 2: Create bin ranges
            explanation.innerHTML = `Step 2: Creating ${numBins} bin intervals of width ${width}`;
            
            let binRangesHTML = '';
            for (let i = 0; i < numBins; i++) {
                const binStart = minVal + i * width;
                const binEnd = minVal + (i + 1) * width;
                binRangesHTML += `
                    <div class="algorithm-step">
                        <strong>Bin ${i + 1}:</strong> [${binStart.toFixed(2)}, ${binEnd.toFixed(2)})
                    </div>
                `;
            }
            
            stepsContainer.innerHTML += binRangesHTML;
            currentStep++;
            setTimeout(executeBinningStep, 2000);
            
        } else if (currentStep === 2) {
            // Step 3: Assign elements to bins
            explanation.innerHTML = `Step 3: Assigning elements to bins`;
            
            let elementIndex = 0;
            
            function assignNextElement() {
                if (elementIndex >= arr.length) {
                    // All elements assigned
                    currentStep++;
                    executeBinningStep();
                    return;
                }
                
                const value = arr[elementIndex];
                const binIndex = Math.min(Math.floor((value - minVal) / width), numBins - 1);
                
                explanation.innerHTML = `Step 3: Assigning element [${elementIndex}] = ${value} to Bin ${binIndex + 1}`;
                
                // Highlight current element
                const transformedElements = transformedContainer.querySelectorAll('.array-element');
                const currentElement = transformedElements[elementIndex].querySelector('.element-value');
                currentElement.classList.add('bin-interval-highlight');
                
                // Update bin
                bins[binIndex].count++;
                bins[binIndex].elements.push(value);
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3:</strong> Element [${elementIndex}] = ${value}  Bin ${binIndex + 1} [${(minVal + binIndex * width).toFixed(2)}, ${(minVal + (binIndex + 1) * width).toFixed(2)})
                    </div>
                `;
                
                setTimeout(() => {
                    currentElement.classList.remove('bin-interval-highlight');
                    elementIndex++;
                    assignNextElement();
                }, 1000);
            }
            
            assignNextElement();
            
        } else if (currentStep === 3) {
            // Step 4: Display results
            explanation.innerHTML = `Step 4: Binning completed! Displaying distribution`;
            
            // Show results table
            binResults.style.display = 'block';
            
            // Populate table
            let tableHTML = '';
            let maxCount = 0;
            
            for (let i = 0; i < numBins; i++) {
                const binStart = minVal + i * width;
                const binEnd = minVal + (i + 1) * width;
                const count = bins[i].count;
                
                if (count > maxCount) maxCount = count;
                
                tableHTML += `
                    <tr>
                        <td>[${binStart.toFixed(2)}, ${binEnd.toFixed(2)})</td>
                        <td>${count}</td>
                        <td>${bins[i].elements.join(', ')}</td>
                    </tr>
                `;
            }
            
            binTableBody.innerHTML = tableHTML;
            
            // Highlight bins with maximum count
            setTimeout(() => {
                const tableRows = binTableBody.querySelectorAll('tr');
                tableRows.forEach((row, index) => {
                    if (bins[index].count === maxCount && maxCount > 0) {
                        row.classList.add('bin-interval-high-count');
                    }
                });
            }, 500);
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step 4:</strong> Binning completed! Created ${numBins} intervals with ${arr.length} total elements
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 30 seconds
            setTimeout(() => {
                returnToOriginalAfterBinning();
            }, 30000);
            
            continueButton.addEventListener('click', returnToOriginalAfterBinning);
        }
    }
    
    // Start binning process
    executeBinningStep();
}

// NEW: Return to Original after Binning
function returnToOriginalAfterBinning() {
    // Reset to original array
    myArray = [...originalArrayForBinning];
    originalArrayForBinning = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isBinningRunning = false;
    
    // Clear inputs
    binCount.value = '';
    binWidth.value = '';
    
    logOperation('Binning operation completed - returned to original array', 'info');
    showNotification('Returned to original array after binning operation', 'success');
}
// NEW: Handle UFunc Selection
function handleUfuncSelection() {
    const selectedFunc = ufuncSelect.value;
    
    // Show/hide additional parameters based on selection
    ufuncParams.style.display = 'none';
    clampLow.style.display = 'none';
    clampHigh.style.display = 'none';
    euclidRef.style.display = 'none';
    bitwiseOperand.style.display = 'none';
    leakyReluAlpha.style.display = 'none';
    
    if (selectedFunc === 'clamp') {
        ufuncParams.style.display = 'block';
        clampLow.style.display = 'block';
        clampHigh.style.display = 'block';
    } else if (selectedFunc === 'euclid_1d') {
        ufuncParams.style.display = 'block';
        euclidRef.style.display = 'block';
    } else if (selectedFunc === 'bit_and' || selectedFunc === 'bit_or' || selectedFunc === 'bit_xor') {
        ufuncParams.style.display = 'block';
        bitwiseOperand.style.display = 'block';
    } else if (selectedFunc === 'leaky_relu') {
        ufuncParams.style.display = 'block';
        leakyReluAlpha.style.display = 'block';
    }
}

// NEW: Apply Universal Function Handler
function handleApplyUfunc() {
    const selectedFunc = ufuncSelect.value;
    
    if (!selectedFunc) {
        showNotification('Please select a universal function', 'warning');
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers for numeric functions
    const numericFunctions = ['c2f', 'f2c', 'square', 'cube', 'reciprocal', 'relu', 'sigmoid', 'clamp', 
                             'zscore_elem', 'percentile_rank', 'euclid_1d', 'inc', 'dec', 'double', 'half', 
                             'neg', 'is_positive', 'is_negative', 'is_zero', 'sqroot', 'cbrt', 'sin_deg', 
                             'cos_deg', 'tan_deg', 'bit_flip', 'bit_and', 'bit_or', 'bit_xor', 'asin_deg',
                             'acos_deg', 'atan_deg', 'factorial_approx', 'leaky_relu', 'bin_0_100'];
    
    if (numericFunctions.includes(selectedFunc)) {
        let allNumbers = true;
        for (let i = 0; i < myArray.length; i++) {
            if (isNaN(parseFloat(myArray[i]))) {
                allNumbers = false;
                break;
            }
        }
        
        if (!allNumbers) {
            showNotification('This function requires all array elements to be numbers', 'danger');
            return;
        }
    }
    
    if (isUfuncRunning) {
        showNotification('A universal function operation is already in progress', 'warning');
        return;
    }
    
    isUfuncRunning = true;
    
    // Store original array
    originalArrayForUfunc = [...myArray];
    
    // Get additional parameters if needed
    let additionalParams = {};
    if (selectedFunc === 'clamp') {
        const low = parseFloat(clampLow.value);
        const high = parseFloat(clampHigh.value);
        
        if (isNaN(low) || isNaN(high) || low >= high) {
            showNotification('Please enter valid lower and upper bounds (lower < upper)', 'danger');
            isUfuncRunning = false;
            return;
        }
        
        additionalParams = { low, high };
    } else if (selectedFunc === 'euclid_1d') {
        const ref = parseFloat(euclidRef.value);
        
        if (isNaN(ref)) {
            showNotification('Please enter a valid reference point', 'danger');
            isUfuncRunning = false;
            return;
        }
        
        additionalParams = { ref };
    } else if (selectedFunc === 'bit_and' || selectedFunc === 'bit_or' || selectedFunc === 'bit_xor') {
        const operand = parseInt(bitwiseOperand.value);
        
        if (isNaN(operand)) {
            showNotification('Please enter a valid operand value', 'danger');
            isUfuncRunning = false;
            return;
        }
        
        additionalParams = { operand };
    } else if (selectedFunc === 'leaky_relu') {
        const alpha = parseFloat(leakyReluAlpha.value);
        
        if (isNaN(alpha)) {
            showNotification('Please enter a valid alpha value', 'danger');
            isUfuncRunning = false;
            return;
        }
        
        additionalParams = { alpha };
    }
    
    // Show UFunc visualization
    showUfuncVisualization(selectedFunc, additionalParams);
}

// NEW: Get Display Name for UFunc
function getUfuncDisplayName(funcName) {
    const names = {
        'c2f': 'CF',
        'f2c': 'FC',
        'square': 'Squaring',
        'cube': 'Cubing',
        'reciprocal': 'Reciprocal',
        'relu': 'ReLU',
        'sigmoid': 'Sigmoid',
        'is_even': 'Is Even Check',
        'is_odd': 'Is Odd Check',
        'clamp': 'Clamping',
        'zscore_elem': 'Z-Score',
        'percentile_rank': 'Percentile Rank',
        'to_grade': 'Grade Conversion',
        'euclid_1d': 'Euclidean Distance',
        'inc': 'Increment',
        'dec': 'Decrement',
        'double': 'Double',
        'half': 'Half',
        'neg': 'Negate',
        'is_positive': 'Is Positive',
        'is_negative': 'Is Negative',
        'is_zero': 'Is Zero',
        'sqroot': 'Square Root',
        'cbrt': 'Cube Root',
        'sin_deg': 'Sine',
        'cos_deg': 'Cosine',
        'tan_deg': 'Tangent',
        'bit_flip': 'Bit Flip',
        'bit_and': 'Bitwise AND',
        'bit_or': 'Bitwise OR',
        'bit_xor': 'Bitwise XOR',
        'asin_deg': 'Arcsine',
        'acos_deg': 'Arccosine',
        'atan_deg': 'Arctangent',
        'factorial_approx': 'Factorial',
        'leaky_relu': 'Leaky ReLU',
        'bin_0_100': 'Bin to 0-100'
    };
    return names[funcName] || funcName;
}

// NEW: Show UFunc Visualization
function showUfuncVisualization(funcName, params = {}) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    
    let title = '';
    let description = '';
    
    // Set title and description based on function
    switch(funcName) {
        case 'c2f':
            title = 'Celsius to Fahrenheit Conversion';
            description = 'Convert temperature values from Celsius to Fahrenheit using: F = (C  9/5) + 32';
            break;
        case 'f2c':
            title = 'Fahrenheit to Celsius Conversion';
            description = 'Convert temperature values from Fahrenheit to Celsius using: C = (F - 32)  5/9';
            break;
        case 'square':
            title = 'Square Function';
            description = 'Calculate the square of each element: x = x  x';
            break;
        case 'cube':
            title = 'Cube Function';
            description = 'Calculate the cube of each element: x = x  x  x';
            break;
        case 'reciprocal':
            title = 'Reciprocal Function';
            description = 'Calculate the reciprocal of each element: 1/x';
            break;
        case 'relu':
            title = 'ReLU Activation Function';
            description = 'Rectified Linear Unit: returns x if x > 0, otherwise returns 0';
            break;
        case 'sigmoid':
            title = 'Sigmoid Activation Function';
            description = 'Sigmoid function: 1 / (1 + e^(-x)) - maps values to range (0, 1)';
            break;
        case 'is_even':
            title = 'Is Even Function';
            description = 'Check if each element is even: returns 1 if even, 0 if odd';
            break;
        case 'is_odd':
            title = 'Is Odd Function';
            description = 'Check if each element is odd: returns 1 if odd, 0 if even';
            break;
        case 'clamp':
            title = `Clamp Function (${params.low} to ${params.high})`;
            description = `Constrain values to range [${params.low}, ${params.high}]: returns lower bound if x < lower, upper bound if x > upper, otherwise x`;
            break;
        // NEW FUNCTIONS
        case 'zscore_elem':
            title = 'Z-Score Normalization';
            description = 'Standardize values using Z-score: (x - mean) / standard deviation';
            break;
        case 'percentile_rank':
            title = 'Percentile Rank';
            description = 'Calculate percentile rank for each value: (number of values below x / total values)  100';
            break;
        case 'to_grade':
            title = 'Grade Conversion';
            description = 'Convert numerical scores to letter grades: A (90-100), B (80-89), C (70-79), D (60-69), F (0-59)';
            break;
        case 'euclid_1d':
            title = `Euclidean Distance (from ${params.ref})`;
            description = `Calculate 1D Euclidean distance from reference point: |x - ${params.ref}|`;
            break;
        case 'inc':
            title = 'Increment';
            description = 'Increase each element by 1: x + 1';
            break;
        case 'dec':
            title = 'Decrement';
            description = 'Decrease each element by 1: x - 1';
            break;
        case 'double':
            title = 'Double';
            description = 'Multiply each element by 2: x  2';
            break;
        case 'half':
            title = 'Half';
            description = 'Divide each element by 2: x  2';
            break;
        case 'neg':
            title = 'Negate';
            description = 'Change sign of each element: -x';
            break;
        case 'is_positive':
            title = 'Is Positive Check';
            description = 'Check if element is positive: returns 1 if x > 0, 0 otherwise';
            break;
        case 'is_negative':
            title = 'Is Negative Check';
            description = 'Check if element is negative: returns 1 if x < 0, 0 otherwise';
            break;
        case 'is_zero':
            title = 'Is Zero Check';
            description = 'Check if element is zero: returns 1 if x = 0, 0 otherwise';
            break;
        case 'sqroot':
            title = 'Square Root';
            description = 'Calculate square root of each element: x';
            break;
        case 'cbrt':
            title = 'Cube Root';
            description = 'Calculate cube root of each element: x';
            break;
        case 'sin_deg':
            title = 'Sine (Degrees)';
            description = 'Calculate sine of each element (in degrees): sin(x)';
            break;
        case 'cos_deg':
            title = 'Cosine (Degrees)';
            description = 'Calculate cosine of each element (in degrees): cos(x)';
            break;
        case 'tan_deg':
            title = 'Tangent (Degrees)';
            description = 'Calculate tangent of each element (in degrees): tan(x)';
            break;
        // NEWLY ADDED FUNCTIONS
        case 'bit_flip':
            title = 'Bit Flip';
            description = 'Flip all bits of each element (bitwise NOT operation): ~x';
            break;
        case 'bit_and':
            title = `Bitwise AND (with ${params.operand})`;
            description = `Perform bitwise AND operation with ${params.operand}: x & ${params.operand}`;
            break;
        case 'bit_or':
            title = `Bitwise OR (with ${params.operand})`;
            description = `Perform bitwise OR operation with ${params.operand}: x | ${params.operand}`;
            break;
        case 'bit_xor':
            title = `Bitwise XOR (with ${params.operand})`;
            description = `Perform bitwise XOR operation with ${params.operand}: x ^ ${params.operand}`;
            break;
        case 'asin_deg':
            title = 'Arcsine (Degrees)';
            description = 'Calculate arcsine of each element (result in degrees): asin(x)  180/';
            break;
        case 'acos_deg':
            title = 'Arccosine (Degrees)';
            description = 'Calculate arccosine of each element (result in degrees): acos(x)  180/';
            break;
        case 'atan_deg':
            title = 'Arctangent (Degrees)';
            description = 'Calculate arctangent of each element (result in degrees): atan(x)  180/';
            break;
        case 'factorial_approx':
            title = 'Factorial (Approximation)';
            description = 'Calculate approximate factorial using Stirling\'s approximation: (2x)  (x/e)^x';
            break;
        case 'leaky_relu':
            title = `Leaky ReLU (alpha=${params.alpha})`;
            description = `Leaky Rectified Linear Unit: returns x if x > 0, otherwise returns ${params.alpha}  x`;
            break;
        case 'bin_0_100':
            title = 'Bin to 0-100';
            description = 'Convert values to bins: 0-200, 21-401, 41-602, 61-803, 81-1004';
            break;
    }
    
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">${title}</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalUfuncArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">After ${getUfuncDisplayName(funcName)}</div>
            <div class="transformed-array-container" id="transformedUfuncArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Universal Function:</strong> ${description}</p>
            <p class="mb-0" id="ufuncExplanation">Starting universal function application...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="ufuncStepsContainer">
            <h6 class="text-center">Function Application Steps</h6>
            <div class="steps-container" id="ufuncSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterUfunc" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForUfunc, 'originalUfuncArray');
    renderArrayInContainer([...originalArrayForUfunc], 'transformedUfuncArray');
    
    performUfuncAnimation(funcName, params);
}

// NEW: Calculate array statistics for z-score and percentile
function calculateArrayStats(arr) {
    const mean = arr.reduce((sum, val) => sum + val, 0) / arr.length;
    const variance = arr.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / arr.length;
    const stdDev = Math.sqrt(variance);
    return { mean, stdDev };
}

// NEW: Convert number to grade
function numberToGrade(score) {
    if (score >= 90) return 'A';
    if (score >= 80) return 'B';
    if (score >= 70) return 'C';
    if (score >= 60) return 'D';
    return 'F';
}

// NEW: Convert number to bin (0-100)
function numberToBin(value) {
    if (value <= 20) return 0;
    if (value <= 40) return 1;
    if (value <= 60) return 2;
    if (value <= 80) return 3;
    return 4;
}

// NEW: Stirling's approximation for factorial
function stirlingFactorial(n) {
    if (n <= 1) return 1;
    return Math.sqrt(2 * Math.PI * n) * Math.pow(n / Math.E, n);
}

// NEW: Perform UFunc Animation
function performUfuncAnimation(funcName, params = {}) {
    const originalContainer = document.getElementById('originalUfuncArray');
    const transformedContainer = document.getElementById('transformedUfuncArray');
    const explanation = document.getElementById('ufuncExplanation');
    const stepsContainer = document.getElementById('ufuncSteps');
    const continueButton = document.getElementById('continueAfterUfunc');
    
    const originalArray = originalArrayForUfunc.map(val => {
        const numericFunctions = ['c2f', 'f2c', 'square', 'cube', 'reciprocal', 'relu', 'sigmoid', 'clamp', 
                                 'zscore_elem', 'percentile_rank', 'euclid_1d', 'inc', 'dec', 'double', 'half', 
                                 'neg', 'is_positive', 'is_negative', 'is_zero', 'sqroot', 'cbrt', 'sin_deg', 
                                 'cos_deg', 'tan_deg', 'bit_flip', 'bit_and', 'bit_or', 'bit_xor', 'asin_deg',
                                 'acos_deg', 'atan_deg', 'factorial_approx', 'leaky_relu', 'bin_0_100'];
        if (numericFunctions.includes(funcName)) {
            return parseFloat(val);
        }
        return val;
    });
    
    let transformedArray = [...originalArray];
    let currentIndex = 0;
    
    // Pre-calculate statistics for functions that need them
    let arrayStats = null;
    if (funcName === 'zscore_elem' || funcName === 'percentile_rank') {
        arrayStats = calculateArrayStats(originalArray);
    }
    
    // Helper function to format numbers with up to 3 decimals
    function formatNumber(num) {
        if (typeof num !== 'number') return num;
        // Check if it's an integer
        if (num % 1 === 0) return num.toString();
        // Format with up to 3 decimal places
        return parseFloat(num.toFixed(3)).toString();
    }
    
    function performUfuncStep() {
        if (currentIndex >= originalArray.length) {
            // Operation completed
            explanation.innerHTML = `<strong>Universal Function Application Completed!</strong> Applied ${getUfuncDisplayName(funcName)} to all elements.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Successfully applied ${getUfuncDisplayName(funcName)} to all ${originalArray.length} elements
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterUfunc();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterUfunc);
            
            return;
        }
        
        const originalValue = originalArray[currentIndex];
        let transformedValue;
        let stepDescription = '';
        
        // Apply the selected function
        switch(funcName) {
            case 'c2f':
                transformedValue = (originalValue * 1.8) + 32;
                stepDescription = `[${currentIndex}]: ${formatNumber(originalValue)}C  (${formatNumber(originalValue)}  1.8) + 32 = ${formatNumber(transformedValue)}F`;
                break;
            case 'f2c':
                transformedValue = (originalValue - 32) * 5/9;
                stepDescription = `[${currentIndex}]: ${formatNumber(originalValue)}F  (${formatNumber(originalValue)} - 32)  5/9 = ${formatNumber(transformedValue)}C`;
                break;
            case 'square':
                transformedValue = originalValue * originalValue;
                stepDescription = `[${currentIndex}]: ${formatNumber(originalValue)} = ${formatNumber(originalValue)}  ${formatNumber(originalValue)} = ${formatNumber(transformedValue)}`;
                break;
            case 'cube':
                transformedValue = originalValue * originalValue * originalValue;
                stepDescription = `[${currentIndex}]: ${formatNumber(originalValue)} = ${formatNumber(originalValue)}  ${formatNumber(originalValue)}  ${formatNumber(originalValue)} = ${formatNumber(transformedValue)}`;
                break;
            case 'reciprocal':
                transformedValue = 1 / originalValue;
                stepDescription = `[${currentIndex}]: 1/${formatNumber(originalValue)} = ${formatNumber(transformedValue)}`;
                break;
            case 'relu':
                transformedValue = Math.max(0, originalValue);
                stepDescription = `[${currentIndex}]: ReLU(${formatNumber(originalValue)}) = max(0, ${formatNumber(originalValue)}) = ${formatNumber(transformedValue)}`;
                break;
            case 'sigmoid':
                transformedValue = 1 / (1 + Math.exp(-originalValue));
                stepDescription = `[${currentIndex}]: sigmoid(${formatNumber(originalValue)}) = 1 / (1 + e^(-${formatNumber(originalValue)})) = ${formatNumber(transformedValue)}`;
                break;
            case 'is_even':
                transformedValue = (parseInt(originalValue) % 2 === 0) ? 1 : 0;
                stepDescription = `[${currentIndex}]: is_even(${formatNumber(originalValue)}) = (${formatNumber(originalValue)} % 2 == 0) = ${transformedValue}`;
                break;
            case 'is_odd':
                transformedValue = (parseInt(originalValue) % 2 !== 0) ? 1 : 0;
                stepDescription = `[${currentIndex}]: is_odd(${formatNumber(originalValue)}) = (${formatNumber(originalValue)} % 2 != 0) = ${transformedValue}`;
                break;
            case 'clamp':
                transformedValue = Math.max(params.low, Math.min(params.high, originalValue));
                let clampAction = 'unchanged';
                if (originalValue < params.low) clampAction = `clamped to lower bound ${formatNumber(params.low)}`;
                else if (originalValue > params.high) clampAction = `clamped to upper bound ${formatNumber(params.high)}`;
                stepDescription = `[${currentIndex}]: clamp(${formatNumber(originalValue)}, ${formatNumber(params.low)}, ${formatNumber(params.high)}) = ${formatNumber(transformedValue)} (${clampAction})`;
                break;
            // NEW FUNCTIONS
            case 'zscore_elem':
                transformedValue = (originalValue - arrayStats.mean) / arrayStats.stdDev;
                stepDescription = `[${currentIndex}]: zscore(${formatNumber(originalValue)}) = (${formatNumber(originalValue)} - ${formatNumber(arrayStats.mean)}) / ${formatNumber(arrayStats.stdDev)} = ${formatNumber(transformedValue)}`;
                break;
            case 'percentile_rank':
                const valuesBelow = originalArray.filter(val => val < originalValue).length;
                transformedValue = (valuesBelow / originalArray.length) * 100;
                stepDescription = `[${currentIndex}]: percentile(${formatNumber(originalValue)}) = (${valuesBelow} values below / ${originalArray.length} total)  100 = ${formatNumber(transformedValue)}%`;
                break;
            case 'to_grade':
                transformedValue = numberToGrade(originalValue);
                stepDescription = `[${currentIndex}]: grade(${formatNumber(originalValue)}) = ${transformedValue}`;
                break;
            case 'euclid_1d':
                transformedValue = Math.abs(originalValue - params.ref);
                stepDescription = `[${currentIndex}]: euclid(${formatNumber(originalValue)}, ${formatNumber(params.ref)}) = |${formatNumber(originalValue)} - ${formatNumber(params.ref)}| = ${formatNumber(transformedValue)}`;
                break;
            case 'inc':
                transformedValue = originalValue + 1;
                stepDescription = `[${currentIndex}]: inc(${formatNumber(originalValue)}) = ${formatNumber(originalValue)} + 1 = ${formatNumber(transformedValue)}`;
                break;
            case 'dec':
                transformedValue = originalValue - 1;
                stepDescription = `[${currentIndex}]: dec(${formatNumber(originalValue)}) = ${formatNumber(originalValue)} - 1 = ${formatNumber(transformedValue)}`;
                break;
            case 'double':
                transformedValue = originalValue * 2;
                stepDescription = `[${currentIndex}]: double(${formatNumber(originalValue)}) = ${formatNumber(originalValue)}  2 = ${formatNumber(transformedValue)}`;
                break;
            case 'half':
                transformedValue = originalValue / 2;
                stepDescription = `[${currentIndex}]: half(${formatNumber(originalValue)}) = ${formatNumber(originalValue)}  2 = ${formatNumber(transformedValue)}`;
                break;
            case 'neg':
                transformedValue = -originalValue;
                stepDescription = `[${currentIndex}]: neg(${formatNumber(originalValue)}) = -${formatNumber(originalValue)} = ${formatNumber(transformedValue)}`;
                break;
            case 'is_positive':
                transformedValue = originalValue > 0 ? 1 : 0;
                stepDescription = `[${currentIndex}]: is_positive(${formatNumber(originalValue)}) = (${formatNumber(originalValue)} > 0) = ${transformedValue}`;
                break;
            case 'is_negative':
                transformedValue = originalValue < 0 ? 1 : 0;
                stepDescription = `[${currentIndex}]: is_negative(${formatNumber(originalValue)}) = (${formatNumber(originalValue)} < 0) = ${transformedValue}`;
                break;
            case 'is_zero':
                transformedValue = originalValue === 0 ? 1 : 0;
                stepDescription = `[${currentIndex}]: is_zero(${formatNumber(originalValue)}) = (${formatNumber(originalValue)} == 0) = ${transformedValue}`;
                break;
            case 'sqroot':
                transformedValue = Math.sqrt(originalValue);
                stepDescription = `[${currentIndex}]: sqrt(${formatNumber(originalValue)}) = ${formatNumber(transformedValue)}`;
                break;
            case 'cbrt':
                transformedValue = Math.cbrt(originalValue);
                stepDescription = `[${currentIndex}]: cbrt(${formatNumber(originalValue)}) = ${formatNumber(transformedValue)}`;
                break;
            case 'sin_deg':
                transformedValue = Math.sin(originalValue * Math.PI / 180);
                stepDescription = `[${currentIndex}]: sin(${formatNumber(originalValue)}) = ${formatNumber(transformedValue)}`;
                break;
            case 'cos_deg':
                transformedValue = Math.cos(originalValue * Math.PI / 180);
                stepDescription = `[${currentIndex}]: cos(${formatNumber(originalValue)}) = ${formatNumber(transformedValue)}`;
                break;
            case 'tan_deg':
                transformedValue = Math.tan(originalValue * Math.PI / 180);
                stepDescription = `[${currentIndex}]: tan(${formatNumber(originalValue)}) = ${formatNumber(transformedValue)}`;
                break;
            // NEWLY ADDED FUNCTIONS
            case 'bit_flip':
                transformedValue = ~parseInt(originalValue);
                stepDescription = `[${currentIndex}]: bit_flip(${formatNumber(originalValue)}) = ~${formatNumber(originalValue)} = ${transformedValue}`;
                break;
            case 'bit_and':
                transformedValue = parseInt(originalValue) & params.operand;
                stepDescription = `[${currentIndex}]: bit_and(${formatNumber(originalValue)}, ${params.operand}) = ${formatNumber(originalValue)} & ${params.operand} = ${transformedValue}`;
                break;
            case 'bit_or':
                transformedValue = parseInt(originalValue) | params.operand;
                stepDescription = `[${currentIndex}]: bit_or(${formatNumber(originalValue)}, ${params.operand}) = ${formatNumber(originalValue)} | ${params.operand} = ${transformedValue}`;
                break;
            case 'bit_xor':
                transformedValue = parseInt(originalValue) ^ params.operand;
                stepDescription = `[${currentIndex}]: bit_xor(${formatNumber(originalValue)}, ${params.operand}) = ${formatNumber(originalValue)} ^ ${params.operand} = ${transformedValue}`;
                break;
            case 'asin_deg':
                transformedValue = Math.asin(originalValue) * 180 / Math.PI;
                stepDescription = `[${currentIndex}]: asin(${formatNumber(originalValue)}) = ${formatNumber(transformedValue)}`;
                break;
            case 'acos_deg':
                transformedValue = Math.acos(originalValue) * 180 / Math.PI;
                stepDescription = `[${currentIndex}]: acos(${formatNumber(originalValue)}) = ${formatNumber(transformedValue)}`;
                break;
            case 'atan_deg':
                transformedValue = Math.atan(originalValue) * 180 / Math.PI;
                stepDescription = `[${currentIndex}]: atan(${formatNumber(originalValue)}) = ${formatNumber(transformedValue)}`;
                break;
            case 'factorial_approx':
                transformedValue = stirlingFactorial(originalValue);
                stepDescription = `[${currentIndex}]: factorial_approx(${formatNumber(originalValue)}) = (2${formatNumber(originalValue)})  (${formatNumber(originalValue)}/e)^${formatNumber(originalValue)} = ${formatNumber(transformedValue)}`;
                break;
            case 'leaky_relu':
                transformedValue = originalValue > 0 ? originalValue : params.alpha * originalValue;
                stepDescription = `[${currentIndex}]: leaky_relu(${formatNumber(originalValue)}, ${params.alpha}) = ${originalValue > 0 ? formatNumber(originalValue) : `${formatNumber(params.alpha)}  ${formatNumber(originalValue)}`} = ${formatNumber(transformedValue)}`;
                break;
            case 'bin_0_100':
                transformedValue = numberToBin(originalValue);
                stepDescription = `[${currentIndex}]: bin_0_100(${formatNumber(originalValue)}) = ${transformedValue}`;
                break;
        }
        
        transformedArray[currentIndex] = transformedValue;
        
        // Update explanation
        explanation.innerHTML = `Applying ${getUfuncDisplayName(funcName)} to element at index ${currentIndex}`;
        
        // Highlight current element
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        
        const originalElement = originalElements[currentIndex].querySelector('.element-value');
        const transformedElement = transformedElements[currentIndex].querySelector('.element-value');
        
        originalElement.classList.add('traverse-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex + 1}:</strong> ${stepDescription}
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Update transformed array display with formatted values
            const formattedTransformedArray = transformedArray.map(val => {
                if (typeof val === 'number' && funcName !== 'to_grade') {
                    return formatNumber(val);
                }
                return val;
            });
            renderArrayInContainer(formattedTransformedArray, 'transformedUfuncArray');
            
            // Highlight the transformed element
            transformedElement.classList.add('create', 'bounce');
            
            // Remove current highlight and mark as completed
            originalElement.classList.remove('traverse-current');
            originalElement.classList.add('traverse-completed');
            
            currentIndex++;
            performUfuncStep();
        }, 1500);
    }
    
    // Start UFunc application process
    performUfuncStep();
}

// NEW: Return to Original after UFunc
function returnToOriginalAfterUfunc() {
    // Reset to original array
    myArray = [...originalArrayForUfunc];
    originalArrayForUfunc = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isUfuncRunning = false;
    
    // Clear selection and inputs
    ufuncSelect.value = '';
    ufuncParams.style.display = 'none';
    clampLow.value = '';
    clampHigh.value = '';
    euclidRef.value = '';
    bitwiseOperand.value = '';
    leakyReluAlpha.value = '';
    
    logOperation('Universal function application completed - returned to original array', 'info');
    showNotification('Returned to original array after universal function application', 'success');
}
// NEW: Load Stock Prices Handler
// Update your existing handleLoadStockPrices function
function handleLoadStockPrices() {
    const input = stockPricesInput.value.trim();
    
    if (input === '') {
        showNotification('Please enter stock prices', 'warning');
        stockPricesInput.focus();
        return;
    }
    
    // Parse input as numbers
    const prices = input.split(',').map(item => {
        const num = parseFloat(item.trim());
        if (isNaN(num)) {
            showNotification(`Invalid number: ${item}`, 'danger');
            return null;
        }
        return num;
    }).filter(item => item !== null);
    
    if (prices.length < 2) {
        showNotification('Please enter at least 2 stock prices', 'warning');
        return;
    }
    
    // Store original prices
    originalStockPrices = [...prices];
    
    // NEW: Generate open and close prices for gap analysis
    openPrices = prices.map(price => {
        // Simulate open price with some variation (2%)
        const variation = (Math.random() - 0.5) * 0.04;
        return price * (1 + variation);
    });
    
    closePrices = [...prices]; // Use input prices as close prices
    
    // Load into main array for visualization
    myArray = prices.map(price => price.toString());
    
    renderArray();
    updateStats();
    
    // Highlight all prices
    setTimeout(() => {
        myArray.forEach((_, index) => {
            highlightElement(index, 'stock-price');
        });
    }, 100);
    
    logOperation(`Loaded ${prices.length} stock prices with open/close data`, 'success');
    showNotification('Stock prices loaded successfully with open/close data', 'success');
}
// NEW: Handle Stock Market Operations
function handleStockOperation(operation) {
    if (originalStockPrices.length === 0) {
        showNotification('Please load stock prices first', 'warning');
        return;
    }
    
    if (isStockOperationRunning) {
        showNotification('A stock operation is already in progress', 'warning');
        return;
    }
    
    isStockOperationRunning = true;
    
    switch (operation) {
        case 'dailyReturns':
            performDailyReturnsCalculation();
            break;
        case 'logReturns':
            performLogReturnsCalculation();
            break;
        case 'cumulativeReturns':
            performCumulativeReturnsCalculation();
            break;
        case 'totalReturn':
            performTotalReturnCalculation();
            break;
        case 'priceDifference':
            performPriceDifferenceCalculation();
            break;
        case 'priceMomentum':
    performPriceMomentumCalculation();
    break;
case 'rateOfChange':
    performRateOfChangeCalculation();
    break;
case 'gapAnalysis':
    performGapAnalysisCalculation();
    break;
case 'intradayGain':
    performIntradayGainCalculation();
    break; 
case 'sma':
    performSMACalculation();
    break;
case 'ema':
    performEMACalculation();
    break;
case 'macd':
    performMACDCalculation();
    break;
case 'macdSignal':
    performMACDSignalCalculation();
    break;
case 'bollingerMiddle':
    performBollingerMiddleCalculation();
    break;
case 'bollingerUpper':
    performBollingerUpperCalculation();
    break;       
    }
}

// NEW: Perform Daily Returns Calculation with Animation
function performDailyReturnsCalculation() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Daily Returns Calculation</h5>
        
        <div class="array-group">
            <div class="array-label">Stock Prices</div>
            <div class="original-array-container" id="originalPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Daily Returns</div>
            <div class="transformed-array-container" id="returnsArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> returns[i] = (price[i] - price[i-1]) / price[i-1]</p>
            <p class="mb-0" id="returnsExplanation">Starting daily returns calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="returnsStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="returnsSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterReturns" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalStockPrices.map(p => p.toString()), 'originalPricesArray');
    renderArrayInContainer([], 'returnsArray');
    
    executeDailyReturnsAnimation();
}

// NEW: Execute Daily Returns Animation
function executeDailyReturnsAnimation() {
    const originalContainer = document.getElementById('originalPricesArray');
    const returnsContainer = document.getElementById('returnsArray');
    const explanation = document.getElementById('returnsExplanation');
    const stepsContainer = document.getElementById('returnsSteps');
    const continueButton = document.getElementById('continueAfterReturns');
    
    const prices = [...originalStockPrices];
    const dailyReturns = [];
    let step = 0;
    
    function executeReturnsStep(i) {
        if (i >= prices.length) {
            // Calculation completed
            explanation.innerHTML = `<strong>Daily Returns Calculation Completed!</strong>`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> All daily returns calculated successfully
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToStockPrices();
            }, 5000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            
            return;
        }
        
        if (i === 0) {
            // First element - no return calculation
            explanation.innerHTML = `Step ${step + 1}: First price - no daily return calculation`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step + 1}:</strong> First price (${prices[i]}) - no return calculation
                </div>
            `;
            
            dailyReturns.push('N/A');
            renderArrayInContainer(dailyReturns, 'returnsArray');
            
            step++;
            setTimeout(() => executeReturnsStep(i + 1), 1500);
            return;
        }
        
        // Calculate daily return
        const currentPrice = prices[i];
        const previousPrice = prices[i - 1];
        const dailyReturn = (currentPrice - previousPrice) / previousPrice;
        
        explanation.innerHTML = `Step ${step + 1}: Calculating return for day ${i}<br>
                                (${currentPrice} - ${previousPrice}) / ${previousPrice} = ${(dailyReturn * 100).toFixed(2)}%`;
        
        // Highlight the prices being used
        const originalElements = originalContainer.querySelectorAll('.array-element');
        originalElements[i - 1].querySelector('.element-value').classList.add('sorting-compared');
        originalElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step + 1}:</strong> Return[${i}] = (${currentPrice} - ${previousPrice}) / ${previousPrice} = ${(dailyReturn * 100).toFixed(2)}%
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            originalElements[i - 1].querySelector('.element-value').classList.remove('sorting-compared');
            originalElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            // Add the calculated return
            dailyReturns.push((dailyReturn * 100).toFixed(2) + '%');
            renderArrayInContainer(dailyReturns, 'returnsArray');
            
            // Highlight the return value
            const returnsElements = returnsContainer.querySelectorAll('.array-element');
            const returnElement = returnsElements[i].querySelector('.element-value');
            returnElement.classList.add('daily-return');
            returnElement.classList.add(dailyReturn >= 0 ? 'positive-return' : 'negative-return');
            
            step++;
            executeReturnsStep(i + 1);
        }, 2000);
    }
    
    // Start calculation
    executeReturnsStep(0);
}

// NEW: Perform Log Returns Calculation (similar structure)
function performLogReturnsCalculation() {
    // Similar structure to performDailyReturnsCalculation but with log formula
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Log Returns Calculation</h5>
        
        <div class="array-group">
            <div class="array-label">Stock Prices</div>
            <div class="original-array-container" id="originalPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Log Returns</div>
            <div class="transformed-array-container" id="logReturnsArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> log_returns[i] = log(price[i] / price[i-1])</p>
            <p class="mb-0" id="logReturnsExplanation">Starting log returns calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="logReturnsStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="logReturnsSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterLogReturns" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalStockPrices.map(p => p.toString()), 'originalPricesArray');
    renderArrayInContainer([], 'logReturnsArray');
    
    executeLogReturnsAnimation();
}

// NEW: Execute Log Returns Animation
function executeLogReturnsAnimation() {
    const originalContainer = document.getElementById('originalPricesArray');
    const logReturnsContainer = document.getElementById('logReturnsArray');
    const explanation = document.getElementById('logReturnsExplanation');
    const stepsContainer = document.getElementById('logReturnsSteps');
    const continueButton = document.getElementById('continueAfterLogReturns');
    
    const prices = [...originalStockPrices];
    const logReturns = [];
    let step = 0;
    
    function executeLogReturnsStep(i) {
        if (i >= prices.length) {
            explanation.innerHTML = `<strong>Log Returns Calculation Completed!</strong>`;
            continueButton.style.display = 'block';
            
            setTimeout(() => {
                returnToStockPrices();
            }, 5000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            return;
        }
        
        if (i === 0) {
            explanation.innerHTML = `Step ${step + 1}: First price - no log return calculation`;
            logReturns.push('N/A');
            renderArrayInContainer(logReturns, 'logReturnsArray');
            
            step++;
            setTimeout(() => executeLogReturnsStep(i + 1), 1500);
            return;
        }
        
        const currentPrice = prices[i];
        const previousPrice = prices[i - 1];
        const logReturn = Math.log(currentPrice / previousPrice);
        
        explanation.innerHTML = `Step ${step + 1}: Calculating log return for day ${i}<br>
                                log(${currentPrice} / ${previousPrice}) = ${logReturn.toFixed(4)}`;
        
        const originalElements = originalContainer.querySelectorAll('.array-element');
        originalElements[i - 1].querySelector('.element-value').classList.add('sorting-compared');
        originalElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step + 1}:</strong> Log_Return[${i}] = log(${currentPrice} / ${previousPrice}) = ${logReturn.toFixed(4)}
            </div>
        `;
        
        setTimeout(() => {
            originalElements[i - 1].querySelector('.element-value').classList.remove('sorting-compared');
            originalElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            logReturns.push(logReturn.toFixed(4));
            renderArrayInContainer(logReturns, 'logReturnsArray');
            
            const logReturnElements = logReturnsContainer.querySelectorAll('.array-element');
            const returnElement = logReturnElements[i].querySelector('.element-value');
            returnElement.classList.add('log-return');
            returnElement.classList.add(logReturn >= 0 ? 'positive-return' : 'negative-return');
            
            step++;
            executeLogReturnsStep(i + 1);
        }, 2000);
    }
    
    executeLogReturnsStep(0);
}

// NEW: Perform Cumulative Returns Calculation with Animation
function performCumulativeReturnsCalculation() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Cumulative Returns Calculation</h5>
        
        <div class="array-group">
            <div class="array-label">Stock Prices</div>
            <div class="original-array-container" id="originalPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Cumulative Returns</div>
            <div class="transformed-array-container" id="cumulativeReturnsArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> cumulative_returns[i] = (price[i] - price[0]) / price[0]</p>
            <p class="mb-2"><strong>Business Insight:</strong> Shows total return from initial investment to each point in time</p>
            <p class="mb-0" id="cumulativeExplanation">Starting cumulative returns calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="cumulativeStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="cumulativeSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Initial Investment Value</div>
            <div class="stats-value" id="initialInvestmentValue">${originalStockPrices[0]}</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterCumulative" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalStockPrices.map(p => p.toString()), 'originalPricesArray');
    renderArrayInContainer([], 'cumulativeReturnsArray');
    
    executeCumulativeReturnsAnimation();
}

// NEW: Execute Cumulative Returns Animation
function executeCumulativeReturnsAnimation() {
    const originalContainer = document.getElementById('originalPricesArray');
    const cumulativeContainer = document.getElementById('cumulativeReturnsArray');
    const explanation = document.getElementById('cumulativeExplanation');
    const stepsContainer = document.getElementById('cumulativeSteps');
    const continueButton = document.getElementById('continueAfterCumulative');
    const initialInvestmentValue = document.getElementById('initialInvestmentValue');
    
    const prices = [...originalStockPrices];
    const cumulativeReturns = [];
    const initialPrice = prices[0];
    let step = 0;
    
    function executeCumulativeStep(i) {
        if (i >= prices.length) {
            // Calculation completed
            explanation.innerHTML = `<strong>Cumulative Returns Calculation Completed!</strong><br>
                                    Total period return: ${((prices[prices.length-1] - initialPrice) / initialPrice * 100).toFixed(2)}%`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final Analysis:</strong> 
                    Initial: ${initialPrice} | Final: ${prices[prices.length-1]} | 
                    Total Return: ${((prices[prices.length-1] - initialPrice) / initialPrice * 100).toFixed(2)}%
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 8 seconds (more time for analysis)
            setTimeout(() => {
                returnToStockPrices();
            }, 8000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            
            return;
        }
        
        const currentPrice = prices[i];
        const cumulativeReturn = (currentPrice - initialPrice) / initialPrice;
        
        explanation.innerHTML = `Step ${step + 1}: Day ${i} Cumulative Return<br>
                                (Current: ${currentPrice} - Initial: ${initialPrice}) / Initial: ${initialPrice}<br>
                                = ${(cumulativeReturn * 100).toFixed(2)}% cumulative return`;
        
        // Highlight the prices being used
        const originalElements = originalContainer.querySelectorAll('.array-element');
        originalElements[0].querySelector('.element-value').classList.add('sorting-compared');
        originalElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Day ${i}:</strong> 
                Cumulative Return = (${currentPrice} - ${initialPrice}) / ${initialPrice} = ${(cumulativeReturn * 100).toFixed(2)}%<br>
                <small>Investment growth from day 0 to day ${i}</small>
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            originalElements[0].querySelector('.element-value').classList.remove('sorting-compared');
            originalElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            // Add the calculated cumulative return
            cumulativeReturns.push((cumulativeReturn * 100).toFixed(2) + '%');
            renderArrayInContainer(cumulativeReturns, 'cumulativeReturnsArray');
            
            // Highlight the cumulative return value
            const cumulativeElements = cumulativeContainer.querySelectorAll('.array-element');
            const cumulativeElement = cumulativeElements[i].querySelector('.element-value');
            cumulativeElement.classList.add('cumulative-return');
            cumulativeElement.classList.add(cumulativeReturn >= 0 ? 'positive-return' : 'negative-return');
            
            // Show investment value growth
            if (i > 0) {
                const investmentValue = initialPrice * (1 + cumulativeReturn);
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Portfolio Value Day ${i}:</strong> 
                        $${investmentValue.toFixed(2)} (Initial: $${initialPrice})
                    </div>
                `;
            }
            
            step++;
            executeCumulativeStep(i + 1);
        }, 2500);
    }
    
    // Start calculation
    executeCumulativeStep(0);
}

// NEW: Perform Total Return Calculation with Animation
function performTotalReturnCalculation() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Total Return Analysis</h5>
        
        <div class="array-group">
            <div class="array-label">Stock Prices Over Time</div>
            <div class="original-array-container" id="originalPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Investment Performance</div>
            <div class="transformed-array-container" id="performanceArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> total_return = (price[last] - price[0]) / price[0]</p>
            <p class="mb-2"><strong>Business Insight:</strong> Overall investment performance across entire period</p>
            <p class="mb-0" id="totalReturnExplanation">Starting total return analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="totalReturnStepsContainer">
            <h6 class="text-center">Investment Analysis</h6>
            <div class="steps-container" id="totalReturnSteps"></div>
        </div>
        
        <div class="row mt-3">
            <div class="col-md-6">
                <div class="stats-card">
                    <div>Initial Price</div>
                    <div class="stats-value" id="initialPriceValue">-</div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="stats-card">
                    <div>Final Price</div>
                    <div class="stats-value" id="finalPriceValue">-</div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="stats-card">
                    <div>Total Return</div>
                    <div class="stats-value" id="totalReturnValue">-</div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="stats-card">
                    <div>Performance</div>
                    <div class="stats-value" id="performanceValue">-</div>
                </div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterTotalReturn" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalStockPrices.map(p => p.toString()), 'originalPricesArray');
    renderArrayInContainer(['Analysis in progress...'], 'performanceArray');
    
    executeTotalReturnAnimation();
}

// NEW: Execute Total Return Animation
function executeTotalReturnAnimation() {
    const originalContainer = document.getElementById('originalPricesArray');
    const performanceContainer = document.getElementById('performanceArray');
    const explanation = document.getElementById('totalReturnExplanation');
    const stepsContainer = document.getElementById('totalReturnSteps');
    const continueButton = document.getElementById('continueAfterTotalReturn');
    
    const initialPriceValue = document.getElementById('initialPriceValue');
    const finalPriceValue = document.getElementById('finalPriceValue');
    const totalReturnValue = document.getElementById('totalReturnValue');
    const performanceValue = document.getElementById('performanceValue');
    
    const prices = [...originalStockPrices];
    const initialPrice = prices[0];
    const finalPrice = prices[prices.length - 1];
    const totalReturn = (finalPrice - initialPrice) / initialPrice;
    
    let step = 0;
    
    function executeTotalReturnStep() {
        switch (step) {
            case 0:
                // Step 1: Show initial price
                explanation.innerHTML = `Step ${step + 1}: Identify Initial Investment Price`;
                initialPriceValue.textContent = initialPrice;
                
                const initialElements = originalContainer.querySelectorAll('.array-element');
                initialElements[0].querySelector('.element-value').classList.add('create', 'pulse');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1 - Initial Investment:</strong> 
                        Day 0 price = $${initialPrice}<br>
                        <small>This is your starting investment value</small>
                    </div>
                `;
                break;
                
            case 1:
                // Step 2: Show final price
                explanation.innerHTML = `Step ${step + 1}: Identify Final Portfolio Value`;
                finalPriceValue.textContent = finalPrice;
                
                const finalElements = originalContainer.querySelectorAll('.array-element');
                finalElements[finalElements.length - 1].querySelector('.element-value').classList.add('update', 'pulse');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 2 - Final Value:</strong> 
                        Day ${prices.length - 1} price = $${finalPrice}<br>
                        <small>This is your ending portfolio value</small>
                    </div>
                `;
                break;
                
            case 2:
                // Step 3: Calculate total return
                explanation.innerHTML = `Step ${step + 1}: Calculate Total Return Percentage`;
                totalReturnValue.textContent = (totalReturn * 100).toFixed(2) + '%';
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 3 - Return Calculation:</strong><br>
                        Formula: (Final - Initial) / Initial<br>
                        (${finalPrice} - ${initialPrice}) / ${initialPrice} = ${(totalReturn * 100).toFixed(2)}%
                    </div>
                `;
                break;
                
            case 3:
                // Step 4: Performance analysis
                explanation.innerHTML = `Step ${step + 1}: Investment Performance Analysis`;
                
                const performanceText = totalReturn >= 0 ? 
                    `POSITIVE - Investment Grew ${(totalReturn * 100).toFixed(2)}%` : 
                    `NEGATIVE - Investment Declined ${Math.abs(totalReturn * 100).toFixed(2)}%`;
                
                performanceValue.textContent = performanceText;
                performanceValue.className = `stats-value ${totalReturn >= 0 ? 'text-success' : 'text-danger'}`;
                
                // Update performance array
                const performanceData = [
                    `Initial: $${initialPrice}`,
                    `Final: $${finalPrice}`,
                    `Return: ${(totalReturn * 100).toFixed(2)}%`,
                    totalReturn >= 0 ? ' PROFIT' : ' LOSS'
                ];
                renderArrayInContainer(performanceData, 'performanceArray');
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step ${totalReturn >= 0 ? 'active' : ''}">
                        <strong>Step 4 - Performance Summary:</strong><br>
                         Initial Investment: $${initialPrice}<br>
                         Final Value: $${finalPrice}<br>
                         Total Return: ${(totalReturn * 100).toFixed(2)}%<br>
                         $10,000 would become $${(10000 * (1 + totalReturn)).toFixed(2)}
                    </div>
                `;
                break;
                
            case 4:
                // Step 5: Complete analysis
                explanation.innerHTML = `<strong>Total Return Analysis Completed!</strong><br>
                                        Your investment ${totalReturn >= 0 ? 'grew' : 'declined'} by ${Math.abs(totalReturn * 100).toFixed(2)}%`;
                
                // Highlight all elements to show the journey
                const allElements = originalContainer.querySelectorAll('.array-element');
                allElements.forEach((el, index) => {
                    setTimeout(() => {
                        el.querySelector('.element-value').classList.add('color-change');
                    }, index * 200);
                });
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>FINAL ANALYSIS:</strong><br>
                        <div class="mt-2 p-2 ${totalReturn >= 0 ? 'bg-success' : 'bg-danger'} rounded text-white">
                            <strong>Investment Result:</strong><br>
                            Period: ${prices.length} days<br>
                            Return: ${(totalReturn * 100).toFixed(2)}%<br>
                            Performance: ${totalReturn >= 0 ? ' SUCCESSFUL' : ' UNSUCCESSFUL'}
                        </div>
                    </div>
                `;
                
                continueButton.style.display = 'block';
                
                // Auto-return after 10 seconds (more time for analysis)
                setTimeout(() => {
                    returnToStockPrices();
                }, 10000);
                
                continueButton.addEventListener('click', returnToStockPrices);
                return;
        }
        
        step++;
        setTimeout(executeTotalReturnStep, 3000);
    }
    
    // Start analysis
    executeTotalReturnStep();
}

// NEW: Perform Price Difference Calculation with Animation
function performPriceDifferenceCalculation() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Price Difference Analysis</h5>
        
        <div class="array-group">
            <div class="array-label">Stock Prices</div>
            <div class="original-array-container" id="originalPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Daily Price Changes</div>
            <div class="transformed-array-container" id="priceDiffArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> diff[i] = price[i] - price[i-1]</p>
            <p class="mb-2"><strong>Business Insight:</strong> Shows daily price movements and volatility</p>
            <p class="mb-0" id="priceDiffExplanation">Starting price difference analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="priceDiffStepsContainer">
            <h6 class="text-center">Daily Movement Analysis</h6>
            <div class="steps-container" id="priceDiffSteps"></div>
        </div>
        
        <div class="row mt-3">
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Total Up Days</div>
                    <div class="stats-value" id="upDaysValue">0</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Total Down Days</div>
                    <div class="stats-value" id="downDaysValue">0</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Net Change</div>
                    <div class="stats-value" id="netChangeValue">0</div>
                </div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPriceDiff" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalStockPrices.map(p => p.toString()), 'originalPricesArray');
    renderArrayInContainer([], 'priceDiffArray');
    
    executePriceDifferenceAnimation();
}

// NEW: Execute Price Difference Animation
function executePriceDifferenceAnimation() {
    const originalContainer = document.getElementById('originalPricesArray');
    const priceDiffContainer = document.getElementById('priceDiffArray');
    const explanation = document.getElementById('priceDiffExplanation');
    const stepsContainer = document.getElementById('priceDiffSteps');
    const continueButton = document.getElementById('continueAfterPriceDiff');
    
    const upDaysValue = document.getElementById('upDaysValue');
    const downDaysValue = document.getElementById('downDaysValue');
    const netChangeValue = document.getElementById('netChangeValue');
    
    const prices = [...originalStockPrices];
    const priceDifferences = [];
    let upDays = 0;
    let downDays = 0;
    let totalNetChange = 0;
    let step = 0;
    
    function executePriceDiffStep(i) {
        if (i >= prices.length) {
            // Calculation completed
            explanation.innerHTML = `<strong>Price Difference Analysis Completed!</strong><br>
                                    Volatility Analysis: ${upDays} up days, ${downDays} down days`;
            
            // Final statistics
            const volatility = (upDays + downDays) / (prices.length - 1);
            const avgGain = upDays > 0 ? totalNetChange / upDays : 0;
            const avgLoss = downDays > 0 ? Math.abs(totalNetChange) / downDays : 0;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>VOLATILITY ANALYSIS:</strong><br>
                     Trading Days: ${prices.length - 1}<br>
                     Up Days: ${upDays} (${((upDays/(prices.length-1))*100).toFixed(1)}%)<br>
                     Down Days: ${downDays} (${((downDays/(prices.length-1))*100).toFixed(1)}%)<br>
                     Net Price Change: ${totalNetChange.toFixed(2)}<br>
                     Volatility Score: ${(volatility * 100).toFixed(1)}%
                </div>
            `;
            
            // Update final stats
            upDaysValue.textContent = upDays;
            downDaysValue.textContent = downDays;
            netChangeValue.textContent = totalNetChange.toFixed(2);
            
            continueButton.style.display = 'block';
            
            // Auto-return after 8 seconds
            setTimeout(() => {
                returnToStockPrices();
            }, 8000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            
            return;
        }
        
        if (i === 0) {
            // First element - no difference calculation
            explanation.innerHTML = `Step ${step + 1}: Baseline price established`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step + 1}:</strong> Baseline price = $${prices[i]}<br>
                    <small>Starting reference point for all calculations</small>
                </div>
            `;
            
            priceDifferences.push('Baseline');
            renderArrayInContainer(priceDifferences, 'priceDiffArray');
            
            step++;
            setTimeout(() => executePriceDiffStep(i + 1), 2000);
            return;
        }
        
        // Calculate price difference
        const currentPrice = prices[i];
        const previousPrice = prices[i - 1];
        const priceDiff = currentPrice - previousPrice;
        
        explanation.innerHTML = `Step ${step + 1}: Day ${i} Price Movement<br>
                                Current: $${currentPrice} - Previous: $${previousPrice} = ${priceDiff >= 0 ? '+' : ''}${priceDiff.toFixed(2)}`;
        
        // Update statistics
        if (priceDiff > 0) {
            upDays++;
            totalNetChange += priceDiff;
        } else if (priceDiff < 0) {
            downDays++;
            totalNetChange += priceDiff;
        }
        
        // Highlight the prices being used
        const originalElements = originalContainer.querySelectorAll('.array-element');
        originalElements[i - 1].querySelector('.element-value').classList.add('sorting-compared');
        originalElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${priceDiff !== 0 ? 'active' : ''}">
                <strong>Day ${i} Analysis:</strong><br>
                 Price Change: ${priceDiff >= 0 ? '+' : ''}${priceDiff.toFixed(2)}<br>
                 Movement: ${priceDiff > 0 ? ' UP' : priceDiff < 0 ? ' DOWN' : ' FLAT'}<br>
                 Cumulative: ${upDays} up, ${downDays} down days
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            originalElements[i - 1].querySelector('.element-value').classList.remove('sorting-compared');
            originalElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            // Add the calculated price difference
            const diffText = priceDiff > 0 ? `+${priceDiff.toFixed(2)}` : priceDiff.toFixed(2);
            priceDifferences.push(diffText);
            renderArrayInContainer(priceDifferences, 'priceDiffArray');
            
            // Highlight the difference value
            const diffElements = priceDiffContainer.querySelectorAll('.array-element');
            const diffElement = diffElements[i].querySelector('.element-value');
            diffElement.classList.add('price-difference');
            
            if (priceDiff > 0) {
                diffElement.classList.add('positive-return');
                diffElement.innerHTML = `${diffText} `;
            } else if (priceDiff < 0) {
                diffElement.classList.add('negative-return');
                diffElement.innerHTML = `${diffText} `;
            } else {
                diffElement.innerHTML = `${diffText} `;
            }
            
            // Update live statistics
            upDaysValue.textContent = upDays;
            downDaysValue.textContent = downDays;
            netChangeValue.textContent = totalNetChange.toFixed(2);
            
            step++;
            executePriceDiffStep(i + 1);
        }, 2500);
    }
    
    // Start calculation
    executePriceDiffStep(0);
}
// NEW: Return to Stock Prices (common function for all operations)
function returnToStockPrices() {
    // Reset to original stock prices
    if (originalStockPrices.length > 0) {
        myArray = originalStockPrices.map(price => price.toString());
        renderArray();
        updateStats();
        
        // Highlight all prices
        setTimeout(() => {
            myArray.forEach((_, index) => {
                highlightElement(index, 'stock-price');
            });
        }, 100);
    }
    
    // Reset state
    isStockOperationRunning = false;
    
    logOperation('Returned to original stock prices', 'info');
    showNotification('Returned to original stock prices', 'success');
}
// NEW: Perform Price Momentum Calculation
function performPriceMomentumCalculation() {
    if (originalStockPrices.length < 2) {
        showNotification('Need at least 2 prices for momentum calculation', 'warning');
        return;
    }

    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3"> Price Momentum Analysis (N-day)</h5>
        
        <div class="array-group">
            <div class="array-label">Stock Prices</div>
            <div class="original-array-container" id="originalPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Price Momentum (N=1 day)</div>
            <div class="transformed-array-container" id="momentumArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> momentum[i] = price[i] - price[i-1]</p>
            <p class="mb-2"><strong>Business Insight:</strong> Shows the directional movement and strength of price changes</p>
            <p class="mb-0" id="momentumExplanation">Starting price momentum calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="momentumStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="momentumSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Total Positive Momentum Days</div>
            <div class="stats-value" id="positiveMomentumCount">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMomentum" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalStockPrices.map(p => p.toString()), 'originalPricesArray');
    renderArrayInContainer([], 'momentumArray');
    
    executePriceMomentumAnimation();
}

// NEW: Execute Price Momentum Animation
function executePriceMomentumAnimation() {
    const originalContainer = document.getElementById('originalPricesArray');
    const momentumContainer = document.getElementById('momentumArray');
    const explanation = document.getElementById('momentumExplanation');
    const stepsContainer = document.getElementById('momentumSteps');
    const continueButton = document.getElementById('continueAfterMomentum');
    const positiveMomentumCount = document.getElementById('positiveMomentumCount');
    
    const prices = [...originalStockPrices];
    const momentumValues = [];
    let positiveDays = 0;
    let step = 0;
    
    function executeMomentumStep(i) {
        if (i >= prices.length) {
            explanation.innerHTML = `<strong>Price Momentum Analysis Completed!</strong><br>
                                    ${positiveDays} positive momentum days out of ${prices.length - 1} trading days`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>MOMENTUM SUMMARY:</strong><br>
                     Total Trading Days: ${prices.length - 1}<br>
                     Positive Momentum Days: ${positiveDays}<br>
                     Negative Momentum Days: ${prices.length - 1 - positiveDays}<br>
                     Bullish Ratio: ${((positiveDays/(prices.length-1))*100).toFixed(1)}%
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToStockPrices();
            }, 10000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            return;
        }
        
        if (i === 0) {
            explanation.innerHTML = `Step ${step + 1}: Baseline established - no momentum calculation for first price`;
            momentumValues.push('Baseline');
            renderArrayInContainer(momentumValues, 'momentumArray');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step + 1}:</strong> Baseline price = $${prices[i]}<br>
                    <small>Starting point for momentum calculations</small>
                </div>
            `;
            
            step++;
            setTimeout(() => executeMomentumStep(i + 1), 2000);
            return;
        }
        
        const currentPrice = prices[i];
        const previousPrice = prices[i - 1];
        const momentum = currentPrice - previousPrice;
        
        explanation.innerHTML = `Step ${step + 1}: Calculating Day ${i} Momentum<br>
                                Formula: ${currentPrice} - ${previousPrice} = ${momentum.toFixed(2)}`;
        
        // Update statistics
        if (momentum > 0) positiveDays++;
        
        // Highlight the prices being used
        const originalElements = originalContainer.querySelectorAll('.array-element');
        originalElements[i - 1].querySelector('.element-value').classList.add('sorting-compared');
        originalElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step + 1}:</strong> Momentum[${i}] = ${currentPrice} - ${previousPrice}<br>
                <strong>Result:</strong> ${momentum >= 0 ? '+' : ''}${momentum.toFixed(2)}<br>
                <small>${momentum > 0 ? ' BULLISH' : momentum < 0 ? ' BEARISH' : ' NEUTRAL'} momentum</small>
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            originalElements[i - 1].querySelector('.element-value').classList.remove('sorting-compared');
            originalElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            // Add the calculated momentum
            momentumValues.push(momentum.toFixed(2));
            renderArrayInContainer(momentumValues, 'momentumArray');
            
            // Highlight the momentum value
            const momentumElements = momentumContainer.querySelectorAll('.array-element');
            const momentumElement = momentumElements[i].querySelector('.element-value');
            momentumElement.classList.add('price-momentum');
            
            if (momentum > 0) {
                momentumElement.classList.add('momentum-positive');
                momentumElement.innerHTML = `+${momentum.toFixed(2)} `;
            } else if (momentum < 0) {
                momentumElement.classList.add('momentum-negative');
                momentumElement.innerHTML = `${momentum.toFixed(2)} `;
            } else {
                momentumElement.innerHTML = `${momentum.toFixed(2)} `;
            }
            
            // Update statistics
            positiveMomentumCount.textContent = positiveDays;
            
            step++;
            executeMomentumStep(i + 1);
        }, 2500);
    }
    
    executeMomentumStep(0);
}

// NEW: Perform Rate of Change (ROC) Calculation
function performRateOfChangeCalculation() {
    if (originalStockPrices.length < 2) {
        showNotification('Need at least 2 prices for ROC calculation', 'warning');
        return;
    }

    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3"> Rate of Change (ROC) Analysis</h5>
        
        <div class="array-group">
            <div class="array-label">Stock Prices</div>
            <div class="original-array-container" id="originalPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Rate of Change % (N=1 day)</div>
            <div class="transformed-array-container" id="rocArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> ROC[i] = ((price[i] - price[i-1]) / price[i-1])  100</p>
            <p class="mb-2"><strong>Business Insight:</strong> Percentage-based momentum indicator showing relative price changes</p>
            <p class="mb-0" id="rocExplanation">Starting ROC calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="rocStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="rocSteps"></div>
        </div>
        
        <div class="row mt-3">
            <div class="col-md-6">
                <div class="stats-card">
                    <div>Average ROC</div>
                    <div class="stats-value" id="averageROC">0%</div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="stats-card">
                    <div>Max ROC</div>
                    <div class="stats-value" id="maxROC">0%</div>
                </div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterROC" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalStockPrices.map(p => p.toString()), 'originalPricesArray');
    renderArrayInContainer([], 'rocArray');
    
    executeRateOfChangeAnimation();
}

// NEW: Execute Rate of Change Animation
function executeRateOfChangeAnimation() {
    const originalContainer = document.getElementById('originalPricesArray');
    const rocContainer = document.getElementById('rocArray');
    const explanation = document.getElementById('rocExplanation');
    const stepsContainer = document.getElementById('rocSteps');
    const continueButton = document.getElementById('continueAfterROC');
    const averageROC = document.getElementById('averageROC');
    const maxROC = document.getElementById('maxROC');
    
    const prices = [...originalStockPrices];
    const rocValues = [];
    let totalROC = 0;
    let maxROCAbs = 0;
    let step = 0;
    
    function executeROCStep(i) {
        if (i >= prices.length) {
            const avgROC = totalROC / (prices.length - 1);
            explanation.innerHTML = `<strong>ROC Analysis Completed!</strong><br>
                                    Average daily ROC: ${avgROC.toFixed(2)}%`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>ROC SUMMARY:</strong><br>
                     Analysis Period: ${prices.length} days<br>
                     Trading Days: ${prices.length - 1}<br>
                     Average Daily ROC: ${avgROC.toFixed(2)}%<br>
                     Maximum ROC: ${maxROCAbs.toFixed(2)}%<br>
                     Volatility: ${(maxROCAbs * 2).toFixed(2)}% range
                </div>
            `;
            
            averageROC.textContent = avgROC.toFixed(2) + '%';
            maxROC.textContent = maxROCAbs.toFixed(2) + '%';
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToStockPrices();
            }, 10000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            return;
        }
        
        if (i === 0) {
            explanation.innerHTML = `Step ${step + 1}: Baseline established - no ROC calculation for first price`;
            rocValues.push('Baseline');
            renderArrayInContainer(rocValues, 'rocArray');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step + 1}:</strong> Baseline price = $${prices[i]}<br>
                    <small>Reference point for ROC calculations</small>
                </div>
            `;
            
            step++;
            setTimeout(() => executeROCStep(i + 1), 2000);
            return;
        }
        
        const currentPrice = prices[i];
        const previousPrice = prices[i - 1];
        const roc = ((currentPrice - previousPrice) / previousPrice) * 100;
        
        explanation.innerHTML = `Step ${step + 1}: Calculating Day ${i} ROC<br>
                                Formula: ((${currentPrice} - ${previousPrice}) / ${previousPrice})  100<br>
                                Result: ${roc.toFixed(2)}%`;
        
        // Update statistics
        totalROC += Math.abs(roc);
        if (Math.abs(roc) > maxROCAbs) maxROCAbs = Math.abs(roc);
        
        // Highlight the prices being used
        const originalElements = originalContainer.querySelectorAll('.array-element');
        originalElements[i - 1].querySelector('.element-value').classList.add('sorting-compared');
        originalElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step + 1}:</strong> ROC[${i}] = ((${currentPrice} - ${previousPrice}) / ${previousPrice})  100<br>
                <strong>Calculation:</strong> (${(currentPrice - previousPrice).toFixed(2)} / ${previousPrice})  100<br>
                <strong>Result:</strong> ${roc >= 0 ? '+' : ''}${roc.toFixed(2)}%<br>
                <small>${roc > 1 ? ' STRONG BULLISH' : roc > 0 ? ' BULLISH' : roc < -1 ? ' STRONG BEARISH' : roc < 0 ? ' BEARISH' : ' NEUTRAL'}</small>
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            originalElements[i - 1].querySelector('.element-value').classList.remove('sorting-compared');
            originalElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            // Add the calculated ROC
            rocValues.push(roc.toFixed(2) + '%');
            renderArrayInContainer(rocValues, 'rocArray');
            
            // Highlight the ROC value
            const rocElements = rocContainer.querySelectorAll('.array-element');
            const rocElement = rocElements[i].querySelector('.element-value');
            rocElement.classList.add('roc-indicator');
            
            if (roc > 1) {
                rocElement.classList.add('roc-high', 'momentum-positive');
                rocElement.innerHTML = `+${roc.toFixed(2)}% `;
            } else if (roc > 0) {
                rocElement.classList.add('roc-high');
                rocElement.innerHTML = `+${roc.toFixed(2)}% `;
            } else if (roc < -1) {
                rocElement.classList.add('roc-low', 'momentum-negative');
                rocElement.innerHTML = `${roc.toFixed(2)}% `;
            } else if (roc < 0) {
                rocElement.classList.add('roc-low');
                rocElement.innerHTML = `${roc.toFixed(2)}% `;
            } else {
                rocElement.innerHTML = `${roc.toFixed(2)}% `;
            }
            
            step++;
            executeROCStep(i + 1);
        }, 3000);
    }
    
    executeROCStep(0);
}

// NEW: Perform Gap Analysis Calculation
function performGapAnalysisCalculation() {
    if (openPrices.length === 0 || closePrices.length === 0) {
        showNotification('Open/Close price data not available', 'warning');
        return;
    }

    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3"> Gap Up/Down Analysis</h5>
        
        <div class="array-group">
            <div class="array-label">Previous Day Close Prices</div>
            <div class="original-array-container" id="closePricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-right"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Current Day Open Prices</div>
            <div class="transformed-array-container" id="openPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Gap Analysis %</div>
            <div class="transformed-array-container" id="gapArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> gap[i] = (open[i] - close[i-1]) / close[i-1]  100</p>
            <p class="mb-2"><strong>Business Insight:</strong> Measures overnight price movements and market sentiment gaps</p>
            <p class="mb-0" id="gapExplanation">Starting gap analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="gapStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="gapSteps"></div>
        </div>
        
        <div class="row mt-3">
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Gap Up Days</div>
                    <div class="stats-value" id="gapUpCount">0</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Gap Down Days</div>
                    <div class="stats-value" id="gapDownCount">0</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Largest Gap</div>
                    <div class="stats-value" id="largestGap">0%</div>
                </div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterGap" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display previous closes (shifted by one)
    const previousCloses = ['N/A', ...closePrices.slice(0, -1).map(p => p.toFixed(2))];
    renderArrayInContainer(previousCloses, 'closePricesArray');
    renderArrayInContainer(openPrices.map(p => p.toFixed(2)), 'openPricesArray');
    renderArrayInContainer([], 'gapArray');
    
    executeGapAnalysisAnimation();
}

// NEW: Execute Gap Analysis Animation
function executeGapAnalysisAnimation() {
    const closeContainer = document.getElementById('closePricesArray');
    const openContainer = document.getElementById('openPricesArray');
    const gapContainer = document.getElementById('gapArray');
    const explanation = document.getElementById('gapExplanation');
    const stepsContainer = document.getElementById('gapSteps');
    const continueButton = document.getElementById('continueAfterGap');
    const gapUpCount = document.getElementById('gapUpCount');
    const gapDownCount = document.getElementById('gapDownCount');
    const largestGap = document.getElementById('largestGap');
    
    let gapUpDays = 0;
    let gapDownDays = 0;
    let maxGap = 0;
    const gapValues = [];
    let step = 0;
    
    function executeGapStep(i) {
        if (i >= openPrices.length) {
            explanation.innerHTML = `<strong>Gap Analysis Completed!</strong><br>
                                    ${gapUpDays} gap up days, ${gapDownDays} gap down days`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>GAP ANALYSIS SUMMARY:</strong><br>
                     Total Trading Days: ${openPrices.length - 1}<br>
                     Gap Up Days: ${gapUpDays} (${((gapUpDays/(openPrices.length-1))*100).toFixed(1)}%)<br>
                     Gap Down Days: ${gapDownDays} (${((gapDownDays/(openPrices.length-1))*100).toFixed(1)}%)<br>
                     Largest Gap: ${maxGap.toFixed(2)}%<br>
                     Market Sentiment: ${gapUpDays > gapDownDays ? 'BULLISH' : gapDownDays > gapUpDays ? 'BEARISH' : 'NEUTRAL'} bias
                </div>
            `;
            
            gapUpCount.textContent = gapUpDays;
            gapDownCount.textContent = gapDownDays;
            largestGap.textContent = maxGap.toFixed(2) + '%';
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToStockPrices();
            }, 10000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            return;
        }
        
        if (i === 0) {
            explanation.innerHTML = `Step ${step + 1}: First day - no previous close for gap calculation`;
            gapValues.push('N/A');
            renderArrayInContainer(gapValues, 'gapArray');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step + 1}:</strong> Day 0 - Initial opening<br>
                    <small>No previous close price available</small>
                </div>
            `;
            
            step++;
            setTimeout(() => executeGapStep(i + 1), 2000);
            return;
        }
        
        const currentOpen = openPrices[i];
        const previousClose = closePrices[i - 1];
        const gap = ((currentOpen - previousClose) / previousClose) * 100;
        
        explanation.innerHTML = `Step ${step + 1}: Calculating Day ${i} Gap<br>
                                Formula: ((${currentOpen.toFixed(2)} - ${previousClose.toFixed(2)}) / ${previousClose.toFixed(2)})  100<br>
                                Result: ${gap.toFixed(2)}%`;
        
        // Update statistics
        if (gap > 0) {
            gapUpDays++;
        } else if (gap < 0) {
            gapDownDays++;
        }
        
        if (Math.abs(gap) > Math.abs(maxGap)) {
            maxGap = gap;
        }
        
        // Highlight the prices being used
        const closeElements = closeContainer.querySelectorAll('.array-element');
        const openElements = openContainer.querySelectorAll('.array-element');
        
        closeElements[i].querySelector('.element-value').classList.add('sorting-compared');
        openElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step + 1}:</strong> Gap[${i}] = ((${currentOpen.toFixed(2)} - ${previousClose.toFixed(2)}) / ${previousClose.toFixed(2)})  100<br>
                <strong>Calculation:</strong> (${(currentOpen - previousClose).toFixed(2)} / ${previousClose.toFixed(2)})  100<br>
                <strong>Result:</strong> ${gap >= 0 ? '+' : ''}${gap.toFixed(2)}%<br>
                <small>${gap > 0 ? ' GAP UP - Bullish opening' : gap < 0 ? ' GAP DOWN - Bearish opening' : ' NO GAP - Neutral opening'}</small>
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            closeElements[i].querySelector('.element-value').classList.remove('sorting-compared');
            openElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            // Add the calculated gap
            gapValues.push(gap.toFixed(2) + '%');
            renderArrayInContainer(gapValues, 'gapArray');
            
            // Highlight the gap value
            const gapElements = gapContainer.querySelectorAll('.array-element');
            const gapElement = gapElements[i].querySelector('.element-value');
            
            if (gap > 0.5) {
                gapElement.classList.add('gap-up', 'momentum-positive');
                gapElement.innerHTML = `+${gap.toFixed(2)}% `;
            } else if (gap > 0) {
                gapElement.classList.add('gap-up');
                gapElement.innerHTML = `+${gap.toFixed(2)}% `;
            } else if (gap < -0.5) {
                gapElement.classList.add('gap-down', 'momentum-negative');
                gapElement.innerHTML = `${gap.toFixed(2)}% `;
            } else if (gap < 0) {
                gapElement.classList.add('gap-down');
                gapElement.innerHTML = `${gap.toFixed(2)}% `;
            } else {
                gapElement.innerHTML = `${gap.toFixed(2)}% `;
            }
            
            // Update statistics
            gapUpCount.textContent = gapUpDays;
            gapDownCount.textContent = gapDownDays;
            largestGap.textContent = maxGap.toFixed(2) + '%';
            
            step++;
            executeGapStep(i + 1);
        }, 3000);
    }
    
    executeGapStep(0);
}

// NEW: Perform Intraday Gain/Loss Calculation
function performIntradayGainCalculation() {
    if (openPrices.length === 0 || closePrices.length === 0) {
        showNotification('Open/Close price data not available', 'warning');
        return;
    }

    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3"> Intraday Gain/Loss Analysis</h5>
        
        <div class="array-group">
            <div class="array-label">Daily Open Prices</div>
            <div class="original-array-container" id="openPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-right"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Daily Close Prices</div>
            <div class="transformed-array-container" id="closePricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Intraday Gain/Loss %</div>
            <div class="transformed-array-container" id="intradayArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> intraday[i] = (close[i] - open[i]) / open[i]  100</p>
            <p class="mb-2"><strong>Business Insight:</strong> Measures daily trading performance and intraday volatility</p>
            <p class="mb-0" id="intradayExplanation">Starting intraday analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="intradayStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="intradaySteps"></div>
        </div>
        
        <div class="row mt-3">
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Profitable Days</div>
                    <div class="stats-value" id="profitableDays">0</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Losing Days</div>
                    <div class="stats-value" id="losingDays">0</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="stats-card">
                    <div>Best Day</div>
                    <div class="stats-value" id="bestDay">0%</div>
                </div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterIntraday" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(openPrices.map(p => p.toFixed(2)), 'openPricesArray');
    renderArrayInContainer(closePrices.map(p => p.toFixed(2)), 'closePricesArray');
    renderArrayInContainer([], 'intradayArray');
    
    executeIntradayGainAnimation();
}

// NEW: Execute Intraday Gain/Loss Animation
function executeIntradayGainAnimation() {
    const openContainer = document.getElementById('openPricesArray');
    const closeContainer = document.getElementById('closePricesArray');
    const intradayContainer = document.getElementById('intradayArray');
    const explanation = document.getElementById('intradayExplanation');
    const stepsContainer = document.getElementById('intradaySteps');
    const continueButton = document.getElementById('continueAfterIntraday');
    const profitableDays = document.getElementById('profitableDays');
    const losingDays = document.getElementById('losingDays');
    const bestDay = document.getElementById('bestDay');
    
    let profitDays = 0;
    let lossDays = 0;
    let bestGain = 0;
    const intradayValues = [];
    let step = 0;
    
    function executeIntradayStep(i) {
        if (i >= openPrices.length) {
            explanation.innerHTML = `<strong>Intraday Analysis Completed!</strong><br>
                                    ${profitDays} profitable days, ${lossDays} losing days`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>INTRADAY TRADING SUMMARY:</strong><br>
                     Total Trading Days: ${openPrices.length}<br>
                     Profitable Days: ${profitDays} (${((profitDays/openPrices.length)*100).toFixed(1)}%)<br>
                     Losing Days: ${lossDays} (${((lossDays/openPrices.length)*100).toFixed(1)}%)<br>
                     Best Day: +${bestGain.toFixed(2)}%<br>
                     Win Rate: ${((profitDays/openPrices.length)*100).toFixed(1)}%
                </div>
            `;
            
            profitableDays.textContent = profitDays;
            losingDays.textContent = lossDays;
            bestDay.textContent = '+' + bestGain.toFixed(2) + '%';
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToStockPrices();
            }, 10000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            return;
        }
        
        const openPrice = openPrices[i];
        const closePrice = closePrices[i];
        const intradayGain = ((closePrice - openPrice) / openPrice) * 100;
        
        explanation.innerHTML = `Step ${step + 1}: Calculating Day ${i} Intraday Performance<br>
                                Formula: ((${closePrice.toFixed(2)} - ${openPrice.toFixed(2)}) / ${openPrice.toFixed(2)})  100<br>
                                Result: ${intradayGain.toFixed(2)}%`;
        
        // Update statistics
        if (intradayGain > 0) {
            profitDays++;
            if (intradayGain > bestGain) bestGain = intradayGain;
        } else if (intradayGain < 0) {
            lossDays++;
        }
        
        // Highlight the prices being used
        const openElements = openContainer.querySelectorAll('.array-element');
        const closeElements = closeContainer.querySelectorAll('.array-element');
        
        openElements[i].querySelector('.element-value').classList.add('sorting-compared');
        closeElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step + 1}:</strong> Intraday[${i}] = ((${closePrice.toFixed(2)} - ${openPrice.toFixed(2)}) / ${openPrice.toFixed(2)})  100<br>
                <strong>Calculation:</strong> (${(closePrice - openPrice).toFixed(2)} / ${openPrice.toFixed(2)})  100<br>
                <strong>Result:</strong> ${intradayGain >= 0 ? '+' : ''}${intradayGain.toFixed(2)}%<br>
                <small>${intradayGain > 0 ? ' PROFIT' : intradayGain < 0 ? ' LOSS' : ' BREAKEVEN'} for the day</small>
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            openElements[i].querySelector('.element-value').classList.remove('sorting-compared');
            closeElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            // Add the calculated intraday gain
            intradayValues.push(intradayGain.toFixed(2) + '%');
            renderArrayInContainer(intradayValues, 'intradayArray');
            
            // Highlight the intraday value
            const intradayElements = intradayContainer.querySelectorAll('.array-element');
            const intradayElement = intradayElements[i].querySelector('.element-value');
            
            if (intradayGain > 1) {
                intradayElement.classList.add('intraday-gain', 'momentum-positive');
                intradayElement.innerHTML = `+${intradayGain.toFixed(2)}% `;
            } else if (intradayGain > 0) {
                intradayElement.classList.add('intraday-gain');
                intradayElement.innerHTML = `+${intradayGain.toFixed(2)}% `;
            } else if (intradayGain < -1) {
                intradayElement.classList.add('intraday-loss', 'momentum-negative');
                intradayElement.innerHTML = `${intradayGain.toFixed(2)}% `;
            } else if (intradayGain < 0) {
                intradayElement.classList.add('intraday-loss');
                intradayElement.innerHTML = `${intradayGain.toFixed(2)}% `;
            } else {
                intradayElement.innerHTML = `${intradayGain.toFixed(2)}% `;
            }
            
            // Update statistics
            profitableDays.textContent = profitDays;
            losingDays.textContent = lossDays;
            if (intradayGain > bestGain) {
                bestDay.textContent = '+' + intradayGain.toFixed(2) + '%';
            }
            
            step++;
            executeIntradayStep(i + 1);
        }, 3000);
    }
    
    executeIntradayStep(0);
}
// NEW: Perform Simple Moving Average (SMA) Calculation
function performSMACalculation() {
    if (originalStockPrices.length < 3) {
        showNotification('Need at least 3 prices for SMA calculation', 'warning');
        return;
    }

    const period = 3; // Default period for SMA

    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3"> Simple Moving Average (SMA) - ${period} Period</h5>
        
        <div class="period-selector">
            <div class="period-label">Calculation Period: ${period} days</div>
            <small>SMA smoothes price data by creating a constantly updated average price</small>
        </div>
        
        <div class="array-group">
            <div class="array-label">Stock Prices</div>
            <div class="original-array-container" id="originalPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">SMA Values (${period}-period)</div>
            <div class="transformed-array-container" id="smaArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> sma[i] = average(price[i-${period-1} : i+1])</p>
            <p class="mb-2"><strong>Business Insight:</strong> Identifies trend direction and smooths out price fluctuations</p>
            <p class="mb-0" id="smaExplanation">Starting SMA calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="smaStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="smaSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Current Trend Direction</div>
            <div class="stats-value" id="trendDirection">Calculating...</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSMA" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalStockPrices.map(p => p.toString()), 'originalPricesArray');
    renderArrayInContainer([], 'smaArray');
    
    executeSMAAnimation(period);
}

// NEW: Execute SMA Animation
function executeSMAAnimation(period) {
    const originalContainer = document.getElementById('originalPricesArray');
    const smaContainer = document.getElementById('smaArray');
    const explanation = document.getElementById('smaExplanation');
    const stepsContainer = document.getElementById('smaSteps');
    const continueButton = document.getElementById('continueAfterSMA');
    const trendDirection = document.getElementById('trendDirection');
    
    const prices = [...originalStockPrices];
    const smaValues = [];
    let step = 0;
    
    function executeSMAStep(i) {
        if (i >= prices.length) {
            // Determine overall trend
            const lastSMA = smaValues[smaValues.length - 1];
            const firstSMA = smaValues[period - 1];
            const overallTrend = lastSMA > firstSMA ? 'UPTREND ' : lastSMA < firstSMA ? 'DOWNTREND ' : 'SIDEWAYS ';
            
            explanation.innerHTML = `<strong>SMA Calculation Completed!</strong><br>
                                    Overall Trend: ${overallTrend}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>TREND ANALYSIS:</strong><br>
                     First SMA (Period ${period}): ${firstSMA.toFixed(2)}<br>
                     Last SMA: ${lastSMA.toFixed(2)}<br>
                     Trend Direction: ${overallTrend}<br>
                     Signal: ${lastSMA > firstSMA ? 'BULLISH' : lastSMA < firstSMA ? 'BEARISH' : 'NEUTRAL'}
                </div>
            `;
            
            trendDirection.textContent = overallTrend;
            trendDirection.className = `stats-value ${lastSMA > firstSMA ? 'text-success' : lastSMA < firstSMA ? 'text-danger' : 'text-warning'}`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToStockPrices();
            }, 10000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            return;
        }
        
        if (i < period - 1) {
            explanation.innerHTML = `Step ${step + 1}: Insufficient data for SMA (need ${period} prices, have ${i + 1})`;
            smaValues.push('N/A');
            renderArrayInContainer(smaValues, 'smaArray');
            
            stepsContainer.innerHTML += `
                <div class="calculation-step">
                    <strong>Step ${step + 1}:</strong> Position ${i} - Not enough data<br>
                    <small>Need ${period} prices, currently have ${i + 1} prices</small>
                </div>
            `;
            
            step++;
            setTimeout(() => executeSMAStep(i + 1), 1500);
            return;
        }
        
        // Calculate SMA for current position
        const periodPrices = prices.slice(i - period + 1, i + 1);
        const sum = periodPrices.reduce((a, b) => a + b, 0);
        const sma = sum / period;
        
        explanation.innerHTML = `Step ${step + 1}: Calculating SMA for position ${i}<br>
                                Prices: [${periodPrices.join(', ')}]<br>
                                Sum: ${sum.toFixed(2)} / ${period} = ${sma.toFixed(2)}`;
        
        // Highlight the prices being used
        const originalElements = originalContainer.querySelectorAll('.array-element');
        for (let j = i - period + 1; j <= i; j++) {
            originalElements[j].querySelector('.element-value').classList.add('sorting-compared');
        }
        originalElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="calculation-step active">
                <strong>Step ${step + 1}:</strong> SMA[${i}] = average(${periodPrices.join(' + ')}) / ${period}<br>
                <strong>Calculation:</strong> ${sum.toFixed(2)} / ${period} = ${sma.toFixed(2)}<br>
                <small>Using prices from position ${i - period + 1} to ${i}</small>
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            for (let j = i - period + 1; j <= i; j++) {
                originalElements[j].querySelector('.element-value').classList.remove('sorting-compared');
            }
            originalElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            // Add the calculated SMA
            smaValues.push(sma);
            renderArrayInContainer(smaValues.map(v => typeof v === 'number' ? v.toFixed(2) : v), 'smaArray');
            
            // Highlight the SMA value
            const smaElements = smaContainer.querySelectorAll('.array-element');
            if (i >= period - 1) {
                const smaElement = smaElements[i].querySelector('.element-value');
                smaElement.classList.add('technical-indicator', 'moving-average');
                
                // Add trend indication
                if (i > period - 1) {
                    const prevSMA = smaValues[i - 1];
                    if (sma > prevSMA) {
                        smaElement.classList.add('trend-up');
                        smaElement.innerHTML = `${sma.toFixed(2)} `;
                    } else if (sma < prevSMA) {
                        smaElement.classList.add('trend-down');
                        smaElement.innerHTML = `${sma.toFixed(2)} `;
                    } else {
                        smaElement.innerHTML = `${sma.toFixed(2)} `;
                    }
                } else {
                    smaElement.innerHTML = `${sma.toFixed(2)} `;
                }
            }
            
            step++;
            executeSMAStep(i + 1);
        }, 3000);
    }
    
    executeSMAStep(0);
}

// NEW: Perform Exponential Moving Average (EMA) Calculation
function performEMACalculation() {
    if (originalStockPrices.length < 3) {
        showNotification('Need at least 3 prices for EMA calculation', 'warning');
        return;
    }

    const period = 3; // Default period for EMA
    const smoothing = 2 / (period + 1);

    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3"> Exponential Moving Average (EMA) - ${period} Period</h5>
        
        <div class="period-selector">
            <div class="period-label">Calculation Period: ${period} days | Smoothing: ${smoothing.toFixed(4)}</div>
            <small>EMA gives more weight to recent prices, reacts faster to price changes</small>
        </div>
        
        <div class="array-group">
            <div class="array-label">Stock Prices</div>
            <div class="original-array-container" id="originalPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">EMA Values (${period}-period)</div>
            <div class="transformed-array-container" id="emaArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> ema[i] = (price[i]  ${smoothing.toFixed(4)}) + (ema[i-1]  ${(1-smoothing).toFixed(4)})</p>
            <p class="mb-2"><strong>Business Insight:</strong> More responsive to recent price action than SMA, better for short-term trading</p>
            <p class="mb-0" id="emaExplanation">Starting EMA calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="emaStepsContainer">
            <h6 class="text-center">Calculation Steps</h6>
            <div class="steps-container" id="emaSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>EMA Sensitivity</div>
            <div class="stats-value" id="emaSensitivity">HIGH </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterEMA" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalStockPrices.map(p => p.toString()), 'originalPricesArray');
    renderArrayInContainer([], 'emaArray');
    
    executeEMAAnimation(period, smoothing);
}

// NEW: Execute EMA Animation
function executeEMAAnimation(period, smoothing) {
    const originalContainer = document.getElementById('originalPricesArray');
    const emaContainer = document.getElementById('emaArray');
    const explanation = document.getElementById('emaExplanation');
    const stepsContainer = document.getElementById('emaSteps');
    const continueButton = document.getElementById('continueAfterEMA');
    const emaSensitivity = document.getElementById('emaSensitivity');
    
    const prices = [...originalStockPrices];
    const emaValues = [];
    let step = 0;
    
    function executeEMAStep(i) {
        if (i >= prices.length) {
            explanation.innerHTML = `<strong>EMA Calculation Completed!</strong><br>
                                    EMA gives more weight to recent price movements`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>EMA CHARACTERISTICS:</strong><br>
                     Period: ${period} days<br>
                     Smoothing Factor: ${smoothing.toFixed(4)}<br>
                     Recent Price Weight: ${(smoothing * 100).toFixed(1)}%<br>
                     Previous EMA Weight: ${((1-smoothing) * 100).toFixed(1)}%<br>
                     Use Case: Short-term trading signals
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToStockPrices();
            }, 10000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            return;
        }
        
        if (i < period - 1) {
            explanation.innerHTML = `Step ${step + 1}: Using SMA as initial EMA value (need ${period} prices)`;
            
            // For first EMA, use SMA
            const periodPrices = prices.slice(0, i + 1);
            if (periodPrices.length === period) {
                const sum = periodPrices.reduce((a, b) => a + b, 0);
                const initialEMA = sum / period;
                emaValues.push(initialEMA);
                
                stepsContainer.innerHTML += `
                    <div class="calculation-step active">
                        <strong>Step ${step + 1}:</strong> Initial EMA = SMA of first ${period} prices<br>
                        <strong>Calculation:</strong> (${periodPrices.join(' + ')}) / ${period} = ${initialEMA.toFixed(2)}<br>
                        <small>Using SMA as starting point for EMA calculation</small>
                    </div>
                `;
            } else {
                emaValues.push('N/A');
                stepsContainer.innerHTML += `
                    <div class="calculation-step">
                        <strong>Step ${step + 1}:</strong> Position ${i} - Building initial dataset<br>
                        <small>Need ${period} prices for initial EMA, currently have ${i + 1}</small>
                    </div>
                `;
            }
            
            renderArrayInContainer(emaValues.map(v => typeof v === 'number' ? v.toFixed(2) : v), 'emaArray');
            step++;
            setTimeout(() => executeEMAStep(i + 1), 2000);
            return;
        }
        
        let ema;
        if (i === period - 1) {
            // First EMA value (SMA)
            const periodPrices = prices.slice(0, i + 1);
            const sum = periodPrices.reduce((a, b) => a + b, 0);
            ema = sum / period;
            
            explanation.innerHTML = `Step ${step + 1}: Initial EMA = SMA of first ${period} prices<br>
                                    (${periodPrices.join(' + ')}) / ${period} = ${ema.toFixed(2)}`;
        } else {
            // Subsequent EMA values
            const currentPrice = prices[i];
            const previousEMA = emaValues[i - 1];
            ema = (currentPrice * smoothing) + (previousEMA * (1 - smoothing));
            
            explanation.innerHTML = `Step ${step + 1}: Calculating EMA for position ${i}<br>
                                    Formula: (${currentPrice}  ${smoothing.toFixed(4)}) + (${previousEMA.toFixed(2)}  ${(1-smoothing).toFixed(4)})<br>
                                    = ${ema.toFixed(2)}`;
        }
        
        // Highlight current price
        const originalElements = originalContainer.querySelectorAll('.array-element');
        originalElements[i].querySelector('.element-value').classList.add('sorting-current');
        if (i > period - 1) {
            originalElements[i - 1].querySelector('.element-value').classList.add('sorting-compared');
        }
        
        stepsContainer.innerHTML += `
            <div class="calculation-step active">
                <strong>Step ${step + 1}:</strong> ${i === period - 1 ? 'Initial EMA (SMA)' : 'EMA'}[${i}]<br>
                ${i === period - 1 ? 
                    `Initial EMA = (${prices.slice(0, i+1).join(' + ')}) / ${period} = ${ema.toFixed(2)}` :
                    `EMA = (${prices[i]}  ${smoothing.toFixed(4)}) + (${emaValues[i-1].toFixed(2)}  ${(1-smoothing).toFixed(4)}) = ${ema.toFixed(2)}`
                }<br>
                <small>${i === period - 1 ? 'Using SMA as starting point' : 'Weighted average favoring recent prices'}</small>
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            originalElements[i].querySelector('.element-value').classList.remove('sorting-current');
            if (i > period - 1) {
                originalElements[i - 1].querySelector('.element-value').classList.remove('sorting-compared');
            }
            
            // Add the calculated EMA
            emaValues.push(ema);
            renderArrayInContainer(emaValues.map(v => typeof v === 'number' ? v.toFixed(2) : v), 'emaArray');
            
            // Highlight the EMA value
            const emaElements = emaContainer.querySelectorAll('.array-element');
            if (i >= period - 1) {
                const emaElement = emaElements[i].querySelector('.element-value');
                emaElement.classList.add('technical-indicator', 'moving-average');
                
                // Add momentum indication
                if (i > period - 1) {
                    const prevEMA = emaValues[i - 1];
                    if (ema > prevEMA) {
                        emaElement.classList.add('trend-up');
                        emaElement.innerHTML = `${ema.toFixed(2)} `;
                    } else if (ema < prevEMA) {
                        emaElement.classList.add('trend-down');
                        emaElement.innerHTML = `${ema.toFixed(2)} `;
                    } else {
                        emaElement.innerHTML = `${ema.toFixed(2)} `;
                    }
                } else {
                    emaElement.innerHTML = `${ema.toFixed(2)} `;
                }
            }
            
            step++;
            executeEMAStep(i + 1);
        }, 3000);
    }
    
    executeEMAStep(0);
}

// NEW: Perform MACD Calculation
function performMACDCalculation() {
    if (originalStockPrices.length < 26) {
        showNotification('Need at least 26 prices for MACD calculation', 'warning');
        return;
    }

    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3"> MACD (Moving Average Convergence Divergence)</h5>
        
        <div class="period-selector">
            <div class="period-label">MACD = EMA(12) - EMA(26) | Trend Momentum Indicator</div>
            <small>Measures the relationship between two EMAs to identify momentum changes</small>
        </div>
        
        <div class="array-group">
            <div class="array-label">Stock Prices</div>
            <div class="original-array-container" id="originalPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">MACD Values (12-26 EMA Difference)</div>
            <div class="transformed-array-container" id="macdArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> MACD = EMA(12 periods) - EMA(26 periods)</p>
            <p class="mb-2"><strong>Business Insight:</strong> Positive MACD = bullish momentum, Negative MACD = bearish momentum</p>
            <p class="mb-0" id="macdExplanation">Starting MACD calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="macdStepsContainer">
            <h6 class="text-center">MACD Calculation Steps</h6>
            <div class="steps-container" id="macdSteps"></div>
        </div>
        
        <div class="row mt-3">
            <div class="col-md-6">
                <div class="stats-card">
                    <div>Current MACD</div>
                    <div class="stats-value" id="currentMACD">-</div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="stats-card">
                    <div>Momentum</div>
                    <div class="stats-value" id="macdMomentum">-</div>
                </div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMACD" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalStockPrices.map(p => p.toString()), 'originalPricesArray');
    renderArrayInContainer([], 'macdArray');
    
    executeMACDAnimation();
}

// NEW: Execute MACD Animation
function executeMACDAnimation() {
    const originalContainer = document.getElementById('originalPricesArray');
    const macdContainer = document.getElementById('macdArray');
    const explanation = document.getElementById('macdExplanation');
    const stepsContainer = document.getElementById('macdSteps');
    const continueButton = document.getElementById('continueAfterMACD');
    const currentMACD = document.getElementById('currentMACD');
    const macdMomentum = document.getElementById('macdMomentum');
    
    const prices = [...originalStockPrices];
    const macdValues = [];
    let step = 0;
    
    // Calculate EMAs for MACD
    function calculateEMA(prices, period) {
        const smoothing = 2 / (period + 1);
        const emaValues = [];
        
        for (let i = 0; i < prices.length; i++) {
            if (i < period - 1) {
                emaValues.push(null);
            } else if (i === period - 1) {
                const periodPrices = prices.slice(0, i + 1);
                const sum = periodPrices.reduce((a, b) => a + b, 0);
                emaValues.push(sum / period);
            } else {
                const ema = (prices[i] * smoothing) + (emaValues[i - 1] * (1 - smoothing));
                emaValues.push(ema);
            }
        }
        return emaValues;
    }
    
    const ema12 = calculateEMA(prices, 12);
    const ema26 = calculateEMA(prices, 26);
    
    function executeMACDStep(i) {
        if (i >= prices.length) {
            const lastMACD = macdValues[macdValues.length - 1];
            const signal = lastMACD > 0 ? 'BULLISH ' : lastMACD < 0 ? 'BEARISH ' : 'NEUTRAL ';
            
            explanation.innerHTML = `<strong>MACD Calculation Completed!</strong><br>
                                    Final MACD: ${lastMACD.toFixed(4)} | Signal: ${signal}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>MACD INTERPRETATION:</strong><br>
                     MACD > 0: Bullish momentum (EMA12 > EMA26)<br>
                     MACD < 0: Bearish momentum (EMA12 < EMA26)<br>
                     Rising MACD: Increasing bullish momentum<br>
                     Falling MACD: Decreasing bullish momentum<br>
                     Current Signal: ${signal}
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToStockPrices();
            }, 10000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            return;
        }
        
        if (i < 25) {
            explanation.innerHTML = `Step ${step + 1}: Building EMA datasets (need 26 prices for MACD)`;
            macdValues.push('N/A');
            renderArrayInContainer(macdValues, 'macdArray');
            
            stepsContainer.innerHTML += `
                <div class="calculation-step">
                    <strong>Step ${step + 1}:</strong> Position ${i} - Insufficient data<br>
                    <small>Need 26 prices for MACD calculation, currently have ${i + 1}</small>
                </div>
            `;
            
            step++;
            setTimeout(() => executeMACDStep(i + 1), 1500);
            return;
        }
        
        const macd = ema12[i] - ema26[i];
        
        explanation.innerHTML = `Step ${step + 1}: Calculating MACD for position ${i}<br>
                                MACD = EMA(12): ${ema12[i].toFixed(2)} - EMA(26): ${ema26[i].toFixed(2)}<br>
                                = ${macd.toFixed(4)}`;
        
        // Highlight relevant prices
        const originalElements = originalContainer.querySelectorAll('.array-element');
        originalElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="calculation-step active">
                <strong>Step ${step + 1}:</strong> MACD[${i}] = EMA12[${i}] - EMA26[${i}]<br>
                <strong>Calculation:</strong> ${ema12[i].toFixed(2)} - ${ema26[i].toFixed(2)} = ${macd.toFixed(4)}<br>
                <small>${macd > 0 ? 'Bullish (EMA12 > EMA26)' : macd < 0 ? 'Bearish (EMA12 < EMA26)' : 'Neutral (EMA12 = EMA26)'}</small>
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            originalElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            // Add the calculated MACD
            macdValues.push(macd);
            renderArrayInContainer(macdValues.map(v => typeof v === 'number' ? v.toFixed(4) : v), 'macdArray');
            
            // Highlight the MACD value
            const macdElements = macdContainer.querySelectorAll('.array-element');
            if (i >= 25) {
                const macdElement = macdElements[i].querySelector('.element-value');
                macdElement.classList.add('technical-indicator', 'macd-line');
                
                if (macd > 0) {
                    macdElement.classList.add('trend-up');
                    macdElement.innerHTML = `+${macd.toFixed(4)} `;
                } else if (macd < 0) {
                    macdElement.classList.add('trend-down');
                    macdElement.innerHTML = `${macd.toFixed(4)} `;
                } else {
                    macdElement.innerHTML = `${macd.toFixed(4)} `;
                }
            }
            
            // Update current values
            if (i === prices.length - 1) {
                currentMACD.textContent = macd.toFixed(4);
                currentMACD.className = `stats-value ${macd > 0 ? 'text-success' : macd < 0 ? 'text-danger' : 'text-warning'}`;
                
                const momentumText = macd > 0 ? 'BULLISH ' : macd < 0 ? 'BEARISH ' : 'NEUTRAL ';
                macdMomentum.textContent = momentumText;
                macdMomentum.className = `stats-value ${macd > 0 ? 'text-success' : macd < 0 ? 'text-danger' : 'text-warning'}`;
            }
            
            step++;
            executeMACDStep(i + 1);
        }, 3000);
    }
    
    executeMACDStep(0);
}

// NEW: Perform MACD Signal Line Calculation
function performMACDSignalCalculation() {
    if (originalStockPrices.length < 35) {
        showNotification('Need at least 35 prices for MACD Signal calculation', 'warning');
        return;
    }

    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3"> MACD Signal Line (9-period EMA of MACD)</h5>
        
        <div class="period-selector">
            <div class="period-label">Signal Line = EMA(MACD, 9 periods) | Trigger for buy/sell signals</div>
            <small>Smoothed version of MACD used to generate trading signals when MACD crosses it</small>
        </div>
        
        <div class="array-group">
            <div class="array-label">MACD Values</div>
            <div class="original-array-container" id="macdValuesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Signal Line Values (9-period EMA)</div>
            <div class="transformed-array-container" id="signalArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> Signal Line = EMA(MACD, 9 periods)</p>
            <p class="mb-2"><strong>Trading Signal:</strong> MACD above Signal = Buy, MACD below Signal = Sell</p>
            <p class="mb-0" id="signalExplanation">Starting Signal Line calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="signalStepsContainer">
            <h6 class="text-center">Signal Line Calculation Steps</h6>
            <div class="steps-container" id="signalSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Current Trading Signal</div>
            <div class="stats-value" id="tradingSignal">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSignal" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // First calculate MACD values
    const macdValues = calculateMACDValues(originalStockPrices);
    renderArrayInContainer(macdValues.map(v => typeof v === 'number' ? v.toFixed(4) : v), 'macdValuesArray');
    renderArrayInContainer([], 'signalArray');
    
    executeMACDSignalAnimation(macdValues);
}

// NEW: Calculate MACD Values
function calculateMACDValues(prices) {
    function calculateEMA(prices, period) {
        const smoothing = 2 / (period + 1);
        const emaValues = [];
        
        for (let i = 0; i < prices.length; i++) {
            if (i < period - 1) {
                emaValues.push(null);
            } else if (i === period - 1) {
                const periodPrices = prices.slice(0, i + 1);
                const sum = periodPrices.reduce((a, b) => a + b, 0);
                emaValues.push(sum / period);
            } else {
                const ema = (prices[i] * smoothing) + (emaValues[i - 1] * (1 - smoothing));
                emaValues.push(ema);
            }
        }
        return emaValues;
    }
    
    const ema12 = calculateEMA(prices, 12);
    const ema26 = calculateEMA(prices, 26);
    const macdValues = [];
    
    for (let i = 0; i < prices.length; i++) {
        if (ema12[i] === null || ema26[i] === null) {
            macdValues.push(null);
        } else {
            macdValues.push(ema12[i] - ema26[i]);
        }
    }
    
    return macdValues;
}

// NEW: Execute MACD Signal Animation
function executeMACDSignalAnimation(macdValues) {
    const macdContainer = document.getElementById('macdValuesArray');
    const signalContainer = document.getElementById('signalArray');
    const explanation = document.getElementById('signalExplanation');
    const stepsContainer = document.getElementById('signalSteps');
    const continueButton = document.getElementById('continueAfterSignal');
    const tradingSignal = document.getElementById('tradingSignal');
    
    const signalValues = [];
    let step = 0;
    
    function executeSignalStep(i) {
        if (i >= macdValues.length) {
            const lastMACD = macdValues[macdValues.length - 1];
            const lastSignal = signalValues[signalValues.length - 1];
            const signal = lastMACD > lastSignal ? 'BUY SIGNAL ' : lastMACD < lastSignal ? 'SELL SIGNAL ' : 'NO SIGNAL ';
            
            explanation.innerHTML = `<strong>Signal Line Calculation Completed!</strong><br>
                                    ${signal} | MACD: ${lastMACD.toFixed(4)} vs Signal: ${lastSignal.toFixed(4)}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>TRADING SIGNALS:</strong><br>
                     MACD > Signal Line: BUY Signal (Bullish)<br>
                     MACD < Signal Line: SELL Signal (Bearish)<br>
                     MACD crosses above: Potential uptrend start<br>
                     MACD crosses below: Potential downtrend start<br>
                     Current: ${signal}
                </div>
            `;
            
            tradingSignal.textContent = signal;
            tradingSignal.className = `stats-value ${lastMACD > lastSignal ? 'text-success' : lastMACD < lastSignal ? 'text-danger' : 'text-warning'}`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToStockPrices();
            }, 10000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            return;
        }
        
        if (i < 33) { // 26 for MACD + 8 for signal EMA = 34, but we start from 0
            explanation.innerHTML = `Step ${step + 1}: Building MACD dataset for signal calculation`;
            signalValues.push('N/A');
            renderArrayInContainer(signalValues, 'signalArray');
            
            stepsContainer.innerHTML += `
                <div class="calculation-step">
                    <strong>Step ${step + 1}:</strong> Position ${i} - Preparing data<br>
                    <small>Need sufficient MACD values for signal calculation</small>
                </div>
            `;
            
            step++;
            setTimeout(() => executeSignalStep(i + 1), 1500);
            return;
        }
        
        // Calculate signal line (EMA of MACD with period 9)
        const signalPeriod = 9;
        const smoothing = 2 / (signalPeriod + 1);
        let signal;
        
        if (i === 33) {
            // First signal value (SMA of first 9 MACD values)
            const periodMACD = macdValues.slice(25, 34); // MACD starts at index 25
            const sum = periodMACD.reduce((a, b) => a + b, 0);
            signal = sum / signalPeriod;
            
            explanation.innerHTML = `Step ${step + 1}: Initial Signal Line = SMA of first 9 MACD values<br>
                                    Average of [${periodMACD.map(v => v.toFixed(4)).join(', ')}] = ${signal.toFixed(4)}`;
        } else {
            // Subsequent signal values (EMA)
            signal = (macdValues[i] * smoothing) + (signalValues[i - 1] * (1 - smoothing));
            
            explanation.innerHTML = `Step ${step + 1}: Calculating Signal Line for position ${i}<br>
                                    Formula: (MACD: ${macdValues[i].toFixed(4)}  ${smoothing.toFixed(4)}) + (Prev Signal: ${signalValues[i-1].toFixed(4)}  ${(1-smoothing).toFixed(4)})<br>
                                    = ${signal.toFixed(4)}`;
        }
        
        // Highlight current MACD value
        const macdElements = macdContainer.querySelectorAll('.array-element');
        macdElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="calculation-step active">
                <strong>Step ${step + 1}:</strong> ${i === 33 ? 'Initial Signal' : 'Signal'}[${i}]<br>
                ${i === 33 ? 
                    `Initial = SMA of MACD[25:33] = ${signal.toFixed(4)}` :
                    `Signal = (${macdValues[i].toFixed(4)}  ${smoothing.toFixed(4)}) + (${signalValues[i-1].toFixed(4)}  ${(1-smoothing).toFixed(4)}) = ${signal.toFixed(4)}`
                }<br>
                <small>${macdValues[i] > signal ? 'MACD above Signal (Bullish)' : macdValues[i] < signal ? 'MACD below Signal (Bearish)' : 'MACD = Signal (Neutral)'}</small>
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            macdElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            // Add the calculated signal
            signalValues.push(signal);
            renderArrayInContainer(signalValues.map(v => typeof v === 'number' ? v.toFixed(4) : v), 'signalArray');
            
            // Highlight the signal value
            const signalElements = signalContainer.querySelectorAll('.array-element');
            if (i >= 33) {
                const signalElement = signalElements[i].querySelector('.element-value');
                signalElement.classList.add('technical-indicator', 'macd-signal');
                
                // Compare with MACD
                if (macdValues[i] > signal) {
                    signalElement.classList.add('trend-up');
                    signalElement.innerHTML = `${signal.toFixed(4)} `;
                } else if (macdValues[i] < signal) {
                    signalElement.classList.add('trend-down');
                    signalElement.innerHTML = `${signal.toFixed(4)} `;
                } else {
                    signalElement.innerHTML = `${signal.toFixed(4)} `;
                }
            }
            
            step++;
            executeSignalStep(i + 1);
        }, 3000);
    }
    
    executeSignalStep(0);
}

// NEW: Perform Bollinger Middle Band Calculation
function performBollingerMiddleCalculation() {
    if (originalStockPrices.length < 20) {
        showNotification('Need at least 20 prices for Bollinger Bands calculation', 'warning');
        return;
    }

    const period = 20; // Standard period for Bollinger Bands

    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3"> Bollinger Middle Band (${period}-period SMA)</h5>
        
        <div class="period-selector">
            <div class="period-label">Middle Band = ${period}-period Simple Moving Average</div>
            <small>Base line for Bollinger Bands, represents the intermediate-term trend</small>
        </div>
        
        <div class="array-group">
            <div class="array-label">Stock Prices</div>
            <div class="original-array-container" id="originalPricesArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Middle Band Values (SMA${period})</div>
            <div class="transformed-array-container" id="middleBandArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> Middle Band = SMA(${period} periods)</p>
            <p class="mb-2"><strong>Trading Insight:</strong> Prices above middle band = bullish, below = bearish</p>
            <p class="mb-0" id="middleBandExplanation">Starting Middle Band calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="middleBandStepsContainer">
            <h6 class="text-center">Middle Band Calculation Steps</h6>
            <div class="steps-container" id="middleBandSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Trend Relative to Middle Band</div>
            <div class="stats-value" id="bandPosition">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterMiddleBand" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalStockPrices.map(p => p.toString()), 'originalPricesArray');
    renderArrayInContainer([], 'middleBandArray');
    
    executeBollingerMiddleAnimation(period);
}

// NEW: Execute Bollinger Middle Band Animation
function executeBollingerMiddleAnimation(period) {
    const originalContainer = document.getElementById('originalPricesArray');
    const middleBandContainer = document.getElementById('middleBandArray');
    const explanation = document.getElementById('middleBandExplanation');
    const stepsContainer = document.getElementById('middleBandSteps');
    const continueButton = document.getElementById('continueAfterMiddleBand');
    const bandPosition = document.getElementById('bandPosition');
    
    const prices = [...originalStockPrices];
    const middleBandValues = [];
    let step = 0;
    
    function executeMiddleBandStep(i) {
        if (i >= prices.length) {
            const lastPrice = prices[prices.length - 1];
            const lastMiddleBand = middleBandValues[middleBandValues.length - 1];
            const position = lastPrice > lastMiddleBand ? 'ABOVE BAND ' : lastPrice < lastMiddleBand ? 'BELOW BAND ' : 'ON BAND ';
            
            explanation.innerHTML = `<strong>Middle Band Calculation Completed!</strong><br>
                                    Current Price: ${lastPrice} vs Middle Band: ${lastMiddleBand.toFixed(2)}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>BOLLINGER BANDS INTERPRETATION:</strong><br>
                     Price > Middle Band: Bullish territory<br>
                     Price < Middle Band: Bearish territory  <br>
                     Price touches upper band: Overbought possible<br>
                     Price touches lower band: Oversold possible<br>
                     Current: ${position}
                </div>
            `;
            
            bandPosition.textContent = position;
            bandPosition.className = `stats-value ${lastPrice > lastMiddleBand ? 'text-success' : lastPrice < lastMiddleBand ? 'text-danger' : 'text-warning'}`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToStockPrices();
            }, 10000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            return;
        }
        
        if (i < period - 1) {
            explanation.innerHTML = `Step ${step + 1}: Building dataset for ${period}-period SMA`;
            middleBandValues.push('N/A');
            renderArrayInContainer(middleBandValues, 'middleBandArray');
            
            stepsContainer.innerHTML += `
                <div class="calculation-step">
                    <strong>Step ${step + 1}:</strong> Position ${i} - Gathering data<br>
                    <small>Need ${period} prices for SMA calculation, currently have ${i + 1}</small>
                </div>
            `;
            
            step++;
            setTimeout(() => executeMiddleBandStep(i + 1), 1500);
            return;
        }
        
        // Calculate SMA for current position
        const periodPrices = prices.slice(i - period + 1, i + 1);
        const sum = periodPrices.reduce((a, b) => a + b, 0);
        const sma = sum / period;
        
        explanation.innerHTML = `Step ${step + 1}: Calculating Middle Band for position ${i}<br>
                                SMA = (${periodPrices.join(' + ')}) / ${period}<br>
                                = ${sma.toFixed(2)}`;
        
        // Highlight the prices being used
        const originalElements = originalContainer.querySelectorAll('.array-element');
        for (let j = i - period + 1; j <= i; j++) {
            originalElements[j].querySelector('.element-value').classList.add('sorting-compared');
        }
        originalElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="calculation-step active">
                <strong>Step ${step + 1}:</strong> MiddleBand[${i}] = SMA(${period})<br>
                <strong>Calculation:</strong> (${periodPrices.join(' + ')}) / ${period} = ${sma.toFixed(2)}<br>
                <small>Using prices ${i - period + 1} to ${i}</small>
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            for (let j = i - period + 1; j <= i; j++) {
                originalElements[j].querySelector('.element-value').classList.remove('sorting-compared');
            }
            originalElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            // Add the calculated middle band
            middleBandValues.push(sma);
            renderArrayInContainer(middleBandValues.map(v => typeof v === 'number' ? v.toFixed(2) : v), 'middleBandArray');
            
            // Highlight the middle band value
            const middleBandElements = middleBandContainer.querySelectorAll('.array-element');
            if (i >= period - 1) {
                const middleBandElement = middleBandElements[i].querySelector('.element-value');
                middleBandElement.classList.add('technical-indicator', 'bollinger-band');
                
                // Compare with current price
                if (prices[i] > sma) {
                    middleBandElement.classList.add('trend-up');
                    middleBandElement.innerHTML = `${sma.toFixed(2)} `;
                } else if (prices[i] < sma) {
                    middleBandElement.classList.add('trend-down');
                    middleBandElement.innerHTML = `${sma.toFixed(2)} `;
                } else {
                    middleBandElement.innerHTML = `${sma.toFixed(2)} `;
                }
            }
            
            step++;
            executeMiddleBandStep(i + 1);
        }, 3000);
    }
    
    executeMiddleBandStep(0);
}

// NEW: Perform Bollinger Upper Band Calculation
function performBollingerUpperCalculation() {
    if (originalStockPrices.length < 20) {
        showNotification('Need at least 20 prices for Bollinger Bands calculation', 'warning');
        return;
    }

    const period = 20; // Standard period for Bollinger Bands
    const stdDevMultiplier = 2; // Standard deviation multiplier

    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3"> Bollinger Upper Band (SMA + 2StdDev)</h5>
        
        <div class="period-selector">
            <div class="period-label">Upper Band = Middle Band + (${stdDevMultiplier}  Standard Deviation)</div>
            <small>Represents overbought territory, often acts as resistance level</small>
        </div>
        
        <div class="array-group">
            <div class="array-label">Stock Prices & Middle Band</div>
            <div class="original-array-container" id="pricesAndMiddleArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Upper Band Values</div>
            <div class="transformed-array-container" id="upperBandArray"></div>
        </div>
        
        <div class="financial-explanation">
            <p class="mb-2"><strong>Formula:</strong> Upper Band = Middle Band + (${stdDevMultiplier}  StdDev)</p>
            <p class="mb-2"><strong>Trading Insight:</strong> Prices near upper band may be overbought, potential reversal area</p>
            <p class="mb-0" id="upperBandExplanation">Starting Upper Band calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="upperBandStepsContainer">
            <h6 class="text-center">Upper Band Calculation Steps</h6>
            <div class="steps-container" id="upperBandSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Current Volatility Level</div>
            <div class="stats-value" id="volatilityLevel">-</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterUpperBand" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Stock Prices
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Calculate middle band values first
    const middleBandValues = calculateMiddleBandValues(originalStockPrices, period);
    const displayValues = originalStockPrices.map((price, i) => 
        `${price} | MB: ${middleBandValues[i] !== null && typeof middleBandValues[i] === 'number' ? middleBandValues[i].toFixed(2) : 'N/A'}`
    );
    
    renderArrayInContainer(displayValues, 'pricesAndMiddleArray');
    renderArrayInContainer([], 'upperBandArray');
    
    executeBollingerUpperAnimation(period, stdDevMultiplier, middleBandValues);
}

// NEW: Calculate Middle Band Values
function calculateMiddleBandValues(prices, period) {
    const middleBandValues = [];
    
    for (let i = 0; i < prices.length; i++) {
        if (i < period - 1) {
            middleBandValues.push(null);
        } else {
            const periodPrices = prices.slice(i - period + 1, i + 1);
            const sum = periodPrices.reduce((a, b) => a + b, 0);
            middleBandValues.push(sum / period);
        }
    }
    
    return middleBandValues;
}

// NEW: Execute Bollinger Upper Band Animation
function executeBollingerUpperAnimation(period, stdDevMultiplier, middleBandValues) {
    const pricesAndMiddleContainer = document.getElementById('pricesAndMiddleArray');
    const upperBandContainer = document.getElementById('upperBandArray');
    const explanation = document.getElementById('upperBandExplanation');
    const stepsContainer = document.getElementById('upperBandSteps');
    const continueButton = document.getElementById('continueAfterUpperBand');
    const volatilityLevel = document.getElementById('volatilityLevel');
    
    const prices = [...originalStockPrices];
    const upperBandValues = [];
    let step = 0;
    
    function executeUpperBandStep(i) {
        if (i >= prices.length) {
            const lastPrice = prices[prices.length - 1];
            const lastUpperBand = upperBandValues[upperBandValues.length - 1];
            const proximity = ((lastPrice / lastUpperBand) * 100).toFixed(1);
            const volatility = lastUpperBand - middleBandValues[middleBandValues.length - 1];
            
            explanation.innerHTML = `<strong>Upper Band Calculation Completed!</strong><br>
                                    Price is at ${proximity}% of upper band | Band Width: ${volatility.toFixed(2)}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>UPPER BAND TRADING SIGNALS:</strong><br>
                     Price > Upper Band: Strong overbought (Caution)<br>
                     Price near Upper Band: Potential resistance<br>
                     Band Width expanding: Increasing volatility<br>
                     Band Width contracting: Decreasing volatility<br>
                     Current Band Width: ${volatility.toFixed(2)}
                </div>
            `;
            
            const volText = volatility > (prices[0] * 0.1) ? 'HIGH VOLATILITY ' : volatility > (prices[0] * 0.05) ? 'MEDIUM VOLATILITY ' : 'LOW VOLATILITY ';
            volatilityLevel.textContent = volText;
            volatilityLevel.className = `stats-value ${volatility > (prices[0] * 0.1) ? 'volatility-high' : volatility > (prices[0] * 0.05) ? 'text-warning' : 'text-info'}`;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToStockPrices();
            }, 10000);
            
            continueButton.addEventListener('click', returnToStockPrices);
            return;
        }
        
        if (i < period - 1) {
            explanation.innerHTML = `Step ${step + 1}: Building datasets for upper band calculation`;
            upperBandValues.push('N/A');
            renderArrayInContainer(upperBandValues, 'upperBandArray');
            
            stepsContainer.innerHTML += `
                <div class="calculation-step">
                    <strong>Step ${step + 1}:</strong> Position ${i} - Preparing data<br>
                    <small>Need ${period} prices for standard deviation calculation</small>
                </div>
            `;
            
            step++;
            setTimeout(() => executeUpperBandStep(i + 1), 1500);
            return;
        }
        
        // Calculate standard deviation
        const periodPrices = prices.slice(i - period + 1, i + 1);
        const mean = middleBandValues[i];
        const squaredDiffs = periodPrices.map(price => Math.pow(price - mean, 2));
        const variance = squaredDiffs.reduce((a, b) => a + b, 0) / period;
        const stdDev = Math.sqrt(variance);
        const upperBand = mean + (stdDev * stdDevMultiplier);
        
        explanation.innerHTML = `Step ${step + 1}: Calculating Upper Band for position ${i}<br>
                                StdDev = [(price - mean) / ${period}] = ${stdDev.toFixed(2)}<br>
                                Upper Band = ${mean.toFixed(2)} + (${stdDev.toFixed(2)}  ${stdDevMultiplier}) = ${upperBand.toFixed(2)}`;
        
        // Highlight relevant data
        const pricesAndMiddleElements = pricesAndMiddleContainer.querySelectorAll('.array-element');
        pricesAndMiddleElements[i].querySelector('.element-value').classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="calculation-step active">
                <strong>Step ${step + 1}:</strong> UpperBand[${i}]<br>
                <strong>Standard Deviation:</strong> ${stdDev.toFixed(2)}<br>
                <strong>Calculation:</strong> ${mean.toFixed(2)} + (${stdDev.toFixed(2)}  ${stdDevMultiplier}) = ${upperBand.toFixed(2)}<br>
                <small>Volatility Measure: ${stdDev.toFixed(2)} (${((stdDev/mean)*100).toFixed(1)}% of mean)</small>
            </div>
        `;
        
        setTimeout(() => {
            // Remove highlights
            pricesAndMiddleElements[i].querySelector('.element-value').classList.remove('sorting-current');
            
            // Add the calculated upper band
            upperBandValues.push(upperBand);
            renderArrayInContainer(upperBandValues.map(v => typeof v === 'number' ? v.toFixed(2) : v), 'upperBandArray');
            
            // Highlight the upper band value
            const upperBandElements = upperBandContainer.querySelectorAll('.array-element');
            if (i >= period - 1) {
                const upperBandElement = upperBandElements[i].querySelector('.element-value');
                upperBandElement.classList.add('technical-indicator', 'bollinger-band', 'volatility-high');
                
                // Check if price is near upper band
                const priceProximity = (prices[i] / upperBand) * 100;
                if (priceProximity > 95) {
                    upperBandElement.classList.add('trend-up');
                    upperBandElement.innerHTML = `${upperBand.toFixed(2)} `;
                } else {
                    upperBandElement.innerHTML = `${upperBand.toFixed(2)} `;
                }
            }
            
            step++;
            executeUpperBandStep(i + 1);
        }, 3500);
    }
    
    executeUpperBandStep(0);
}
// NEW: Handle Axis Function Selection Change
function handleAxisFunctionChange() {
    const selectedFunction = axisFunctionSelect.value;
    
    // Show/hide custom function input
    if (selectedFunction === 'custom') {
        customFunctionGroup.style.display = 'block';
    } else {
        customFunctionGroup.style.display = 'none';
    }
    
    // Show matrix dimensions for all axis operations
    matrixDimensionsGroup.style.display = 'block';
}

// NEW: Create Matrix Handler
function handleCreateMatrix() {
    const rows = parseInt(matrixRowsInput.value);
    const cols = parseInt(matrixColsInput.value);
    
    if (isNaN(rows) || rows < 1 || rows > 10 || isNaN(cols) || cols < 1 || cols > 10) {
        showNotification('Please enter valid matrix dimensions (1-10 for rows and columns)', 'danger');
        return;
    }
    
    matrixRows = rows;
    matrixCols = cols;
    
    // Create a sample matrix with random values
    currentMatrix = [];
    for (let i = 0; i < rows; i++) {
        const row = [];
        for (let j = 0; j < cols; j++) {
            row.push(Math.floor(Math.random() * 100) + 1); // Random values 1-100
        }
        currentMatrix.push(row);
    }
    
    // Store original array
    originalArrayForAxis = [...myArray];
    
    // Show matrix visualization
    showMatrixVisualization(currentMatrix, 'Original Matrix');
    
    logOperation(`Created ${rows}x${cols} matrix for axis operations`, 'success');
    showNotification(`Created ${rows}x${cols} matrix successfully`, 'success');
}

// NEW: Apply Axis Operation Handler
function handleApplyAxis() {
    const selectedFunction = axisFunctionSelect.value;
    
    if (!selectedFunction) {
        showNotification('Please select an operation', 'warning');
        return;
    }
    
    if (currentMatrix.length === 0) {
        showNotification('Please create a matrix first', 'warning');
        return;
    }
    
    if (isAxisOperationRunning) {
        showNotification('An axis operation is already in progress', 'warning');
        return;
    }
    
    isAxisOperationRunning = true;
    
    // Perform the selected axis operation
    performAxisOperation(selectedFunction);
}

// NEW: Show Matrix Visualization
function showMatrixVisualization(matrix, title) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">${title}</h5>
        
        <div class="array-group">
            <div class="array-label">Matrix (${matrix.length}  ${matrix[0].length})</div>
            <div class="matrix-container" id="matrixDisplay"></div>
        </div>
        
        <div class="axis-operation-explanation">
            <p class="mb-2"><strong>apply_along_axis() Simulation:</strong> Applying function to 1D slices</p>
            <p class="mb-0" id="axisExplanation">Ready to perform axis operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="axisStepsContainer">
            <h6 class="text-center">Operation Steps</h6>
            <div class="steps-container" id="axisSteps"></div>
        </div>
        
        <div id="resultContainer" style="display: none;">
            <div class="array-group mt-3">
                <div class="array-label">Result</div>
                <div class="matrix-container" id="resultDisplay"></div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterAxis" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderMatrix(matrix, 'matrixDisplay');
}

// NEW: Render Matrix
function renderMatrix(matrix, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    container.style.gridTemplateColumns = `repeat(${matrix[0].length}, 1fr)`;
    
    matrix.forEach((row, i) => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'matrix-row';
        
        row.forEach((cell, j) => {
            const cellDiv = document.createElement('div');
            cellDiv.className = 'matrix-cell';
            cellDiv.textContent = cell;
            cellDiv.title = `[${i}][${j}] = ${cell}`;
            rowDiv.appendChild(cellDiv);
        });
        
        container.appendChild(rowDiv);
    });
}

// NEW: Perform Axis Operation - ENHANCED VERSION
function performAxisOperation(operation) {
    const explanation = document.getElementById('axisExplanation');
    const stepsContainer = document.getElementById('axisSteps');
    const resultContainer = document.getElementById('resultContainer');
    const continueButton = document.getElementById('continueAfterAxis');
    
    let operationName = '';
    let operationType = ''; // 'row' or 'col'
    
    // Define the operation functions with better error handling
    const operations = {
        rowSum: {
            name: 'Row-wise Sum',
            type: 'row',
            func: (arr) => {
                if (!arr.every(val => !isNaN(parseFloat(val)))) {
                    throw new Error('All elements must be numbers for sum operation');
                }
                return arr.reduce((a, b) => parseFloat(a) + parseFloat(b), 0);
            },
            description: 'Sum of all elements in each row'
        },
        colMean: {
            name: 'Column-wise Mean',
            type: 'col',
            func: (arr) => {
                if (!arr.every(val => !isNaN(parseFloat(val)))) {
                    throw new Error('All elements must be numbers for mean operation');
                }
                const sum = arr.reduce((a, b) => parseFloat(a) + parseFloat(b), 0);
                return sum / arr.length;
            },
            description: 'Average of all elements in each column'
        },
        rowStd: {
            name: 'Row-wise Standard Deviation',
            type: 'row',
            func: (arr) => {
                if (!arr.every(val => !isNaN(parseFloat(val)))) {
                    throw new Error('All elements must be numbers for standard deviation');
                }
                const floatArr = arr.map(val => parseFloat(val));
                const mean = floatArr.reduce((a, b) => a + b, 0) / floatArr.length;
                return Math.sqrt(floatArr.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / floatArr.length);
            },
            description: 'Standard deviation of elements in each row'
        },
        colMedian: {
            name: 'Column-wise Median',
            type: 'col',
            func: (arr) => {
                if (!arr.every(val => !isNaN(parseFloat(val)))) {
                    throw new Error('All elements must be numbers for median operation');
                }
                const sorted = arr.map(val => parseFloat(val)).sort((a, b) => a - b);
                const mid = Math.floor(sorted.length / 2);
                return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
            },
            description: 'Median value of elements in each column'
        },
        rowMax: {
            name: 'Row-wise Maximum',
            type: 'row',
            func: (arr) => {
                if (!arr.every(val => !isNaN(parseFloat(val)))) {
                    throw new Error('All elements must be numbers for max operation');
                }
                return Math.max(...arr.map(val => parseFloat(val)));
            },
            description: 'Maximum value in each row'
        },
        rowMin: {
            name: 'Row-wise Minimum',
            type: 'row',
            func: (arr) => {
                if (!arr.every(val => !isNaN(parseFloat(val)))) {
                    throw new Error('All elements must be numbers for min operation');
                }
                return Math.min(...arr.map(val => parseFloat(val)));
            },
            description: 'Minimum value in each row'
        },
        colVariance: {
            name: 'Column-wise Variance',
            type: 'col',
            func: (arr) => {
                if (!arr.every(val => !isNaN(parseFloat(val)))) {
                    throw new Error('All elements must be numbers for variance operation');
                }
                const floatArr = arr.map(val => parseFloat(val));
                const mean = floatArr.reduce((a, b) => a + b, 0) / floatArr.length;
                return floatArr.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / floatArr.length;
            },
            description: 'Variance of elements in each column'
        },
        rowRange: {
            name: 'Row-wise Range',
            type: 'row',
            func: (arr) => {
                if (!arr.every(val => !isNaN(parseFloat(val)))) {
                    throw new Error('All elements must be numbers for range operation');
                }
                const floatArr = arr.map(val => parseFloat(val));
                return Math.max(...floatArr) - Math.min(...floatArr);
            },
            description: 'Range (max-min) of elements in each row'
        },
        rowNormalize: {
            name: 'Row-wise Normalization',
            type: 'row',
            func: (arr) => {
                if (!arr.every(val => !isNaN(parseFloat(val)))) {
                    throw new Error('All elements must be numbers for normalization');
                }
                const floatArr = arr.map(val => parseFloat(val));
                const min = Math.min(...floatArr);
                const max = Math.max(...floatArr);
                if (min === max) return floatArr.map(() => 0); // Avoid division by zero
                return floatArr.map(val => (val - min) / (max - min));
            },
            description: 'Normalize each row to [0,1] range'
        },
        colZScore: {
            name: 'Column-wise Z-Score',
            type: 'col',
            func: (arr) => {
                if (!arr.every(val => !isNaN(parseFloat(val)))) {
                    throw new Error('All elements must be numbers for Z-score normalization');
                }
                const floatArr = arr.map(val => parseFloat(val));
                const mean = floatArr.reduce((a, b) => a + b, 0) / floatArr.length;
                const std = Math.sqrt(floatArr.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / floatArr.length);
                if (std === 0) return floatArr.map(() => 0); // Avoid division by zero
                return floatArr.map(val => (val - mean) / std);
            },
            description: 'Z-score normalization for each column'
        },
        custom: {
            name: 'Custom Function',
            type: 'row',
            func: null,
            description: 'Custom user-defined function'
        }
    };
    
    const opConfig = operations[operation];
    
    if (operation === 'custom') {
        try {
            const customFunc = new Function('arr', `
                try {
                    ${customFunction.value}
                } catch (error) {
                    throw new Error('Custom function error: ' + error.message);
                }
            `);
            opConfig.func = customFunc;
        } catch (error) {
            showNotification('Invalid custom function: ' + error.message, 'danger');
            isAxisOperationRunning = false;
            return;
        }
    }
    
    operationName = opConfig.name;
    operationType = opConfig.type;
    
    explanation.innerHTML = `<strong>${operationName}</strong><br>${opConfig.description}`;
    explanation.classList.add('highlight');
    
    // Clear previous results
    stepsContainer.innerHTML = '';
    resultContainer.style.display = 'none';
    continueButton.style.display = 'none';
    
    // Perform the axis operation with animation
    performAxisOperationAnimation(currentMatrix, opConfig.func, operationType, operationName);
}

// NEW: Perform Axis Operation with Animation - FIXED VERSION
function performAxisOperationAnimation(matrix, operation, type, name) {
    const explanation = document.getElementById('axisExplanation');
    const stepsContainer = document.getElementById('axisSteps');
    const resultContainer = document.getElementById('resultContainer');
    const continueButton = document.getElementById('continueAfterAxis');
    const matrixDisplay = document.getElementById('matrixDisplay');
    
    let result = [];
    let step = 0;
    
    // Clear previous steps
    stepsContainer.innerHTML = '';
    
    function performStep() {
        if (type === 'row' && step >= matrix.length) {
            finishOperation();
            return;
        }
        
        if (type === 'col' && step >= matrix[0].length) {
            finishOperation();
            return;
        }
        
        if (type === 'row') {
            // Row-wise operation
            const currentRow = matrix[step];
            explanation.innerHTML = `Processing row ${step}: [${currentRow.join(', ')}]`;
            
            // Highlight current row
            const rows = matrixDisplay.querySelectorAll('.matrix-row');
            if (rows[step]) {
                const cells = rows[step].querySelectorAll('.matrix-cell');
                
                cells.forEach(cell => {
                    cell.classList.add('highlight');
                });
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step + 1}:</strong> Processing row ${step} = [${currentRow.join(', ')}]
                    </div>
                `;
                
                // Scroll to show the current step
                stepsContainer.scrollTop = stepsContainer.scrollHeight;
                
                setTimeout(() => {
                    // Apply operation
                    let rowResult;
                    try {
                        rowResult = operation(currentRow);
                        result.push(rowResult);
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Result:</strong> ${name} for row ${step} = ${Array.isArray(rowResult) ? `[${rowResult.map(r => typeof r === 'number' ? r.toFixed(2) : r).join(', ')}]` : (typeof rowResult === 'number' ? rowResult.toFixed(2) : rowResult)}
                            </div>
                        `;
                        
                        // Scroll to show the result
                        stepsContainer.scrollTop = stepsContainer.scrollHeight;
                        
                    } catch (error) {
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step" style="border-left-color: var(--danger-color);">
                                <strong>Error:</strong> ${error.message}
                            </div>
                        `;
                        result.push(null);
                    }
                    
                    // Remove highlight with animation
                    cells.forEach((cell, index) => {
                        setTimeout(() => {
                            cell.classList.remove('highlight');
                        }, index * 100);
                    });
                    
                    step++;
                    setTimeout(performStep, 1000);
                }, 2000);
            }
            
        } else {
            // Column-wise operation
            explanation.innerHTML = `Processing column ${step}`;
            
            // Highlight current column
            const rows = matrixDisplay.querySelectorAll('.matrix-row');
            const column = matrix.map(row => row[step]);
            
            // Highlight all cells in this column
            rows.forEach((row, rowIndex) => {
                const cells = row.querySelectorAll('.matrix-cell');
                if (cells[step]) {
                    setTimeout(() => {
                        cells[step].classList.add('highlight');
                    }, rowIndex * 100);
                }
            });
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step + 1}:</strong> Processing column ${step} = [${column.join(', ')}]
                </div>
            `;
            
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            setTimeout(() => {
                // Apply operation
                let colResult;
                try {
                    colResult = operation(column);
                    result.push(colResult);
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Result:</strong> ${name} for column ${step} = ${Array.isArray(colResult) ? `[${colResult.map(r => typeof r === 'number' ? r.toFixed(2) : r).join(', ')}]` : (typeof colResult === 'number' ? colResult.toFixed(2) : colResult)}
                        </div>
                    `;
                    
                    stepsContainer.scrollTop = stepsContainer.scrollHeight;
                    
                } catch (error) {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step" style="border-left-color: var(--danger-color);">
                            <strong>Error:</strong> ${error.message}
                        </div>
                    `;
                    result.push(null);
                }
                
                // Remove highlight from column
                rows.forEach((row, rowIndex) => {
                    const cells = row.querySelectorAll('.matrix-cell');
                    if (cells[step]) {
                        setTimeout(() => {
                            cells[step].classList.remove('highlight');
                        }, rowIndex * 100);
                    }
                });
                
                step++;
                setTimeout(performStep, 1000);
            }, 2000 + (rows.length * 100));
        }
    }
    
    function finishOperation() {
        explanation.innerHTML = `<strong>${name} Completed!</strong> All ${type === 'row' ? 'rows' : 'columns'} processed.`;
        
        // Filter out null results from errors
        const validResults = result.filter(r => r !== null);
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Final Result:</strong> [${validResults.map(r => 
                    Array.isArray(r) ? `[${r.map(v => typeof v === 'number' ? v.toFixed(2) : v).join(', ')}]` : 
                    (typeof r === 'number' ? r.toFixed(2) : r)
                ).join(', ')}]
            </div>
        `;
        
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Show result after a delay
        setTimeout(() => {
            resultContainer.style.display = 'block';
            
            if (type === 'row') {
                // For row operations, result is a 1D array - show as single row
                const resultMatrix = [validResults];
                renderMatrix(resultMatrix, 'resultDisplay');
                
                // Add labels
                const resultDisplay = document.getElementById('resultDisplay');
                resultDisplay.previousElementSibling.innerHTML = 
                    `Result (Row-wise ${name}): 1  ${validResults.length}`;
            } else {
                // For column operations, result is a 1D array - show as single row
                const resultMatrix = [validResults];
                renderMatrix(resultMatrix, 'resultDisplay');
                
                // Add labels
                const resultDisplay = document.getElementById('resultDisplay');
                resultDisplay.previousElementSibling.innerHTML = 
                    `Result (Column-wise ${name}): 1  ${validResults.length}`;
            }
            
            // Highlight result cells with animation
            const resultCells = document.querySelectorAll('#resultDisplay .matrix-cell');
            resultCells.forEach((cell, index) => {
                setTimeout(() => {
                    cell.classList.add('result');
                    cell.style.animation = 'bounce 0.5s ease';
                }, index * 200);
            });
            
            continueButton.style.display = 'block';
            
        }, 1000);
        
        // Auto-return after 10 seconds
        const autoReturnTimer = setTimeout(() => {
            returnToOriginalAfterAxis();
        }, 10000);
        
        continueButton.addEventListener('click', () => {
            clearTimeout(autoReturnTimer);
            returnToOriginalAfterAxis();
        });
    }
    
    // Start the operation with a small delay
    setTimeout(performStep, 500);
}

// Also update the CSS to ensure animations work properly - ADD THESE STYLES:
// NEW: Return to Original after Axis Operation
function returnToOriginalAfterAxis() {
    // Reset to original array
    myArray = [...originalArrayForAxis];
    originalArrayForAxis = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isAxisOperationRunning = false;
    currentMatrix = [];
    
    // Clear inputs
    axisFunctionSelect.value = '';
    customFunction.value = '';
    matrixRowsInput.value = '';
    matrixColsInput.value = '';
    customFunctionGroup.style.display = 'none';
    matrixDimensionsGroup.style.display = 'none';
    
    logOperation('Axis operation completed - returned to original array', 'info');
    showNotification('Returned to original array after axis operation', 'success');
}
// NEW: Statistical Analysis Operations Handler
function handleStatisticalOperation(operation) {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Statistical operations require all array elements to be numbers', 'danger');
        return;
    }
    
    if (isStatisticalAnalysisRunning) {
        showNotification('A statistical analysis operation is already in progress', 'warning');
        return;
    }
    
    currentStatOperation = operation; // Using renamed variable
    
    if (operation === 'nSmallest' || operation === 'nLargest') {
        // Show N value input for these operations
        nValueInputGroup.style.display = 'block';
        nValueInput.focus();
        nValueInput.placeholder = `Enter N (1 to ${myArray.length})`;
    } else {
        // Directly perform min/max index operations
        performStatisticalOperation(operation);
    }
}

// NEW: Confirm N Value Handler
function handleConfirmNValue() {
    const nValue = parseInt(nValueInput.value);
    const maxN = myArray.length;
    
    if (isNaN(nValue) || nValue < 1 || nValue > maxN) {
        showNotification(`Please enter a valid N value between 1 and ${maxN}`, 'danger');
        nValueInput.focus();
        return;
    }
    
    nValueForStatisticalAnalysis = nValue;
    nValueInputGroup.style.display = 'none';
    nValueInput.value = '';
    
    performStatisticalOperation(currentStatOperation); // Using renamed variable
}

// NEW: Cancel N Value Handler
function handleCancelNValue() {
    nValueInputGroup.style.display = 'none';
    nValueInput.value = '';
    currentStatOperation = null; // Using renamed variable
}

// NEW: Perform Statistical Operation
function performStatisticalOperation(operation) {
    isStatisticalAnalysisRunning = true;
    
    // Store original array
    originalArrayForStatisticalOps = [...myArray];
    
    // Convert array to numbers
    const numericArray = myArray.map(val => parseFloat(val));
    
    switch(operation) {
        case 'minIndex':
            findMinIndex(numericArray);
            break;
        case 'maxIndex':
            findMaxIndex(numericArray);
            break;
        case 'nSmallest':
            findNSmallestValues(numericArray);
            break;
        case 'nLargest':
            findNLargestValues(numericArray);
            break;
    }
}

// NEW: Find Minimum Index
function findMinIndex(numericArray) {
    let minIndex = 0;
    let minValue = numericArray[0];
    
    // Create visualization container
    const statsContainer = document.createElement('div');
    statsContainer.className = 'stats-results-container';
    statsContainer.innerHTML = `
        <h5 class="text-center mb-3">Finding Minimum Value Index</h5>
        <div class="array-container" id="statsArrayContainer"></div>
        <div id="statsResults" class="mt-3"></div>
        <button class="btn btn-sm btn-outline-light mt-3 w-100" id="resetAfterStats">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(statsContainer);
    
    renderArrayInContainer(originalArrayForStatisticalOps, 'statsArrayContainer');
    
    const resultsDiv = document.getElementById('statsResults');
    const arrayContainer = document.getElementById('statsArrayContainer');
    const resetBtn = document.getElementById('resetAfterStats');
    
    let currentIndex = 0;
    
    function findMinStep() {
        if (currentIndex >= numericArray.length) {
            // Search completed
            resultsDiv.innerHTML = `
                <div class="alert alert-success">
                    <h6><i class="fas fa-check-circle me-2"></i>Minimum Value Found!</h6>
                    <p class="mb-1">Index: <strong>${minIndex}</strong></p>
                    <p class="mb-1">Value: <strong>${minValue}</strong></p>
                    <p class="mb-0">Position: <strong>${minIndex + 1}</strong> of ${numericArray.length}</p>
                </div>
            `;
            
            // Highlight the minimum element
            const elements = arrayContainer.querySelectorAll('.array-element');
            elements[minIndex].querySelector('.element-value').classList.add('stat-min-highlight');
            
            resetBtn.style.display = 'block';
            resetBtn.addEventListener('click', resetAfterStatisticalOperation);
            
            // Auto-reset after 5 seconds
            setTimeout(() => {
                resetAfterStatisticalOperation();
            }, 5000);
            
            return;
        }
        
        // Highlight current element being checked
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElement = elements[currentIndex].querySelector('.element-value');
        
        if (currentIndex === 0) {
            // First element - initialize min
            currentElement.classList.add('stat-min-highlight');
            setTimeout(() => {
                currentIndex++;
                findMinStep();
            }, 1000);
        } else {
            currentElement.classList.add('sorting-current');
            
            setTimeout(() => {
                if (numericArray[currentIndex] < minValue) {
                    // New minimum found
                    minValue = numericArray[currentIndex];
                    minIndex = currentIndex;
                    
                    // Remove highlight from previous min
                    elements[minIndex].querySelector('.element-value').classList.remove('stat-min-highlight');
                    // Add highlight to new min
                    currentElement.classList.remove('sorting-current');
                    currentElement.classList.add('stat-min-highlight');
                    
                    resultsDiv.innerHTML = `
                        <div class="alert alert-info">
                            <p class="mb-1">New minimum found at index ${currentIndex}</p>
                            <p class="mb-0">Current minimum: ${minValue} at index ${minIndex}</p>
                        </div>
                    `;
                } else {
                    // Not a new minimum
                    currentElement.classList.remove('sorting-current');
                }
                
                currentIndex++;
                findMinStep();
            }, 1000);
        }
    }
    
    // Start the search
    findMinStep();
}

// NEW: Find Maximum Index
function findMaxIndex(numericArray) {
    let maxIndex = 0;
    let maxValue = numericArray[0];
    
    // Create visualization container
    const statsContainer = document.createElement('div');
    statsContainer.className = 'stats-results-container';
    statsContainer.innerHTML = `
        <h5 class="text-center mb-3">Finding Maximum Value Index</h5>
        <div class="array-container" id="statsArrayContainer"></div>
        <div id="statsResults" class="mt-3"></div>
        <button class="btn btn-sm btn-outline-light mt-3 w-100" id="resetAfterStats">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(statsContainer);
    
    renderArrayInContainer(originalArrayForStatisticalOps, 'statsArrayContainer');
    
    const resultsDiv = document.getElementById('statsResults');
    const arrayContainer = document.getElementById('statsArrayContainer');
    const resetBtn = document.getElementById('resetAfterStats');
    
    let currentIndex = 0;
    
    function findMaxStep() {
        if (currentIndex >= numericArray.length) {
            // Search completed
            resultsDiv.innerHTML = `
                <div class="alert alert-success">
                    <h6><i class="fas fa-check-circle me-2"></i>Maximum Value Found!</h6>
                    <p class="mb-1">Index: <strong>${maxIndex}</strong></p>
                    <p class="mb-1">Value: <strong>${maxValue}</strong></p>
                    <p class="mb-0">Position: <strong>${maxIndex + 1}</strong> of ${numericArray.length}</p>
                </div>
            `;
            
            // Highlight the maximum element
            const elements = arrayContainer.querySelectorAll('.array-element');
            elements[maxIndex].querySelector('.element-value').classList.add('stat-max-highlight');
            
            resetBtn.style.display = 'block';
            resetBtn.addEventListener('click', resetAfterStatisticalOperation);
            
            // Auto-reset after 5 seconds
            setTimeout(() => {
                resetAfterStatisticalOperation();
            }, 5000);
            
            return;
        }
        
        // Highlight current element being checked
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElement = elements[currentIndex].querySelector('.element-value');
        
        if (currentIndex === 0) {
            // First element - initialize max
            currentElement.classList.add('stat-max-highlight');
            setTimeout(() => {
                currentIndex++;
                findMaxStep();
            }, 1000);
        } else {
            currentElement.classList.add('sorting-current');
            
            setTimeout(() => {
                if (numericArray[currentIndex] > maxValue) {
                    // New maximum found
                    maxValue = numericArray[currentIndex];
                    maxIndex = currentIndex;
                    
                    // Remove highlight from previous max
                    elements[maxIndex].querySelector('.element-value').classList.remove('stat-max-highlight');
                    // Add highlight to new max
                    currentElement.classList.remove('sorting-current');
                    currentElement.classList.add('stat-max-highlight');
                    
                    resultsDiv.innerHTML = `
                        <div class="alert alert-info">
                            <p class="mb-1">New maximum found at index ${currentIndex}</p>
                            <p class="mb-0">Current maximum: ${maxValue} at index ${maxIndex}</p>
                        </div>
                    `;
                } else {
                    // Not a new maximum
                    currentElement.classList.remove('sorting-current');
                }
                
                currentIndex++;
                findMaxStep();
            }, 1000);
        }
    }
    
    // Start the search
    findMaxStep();
}

// NEW: Find N Smallest Values
function findNSmallestValues(numericArray) {
    const n = nValueForStatisticalAnalysis;
    
    // Create visualization container
    const statsContainer = document.createElement('div');
    statsContainer.className = 'stats-results-container';
    statsContainer.innerHTML = `
        <h5 class="text-center mb-3">Finding ${n} Smallest Values</h5>
        <div class="array-container" id="statsArrayContainer"></div>
        <div id="statsResults" class="mt-3"></div>
        <button class="btn btn-sm btn-outline-light mt-3 w-100" id="resetAfterStats">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(statsContainer);
    
    renderArrayInContainer(originalArrayForStatisticalOps, 'statsArrayContainer');
    
    const resultsDiv = document.getElementById('statsResults');
    const arrayContainer = document.getElementById('statsArrayContainer');
    const resetBtn = document.getElementById('resetAfterStats');
    
    // Create array with indices for tracking
    const indexedArray = numericArray.map((value, index) => ({ value, index }));
    
    // Sort to find N smallest values
    indexedArray.sort((a, b) => a.value - b.value);
    const nSmallest = indexedArray.slice(0, n);
    
    // Display results
    resultsDiv.innerHTML = `
        <div class="alert alert-success">
            <h6><i class="fas fa-check-circle me-2"></i>${n} Smallest Values Found!</h6>
            <div class="mt-2">
                ${nSmallest.map((item, i) => `
                    <div class="stats-result-item">
                        ${i + 1}. Index ${item.index}: ${item.value}
                    </div>
                `).join('')}
            </div>
        </div>
    `;
    
    // Highlight the N smallest elements with animation
    const elements = arrayContainer.querySelectorAll('.array-element');
    nSmallest.forEach((item, i) => {
        setTimeout(() => {
            elements[item.index].querySelector('.element-value').classList.add('stat-n-smallest');
        }, i * 300);
    });
    
    resetBtn.style.display = 'block';
    resetBtn.addEventListener('click', resetAfterStatisticalOperation);
    
    // Auto-reset after 8 seconds
    setTimeout(() => {
        resetAfterStatisticalOperation();
    }, 8000);
}

// NEW: Find N Largest Values
function findNLargestValues(numericArray) {
    const n = nValueForStatisticalAnalysis;
    
    // Create visualization container
    const statsContainer = document.createElement('div');
    statsContainer.className = 'stats-results-container';
    statsContainer.innerHTML = `
        <h5 class="text-center mb-3">Finding ${n} Largest Values</h5>
        <div class="array-container" id="statsArrayContainer"></div>
        <div id="statsResults" class="mt-3"></div>
        <button class="btn btn-sm btn-outline-light mt-3 w-100" id="resetAfterStats">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(statsContainer);
    
    renderArrayInContainer(originalArrayForStatisticalOps, 'statsArrayContainer');
    
    const resultsDiv = document.getElementById('statsResults');
    const arrayContainer = document.getElementById('statsArrayContainer');
    const resetBtn = document.getElementById('resetAfterStats');
    
    // Create array with indices for tracking
    const indexedArray = numericArray.map((value, index) => ({ value, index }));
    
    // Sort to find N largest values
    indexedArray.sort((a, b) => b.value - a.value);
    const nLargest = indexedArray.slice(0, n);
    
    // Display results
    resultsDiv.innerHTML = `
        <div class="alert alert-success">
            <h6><i class="fas fa-check-circle me-2"></i>${n} Largest Values Found!</h6>
            <div class="mt-2">
                ${nLargest.map((item, i) => `
                    <div class="stats-result-item">
                        ${i + 1}. Index ${item.index}: ${item.value}
                    </div>
                `).join('')}
            </div>
        </div>
    `;
    
    // Highlight the N largest elements with animation
    const elements = arrayContainer.querySelectorAll('.array-element');
    nLargest.forEach((item, i) => {
        setTimeout(() => {
            elements[item.index].querySelector('.element-value').classList.add('stat-n-largest');
        }, i * 300);
    });
    
    resetBtn.style.display = 'block';
    resetBtn.addEventListener('click', resetAfterStatisticalOperation);
    
    // Auto-reset after 8 seconds
    setTimeout(() => {
        resetAfterStatisticalOperation();
    }, 8000);
}

// NEW: Reset after Statistical Operation
function resetAfterStatisticalOperation() {
    // Reset to original array
    myArray = [...originalArrayForStatisticalOps];
    originalArrayForStatisticalOps = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isStatisticalAnalysisRunning = false;
    currentStatOperation = null; // Using renamed variable
    nValueForStatisticalAnalysis = 0;
    
    logOperation('Statistical analysis completed - returned to original array', 'info');
    showNotification('Returned to original array after statistical analysis', 'success');
}
// NEW: Valid Parentheses Handler
function handleValidParentheses() {
    const inputString = parenthesesInput.value.trim();
    
    if (inputString === '') {
        showNotification('Please enter a string to validate', 'warning');
        parenthesesInput.focus();
        return;
    }
    
    // Check if string contains only parentheses
    const parenthesesRegex = /^[{}]*$/;
    if (!parenthesesRegex.test(inputString)) {
        showNotification('Please enter only curly braces {} - no numbers, alphabets, or other characters allowed', 'danger');
        parenthesesInput.focus();
        return;
    }
    
    if (isParenthesesCheckActive) {
        showNotification('Parentheses validation is already in progress', 'warning');
        return;
    }
    
    isParenthesesCheckActive = true;
    
    // Store original array state
    originalArrayState = [...myArray];
    
    // Show parentheses validation visualization
    showParenthesesValidation(inputString);
}

// NEW: Show Parentheses Validation Visualization
function showParenthesesValidation(inputString) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Valid Parentheses Validation</h5>
        
        <div class="array-group">
            <div class="array-label">Input String: "${inputString}"</div>
            <div class="original-array-container" id="parenthesesString"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Validation Process</div>
            <div id="stackContainer" class="mt-3">
                <h6 class="text-center">Stack Operations</h6>
                <div class="d-flex flex-wrap justify-content-center" id="stackVisualization"></div>
            </div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Using stack to validate balanced parentheses</p>
            <p class="mb-0" id="parenthesesExplanation">Starting parentheses validation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="parenthesesStepsContainer">
            <h6 class="text-center">Validation Steps</h6>
            <div class="steps-container" id="parenthesesSteps"></div>
        </div>
        
        <div id="parenthesesResult" class="mt-3" style="display: none;"></div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterParentheses" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Render the input string as array elements
    renderParenthesesString(inputString);
    
    // Start parentheses validation animation
    performParenthesesValidation(inputString);
}

// NEW: Render Parentheses String
function renderParenthesesString(inputString) {
    const container = document.getElementById('parenthesesString');
    container.innerHTML = '';
    
    const characters = inputString.split('');
    
    characters.forEach((char, index) => {
        const element = document.createElement('div');
        element.className = 'array-element';
        element.innerHTML = `
            <div class="element-value" data-index="${index}" data-char="${char}">
                ${char}
            </div>
            <div class="element-index">${index}</div>
        `;
        container.appendChild(element);
    });
}

// NEW: Perform Parentheses Validation with Animation
function performParenthesesValidation(inputString) {
    const stringContainer = document.getElementById('parenthesesString');
    const stackContainer = document.getElementById('stackVisualization');
    const explanation = document.getElementById('parenthesesExplanation');
    const stepsContainer = document.getElementById('parenthesesSteps');
    const resultContainer = document.getElementById('parenthesesResult');
    const continueButton = document.getElementById('continueAfterParentheses');
    
    const characters = inputString.split('');
    const stack = [];
    let currentIndex = 0;
    let isValid = true;
    let autoReturnTimer = null;
    let unmatchedClosingBrackets = []; // Track unmatched closing brackets
    
    function performValidationStep() {
        if (currentIndex >= characters.length) {
            // Validation completed
            if (stack.length === 0 && unmatchedClosingBrackets.length === 0 && isValid) {
                explanation.innerHTML = `<strong>Algorithm Completed!</strong> Given string is Valid Parentheses`;
                resultContainer.innerHTML = `
                    <div class="parentheses-valid">
                        <i class="fas fa-check-circle me-2"></i>
                        YES - Given string is Valid Parentheses
                    </div>
                `;
                resultContainer.style.display = 'block';
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Algorithm completed - All parentheses are properly matched!
                    </div>
                `;
            } else {
                explanation.innerHTML = `<strong>Algorithm Completed!</strong> Given string is Invalid Parentheses`;
                resultContainer.innerHTML = `
                    <div class="parentheses-invalid">
                        <i class="fas fa-times-circle me-2"></i>
                        NO - Given string is Invalid Parentheses
                    </div>
                `;
                resultContainer.style.display = 'block';
                
                let errorMessage = '';
                if (stack.length > 0) {
                    errorMessage += `${stack.length} unmatched opening parentheses`;
                }
                if (unmatchedClosingBrackets.length > 0) {
                    if (errorMessage) errorMessage += ' and ';
                    errorMessage += `${unmatchedClosingBrackets.length} unmatched closing parentheses`;
                }
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Algorithm completed - ${errorMessage} found!
                    </div>
                `;
            }
            
            continueButton.style.display = 'block';
            
            // Set up auto-return after 10 seconds
            autoReturnTimer = setTimeout(() => {
                resetToOriginalArray();
            }, 10000);
            
            // Set up manual return button
            continueButton.onclick = function() {
                if (autoReturnTimer) {
                    clearTimeout(autoReturnTimer);
                }
                resetToOriginalArray();
            };
            
            return;
        }
        
        const currentChar = characters[currentIndex];
        const elements = stringContainer.querySelectorAll('.array-element');
        const currentElement = elements[currentIndex].querySelector('.element-value');
        
        // Highlight current character
        currentElement.classList.add('parentheses-current');
        explanation.innerHTML = `Processing character at position ${currentIndex}: "${currentChar}"`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${currentIndex + 1}:</strong> Processing character "${currentChar}" at index ${currentIndex}
            </div>
        `;
        
        setTimeout(() => {
            if (currentChar === '{') {
                // Opening bracket - push to stack
                explanation.innerHTML = `Found opening bracket "{" - pushing to stack`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Action:</strong> Opening bracket - Pushing to stack
                    </div>
                `;
                
                stack.push({
                    char: currentChar,
                    index: currentIndex
                });
                currentElement.classList.remove('parentheses-current');
                currentElement.classList.add('parentheses-unmatched');
                
                // Update stack visualization
                updateStackVisualization(stack, unmatchedClosingBrackets, stackContainer);
                
            } else if (currentChar === '}') {
                // Closing bracket - check stack
                explanation.innerHTML = `Found closing bracket "}" - checking stack`;
                
                if (stack.length > 0 && stack[stack.length - 1].char === '{') {
                    // Matching pair found
                    explanation.innerHTML = `Matching pair found - popping from stack`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Action:</strong> Closing bracket matches top of stack - Popping "{"
                        </div>
                    `;
                    
                    stack.pop();
                    currentElement.classList.remove('parentheses-current');
                    currentElement.classList.add('parentheses-matched');
                    
                    // Also highlight the corresponding opening bracket
                    for (let i = currentIndex - 1; i >= 0; i--) {
                        const element = elements[i].querySelector('.element-value');
                        if (element.classList.contains('parentheses-unmatched') && 
                            element.getAttribute('data-char') === '{') {
                            element.classList.remove('parentheses-unmatched');
                            element.classList.add('parentheses-matched');
                            break;
                        }
                    }
                    
                } else {
                    // No matching opening bracket - track as unmatched closing bracket
                    explanation.innerHTML = `No matching opening bracket found!`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Error:</strong> No matching opening bracket - Invalid parentheses!
                        </div>
                    `;
                    
                    currentElement.classList.remove('parentheses-current');
                    currentElement.classList.add('parentheses-unmatched');
                    unmatchedClosingBrackets.push({
                        char: currentChar,
                        index: currentIndex
                    });
                    isValid = false;
                }
                
                // Update stack visualization
                updateStackVisualization(stack, unmatchedClosingBrackets, stackContainer);
            }
            
            // Scroll steps container to bottom
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            currentIndex++;
            performValidationStep();
        }, 1500);
    }
    
    // Start validation process
    performValidationStep();
}

// NEW: Update Stack Visualization - Show both unmatched opening and closing brackets
function updateStackVisualization(stack, unmatchedClosingBrackets, container) {
    container.innerHTML = '';
    
    if (stack.length === 0 && unmatchedClosingBrackets.length === 0) {
        container.innerHTML = '<div class="text-muted">Stack is empty</div>';
        return;
    }
    
    // Create a wrapper for better organization
    const wrapper = document.createElement('div');
    wrapper.className = 'w-100';
    
    // Show unmatched opening brackets (stack)
    if (stack.length > 0) {
        const openingSection = document.createElement('div');
        openingSection.className = 'mb-3';
        openingSection.innerHTML = '<div class="text-info mb-2"><strong>Unmatched Opening Brackets:</strong></div>';
        
        const openingStack = document.createElement('div');
        openingStack.className = 'd-flex flex-wrap justify-content-center';
        
        // Display stack from top to bottom
        for (let i = stack.length - 1; i >= 0; i--) {
            const stackItem = document.createElement('div');
            stackItem.className = 'parentheses-stack-item';
            if (i === stack.length - 1) {
                stackItem.classList.add('current');
            }
            stackItem.innerHTML = `${stack[i].char}<small class="ms-1">[${stack[i].index}]</small>`;
            openingStack.appendChild(stackItem);
        }
        
        openingSection.appendChild(openingStack);
        wrapper.appendChild(openingSection);
    }
    
    // Show unmatched closing brackets
    if (unmatchedClosingBrackets.length > 0) {
        const closingSection = document.createElement('div');
        closingSection.className = 'mb-3';
        closingSection.innerHTML = '<div class="text-danger mb-2"><strong>Unmatched Closing Brackets:</strong></div>';
        
        const closingStack = document.createElement('div');
        closingStack.className = 'd-flex flex-wrap justify-content-center';
        
        // Display unmatched closing brackets
        for (let i = 0; i < unmatchedClosingBrackets.length; i++) {
            const closingItem = document.createElement('div');
            closingItem.className = 'parentheses-stack-item';
            closingItem.style.background = 'var(--danger-color) !important';
            closingItem.innerHTML = `${unmatchedClosingBrackets[i].char}<small class="ms-1">[${unmatchedClosingBrackets[i].index}]</small>`;
            closingStack.appendChild(closingItem);
        }
        
        closingSection.appendChild(closingStack);
        wrapper.appendChild(closingSection);
    }
    
    container.appendChild(wrapper);
}

// NEW: Reset to Original Array Function
function resetToOriginalArray() {
    // Reset to original array
    myArray = [...originalArrayState];
    originalArrayState = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isParenthesesCheckActive = false;
    
    // Clear input
    parenthesesInput.value = '';
    
    logOperation('Parentheses validation completed - returned to original array', 'info');
    showNotification('Returned to original array after parentheses validation', 'success');
}

// NEW: Maximum Subarray Sum Handler (Kadane's Algorithm)
function handleMaxSubarraySum() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Maximum subarray algorithm requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForKadane = [...myArray];
    
    // Show Kadane's algorithm visualization
    showMaxSubarraySumVisualization();
}

// NEW: Maximum Product Subarray Handler
function handleMaxProductSubarray() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Maximum product subarray algorithm requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForKadane = [...myArray];
    
    // Show maximum product subarray visualization
    showMaxProductSubarrayVisualization();
}

// NEW: Show Maximum Subarray Sum Visualization
function showMaxSubarraySumVisualization() {
    isKadaneAlgorithmRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Maximum Subarray Sum - Kadane's Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalKadaneArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Kadane's Algorithm Process</div>
            <div class="transformed-array-container" id="transformedKadaneArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Kadane's Algorithm:</strong> Finding the contiguous subarray with maximum sum</p>
            <p class="mb-0" id="kadaneExplanation">Initializing Kadane's algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="kadaneStepsContainer">
            <h6 class="text-center">Kadane's Algorithm Steps</h6>
            <div class="steps-container" id="kadaneSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Maximum Subarray Sum</div>
            <div class="stats-value" id="maxSubarraySumValue">0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Subarray Indices</div>
            <div class="stats-value" id="maxSubarrayIndices">-</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Subarray Elements</div>
            <div class="stats-value" id="maxSubarrayElements">-</div>
        </div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForKadane, 'originalKadaneArray');
    renderArrayInContainer([...originalArrayForKadane], 'transformedKadaneArray');
    
    performKadaneAlgorithmAnimation();
}

// NEW: Show Maximum Product Subarray Visualization
function showMaxProductSubarrayVisualization() {
    isKadaneAlgorithmRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Maximum Product Subarray</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalProductArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Maximum Product Subarray Process</div>
            <div class="transformed-array-container" id="transformedProductArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Maximum Product Subarray:</strong> Finding the contiguous subarray with maximum product</p>
            <p class="mb-0" id="productExplanation">Initializing maximum product algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="productStepsContainer">
            <h6 class="text-center">Maximum Product Algorithm Steps</h6>
            <div class="steps-container" id="productSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Maximum Product</div>
            <div class="stats-value" id="maxProductValue">1</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Subarray Indices</div>
            <div class="stats-value" id="maxProductIndices">-</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Subarray Elements</div>
            <div class="stats-value" id="maxProductElements">-</div>
        </div>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForKadane, 'originalProductArray');
    renderArrayInContainer([...originalArrayForKadane], 'transformedProductArray');
    
    performMaxProductSubarrayAnimation();
}

// NEW: Perform Kadane's Algorithm Animation
function performKadaneAlgorithmAnimation() {
    const originalContainer = document.getElementById('originalKadaneArray');
    const transformedContainer = document.getElementById('transformedKadaneArray');
    const explanation = document.getElementById('kadaneExplanation');
    const stepsContainer = document.getElementById('kadaneSteps');
    const maxSubarraySumValue = document.getElementById('maxSubarraySumValue');
    const maxSubarrayIndices = document.getElementById('maxSubarrayIndices');
    const maxSubarrayElements = document.getElementById('maxSubarrayElements');
    
    const arr = originalArrayForKadane.map(val => parseFloat(val));
    let maxEndingHere = arr[0];
    let maxSoFar = arr[0];
    let start = 0;
    let end = 0;
    let tempStart = 0;
    let step = 0;
    
    // Highlight first element
    const transformedElements = transformedContainer.querySelectorAll('.array-element');
    transformedElements[0].querySelector('.element-value').classList.add('kadane-current');
    
    explanation.innerHTML = `Step ${step + 1}: Initialize with first element = ${arr[0]}`;
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Step 1:</strong> Initialize maxEndingHere = ${arr[0]}, maxSoFar = ${arr[0]}
        </div>
    `;
    
    maxSubarraySumValue.textContent = maxSoFar;
    maxSubarrayIndices.textContent = `0 to 0`;
    maxSubarrayElements.textContent = `[${arr[0]}]`;
    
    step++;
    
    function performKadaneStep(i) {
        if (i >= arr.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Kadane's Algorithm Completed!</strong> Maximum subarray sum found.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Maximum subarray sum = ${maxSoFar} from indices ${start} to ${end}
                </div>
            `;
            
            // Highlight the maximum subarray
            for (let j = start; j <= end; j++) {
                setTimeout(() => {
                    transformedElements[j].querySelector('.element-value').classList.add('kadane-max-subarray');
                }, (j - start) * 200);
            }
            
            maxSubarraySumValue.textContent = maxSoFar;
            maxSubarrayIndices.textContent = `${start} to ${end}`;
            maxSubarrayElements.textContent = `[${arr.slice(start, end + 1).join(', ')}]`;
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterKadane();
            }, 10000);
            
            return;
        }
        
        // Remove previous highlights
        if (i > 0) {
            transformedElements[i-1].querySelector('.element-value').classList.remove('kadane-current');
        }
        
        // Highlight current element
        transformedElements[i].querySelector('.element-value').classList.add('kadane-current');
        
        explanation.innerHTML = `Step ${step + 1}: Processing element [${i}] = ${arr[i]}`;
        
        // Calculate maxEndingHere
        const newMaxEndingHere = Math.max(arr[i], maxEndingHere + arr[i]);
        
        if (newMaxEndingHere === arr[i]) {
            // Start new subarray
            tempStart = i;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step + 1}:</strong> maxEndingHere = max(${arr[i]}, ${maxEndingHere} + ${arr[i]}) = ${arr[i]} (start new subarray at index ${i})
                </div>
            `;
        } else {
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step + 1}:</strong> maxEndingHere = max(${arr[i]}, ${maxEndingHere} + ${arr[i]}) = ${newMaxEndingHere} (extend subarray)
                </div>
            `;
        }
        
        maxEndingHere = newMaxEndingHere;
        
        // Update maxSoFar if needed
        if (maxEndingHere > maxSoFar) {
            maxSoFar = maxEndingHere;
            start = tempStart;
            end = i;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Update:</strong> New maximum found! maxSoFar = ${maxSoFar} (indices ${start}-${end})
                </div>
            `;
            
            // Highlight current best subarray
            const currentElements = transformedContainer.querySelectorAll('.array-element');
            currentElements.forEach(el => {
                el.querySelector('.element-value').classList.remove('kadane-included');
            });
            for (let j = start; j <= end; j++) {
                currentElements[j].querySelector('.element-value').classList.add('kadane-included');
            }
        }
        
        maxSubarraySumValue.textContent = maxSoFar;
        maxSubarrayIndices.textContent = `${start} to ${end}`;
        maxSubarrayElements.textContent = `[${arr.slice(start, end + 1).join(', ')}]`;
        
        step++;
        
        // Scroll to bottom of steps
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Continue to next element
        setTimeout(() => {
            performKadaneStep(i + 1);
        }, 2000);
    }
    
    // Start algorithm from second element
    setTimeout(() => {
        performKadaneStep(1);
    }, 2000);
}

// NEW: Perform Maximum Product Subarray Animation
function performMaxProductSubarrayAnimation() {
    const originalContainer = document.getElementById('originalProductArray');
    const transformedContainer = document.getElementById('transformedProductArray');
    const explanation = document.getElementById('productExplanation');
    const stepsContainer = document.getElementById('productSteps');
    const maxProductValue = document.getElementById('maxProductValue');
    const maxProductIndices = document.getElementById('maxProductIndices');
    const maxProductElements = document.getElementById('maxProductElements');
    
    const arr = originalArrayForKadane.map(val => parseFloat(val));
    let maxProduct = arr[0];
    let minProduct = arr[0];
    let result = arr[0];
    let start = 0;
    let end = 0;
    let tempStart = 0;
    let step = 0;
    
    // Highlight first element
    const transformedElements = transformedContainer.querySelectorAll('.array-element');
    transformedElements[0].querySelector('.element-value').classList.add('kadane-current');
    
    explanation.innerHTML = `Step ${step + 1}: Initialize with first element = ${arr[0]}`;
    stepsContainer.innerHTML += `
        <div class="algorithm-step active">
            <strong>Step 1:</strong> Initialize maxProduct = ${arr[0]}, minProduct = ${arr[0]}, result = ${arr[0]}
        </div>
    `;
    
    maxProductValue.textContent = result;
    maxProductIndices.textContent = `0 to 0`;
    maxProductElements.textContent = `[${arr[0]}]`;
    
    step++;
    
    function performProductStep(i) {
        if (i >= arr.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Maximum Product Algorithm Completed!</strong> Maximum product subarray found.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Maximum product = ${result} from indices ${start} to ${end}
                </div>
            `;
            
            // Highlight the maximum product subarray
            for (let j = start; j <= end; j++) {
                setTimeout(() => {
                    transformedElements[j].querySelector('.element-value').classList.add('kadane-max-subarray');
                }, (j - start) * 200);
            }
            
            maxProductValue.textContent = result;
            maxProductIndices.textContent = `${start} to ${end}`;
            maxProductElements.textContent = `[${arr.slice(start, end + 1).join(', ')}]`;
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterKadane();
            }, 10000);
            
            return;
        }
        
        // Remove previous highlights
        if (i > 0) {
            transformedElements[i-1].querySelector('.element-value').classList.remove('kadane-current');
        }
        
        // Highlight current element
        transformedElements[i].querySelector('.element-value').classList.add('kadane-current');
        
        explanation.innerHTML = `Step ${step + 1}: Processing element [${i}] = ${arr[i]}`;
        
        // Store previous values
        const tempMax = maxProduct;
        const tempMin = minProduct;
        
        // Calculate new max and min products
        maxProduct = Math.max(arr[i], tempMax * arr[i], tempMin * arr[i]);
        minProduct = Math.min(arr[i], tempMax * arr[i], tempMin * arr[i]);
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step + 1}:</strong> 
                maxProduct = max(${arr[i]}, ${tempMax}  ${arr[i]}, ${tempMin}  ${arr[i]}) = ${maxProduct}<br>
                minProduct = min(${arr[i]}, ${tempMax}  ${arr[i]}, ${tempMin}  ${arr[i]}) = ${minProduct}
            </div>
        `;
        
        // Update result if needed
        if (maxProduct > result) {
            result = maxProduct;
            // For simplicity, we'll show the current subarray
            // In a real implementation, you'd track the actual subarray indices
            end = i;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Update:</strong> New maximum product found! result = ${result}
                </div>
            `;
            
            // Highlight current subarray (simplified - shows up to current index)
            const currentElements = transformedContainer.querySelectorAll('.array-element');
            currentElements.forEach(el => {
                el.querySelector('.element-value').classList.remove('kadane-included');
            });
            for (let j = 0; j <= i; j++) {
                currentElements[j].querySelector('.element-value').classList.add('kadane-included');
            }
        }
        
        maxProductValue.textContent = result;
        maxProductIndices.textContent = `0 to ${end}`; // Simplified indices
        maxProductElements.textContent = `[${arr.slice(0, end + 1).join(', ')}]`;
        
        step++;
        
        // Scroll to bottom of steps
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        // Continue to next element
        setTimeout(() => {
            performProductStep(i + 1);
        }, 2500);
    }
    
    // Start algorithm from second element
    setTimeout(() => {
        performProductStep(1);
    }, 2000);
}

// NEW: Return to Original after Kadane/Product Operations
function returnToOriginalAfterKadane() {
    // Reset to original array
    myArray = [...originalArrayForKadane];
    originalArrayForKadane = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isKadaneAlgorithmRunning = false;
    
    logOperation('Maximum subarray operation completed - returned to original array', 'info');
    showNotification('Returned to original array after maximum subarray operation', 'success');
}
// NEW: Check Palindrome Handler
function handleCheckPalindrome() {
    if (isPalindromeOperationRunning) {
        showNotification('A palindrome check is already in progress', 'warning');
        return;
    }

    // Create modal for string input
    const inputString = prompt('Enter a string to check if it\'s a palindrome:');
    
    if (!inputString) {
        showNotification('No string entered', 'info');
        return;
    }

    isPalindromeOperationRunning = true;
    performPalindromeCheck(inputString);
}

// NEW: Perform Palindrome Check with Animation
function performPalindromeCheck(inputString) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'string-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Check Valid Palindrome</h5>
        
        <div class="string-input-group">
            <div class="array-label">Original String</div>
            <div class="string-display" id="originalString">${inputString}</div>
        </div>

        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>

        <div class="string-input-group">
            <div class="array-label">Processing Steps</div>
            <div class="character-container" id="characterContainer"></div>
        </div>

        <div class="operation-explanation">
            <p class="mb-2"><strong>Palindrome Check:</strong> A string that reads the same forward and backward</p>
            <p class="mb-0" id="palindromeExplanation">Starting palindrome check...</p>
        </div>

        <div class="algorithm-steps mt-3" id="palindromeStepsContainer">
            <h6 class="text-center">Palindrome Check Steps</h6>
            <div class="steps-container" id="palindromeSteps"></div>
        </div>

        <div class="stats-card mt-3" id="palindromeResult" style="display: none;">
            <div>Result</div>
            <div class="stats-value" id="palindromeResultValue">-</div>
        </div>

        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPalindrome" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Array Operations
        </button>
    `;

    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);

    executePalindromeAlgorithm(inputString);
}

// NEW: Execute Palindrome Algorithm
function executePalindromeAlgorithm(inputString) {
    const characterContainer = document.getElementById('characterContainer');
    const explanation = document.getElementById('palindromeExplanation');
    const stepsContainer = document.getElementById('palindromeSteps');
    const resultDiv = document.getElementById('palindromeResult');
    const resultValue = document.getElementById('palindromeResultValue');
    const continueButton = document.getElementById('continueAfterPalindrome');

    // Clean the string: convert to lowercase and remove non-alphanumeric characters
    const cleanString = inputString.toLowerCase().replace(/[^a-z0-9]/g, '');
    const chars = cleanString.split('');
    const n = chars.length;
    
    let left = 0;
    let right = n - 1;
    let isPalindrome = true;
    let step = 0;

    // Display characters
    chars.forEach((char, index) => {
        const charBox = document.createElement('div');
        charBox.className = 'character-box';
        charBox.textContent = char;
        charBox.id = `char-${index}`;
        characterContainer.appendChild(charBox);
    });

    function executePalindromeStep() {
        if (left >= right) {
            // Algorithm completed
            if (isPalindrome) {
                explanation.innerHTML = `<strong class="text-success">Palindrome Check Complete!</strong> The string is a valid palindrome.`;
                resultValue.innerHTML = '<span class="text-success">Valid Palindrome </span>';
                resultValue.classList.add('palindrome-valid');
            } else {
                explanation.innerHTML = `<strong class="text-danger">Palindrome Check Complete!</strong> The string is not a palindrome.`;
                resultValue.innerHTML = '<span class="text-danger">Not a Palindrome </span>';
                resultValue.classList.add('palindrome-invalid');
            }

            resultDiv.style.display = 'block';
            continueButton.style.display = 'block';

            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterPalindrome();
            }, 10000);

            continueButton.addEventListener('click', returnToOriginalAfterPalindrome);
            return;
        }

        step++;
        explanation.innerHTML = `Step ${step}: Comparing characters at positions ${left} and ${right}`;

        // Highlight current characters being compared
        const leftChar = document.getElementById(`char-${left}`);
        const rightChar = document.getElementById(`char-${right}`);

        leftChar.classList.add('highlight');
        rightChar.classList.add('highlight');

        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Compare [${left}]='${chars[left]}' and [${right}]='${chars[right]}'
            </div>
        `;

        setTimeout(() => {
            if (chars[left] !== chars[right]) {
                isPalindrome = false;
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Mismatch Found:</strong> '${chars[left]}'  '${chars[right]}' - Not a palindrome
                    </div>
                `;
                
                leftChar.classList.add('palindrome-invalid');
                rightChar.classList.add('palindrome-invalid');
            } else {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Match:</strong> '${chars[left]}' = '${chars[right]}' - Continue checking
                    </div>
                `;
                
                leftChar.classList.add('palindrome-valid');
                rightChar.classList.add('palindrome-valid');
            }

            // Move pointers
            left++;
            right--;

            // Remove highlight for next step
            setTimeout(() => {
                leftChar.classList.remove('highlight');
                rightChar.classList.remove('highlight');
                executePalindromeStep();
            }, 1000);
        }, 1500);
    }

    // Start algorithm
    if (n === 0) {
        explanation.innerHTML = `<strong class="text-warning">Empty string after cleaning - considered a palindrome</strong>`;
        resultValue.innerHTML = '<span class="text-success">Valid Palindrome </span>';
        resultValue.classList.add('palindrome-valid');
        resultDiv.style.display = 'block';
        continueButton.style.display = 'block';
        continueButton.addEventListener('click', returnToOriginalAfterPalindrome);
    } else {
        executePalindromeStep();
    }
}

// NEW: Return to Original after Palindrome Check
function returnToOriginalAfterPalindrome() {
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    isPalindromeOperationRunning = false;
    
    logOperation('Palindrome check completed - returned to array operations', 'info');
    showNotification('Returned to array operations after palindrome check', 'success');
}

// NEW: Find Anagrams Handler
function handleFindAnagrams() {
    if (isAnagramOperationRunning) {
        showNotification('An anagram check is already in progress', 'warning');
        return;
    }

    const string1 = prompt('Enter first string:');
    if (!string1) {
        showNotification('No first string entered', 'info');
        return;
    }

    const string2 = prompt('Enter second string:');
    if (!string2) {
        showNotification('No second string entered', 'info');
        return;
    }

    isAnagramOperationRunning = true;
    performAnagramCheck(string1, string2);
}

// NEW: Perform Anagram Check with Animation
function performAnagramCheck(string1, string2) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'string-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find All Anagrams</h5>
        
        <div class="string-input-group">
            <div class="array-label">First String</div>
            <div class="string-display" id="firstString">${string1}</div>
        </div>

        <div class="string-input-group">
            <div class="array-label">Second String</div>
            <div class="string-display" id="secondString">${string2}</div>
        </div>

        <div class="operation-arrow">
            <i class="fas fa-exchange-alt"></i>
        </div>

        <div class="string-input-group">
            <div class="array-label">Character Frequency Analysis</div>
            <div class="character-container" id="frequencyContainer"></div>
        </div>

        <div class="operation-explanation">
            <p class="mb-2"><strong>Anagram Check:</strong> Two strings that contain the same characters in different order</p>
            <p class="mb-0" id="anagramExplanation">Starting anagram check...</p>
        </div>

        <div class="algorithm-steps mt-3" id="anagramStepsContainer">
            <h6 class="text-center">Anagram Check Steps</h6>
            <div class="steps-container" id="anagramSteps"></div>
        </div>

        <div class="stats-card mt-3" id="anagramResult" style="display: none;">
            <div>Result</div>
            <div class="stats-value" id="anagramResultValue">-</div>
        </div>

        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterAnagram" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Array Operations
        </button>
    `;

    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);

    executeAnagramAlgorithm(string1, string2);
}

// NEW: Execute Anagram Algorithm
function executeAnagramAlgorithm(string1, string2) {
    const frequencyContainer = document.getElementById('frequencyContainer');
    const explanation = document.getElementById('anagramExplanation');
    const stepsContainer = document.getElementById('anagramSteps');
    const resultDiv = document.getElementById('anagramResult');
    const resultValue = document.getElementById('anagramResultValue');
    const continueButton = document.getElementById('continueAfterAnagram');

    // Clean strings: convert to lowercase and sort characters
    const cleanStr1 = string1.toLowerCase().replace(/[^a-z]/g, '');
    const cleanStr2 = string2.toLowerCase().replace(/[^a-z]/g, '');
    
    const sortedStr1 = cleanStr1.split('').sort().join('');
    const sortedStr2 = cleanStr2.split('').sort().join('');
    
    const isAnagram = sortedStr1 === sortedStr2;
    let step = 0;

    // Display unique characters from both strings
    const allChars = [...new Set([...cleanStr1, ...cleanStr2])].sort();
    
    allChars.forEach(char => {
        const charBox = document.createElement('div');
        charBox.className = 'character-box';
        charBox.textContent = char;
        charBox.id = `char-${char}`;
        frequencyContainer.appendChild(charBox);
    });

    function executeAnagramStep() {
        if (step >= allChars.length) {
            // Algorithm completed
            if (isAnagram) {
                explanation.innerHTML = `<strong class="text-success">Anagram Check Complete!</strong> The strings are anagrams.`;
                resultValue.innerHTML = '<span class="text-success">Anagrams </span>';
                resultValue.classList.add('anagram-valid');
            } else {
                explanation.innerHTML = `<strong class="text-danger">Anagram Check Complete!</strong> The strings are not anagrams.`;
                resultValue.innerHTML = '<span class="text-danger">Not Anagrams </span>';
                resultValue.classList.add('anagram-invalid');
            }

            resultDiv.style.display = 'block';
            continueButton.style.display = 'block';

            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterAnagram();
            }, 10000);

            continueButton.addEventListener('click', returnToOriginalAfterAnagram);
            return;
        }

        const char = allChars[step];
        step++;
        
        const count1 = (cleanStr1.match(new RegExp(char, 'g')) || []).length;
        const count2 = (cleanStr2.match(new RegExp(char, 'g')) || []).length;
        
        explanation.innerHTML = `Step ${step}: Checking frequency of character '${char}'`;

        const charElement = document.getElementById(`char-${char}`);
        charElement.classList.add('highlight');

        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Character '${char}' - String1: ${count1} occurrence(s), String2: ${count2} occurrence(s)
            </div>
        `;

        setTimeout(() => {
            if (count1 !== count2) {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Frequency Mismatch:</strong> '${char}' appears ${count1} time(s) in first string but ${count2} time(s) in second string
                    </div>
                `;
                charElement.classList.add('anagram-invalid');
            } else {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Frequency Match:</strong> '${char}' appears equally in both strings (${count1} time(s))
                    </div>
                `;
                charElement.classList.add('anagram-valid');
            }

            // Remove highlight for next step
            setTimeout(() => {
                charElement.classList.remove('highlight');
                executeAnagramStep();
            }, 1000);
        }, 1500);
    }

    // Start algorithm
    if (cleanStr1.length !== cleanStr2.length) {
        explanation.innerHTML = `<strong class="text-warning">Different lengths - cannot be anagrams</strong>`;
        resultValue.innerHTML = '<span class="text-danger">Not Anagrams </span>';
        resultValue.classList.add('anagram-invalid');
        resultDiv.style.display = 'block';
        continueButton.style.display = 'block';
        continueButton.addEventListener('click', returnToOriginalAfterAnagram);
    } else {
        executeAnagramStep();
    }
}

// NEW: Return to Original after Anagram Check
function returnToOriginalAfterAnagram() {
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    isAnagramOperationRunning = false;
    
    logOperation('Anagram check completed - returned to array operations', 'info');
    showNotification('Returned to array operations after anagram check', 'success');
}
// NEW: Range Sum Query Handler
function handleRangeSumQuery() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isRangeSumRunning) {
        showNotification('A range sum operation is already in progress', 'warning');
        return;
    }
    
    const start = parseInt(rangeSumStart.value);
    const end = parseInt(rangeSumEnd.value);
    const n = myArray.length;
    
    // Validation
    if (isNaN(start) || isNaN(end)) {
        showNotification('Please enter valid start and end indices', 'danger');
        rangeSumStart.focus();
        return;
    }
    
    if (start < 0 || start >= n || end < 0 || end >= n) {
        showNotification(`Indices should be between 0 and ${n-1}`, 'danger');
        rangeSumStart.focus();
        return;
    }
    
    if (end < start) {
        showNotification('End index should be greater than or equal to start index', 'danger');
        rangeSumStart.focus();
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = start; i <= end; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Range sum query requires all elements in the range to be numbers', 'danger');
        return;
    }
    
    isRangeSumRunning = true;
    
    // Store original array
    originalArrayForRangeSum = [...myArray];
    
    // Perform range sum visualization
    performRangeSumVisualization(start, end);
}
// NEW: Perform Range Sum Visualization
function performRangeSumVisualization(start, end) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Range Sum Query (Indices ${start} to ${end})</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalRangeSumArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Range Sum Query:</strong> Calculating sum of elements from index ${start} to ${end}</p>
            <p class="mb-0" id="rangeSumExplanation">Starting range sum calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="rangeSumStepsContainer">
            <h6 class="text-center">Range Sum Calculation Steps</h6>
            <div class="steps-container" id="rangeSumSteps"></div>
        </div>
        
        <div class="range-sum-results mt-3" id="rangeSumResults" style="display: none;">
            <h6 class="text-center">Range Sum Result</h6>
            <div class="stats-card">
                <div>Sum of elements from index ${start} to ${end}</div>
                <div class="stats-value" id="rangeSumValue">0</div>
            </div>
            <div class="stats-card mt-2">
                <div>Elements included</div>
                <div class="stats-value" id="rangeSumElements">-</div>
            </div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterRangeSum" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForRangeSum, 'originalRangeSumArray');
    
    performRangeSumAnimation(start, end);
}
// NEW: Perform Range Sum Animation
function performRangeSumAnimation(start, end) {
    const arrayContainer = document.getElementById('originalRangeSumArray');
    const explanation = document.getElementById('rangeSumExplanation');
    const stepsContainer = document.getElementById('rangeSumSteps');
    const rangeSumResults = document.getElementById('rangeSumResults');
    const rangeSumValue = document.getElementById('rangeSumValue');
    const rangeSumElements = document.getElementById('rangeSumElements');
    const continueButton = document.getElementById('continueAfterRangeSum');
    
    const arr = originalArrayForRangeSum;
    let currentSum = 0;
    let currentIndex = start;
    let step = 0;
    const includedElements = [];
    
    function performRangeSumStep() {
        if (currentIndex > end) {
            // Calculation completed
            explanation.innerHTML = `<strong>Range Sum Calculation Completed!</strong>`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Total sum = ${currentSum}
                </div>
            `;
            
            // Show results
            rangeSumValue.textContent = currentSum;
            rangeSumElements.textContent = `[${includedElements.join(' + ')}]`;
            rangeSumResults.style.display = 'block';
            
            // Highlight all range elements
            const elements = arrayContainer.querySelectorAll('.array-element');
            for (let i = start; i <= end; i++) {
                setTimeout(() => {
                    elements[i].querySelector('.element-value').classList.add('range-sum-highlight');
                }, (i - start) * 200);
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterRangeSum();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterRangeSum);
            
            return;
        }
        
        step++;
        const currentValue = parseFloat(arr[currentIndex]);
        
        explanation.innerHTML = `Step ${step}: Adding element at index ${currentIndex} = ${currentValue}`;
        
        // Highlight current element
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElement = elements[currentIndex].querySelector('.element-value');
        currentElement.classList.add('range-sum-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> Current sum = ${currentSum} + [${currentIndex}]=${currentValue} = ${currentSum + currentValue}
            </div>
        `;
        
        // Scroll steps container to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Add to sum
            currentSum += currentValue;
            includedElements.push(currentValue);
            
            // Update current element highlight
            currentElement.classList.remove('range-sum-current');
            currentElement.classList.add('range-sum-highlight');
            
            // Show intermediate sum
            rangeSumValue.textContent = currentSum;
            rangeSumElements.textContent = `[${includedElements.join(' + ')}]`;
            rangeSumResults.style.display = 'block';
            
            // Move to next index
            currentIndex++;
            performRangeSumStep();
        }, 1500);
    }
    
    // Start calculation
    performRangeSumStep();
}
// NEW: Return to Original after Range Sum
function returnToOriginalAfterRangeSum() {
    // Reset to original array
    myArray = [...originalArrayForRangeSum];
    originalArrayForRangeSum = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isRangeSumRunning = false;
    
    // Clear inputs
    rangeSumStart.value = '';
    rangeSumEnd.value = '';
    
    logOperation('Range sum query completed - returned to original array', 'info');
    showNotification('Returned to original array after range sum query', 'success');
}
// NEW: Daily Temperatures Handler
function handleDailyTemperatures() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isDailyTemperaturesRunning) {
        showNotification('Daily temperatures algorithm is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Daily temperatures algorithm requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForDailyTemperatures = [...myArray];
    
    // Show daily temperatures visualization
    showDailyTemperaturesVisualization();
}
// NEW: Show Daily Temperatures Visualization
function showDailyTemperaturesVisualization() {
    isDailyTemperaturesRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Daily Temperatures Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">Temperatures Array</div>
            <div class="original-array-container" id="originalDailyTempArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Result (Days until Warmer)</div>
            <div class="transformed-array-container" id="resultDailyTempArray"></div>
        </div>
        
        <div class="daily-temp-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> For each day, find how many days until a warmer temperature</p>
            <p class="mb-0" id="dailyTempExplanation">Initializing daily temperatures algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="dailyTempStepsContainer">
            <h6 class="text-center">Algorithm Steps (Monotonic Stack)</h6>
            <div class="steps-container" id="dailyTempSteps"></div>
        </div>
        
        <div class="daily-temp-result mt-3" id="dailyTempResult" style="display: none;">
            <h6 class="text-center">Final Result</h6>
            <div class="row text-center" id="finalResultDisplay"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterDailyTemp" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForDailyTemperatures, 'originalDailyTempArray');
    
    // Initialize result array with zeros
    const resultArray = Array(originalArrayForDailyTemperatures.length).fill(0);
    renderArrayInContainer(resultArray, 'resultDailyTempArray');
    
    performDailyTemperaturesAnimation();
}
// NEW: Perform Daily Temperatures Animation
function performDailyTemperaturesAnimation() {
    const originalContainer = document.getElementById('originalDailyTempArray');
    const resultContainer = document.getElementById('resultDailyTempArray');
    const explanation = document.getElementById('dailyTempExplanation');
    const stepsContainer = document.getElementById('dailyTempSteps');
    const resultDisplay = document.getElementById('finalResultDisplay');
    const resultSection = document.getElementById('dailyTempResult');
    const continueButton = document.getElementById('continueAfterDailyTemp');
    
    const temperatures = originalArrayForDailyTemperatures.map(val => parseFloat(val));
    const n = temperatures.length;
    const answer = Array(n).fill(0);
    const stack = [];
    let currentDay = 0;
    let stepCount = 0;
    
    function performDailyTempStep() {
        if (currentDay >= n) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> All days processed.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Daily temperatures algorithm completed. Final result computed.
                </div>
            `;
            
            // Show final result
            resultSection.style.display = 'block';
            resultDisplay.innerHTML = `
                <div class="col-md-6">
                    <div class="stats-card">
                        <div>Input Temperatures</div>
                        <div class="stats-value">[${temperatures.join(', ')}]</div>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="stats-card">
                        <div>Output (Days until Warmer)</div>
                        <div class="stats-value">[${answer.join(', ')}]</div>
                    </div>
                </div>
            `;
            
            // Highlight all elements in result
            const resultElements = resultContainer.querySelectorAll('.array-element');
            resultElements.forEach((el, index) => {
                setTimeout(() => {
                    el.querySelector('.element-value').classList.add('daily-temp-warmer');
                }, index * 200);
            });
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterDailyTemperatures();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterDailyTemperatures);
            
            return;
        }
        
        stepCount++;
        const currentTemp = temperatures[currentDay];
        
        // Highlight current day
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentDay].querySelector('.element-value');
        currentElement.classList.add('daily-temp-current');
        
        explanation.innerHTML = `Day ${currentDay}: Processing temperature ${currentTemp}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${stepCount}:</strong> Processing day ${currentDay} (temp: ${currentTemp})
            </div>
        `;
        
        setTimeout(() => {
            // Check stack for warmer temperatures
            let foundWarmer = false;
            
            function processStack() {
                if (stack.length === 0) {
                    // No more elements in stack to compare
                    stack.push(currentDay);
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${stepCount}.${stack.length}:</strong> No warmer days found in stack. Pushing day ${currentDay} to stack.
                        </div>
                    `;
                    
                    // Highlight stack elements
                    highlightStackElements();
                    moveToNextDay();
                    return;
                }
                
                const prevIndex = stack[stack.length - 1];
                const prevTemp = temperatures[prevIndex];
                
                if (currentTemp > prevTemp) {
                    // Found a warmer day
                    foundWarmer = true;
                    const poppedIndex = stack.pop();
                    answer[poppedIndex] = currentDay - poppedIndex;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${stepCount}.${stack.length + 1}:</strong> Day ${currentDay} (${currentTemp}) > Day ${poppedIndex} (${prevTemp}). 
                            Answer[${poppedIndex}] = ${currentDay} - ${poppedIndex} = ${answer[poppedIndex]}
                        </div>
                    `;
                    
                    // Update result display
                    updateResultDisplay(poppedIndex, answer[poppedIndex]);
                    
                    // Highlight the warmer day connection
                    const prevElement = originalElements[poppedIndex].querySelector('.element-value');
                    const resultElement = resultContainer.querySelectorAll('.array-element')[poppedIndex].querySelector('.element-value');
                    
                    prevElement.classList.add('daily-temp-warmer');
                    resultElement.classList.add('daily-temp-warmer');
                    resultElement.textContent = answer[poppedIndex];
                    
                    setTimeout(() => {
                        prevElement.classList.remove('daily-temp-warmer');
                        prevElement.classList.add('daily-temp-processed');
                        
                        // Continue processing stack
                        processStack();
                    }, 2000);
                    
                } else {
                    // Current temp is not warmer than stack top
                    stack.push(currentDay);
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${stepCount}.${stack.length}:</strong> Day ${currentDay} (${currentTemp})  Day ${prevIndex} (${prevTemp}). Pushing to stack.
                        </div>
                    `;
                    
                    highlightStackElements();
                    moveToNextDay();
                }
            }
            
            function highlightStackElements() {
                // Highlight all elements in stack
                originalElements.forEach((el, index) => {
                    const valueDiv = el.querySelector('.element-value');
                    if (stack.includes(index)) {
                        valueDiv.classList.add('daily-temp-stack');
                    } else {
                        valueDiv.classList.remove('daily-temp-stack');
                    }
                });
            }
            
            function updateResultDisplay(index, value) {
                const resultElements = resultContainer.querySelectorAll('.array-element');
                resultElements[index].querySelector('.element-value').textContent = value;
            }
            
            function moveToNextDay() {
                currentElement.classList.remove('daily-temp-current');
                currentElement.classList.add('daily-temp-processed');
                
                currentDay++;
                setTimeout(performDailyTempStep, 1500);
            }
            
            // Start processing the stack
            processStack();
            
        }, 1500);
    }
    
    // Start the algorithm
    performDailyTempStep();
}
// NEW: Return to Original after Daily Temperatures
function returnToOriginalAfterDailyTemperatures() {
    // Reset to original array
    myArray = [...originalArrayForDailyTemperatures];
    originalArrayForDailyTemperatures = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isDailyTemperaturesRunning = false;
    
    logOperation('Daily temperatures algorithm completed - returned to original array', 'info');
    showNotification('Returned to original array after daily temperatures algorithm', 'success');
}
// NEW: Find First and Last Position Handler
function handleFindFirstLast() {
    const target = firstLastTarget.value.trim();
    
    if (target === '') {
        showNotification('Please enter a target element to search for', 'warning');
        firstLastTarget.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isFirstLastSearchRunning) {
        showNotification('First/last position search is already in progress', 'warning');
        return;
    }
    
    isFirstLastSearchRunning = true;
    
    // Store original array
    originalArrayForFirstLast = [...myArray];
    
    // Check if array is sorted, if not, sort it
    if (!isArraySorted(myArray)) {
        showNotification('Array is not sorted. Auto-sorting array for binary search...', 'info');
        
        // Sort the array numerically if possible
        const isNumeric = !myArray.some(item => isNaN(parseFloat(item)));
        if (isNumeric) {
            myArray.sort((a, b) => parseFloat(a) - parseFloat(b));
        } else {
            myArray.sort();
        }
        
        renderArray();
        updateStats();
        
        logOperation('Array auto-sorted for first/last position search', 'warning');
    }
    
    // Perform first/last position search
    performFirstLastSearch(target);
}

// NEW: Check if array is sorted
function isArraySorted(arr) {
    const isNumeric = !arr.some(item => isNaN(parseFloat(item)));
    
    for (let i = 1; i < arr.length; i++) {
        if (isNumeric) {
            if (parseFloat(arr[i]) < parseFloat(arr[i - 1])) {
                return false;
            }
        } else {
            if (arr[i] < arr[i - 1]) {
                return false;
            }
        }
    }
    return true;
}

// NEW: Perform First and Last Position Search with Visualization
function performFirstLastSearch(target) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find First & Last Position of "${target}"</h5>
        
        <div class="array-group">
            <div class="array-label">Sorted Array</div>
            <div class="original-array-container" id="firstLastArray"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Two binary searches - one for first occurrence, one for last occurrence</p>
            <p class="mb-0" id="firstLastExplanation">Starting binary search for first occurrence...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="firstLastStepsContainer">
            <h6 class="text-center">Binary Search Steps</h6>
            <div class="steps-container" id="firstLastSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>First Occurrence</div>
            <div class="stats-value" id="firstOccurrenceValue">-</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Last Occurrence</div>
            <div class="stats-value" id="lastOccurrenceValue">-</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Total Occurrences</div>
            <div class="stats-value" id="totalOccurrencesValue">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterFirstLast" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(myArray, 'firstLastArray');
    
    executeFirstLastSearchAlgorithm(target);
}

// NEW: Execute First and Last Position Search Algorithm
function executeFirstLastSearchAlgorithm(target) {
    const arrayContainer = document.getElementById('firstLastArray');
    const explanation = document.getElementById('firstLastExplanation');
    const stepsContainer = document.getElementById('firstLastSteps');
    const firstOccurrenceValue = document.getElementById('firstOccurrenceValue');
    const lastOccurrenceValue = document.getElementById('lastOccurrenceValue');
    const totalOccurrencesValue = document.getElementById('totalOccurrencesValue');
    const continueButton = document.getElementById('continueAfterFirstLast');
    
    const arr = [...myArray];
    const targetNum = isNaN(parseFloat(target)) ? target : parseFloat(target);
    let step = 0;
    
    // Convert array elements to numbers if target is numeric
    const numericArr = arr.map(item => isNaN(parseFloat(item)) ? item : parseFloat(item));
    
    function findFirstOccurrence() {
        let left = 0;
        let right = numericArr.length - 1;
        let firstOccurrence = -1;
        
        explanation.innerHTML = `Searching for FIRST occurrence of ${target}...`;
        
        function performFirstSearchStep() {
            if (left > right) {
                // Search completed for first occurrence
                stepsContainer.innerHTML += `
                    <div class="algorithm-step ${firstOccurrence !== -1 ? 'active' : ''}">
                        <strong>First Search Complete:</strong> ${firstOccurrence !== -1 ? 
                            `Found at index ${firstOccurrence}` : 'Not found'}
                    </div>
                `;
                
                firstOccurrenceValue.textContent = firstOccurrence !== -1 ? firstOccurrence : 'Not found';
                
                // Start searching for last occurrence
                setTimeout(() => {
                    findLastOccurrence(firstOccurrence);
                }, 1500);
                return;
            }
            
            step++;
            const mid = Math.floor((left + right) / 2);
            
            // Update explanation
            explanation.innerHTML = `Step ${step}: First search - Left=${left}, Right=${right}, Mid=${mid}`;
            
            // Highlight current search range
            const elements = arrayContainer.querySelectorAll('.array-element');
            
            // Highlight left, right, and mid pointers
            if (left <= right) {
                elements[left].querySelector('.element-value').classList.add('binary-search-left');
                elements[right].querySelector('.element-value').classList.add('binary-search-right');
                elements[mid].querySelector('.element-value').classList.add('binary-search-mid');
            }
            
            const midVal = numericArr[mid];
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}:</strong> First search - Checking mid[${mid}]=${midVal} vs target=${target}
                </div>
            `;
            
            // Scroll steps container
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            setTimeout(() => {
                // Remove highlights
                if (left <= right) {
                    elements[left].querySelector('.element-value').classList.remove('binary-search-left');
                    elements[right].querySelector('.element-value').classList.remove('binary-search-right');
                    elements[mid].querySelector('.element-value').classList.remove('binary-search-mid');
                }
                
                if (midVal < targetNum) {
                    // Search right half
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step}.1:</strong> ${midVal} < ${target}  Search RIGHT (left = ${mid + 1})
                        </div>
                    `;
                    left = mid + 1;
                } else {
                    // Search left half (including when equal, to find first occurrence)
                    if (midVal === targetNum) {
                        firstOccurrence = mid;
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Step ${step}.1:</strong> ${midVal} = ${target}  Found potential first occurrence at ${mid}, continue LEFT
                            </div>
                        `;
                        
                        // Highlight the found occurrence
                        elements[mid].querySelector('.element-value').classList.add('first-occurrence');
                    } else {
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Step ${step}.1:</strong> ${midVal} > ${target}  Search LEFT (right = ${mid - 1})
                            </div>
                        `;
                    }
                    right = mid - 1;
                }
                
                performFirstSearchStep();
            }, 2000);
        }
        
        performFirstSearchStep();
    }
    
    function findLastOccurrence(firstOccurrence) {
        if (firstOccurrence === -1) {
            // Element not found at all
            explanation.innerHTML = `<strong>Element ${target} not found in array</strong>`;
            lastOccurrenceValue.textContent = 'Not found';
            totalOccurrencesValue.textContent = '0';
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Final Result:</strong> Element ${target} not found in array
                </div>
            `;
            
            continueButton.style.display = 'block';
            setTimeout(() => {
                returnToOriginalAfterFirstLast();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterFirstLast);
            return;
        }
        
        let left = 0;
        let right = numericArr.length - 1;
        let lastOccurrence = -1;
        
        explanation.innerHTML = `Searching for LAST occurrence of ${target}...`;
        
        function performLastSearchStep() {
            if (left > right) {
                // Search completed for last occurrence
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Last Search Complete:</strong> Found at index ${lastOccurrence}
                    </div>
                `;
                
                lastOccurrenceValue.textContent = lastOccurrence;
                const totalOccurrences = lastOccurrence - firstOccurrence + 1;
                totalOccurrencesValue.textContent = totalOccurrences;
                
                // Show final result
                explanation.innerHTML = `<strong>Search Complete!</strong> First occurrence: ${firstOccurrence}, Last occurrence: ${lastOccurrence}, Total: ${totalOccurrences}`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final Result:</strong> First occurrence at ${firstOccurrence}, Last occurrence at ${lastOccurrence}, Total occurrences: ${totalOccurrences}
                    </div>
                `;
                
                // Highlight all occurrences
                const elements = arrayContainer.querySelectorAll('.array-element');
                for (let i = firstOccurrence; i <= lastOccurrence; i++) {
                    setTimeout(() => {
                        elements[i].querySelector('.element-value').classList.add('all-occurrence');
                    }, (i - firstOccurrence) * 200);
                }
                
                // Highlight first and last specifically
                setTimeout(() => {
                    elements[firstOccurrence].querySelector('.element-value').classList.add('first-occurrence');
                    elements[lastOccurrence].querySelector('.element-value').classList.add('last-occurrence');
                }, (lastOccurrence - firstOccurrence + 1) * 200 + 500);
                
                continueButton.style.display = 'block';
                
                // Auto-return after 10 seconds
                setTimeout(() => {
                    returnToOriginalAfterFirstLast();
                }, 10000);
                
                continueButton.addEventListener('click', returnToOriginalAfterFirstLast);
                return;
            }
            
            step++;
            const mid = Math.floor((left + right) / 2);
            
            // Update explanation
            explanation.innerHTML = `Step ${step}: Last search - Left=${left}, Right=${right}, Mid=${mid}`;
            
            // Highlight current search range
            const elements = arrayContainer.querySelectorAll('.array-element');
            
            // Highlight left, right, and mid pointers
            if (left <= right) {
                elements[left].querySelector('.element-value').classList.add('binary-search-left');
                elements[right].querySelector('.element-value').classList.add('binary-search-right');
                elements[mid].querySelector('.element-value').classList.add('binary-search-mid');
            }
            
            const midVal = numericArr[mid];
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}:</strong> Last search - Checking mid[${mid}]=${midVal} vs target=${target}
                </div>
            `;
            
            // Scroll steps container
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            setTimeout(() => {
                // Remove highlights
                if (left <= right) {
                    elements[left].querySelector('.element-value').classList.remove('binary-search-left');
                    elements[right].querySelector('.element-value').classList.remove('binary-search-right');
                    elements[mid].querySelector('.element-value').classList.remove('binary-search-mid');
                }
                
                if (midVal > targetNum) {
                    // Search left half
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step}.1:</strong> ${midVal} > ${target}  Search LEFT (right = ${mid - 1})
                        </div>
                    `;
                    right = mid - 1;
                } else {
                    // Search right half (including when equal, to find last occurrence)
                    if (midVal === targetNum) {
                        lastOccurrence = mid;
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Step ${step}.1:</strong> ${midVal} = ${target}  Found potential last occurrence at ${mid}, continue RIGHT
                            </div>
                        `;
                        
                        // Highlight the found occurrence
                        elements[mid].querySelector('.element-value').classList.add('last-occurrence');
                    } else {
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Step ${step}.1:</strong> ${midVal} < ${target}  Search RIGHT (left = ${mid + 1})
                            </div>
                        `;
                    }
                    left = mid + 1;
                }
                
                performLastSearchStep();
            }, 2000);
        }
        
        performLastSearchStep();
    }
    
    // Start the search process
    findFirstOccurrence();
}

// NEW: Return to Original after First/Last Search
function returnToOriginalAfterFirstLast() {
    // Reset to original array
    myArray = [...originalArrayForFirstLast];
    originalArrayForFirstLast = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isFirstLastSearchRunning = false;
    
    // Clear input
    firstLastTarget.value = '';
    
    logOperation('First/last position search completed - returned to original array', 'info');
    showNotification('Returned to original array after first/last position search', 'success');
}
// NEW: Find Palindromic Substrings Handler
function handleFindPalindromicSubstrings() {
    const inputString = palindromeInput.value.trim();
    
    if (inputString === '') {
        showNotification('Please enter a string to find palindromic substrings', 'danger');
        palindromeInput.focus();
        return;
    }
    
    if (isPalindromicOperationRunning) {
        showNotification('A palindrome operation is already in progress', 'warning');
        return;
    }
    
    isPalindromicOperationRunning = true;
    originalStringBeforePalindrome = inputString;
    
    // Store original array
    originalArrayBeforePalindrome = [...myArray];
    
    // Convert string to array of characters for visualization
    myArray = inputString.split('');
    
    // Show palindrome visualization
    showPalindromicSubstringsVisualization(inputString);
}

// NEW: Find Longest Palindromic Substring Handler
function handleFindLongestPalindromicSubstring() {
    let inputString = longestPalindromeInput.value.trim();
    
    // If empty, use the value from the other input field
    if (inputString === '') {
        inputString = palindromeInput.value.trim();
    }
    
    if (inputString === '') {
        showNotification('Please enter a string to find the longest palindromic substring', 'danger');
        longestPalindromeInput.focus();
        return;
    }
    
    if (isPalindromicOperationRunning) {
        showNotification('A palindrome operation is already in progress', 'warning');
        return;
    }
    
    isPalindromicOperationRunning = true;
    originalStringBeforePalindrome = inputString;
    
    // Store original array
    originalArrayBeforePalindrome = [...myArray];
    
    // Convert string to array of characters for visualization
    myArray = inputString.split('');
    
    // Show longest palindrome visualization
    showLongestPalindromicSubstringVisualization(inputString);
}
// NEW: Show Palindromic Substrings Visualization
function showPalindromicSubstringsVisualization(inputString) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find All Palindromic Substrings</h5>
        
        <div class="array-group">
            <div class="array-label">Input String: "${inputString}"</div>
            <div class="original-array-container" id="palindromeArray"></div>
        </div>
        
        <div class="palindrome-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Expand Around Center - Check all possible centers</p>
            <p class="mb-0" id="palindromeExplanation">Initializing palindrome search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="palindromeStepsContainer">
            <h6 class="text-center">Palindrome Detection Steps</h6>
            <div class="steps-container" id="palindromeSteps"></div>
        </div>
        
        <div class="palindrome-stats mt-3">
            <div>Total Palindromic Substrings Found</div>
            <div class="stats-value" id="palindromeCount">0</div>
            <div id="palindromesList" class="mt-2"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPalindrome" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array (Auto in 10s)
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(myArray, 'palindromeArray');
    
    performPalindromicSubstringsSearch(inputString);
}

// NEW: Show Longest Palindromic Substring Visualization
function showLongestPalindromicSubstringVisualization(inputString) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find Longest Palindromic Substring</h5>
        
        <div class="array-group">
            <div class="array-label">Input String: "${inputString}"</div>
            <div class="original-array-container" id="longestPalindromeArray"></div>
        </div>
        
        <div class="palindrome-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Expand Around Center - Find maximum length palindrome</p>
            <p class="mb-0" id="longestPalindromeExplanation">Initializing longest palindrome search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="longestPalindromeStepsContainer">
            <h6 class="text-center">Longest Palindrome Detection Steps</h6>
            <div class="steps-container" id="longestPalindromeSteps"></div>
        </div>
        
        <div class="palindrome-stats mt-3">
            <div>Longest Palindromic Substring</div>
            <div class="stats-value" id="longestPalindromeResult">-</div>
            <div>Length</div>
            <div class="stats-value" id="longestPalindromeLength">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterLongestPalindrome" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array (Auto in 10s)
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(myArray, 'longestPalindromeArray');
    
    performLongestPalindromicSubstringSearch(inputString);
}
// NEW: Show Palindromic Substrings Visualization
function showPalindromicSubstringsVisualization(inputString) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find All Palindromic Substrings</h5>
        
        <div class="array-group">
            <div class="array-label">Input String: "${inputString}"</div>
            <div class="original-array-container" id="palindromeArray"></div>
        </div>
        
        <div class="palindrome-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Expand Around Center - Check all possible centers</p>
            <p class="mb-0" id="palindromeExplanation">Initializing palindrome search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="palindromeStepsContainer">
            <h6 class="text-center">Palindrome Detection Steps</h6>
            <div class="steps-container" id="palindromeSteps"></div>
        </div>
        
        <div class="palindrome-stats mt-3">
            <div>Total Palindromic Substrings Found</div>
            <div class="stats-value" id="palindromeCount">0</div>
            <div id="palindromesList" class="mt-2"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPalindrome" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array (Auto in 10s)
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(myArray, 'palindromeArray');
    
    performPalindromicSubstringsSearch(inputString);
}

// NEW: Show Longest Palindromic Substring Visualization
function showLongestPalindromicSubstringVisualization(inputString) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find Longest Palindromic Substring</h5>
        
        <div class="array-group">
            <div class="array-label">Input String: "${inputString}"</div>
            <div class="original-array-container" id="longestPalindromeArray"></div>
        </div>
        
        <div class="palindrome-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Expand Around Center - Find maximum length palindrome</p>
            <p class="mb-0" id="longestPalindromeExplanation">Initializing longest palindrome search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="longestPalindromeStepsContainer">
            <h6 class="text-center">Longest Palindrome Detection Steps</h6>
            <div class="steps-container" id="longestPalindromeSteps"></div>
        </div>
        
        <div class="palindrome-stats mt-3">
            <div>Longest Palindromic Substring</div>
            <div class="stats-value" id="longestPalindromeResult">-</div>
            <div>Length</div>
            <div class="stats-value" id="longestPalindromeLength">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterLongestPalindrome" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array (Auto in 10s)
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(myArray, 'longestPalindromeArray');
    
    performLongestPalindromicSubstringSearch(inputString);
}
// NEW: Perform Palindromic Substrings Search with Animation
function performPalindromicSubstringsSearch(inputString) {
    const arrayContainer = document.getElementById('palindromeArray');
    const explanation = document.getElementById('palindromeExplanation');
    const stepsContainer = document.getElementById('palindromeSteps');
    const palindromeCount = document.getElementById('palindromeCount');
    const palindromesList = document.getElementById('palindromesList');
    const continueButton = document.getElementById('continueAfterPalindrome');
    
    const chars = inputString.split('');
    const n = chars.length;
    let palindromes = [];
    let step = 0;
    
    function expandAroundCenter(left, right) {
        return new Promise((resolve) => {
            let currentLeft = left;
            let currentRight = right;
            let currentPalindrome = '';
            
            function expandStep() {
                if (currentLeft < 0 || currentRight >= n || chars[currentLeft] !== chars[currentRight]) {
                    resolve(palindromes);
                    return;
                }
                
                // Highlight current expansion
                const elements = arrayContainer.querySelectorAll('.array-element');
                
                // Highlight center for odd length
                if (currentLeft === currentRight) {
                    elements[currentLeft].querySelector('.element-value').classList.add('palindrome-center');
                }
                
                // Highlight expanding characters
                if (currentLeft !== currentRight) {
                    elements[currentLeft].querySelector('.element-value').classList.add('palindrome-expanding');
                    elements[currentRight].querySelector('.element-value').classList.add('palindrome-expanding');
                }
                
                currentPalindrome = chars.slice(currentLeft, currentRight + 1).join('');
                
                step++;
                explanation.innerHTML = `Step ${step}: Expanding around center - Found: "${currentPalindrome}"`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> Center [${currentLeft},${currentRight}], Found: "${currentPalindrome}"
                    </div>
                `;
                
                // Add to palindromes list if not already included (for single characters)
                if (currentPalindrome.length >= 1 && !palindromes.includes(currentPalindrome)) {
                    palindromes.push(currentPalindrome);
                    palindromeCount.textContent = palindromes.length;
                    
                    // Update palindromes list
                    palindromesList.innerHTML = `<small>Found: ${palindromes.join(', ')}</small>`;
                    
                    // Highlight found palindrome
                    setTimeout(() => {
                        for (let i = currentLeft; i <= currentRight; i++) {
                            elements[i].querySelector('.element-value').classList.add('palindrome-found');
                        }
                    }, 500);
                }
                
                setTimeout(() => {
                    // Remove highlights
                    if (currentLeft === currentRight) {
                        elements[currentLeft].querySelector('.element-value').classList.remove('palindrome-center');
                    }
                    if (currentLeft !== currentRight) {
                        elements[currentLeft].querySelector('.element-value').classList.remove('palindrome-expanding');
                        elements[currentRight].querySelector('.element-value').classList.remove('palindrome-expanding');
                    }
                    
                    // Continue expansion
                    currentLeft--;
                    currentRight++;
                    expandStep();
                }, 1500);
            }
            
            expandStep();
        });
    }
    
    async function performSearch() {
        for (let i = 0; i < n; i++) {
            // Odd length palindromes
            await expandAroundCenter(i, i);
            
            // Even length palindromes
            await expandAroundCenter(i, i + 1);
        }
        
        // Search completed
        explanation.innerHTML = `<strong>Search Completed!</strong> Found ${palindromes.length} palindromic substrings.`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Final:</strong> Total ${palindromes.length} palindromic substrings found: ${palindromes.join(', ')}
            </div>
        `;
        
        // Highlight all found palindromes briefly
        const elements = arrayContainer.querySelectorAll('.array-element');
        elements.forEach(el => {
            el.querySelector('.element-value').classList.add('palindrome-found');
        });
        
        continueButton.style.display = 'block';
        
        // Auto-return after 10 seconds
        setTimeout(() => {
            returnToOriginalAfterPalindrome();
        }, 10000);
        
        continueButton.addEventListener('click', returnToOriginalAfterPalindrome);
    }
    
    // Start search
    performSearch();
}

// NEW: Perform Longest Palindromic Substring Search with Animation
function performLongestPalindromicSubstringSearch(inputString) {
    const arrayContainer = document.getElementById('longestPalindromeArray');
    const explanation = document.getElementById('longestPalindromeExplanation');
    const stepsContainer = document.getElementById('longestPalindromeSteps');
    const longestPalindromeResult = document.getElementById('longestPalindromeResult');
    const longestPalindromeLength = document.getElementById('longestPalindromeLength');
    const continueButton = document.getElementById('continueAfterLongestPalindrome');
    
    const chars = inputString.split('');
    const n = chars.length;
    let longestPalindrome = '';
    let maxLength = 0;
    let step = 0;
    
    function expandAroundCenter(left, right, isEven = false) {
        return new Promise((resolve) => {
            let l = left;
            let r = right;
            let currentLength = 0;
            let currentPalindrome = '';
            
            function expandStep() {
                if (l < 0 || r >= n || chars[l] !== chars[r]) {
                    resolve({length: currentLength, palindrome: currentPalindrome});
                    return;
                }
                
                // Highlight current expansion
                const elements = arrayContainer.querySelectorAll('.array-element');
                
                if (l === r) {
                    elements[l].querySelector('.element-value').classList.add('palindrome-center');
                } else {
                    elements[l].querySelector('.element-value').classList.add('palindrome-expanding');
                    elements[r].querySelector('.element-value').classList.add('palindrome-expanding');
                }
                
                currentLength = r - l + 1;
                currentPalindrome = chars.slice(l, r + 1).join('');
                
                step++;
                const type = isEven ? 'Even' : 'Odd';
                explanation.innerHTML = `Step ${step}: ${type} expansion - Center [${l},${r}], Current: "${currentPalindrome}"`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step ${currentLength > maxLength ? 'active' : ''}">
                        <strong>Step ${step}:</strong> ${type} center [${l},${r}], Found: "${currentPalindrome}" (Length: ${currentLength})
                    </div>
                `;
                
                // Check if this is the new longest
                if (currentLength > maxLength) {
                    maxLength = currentLength;
                    longestPalindrome = currentPalindrome;
                    
                    longestPalindromeResult.textContent = `"${longestPalindrome}"`;
                    longestPalindromeLength.textContent = maxLength;
                    
                    // Highlight the new longest palindrome
                    setTimeout(() => {
                        // Remove previous longest highlights
                        elements.forEach(el => {
                            el.querySelector('.element-value').classList.remove('longest-palindrome');
                        });
                        
                        // Add new longest highlights
                        for (let i = l; i <= r; i++) {
                            elements[i].querySelector('.element-value').classList.add('longest-palindrome');
                        }
                    }, 500);
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>New Longest!</strong> "${longestPalindrome}" (Length: ${maxLength})
                        </div>
                    `;
                }
                
                setTimeout(() => {
                    // Remove temporary highlights
                    if (l === r) {
                        elements[l].querySelector('.element-value').classList.remove('palindrome-center');
                    } else {
                        elements[l].querySelector('.element-value').classList.remove('palindrome-expanding');
                        elements[r].querySelector('.element-value').classList.remove('palindrome-expanding');
                    }
                    
                    // Continue expansion
                    l--;
                    r++;
                    expandStep();
                }, 2000);
            }
            
            expandStep();
        });
    }
    
    async function performSearch() {
        for (let i = 0; i < n; i++) {
            // Odd length palindromes (single character center)
            const oddResult = await expandAroundCenter(i, i, false);
            
            // Even length palindromes (two character center)
            const evenResult = await expandAroundCenter(i, i + 1, true);
        }
        
        // Search completed
        explanation.innerHTML = `<strong>Search Completed!</strong> Longest palindromic substring: "${longestPalindrome}" (Length: ${maxLength})`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Final Result:</strong> Longest Palindromic Substring = "${longestPalindrome}" with length ${maxLength}
            </div>
        `;
        
        continueButton.style.display = 'block';
        
        // Auto-return after 10 seconds
        setTimeout(() => {
            returnToOriginalAfterPalindrome();
        }, 10000);
        
        continueButton.addEventListener('click', returnToOriginalAfterPalindrome);
    }
    
    // Start search
    performSearch();
}

// NEW: Return to Original after Palindrome Operations
function returnToOriginalAfterPalindrome() {
    // Reset to original array
    myArray = [...originalArrayBeforePalindrome];
    originalArrayBeforePalindrome = [];
    originalStringBeforePalindrome = "";
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isPalindromicOperationRunning = false;
    
    // Clear inputs
    palindromeInput.value = '';
    longestPalindromeInput.value = '';
    
    logOperation('Palindrome operation completed - returned to original array', 'info');
    showNotification('Returned to original array after palindrome operation', 'success');
}

// NEW: Handle Pattern Matching Selection
function handlePatternMatching(type) {
    if (isPatternMatchingRunning) {
        showNotification('A pattern matching operation is already in progress', 'warning');
        return;
    }
    
    currentPatternMatchingType = type;
    
    // Show input group
    patternMatchingGroup.style.display = 'block';
    
    // Update label based on type
    if (type === 'wildcard') {
        patternMatchingLabel.innerHTML = 'Wildcard Matching Details';
        patternPattern.placeholder = 'Enter wildcard pattern (e.g., a*b*)';
    } else {
        patternMatchingLabel.innerHTML = 'Regular Expression Matching Details';
        patternPattern.placeholder = 'Enter regex pattern (e.g., a.*b*)';
    }
    
    patternString.focus();
    
    logOperation(`Started ${type === 'wildcard' ? 'Wildcard' : 'Regular Expression'} Matching operation`, 'info');
}

// NEW: Confirm Pattern Matching Handler
function handleConfirmPatternMatching() {
    const str = patternString.value.trim();
    const pattern = patternPattern.value.trim();
    
    if (str === '') {
        showNotification('Please enter a string to match', 'danger');
        patternString.focus();
        return;
    }
    
    if (pattern === '') {
        showNotification('Please enter a pattern', 'danger');
        patternPattern.focus();
        return;
    }
    
    // Hide input group
    patternMatchingGroup.style.display = 'none';
    
    // Store original array
    originalArrayForPatternMatching = [...myArray];
    
    // Start pattern matching visualization
    if (currentPatternMatchingType === 'wildcard') {
        performWildcardMatching(str, pattern);
    } else {
        performRegexMatching(str, pattern);
    }
}

// NEW: Cancel Pattern Matching Handler
function handleCancelPatternMatching() {
    patternMatchingGroup.style.display = 'none';
    patternString.value = '';
    patternPattern.value = '';
    currentPatternMatchingType = null;
    
    logOperation('Cancelled pattern matching operation', 'info');
    showNotification('Pattern matching operation cancelled', 'info');
}

// NEW: Perform Wildcard Matching with Animation
function performWildcardMatching(str, pattern) {
    isPatternMatchingRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Wildcard Matching Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">String: "${str}"</div>
            <div class="original-array-container" id="stringDisplay"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Pattern: "${pattern}"</div>
            <div class="original-array-container" id="patternDisplay"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Dynamic Programming Table</div>
            <div class="transformed-array-container" id="dpTableDisplay"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Wildcard Matching:</strong> Check if string matches pattern with '*' and '?' wildcards</p>
            <p class="mb-0" id="wildcardExplanation">Initializing wildcard matching algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="wildcardStepsContainer">
            <h6 class="text-center">Wildcard Matching Steps</h6>
            <div class="steps-container" id="wildcardSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Matching Result</div>
            <div class="stats-value" id="wildcardResult">Processing...</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterWildcard" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display string and pattern
    renderStringAsArray(str, 'stringDisplay');
    renderPatternAsArray(pattern, 'patternDisplay');
    
    // Initialize DP table display
    initializeDPTable(str, pattern, 'dpTableDisplay');
    
    // Start wildcard matching animation
    executeWildcardMatching(str, pattern);
}

// NEW: Perform Regex Matching with Animation
function performRegexMatching(str, pattern) {
    isPatternMatchingRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Regular Expression Matching Algorithm</h5>
        
        <div class="array-group">
            <div class="array-label">String: "${str}"</div>
            <div class="original-array-container" id="stringDisplay"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Pattern: "${pattern}"</div>
            <div class="original-array-container" id="patternDisplay"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Dynamic Programming Table</div>
            <div class="transformed-array-container" id="dpTableDisplay"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Regular Expression Matching:</strong> Check if string matches pattern with '.' and '*' operators</p>
            <p class="mb-0" id="regexExplanation">Initializing regex matching algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="regexStepsContainer">
            <h6 class="text-center">Regex Matching Steps</h6>
            <div class="steps-container" id="regexSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Matching Result</div>
            <div class="stats-value" id="regexResult">Processing...</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterRegex" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    // Display string and pattern
    renderStringAsArray(str, 'stringDisplay');
    renderPatternAsArray(pattern, 'patternDisplay');
    
    // Initialize DP table display
    initializeDPTable(str, pattern, 'dpTableDisplay');
    
    // Start regex matching animation
    executeRegexMatching(str, pattern);
}

// NEW: Render String as Array
function renderStringAsArray(str, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    for (let i = 0; i <= str.length; i++) {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        
        const valueDiv = document.createElement('div');
        valueDiv.className = 'element-value';
        
        if (i === 0) {
            valueDiv.textContent = ''; // Empty string symbol
            valueDiv.style.background = 'var(--secondary-color)';
        } else {
            valueDiv.textContent = str[i-1];
        }
        
        const indexDiv = document.createElement('div');
        indexDiv.className = 'element-index';
        indexDiv.textContent = i === 0 ? 'start' : `[${i-1}]`;
        
        arrayElement.appendChild(valueDiv);
        arrayElement.appendChild(indexDiv);
        container.appendChild(arrayElement);
    }
}

// NEW: Render Pattern as Array
function renderPatternAsArray(pattern, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    for (let i = 0; i <= pattern.length; i++) {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        
        const valueDiv = document.createElement('div');
        valueDiv.className = 'element-value';
        
        if (i === 0) {
            valueDiv.textContent = ''; // Empty string symbol
            valueDiv.style.background = 'var(--secondary-color)';
        } else {
            valueDiv.textContent = pattern[i-1];
            // Color code special characters
            if (pattern[i-1] === '*' || pattern[i-1] === '?' || pattern[i-1] === '.') {
                valueDiv.style.background = 'var(--warning-color)';
            }
        }
        
        const indexDiv = document.createElement('div');
        indexDiv.className = 'element-index';
        indexDiv.textContent = i === 0 ? 'start' : `[${i-1}]`;
        
        arrayElement.appendChild(valueDiv);
        arrayElement.appendChild(indexDiv);
        container.appendChild(arrayElement);
    }
}

// NEW: Initialize DP Table
function initializeDPTable(str, pattern, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    const table = document.createElement('div');
    table.className = 'dp-table';
    table.style.display = 'grid';
    table.style.gridTemplateColumns = `repeat(${pattern.length + 2}, 1fr)`;
    table.style.gap = '5px';
    table.style.width = '100%';
    
    // Create header row
    for (let i = -1; i <= pattern.length; i++) {
        const headerCell = document.createElement('div');
        headerCell.className = 'dp-cell dp-header';
        headerCell.style.padding = '10px';
        headerCell.style.textAlign = 'center';
        headerCell.style.background = 'var(--primary-color)';
        headerCell.style.borderRadius = '5px';
        
        if (i === -1) {
            headerCell.textContent = 'str\\pat';
        } else if (i === 0) {
            headerCell.textContent = '';
        } else {
            headerCell.textContent = pattern[i-1];
        }
        
        table.appendChild(headerCell);
    }
    
    // Create data rows
    for (let i = 0; i <= str.length; i++) {
        // Row header
        const rowHeader = document.createElement('div');
        rowHeader.className = 'dp-cell dp-header';
        rowHeader.style.padding = '10px';
        rowHeader.style.textAlign = 'center';
        rowHeader.style.background = 'var(--primary-color)';
        rowHeader.style.borderRadius = '5px';
        rowHeader.textContent = i === 0 ? '' : str[i-1];
        table.appendChild(rowHeader);
        
        // Data cells
        for (let j = 0; j <= pattern.length; j++) {
            const dataCell = document.createElement('div');
            dataCell.className = 'dp-cell';
            dataCell.style.padding = '10px';
            dataCell.style.textAlign = 'center';
            dataCell.style.background = 'rgba(255, 255, 255, 0.1)';
            dataCell.style.borderRadius = '5px';
            dataCell.style.minHeight = '40px';
            dataCell.style.display = 'flex';
            dataCell.style.alignItems = 'center';
            dataCell.style.justifyContent = 'center';
            dataCell.id = `dp-cell-${i}-${j}`;
            dataCell.textContent = 'F'; // Initialize as false
            
            table.appendChild(dataCell);
        }
    }
    
    container.appendChild(table);
}

// NEW: Execute Wildcard Matching Algorithm
function executeWildcardMatching(str, pattern) {
    const explanation = document.getElementById('wildcardExplanation');
    const stepsContainer = document.getElementById('wildcardSteps');
    const resultDiv = document.getElementById('wildcardResult');
    const continueButton = document.getElementById('continueAfterWildcard');
    
    const m = str.length;
    const n = pattern.length;
    
    // Initialize DP table
    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(false));
    dp[0][0] = true;
    
    // Handle patterns that start with multiple '*'
    for (let j = 1; j <= n; j++) {
        if (pattern[j - 1] === '*') {
            dp[0][j] = dp[0][j - 1];
        }
    }
    
    let step = 0;
    
    function updateDPCell(i, j, value, reason) {
        setTimeout(() => {
            const cell = document.getElementById(`dp-cell-${i}-${j}`);
            cell.textContent = value ? 'T' : 'F';
            cell.style.background = value ? 'var(--success-color)' : 'var(--danger-color)';
            cell.classList.add('pulse');
            
            explanation.innerHTML = reason;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> ${reason}
                </div>
            `;
            
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            step++;
        }, step * 1000);
    }
    
    // Initialize first row (empty string)
    updateDPCell(0, 0, true, 'Base case: Empty string matches empty pattern');
    
    for (let j = 1; j <= n; j++) {
        if (pattern[j - 1] === '*') {
            dp[0][j] = dp[0][j - 1];
            updateDPCell(0, j, dp[0][j], 
                `Pattern[${j-1}]='*': Empty string matches pattern[0:${j}] = ${dp[0][j]}`);
        }
    }
    
    // Fill DP table
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            setTimeout(() => {
                if (pattern[j - 1] === '*') {
                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];
                    updateDPCell(i, j, dp[i][j],
                        `Pattern[${j-1}]='*': str[0:${i}] matches pattern[0:${j}] = ${dp[i][j]} ` +
                        `(using str[0:${i-1}] or pattern[0:${j-1}])`);
                } else if (pattern[j - 1] === '?' || str[i - 1] === pattern[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                    updateDPCell(i, j, dp[i][j],
                        `str[${i-1}]='${str[i-1]}' matches pattern[${j-1}]='${pattern[j-1]}': ` +
                        `str[0:${i}] matches pattern[0:${j}] = ${dp[i][j]}`);
                } else {
                    dp[i][j] = false;
                    updateDPCell(i, j, dp[i][j],
                        `str[${i-1}]='${str[i-1]}' doesn't match pattern[${j-1}]='${pattern[j-1]}': ` +
                        `str[0:${i}] matches pattern[0:${j}] = false`);
                }
                
                // If this is the last cell, show final result
                if (i === m && j === n) {
                    setTimeout(() => {
                        const result = dp[m][n];
                        resultDiv.textContent = result ? 'MATCH' : 'NO MATCH';
                        resultDiv.style.color = result ? 'var(--success-color)' : 'var(--danger-color)';
                        resultDiv.style.fontWeight = 'bold';
                        
                        explanation.innerHTML = `<strong>Final Result:</strong> "${str}" ${result ? 'matches' : 'does not match'} pattern "${pattern}"`;
                        
                        continueButton.style.display = 'block';
                        
                        // Auto-return after 10 seconds
                        setTimeout(() => {
                            returnToOriginalAfterPatternMatching();
                        }, 10000);
                        
                        continueButton.addEventListener('click', returnToOriginalAfterPatternMatching);
                    }, 1000);
                }
            }, step * 1000);
        }
    }
}

// NEW: Execute Regex Matching Algorithm
function executeRegexMatching(str, pattern) {
    const explanation = document.getElementById('regexExplanation');
    const stepsContainer = document.getElementById('regexSteps');
    const resultDiv = document.getElementById('regexResult');
    const continueButton = document.getElementById('continueAfterRegex');
    
    const m = str.length;
    const n = pattern.length;
    
    // Initialize DP table
    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(false));
    dp[0][0] = true;
    
    // Handle patterns like a*, a*b*, a*b*c* that can match empty string
    for (let j = 2; j <= n; j++) {
        if (pattern[j - 1] === '*') {
            dp[0][j] = dp[0][j - 2];
        }
    }
    
    let step = 0;
    
    function updateDPCell(i, j, value, reason) {
        setTimeout(() => {
            const cell = document.getElementById(`dp-cell-${i}-${j}`);
            cell.textContent = value ? 'T' : 'F';
            cell.style.background = value ? 'var(--success-color)' : 'var(--danger-color)';
            cell.classList.add('pulse');
            
            explanation.innerHTML = reason;
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong> ${reason}
                </div>
            `;
            
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            step++;
        }, step * 800);
    }
    
    // Initialize first row (empty string)
    updateDPCell(0, 0, true, 'Base case: Empty string matches empty pattern');
    
    for (let j = 2; j <= n; j++) {
        if (pattern[j - 1] === '*') {
            dp[0][j] = dp[0][j - 2];
            updateDPCell(0, j, dp[0][j], 
                `Pattern[${j-1}]='*': Empty string matches pattern[0:${j}] = ${dp[0][j]} ` +
                `(ignoring previous character with '*')`);
        }
    }
    
    // Fill DP table
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            setTimeout(() => {
                if (pattern[j - 1] === '*') {
                    // Zero or more of the previous character
                    dp[i][j] = dp[i][j - 2] || 
                               (dp[i - 1][j] && (str[i - 1] === pattern[j - 2] || pattern[j - 2] === '.'));
                    
                    updateDPCell(i, j, dp[i][j],
                        `Pattern[${j-1}]='*': str[0:${i}] matches pattern[0:${j}] = ${dp[i][j]} ` +
                        `(zero occurrences or matching previous character)`);
                } else if (pattern[j - 1] === '.' || str[i - 1] === pattern[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                    updateDPCell(i, j, dp[i][j],
                        `str[${i-1}]='${str[i-1]}' matches pattern[${j-1}]='${pattern[j-1]}': ` +
                        `str[0:${i}] matches pattern[0:${j}] = ${dp[i][j]}`);
                } else {
                    dp[i][j] = false;
                    updateDPCell(i, j, dp[i][j],
                        `str[${i-1}]='${str[i-1]}' doesn't match pattern[${j-1}]='${pattern[j-1]}': ` +
                        `str[0:${i}] matches pattern[0:${j}] = false`);
                }
                
                // If this is the last cell, show final result
                if (i === m && j === n) {
                    setTimeout(() => {
                        const result = dp[m][n];
                        resultDiv.textContent = result ? 'MATCH' : 'NO MATCH';
                        resultDiv.style.color = result ? 'var(--success-color)' : 'var(--danger-color)';
                        resultDiv.style.fontWeight = 'bold';
                        
                        explanation.innerHTML = `<strong>Final Result:</strong> "${str}" ${result ? 'matches' : 'does not match'} pattern "${pattern}"`;
                        
                        continueButton.style.display = 'block';
                        
                        // Auto-return after 10 seconds
                        setTimeout(() => {
                            returnToOriginalAfterPatternMatching();
                        }, 15000);
                        
                        continueButton.addEventListener('click', returnToOriginalAfterPatternMatching);
                    }, 1000);
                }
            }, step * 800);
        }
    }
}

// NEW: Return to Original after Pattern Matching
function returnToOriginalAfterPatternMatching() {
    // Reset to original array
    myArray = [...originalArrayForPatternMatching];
    originalArrayForPatternMatching = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isPatternMatchingRunning = false;
    currentPatternMatchingType = null;
    
    // Clear inputs
    patternString.value = '';
    patternPattern.value = '';
    
    logOperation('Pattern matching completed - returned to original array', 'info');
    showNotification('Returned to original array after pattern matching', 'success');
}
// NEW: Combination Sum Handler
function handleCombinationSum() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Combination Sum requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Show input group
    combinationSumGroup.style.display = 'block';
    combinationSumTarget.focus();
}

// NEW: Subsets Handler
function handleSubsets() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isSubsetsRunning) {
        showNotification('Subsets operation is already in progress', 'warning');
        return;
    }
    
    isSubsetsRunning = true;
    
    // Store original array
    originalArrayForBacktrack = [...myArray];
    
    // Perform subsets visualization
    performSubsetsVisualization();
}

// NEW: Confirm Combination Sum Handler
function handleConfirmCombinationSum() {
    const target = parseFloat(combinationSumTarget.value);
    
    if (isNaN(target)) {
        showNotification('Please enter a valid target sum', 'danger');
        combinationSumTarget.focus();
        return;
    }
    
    if (isCombinationSumRunning) {
        showNotification('Combination Sum operation is already in progress', 'warning');
        return;
    }
    
    isCombinationSumRunning = true;
    
    // Hide input group
    combinationSumGroup.style.display = 'none';
    combinationSumTarget.value = '';
    
    // Store original array
    originalArrayForBacktrack = [...myArray];
    
    // Perform combination sum visualization
    performCombinationSumVisualization(target);
}

// NEW: Cancel Combination Sum Handler
function handleCancelCombinationSum() {
    combinationSumGroup.style.display = 'none';
    combinationSumTarget.value = '';
}
// NEW: Perform Combination Sum Visualization
function performCombinationSumVisualization(target) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Combination Sum - Target: ${target}</h5>
        
        <div class="array-group">
            <div class="array-label">Candidates Array</div>
            <div class="original-array-container" id="candidatesArray"></div>
        </div>
        
        <div class="backtrack-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find all unique combinations where candidate numbers sum to target</p>
            <p class="mb-0" id="combinationExplanation">Initializing backtracking algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="combinationStepsContainer">
            <h6 class="text-center">Backtracking Steps</h6>
            <div class="steps-container" id="combinationSteps"></div>
        </div>
        
        <div class="combination-result mt-3" id="combinationResults" style="display: none;">
            <h6 class="text-center">Valid Combinations Found</h6>
            <div id="combinationsList"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterCombination" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForBacktrack, 'candidatesArray');
    
    executeCombinationSumAlgorithm(target);
}

// NEW: Execute Combination Sum Algorithm
function executeCombinationSumAlgorithm(target) {
    const arrayContainer = document.getElementById('candidatesArray');
    const explanation = document.getElementById('combinationExplanation');
    const stepsContainer = document.getElementById('combinationSteps');
    const resultsDiv = document.getElementById('combinationResults');
    const combinationsList = document.getElementById('combinationsList');
    const continueButton = document.getElementById('continueAfterCombination');
    
    const candidates = originalArrayForBacktrack.map(val => parseFloat(val));
    const result = [];
    let step = 0;
    let currentPath = [];
    let currentSum = 0;
    
    // Sort candidates (helps with pruning)
    candidates.sort((a, b) => a - b);
    
    function backtrack(start, path, sum) {
        step++;
        
        if (sum === target) {
            // Found a valid combination
            explanation.innerHTML = `<strong>Valid Combination Found!</strong> Sum = ${sum}, Path: [${path.join(', ')}]`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step}:</strong>  Valid combination found! [${path.join(', ')}] = ${sum}
                </div>
            `;
            
            result.push([...path]);
            
            // Highlight the valid combination
            highlightValidCombination(path);
            
            return new Promise(resolve => setTimeout(resolve, 2000));
        }
        
        if (sum > target) {
            // Exceeded target
            explanation.innerHTML = `Sum exceeded target: ${sum} > ${target}, backtracking...`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}:</strong>  Sum ${sum} > target ${target}, backtracking
                </div>
            `;
            
            return Promise.resolve();
        }
        
        explanation.innerHTML = `Exploring combinations starting from index ${start}, current sum: ${sum}, path: [${path.join(', ')}]`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${step}:</strong> Start=${start}, Sum=${sum}, Path=[${path.join(', ')}]
            </div>
        `;
        
        return new Promise(resolve => {
            let promiseChain = Promise.resolve();
            
            for (let i = start; i < candidates.length; i++) {
                const num = candidates[i];
                
                if (sum + num > target) {
                    // Prune: since array is sorted, no need to check further
                    explanation.innerHTML = `Pruning: sum ${sum + num} > target ${target}, stopping exploration`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step}.${i}:</strong> Pruning - sum would exceed target
                        </div>
                    `;
                    
                    break;
                }
                
                promiseChain = promiseChain.then(() => {
                    // Add current number to path
                    step++;
                    path.push(num);
                    const newSum = sum + num;
                    
                    explanation.innerHTML = `Trying candidate [${i}]=${num}, new sum: ${newSum}, path: [${path.join(', ')}]`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step}:</strong> Add [${i}]=${num}, Sum=${newSum}, Path=[${path.join(', ')}]
                        </div>
                    `;
                    
                    // Highlight current candidate
                    const elements = arrayContainer.querySelectorAll('.array-element');
                    elements[i].querySelector('.element-value').classList.add('backtrack-current');
                    
                    return new Promise(resolveStep => {
                        setTimeout(() => {
                            elements[i].querySelector('.element-value').classList.remove('backtrack-current');
                            elements[i].querySelector('.element-value').classList.add('backtrack-included');
                            
                            // Recursively explore
                            backtrack(i, path, newSum).then(() => {
                                // Backtrack: remove last element
                                path.pop();
                                step++;
                                
                                explanation.innerHTML = `Backtracking: removed ${num}, path: [${path.join(', ')}]`;
                                
                                stepsContainer.innerHTML += `
                                    <div class="algorithm-step">
                                        <strong>Step ${step}:</strong> Backtrack - remove ${num}, Path=[${path.join(', ')}]
                                    </div>
                                `;
                                
                                elements[i].querySelector('.element-value').classList.remove('backtrack-included');
                                resolveStep();
                            });
                        }, 1500);
                    });
                });
            }
            
            promiseChain.then(resolve);
        });
    }
    
    function highlightValidCombination(path) {
        const elements = arrayContainer.querySelectorAll('.array-element');
        const candidateCount = {};
        
        // Count occurrences in the valid combination
        path.forEach(num => {
            candidateCount[num] = (candidateCount[num] || 0) + 1;
        });
        
        // Highlight elements that are part of the combination
        elements.forEach((element, index) => {
            const value = parseFloat(element.querySelector('.element-value').textContent);
            const countInCombination = candidateCount[value] || 0;
            
            if (countInCombination > 0) {
                element.querySelector('.element-value').classList.add('backtrack-valid');
                candidateCount[value]--;
            }
        });
        
        // Add combination to results
        const combinationDiv = document.createElement('div');
        combinationDiv.className = 'subset-item';
        combinationDiv.textContent = `[${path.join(', ')}]`;
        combinationsList.appendChild(combinationDiv);
    }
    
    // Start the algorithm
    backtrack(0, [], 0).then(() => {
        explanation.innerHTML = `<strong>Algorithm Completed!</strong> Found ${result.length} valid combination(s) for target ${target}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Final:</strong> Found ${result.length} combination(s) for target ${target}
            </div>
        `;
        
        resultsDiv.style.display = 'block';
        continueButton.style.display = 'block';
        
        // Auto-return after 10 seconds
        setTimeout(() => {
            returnToOriginalAfterBacktrack();
        }, 10000);
        
        continueButton.addEventListener('click', returnToOriginalAfterBacktrack);
        
        // Log operation
        logOperation(`Found ${result.length} combination(s) for target ${target}: ${JSON.stringify(result)}`, 'success');
    });
}

// NEW: Perform Subsets Visualization
function performSubsetsVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Generate All Subsets</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="subsetsArray"></div>
        </div>
        
        <div class="backtrack-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Generate all possible subsets (power set)</p>
            <p class="mb-0" id="subsetsExplanation">Initializing backtracking algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="subsetsStepsContainer">
            <h6 class="text-center">Backtracking Steps</h6>
            <div class="steps-container" id="subsetsSteps"></div>
        </div>
        
        <div class="combination-result mt-3" id="subsetsResults">
            <h6 class="text-center">Generated Subsets</h6>
            <div id="subsetsList"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSubsets" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForBacktrack, 'subsetsArray');
    
    executeSubsetsAlgorithm();
}

// NEW: Execute Subsets Algorithm
function executeSubsetsAlgorithm() {
    const arrayContainer = document.getElementById('subsetsArray');
    const explanation = document.getElementById('subsetsExplanation');
    const stepsContainer = document.getElementById('subsetsSteps');
    const subsetsList = document.getElementById('subsetsList');
    const continueButton = document.getElementById('continueAfterSubsets');
    
    const nums = [...originalArrayForBacktrack];
    const result = [];
    let step = 0;
    
    function backtrack(start, path) {
        step++;
        
        // Add current subset to result
        explanation.innerHTML = `Adding subset: [${path.join(', ')}]`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong>  Subset found: [${path.join(', ')}]
            </div>
        `;
        
        result.push([...path]);
        
        // Display the subset
        const subsetDiv = document.createElement('div');
        subsetDiv.className = 'subset-item';
        subsetDiv.textContent = `[${path.join(', ')}]`;
        subsetsList.appendChild(subsetDiv);
        
        // Highlight elements in current subset
        const elements = arrayContainer.querySelectorAll('.array-element');
        elements.forEach((element, index) => {
            element.querySelector('.element-value').classList.remove('backtrack-included', 'backtrack-skipped');
            
            if (path.includes(nums[index])) {
                element.querySelector('.element-value').classList.add('backtrack-included');
            } else {
                element.querySelector('.element-value').classList.add('backtrack-skipped');
            }
        });
        
        return new Promise(resolve => {
            setTimeout(() => {
                let promiseChain = Promise.resolve();
                
                for (let i = start; i < nums.length; i++) {
                    promiseChain = promiseChain.then(() => {
                        step++;
                        
                        explanation.innerHTML = `Exploring: add ${nums[i]} to current subset`;
                        
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step">
                                <strong>Step ${step}:</strong> Include [${i}]=${nums[i]} in subset
                            </div>
                        `;
                        
                        // Highlight current element being considered
                        elements[i].querySelector('.element-value').classList.add('backtrack-current');
                        
                        return new Promise(resolveStep => {
                            setTimeout(() => {
                                elements[i].querySelector('.element-value').classList.remove('backtrack-current');
                                
                                path.push(nums[i]);
                                backtrack(i + 1, path).then(() => {
                                    path.pop();
                                    resolveStep();
                                });
                            }, 1000);
                        });
                    });
                }
                
                promiseChain.then(resolve);
            }, 1000);
        });
    }
    
    // Start the algorithm
    backtrack(0, []).then(() => {
        explanation.innerHTML = `<strong>Algorithm Completed!</strong> Generated ${result.length} subsets (power set)`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Final:</strong> Generated ${result.length} subsets including empty set
            </div>
        `;
        
        continueButton.style.display = 'block';
        
        // Auto-return after 10 seconds
        setTimeout(() => {
            returnToOriginalAfterBacktrack();
        }, 10000);
        
        continueButton.addEventListener('click', returnToOriginalAfterBacktrack);
        
        // Log operation
        logOperation(`Generated ${result.length} subsets: ${JSON.stringify(result)}`, 'success');
    });
}

// NEW: Return to Original after Backtracking Operations
function returnToOriginalAfterBacktrack() {
    // Reset to original array
    myArray = [...originalArrayForBacktrack];
    originalArrayForBacktrack = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset states
    isCombinationSumRunning = false;
    isSubsetsRunning = false;
    
    logOperation('Returned to original array after backtracking operation', 'info');
    showNotification('Returned to original array', 'success');
}
// NEW: Longest Valid Parentheses Handler
function handleLongestValidParentheses() {
    if (isParenthesesOperationRunning) {
        showNotification('A parentheses operation is already in progress', 'warning');
        return;
    }
    
    // Show input group
    parenthesesInputGroup.style.display = 'block';
    lvpInput.focus();
    
    // Hide other input groups
    subsequencesInputGroup.style.display = 'none';
    
    logOperation('Started longest valid parentheses operation', 'info');
}

// NEW: Distinct Subsequences Handler
function handleDistinctSubsequences() {
    if (isSubsequencesOperationRunning) {
        showNotification('A subsequences operation is already in progress', 'warning');
        return;
    }
    
    // Show input group
    subsequencesInputGroup.style.display = 'block';
    dsMainStringInput.focus();
    
    // Hide other input groups
    parenthesesInputGroup.style.display = 'none';
    
    logOperation('Started distinct subsequences operation', 'info');
}

// NEW: Confirm Parentheses Handler
function handleConfirmParentheses() {
    const input = lvpInput.value.trim();
    
    if (input === '') {
        showNotification('Please enter a parentheses string', 'danger');
        lvpInput.focus();
        return;
    }
    
    // Validate input - only allow parentheses
    if (!/^[()]*$/.test(input)) {
        showNotification('Please enter only parentheses characters: ( and )', 'danger');
        lvpInput.focus();
        return;
    }
    
    if (input.length > 50) {
        showNotification('String too long. Maximum 50 characters allowed.', 'danger');
        lvpInput.focus();
        return;
    }
    
    // Store original array
    originalArrayForParentheses = [...myArray];
    
    // Hide input group
    parenthesesInputGroup.style.display = 'none';
    
    // Start parentheses visualization
    performLongestValidParentheses(input);
}

// NEW: Confirm Subsequences Handler
function handleConfirmSubsequences() {
    const s = dsMainStringInput.value.trim();
    const t = dsTargetStringInput.value.trim();
    
    if (s === '') {
        showNotification('Please enter the main string', 'danger');
        dsMainStringInput.focus();
        return;
    }
    
    if (t === '') {
        showNotification('Please enter the target string', 'danger');
        dsTargetStringInput.focus();
        return;
    }
    
    if (s.length > 30) {
        showNotification('Main string too long. Maximum 30 characters allowed.', 'danger');
        dsMainStringInput.focus();
        return;
    }
    
    if (t.length > 20) {
        showNotification('Target string too long. Maximum 20 characters allowed.', 'danger');
        dsTargetStringInput.focus();
        return;
    }
    
    if (t.length > s.length) {
        showNotification('Target string cannot be longer than main string', 'danger');
        dsTargetStringInput.focus();
        return;
    }
    
    // Store original array
    originalArrayForSubsequences = [...myArray];
    
    // Hide input group
    subsequencesInputGroup.style.display = 'none';
    
    // Start subsequences visualization
    performDistinctSubsequences(s, t);
}

// NEW: Cancel Parentheses Handler
function handleCancelParentheses() {
    parenthesesInputGroup.style.display = 'none';
    lvpInput.value = '';
}

// NEW: Cancel Subsequences Handler
function handleCancelSubsequences() {
    subsequencesInputGroup.style.display = 'none';
    dsMainStringInput.value = '';
    dsTargetStringInput.value = '';
}
// NEW: Perform Longest Valid Parentheses with Animation
function performLongestValidParentheses(s) {
    isParenthesesOperationRunning = true;
    
    const container = document.createElement('div');
    container.className = 'dual-operation-container';
    container.innerHTML = `
        <h5 class="text-center mb-3">Longest Valid Parentheses</h5>
        
        <div class="array-group">
            <div class="array-label">Input String: "${s}"</div>
            <div class="original-array-container" id="parenthesesArray"></div>
        </div>
        
        <div class="parenthesis-stack mt-3">
            <h6 class="text-center">Stack Operations</h6>
            <div id="stackContainer"></div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Using stack to track valid parentheses positions</p>
            <p class="mb-0" id="parenthesesExplanation">Initializing algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="parenthesesStepsContainer">
            <h6 class="text-center">Algorithm Steps</h6>
            <div class="steps-container" id="parenthesesSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Longest Valid Parentheses Length</div>
            <div class="stats-value" id="longestParenthesesValue">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterParentheses" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(container);
    
    // Render the parentheses as array elements
    renderParenthesesArray(s);
    
    executeLongestValidParentheses(s);
}

// NEW: Render Parentheses Array
function renderParenthesesArray(s) {
    const container = document.getElementById('parenthesesArray');
    container.innerHTML = '';
    
    for (let i = 0; i < s.length; i++) {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value" data-index="${i}">${s[i]}</div>
            <div class="element-index">${i}</div>
        `;
        container.appendChild(arrayElement);
    }
}

// NEW: Execute Longest Valid Parentheses Algorithm
function executeLongestValidParentheses(s) {
    const arrayContainer = document.getElementById('parenthesesArray');
    const stackContainer = document.getElementById('stackContainer');
    const explanation = document.getElementById('parenthesesExplanation');
    const stepsContainer = document.getElementById('parenthesesSteps');
    const longestValue = document.getElementById('longestParenthesesValue');
    const continueButton = document.getElementById('continueAfterParentheses');
    
    let max_len = 0;
    let stack = [-1]; // stack stores indices, -1 is sentinel
    let step = 0;
    
    // Initialize stack display
    updateStackDisplay(stack, stackContainer, -1);
    
    function executeStep(i) {
        if (i >= s.length) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Longest valid parentheses length = ${max_len}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Maximum valid parentheses length = ${max_len}
                </div>
            `;
            
            longestValue.textContent = max_len;
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterParentheses();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterParentheses);
            
            return;
        }
        
        step++;
        const char = s[i];
        
        // Highlight current character
        const elements = arrayContainer.querySelectorAll('.array-element');
        const currentElement = elements[i].querySelector('.element-value');
        currentElement.classList.add('parenthesis-current');
        
        explanation.innerHTML = `Step ${step}: Processing character at index ${i} = "${char}"`;
        
        if (char === '(') {
            // Push opening bracket index
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}:</strong> Found '(', pushing index ${i} to stack
                </div>
            `;
            
            setTimeout(() => {
                stack.push(i);
                updateStackDisplay(stack, stackContainer, i);
                
                currentElement.classList.remove('parenthesis-current');
                
                executeStep(i + 1);
            }, 1500);
            
        } else {
            // Closing bracket
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}:</strong> Found ')', popping from stack
                </div>
            `;
            
            setTimeout(() => {
                stack.pop();
                
                if (stack.length === 0) {
                    // New base if no valid structure left
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step}.1:</strong> Stack empty, pushing current index ${i} as new base
                        </div>
                    `;
                    
                    stack.push(i);
                    updateStackDisplay(stack, stackContainer, i);
                    currentElement.classList.add('parenthesis-invalid');
                    
                } else {
                    // Calculate current valid length
                    const current_len = i - stack[stack.length - 1];
                    max_len = Math.max(max_len, current_len);
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step}.1:</strong> Valid sequence found! Length = ${current_len}, Max = ${max_len}
                        </div>
                    `;
                    
                    // Highlight the valid sequence
                    const start = stack[stack.length - 1] + 1;
                    for (let j = start; j <= i; j++) {
                        elements[j].querySelector('.element-value').classList.add('parenthesis-match');
                    }
                    
                    currentElement.classList.add('parenthesis-match');
                    longestValue.textContent = max_len;
                }
                
                updateStackDisplay(stack, stackContainer, -1);
                
                setTimeout(() => {
                    currentElement.classList.remove('parenthesis-current');
                    executeStep(i + 1);
                }, 2000);
                
            }, 1500);
        }
    }
    
    // Start execution
    executeStep(0);
}

// NEW: Update Stack Display
function updateStackDisplay(stack, container, highlightIndex) {
    container.innerHTML = '';
    
    // Display stack from bottom to top
    for (let i = 0; i < stack.length; i++) {
        const item = document.createElement('div');
        item.className = `stack-item ${stack[i] === highlightIndex ? 'current' : ''} ${stack[i] === -1 ? 'sentinel' : ''}`;
        item.textContent = stack[i] === -1 ? 'Sentinel (-1)' : `Index: ${stack[i]} (${stack[i] === -1 ? '' : `"${myArray[stack[i]] || 'N/A'}"`})`;
        container.appendChild(item);
    }
    
    if (stack.length === 0) {
        const emptyMsg = document.createElement('div');
        emptyMsg.className = 'stack-item';
        emptyMsg.textContent = 'Stack is empty';
        container.appendChild(emptyMsg);
    }
}

// NEW: Perform Distinct Subsequences with Animation
function performDistinctSubsequences(s, t) {
    isSubsequencesOperationRunning = true;
    
    const container = document.createElement('div');
    container.className = 'dual-operation-container';
    container.innerHTML = `
        <h5 class="text-center mb-3">Distinct Subsequences</h5>
        
        <div class="array-group">
            <div class="array-label">Main String (s): "${s}"</div>
            <div class="original-array-container" id="mainStringArray"></div>
        </div>
        
        <div class="array-group mt-3">
            <div class="array-label">Target String (t): "${t}"</div>
            <div class="original-array-container" id="targetStringArray"></div>
        </div>
        
        <div class="algorithm-explanation mt-3">
            <p class="mb-2"><strong>Algorithm:</strong> Dynamic Programming - Count how many times t appears in s as subsequence</p>
            <p class="mb-0" id="subsequencesExplanation">Initializing DP table...</p>
        </div>
        
        <div id="dpTableContainer" class="mt-3"></div>
        
        <div class="algorithm-steps mt-3" id="subsequencesStepsContainer">
            <h6 class="text-center">DP Table Construction Steps</h6>
            <div class="steps-container" id="subsequencesSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Distinct Subsequences Count</div>
            <div class="stats-value" id="subsequencesCountValue">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSubsequences" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(container);
    
    // Render the strings as arrays
    renderStringArray(s, 'mainStringArray');
    renderStringArray(t, 'targetStringArray');
    
    executeDistinctSubsequences(s, t);
}

// NEW: Render String Array
function renderStringArray(str, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    for (let i = 0; i < str.length; i++) {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value" data-index="${i}">${str[i]}</div>
            <div class="element-index">${i}</div>
        `;
        container.appendChild(arrayElement);
    }
}

// NEW: Execute Distinct Subsequences Algorithm
function executeDistinctSubsequences(s, t) {
    const explanation = document.getElementById('subsequencesExplanation');
    const stepsContainer = document.getElementById('subsequencesSteps');
    const countValue = document.getElementById('subsequencesCountValue');
    const continueButton = document.getElementById('continueAfterSubsequences');
    const dpTableContainer = document.getElementById('dpTableContainer');
    
    const m = s.length, n = t.length;
    let dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
    let step = 0;
    
    // Initialize DP table display
    updateDPTable(dp, s, t, dpTableContainer, -1, -1);
    
    function executeStep() {
        if (step === 0) {
            // Step 1: Initialize first column (empty t can be formed in 1 way)
            explanation.innerHTML = `Step ${step + 1}: Initialize DP table - empty target can be formed in 1 way`;
            
            for (let i = 0; i <= m; i++) {
                dp[i][0] = 1;
            }
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Step ${step + 1}:</strong> Initialize dp[i][0] = 1 for all i (empty target)
                </div>
            `;
            
            updateDPTable(dp, s, t, dpTableContainer, -1, 0);
            step++;
            
            setTimeout(executeStep, 2000);
            
        } else if (step <= m * n) {
            const i = Math.floor((step - 1) / n) + 1;
            const j = ((step - 1) % n) + 1;
            
            if (i <= m && j <= n) {
                explanation.innerHTML = `Step ${step + 1}: Processing dp[${i}][${j}] - s[${i-1}]="${s[i-1]}", t[${j-1}]="${t[j-1]}"`;
                
                // Highlight current characters in strings
                highlightCurrentCharacters(i-1, j-1);
                
                if (s[i-1] === t[j-1]) {
                    // Characters match
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step + 1}:</strong> s[${i-1}]="${s[i-1]}" == t[${j-1}]="${t[j-1]}", so dp[${i}][${j}] = dp[${i-1}][${j-1}] + dp[${i-1}][${j}] = ${dp[i-1][j-1]} + ${dp[i-1][j]} = ${dp[i-1][j-1] + dp[i-1][j]}
                        </div>
                    `;
                    
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
                    
                } else {
                    // Characters don't match
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step + 1}:</strong> s[${i-1}]="${s[i-1]}" != t[${j-1}]="${t[j-1]}", so dp[${i}][${j}] = dp[${i-1}][${j}] = ${dp[i-1][j]}
                        </div>
                    `;
                    
                    dp[i][j] = dp[i-1][j];
                }
                
                updateDPTable(dp, s, t, dpTableContainer, i, j);
                countValue.textContent = dp[m][n];
                step++;
                
                setTimeout(executeStep, 2000);
                
            } else {
                step++;
                executeStep();
            }
            
        } else {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Distinct subsequences count = ${dp[m][n]}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> dp[${m}][${n}] = ${dp[m][n]} distinct subsequences
                </div>
            `;
            
            countValue.textContent = dp[m][n];
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterSubsequences();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSubsequences);
        }
    }
    
    // Start execution
    executeStep();
}

// NEW: Highlight Current Characters
function highlightCurrentCharacters(sIndex, tIndex) {
    // Highlight in main string
    const mainElements = document.getElementById('mainStringArray').querySelectorAll('.array-element');
    mainElements.forEach((el, idx) => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('parenthesis-current', 'parenthesis-match');
        if (idx === sIndex) {
            valueDiv.classList.add('parenthesis-current');
        }
    });
    
    // Highlight in target string
    const targetElements = document.getElementById('targetStringArray').querySelectorAll('.array-element');
    targetElements.forEach((el, idx) => {
        const valueDiv = el.querySelector('.element-value');
        valueDiv.classList.remove('parenthesis-current', 'parenthesis-match');
        if (idx === tIndex) {
            valueDiv.classList.add('parenthesis-current');
        }
    });
}

// NEW: Update DP Table Display
function updateDPTable(dp, s, t, container, highlightI, highlightJ) {
    const m = s.length, n = t.length;
    
    let html = `
        <div class="dp-table">
            <div class="dp-row">
                <div class="dp-cell header">s\\t</div>
                <div class="dp-cell header"></div>
    `;
    
    // Header row (target string)
    for (let j = 0; j < n; j++) {
        html += `<div class="dp-cell header">${t[j]}</div>`;
    }
    html += `</div>`;
    
    // Data rows
    for (let i = 0; i <= m; i++) {
        html += `<div class="dp-row">`;
        
        // First column (main string character or empty)
        if (i === 0) {
            html += `<div class="dp-cell header"></div>`;
        } else {
            html += `<div class="dp-cell header">${s[i-1]}</div>`;
        }
        
        // DP values
        for (let j = 0; j <= n; j++) {
            let cellClass = 'dp-cell';
            if (i === highlightI && j === highlightJ) {
                cellClass += ' current';
            } else if (dp[i][j] > 0) {
                cellClass += ' updated';
            } else if (i > 0 && j > 0) {
                cellClass += ' zero';
            }
            
            html += `<div class="${cellClass}">${dp[i][j]}</div>`;
        }
        
        html += `</div>`;
    }
    
    html += `</div>`;
    container.innerHTML = html;
}

// NEW: Return to Original after Parentheses
function returnToOriginalAfterParentheses() {
    // Reset to original array
    myArray = [...originalArrayForParentheses];
    originalArrayForParentheses = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state and clear input
    isParenthesesOperationRunning = false;
    lvpInput.value = '';
    
    logOperation('Longest valid parentheses operation completed', 'info');
    showNotification('Returned to original array', 'success');
}

// NEW: Return to Original after Subsequences
function returnToOriginalAfterSubsequences() {
    // Reset to original array
    myArray = [...originalArrayForSubsequences];
    originalArrayForSubsequences = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state and clear inputs
    isSubsequencesOperationRunning = false;
    dsMainStringInput.value = '';
    dsTargetStringInput.value = '';
    
    logOperation('Distinct subsequences operation completed', 'info');
    showNotification('Returned to original array', 'success');
}
// NEW: Start Word Concatenation Search Handler
function handleStartWordConcatSearch() {
    if (isWordConcatSearchActive) {
        showNotification('Word concatenation search is already running', 'warning');
        return;
    }
    
    // Show input section
    wordConcatInputSection.style.display = 'block';
    textStringInputField.focus();
    
    logOperation('Started word concatenation substring search operation', 'info');
}

// NEW: Run Word Concatenation Search Handler
function handleRunWordConcatSearch() {
    const inputTextString = textStringInputField.value.trim();
    const wordsInputText = searchWordsInputField.value.trim();
    
    if (inputTextString === '') {
        showNotification('Please enter a text string', 'danger');
        textStringInputField.focus();
        return;
    }
    
    if (wordsInputText === '') {
        showNotification('Please enter search words', 'danger');
        searchWordsInputField.focus();
        return;
    }
    
    const searchWordsArray = wordsInputText.split(',').map(word => word.trim()).filter(word => word !== '');
    
    if (searchWordsArray.length === 0) {
        showNotification('Please enter valid words separated by commas', 'danger');
        searchWordsInputField.focus();
        return;
    }
    
    // Check if all words have same length
    const firstWordLength = searchWordsArray[0].length;
    if (!searchWordsArray.every(word => word.length === firstWordLength)) {
        showNotification('All search words must have the same length', 'danger');
        searchWordsInputField.focus();
        return;
    }
    
    // Store original array
    originalArrayBeforeWordConcat = [...myArray];
    
    // Hide input section
    wordConcatInputSection.style.display = 'none';
    
    // Start word concatenation visualization
    showWordConcatVisualization(inputTextString, searchWordsArray);
}

// NEW: Stop Word Concatenation Search Handler
function handleStopWordConcatSearch() {
    wordConcatInputSection.style.display = 'none';
    textStringInputField.value = '';
    searchWordsInputField.value = '';
    
    logOperation('Cancelled word concatenation search operation', 'info');
    showNotification('Word concatenation search cancelled', 'info');
}
// NEW: Show Word Concatenation Visualization
function showWordConcatVisualization(textString, wordsArray) {
    isWordConcatSearchActive = true;
    
    const visualizationContainer = document.createElement('div');
    visualizationContainer.className = 'dual-operation-container';
    visualizationContainer.innerHTML = `
        <h5 class="text-center mb-3">Substring with Concatenation of All Words</h5>
        
        <div class="array-group">
            <div class="array-label">Input Text String (Length: ${textString.length})</div>
            <div class="original-array-container" id="textStringVisualization"></div>
        </div>
        
        <div class="array-group">
            <div class="array-label">Search Words (${wordsArray.length} words)</div>
            <div class="original-array-container" id="wordsArrayVisualization"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Found Starting Positions</div>
            <div class="transformed-array-container" id="concatResultsVisualization"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find starting indices where substring contains all words in any order</p>
            <p class="mb-0" id="wordConcatAlgorithmExplanation">Initializing word concatenation search algorithm...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="wordConcatStepsArea">
            <h6 class="text-center">Algorithm Execution Steps</h6>
            <div class="steps-container" id="wordConcatStepsContainer"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Found Starting Indices</div>
            <div class="stats-value" id="foundPositionsDisplay">[]</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>Total Valid Substrings</div>
            <div class="stats-value" id="totalSubstringsCount">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="finishWordConcatBtn" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(visualizationContainer);
    
    // Display the input text as individual characters
    renderTextAsCharacterGrid(textString, 'textStringVisualization');
    
    // Display words
    renderArrayInContainer(wordsArray, 'wordsArrayVisualization');
    
    // Initialize results display
    renderArrayInContainer([], 'concatResultsVisualization');
    
    // Start algorithm animation
    executeWordConcatAlgorithm(textString, wordsArray);
}

// NEW: Render Text as Character Grid for visualization
function renderTextAsCharacterGrid(text, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    for (let i = 0; i < text.length; i++) {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value">${text[i]}</div>
            <div class="element-index">${i}</div>
        `;
        container.appendChild(arrayElement);
    }
}
// NEW: Execute Word Concatenation Algorithm
function executeWordConcatAlgorithm(sourceText, targetWords) {
    const textContainer = document.getElementById('textStringVisualization');
    const resultsContainer = document.getElementById('concatResultsVisualization');
    const explanation = document.getElementById('wordConcatAlgorithmExplanation');
    const stepsContainer = document.getElementById('wordConcatStepsContainer');
    const foundPositionsDisplay = document.getElementById('foundPositionsDisplay');
    const totalSubstringsCount = document.getElementById('totalSubstringsCount');
    const finishButton = document.getElementById('finishWordConcatBtn');
    
    const singleWordLength = targetWords[0].length;
    const totalWordsCount = targetWords.length;
    const concatenationLength = singleWordLength * totalWordsCount;
    const wordFrequencyMap = new Map();
    const foundStartPositions = [];
    
    // Initialize word frequency counter
    targetWords.forEach(word => {
        wordFrequencyMap.set(word, (wordFrequencyMap.get(word) || 0) + 1);
    });
    
    let algorithmStep = 0;
    let currentSearchPosition = 0;
    
    function processSearchWindow(windowStart) {
        if (windowStart > sourceText.length - concatenationLength) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Algorithm Completed!</strong> Found ${foundStartPositions.length} valid starting positions.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final Result:</strong> Valid starting indices: [${foundStartPositions.join(', ')}]
                </div>
            `;
            
            // Display results
            renderArrayInContainer(foundStartPositions.map(pos => `Position ${pos}`), 'concatResultsVisualization');
            
            // Highlight found positions in the text
            const textElements = textContainer.querySelectorAll('.array-element');
            foundStartPositions.forEach((position, index) => {
                setTimeout(() => {
                    for (let j = position; j < position + concatenationLength; j++) {
                        if (j < textElements.length) {
                            textElements[j].querySelector('.element-value').classList.add('success-color');
                        }
                    }
                }, index * 300);
            });
            
            foundPositionsDisplay.textContent = `[${foundStartPositions.join(', ')}]`;
            totalSubstringsCount.textContent = foundStartPositions.length;
            finishButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                resetAfterWordConcatSearch();
            }, 10000);
            
            finishButton.addEventListener('click', resetAfterWordConcatSearch);
            
            return;
        }
        
        algorithmStep++;
        currentSearchPosition = windowStart;
        
        explanation.innerHTML = `Examining window starting at position ${windowStart}: "${sourceText.substring(windowStart, windowStart + Math.min(10, sourceText.length - windowStart))}..."`;
        
        // Highlight current window in the text
        const textElements = textContainer.querySelectorAll('.array-element');
        
        // Remove previous highlights
        textElements.forEach(el => {
            el.querySelector('.element-value').classList.remove('window-current', 'window-checking', 'success-color', 'danger-color', 'info-color');
        });
        
        // Highlight current search window
        for (let j = windowStart; j < windowStart + concatenationLength && j < sourceText.length; j++) {
            textElements[j].querySelector('.element-value').classList.add('window-current');
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${algorithmStep}:</strong> Checking window starting at position ${windowStart}
            </div>
        `;
        
        // Scroll to bottom of steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            const currentWordCounts = new Map();
            let isWindowValid = true;
            let wordValidationStep = 0;
            
            function validateCurrentWord(wordIndex) {
                if (wordIndex >= totalWordsCount) {
                    // All words matched successfully
                    foundStartPositions.push(windowStart);
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${algorithmStep}.${wordValidationStep}:</strong>  Valid word concatenation found at position ${windowStart}!
                        </div>
                    `;
                    
                    // Highlight the valid window
                    for (let k = windowStart; k < windowStart + concatenationLength; k++) {
                        textElements[k].querySelector('.element-value').classList.remove('window-current');
                        textElements[k].querySelector('.element-value').classList.add('success-color');
                    }
                    
                    foundPositionsDisplay.textContent = `[${foundStartPositions.join(', ')}]`;
                    totalSubstringsCount.textContent = foundStartPositions.length;
                    
                    // Move to next search position
                    setTimeout(() => {
                        processSearchWindow(windowStart + 1);
                    }, 2000);
                    
                    return;
                }
                
                wordValidationStep++;
                const currentWordStart = windowStart + wordIndex * singleWordLength;
                const extractedWord = sourceText.substring(currentWordStart, currentWordStart + singleWordLength);
                
                // Highlight current word being validated
                for (let k = currentWordStart; k < currentWordStart + singleWordLength; k++) {
                    textElements[k].querySelector('.element-value').classList.add('window-checking');
                }
                
                explanation.innerHTML = `Validating word at positions ${currentWordStart}-${currentWordStart + singleWordLength - 1}: "${extractedWord}"`;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step ${algorithmStep}.${wordValidationStep}:</strong> Checking word "${extractedWord}" at position ${currentWordStart}
                    </div>
                `;
                
                // Scroll to bottom
                stepsContainer.scrollTop = stepsContainer.scrollHeight;
                
                setTimeout(() => {
                    if (!wordFrequencyMap.has(extractedWord)) {
                        // Invalid word - not in our target words
                        stepsContainer.innerHTML += `
                            <div class="algorithm-step active">
                                <strong>Step ${algorithmStep}.${wordValidationStep}:</strong>  "${extractedWord}" not in target word list
                            </div>
                        `;
                        
                        // Highlight invalid word
                        for (let k = currentWordStart; k < currentWordStart + singleWordLength; k++) {
                            textElements[k].querySelector('.element-value').classList.remove('window-checking');
                            textElements[k].querySelector('.element-value').classList.add('danger-color');
                        }
                        
                        isWindowValid = false;
                    } else {
                        currentWordCounts.set(extractedWord, (currentWordCounts.get(extractedWord) || 0) + 1);
                        
                        if (currentWordCounts.get(extractedWord) > wordFrequencyMap.get(extractedWord)) {
                            // Too many occurrences of this word
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step active">
                                    <strong>Step ${algorithmStep}.${wordValidationStep}:</strong>  Too many "${extractedWord}" (${currentWordCounts.get(extractedWord)} > ${wordFrequencyMap.get(extractedWord)})
                                </div>
                            `;
                            
                            isWindowValid = false;
                        } else {
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step">
                                    <strong>Step ${algorithmStep}.${wordValidationStep}:</strong>  "${extractedWord}" validated (${currentWordCounts.get(extractedWord)}/${wordFrequencyMap.get(extractedWord)})
                                </div>
                            `;
                        }
                    }
                    
                    // Remove temporary highlights
                    for (let k = currentWordStart; k < currentWordStart + singleWordLength; k++) {
                        textElements[k].querySelector('.element-value').classList.remove('window-checking');
                        if (isWindowValid) {
                            textElements[k].querySelector('.element-value').classList.add('info-color');
                        }
                    }
                    
                    if (!isWindowValid) {
                        // Invalid window found, move to next search position
                        setTimeout(() => {
                            processSearchWindow(windowStart + 1);
                        }, 1500);
                    } else {
                        // Validate next word in current window
                        setTimeout(() => {
                            validateCurrentWord(wordIndex + 1);
                        }, 1000);
                    }
                }, 1500);
            }
            
            // Start validating words in current window
            validateCurrentWord(0);
            
        }, 1500);
    }
    
    // Start algorithm execution from first position
    processSearchWindow(0);
}
// NEW: Reset after Word Concatenation Search
function resetAfterWordConcatSearch() {
    // Reset to original array
    myArray = [...originalArrayBeforeWordConcat];
    originalArrayBeforeWordConcat = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isWordConcatSearchActive = false;
    
    // Clear input fields
    textStringInputField.value = '';
    searchWordsInputField.value = '';
    
    logOperation('Word concatenation search completed - returned to original array', 'info');
    showNotification('Returned to original array after word concatenation search', 'success');
}
// NEW: Count Smaller Numbers After Self Handler
function handleCountSmallerAfterSelf() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isSmallerCountRunning) {
        showNotification('Count operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('This operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isSmallerCountRunning = true;
    
    // Store original array
    originalArrayForSmallerCount = [...myArray];
    
    // Show smaller count visualization
    showSmallerCountVisualization();
}
// NEW: Show Smaller Count Visualization
function showSmallerCountVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Count of Smaller Numbers After Self</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalSmallerCountArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Counting Process</div>
            <div class="transformed-array-container" id="transformedSmallerCountArray"></div>
        </div>
        
        <!-- Results Table positioned below the counting process array -->
        <div class="array-group">
            <div class="array-label">Results Table</div>
            <div class="smaller-count-results-container">
                <div id="smallerCountResultsTable">
                    <p class="text-center text-muted">Results will appear here as the algorithm progresses...</p>
                </div>
            </div>
        </div>
        
        <div class="algorithm-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> For each element, count how many elements to the right are smaller</p>
            <p class="mb-0" id="smallerCountExplanation">Initializing count operation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="smallerCountStepsContainer">
            <h6 class="text-center">Counting Steps</h6>
            <div class="steps-container" id="smallerCountSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSmallerCount" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSmallerCount, 'originalSmallerCountArray');
    renderArrayInContainer([...originalArrayForSmallerCount], 'transformedSmallerCountArray');
    
    performSmallerCountAnimation();
}

// NEW: Perform Smaller Count Animation
function performSmallerCountAnimation() {
    const originalContainer = document.getElementById('originalSmallerCountArray');
    const transformedContainer = document.getElementById('transformedSmallerCountArray');
    const explanation = document.getElementById('smallerCountExplanation');
    const stepsContainer = document.getElementById('smallerCountSteps');
    const resultsTable = document.getElementById('smallerCountResultsTable');
    const continueButton = document.getElementById('continueAfterSmallerCount');
    
    const arr = originalArrayForSmallerCount.map(val => parseFloat(val));
    const n = arr.length;
    const result = new Array(n).fill(0);
    let currentIndex = 0;
    let step = 0;
    
    // Initialize results table
    initializeResultsTable(arr, result);
    
    function performCountStep() {
        if (currentIndex >= n) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Counting Completed!</strong> All elements processed.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Counting completed for all elements
                </div>
            `;
            
            // Update final results table
            updateResultsTable(arr, result);
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterSmallerCount();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSmallerCount);
            
            return;
        }
        
        step++;
        explanation.innerHTML = `Processing element at index ${currentIndex}: ${arr[currentIndex]}`;
        
        // Highlight current element
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        const currentElement = transformedElements[currentIndex].querySelector('.element-value');
        currentElement.classList.add('smaller-count-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> Processing element [${currentIndex}] = ${arr[currentIndex]}
            </div>
        `;
        
        let count = 0;
        let comparisonStep = 0;
        
        function performComparison(j) {
            if (j >= n) {
                // All comparisons completed for current element
                result[currentIndex] = count;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}.${comparisonStep}:</strong> Total smaller elements after [${currentIndex}] = ${count}
                    </div>
                `;
                
                // Highlight the result
                currentElement.classList.remove('smaller-count-current');
                currentElement.classList.add('smaller-count-result');
                currentElement.textContent = `${arr[currentIndex]} (${count})`;
                
                // Update results table for this element
                updateResultsTableRow(currentIndex, arr, result);
                
                // Move to next element
                currentIndex++;
                setTimeout(performCountStep, 1000);
                return;
            }
            
            comparisonStep++;
            
            if (j <= currentIndex) {
                // Skip elements before or at current index
                performComparison(j + 1);
                return;
            }
            
            explanation.innerHTML = `Comparing [${currentIndex}]=${arr[currentIndex]} with [${j}]=${arr[j]}`;
            
            // Highlight compared element
            const comparedElement = transformedElements[j].querySelector('.element-value');
            comparedElement.classList.add('smaller-count-compared');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Step ${step}.${comparisonStep}:</strong> Compare [${currentIndex}]=${arr[currentIndex]} with [${j}]=${arr[j]}
                </div>
            `;
            
            setTimeout(() => {
                if (arr[j] < arr[currentIndex]) {
                    // Found a smaller element
                    count++;
                    comparedElement.classList.remove('smaller-count-compared');
                    comparedElement.classList.add('smaller-count-smaller');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step ${step}.${comparisonStep}:</strong> [${j}]=${arr[j]} is SMALLER than [${currentIndex}]=${arr[currentIndex]} - Count: ${count}
                        </div>
                    `;
                    
                    setTimeout(() => {
                        comparedElement.classList.remove('smaller-count-smaller');
                        performComparison(j + 1);
                    }, 1000);
                } else {
                    // Element is not smaller
                    comparedElement.classList.remove('smaller-count-compared');
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step ${step}.${comparisonStep}:</strong> [${j}]=${arr[j]} is NOT smaller than [${currentIndex}]=${arr[currentIndex]} - Count: ${count}
                        </div>
                    `;
                    
                    performComparison(j + 1);
                }
            }, 1000);
        }
        
        // Start comparisons for current element
        setTimeout(() => {
            performComparison(currentIndex + 1);
        }, 1000);
    }
    
    // Start counting process
    performCountStep();
}

// NEW: Initialize Results Table
function initializeResultsTable(arr, result) {
    const resultsTable = document.getElementById('smallerCountResultsTable');
    
    let tableHTML = `
        <table class="smaller-count-table">
            <thead>
                <tr>
                    <th>Index</th>
                    <th>Element Value</th>
                    <th>Count of Smaller Numbers After Self</th>
                </tr>
            </thead>
            <tbody>
    `;
    
    for (let i = 0; i < arr.length; i++) {
        tableHTML += `
            <tr id="resultRow-${i}">
                <td>[${i}]</td>
                <td>${arr[i]}</td>
                <td id="resultCount-${i}">-</td>
            </tr>
        `;
    }
    
    tableHTML += `
            </tbody>
        </table>
    `;
    
    resultsTable.innerHTML = tableHTML;
}

// NEW: Update Results Table Row
function updateResultsTableRow(index, arr, result) {
    const resultCountCell = document.getElementById(`resultCount-${index}`);
    const resultRow = document.getElementById(`resultRow-${index}`);
    
    if (resultCountCell && resultRow) {
        resultCountCell.textContent = result[index];
        resultCountCell.classList.add('stats-value');
        resultRow.style.background = 'rgba(0, 184, 148, 0.1)';
        
        // Add animation effect
        setTimeout(() => {
            resultCountCell.classList.add('pulse');
            setTimeout(() => {
                resultCountCell.classList.remove('pulse');
            }, 500);
        }, 100);
    }
}

// NEW: Update Complete Results Table
function updateResultsTable(arr, result) {
    const resultsTable = document.getElementById('smallerCountResultsTable');
    
    let tableHTML = `
        <table class="smaller-count-table">
            <thead>
                <tr>
                    <th>Index</th>
                    <th>Element Value</th>
                    <th>Count of Smaller Numbers After Self</th>
                </tr>
            </thead>
            <tbody>
    `;
    
    for (let i = 0; i < arr.length; i++) {
        tableHTML += `
            <tr style="background: rgba(0, 184, 148, 0.1);">
                <td>[${i}]</td>
                <td>${arr[i]}</td>
                <td class="stats-value">${result[i]}</td>
            </tr>
        `;
    }
    
    tableHTML += `
            </tbody>
        </table>
        <div class="text-center mt-3">
            <small class="text-success">
                <i class="fas fa-check-circle me-1"></i>
                All counts calculated successfully!
            </small>
        </div>
    `;
    
    resultsTable.innerHTML = tableHTML;
}

// NEW: Return to Original after Smaller Count
function returnToOriginalAfterSmallerCount() {
    // Reset to original array
    myArray = [...originalArrayForSmallerCount];
    originalArrayForSmallerCount = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isSmallerCountRunning = false;
    
    logOperation('Count of smaller numbers after self completed - returned to original array', 'info');
    showNotification('Returned to original array after count operation', 'success');
}
// NEW: Check Ugly Number Handler
function handleCheckUglyNumber() {
    const num = parseInt(uglyNumberInput.value);
    
    if (isNaN(num) || num < 1) {
        showNotification('Please enter a valid positive number', 'danger');
        uglyNumberInput.focus();
        return;
    }
    
    if (isUglyNumberOperationRunning) {
        showNotification('An ugly number operation is already in progress', 'warning');
        return;
    }
    
    isUglyNumberOperationRunning = true;
    
    // Show visualization
    showUglyNumberCheckVisualization(num);
}

// NEW: Find Nth Ugly Number Handler
function handleFindNthUglyNumber() {
    const n = parseInt(nthUglyNumberInput.value);
    
    if (isNaN(n) || n < 1 || n > 100) {
        showNotification('Please enter a valid n between 1 and 100', 'danger');
        nthUglyNumberInput.focus();
        return;
    }
    
    if (isUglyNumberOperationRunning) {
        showNotification('An ugly number operation is already in progress', 'warning');
        return;
    }
    
    isUglyNumberOperationRunning = true;
    
    // Show visualization
    showNthUglyNumberVisualization(n);
}

// NEW: Find Super Ugly Number Handler
function handleFindSuperUglyNumber() {
    const n = parseInt(superUglyNInput.value);
    const primesInput = superUglyPrimesInput.value.trim();
    
    if (isNaN(n) || n < 1 || n > 50) {
        showNotification('Please enter a valid n between 1 and 50', 'danger');
        superUglyNInput.focus();
        return;
    }
    
    if (primesInput === '') {
        showNotification('Please enter prime numbers separated by commas', 'danger');
        superUglyPrimesInput.focus();
        return;
    }
    
    // Parse primes
    const primes = primesInput.split(',').map(p => parseInt(p.trim())).filter(p => !isNaN(p) && p > 1);
    
    if (primes.length === 0) {
        showNotification('Please enter valid prime numbers (e.g., 2,3,5,7)', 'danger');
        superUglyPrimesInput.focus();
        return;
    }
    
    if (isUglyNumberOperationRunning) {
        showNotification('An ugly number operation is already in progress', 'warning');
        return;
    }
    
    isUglyNumberOperationRunning = true;
    
    // Show visualization
    showSuperUglyNumberVisualization(n, primes);
}

// NEW: Show Ugly Number Check Visualization
function showUglyNumberCheckVisualization(num) {
    const visualizationContainer = document.createElement('div');
    visualizationContainer.className = 'dual-operation-container';
    visualizationContainer.innerHTML = `
        <h5 class="text-center mb-3">Checking Ugly Number: ${num}</h5>
        
        <div class="array-group">
            <div class="array-label">Prime Factorization Process</div>
            <div class="original-array-container" id="factorizationProcess"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Ugly Number Check:</strong> Keep dividing by 2, 3, 5 until we reach 1</p>
            <p class="mb-0" id="uglyCheckExplanation">Starting factorization process...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="uglyCheckStepsContainer">
            <h6 class="text-center">Factorization Steps</h6>
            <div class="steps-container" id="uglyCheckSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Final Result</div>
            <div class="stats-value" id="uglyCheckResult">Processing...</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterUglyCheck" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Operations
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(visualizationContainer);
    
    performUglyNumberCheckAnimation(num);
}

// NEW: Perform Ugly Number Check Animation
function performUglyNumberCheckAnimation(num) {
    const processContainer = document.getElementById('factorizationProcess');
    const explanation = document.getElementById('uglyCheckExplanation');
    const stepsContainer = document.getElementById('uglyCheckSteps');
    const resultDiv = document.getElementById('uglyCheckResult');
    const continueButton = document.getElementById('continueAfterUglyCheck');
    
    let currentNumber = num;
    let step = 0;
    const primes = [2, 3, 5];
    
    function performFactorizationStep() {
        if (currentNumber === 1) {
            // Success - number is ugly
            explanation.innerHTML = `<strong>Success!</strong> Number reduced to 1 - it's an Ugly Number!`;
            resultDiv.innerHTML = `<span class="text-success">${num} is an Ugly Number</span>`;
            resultDiv.classList.add('success-color');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Number reduced to 1 -  UGLY NUMBER
                </div>
            `;
            
            showCompletion();
            return;
        }
        
        if (currentNumber < 1) {
            // Invalid case
            explanation.innerHTML = `<strong>Invalid:</strong> Number became less than 1`;
            resultDiv.innerHTML = `<span class="text-danger">${num} is NOT an Ugly Number</span>`;
            resultDiv.classList.add('danger-color');
            showCompletion();
            return;
        }
        
        step++;
        let divisible = false;
        
        // Check divisibility by each prime
        for (let i = 0; i < primes.length; i++) {
            const prime = primes[i];
            if (currentNumber % prime === 0) {
                divisible = true;
                const oldNumber = currentNumber;
                currentNumber = currentNumber / prime;
                
                explanation.innerHTML = `Step ${step}: ${oldNumber}  ${prime} = ${currentNumber}`;
                
                // Display current state
                const stepDiv = document.createElement('div');
                stepDiv.className = 'array-element';
                stepDiv.innerHTML = `
                    <div class="element-value warning-color">
                        ${oldNumber}  ${prime}
                    </div>
                    <div class="element-index">Step ${step}</div>
                `;
                processContainer.appendChild(stepDiv);
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step ${step}:</strong> ${oldNumber}  ${prime} = ${currentNumber}
                    </div>
                `;
                
                // Scroll to bottom
                stepsContainer.scrollTop = stepsContainer.scrollHeight;
                
                // Animate the step
                setTimeout(() => {
                    stepDiv.querySelector('.element-value').classList.add('pulse');
                    setTimeout(() => {
                        performFactorizationStep();
                    }, 1000);
                }, 500);
                
                break;
            }
        }
        
        if (!divisible) {
            // Not divisible by any ugly prime - not an ugly number
            explanation.innerHTML = `<strong>Failed!</strong> ${currentNumber} is not divisible by 2, 3, or 5`;
            resultDiv.innerHTML = `<span class="text-danger">${num} is NOT an Ugly Number</span>`;
            resultDiv.classList.add('danger-color');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Final:</strong> Stuck at ${currentNumber} -  NOT UGLY NUMBER
                </div>
            `;
            
            showCompletion();
        }
    }
    
    function showCompletion() {
        continueButton.style.display = 'block';
        
        // Auto-return after 5 seconds
        setTimeout(() => {
            returnToOperationsAfterUglyCheck();
        }, 5000);
        
        continueButton.addEventListener('click', returnToOperationsAfterUglyCheck);
    }
    
    // Start the process
    performFactorizationStep();
}

// NEW: Show Nth Ugly Number Visualization
function showNthUglyNumberVisualization(n) {
    const visualizationContainer = document.createElement('div');
    visualizationContainer.className = 'dual-operation-container';
    visualizationContainer.innerHTML = `
        <h5 class="text-center mb-3">Finding ${getOrdinal(n)} Ugly Number</h5>
        
        <div class="array-group">
            <div class="array-label">Ugly Numbers Sequence</div>
            <div class="original-array-container" id="uglySequenceContainer"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Dynamic Programming Approach:</strong> Generate ugly numbers using three pointers</p>
            <p class="mb-0" id="nthUglyExplanation">Initializing sequence generation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="nthUglyStepsContainer">
            <h6 class="text-center">Generation Steps</h6>
            <div class="steps-container" id="nthUglySteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Pointers Status</div>
            <div class="stats-value" id="pointersStatus">i2=0, i3=0, i5=0</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>${getOrdinal(n)} Ugly Number</div>
            <div class="stats-value" id="nthUglyResult">Processing...</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterNthUgly" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Operations
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(visualizationContainer);
    
    performNthUglyNumberAnimation(n);
}

// NEW: Perform Nth Ugly Number Animation
function performNthUglyNumberAnimation(n) {
    const sequenceContainer = document.getElementById('uglySequenceContainer');
    const explanation = document.getElementById('nthUglyExplanation');
    const stepsContainer = document.getElementById('nthUglySteps');
    const pointersStatus = document.getElementById('pointersStatus');
    const resultDiv = document.getElementById('nthUglyResult');
    const continueButton = document.getElementById('continueAfterNthUgly');
    
    const ugly = [1];
    let i2 = 0, i3 = 0, i5 = 0;
    let step = 0;
    
    // Display initial state
    renderUglySequence(ugly, sequenceContainer, i2, i3, i5);
    
    function generateNextUglyNumber() {
        if (ugly.length >= n) {
            // Generation completed
            const result = ugly[n - 1];
            explanation.innerHTML = `<strong>Generation Completed!</strong> ${getOrdinal(n)} Ugly Number found.`;
            resultDiv.innerHTML = `<span class="text-success">${result}</span>`;
            resultDiv.classList.add('success-color');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> ${getOrdinal(n)} Ugly Number = ${result}
                </div>
            `;
            
            showCompletion();
            return;
        }
        
        step++;
        const next2 = ugly[i2] * 2;
        const next3 = ugly[i3] * 3;
        const next5 = ugly[i5] * 5;
        const nextUgly = Math.min(next2, next3, next5);
        
        explanation.innerHTML = `Step ${step}: min(${next2}, ${next3}, ${next5}) = ${nextUgly}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> min(ugly[${i2}]2=${next2}, ugly[${i3}]3=${next3}, ugly[${i5}]5=${next5}) = ${nextUgly}
            </div>
        `;
        
        // Add to sequence
        ugly.push(nextUgly);
        
        // Update pointers
        if (nextUgly === next2) i2++;
        if (nextUgly === next3) i3++;
        if (nextUgly === next5) i5++;
        
        pointersStatus.textContent = `i2=${i2}, i3=${i3}, i5=${i5}`;
        
        // Update visualization
        setTimeout(() => {
            renderUglySequence(ugly, sequenceContainer, i2, i3, i5);
            
            // Highlight the new number
            const newElement = sequenceContainer.lastChild;
            if (newElement) {
                newElement.querySelector('.element-value').classList.add('create', 'bounce');
            }
            
            // Continue generation
            setTimeout(() => {
                generateNextUglyNumber();
            }, 1500);
        }, 1000);
    }
    
    function showCompletion() {
        continueButton.style.display = 'block';
        
        // Auto-return after 5 seconds
        setTimeout(() => {
            returnToOperationsAfterUglyCheck();
        }, 5000);
        
        continueButton.addEventListener('click', returnToOperationsAfterUglyCheck);
    }
    
    // Start generation
    generateNextUglyNumber();
}

// NEW: Show Super Ugly Number Visualization
function showSuperUglyNumberVisualization(n, primes) {
    const visualizationContainer = document.createElement('div');
    visualizationContainer.className = 'dual-operation-container';
    visualizationContainer.innerHTML = `
        <h5 class="text-center mb-3">Finding ${getOrdinal(n)} Super Ugly Number</h5>
        
        <div class="array-group">
            <div class="array-label">Super Ugly Numbers Sequence</div>
            <div class="original-array-container" id="superUglySequenceContainer"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Super Ugly Numbers:</strong> Using primes [${primes.join(', ')}]</p>
            <p class="mb-0" id="superUglyExplanation">Initializing sequence generation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="superUglyStepsContainer">
            <h6 class="text-center">Generation Steps</h6>
            <div class="steps-container" id="superUglySteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Pointers Status</div>
            <div class="stats-value" id="superPointersStatus">${primes.map((_, i) => `i${i}=0`).join(', ')}</div>
        </div>
        
        <div class="stats-card mt-2">
            <div>${getOrdinal(n)} Super Ugly Number</div>
            <div class="stats-value" id="superUglyResult">Processing...</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterSuperUgly" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Operations
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(visualizationContainer);
    
    performSuperUglyNumberAnimation(n, primes);
}

// NEW: Perform Super Ugly Number Animation
function performSuperUglyNumberAnimation(n, primes) {
    const sequenceContainer = document.getElementById('superUglySequenceContainer');
    const explanation = document.getElementById('superUglyExplanation');
    const stepsContainer = document.getElementById('superUglySteps');
    const pointersStatus = document.getElementById('superPointersStatus');
    const resultDiv = document.getElementById('superUglyResult');
    const continueButton = document.getElementById('continueAfterSuperUgly');
    
    const ugly = [1];
    const indices = Array(primes.length).fill(0);
    let step = 0;
    
    // Display initial state
    renderSuperUglySequence(ugly, sequenceContainer, indices, primes);
    
    function generateNextSuperUglyNumber() {
        if (ugly.length >= n) {
            // Generation completed
            const result = ugly[n - 1];
            explanation.innerHTML = `<strong>Generation Completed!</strong> ${getOrdinal(n)} Super Ugly Number found.`;
            resultDiv.innerHTML = `<span class="text-success">${result}</span>`;
            resultDiv.classList.add('success-color');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> ${getOrdinal(n)} Super Ugly Number = ${result}
                </div>
            `;
            
            showCompletion();
            return;
        }
        
        step++;
        
        // Calculate next candidates
        const candidates = primes.map((p, j) => ugly[indices[j]] * p);
        const nextUgly = Math.min(...candidates);
        
        explanation.innerHTML = `Step ${step}: min(${candidates.join(', ')}) = ${nextUgly}`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${step}:</strong> min(${candidates.map((c, j) => `ugly[${indices[j]}]${primes[j]}=${c}`).join(', ')}) = ${nextUgly}
            </div>
        `;
        
        // Add to sequence
        ugly.push(nextUgly);
        
        // Update pointers
        primes.forEach((p, j) => {
            if (nextUgly === ugly[indices[j]] * p) {
                indices[j]++;
            }
        });
        
        pointersStatus.textContent = indices.map((idx, j) => `i${j}=${idx}`).join(', ');
        
        // Update visualization
        setTimeout(() => {
            renderSuperUglySequence(ugly, sequenceContainer, indices, primes);
            
            // Highlight the new number
            const newElement = sequenceContainer.lastChild;
            if (newElement) {
                newElement.querySelector('.element-value').classList.add('create', 'bounce');
            }
            
            // Continue generation
            setTimeout(() => {
                generateNextSuperUglyNumber();
            }, 1500);
        }, 1000);
    }
    
    function showCompletion() {
        continueButton.style.display = 'block';
        
        // Auto-return after 5 seconds
        setTimeout(() => {
            returnToOperationsAfterUglyCheck();
        }, 5000);
        
        continueButton.addEventListener('click', returnToOperationsAfterUglyCheck);
    }
    
    // Start generation
    generateNextSuperUglyNumber();
}

// NEW: Helper function to render ugly sequence
function renderUglySequence(ugly, container, i2, i3, i5) {
    container.innerHTML = '';
    
    ugly.forEach((num, index) => {
        const element = document.createElement('div');
        element.className = 'array-element';
        
        let specialClass = '';
        if (index === i2) specialClass = 'two-pointer-left';
        else if (index === i3) specialClass = 'two-pointer-right';
        else if (index === i5) specialClass = 'info-color';
        
        element.innerHTML = `
            <div class="element-value ${specialClass}">
                ${num}
            </div>
            <div class="element-index">[${index}]</div>
        `;
        
        container.appendChild(element);
    });
}

// NEW: Helper function to render super ugly sequence
function renderSuperUglySequence(ugly, container, indices, primes) {
    container.innerHTML = '';
    
    ugly.forEach((num, index) => {
        const element = document.createElement('div');
        element.className = 'array-element';
        
        // Find if this index is a pointer for any prime
        let pointerIndex = indices.indexOf(index);
        let specialClass = pointerIndex !== -1 ? `window-included` : '';
        
        element.innerHTML = `
            <div class="element-value ${specialClass}">
                ${num}
            </div>
            <div class="element-index">[${index}]</div>
        `;
        
        if (pointerIndex !== -1) {
            const pointerLabel = document.createElement('div');
            pointerLabel.className = 'element-pointer';
            pointerLabel.textContent = `${primes[pointerIndex]}`;
            pointerLabel.style.fontSize = '0.7rem';
            pointerLabel.style.color = 'var(--warning-color)';
            element.appendChild(pointerLabel);
        }
        
        container.appendChild(element);
    });
}

// NEW: Helper function to get ordinal number
function getOrdinal(n) {
    const suffixes = ['th', 'st', 'nd', 'rd'];
    const value = n % 100;
    return n + (suffixes[(value - 20) % 10] || suffixes[value] || suffixes[0]);
}

// NEW: Return to operations after ugly number check
function returnToOperationsAfterUglyCheck() {
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isUglyNumberOperationRunning = false;
    
    // Clear inputs
    uglyNumberInput.value = '';
    nthUglyNumberInput.value = '';
    superUglyNInput.value = '';
    superUglyPrimesInput.value = '';
    
    logOperation('Ugly number operation completed', 'info');
    showNotification('Returned to normal array view', 'success');
}
// NEW: Find Perfect Numbers Handler
function handleFindPerfectNumbers() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isPerfectNumberRunning) {
        showNotification('Perfect number detection is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseInt(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Perfect number detection requires all array elements to be integers', 'danger');
        return;
    }
    
    isPerfectNumberRunning = true;
    
    // Store original array
    originalArrayForSpecialNumbers = [...myArray];
    
    // Show perfect number visualization
    showPerfectNumberVisualization();
}

// NEW: Find Armstrong Numbers Handler
function handleFindArmstrongNumbers() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isArmstrongNumberRunning) {
        showNotification('Armstrong number detection is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseInt(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Armstrong number detection requires all array elements to be integers', 'danger');
        return;
    }
    
    isArmstrongNumberRunning = true;
    
    // Store original array
    originalArrayForSpecialNumbers = [...myArray];
    
    // Show Armstrong number visualization
    showArmstrongNumberVisualization();
}
// NEW: Show Perfect Number Visualization
function showPerfectNumberVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Perfect Number Detection</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalPerfectArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Perfect Numbers Found</div>
            <div class="transformed-array-container" id="perfectNumbersArray"></div>
        </div>
        
        <div class="perfect-explanation">
            <p class="mb-2"><strong>Perfect Number:</strong> A number that equals the sum of its proper divisors (excluding itself)</p>
            <p class="mb-0" id="perfectExplanation">Starting perfect number detection...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="perfectStepsContainer">
            <h6 class="text-center">Perfect Number Detection Steps</h6>
            <div class="steps-container" id="perfectSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Perfect Numbers Found</div>
            <div class="stats-value" id="perfectCount">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPerfect" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSpecialNumbers, 'originalPerfectArray');
    renderArrayInContainer([], 'perfectNumbersArray');
    
    performPerfectNumberDetection();
}

// NEW: Show Armstrong Number Visualization
function showArmstrongNumberVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Armstrong Number Detection</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalArmstrongArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Armstrong Numbers Found</div>
            <div class="transformed-array-container" id="armstrongNumbersArray"></div>
        </div>
        
        <div class="armstrong-explanation">
            <p class="mb-2"><strong>Armstrong Number:</strong> A number that equals the sum of its own digits each raised to the power of the number of digits</p>
            <p class="mb-0" id="armstrongExplanation">Starting Armstrong number detection...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="armstrongStepsContainer">
            <h6 class="text-center">Armstrong Number Detection Steps</h6>
            <div class="steps-container" id="armstrongSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Armstrong Numbers Found</div>
            <div class="stats-value" id="armstrongCount">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterArmstrong" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForSpecialNumbers, 'originalArmstrongArray');
    renderArrayInContainer([], 'armstrongNumbersArray');
    
    performArmstrongNumberDetection();
}
// NEW: Helper function to check if a number is perfect
function isPerfectNumber(num) {
    if (num <= 1) return false;
    
    let sum = 1; // 1 is always a divisor
    for (let i = 2; i <= Math.sqrt(num); i++) {
        if (num % i === 0) {
            sum += i;
            if (i !== num / i) {
                sum += num / i;
            }
        }
    }
    return sum === num;
}

// NEW: Helper function to check if a number is Armstrong
function isArmstrongNumber(num) {
    const digits = num.toString().split('');
    const power = digits.length;
    const sum = digits.reduce((total, digit) => total + Math.pow(parseInt(digit), power), 0);
    return sum === num;
}

// NEW: Perform Perfect Number Detection with Animation
function performPerfectNumberDetection() {
    const originalContainer = document.getElementById('originalPerfectArray');
    const perfectContainer = document.getElementById('perfectNumbersArray');
    const explanation = document.getElementById('perfectExplanation');
    const stepsContainer = document.getElementById('perfectSteps');
    const perfectCount = document.getElementById('perfectCount');
    const continueButton = document.getElementById('continueAfterPerfect');
    
    const arr = originalArrayForSpecialNumbers.map(val => parseInt(val));
    let perfectNumbers = [];
    let currentIndex = 0;
    
    function checkNextNumber() {
        if (currentIndex >= arr.length) {
            // Detection completed
            explanation.innerHTML = `<strong>Perfect Number Detection Completed!</strong> Found ${perfectNumbers.length} perfect number(s).`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Perfect numbers found: ${perfectNumbers.length > 0 ? perfectNumbers.join(', ') : 'None'}
                </div>
            `;
            
            perfectCount.textContent = perfectNumbers.length;
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterSpecialNumbers();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSpecialNumbers);
            
            return;
        }
        
        const currentNumber = arr[currentIndex];
        explanation.innerHTML = `Checking if ${currentNumber} is a perfect number...`;
        
        // Highlight current number being checked
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentIndex].querySelector('.element-value');
        currentElement.classList.add('checking-perfect');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${currentIndex + 1}:</strong> Checking ${currentNumber} for perfect number property
            </div>
        `;
        
        // Check if perfect number
        setTimeout(() => {
            if (isPerfectNumber(currentNumber)) {
                perfectNumbers.push(currentNumber);
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Found!</strong> ${currentNumber} is a perfect number! 
                        (Sum of proper divisors = ${currentNumber})
                    </div>
                `;
                
                // Highlight as perfect number
                currentElement.classList.remove('checking-perfect');
                currentElement.classList.add('perfect-number');
                
                // Add to perfect numbers array
                renderArrayInContainer(perfectNumbers, 'perfectNumbersArray');
                perfectCount.textContent = perfectNumbers.length;
                
                // Highlight the new perfect number in results
                const perfectElements = perfectContainer.querySelectorAll('.array-element');
                if (perfectElements.length > 0) {
                    const newPerfectElement = perfectElements[perfectElements.length - 1].querySelector('.element-value');
                    newPerfectElement.classList.add('perfect-number', 'bounce');
                }
                
            } else {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Not Perfect:</strong> ${currentNumber} is not a perfect number
                    </div>
                `;
                
                currentElement.classList.remove('checking-perfect');
            }
            
            // Scroll to bottom of steps
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            currentIndex++;
            setTimeout(checkNextNumber, 1500);
        }, 1000);
    }
    
    // Start detection process
    checkNextNumber();
}

// NEW: Perform Armstrong Number Detection with Animation
function performArmstrongNumberDetection() {
    const originalContainer = document.getElementById('originalArmstrongArray');
    const armstrongContainer = document.getElementById('armstrongNumbersArray');
    const explanation = document.getElementById('armstrongExplanation');
    const stepsContainer = document.getElementById('armstrongSteps');
    const armstrongCount = document.getElementById('armstrongCount');
    const continueButton = document.getElementById('continueAfterArmstrong');
    
    const arr = originalArrayForSpecialNumbers.map(val => parseInt(val));
    let armstrongNumbers = [];
    let currentIndex = 0;
    
    function checkNextNumber() {
        if (currentIndex >= arr.length) {
            // Detection completed
            explanation.innerHTML = `<strong>Armstrong Number Detection Completed!</strong> Found ${armstrongNumbers.length} Armstrong number(s).`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Armstrong numbers found: ${armstrongNumbers.length > 0 ? armstrongNumbers.join(', ') : 'None'}
                </div>
            `;
            
            armstrongCount.textContent = armstrongNumbers.length;
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterSpecialNumbers();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterSpecialNumbers);
            
            return;
        }
        
        const currentNumber = arr[currentIndex];
        explanation.innerHTML = `Checking if ${currentNumber} is an Armstrong number...`;
        
        // Highlight current number being checked
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentIndex].querySelector('.element-value');
        currentElement.classList.add('checking-armstrong');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${currentIndex + 1}:</strong> Checking ${currentNumber} for Armstrong number property
            </div>
        `;
        
        // Check if Armstrong number
        setTimeout(() => {
            if (isArmstrongNumber(currentNumber)) {
                armstrongNumbers.push(currentNumber);
                
                const digits = currentNumber.toString().split('');
                const power = digits.length;
                const sum = digits.reduce((total, digit) => total + Math.pow(parseInt(digit), power), 0);
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Found!</strong> ${currentNumber} is an Armstrong number! 
                        (${digits.join('^' + power + ' + ')}^${power} = ${sum})
                    </div>
                `;
                
                // Highlight as Armstrong number
                currentElement.classList.remove('checking-armstrong');
                currentElement.classList.add('armstrong-number');
                
                // Add to Armstrong numbers array
                renderArrayInContainer(armstrongNumbers, 'armstrongNumbersArray');
                armstrongCount.textContent = armstrongNumbers.length;
                
                // Highlight the new Armstrong number in results
                const armstrongElements = armstrongContainer.querySelectorAll('.array-element');
                if (armstrongElements.length > 0) {
                    const newArmstrongElement = armstrongElements[armstrongElements.length - 1].querySelector('.element-value');
                    newArmstrongElement.classList.add('armstrong-number', 'bounce');
                }
                
            } else {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Not Armstrong:</strong> ${currentNumber} is not an Armstrong number
                    </div>
                `;
                
                currentElement.classList.remove('checking-armstrong');
            }
            
            // Scroll to bottom of steps
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            currentIndex++;
            setTimeout(checkNextNumber, 1500);
        }, 1000);
    }
    
    // Start detection process
    checkNextNumber();
}

// NEW: Return to Original after Special Number Detection
function returnToOriginalAfterSpecialNumbers() {
    // Reset to original array
    myArray = [...originalArrayForSpecialNumbers];
    originalArrayForSpecialNumbers = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset states
    isPerfectNumberRunning = false;
    isArmstrongNumberRunning = false;
    
    logOperation('Special number detection completed - returned to original array', 'info');
    showNotification('Returned to original array after special number detection', 'success');
}
// NEW: Pascal's Triangle - Specific Row Handler
function handlePascalSpecificRow() {
    const rowNum = parseInt(pascalRowNumber.value);
    
    if (isNaN(rowNum) || rowNum < 0 || rowNum > 20) {
        showNotification('Please enter a valid row number between 0 and 20', 'danger');
        pascalRowNumber.focus();
        return;
    }
    
    if (isPascalOperationRunning) {
        showNotification('A Pascal operation is already in progress', 'warning');
        return;
    }
    
    isPascalOperationRunning = true;
    
    // Store original array
    originalArrayForPascal = [...myArray];
    
    // Generate and display specific row
    showPascalSpecificRow(rowNum);
}

// NEW: Pascal's Triangle - Multiple Rows Handler
function handlePascalMultipleRows() {
    const numRows = parseInt(pascalNumRows.value);
    
    if (isNaN(numRows) || numRows < 1 || numRows > 10) {
        showNotification('Please enter a valid number of rows between 1 and 10', 'danger');
        pascalNumRows.focus();
        return;
    }
    
    if (isPascalOperationRunning) {
        showNotification('A Pascal operation is already in progress', 'warning');
        return;
    }
    
    isPascalOperationRunning = true;
    
    // Store original array
    originalArrayForPascal = [...myArray];
    
    // Generate and display multiple rows
    showPascalMultipleRows(numRows);
}

// NEW: Show Pascal's Triangle Specific Row
function showPascalSpecificRow(rowNum) {
    const pascalContainer = document.createElement('div');
    pascalContainer.className = 'dual-operation-container';
    pascalContainer.innerHTML = `
        <h5 class="text-center mb-3">Pascal's Triangle - Row ${rowNum}</h5>
        
        <div class="array-group">
            <div class="array-label">Row ${rowNum} of Pascal's Triangle</div>
            <div class="transformed-array-container" id="pascalRowContainer"></div>
        </div>
        
        <div class="pascal-explanation">
            <p class="mb-2"><strong>Pascal's Triangle Row Generation:</strong> Each element is computed using binomial coefficients</p>
            <p class="mb-0" id="pascalExplanation">Generating row ${rowNum}...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="pascalStepsContainer">
            <h6 class="text-center">Row Generation Steps</h6>
            <div class="steps-container" id="pascalSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPascal" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(pascalContainer);
    
    generatePascalRowWithAnimation(rowNum);
}

// NEW: Show Pascal's Triangle Multiple Rows
function showPascalMultipleRows(numRows) {
    const pascalContainer = document.createElement('div');
    pascalContainer.className = 'pascal-triangle-container';
    pascalContainer.innerHTML = `
        <h5 class="text-center mb-3">Pascal's Triangle - First ${numRows} Rows</h5>
        
        <div id="pascalTriangleContainer" class="mb-3"></div>
        
        <div class="pascal-explanation">
            <p class="mb-2"><strong>Pascal's Triangle:</strong> Each number is the sum of the two numbers directly above it</p>
            <p class="mb-0" id="pascalMultiExplanation">Generating ${numRows} rows...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="pascalMultiStepsContainer">
            <h6 class="text-center">Triangle Generation Steps</h6>
            <div class="steps-container" id="pascalMultiSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterPascalMulti" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(pascalContainer);
    
    generatePascalTriangleWithAnimation(numRows);
}

// NEW: Generate Pascal's Triangle Row with Animation
function generatePascalRowWithAnimation(rowNum) {
    const rowContainer = document.getElementById('pascalRowContainer');
    const explanation = document.getElementById('pascalExplanation');
    const stepsContainer = document.getElementById('pascalSteps');
    const continueButton = document.getElementById('continueAfterPascal');
    
    const row = [];
    let currentStep = 0;
    
    function generateStep() {
        if (currentStep > rowNum) {
            // Generation completed
            explanation.innerHTML = `<strong>Row ${rowNum} Generated!</strong> Contains ${row.length} elements.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Row ${rowNum} of Pascal's Triangle: [${row.join(', ')}]
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterPascal();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterPascal);
            
            return;
        }
        
        // Calculate binomial coefficient C(rowNum, currentStep)
        explanation.innerHTML = `Calculating element at position ${currentStep}: C(${rowNum}, ${currentStep})`;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentStep + 1}:</strong> Computing C(${rowNum}, ${currentStep}) = ${rowNum}! / (${currentStep}!  ${rowNum - currentStep}!)
            </div>
        `;
        
        setTimeout(() => {
            // Calculate binomial coefficient
            const value = binomialCoefficient(rowNum, currentStep);
            row.push(value);
            
            // Update row display
            renderPascalRow(row, 'pascalRowContainer');
            
            // Highlight the new element
            const elements = rowContainer.querySelectorAll('.array-element');
            const newElement = elements[currentStep].querySelector('.element-value');
            newElement.classList.add('highlight');
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Result:</strong> C(${rowNum}, ${currentStep}) = ${value}
                </div>
            `;
            
            // Scroll steps container
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            currentStep++;
            generateStep();
        }, 1500);
    }
    
    // Start generation
    generateStep();
}

// NEW: Generate Pascal's Triangle with Animation
function generatePascalTriangleWithAnimation(numRows) {
    const triangleContainer = document.getElementById('pascalTriangleContainer');
    const explanation = document.getElementById('pascalMultiExplanation');
    const stepsContainer = document.getElementById('pascalMultiSteps');
    const continueButton = document.getElementById('continueAfterPascalMulti');
    
    const triangle = [];
    let currentRow = 0;
    
    function generateRow() {
        if (currentRow >= numRows) {
            // Generation completed
            explanation.innerHTML = `<strong>Pascal's Triangle Generated!</strong> ${numRows} rows created.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Pascal's Triangle with ${numRows} rows completed
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 5 seconds
            setTimeout(() => {
                returnToOriginalAfterPascal();
            }, 5000);
            
            continueButton.addEventListener('click', returnToOriginalAfterPascal);
            
            return;
        }
        
        explanation.innerHTML = `Generating row ${currentRow}...`;
        
        const row = [];
        for (let i = 0; i <= currentRow; i++) {
            if (i === 0 || i === currentRow) {
                row.push(1);
            } else {
                row.push(triangle[currentRow - 1][i - 1] + triangle[currentRow - 1][i]);
            }
        }
        
        triangle.push(row);
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Row ${currentRow}:</strong> [${row.join(', ')}]
            </div>
        `;
        
        // Update triangle display
        renderPascalTriangle(triangle);
        
        // Highlight the current row
        const rows = triangleContainer.querySelectorAll('.pascal-row');
        const currentRowElements = rows[currentRow].querySelectorAll('.pascal-element');
        
        currentRowElements.forEach(element => {
            element.classList.add('highlight');
        });
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        currentRow++;
        setTimeout(generateRow, 1000);
    }
    
    // Start generation
    generateRow();
}

// NEW: Render Pascal's Triangle Row
function renderPascalRow(row, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    row.forEach((value, index) => {
        const elementDiv = document.createElement('div');
        elementDiv.className = 'array-element';
        elementDiv.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(elementDiv);
    });
}

// NEW: Render Pascal's Triangle
function renderPascalTriangle(triangle) {
    const container = document.getElementById('pascalTriangleContainer');
    container.innerHTML = '';
    
    triangle.forEach((row, rowIndex) => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'pascal-row';
        
        row.forEach(value => {
            const elementDiv = document.createElement('div');
            elementDiv.className = 'pascal-element';
            elementDiv.textContent = value;
            rowDiv.appendChild(elementDiv);
        });
        
        container.appendChild(rowDiv);
    });
}

// NEW: Binomial Coefficient Calculation
function binomialCoefficient(n, k) {
    if (k < 0 || k > n) return 0;
    if (k === 0 || k === n) return 1;
    
    let result = 1;
    for (let i = 1; i <= k; i++) {
        result = result * (n - i + 1) / i;
    }
    return result;
}

// NEW: Return to Original after Pascal Operations
function returnToOriginalAfterPascal() {
    // Reset to original array
    myArray = [...originalArrayForPascal];
    originalArrayForPascal = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isPascalOperationRunning = false;
    
    // Clear inputs
    pascalRowNumber.value = '';
    pascalNumRows.value = '';
    
    logOperation('Pascal\'s Triangle operation completed - returned to original array', 'info');
    showNotification('Returned to original array after Pascal\'s Triangle operation', 'success');
}
// NEW: Random Pick with Weight Handler
function handleRandomPickWithWeight() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isRandomPickRunning) {
        showNotification('Random pick operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers (weights)
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Random Pick with Weight requires all array elements to be numbers', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForRandomPick = [...myArray];
    
    // Show random pick visualization
    showRandomPickVisualization();
}

// NEW: Show Random Pick Visualization
function showRandomPickVisualization() {
    isRandomPickRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Random Pick with Weight - Cumulative Weights Method</h5>
        
        <div class="array-group">
            <div class="array-label">Original Weights Array</div>
            <div class="original-array-container" id="originalWeightsArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Cumulative Weights Array</div>
            <div class="transformed-array-container" id="cumulativeWeightsArray"></div>
        </div>
        
        <!-- Results Display Section -->
        <div class="results-display mt-4" id="randomPickResults" style="display: none;">
            <div class="row text-center">
                <div class="col-md-4">
                    <div class="stats-card">
                        <div>Random Number Generated</div>
                        <div class="stats-value" id="randomNumberValue">-</div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="stats-card">
                        <div>Selected Index</div>
                        <div class="stats-value" id="selectedIndexValue">-</div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="stats-card">
                        <div>Selected Element Value</div>
                        <div class="stats-value" id="selectedElementValue">-</div>
                    </div>
                </div>
            </div>
            
            <!-- Random Pick Visualization Array -->
            <div class="array-group mt-3">
                <div class="array-label">Random Pick Selection</div>
                <div class="transformed-array-container" id="randomPickArray"></div>
            </div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Random selection based on weights using cumulative distribution</p>
            <p class="mb-0" id="randomPickExplanation">Initializing random pick with weights...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="randomPickStepsContainer">
            <h6 class="text-center">Random Pick Steps</h6>
            <div class="steps-container" id="randomPickSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterRandomPick" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForRandomPick, 'originalWeightsArray');
    renderArrayInContainer([...originalArrayForRandomPick], 'cumulativeWeightsArray');
    
    // Initialize random pick array with weight values (initially normal state)
    renderArrayInContainer(originalArrayForRandomPick, 'randomPickArray');
    
    performRandomPickAnimation();
}

// NEW: Perform Random Pick Animation
function performRandomPickAnimation() {
    const originalContainer = document.getElementById('originalWeightsArray');
    const cumulativeContainer = document.getElementById('cumulativeWeightsArray');
    const randomPickContainer = document.getElementById('randomPickArray');
    const explanation = document.getElementById('randomPickExplanation');
    const stepsContainer = document.getElementById('randomPickSteps');
    const randomNumberValue = document.getElementById('randomNumberValue');
    const selectedElementValue = document.getElementById('selectedElementValue');
    const selectedIndexValue = document.getElementById('selectedIndexValue');
    const resultsDisplay = document.getElementById('randomPickResults');
    const continueButton = document.getElementById('continueAfterRandomPick');
    
    const weights = originalArrayForRandomPick.map(val => parseFloat(val));
    let cumulativeWeights = [];
    let totalWeight = 0;
    let step = 0;
    
    function performRandomPickStep() {
        switch (step) {
            case 0:
                // Step 1: Calculate cumulative weights
                explanation.innerHTML = "Step 1: Calculating cumulative weights...";
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Calculate cumulative weights from original weights
                    </div>
                `;
                
                // Highlight original weights
                const originalElements = originalContainer.querySelectorAll('.array-element');
                originalElements.forEach((el, index) => {
                    setTimeout(() => {
                        el.querySelector('.element-value').classList.add('cumulative-highlight');
                    }, index * 300);
                });
                
                setTimeout(() => {
                    // Calculate cumulative weights
                    cumulativeWeights = [];
                    totalWeight = 0;
                    
                    for (let i = 0; i < weights.length; i++) {
                        totalWeight += weights[i];
                        cumulativeWeights.push(totalWeight);
                    }
                    
                    explanation.innerHTML = `Step 2: Cumulative weights calculated. Total weight = ${totalWeight}`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 2:</strong> Cumulative weights: [${cumulativeWeights.join(', ')}], Total weight = ${totalWeight}
                        </div>
                    `;
                    
                    // Update cumulative weights display
                    renderArrayInContainer(cumulativeWeights.map(w => w.toString()), 'cumulativeWeightsArray');
                    
                    // Highlight cumulative weights
                    const cumulativeElements = cumulativeContainer.querySelectorAll('.array-element');
                    cumulativeElements.forEach((el, index) => {
                        setTimeout(() => {
                            el.querySelector('.element-value').classList.add('prefix-highlight');
                        }, index * 300);
                    });
                    
                    step++;
                    performRandomPickStep();
                }, weights.length * 300 + 1000);
                break;
                
            case 1:
                // Step 3: Generate random number
                explanation.innerHTML = "Step 3: Generating random number between 0 and total weight...";
                
                setTimeout(() => {
                    const randomNum = Math.random() * totalWeight;
                    randomNumberValue.textContent = randomNum.toFixed(2);
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 3:</strong> Generated random number: ${randomNum.toFixed(2)} (range: 0 to ${totalWeight})
                        </div>
                    `;
                    
                    // Show results display
                    resultsDisplay.style.display = 'block';
                    
                    explanation.innerHTML = `Step 4: Finding element where cumulative weight  ${randomNum.toFixed(2)}`;
                    
                    step++;
                    performRandomPickStep();
                }, 1500);
                break;
                
            case 2:
                // Step 4: Find selected element
                const randomNum = parseFloat(randomNumberValue.textContent);
                let selectedIndex = -1;
                
                explanation.innerHTML = `Step 4: Searching for element where cumulative weight  ${randomNum.toFixed(2)}`;
                
                // Linear search visualization
                function findSelectedElement(currentIndex) {
                    if (currentIndex >= cumulativeWeights.length) {
                        // Should not happen if randomNum < totalWeight
                        selectedIndex = cumulativeWeights.length - 1;
                        completeSelection();
                        return;
                    }
                    
                    // Highlight current cumulative weight being checked
                    const cumulativeElements = cumulativeContainer.querySelectorAll('.array-element');
                    if (currentIndex > 0) {
                        cumulativeElements[currentIndex - 1].querySelector('.element-value').classList.remove('linear-search-current');
                        cumulativeElements[currentIndex - 1].querySelector('.element-value').classList.add('linear-search-checked');
                    }
                    
                    cumulativeElements[currentIndex].querySelector('.element-value').classList.add('linear-search-current');
                    
                    explanation.innerHTML = `Checking index ${currentIndex}: cumulative weight = ${cumulativeWeights[currentIndex]}, target = ${randomNum.toFixed(2)}`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step">
                            <strong>Step 4.${currentIndex + 1}:</strong> Check index ${currentIndex}: cumulative[${currentIndex}] = ${cumulativeWeights[currentIndex]} ${cumulativeWeights[currentIndex] >= randomNum ? '' : '<'} ${randomNum.toFixed(2)}
                        </div>
                    `;
                    
                    setTimeout(() => {
                        if (cumulativeWeights[currentIndex] >= randomNum) {
                            selectedIndex = currentIndex;
                            completeSelection();
                        } else {
                            findSelectedElement(currentIndex + 1);
                        }
                    }, 1500);
                }
                
                function completeSelection() {
                    // Remove current highlight
                    const cumulativeElements = cumulativeContainer.querySelectorAll('.array-element');
                    if (selectedIndex > 0) {
                        cumulativeElements[selectedIndex - 1].querySelector('.element-value').classList.remove('linear-search-checked');
                    }
                    cumulativeElements[selectedIndex].querySelector('.element-value').classList.remove('linear-search-current');
                    
                    // Highlight selected element in cumulative array
                    cumulativeElements[selectedIndex].querySelector('.element-value').classList.add('linear-search-found');
                    
                    // Also highlight corresponding original element
                    const originalElements = originalContainer.querySelectorAll('.array-element');
                    originalElements[selectedIndex].querySelector('.element-value').classList.add('linear-search-found');
                    
                    // Update random pick array - show all weights but highlight the selected one
                    const randomPickElements = randomPickContainer.querySelectorAll('.array-element');
                    
                    // Highlight the selected element in random pick array
                    setTimeout(() => {
                        randomPickElements[selectedIndex].querySelector('.element-value').classList.add('linear-search-found', 'bounce');
                    }, 500);
                    
                    explanation.innerHTML = `<strong>Selection Complete!</strong> Element at index ${selectedIndex} selected with weight ${weights[selectedIndex]}`;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 5:</strong> Found! Index ${selectedIndex} selected (cumulative[${selectedIndex}] = ${cumulativeWeights[selectedIndex]}  ${randomNum.toFixed(2)})
                        </div>
                    `;
                    
                    // Update results display
                    selectedElementValue.textContent = weights[selectedIndex];
                    selectedIndexValue.textContent = selectedIndex;
                    
                    // Show probability information
                    const probability = (weights[selectedIndex] / totalWeight * 100).toFixed(2);
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Probability Analysis:</strong> 
                            <br> Element ${selectedIndex} weight: ${weights[selectedIndex]}
                            <br> Total weight: ${totalWeight}
                            <br> Selection probability: ${probability}%
                            <br> Random number: ${randomNum.toFixed(2)}
                        </div>
                    `;
                    
                    continueButton.style.display = 'block';
                    
                    // Auto-return after 10 seconds
                    setTimeout(() => {
                        returnToOriginalAfterRandomPick();
                    }, 10000);
                    
                    continueButton.addEventListener('click', returnToOriginalAfterRandomPick);
                }
                
                // Start the search
                findSelectedElement(0);
                break;
        }
    }
    
    // Start random pick process
    performRandomPickStep();
}

// NEW: Return to Original after Random Pick
function returnToOriginalAfterRandomPick() {
    // Reset to original array
    myArray = [...originalArrayForRandomPick];
    originalArrayForRandomPick = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isRandomPickRunning = false;
    
    logOperation('Random pick with weight completed - returned to original array', 'info');
    showNotification('Returned to original array after random pick operation', 'success');
}
// NEW: Generate Random Point in Circle Handler
function handleGenerateRandomPoint() {
    if (myArray.length < 3) {
        showNotification('Array needs at least 3 elements for circle generation', 'danger');
        return;
    }

    if (isRandomPointRunning) {
        showNotification('Random point generation is already in progress', 'warning');
        return;
    }

    isRandomPointRunning = true;

    // Store original array
    originalArrayForRandomPoint = [...myArray];

    // Show circle visualization
    showCircleVisualization();
}

// NEW: Show Circle Visualization
function showCircleVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Generate Random Point in Circle</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalRandomPointArray"></div>
        </div>

        <div class="circle-visualization">
            <div class="circle-container" id="circleCanvas">
                <!-- Circle and points will be drawn here -->
            </div>
            
            <div class="circle-info">
                <p class="mb-2"><strong>Circle Parameters:</strong></p>
                <div class="coordinate-display">
                    <div class="coordinate-item" id="centerDisplay">Center: [?, ?]</div>
                    <div class="coordinate-item" id="radiusDisplay">Radius: ?</div>
                </div>
                <p class="mb-0" id="circleExplanation">Initializing circle generation...</p>
            </div>
        </div>

        <div class="algorithm-steps mt-3" id="circleStepsContainer">
            <h6 class="text-center">Random Point Generation Steps</h6>
            <div class="steps-container" id="circleSteps"></div>
        </div>

        <div class="stats-card mt-3">
            <div>Generated Point Coordinates</div>
            <div class="stats-value" id="generatedPointCoords">-</div>
        </div>

        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterRandomPoint" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;

    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);

    renderArrayInContainer(originalArrayForRandomPoint, 'originalRandomPointArray');
    performRandomPointGeneration();
}

// NEW: Perform Random Point Generation with Animation
function performRandomPointGeneration() {
    const arrayContainer = document.getElementById('originalRandomPointArray');
    const circleCanvas = document.getElementById('circleCanvas');
    const centerDisplay = document.getElementById('centerDisplay');
    const radiusDisplay = document.getElementById('radiusDisplay');
    const explanation = document.getElementById('circleExplanation');
    const stepsContainer = document.getElementById('circleSteps');
    const generatedPointCoords = document.getElementById('generatedPointCoords');
    const continueButton = document.getElementById('continueAfterRandomPoint');

    const arr = originalArrayForRandomPoint;
    let step = 0;

    // Extract center coordinates and radius from array
    const centerX = parseFloat(arr[0]) || 0;
    const centerY = parseFloat(arr[1]) || 0;
    const radius = parseFloat(arr[2]) || 1;

    // Set up circle visualization
    const circleSize = 300;
    const scale = circleSize / (2 * (radius + 1)); // Add padding

    function drawCircle() {
        // Clear previous drawings
        circleCanvas.innerHTML = '';

        // Draw center point
        const centerDot = document.createElement('div');
        centerDot.className = 'circle-center';
        centerDot.style.left = '50%';
        centerDot.style.top = '50%';
        circleCanvas.appendChild(centerDot);

        // Add center label
        const centerLabel = document.createElement('div');
        centerLabel.className = 'point-label';
        centerLabel.textContent = `Center (${centerX}, ${centerY})`;
        centerLabel.style.left = '50%';
        centerLabel.style.top = '50%';
        circleCanvas.appendChild(centerLabel);

        // Update displays
        centerDisplay.textContent = `Center: [${centerX}, ${centerY}]`;
        radiusDisplay.textContent = `Radius: ${radius}`;
    }

    function performGenerationStep() {
        switch (step) {
            case 0:
                // Step 1: Show array elements being used
                explanation.innerHTML = 'Step 1: Using array elements for circle parameters';
                
                // Highlight the array elements being used
                const elements = arrayContainer.querySelectorAll('.array-element');
                if (elements.length >= 3) {
                    elements[0].querySelector('.element-value').classList.add('info-color');
                    elements[1].querySelector('.element-value').classList.add('info-color');
                    elements[2].querySelector('.element-value').classList.add('warning-color');
                }

                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 1:</strong> Using array[0]=${arr[0]} as center X, array[1]=${arr[1]} as center Y, array[2]=${arr[2]} as radius
                    </div>
                `;

                // Draw the circle
                drawCircle();
                break;

            case 1:
                // Step 2: Generate random angle
                explanation.innerHTML = 'Step 2: Generating random angle (0 to 2)';
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step 2:</strong> Generating random angle  between 0 and 2 radians
                    </div>
                `;

                // Show angle visualization
                setTimeout(() => {
                    const angle = Math.random() * 2 * Math.PI;
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 2a:</strong> Generated angle  = ${angle.toFixed(4)} radians
                        </div>
                    `;
                    step++;
                    performGenerationStep();
                }, 1500);
                return;

            case 2:
                // Step 3: Generate random distance
                explanation.innerHTML = 'Step 3: Generating random distance within radius';
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Step 3:</strong> Generating random distance r using (random(0,1))  radius
                    </div>
                `;

                setTimeout(() => {
                    const randomValue = Math.random();
                    const distance = Math.sqrt(randomValue) * radius;
                    
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step active">
                            <strong>Step 3a:</strong> Random value = ${randomValue.toFixed(4)}, Distance r = (${randomValue.toFixed(4)})  ${radius} = ${distance.toFixed(4)}
                        </div>
                    `;
                    step++;
                    performGenerationStep();
                }, 1500);
                return;

            case 3:
                // Step 4: Calculate coordinates
                explanation.innerHTML = 'Step 4: Calculating point coordinates';
                
                const angle = Math.random() * 2 * Math.PI;
                const randomValue = Math.random();
                const distance = Math.sqrt(randomValue) * radius;
                
                const pointX = centerX + distance * Math.cos(angle);
                const pointY = centerY + distance * Math.sin(angle);

                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Step 4:</strong> Calculating coordinates:<br>
                        x = ${centerX} + ${distance.toFixed(4)}  cos(${angle.toFixed(4)}) = ${pointX.toFixed(4)}<br>
                        y = ${centerY} + ${distance.toFixed(4)}  sin(${angle.toFixed(4)}) = ${pointY.toFixed(4)}
                    </div>
                `;

                // Draw the generated point
                const pointDot = document.createElement('div');
                pointDot.className = 'random-point';
                pointDot.style.left = '50%';
                pointDot.style.top = '50%';
                pointDot.style.transform = `translate(-50%, -50%) translate(${(pointX - centerX) * scale}px, ${(centerY - pointY) * scale}px)`;
                circleCanvas.appendChild(pointDot);

                // Add point label
                const pointLabel = document.createElement('div');
                pointLabel.className = 'point-label';
                pointLabel.textContent = `Point (${pointX.toFixed(2)}, ${pointY.toFixed(2)})`;
                pointLabel.style.left = `calc(50% + ${(pointX - centerX) * scale}px)`;
                pointLabel.style.top = `calc(50% + ${(centerY - pointY) * scale}px)`;
                circleCanvas.appendChild(pointLabel);

                // Draw radius line
                const radiusLine = document.createElement('div');
                radiusLine.className = 'radius-line';
                radiusLine.style.left = '50%';
                radiusLine.style.top = '50%';
                radiusLine.style.width = `${distance * scale}px`;
                radiusLine.style.transform = `rotate(${-angle}rad)`;
                circleCanvas.appendChild(radiusLine);

                // Update generated coordinates display
                generatedPointCoords.textContent = `[${pointX.toFixed(4)}, ${pointY.toFixed(4)}]`;
                break;

            case 4:
                // Step 5: Completion
                explanation.innerHTML = '<strong>Random Point Generation Completed!</strong> Point successfully generated within circle.';
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Final:</strong> Random point generated at coordinates [${generatedPointCoords.textContent}]
                    </div>
                `;

                continueButton.style.display = 'block';
                
                // Auto-return after 10 seconds
                setTimeout(() => {
                    returnToOriginalAfterRandomPoint();
                }, 10000);
                
                continueButton.addEventListener('click', returnToOriginalAfterRandomPoint);
                return;
        }

        step++;
        setTimeout(performGenerationStep, 2000);
    }

    // Start the generation process
    performGenerationStep();
}

// NEW: Return to Original after Random Point Generation
function returnToOriginalAfterRandomPoint() {
    // Reset to original array
    myArray = [...originalArrayForRandomPoint];
    originalArrayForRandomPoint = [];

    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();

    // Reset state
    isRandomPointRunning = false;

    logOperation('Random point generation completed - returned to original array', 'info');
    showNotification('Returned to original array after random point generation', 'success');
}

// Helper function to render array in specific container
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';

    if (array.length === 0) {
        container.innerHTML = '<div class="array-empty-state"><i class="fas fa-layer-group"></i><h4>Array is Empty</h4></div>';
        return;
    }

    array.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}
// NEW: Find Consecutive Sequences Handler
function handleFindConsecutiveSequences() {
    const targetSum = parseInt(consecutiveTargetSum.value);
    
    if (isNaN(targetSum)) {
        showNotification('Please enter a valid target sum', 'danger');
        consecutiveTargetSum.focus();
        return;
    }
    
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('This operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    if (isConsecutiveSequenceSearchRunning) {
        showNotification('Consecutive sequence search is already in progress', 'warning');
        return;
    }
    
    isConsecutiveSequenceSearchRunning = true;
    
    // Store original array with unique name
    originalArrayForConsecutiveSearch = [...myArray];
    
    // Perform consecutive sequence visualization
    performConsecutiveSequenceVisualization(targetSum);
}

// NEW: Perform Consecutive Sequence Visualization
function performConsecutiveSequenceVisualization(targetSum) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find Consecutive Sequences Summing to ${targetSum}</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalConsecutiveSearchArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Algorithm:</strong> Find all sequences of consecutive numbers that sum to ${targetSum}</p>
            <p class="mb-0" id="consecutiveSearchExplanation">Initializing sequence search...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="consecutiveSearchStepsContainer">
            <h6 class="text-center">Search Steps</h6>
            <div class="steps-container" id="consecutiveSearchSteps"></div>
        </div>
        
        <div class="subarrays-results mt-3" id="consecutiveSearchResults">
            <h6 class="text-center">Found Sequences</h6>
            <div class="stats-card">
                <div>Total Sequences Found</div>
                <div class="stats-value" id="consecutiveSequenceCount">0</div>
            </div>
            <div id="consecutiveSequencesList" class="mt-3"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterConsecutiveSearch" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForConsecutiveSearch, 'originalConsecutiveSearchArray');
    
    executeConsecutiveSequenceAlgorithm(targetSum);
}

// NEW: Execute Consecutive Sequence Algorithm with Animation
function executeConsecutiveSequenceAlgorithm(targetSum) {
    const arrayContainer = document.getElementById('originalConsecutiveSearchArray');
    const explanation = document.getElementById('consecutiveSearchExplanation');
    const stepsContainer = document.getElementById('consecutiveSearchSteps');
    const resultsContainer = document.getElementById('consecutiveSearchResults');
    const sequenceCount = document.getElementById('consecutiveSequenceCount');
    const sequencesList = document.getElementById('consecutiveSequencesList');
    const continueButton = document.getElementById('continueAfterConsecutiveSearch');
    
    const arr = originalArrayForConsecutiveSearch.map(val => parseFloat(val));
    const n = arr.length;
    let foundSequences = [];
    let step = 0;
    let currentStart = 0;
    let currentEnd = 0;
    
    // Initialize results display
    sequenceCount.textContent = '0';
    sequencesList.innerHTML = '<p class="text-center text-muted">No sequences found yet</p>';
    
    function executeStep() {
        if (currentStart >= n) {
            // Algorithm completed
            explanation.innerHTML = `<strong>Search Completed!</strong> Found ${foundSequences.length} sequence(s) summing to ${targetSum}`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Search completed. Found ${foundSequences.length} sequence(s)
                </div>
            `;
            
            // Update final results
            updateSequencesDisplay();
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterConsecutiveSearch();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterConsecutiveSearch);
            
            return;
        }
        
        step++;
        
        if (currentEnd >= n) {
            // Current start exhausted, move to next start
            currentStart++;
            currentEnd = currentStart;
            executeStep();
            return;
        }
        
        // Calculate current sum from currentStart to currentEnd
        let currentSum = 0;
        for (let i = currentStart; i <= currentEnd; i++) {
            currentSum += arr[i];
        }
        
        explanation.innerHTML = `Checking sequence [${currentStart}-${currentEnd}]: Sum = ${currentSum}`;
        
        // Highlight current window
        const elements = arrayContainer.querySelectorAll('.array-element');
        for (let i = currentStart; i <= currentEnd; i++) {
            elements[i].querySelector('.element-value').classList.add('window-current');
        }
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${currentSum === targetSum ? 'active' : ''}">
                <strong>Step ${step}:</strong> Checking [${currentStart}-${currentEnd}] = ${arr.slice(currentStart, currentEnd + 1).join(' + ')} = ${currentSum}
                ${currentSum === targetSum ? ' - MATCH FOUND!' : ''}
            </div>
        `;
        
        // Scroll steps container
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        setTimeout(() => {
            // Remove current window highlights
            for (let i = currentStart; i <= currentEnd; i++) {
                elements[i].querySelector('.element-value').classList.remove('window-current');
            }
            
            if (currentSum === targetSum) {
                // Found a sequence
                const sequence = arr.slice(currentStart, currentEnd + 1);
                foundSequences.push({
                    start: currentStart,
                    end: currentEnd,
                    sequence: sequence
                });
                
                // Highlight the found sequence
                for (let i = currentStart; i <= currentEnd; i++) {
                    elements[i].querySelector('.element-value').classList.add('subarray-sum-match');
                }
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Sequence Found!</strong> [${currentStart}-${currentEnd}] = [${sequence.join(', ')}] sums to ${targetSum}
                    </div>
                `;
                
                // Update sequences display immediately when found
                updateSequencesDisplay();
                
                // Move to next start
                currentStart++;
                currentEnd = currentStart;
            } else if (currentSum < targetSum) {
                // Sum is less than target, extend window
                currentEnd++;
            } else {
                // Sum is greater than target, move start forward
                currentStart++;
                currentEnd = currentStart;
            }
            
            executeStep();
        }, 1500);
    }
    
    // Function to update sequences display
    function updateSequencesDisplay() {
        sequenceCount.textContent = foundSequences.length;
        
        if (foundSequences.length > 0) {
            sequencesList.innerHTML = '';
            foundSequences.forEach((seq, index) => {
                const sequenceDiv = document.createElement('div');
                sequenceDiv.className = 'subarray-sum-item mb-2 p-3';
                sequenceDiv.innerHTML = `
                    <div class="d-flex justify-content-between align-items-center">
                        <strong class="text-warning">Sequence ${index + 1}</strong>
                        <span class="badge bg-success">Sum: ${seq.sequence.reduce((a, b) => a + b, 0)}</span>
                    </div>
                    <div class="mt-2">
                        <strong>Indices:</strong> [${seq.start} - ${seq.end}]<br>
                        <strong>Values:</strong> [${seq.sequence.join(', ')}]<br>
                        <strong>Verification:</strong> ${seq.sequence.join(' + ')} = ${targetSum}
                    </div>
                `;
                sequencesList.appendChild(sequenceDiv);
            });
        } else {
            sequencesList.innerHTML = '<p class="text-center text-muted">No sequences found yet</p>';
        }
        
        // Scroll results into view
        resultsContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
    
    // Start execution
    executeStep();
}

// NEW: Return to Original after Consecutive Sequence Search
function returnToOriginalAfterConsecutiveSearch() {
    // Reset to original array
    myArray = [...originalArrayForConsecutiveSearch];
    originalArrayForConsecutiveSearch = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isConsecutiveSequenceSearchRunning = false;
    
    // Clear input
    consecutiveTargetSum.value = '';
    
    logOperation('Consecutive sequence search completed - returned to original array', 'info');
    showNotification('Returned to original array after consecutive sequence search', 'success');
}
// NEW: Convert to English Words Handler
function handleConvertToEnglish() {
    const number = parseInt(numberInput.value);
    
    if (isNaN(number) || number < 0 || number > 999999999) {
        showNotification('Please enter a valid number between 0 and 999,999,999', 'danger');
        numberInput.focus();
        return;
    }
    
    if (isNumberOperationRunning) {
        showNotification('A number operation is already in progress', 'warning');
        return;
    }
    
    isNumberOperationRunning = true;
    
    // Store original array
    originalArrayForNumberOps = [...myArray];
    
    // Show conversion visualization
    showEnglishConversionVisualization(number);
}

// NEW: Find Digit One Handler
function handleFindDigitOne() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isNumberOperationRunning) {
        showNotification('A number operation is already in progress', 'warning');
        return;
    }
    
    isNumberOperationRunning = true;
    
    // Store original array
    originalArrayForNumberOps = [...myArray];
    
    // Show digit one visualization
    showDigitOneVisualization();
}

// NEW: Show English Conversion Visualization
function showEnglishConversionVisualization(number) {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Convert Number to English Words</h5>
        
        <div class="array-group">
            <div class="array-label">Original Number</div>
            <div class="english-word-display" id="originalNumberDisplay">${number}</div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">English Words</div>
            <div class="english-word-display" id="englishWordsDisplay">Converting...</div>
        </div>
        
        <div class="number-operation-explanation">
            <p class="mb-2"><strong>Conversion Process:</strong> Converting numeric digits to English words</p>
            <p class="mb-0" id="conversionExplanation">Starting conversion process...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="conversionStepsContainer">
            <h6 class="text-center">Conversion Steps</h6>
            <div class="steps-container" id="conversionSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterConversion" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    performEnglishConversionAnimation(number);
}

// NEW: Perform English Conversion Animation
function performEnglishConversionAnimation(number) {
    const englishDisplay = document.getElementById('englishWordsDisplay');
    const explanation = document.getElementById('conversionExplanation');
    const stepsContainer = document.getElementById('conversionSteps');
    const continueButton = document.getElementById('continueAfterConversion');
    
    const steps = [];
    let currentStep = 0;
    
    function performConversionStep() {
        if (currentStep >= steps.length) {
            // Conversion completed
            const englishWords = numberToWords(number);
            englishDisplay.textContent = englishWords;
            
            explanation.innerHTML = `<strong>Conversion Completed!</strong> Number converted to English words.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> "${number}" = "${englishWords}"
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterNumberOperation();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterNumberOperation);
            
            return;
        }
        
        const step = steps[currentStep];
        explanation.innerHTML = step.explanation;
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step ${step.active ? 'active' : ''}">
                <strong>Step ${currentStep + 1}:</strong> ${step.description}
            </div>
        `;
        
        // Scroll to bottom
        stepsContainer.scrollTop = stepsContainer.scrollHeight;
        
        currentStep++;
        setTimeout(performConversionStep, 1500);
    }
    
    // Generate conversion steps based on the number
    generateConversionSteps(number, steps);
    
    // Start conversion process
    performConversionStep();
}

// NEW: Generate Conversion Steps
function generateConversionSteps(number, steps) {
    if (number === 0) {
        steps.push({
            explanation: "Processing number: 0",
            description: "Zero is a special case",
            active: true
        });
        return;
    }
    
    const numStr = number.toString();
    const length = numStr.length;
    
    steps.push({
        explanation: `Processing number: ${number} (${length} digit${length > 1 ? 's' : ''})`,
        description: `Input number has ${length} digit${length > 1 ? 's' : ''}`,
        active: true
    });
    
    // Process based on number length
    if (length <= 3) {
        steps.push({
            explanation: "Processing hundreds, tens, and units",
            description: "Breaking down into hundreds, tens, and units places",
            active: true
        });
    } else if (length <= 6) {
        steps.push({
            explanation: "Processing thousands",
            description: "Breaking down into thousands and hundreds",
            active: true
        });
    } else {
        steps.push({
            explanation: "Processing millions",
            description: "Breaking down into millions, thousands, and hundreds",
            active: true
        });
    }
    
    steps.push({
        explanation: "Converting each segment to English words",
        description: "Mapping digits to their English equivalents",
        active: true
    });
    
    steps.push({
        explanation: "Combining all segments with proper formatting",
        description: "Adding spaces and proper punctuation",
        active: true
    });
}

// NEW: Number to Words Conversion Function
function numberToWords(num) {
    if (num === 0) return "Zero";
    
    const belowTwenty = [
        "", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten",
        "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", 
        "Eighteen", "Nineteen"
    ];
    
    const tens = [
        "", "", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"
    ];
    
    const thousands = ["", "Thousand", "Million", "Billion"];
    
    function convertChunk(n) {
        if (n === 0) return "";
        if (n < 20) return belowTwenty[n];
        if (n < 100) {
            return tens[Math.floor(n / 10)] + (n % 10 !== 0 ? " " + belowTwenty[n % 10] : "");
        }
        return belowTwenty[Math.floor(n / 100)] + " Hundred" + (n % 100 !== 0 ? " " + convertChunk(n % 100) : "");
    }
    
    let result = "";
    let chunkIndex = 0;
    
    while (num > 0) {
        if (num % 1000 !== 0) {
            result = convertChunk(num % 1000) + (thousands[chunkIndex] ? " " + thousands[chunkIndex] : "") + (result ? " " + result : "");
        }
        num = Math.floor(num / 1000);
        chunkIndex++;
    }
    
    return result.trim();
}

// NEW: Show Digit One Visualization
function showDigitOneVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Find Digit '1' in Array Elements</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalDigitOneArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Digit '1' Analysis</div>
            <div class="transformed-array-container" id="transformedDigitOneArray"></div>
        </div>
        
        <div class="number-operation-explanation">
            <p class="mb-2"><strong>Analysis Process:</strong> Finding elements that contain digit '1'</p>
            <p class="mb-0" id="digitOneExplanation">Starting digit analysis...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="digitOneStepsContainer">
            <h6 class="text-center">Digit Analysis Steps</h6>
            <div class="steps-container" id="digitOneSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Total Elements with Digit '1'</div>
            <div class="stats-value" id="digitOneCount">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterDigitOne" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForNumberOps, 'originalDigitOneArray');
    renderArrayInContainer([...originalArrayForNumberOps], 'transformedDigitOneArray');
    
    performDigitOneAnalysisAnimation();
}

// NEW: Perform Digit One Analysis Animation
function performDigitOneAnalysisAnimation() {
    const originalContainer = document.getElementById('originalDigitOneArray');
    const transformedContainer = document.getElementById('transformedDigitOneArray');
    const explanation = document.getElementById('digitOneExplanation');
    const stepsContainer = document.getElementById('digitOneSteps');
    const digitOneCount = document.getElementById('digitOneCount');
    const continueButton = document.getElementById('continueAfterDigitOne');
    
    const array = [...originalArrayForNumberOps];
    let totalOnes = 0;
    let currentIndex = 0;
    
    function performAnalysisStep() {
        if (currentIndex >= array.length) {
            // Analysis completed
            explanation.innerHTML = `<strong>Analysis Completed!</strong> Found ${totalOnes} element${totalOnes !== 1 ? 's' : ''} containing digit '1'.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Total elements with digit '1': ${totalOnes}
                </div>
            `;
            
            digitOneCount.textContent = totalOnes;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterNumberOperation();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterNumberOperation);
            
            return;
        }
        
        const element = array[currentIndex];
        const elementStr = element.toString();
        
        explanation.innerHTML = `Checking element [${currentIndex}]: "${element}"`;
        
        // Highlight current element being checked
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const transformedElements = transformedContainer.querySelectorAll('.array-element');
        
        const originalElement = originalElements[currentIndex].querySelector('.element-value');
        const transformedElement = transformedElements[currentIndex].querySelector('.element-value');
        
        originalElement.classList.add('sorting-current');
        transformedElement.classList.add('sorting-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step">
                <strong>Step ${currentIndex + 1}:</strong> Checking "${element}" for digit '1'
            </div>
        `;
        
        setTimeout(() => {
            // Check if element contains digit '1'
            const containsOne = elementStr.includes('1');
            const oneCount = (elementStr.match(/1/g) || []).length;
            
            if (containsOne) {
                totalOnes++;
                
                stepsContainer.innerHTML += `
                    <div class="algorithm-step active">
                        <strong>Found:</strong> "${element}" contains digit '1' ${oneCount} time${oneCount !== 1 ? 's' : ''}
                    </div>
                `;
                
                // Highlight as containing digit one
                originalElement.classList.remove('sorting-current');
                transformedElement.classList.remove('sorting-current');
                originalElement.classList.add('contains-digit-one');
                transformedElement.classList.add('contains-digit-one');
                
                // If it's exactly "1", highlight differently
                if (element === '1') {
                    transformedElement.classList.add('digit-one-count');
                }
                
            } else {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>No Match:</strong> "${element}" does not contain digit '1'
                    </div>
                `;
                
                originalElement.classList.remove('sorting-current');
                transformedElement.classList.remove('sorting-current');
            }
            
            digitOneCount.textContent = totalOnes;
            
            // Scroll to bottom
            stepsContainer.scrollTop = stepsContainer.scrollHeight;
            
            currentIndex++;
            performAnalysisStep();
        }, 1500);
    }
    
    // Start analysis process
    performAnalysisStep();
}

// NEW: Return to Original after Number Operations
function returnToOriginalAfterNumberOperation() {
    // Reset to original array
    myArray = [...originalArrayForNumberOps];
    originalArrayForNumberOps = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isNumberOperationRunning = false;
    
    // Clear input
    numberInput.value = '';
    
    logOperation('Number operation completed - returned to original array', 'info');
    showNotification('Returned to original array after number operation', 'success');
}
// NEW: Add Digits (Digital Root) Handler
function handleAddDigits() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isDigitalRootRunning) {
        showNotification('Digital root operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Digital root operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isDigitalRootRunning = true;
    
    // Store original array
    originalArrayForDigitalRoot = [...myArray];
    
    // Show digital root visualization
    showDigitalRootVisualization();
}
// NEW: Happy Number Handler
function handleHappyNumber() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isHappyNumberRunning) {
        showNotification('Happy number operation is already in progress', 'warning');
        return;
    }
    
    // Check if array contains numbers
    let allNumbers = true;
    for (let i = 0; i < myArray.length; i++) {
        if (isNaN(parseFloat(myArray[i]))) {
            allNumbers = false;
            break;
        }
    }
    
    if (!allNumbers) {
        showNotification('Happy number operation requires all array elements to be numbers', 'danger');
        return;
    }
    
    isHappyNumberRunning = true;
    
    // Store original array
    originalArrayForHappyNumber = [...myArray];
    
    // Show happy number visualization
    showHappyNumberVisualization();
}

// NEW: Show Digital Root Visualization
function showDigitalRootVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Add Digits (Digital Root) Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalDigitalRootArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Digital Root Results</div>
            <div class="transformed-array-container" id="transformedDigitalRootArray"></div>
        </div>
        
        <div class="digital-root-explanation">
            <p class="mb-2"><strong>Digital Root Algorithm:</strong> Repeatedly sum digits until single digit is obtained</p>
            <p class="mb-0" id="digitalRootExplanation">Starting digital root calculation...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="digitalRootStepsContainer">
            <h6 class="text-center">Digital Root Calculation Steps</h6>
            <div class="steps-container" id="digitalRootSteps"></div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterDigitalRoot" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForDigitalRoot, 'originalDigitalRootArray');
    renderArrayInContainer([...originalArrayForDigitalRoot], 'transformedDigitalRootArray');
    
    performDigitalRootAnimation();
}

// NEW: Perform Digital Root Animation
function performDigitalRootAnimation() {
    const originalContainer = document.getElementById('originalDigitalRootArray');
    const transformedContainer = document.getElementById('transformedDigitalRootArray');
    const explanation = document.getElementById('digitalRootExplanation');
    const stepsContainer = document.getElementById('digitalRootSteps');
    const continueButton = document.getElementById('continueAfterDigitalRoot');
    
    const originalArray = [...originalArrayForDigitalRoot];
    const digitalRootResults = [];
    let currentIndex = 0;
    
    // Helper function to calculate digital root
    function calculateDigitalRoot(num) {
        let current = Math.abs(parseInt(num));
        const steps = [];
        
        while (current > 9) {
            const digits = current.toString().split('').map(Number);
            const sum = digits.reduce((acc, digit) => acc + digit, 0);
            steps.push(`${current}  ${digits.join(' + ')} = ${sum}`);
            current = sum;
        }
        
        steps.push(`Final digital root: ${current}`);
        return { result: current, steps: steps };
    }
    
    function processNextElement() {
        if (currentIndex >= originalArray.length) {
            // All elements processed
            explanation.innerHTML = `<strong>Digital Root Operation Completed!</strong> All elements processed.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Digital root calculation completed for all elements
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterDigitalRoot();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterDigitalRoot);
            
            return;
        }
        
        const currentElement = originalArray[currentIndex];
        const num = parseFloat(currentElement);
        
        if (isNaN(num)) {
            // Skip non-numeric elements
            digitalRootResults.push('N/A');
            currentIndex++;
            processNextElement();
            return;
        }
        
        explanation.innerHTML = `Processing element [${currentIndex}]: ${currentElement}`;
        
        // Highlight current element in original array
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentOriginalElement = originalElements[currentIndex].querySelector('.element-value');
        currentOriginalElement.classList.add('digital-root-current');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Processing Element ${currentIndex}:</strong> ${currentElement}
            </div>
        `;
        
        setTimeout(() => {
            // Calculate digital root with step-by-step demonstration
            const digitalRootData = calculateDigitalRoot(num);
            digitalRootResults.push(digitalRootData.result.toString());
            
            // Show calculation steps
            digitalRootData.steps.forEach((step, stepIndex) => {
                setTimeout(() => {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step ${stepIndex === digitalRootData.steps.length - 1 ? 'active' : ''}">
                            <strong>Step ${stepIndex + 1}:</strong> ${step}
                        </div>
                    `;
                    stepsContainer.scrollTop = stepsContainer.scrollHeight;
                    
                    if (stepIndex === digitalRootData.steps.length - 1) {
                        // Final step - update transformed array
                        renderArrayInContainer(digitalRootResults, 'transformedDigitalRootArray');
                        
                        // Highlight the result
                        const transformedElements = transformedContainer.querySelectorAll('.array-element');
                        if (transformedElements[currentIndex]) {
                            const resultElement = transformedElements[currentIndex].querySelector('.element-value');
                            resultElement.classList.add('digital-root-result');
                        }
                        
                        // Remove highlight from original element
                        currentOriginalElement.classList.remove('digital-root-current');
                        
                        // Move to next element
                        currentIndex++;
                        setTimeout(processNextElement, 1500);
                    }
                }, stepIndex * 1000);
            });
        }, 1000);
    }
    
    // Start processing
    processNextElement();
}
// NEW: Show Happy Number Visualization
function showHappyNumberVisualization() {
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Happy Number Check Operation</h5>
        
        <div class="array-group">
            <div class="array-label">Original Array</div>
            <div class="original-array-container" id="originalHappyNumberArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Happy Numbers Found</div>
            <div class="transformed-array-container" id="transformedHappyNumberArray"></div>
        </div>
        
        <div class="happy-number-explanation">
            <p class="mb-2"><strong>Happy Number Algorithm:</strong> A number is happy if the process of summing squares of digits eventually reaches 1</p>
            <p class="mb-0" id="happyNumberExplanation">Starting happy number check...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="happyNumberStepsContainer">
            <h6 class="text-center">Happy Number Check Steps</h6>
            <div class="steps-container" id="happyNumberSteps"></div>
        </div>
        
        <div class="stats-card mt-3">
            <div>Happy Numbers Found</div>
            <div class="stats-value" id="happyNumberCount">0</div>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterHappyNumber" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForHappyNumber, 'originalHappyNumberArray');
    renderArrayInContainer([], 'transformedHappyNumberArray'); // Start with empty array for results
    
    performHappyNumberAnimation();
}

// NEW: Perform Happy Number Animation
function performHappyNumberAnimation() {
    const originalContainer = document.getElementById('originalHappyNumberArray');
    const transformedContainer = document.getElementById('transformedHappyNumberArray');
    const explanation = document.getElementById('happyNumberExplanation');
    const stepsContainer = document.getElementById('happyNumberSteps');
    const happyNumberCount = document.getElementById('happyNumberCount');
    const continueButton = document.getElementById('continueAfterHappyNumber');
    
    const originalArray = [...originalArrayForHappyNumber];
    const happyNumberResults = []; // This will only contain happy numbers from original array
    let currentIndex = 0;
    let totalHappyNumbers = 0;
    
    // Helper function to check if a number is happy
    function isHappyNumber(num) {
        let seen = new Set();
        let current = Math.abs(parseInt(num));
        const steps = [];
        
        while (current !== 1 && !seen.has(current)) {
            seen.add(current);
            const digits = current.toString().split('').map(Number);
            const sumOfSquares = digits.reduce((acc, digit) => acc + digit * digit, 0);
            steps.push(`${current}  ${digits.map(d => d + '').join(' + ')} = ${sumOfSquares}`);
            current = sumOfSquares;
        }
        
        const isHappy = current === 1;
        steps.push(isHappy ? 'Reached 1 - This is a HAPPY NUMBER! ' : 'Entered cycle - This is NOT a happy number');
        
        return { isHappy: isHappy, steps: steps };
    }
    
    function processNextElement() {
        if (currentIndex >= originalArray.length) {
            // All elements processed
            explanation.innerHTML = `<strong>Happy Number Check Completed!</strong> Found ${totalHappyNumbers} happy number(s).`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> Happy number check completed. Total happy numbers found: ${totalHappyNumbers}
                </div>
            `;
            
            if (totalHappyNumbers === 0) {
                stepsContainer.innerHTML += `
                    <div class="algorithm-step">
                        <strong>Note:</strong> No happy numbers found in the array
                    </div>
                `;
            }
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterHappyNumber();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterHappyNumber);
            
            return;
        }
        
        const currentElement = originalArray[currentIndex];
        const num = parseFloat(currentElement);
        
        if (isNaN(num)) {
            // Skip non-numeric elements
            stepsContainer.innerHTML += `
                <div class="algorithm-step">
                    <strong>Skipping Element ${currentIndex}:</strong> "${currentElement}" is not a number
                </div>
            `;
            currentIndex++;
            setTimeout(processNextElement, 1000);
            return;
        }
        
        explanation.innerHTML = `Checking if ${currentElement} is a happy number...`;
        
        // Highlight current element in original array
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentOriginalElement = originalElements[currentIndex].querySelector('.element-value');
        currentOriginalElement.classList.add('happy-process');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Checking Element ${currentIndex}:</strong> ${currentElement}
            </div>
        `;
        
        setTimeout(() => {
            // Check if number is happy with step-by-step demonstration
            const happyData = isHappyNumber(num);
            
            // Show calculation steps
            happyData.steps.forEach((step, stepIndex) => {
                setTimeout(() => {
                    stepsContainer.innerHTML += `
                        <div class="algorithm-step ${stepIndex === happyData.steps.length - 1 ? 'active' : ''}">
                            <strong>Step ${stepIndex + 1}:</strong> ${step}
                        </div>
                    `;
                    stepsContainer.scrollTop = stepsContainer.scrollHeight;
                    
                    if (stepIndex === happyData.steps.length - 1) {
                        // Final step - check if it's happy
                        if (happyData.isHappy) {
                            // Add the happy number to results
                            happyNumberResults.push(currentElement);
                            totalHappyNumbers++;
                            happyNumberCount.textContent = totalHappyNumbers;
                            
                            // Update transformed array with only happy numbers
                            renderArrayInContainer(happyNumberResults, 'transformedHappyNumberArray');
                            
                            // Highlight both the original element and the result
                            currentOriginalElement.classList.add('happy-number');
                            
                            const transformedElements = transformedContainer.querySelectorAll('.array-element');
                            if (transformedElements[happyNumberResults.length - 1]) {
                                const resultElement = transformedElements[happyNumberResults.length - 1].querySelector('.element-value');
                                resultElement.classList.add('happy-number', 'bounce');
                            }
                            
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step active">
                                    <strong>Result:</strong> ${currentElement} is a HAPPY NUMBER! Added to results. 
                                </div>
                            `;
                        } else {
                            // Not a happy number - just show the result
                            stepsContainer.innerHTML += `
                                <div class="algorithm-step">
                                    <strong>Result:</strong> ${currentElement} is not a happy number
                                </div>
                            `;
                        }
                        
                        // Remove process highlight from original element
                        currentOriginalElement.classList.remove('happy-process');
                        
                        // Move to next element
                        currentIndex++;
                        setTimeout(processNextElement, 1500);
                    }
                }, stepIndex * 1000);
            });
        }, 1000);
    }
    
    // Start processing
    processNextElement();
}

// NEW: Return to Original after Digital Root
function returnToOriginalAfterDigitalRoot() {
    // Reset to original array
    myArray = [...originalArrayForDigitalRoot];
    originalArrayForDigitalRoot = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isDigitalRootRunning = false;
    
    logOperation('Digital root operation completed - returned to original array', 'info');
    showNotification('Returned to original array after digital root operation', 'success');
}

// NEW: Return to Original after Happy Number
function returnToOriginalAfterHappyNumber() {
    // Reset to original array
    myArray = [...originalArrayForHappyNumber];
    originalArrayForHappyNumber = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isHappyNumberRunning = false;
    
    logOperation('Happy number operation completed - returned to original array', 'info');
    showNotification('Returned to original array after happy number operation', 'success');
}
// NEW: Excel Column Number Handler
function handleExcelColumnNumber() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isExcelConversionRunning) {
        showNotification('Excel conversion is already in progress', 'warning');
        return;
    }
    
    // Validate that all elements are valid Excel column titles
    const invalidElements = [];
    for (let i = 0; i < myArray.length; i++) {
        const element = myArray[i].toString().trim().toUpperCase();
        if (!isValidExcelColumn(element)) {
            invalidElements.push({
                index: i,
                value: myArray[i],
                element: element
            });
        }
    }
    
    if (invalidElements.length > 0) {
        // Show detailed error message
        let errorMessage = 'Invalid Excel column titles found:<br>';
        invalidElements.forEach(invalid => {
            errorMessage += ` Index ${invalid.index}: "${invalid.value}" is not a valid Excel column<br>`;
        });
        errorMessage += '<br>Please enter only alphabetic characters (A-Z, AA-ZZ, etc.)';
        
        // Show error in search results
        searchResults.innerHTML = `
            <div class="alert alert-danger">
                <h6><i class="fas fa-exclamation-triangle me-2"></i>Invalid Input</h6>
                <p class="mb-0">${errorMessage}</p>
            </div>
        `;
        
        // Highlight invalid elements with animation
        invalidElements.forEach(invalid => {
            highlightElement(invalid.index, 'excel-error');
        });
        
        logOperation('Excel conversion failed - invalid column titles detected', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForExcel = [...myArray];
    
    // Show Excel conversion visualization
    showExcelConversionVisualization();
}

// NEW: Validate Excel Column Title
function isValidExcelColumn(title) {
    if (typeof title !== 'string') return false;
    
    const trimmed = title.trim().toUpperCase();
    if (trimmed.length === 0) return false;
    
    // Check if all characters are uppercase letters A-Z
    for (let i = 0; i < trimmed.length; i++) {
        const char = trimmed.charAt(i);
        if (char < 'A' || char > 'Z') {
            return false;
        }
    }
    
    return true;
}

// NEW: Convert Excel Column to Number (Python implementation equivalent)
function excelColumnToNumber(columnTitle) {
    let result = 0;
    const upperTitle = columnTitle.toString().trim().toUpperCase();
    
    for (let i = 0; i < upperTitle.length; i++) {
        const char = upperTitle.charAt(i);
        const charValue = char.charCodeAt(0) - 'A'.charCodeAt(0) + 1;
        result = result * 26 + charValue;
    }
    
    return result;
}

// NEW: Show Excel Conversion Visualization
function showExcelConversionVisualization() {
    isExcelConversionRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Excel Column to Number Conversion</h5>
        
        <div class="array-group">
            <div class="array-label">Excel Column Titles</div>
            <div class="original-array-container" id="originalExcelArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Column Numbers</div>
            <div class="transformed-array-container" id="transformedExcelArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Conversion Formula:</strong> result = result  26 + (char - 'A' + 1)</p>
            <p class="mb-0" id="excelExplanation">Starting Excel column conversion...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="excelStepsContainer">
            <h6 class="text-center">Conversion Steps</h6>
            <div class="steps-container" id="excelSteps"></div>
        </div>
        
        <div class="table-container mt-3">
            <table class="excel-table">
                <thead>
                    <tr>
                        <th>Excel Column</th>
                        <th>Calculation Steps</th>
                        <th>Result</th>
                    </tr>
                </thead>
                <tbody id="excelConversionTable">
                </tbody>
            </table>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterExcel" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForExcel, 'originalExcelArray');
    renderArrayInContainer([], 'transformedExcelArray');
    
    performExcelConversionAnimation();
}

// NEW: Perform Excel Conversion Animation
function performExcelConversionAnimation() {
    const originalContainer = document.getElementById('originalExcelArray');
    const transformedContainer = document.getElementById('transformedExcelArray');
    const explanation = document.getElementById('excelExplanation');
    const stepsContainer = document.getElementById('excelSteps');
    const conversionTable = document.getElementById('excelConversionTable');
    const continueButton = document.getElementById('continueAfterExcel');
    
    const excelColumns = [...originalArrayForExcel];
    const convertedNumbers = [];
    let currentIndex = 0;
    
    function performConversionStep() {
        if (currentIndex >= excelColumns.length) {
            // Conversion completed
            explanation.innerHTML = `<strong>Conversion Completed!</strong> All Excel columns converted to numbers.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> All ${excelColumns.length} Excel columns successfully converted
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterExcel();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterExcel);
            
            return;
        }
        
        const currentColumn = excelColumns[currentIndex].toString().trim().toUpperCase();
        explanation.innerHTML = `Converting column "${currentColumn}" to number...`;
        
        // Highlight current element being converted
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentIndex].querySelector('.element-value');
        currentElement.classList.add('excel-column');
        
        // Show detailed calculation steps
        const calculationSteps = calculateExcelColumnSteps(currentColumn);
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex + 1}:</strong> Converting "${currentColumn}" to number
            </div>
        `;
        
        // Add to conversion table
        const tableRow = document.createElement('tr');
        tableRow.innerHTML = `
            <td><strong>${currentColumn}</strong></td>
            <td>
                <div class="excel-conversion-steps" id="steps-${currentIndex}"></div>
            </td>
            <td><strong id="result-${currentIndex}">Calculating...</strong></td>
        `;
        conversionTable.appendChild(tableRow);
        
        const stepsElement = document.getElementById(`steps-${currentIndex}`);
        const resultElement = document.getElementById(`result-${currentIndex}`);
        
        // Animate the calculation process
        animateExcelCalculation(currentColumn, calculationSteps, stepsElement, resultElement, currentIndex, () => {
            // Calculation complete for this column
            const finalResult = excelColumnToNumber(currentColumn);
            convertedNumbers.push(finalResult);
            
            // Update transformed array
            renderArrayInContainer(convertedNumbers, 'transformedExcelArray');
            
            // Highlight the converted number
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            if (transformedElements[currentIndex]) {
                transformedElements[currentIndex].querySelector('.element-value').classList.add('excel-number');
            }
            
            // Remove highlight from original element
            currentElement.classList.remove('excel-column');
            
            // Move to next column
            currentIndex++;
            setTimeout(performConversionStep, 1000);
        });
    }
    
    // Start conversion process
    performConversionStep();
}

// NEW: Calculate Detailed Steps for Excel Conversion
function calculateExcelColumnSteps(columnTitle) {
    const steps = [];
    let result = 0;
    const upperTitle = columnTitle.toUpperCase();
    
    for (let i = 0; i < upperTitle.length; i++) {
        const char = upperTitle.charAt(i);
        const charValue = char.charCodeAt(0) - 'A'.charCodeAt(0) + 1;
        const previousResult = result;
        result = result * 26 + charValue;
        
        steps.push({
            char: char,
            charValue: charValue,
            previousResult: previousResult,
            newResult: result,
            step: i + 1
        });
    }
    
    return steps;
}

// NEW: Animate Excel Calculation Steps
function animateExcelCalculation(columnTitle, steps, stepsElement, resultElement, index, callback) {
    let currentStep = 0;
    let finalResult = 0;
    
    function showNextStep() {
        if (currentStep >= steps.length) {
            // All steps completed
            resultElement.innerHTML = `<span class="text-success">${finalResult}</span>`;
            resultElement.classList.add('text-success', 'fw-bold');
            callback();
            return;
        }
        
        const step = steps[currentStep];
        finalResult = step.newResult;
        
        const stepHTML = `
            <div class="excel-conversion-step ${currentStep === steps.length - 1 ? 'active' : ''}">
                <strong>Step ${step.step}:</strong> '${step.char}'  ${step.charValue}<br>
                Calculation: ${step.previousResult}  26 + ${step.charValue} = <strong>${step.newResult}</strong>
            </div>
        `;
        
        stepsElement.innerHTML += stepHTML;
        
        // Scroll to show the latest step
        stepsElement.scrollTop = stepsElement.scrollHeight;
        
        // Update result with animation
        resultElement.innerHTML = `<span class="text-warning">${step.newResult}</span>`;
        resultElement.classList.add('pulse');
        
        setTimeout(() => {
            resultElement.classList.remove('pulse');
            currentStep++;
            showNextStep();
        }, 1500);
    }
    
    // Start showing steps
    showNextStep();
}

// NEW: Return to Original after Excel Conversion
function returnToOriginalAfterExcel() {
    // Reset to original array
    myArray = [...originalArrayForExcel];
    originalArrayForExcel = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isExcelConversionRunning = false;
    
    logOperation('Excel column conversion completed - returned to original array', 'info');
    showNotification('Returned to original array after Excel conversion', 'success');
}
// Helper function to render array in specific container
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = `
            <div class="array-empty-state">
                <i class="fas fa-layer-group"></i>
                <h6>Empty</h6>
            </div>
        `;
        return;
    }
    
    array.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        arrayElement.innerHTML = `
            <div class="element-value">${value}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}
// NEW: Number to Column Title Handler
function handleNumberToColumnTitle() {
    if (myArray.length === 0) {
        showNotification('Array is empty. Please add elements first.', 'warning');
        return;
    }
    
    if (isNumberToColumnRunning) {
        showNotification('Number to column conversion is already in progress', 'warning');
        return;
    }
    
    // Validate that all elements are valid positive integers
    const invalidElements = [];
    for (let i = 0; i < myArray.length; i++) {
        const element = myArray[i];
        const num = parseInt(element);
        
        if (isNaN(num) || num < 1 || num > 2147483647 || !Number.isInteger(parseFloat(element))) {
            invalidElements.push({
                index: i,
                value: myArray[i],
                parsed: num
            });
        }
    }
    
    if (invalidElements.length > 0) {
        // Show detailed error message
        let errorMessage = 'Invalid numbers found:<br>';
        invalidElements.forEach(invalid => {
            let reason = '';
            if (isNaN(invalid.parsed)) {
                reason = 'not a number';
            } else if (invalid.parsed < 1) {
                reason = 'must be  1';
            } else if (invalid.parsed > 2147483647) {
                reason = 'must be  2147483647';
            } else if (!Number.isInteger(parseFloat(invalid.value))) {
                reason = 'must be integer';
            }
            
            errorMessage += ` Index ${invalid.index}: "${invalid.value}" - ${reason}<br>`;
        });
        errorMessage += '<br>Please enter only positive integers between 1 and 2147483647';
        
        // Show error in search results
        searchResults.innerHTML = `
            <div class="alert alert-danger">
                <h6><i class="fas fa-exclamation-triangle me-2"></i>Invalid Input</h6>
                <p class="mb-0">${errorMessage}</p>
            </div>
        `;
        
        // Highlight invalid elements with animation
        invalidElements.forEach(invalid => {
            highlightElement(invalid.index, 'excel-error');
        });
        
        logOperation('Number to column conversion failed - invalid numbers detected', 'danger');
        return;
    }
    
    // Store original array
    originalArrayForNumberToColumn = [...myArray];
    
    // Show Number to Column conversion visualization
    showNumberToColumnVisualization();
}

// NEW: Convert Number to Excel Column Title (Python implementation equivalent)
function numberToExcelColumn(columnNumber) {
    let result = "";
    let num = columnNumber;
    
    while (num > 0) {
        num -= 1; // Adjust for 1-based indexing
        result = String.fromCharCode('A'.charCodeAt(0) + (num % 26)) + result;
        num = Math.floor(num / 26);
    }
    
    return result;
}

// NEW: Show Number to Column Visualization
function showNumberToColumnVisualization() {
    isNumberToColumnRunning = true;
    
    const dualContainer = document.createElement('div');
    dualContainer.className = 'dual-operation-container';
    dualContainer.innerHTML = `
        <h5 class="text-center mb-3">Number to Excel Column Title Conversion</h5>
        
        <div class="array-group">
            <div class="array-label">Column Numbers</div>
            <div class="original-array-container" id="originalNumberArray"></div>
        </div>
        
        <div class="operation-arrow">
            <i class="fas fa-arrow-down"></i>
        </div>
        
        <div class="array-group">
            <div class="array-label">Excel Column Titles</div>
            <div class="transformed-array-container" id="transformedNumberArray"></div>
        </div>
        
        <div class="operation-explanation">
            <p class="mb-2"><strong>Conversion Algorithm:</strong> 
                <span class="code-snippet" style="display: inline-block; padding: 5px; margin: 0;">
                    while n > 0: n--; result = chr(65 + n % 26) + result; n //= 26
                </span>
            </p>
            <p class="mb-0" id="numberToColumnExplanation">Starting number to column conversion...</p>
        </div>
        
        <div class="algorithm-steps mt-3" id="numberToColumnStepsContainer">
            <h6 class="text-center">Conversion Steps</h6>
            <div class="steps-container" id="numberToColumnSteps"></div>
        </div>
        
        <div class="table-container mt-3">
            <table class="excel-table">
                <thead>
                    <tr>
                        <th>Input Number</th>
                        <th>Conversion Process</th>
                        <th>Excel Column</th>
                    </tr>
                </thead>
                <tbody id="numberToColumnTable">
                </tbody>
            </table>
        </div>
        
        <button class="btn btn-sm btn-outline-light mt-3" id="continueAfterNumberToColumn" style="display: none;">
            <i class="fas fa-undo me-1"></i>Return to Original Array
        </button>
    `;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(dualContainer);
    
    renderArrayInContainer(originalArrayForNumberToColumn, 'originalNumberArray');
    renderArrayInContainer([], 'transformedNumberArray');
    
    performNumberToColumnAnimation();
}

// NEW: Perform Number to Column Animation
function performNumberToColumnAnimation() {
    const originalContainer = document.getElementById('originalNumberArray');
    const transformedContainer = document.getElementById('transformedNumberArray');
    const explanation = document.getElementById('numberToColumnExplanation');
    const stepsContainer = document.getElementById('numberToColumnSteps');
    const conversionTable = document.getElementById('numberToColumnTable');
    const continueButton = document.getElementById('continueAfterNumberToColumn');
    
    const numbers = [...originalArrayForNumberToColumn].map(num => parseInt(num));
    const convertedColumns = [];
    let currentIndex = 0;
    
    function performConversionStep() {
        if (currentIndex >= numbers.length) {
            // Conversion completed
            explanation.innerHTML = `<strong>Conversion Completed!</strong> All numbers converted to Excel columns.`;
            
            stepsContainer.innerHTML += `
                <div class="algorithm-step active">
                    <strong>Final:</strong> All ${numbers.length} numbers successfully converted to Excel column titles
                </div>
            `;
            
            continueButton.style.display = 'block';
            
            // Auto-return after 10 seconds
            setTimeout(() => {
                returnToOriginalAfterNumberToColumn();
            }, 10000);
            
            continueButton.addEventListener('click', returnToOriginalAfterNumberToColumn);
            
            return;
        }
        
        const currentNumber = numbers[currentIndex];
        explanation.innerHTML = `Converting number ${currentNumber} to Excel column...`;
        
        // Highlight current element being converted
        const originalElements = originalContainer.querySelectorAll('.array-element');
        const currentElement = originalElements[currentIndex].querySelector('.element-value');
        currentElement.classList.add('number-to-column');
        
        stepsContainer.innerHTML += `
            <div class="algorithm-step active">
                <strong>Step ${currentIndex + 1}:</strong> Converting number ${currentNumber} to Excel column
            </div>
        `;
        
        // Add to conversion table
        const tableRow = document.createElement('tr');
        tableRow.innerHTML = `
            <td><strong>${currentNumber}</strong></td>
            <td>
                <div class="conversion-process" id="process-${currentIndex}">
                    <div class="process-steps" id="steps-${currentIndex}"></div>
                </div>
            </td>
            <td><strong id="result-${currentIndex}">Calculating...</strong></td>
        `;
        conversionTable.appendChild(tableRow);
        
        const processElement = document.getElementById(`process-${currentIndex}`);
        const stepsElement = document.getElementById(`steps-${currentIndex}`);
        const resultElement = document.getElementById(`result-${currentIndex}`);
        
        // Animate the conversion process
        animateNumberToColumnConversion(currentNumber, processElement, stepsElement, resultElement, currentIndex, () => {
            // Conversion complete for this number
            const finalResult = numberToExcelColumn(currentNumber);
            convertedColumns.push(finalResult);
            
            // Update transformed array
            renderArrayInContainer(convertedColumns, 'transformedNumberArray');
            
            // Highlight the converted column
            const transformedElements = transformedContainer.querySelectorAll('.array-element');
            if (transformedElements[currentIndex]) {
                transformedElements[currentIndex].querySelector('.element-value').classList.add('column-title-result');
            }
            
            // Remove highlight from original element
            currentElement.classList.remove('number-to-column');
            
            // Move to next number
            currentIndex++;
            setTimeout(performConversionStep, 1000);
        });
    }
    
    // Start conversion process
    performConversionStep();
}

// NEW: Animate Number to Column Conversion Process
function animateNumberToColumnConversion(number, processElement, stepsElement, resultElement, index, callback) {
    let currentNumber = number;
    let steps = [];
    let result = "";
    let stepCount = 0;
    
    function performConversionStep() {
        if (currentNumber <= 0) {
            // Conversion completed
            resultElement.innerHTML = `<span class="text-success">"${result}"</span>`;
            resultElement.classList.add('text-success', 'fw-bold');
            
            // Show final summary
            stepsElement.innerHTML += `
                <div class="number-to-column-step active">
                    <strong>Final Result:</strong> "${result}"<br>
                    <em>Conversion completed in ${stepCount} steps</em>
                </div>
            `;
            
            callback();
            return;
        }
        
        stepCount++;
        const stepNumber = currentNumber;
        
        // Perform the conversion step
        currentNumber -= 1; // Adjust for 1-based indexing
        const remainder = currentNumber % 26;
        const char = String.fromCharCode('A'.charCodeAt(0) + remainder);
        result = char + result;
        const quotient = Math.floor(currentNumber / 26);
        
        steps.push({
            step: stepCount,
            currentNumber: stepNumber,
            adjustedNumber: currentNumber + 1,
            remainder: remainder,
            character: char,
            newResult: result,
            quotient: quotient
        });
        
        // Display current step
        const step = steps[steps.length - 1];
        const stepHTML = `
            <div class="number-to-column-step ${quotient <= 0 ? 'active' : ''}">
                <strong>Step ${step.step}:</strong><br>
                 Current number: ${step.currentNumber}<br>
                 Subtract 1: ${step.currentNumber} - 1 = ${step.adjustedNumber}<br>
                 Calculate remainder: ${step.adjustedNumber} % 26 = ${step.remainder}<br>
                 Convert to letter: ${step.remainder}  '${step.character}'<br>
                 Build result: "${step.newResult}"<br>
                 New number: ${step.adjustedNumber} // 26 = ${step.quotient}
            </div>
        `;
        
        stepsElement.innerHTML = stepHTML;
        
        // Update process visualization
        processElement.innerHTML = `
            <div class="process-step">
                <div class="bg-warning text-dark p-2 rounded">${step.currentNumber}</div>
                <div class="process-arrow"><i class="fas fa-arrow-right"></i></div>
                <div class="bg-info text-white p-2 rounded">${step.adjustedNumber}</div>
                <div class="process-arrow"><i class="fas fa-arrow-right"></i></div>
                <div class="bg-primary text-white p-2 rounded">${step.remainder}  '${step.character}'</div>
                <div class="process-arrow"><i class="fas fa-arrow-right"></i></div>
                <div class="bg-success text-white p-2 rounded">"${step.newResult}"</div>
            </div>
        `;
        
        // Update current number for next iteration
        currentNumber = quotient;
        
        // Update result with current progress
        resultElement.innerHTML = `<span class="text-warning">"${result}"</span>`;
        resultElement.classList.add('pulse');
        
        setTimeout(() => {
            resultElement.classList.remove('pulse');
            performConversionStep();
        }, 2000);
    }
    
    // Start conversion process
    performConversionStep();
}

// NEW: Return to Original after Number to Column Conversion
function returnToOriginalAfterNumberToColumn() {
    // Reset to original array
    myArray = [...originalArrayForNumberToColumn];
    originalArrayForNumberToColumn = [];
    
    // Remove visualization and return to normal view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    // Reset state
    isNumberToColumnRunning = false;
    
    logOperation('Number to column conversion completed - returned to original array', 'info');
    showNotification('Returned to original array after number to column conversion', 'success');
}
// Update the renderArrayInContainer function to handle different data types better
function renderArrayInContainer(array, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    
    if (array.length === 0) {
        container.innerHTML = `
            <div class="array-empty-state">
                <i class="fas fa-layer-group"></i>
                <h6>Empty</h6>
            </div>
        `;
        return;
    }
    
    array.forEach((value, index) => {
        const arrayElement = document.createElement('div');
        arrayElement.className = 'array-element';
        
        // Format the value for display
        let displayValue = value;
        if (typeof value === 'string' && value.length > 8) {
            displayValue = value.substring(0, 8) + '...';
        }
        
        arrayElement.innerHTML = `
            <div class="element-value">${displayValue}</div>
            <div class="element-index">[${index}]</div>
        `;
        container.appendChild(arrayElement);
    });
}
// Stack Implementation Functions
function handleImplementStack() {
    stackImplementationGroup.style.display = 'block';
    stackSizeInput.focus();
    logOperation('Started stack implementation setup', 'info');
}

function handleCreateStack() {
    const size = parseInt(stackSizeInput.value);
    
    if (isNaN(size) || size < 1 || size > 50) {
        showNotification('Please enter a valid stack size between 1 and 50', 'danger');
        stackSizeInput.focus();
        return;
    }
    
    // Store original array
    originalArrayForStack = [...myArray];
    
    // Create stack
    stack = {
        arr: new Array(size),
        top: -1,
        capacity: size
    };
    
    // Show stack operations
    stackOperations.style.display = 'block';
    stackInfo.style.display = 'flex';
    stackExplanation.style.display = 'block';
    
    // Update stack info
    updateStackInfo();
    
    // Render stack visualization
    renderStack();
    
    logOperation(`Created stack with capacity ${size}`, 'success');
    showNotification(`Stack created with capacity ${size}`, 'success');
}

function handlePush() {
    if (!stack) {
        showNotification('Please create a stack first', 'warning');
        return;
    }
    
    const value = pushValue.value.trim();
    if (value === '') {
        showNotification('Please enter a value to push', 'warning');
        pushValue.focus();
        return;
    }
    
    if (isStackOperationRunning) {
        showNotification('A stack operation is already in progress', 'warning');
        return;
    }
    
    performPushOperation(value);
}

function handlePop() {
    if (!stack) {
        showNotification('Please create a stack first', 'warning');
        return;
    }
    
    const count = parseInt(popCount.value) || 1;
    
    if (count < 1) {
        showNotification('Please enter a valid number of pops', 'warning');
        popCount.focus();
        return;
    }
    
    if (isStackOperationRunning) {
        showNotification('A stack operation is already in progress', 'warning');
        return;
    }
    
    performPopOperation(count);
}

function handlePeek() {
    if (!stack) {
        showNotification('Please create a stack first', 'warning');
        return;
    }
    
    if (isStackOperationRunning) {
        showNotification('A stack operation is already in progress', 'warning');
        return;
    }
    
    performPeekOperation();
}
function handleIsFull() {
    if (!stack) {
        showNotification('Please create a stack first', 'warning');
        return;
    }
    
    const isFull = stack.top === stack.capacity - 1;
    const message = isFull ? 'Stack is FULL' : 'Stack is NOT full';
    const type = isFull ? 'warning' : 'info';
    
    showNotification(message, type);
    logOperation(`Checked if stack is full: ${message}`, type);
    
    // Visual feedback
    if (isFull) {
        const stackContainer = document.getElementById('arrayContainer');
        stackContainer.classList.add('shake');
        setTimeout(() => {
            stackContainer.classList.remove('shake');
        }, 500);
    }
}

function handleIsEmpty() {
    if (!stack) {
        showNotification('Please create a stack first', 'warning');
        return;
    }
    
    const isEmpty = stack.top === -1;
    const message = isEmpty ? 'Stack is EMPTY' : 'Stack is NOT empty';
    const type = isEmpty ? 'warning' : 'info';
    
    showNotification(message, type);
    logOperation(`Checked if stack is empty: ${message}`, type);
}
function handleResetStack() {
    if (!stack && !isStackOperationRunning) {
        showNotification('No stack to reset', 'info');
        return;
    }
    
    // Stop any running animation first
    if (isStackOperationRunning) {
        stopStackAnimation();
    }
    
    // Reset to original array
    myArray = [...originalArrayForStack];
    stack = null;
    isStackOperationRunning = false;
    
    // Hide stack interface
    stackOperations.style.display = 'none';
    stackInfo.style.display = 'none';
    stackExplanation.style.display = 'none';
    stackImplementationGroup.style.display = 'none';
    
    // Clear inputs
    stackSizeInput.value = '';
    pushValue.value = '';
    popCount.value = '1';
    
    // Return to normal array view
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    renderArray();
    updateStats();
    
    logOperation('Stack implementation reset (Shift+R)', 'info');
    showNotification('Stack reset to original position', 'success');
}

function performPushOperation(value) {
    isStackOperationRunning = true;
    
    // Auto-scroll to animation
    setTimeout(() => {
        scrollToAnimation();
    }, 100);
    
    if (stack.top === stack.capacity - 1) {
        showNotification('Stack Overflow! Cannot push to full stack', 'danger');
        logOperation(`Push operation failed: Stack Overflow (tried to push "${value}")`, 'danger');
        isStackOperationRunning = false;
        
        // Scroll back to controls after error
        setTimeout(() => {
            scrollToStackControls();
        }, 500);
        return;
    }
    
    // Create operation log
    const operationLog = document.createElement('div');
    operationLog.className = 'stack-operation-log';
    operationLog.innerHTML = '<h6>Push Operation Steps</h6>';
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(operationLog);
    
    renderStack();
    
    let step = 0;
    
    function executePushStep() {
        if (isStackOperationRunning === false) return;
        
        switch (step) {
            case 0:
                addOperationStep(operationLog, `Step 1: Check if stack is full (top = ${stack.top}, capacity = ${stack.capacity})`, 'info');
                setTimeout(executePushStep, 1500);
                break;
                
            case 1:
                addOperationStep(operationLog, `Step 2: Stack is not full, proceeding with push operation`, 'success');
                setTimeout(executePushStep, 1500);
                break;
                
            case 2:
                addOperationStep(operationLog, `Step 3: Increment top pointer from ${stack.top} to ${stack.top + 1}`, 'info');
                highlightTopPointer();
                setTimeout(executePushStep, 1500);
                break;
                
            case 3:
                stack.top++;
                updateStackInfo();
                addOperationStep(operationLog, `Step 4: Insert value "${value}" at position ${stack.top}`, 'info');
                setTimeout(executePushStep, 1500);
                break;
                
            case 4:
                stack.arr[stack.top] = value;
                renderStack();
                addOperationStep(operationLog, `Step 5: Value "${value}" successfully pushed to stack`, 'success');
                
                // Highlight the pushed element
                const stackElements = document.querySelectorAll('.stack-element');
                if (stackElements[stack.top]) {
                    const pushedElement = stackElements[stack.top];
                    pushedElement.classList.add('push-animation', 'top-element');
                }
                
                setTimeout(() => {
                    pushValue.value = '';
                    isStackOperationRunning = false;
                    logOperation(`Pushed "${value}" to stack`, 'success');
                    showNotification(`"${value}" pushed to stack successfully`, 'success');
                    
                    // Auto-scroll back to stack controls after completion
                    setTimeout(() => {
                        scrollToStackControls();
                    }, 500);
                }, 2000);
                return;
        }
        
        step++;
    }
    
    executePushStep();
}
function performPopOperation(count) {
    isStackOperationRunning = true;
    
    // Auto-scroll to animation
    setTimeout(() => {
        scrollToAnimation();
    }, 100);
    
    if (stack.top === -1) {
        showNotification('Stack Underflow! Cannot pop from empty stack', 'danger');
        logOperation(`Pop operation failed: Stack Underflow (tried to pop ${count} elements)`, 'danger');
        isStackOperationRunning = false;
        
        // Scroll back to controls after error
        setTimeout(() => {
            scrollToStackControls();
        }, 500);
        return;
    }
    
    if (count > stack.top + 1) {
        showNotification(`Cannot pop ${count} elements. Only ${stack.top + 1} elements in stack`, 'danger');
        logOperation(`Pop operation failed: Insufficient elements`, 'danger');
        isStackOperationRunning = false;
        
        // Scroll back to controls after error
        setTimeout(() => {
            scrollToStackControls();
        }, 500);
        return;
    }
    
    const operationLog = document.createElement('div');
    operationLog.className = 'stack-operation-log';
    operationLog.innerHTML = `<h6>Pop Operation Steps (Popping ${count} element${count > 1 ? 's' : ''})</h6>`;
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(operationLog);
    
    renderStack();
    
    let step = 0;
    let poppedCount = 0;
    const poppedValues = [];
    
    function executePopStep() {
        if (isStackOperationRunning === false) return;
        
        if (poppedCount >= count || stack.top === -1) {
            // Operation completed
            addOperationStep(operationLog, `Pop operation completed. Popped values: [${poppedValues.join(', ')}]`, 'success');
            
            setTimeout(() => {
                popCount.value = '1';
                isStackOperationRunning = false;
                logOperation(`Popped ${count} element${count > 1 ? 's' : ''} from stack: [${poppedValues.join(', ')}]`, 'success');
                showNotification(`Popped ${count} element${count > 1 ? 's' : ''} successfully`, 'success');
                
                // Auto-scroll back to stack controls after completion
                setTimeout(() => {
                    scrollToStackControls();
                }, 500);
            }, 2000);
            return;
        }
        
        switch (step % 5) {
            case 0:
                addOperationStep(operationLog, `Step ${poppedCount + 1}.1: Check if stack is empty (top = ${stack.top})`, 'info');
                setTimeout(executePopStep, 1500);
                break;
                
            case 1:
                addOperationStep(operationLog, `Step ${poppedCount + 1}.2: Stack is not empty, proceeding with pop`, 'success');
                setTimeout(executePopStep, 1500);
                break;
                
            case 2:
                const valueToPop = stack.arr[stack.top];
                addOperationStep(operationLog, `Step ${poppedCount + 1}.3: Access top element "${valueToPop}" at position ${stack.top}`, 'info');
                
                // Highlight the element to be popped
                const stackElements = document.querySelectorAll('.stack-element');
                if (stackElements[stack.top]) {
                    stackElements[stack.top].classList.add('pop-animation');
                }
                
                setTimeout(executePopStep, 1500);
                break;
                
            case 3:
                addOperationStep(operationLog, `Step ${poppedCount + 1}.4: Decrement top pointer from ${stack.top} to ${stack.top - 1}`, 'info');
                setTimeout(executePopStep, 1500);
                break;
                
            case 4:
                const poppedValue = stack.arr[stack.top];
                stack.arr[stack.top] = undefined;
                stack.top--;
                poppedValues.push(poppedValue);
                poppedCount++;
                
                updateStackInfo();
                renderStack();
                addOperationStep(operationLog, `Step ${poppedCount + 1}.5: Value "${poppedValue}" popped successfully`, 'success');
                
                setTimeout(executePopStep, 1500);
                break;
        }
        
        step++;
    }
    
    executePopStep();
}
function performPeekOperation() {
    isStackOperationRunning = true;
    
    // Auto-scroll to animation
    setTimeout(() => {
        scrollToAnimation();
    }, 100);
    
    if (stack.top === -1) {
        showNotification('Stack is empty! Cannot peek', 'danger');
        logOperation('Peek operation failed: Stack is empty', 'danger');
        isStackOperationRunning = false;
        
        // Scroll back to controls after error
        setTimeout(() => {
            scrollToStackControls();
        }, 500);
        return;
    }
    
    const operationLog = document.createElement('div');
    operationLog.className = 'stack-operation-log';
    operationLog.innerHTML = '<h6>Peek Operation Steps</h6>';
    
    const mainContainer = document.getElementById('arrayContainer');
    mainContainer.innerHTML = '';
    mainContainer.appendChild(operationLog);
    
    renderStack();
    
    let step = 0;
    
    function executePeekStep() {
        if (isStackOperationRunning === false) return;
        
        switch (step) {
            case 0:
                addOperationStep(operationLog, `Step 1: Check if stack is empty (top = ${stack.top})`, 'info');
                setTimeout(executePeekStep, 1500);
                break;
                
            case 1:
                addOperationStep(operationLog, 'Step 2: Stack is not empty, proceeding with peek', 'success');
                setTimeout(executePeekStep, 1500);
                break;
                
            case 2:
                const topValue = stack.arr[stack.top];
                addOperationStep(operationLog, `Step 3: Access top element at position ${stack.top}`, 'info');
                
                // Highlight the top element
                const stackElements = document.querySelectorAll('.stack-element');
                if (stackElements[stack.top]) {
                    stackElements[stack.top].classList.add('peek-highlight');
                }
                
                setTimeout(executePeekStep, 1500);
                break;
                
            case 3:
                addOperationStep(operationLog, `Step 4: Top element is "${stack.arr[stack.top]}"`, 'success');
                
                setTimeout(() => {
                    isStackOperationRunning = false;
                    logOperation(`Peek operation: Top element is "${stack.arr[stack.top]}"`, 'success');
                    showNotification(`Top element is "${stack.arr[stack.top]}"`, 'success');
                    
                    // Remove highlight after delay
                    const stackElements = document.querySelectorAll('.stack-element');
                    if (stackElements[stack.top]) {
                        setTimeout(() => {
                            stackElements[stack.top].classList.remove('peek-highlight');
                        }, 1000);
                    }
                    
                    // Auto-scroll back to stack controls after completion
                    setTimeout(() => {
                        scrollToStackControls();
                    }, 500);
                }, 2000);
                return;
        }
        
        step++;
    }
    
    executePeekStep();
}
// Stack Utility Functions
function renderStack() {
    const mainContainer = document.getElementById('arrayContainer');
    const existingLog = mainContainer.querySelector('.stack-operation-log');
    
    if (existingLog) {
        mainContainer.innerHTML = '';
        mainContainer.appendChild(existingLog);
    }
    
    const stackContainer = document.createElement('div');
    stackContainer.className = 'stack-container';
    
    // Create stack elements
    for (let i = stack.capacity - 1; i >= 0; i--) {
        const stackElement = document.createElement('div');
        stackElement.className = 'stack-element';
        
        if (i <= stack.top) {
            stackElement.textContent = stack.arr[i];
            if (i === stack.top) {
                stackElement.classList.add('top-element');
            }
        } else {
            stackElement.textContent = '';
            stackElement.style.opacity = '0.5';
        }
        
        stackContainer.appendChild(stackElement);
    }
    
    // Add top pointer
    const pointer = document.createElement('div');
    pointer.className = 'stack-pointer';
    pointer.textContent = `TOP  ${stack.top}`;
    stackContainer.appendChild(pointer);
    
    mainContainer.appendChild(stackContainer);
    
    // Add comparison section
    const comparisonSection = document.createElement('div');
    comparisonSection.className = 'stack-comparison';
    comparisonSection.innerHTML = `
        <div class="comparison-section">
            <div class="comparison-title">Array Representation</div>
            <div class="code-snippet">
                [${stack.arr.map((val, idx) => 
                    idx <= stack.top ? val : ''
                ).join(', ')}]
            </div>
            <div class="mt-2">
                <strong>Top Index:</strong> ${stack.top}<br>
                <strong>Capacity:</strong> ${stack.capacity}
            </div>
        </div>
        <div class="comparison-section">
            <div class="comparison-title">Stack Operations</div>
            <div class="code-snippet">
                push(x): O(1) - Add element<br>
                pop(): O(1) - Remove element<br>
                peek(): O(1) - View top<br>
                isEmpty(): O(1)<br>
                isFull(): O(1)
            </div>
        </div>
    `;
    
    mainContainer.appendChild(comparisonSection);
}

function updateStackInfo() {
    stackSizeValue.textContent = stack.capacity;
    stackTopValue.textContent = stack.top;
    stackStatus.textContent = stack.top === -1 ? 'Empty' : 
                             stack.top === stack.capacity - 1 ? 'Full' : 'Available';
}

function highlightTopPointer() {
    const pointers = document.querySelectorAll('.stack-pointer');
    pointers.forEach(pointer => {
        pointer.classList.add('pulse');
        setTimeout(() => {
            pointer.classList.remove('pulse');
        }, 1000);
    });
}

function addOperationStep(container, message, type) {
    const step = document.createElement('div');
    step.className = `stack-operation-step ${type}`;
    step.textContent = message;
    container.appendChild(step);
    container.scrollTop = container.scrollHeight;
}

function stopStackAnimation() {
    isStackOperationRunning = false;
    if (stackAnimationTimeout) {
        clearTimeout(stackAnimationTimeout);
    }
    showNotification('Stack animation stopped', 'warning');
    logOperation('Stack animation stopped (Shift+X)', 'warning');
    
    // Re-render stack in current state
    if (stack) {
        renderStack();
    }
}
// Add these utility functions for auto-scrolling
function scrollToAnimation() {
    const arrayContainer = document.getElementById('arrayContainer');
    if (arrayContainer) {
        arrayContainer.scrollIntoView({ 
            behavior: 'smooth', 
            block: 'center'
        });
    }
}

function scrollToStackControls() {
    const stackControls = document.getElementById('stackOperations');
    if (stackControls) {
        stackControls.scrollIntoView({ 
            behavior: 'smooth', 
            block: 'center'
        });
    }
}
// Render the array visually
// Update the renderArray function
function renderArray() {
    if (myArray.length === 0) {
        arrayContainer.innerHTML = `
            <div class="array-empty-state">
                <i class="fas fa-layer-group"></i>
                <h4>Array is Empty</h4>
                <p>Add some elements to get started!</p>
            </div>
        `;
        return;
    }
    
    arrayContainer.innerHTML = '';
    
    // Add transformation label if applicable
    if (currentTransformationType) {
        const label = document.createElement('div');
        label.className = 'w-100 text-center mb-3';
        label.innerHTML = `
            <span class="badge bg-success">
                <i class="fas fa-calculator me-1"></i>
                ${currentTransformationType === 'cumulative' ? 'Cumulative Sum Array' : 'Prefix Sum Array'}
            </span>
        `;
        arrayContainer.appendChild(label);
    }
    
    myArray.forEach((value, index) => {
        const element = document.createElement('div');
        element.className = 'array-element slide-in';
        element.style.animationDelay = `${index * 0.1}s`;
        
        const valueDiv = document.createElement('div');
        valueDiv.className = 'element-value';
        valueDiv.textContent = value;
        
        const indexDiv = document.createElement('div');
        indexDiv.className = 'element-index';
        indexDiv.textContent = `[${index}]`;
        
        element.appendChild(valueDiv);
        element.appendChild(indexDiv);
        
        arrayContainer.appendChild(element);
    });
    
    // Update memory address display
    updateMemoryAddress();

}
        
        // Highlight an element with animation
        function highlightElement(index, operation, callback = null) {
            const elements = document.querySelectorAll('.array-element');
            if (index < 0 || index >= elements.length) return;
            
            const valueDiv = elements[index].querySelector('.element-value');
            valueDiv.classList.add(operation);
            
            // Different animations for different operations
            switch(operation) {
                case 'create':
                    valueDiv.classList.add('bounce', 'color-change');
                    break;
                case 'read':
                    valueDiv.classList.add('pulse');
                    break;
                case 'update':
                    valueDiv.classList.add('flip');
                    break;
                case 'delete':
                    valueDiv.classList.add('shake');
                    break;
                case 'search':
                    valueDiv.classList.add('pulse', 'color-change');
                    break;
            }
            
            // Reset classes after animation
            setTimeout(() => {
                valueDiv.classList.remove(operation, 'bounce', 'pulse', 'flip', 'shake', 'color-change');
                if (callback) callback();
            }, 1000);
        }
        
        // Update statistics
        // Update statistics
function updateStats() {
    arrayLength.textContent = myArray.length;
    firstElement.textContent = myArray.length > 0 ? myArray[0] : '-';
    lastElement.textContent = myArray.length > 0 ? myArray[myArray.length - 1] : '-';
    sumElements.textContent = calculateSum();
    productElements.textContent = calculateProduct();
    totalOperations.textContent = ++operationCount;
    // Calculate mode
    calculateMode();
}
// NEW: Calculate Mode Function
function calculateMode() {
    if (myArray.length === 0) {
        modeElements.textContent = '-';
        return;
    }
    
    // Count frequency of each element
    const frequencyMap = {};
    let maxFrequency = 0;
    let modes = [];
    
    // Count occurrences
    myArray.forEach(item => {
        frequencyMap[item] = (frequencyMap[item] || 0) + 1;
        if (frequencyMap[item] > maxFrequency) {
            maxFrequency = frequencyMap[item];
        }
    });
    
    // Find all elements with max frequency
    for (const [key, value] of Object.entries(frequencyMap)) {
        if (value === maxFrequency) {
            modes.push(key);
        }
    }
    
    // Display mode(s)
    if (modes.length === 1) {
        modeElements.textContent = `${modes[0]} (${maxFrequency} times)`;
    } else if (modes.length > 1) {
        modeElements.textContent = `${modes.slice(0, 3).join(', ')}${modes.length > 3 ? '...' : ''} (${maxFrequency} times each)`;
    } else {
        modeElements.textContent = 'No mode';
    }
    
    // Optional: Add special styling for multiple modes
    if (modes.length > 1) {
        modeElements.style.color = 'var(--warning-color)';
        modeElements.title = `Multiple modes: ${modes.join(', ')}`;
    } else {
        modeElements.style.color = '';
        modeElements.title = '';
    }
}
        
        // Log operations
        function logOperation(message, type) {
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            
            operationLog.prepend(logEntry);
            
            // Limit log entries to 10
            if (operationLog.children.length > 10) {
                operationLog.removeChild(operationLog.lastChild);
            }
        }
        
        // Show notification
        function showNotification(message, type) {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
            notification.style.top = '20px';
            notification.style.right = '20px';
            notification.style.zIndex = '1050';
            notification.style.minWidth = '300px';
            notification.innerHTML = `
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            
            document.body.appendChild(notification);
            
            // Auto remove after 3 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 3000);
        }
      // Helper function for icons (add if not exists)
function getIconForType(type) {
    switch(type) {
        case 'success': return 'check-circle';
        case 'warning': return 'exclamation-triangle';
        case 'danger': return 'times-circle';
        case 'info': 
        default: return 'info-circle';
    }
}
  
    // In the sample data initialization, update:
setTimeout(() => {
    myArray = [1,2,3,4];
    originalArray = []; // Reset original array
    isSubarray = false; // Reset subarray flag
    renderArray();
    updateStats();
    logOperation('Array initialized with sample data', 'info');
}, 1000);
    </script>
</body>
</html>